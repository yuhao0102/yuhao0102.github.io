<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Leetcode401. Binary WatchA binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the l">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode401 - 500">
<meta property="og:url" content="http://yoursite.com/2020/08/25/Leetcode401_500/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Leetcode401. Binary WatchA binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the l">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/trap1-3d.jpg">
<meta property="og:image" content="http://yoursite.com/img/trap2-3d.jpg">
<meta property="og:image" content="http://yoursite.com/img/20210704132900407_1.jpg">
<meta property="og:image" content="http://yoursite.com/img/20210704132900407_2.jpg">
<meta property="og:image" content="http://yoursite.com/img/20210704132900407_3.jpg">
<meta property="og:image" content="http://yoursite.com/img/20210704132900407_4.jpg">
<meta property="og:image" content="http://yoursite.com/img/20210704132900407_5.jpg">
<meta property="og:image" content="http://yoursite.com/img/20210704132900407_6.jpg">
<meta property="og:image" content="http://yoursite.com/img/20210704132900407_7.jpg">
<meta property="og:image" content="http://yoursite.com/img/20210704132900407_8.jpg">
<meta property="og:image" content="http://yoursite.com/img/waterflow-grid.jpg">
<meta property="og:image" content="http://yoursite.com/img/e2tree.png">
<meta property="og:image" content="http://yoursite.com/img/20210704132900multilevellinkedlist.png">
<meta property="og:image" content="http://yoursite.com/img/20210704132900multilevellinkedlistflattened.png">
<meta property="og:image" content="http://yoursite.com/img/20210707103800.jpg">
<meta property="og:image" content="http://yoursite.com/img/20200617105700.png">
<meta property="og:image" content="http://yoursite.com/img/20210710152100.jpg">
<meta property="article:published_time" content="2020-08-25T02:17:13.000Z">
<meta property="article:modified_time" content="2022-12-26T08:02:33.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="Leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/trap1-3d.jpg">

<link rel="canonical" href="http://yoursite.com/2020/08/25/Leetcode401_500/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>Leetcode401 - 500 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/25/Leetcode401_500/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Leetcode401 - 500
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-25 10:17:13" itemprop="dateCreated datePublished" datetime="2020-08-25T10:17:13+08:00">2020-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-26 16:02:33" itemprop="dateModified" datetime="2022-12-26T16:02:33+08:00">2022-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Leetcode401-Binary-Watch"><a href="#Leetcode401-Binary-Watch" class="headerlink" title="Leetcode401. Binary Watch"></a>Leetcode401. Binary Watch</h1><p>A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.</p>
<p>Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;]</span><br></pre></td></tr></table></figure><br>Note:</p>
<ul>
<li>The order of output does not matter.</li>
<li>The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”.</li>
<li>The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”.</li>
</ul>
<p>首先先明白二进制手表的含义，把1，2，4，8转化为四位的二进制就是0001， 0010， 0100，1000， 9点时亮1和8，是1001。分钟数也是同理。<br>其次表示小时的数值只有0-11，表示分钟的数值只有0-59。先分别对小时跟分钟的数值进行预处理，按照包含而二进制中包含1的个数分开保存小时数值的字符串跟分钟数值的字符串。</p>
<p>用bitset可以方便地记下来每个数字有几个二进制1，这样可以简单地做出来。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i ++) &#123;</span><br><span class="line">            <span class="function">bitset&lt;4&gt; <span class="title">h</span><span class="params">(i)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">60</span>; j ++) &#123;</span><br><span class="line">                <span class="function">bitset&lt;6&gt; <span class="title">m</span><span class="params">(j)</span></span>;</span><br><span class="line">                <span class="keyword">if</span>(h.<span class="built_in">count</span>() + m.<span class="built_in">count</span>() == num)</span><br><span class="line">                    res.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(i) + (j &lt; <span class="number">10</span>? <span class="string">&quot;:0&quot;</span>: <span class="string">&quot;:&quot;</span>) + <span class="built_in">to_string</span>(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>基本还是一道DFS的题目，分别在小时和分钟上做DFS，给定几个灯亮，然后把这些亮的灯枚举分给小时和分钟．需要注意的是剪枝，即小时必须小于12，分钟小于60。然后将小时和分钟组合即可．还有一个需要注意的是如果分钟只有1位数，还要补0.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> len, <span class="type">int</span> k, <span class="type">int</span> curIndex, <span class="type">int</span> val, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span> &amp;&amp; len==<span class="number">4</span> &amp;&amp; val &lt; <span class="number">12</span>) vec.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span> &amp;&amp; len==<span class="number">6</span> &amp;&amp; val &lt; <span class="number">60</span>) vec.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(curIndex == len || k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(len, k, curIndex<span class="number">+1</span>, val, vec);</span><br><span class="line">        val += <span class="built_in">pow</span>(<span class="number">2</span>, curIndex), k--, curIndex++;</span><br><span class="line">        <span class="built_in">DFS</span>(len, k, curIndex, val, vec);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">0</span>, num<span class="number">-6</span>); i &lt;= <span class="built_in">min</span>(<span class="number">4</span>, num); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec1, vec2;</span><br><span class="line">            <span class="built_in">DFS</span>(<span class="number">4</span>, i, <span class="number">0</span>, <span class="number">0</span>, vec1), <span class="built_in">DFS</span>(<span class="number">6</span>, num-i, <span class="number">0</span>, <span class="number">0</span>, vec2);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> val1: vec1)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> val2: vec2) </span><br><span class="line">                &#123;</span><br><span class="line">                    string str = (<span class="built_in">to_string</span>(val2).<span class="built_in">size</span>()==<span class="number">1</span>?<span class="string">&quot;0&quot;</span>:<span class="string">&quot;&quot;</span>) + <span class="built_in">to_string</span>(val2);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(val1)+<span class="string">&quot;:&quot;</span>+ str);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode402-Remove-K-Digits"><a href="#Leetcode402-Remove-K-Digits" class="headerlink" title="Leetcode402. Remove K Digits"></a>Leetcode402. Remove K Digits</h1><p>Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: num = &quot;1432219&quot;, k = 3</span><br><span class="line">Output: &quot;1219&quot;</span><br><span class="line">Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: num = &quot;10200&quot;, k = 1</span><br><span class="line">Output: &quot;200&quot;</span><br><span class="line">Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: num = &quot;10&quot;, k = 2</span><br><span class="line">Output: &quot;0&quot;</span><br><span class="line">Explanation: Remove all the digits from the number and it is left with nothing which is 0.</span><br></pre></td></tr></table></figure></p>
<p>这道题让我们将给定的数字去掉k位，要使得留下来的数字最小。</p>
<p>首先来考虑，若数字是递增的话，比如 1234，那么肯定是要从最后面移除最大的数字。若是乱序的时候，比如 1324，若只移除一个数字，移除谁呢？这个例子比较简单，我们一眼可以看出是移除3，变成 124 是最小。这里我们维护一个递增栈，只要发现当前的数字小于栈顶元素的话，就将栈顶元素移除，比如点那个遍历到2的时候，栈里面有1和3，此时2小于栈顶元素3，那么将3移除即可。为何一定要移除栈顶元素呢，后面说不定有更大的数字呢？这是因为此时栈顶元素在高位上，就算后面的数字再大，也是在低位上，我们只有将高位上的数字尽可能的变小，才能使整个剩下的数字尽可能的小。</p>
<p>我们开始遍历给定数字 num 的每一位，对于当前遍历到的数字c，进行如下 while 循环，如果 res 不为空，且k大于0，且 res 的最后一位大于c，那么应该将 res 的最后一位移去，且k自减1。当跳出 while 循环后，我们将c加入 res 中，最后将 res 的大小重设为 n-k。根据题目中的描述，可能会出现 “0200” 这样不符合要求的情况，所以我们用一个 while 循环来去掉前面的所有0，然后返回时判断是否为空，为空则返回 “0”。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeKdigits</span><span class="params">(string num, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> len = num.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; res.<span class="built_in">length</span>() &gt; <span class="number">0</span> &amp;&amp; num[i] &lt; res.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">                k --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res.<span class="built_in">length</span>() &gt; <span class="number">0</span> || num[i] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                res += num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(res.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; k--)</span><br><span class="line">            res.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">empty</span>() ? <span class="string">&quot;0&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode403-Frog-Jump"><a href="#Leetcode403-Frog-Jump" class="headerlink" title="Leetcode403. Frog Jump"></a>Leetcode403. Frog Jump</h1><p>A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.</p>
<p>Given a list of stones’ positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.</p>
<p>If the frog’s last jump was  k  units, then its next jump must be either  k  - 1,  k , or  k  + 1 units. Note that the frog can only jump in the forward direction.</p>
<p>Note:</p>
<ul>
<li>The number of stones is ≥ 2 and is &lt; 1,100.</li>
<li>Each stone’s position will be a non-negative integer &lt; 231.</li>
<li>The first stone’s position is always 0.</li>
</ul>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[0,1,3,5,6,8,12,17]</span><br><span class="line"></span><br><span class="line">There are a total of 8 stones.</span><br><span class="line">The first stone at the 0th unit, second stone at the 1st unit,</span><br><span class="line">third stone at the 3rd unit, and so on...</span><br><span class="line">The last stone at the 17th unit.</span><br><span class="line"></span><br><span class="line">Return true. The frog can jump to the last stone by jumping </span><br><span class="line">1 unit to the 2nd stone, then 2 units to the 3rd stone, then </span><br><span class="line">2 units to the 4th stone, then 3 units to the 6th stone, </span><br><span class="line">4 units to the 7th stone, and 5 units to the 8th stone.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0,1,2,3,4,8,9,11]</span><br><span class="line"></span><br><span class="line">Return false. There is no way to jump to the last stone as </span><br><span class="line">the gap between the 5th and 6th stone is too large.</span><br></pre></td></tr></table></figure></p>
<p>题目中说青蛙如果上一次跳了k距离，那么下一次只能跳 k-1, k, 或 k+1 的距离，那么青蛙跳到某个石头上可能有多种跳法，由于这道题只是让判断青蛙是否能跳到最后一个石头上，并没有让返回所有的路径，这样就降低了一些难度。我们可以用递归来做，这里维护一个 HashMap，建立青蛙在 pos 位置和拥有 jump 跳跃能力时是否能跳到对岸。为了能用一个变量同时表示 pos 和 jump，可以将jump左移很多位并或上 pos，由于题目中对于位置大小有限制，所以不会产生冲突。首先判断 pos 是否已经到最后一个石头了，是的话直接返回 true；然后看当前这种情况是否已经出现在 HashMap 中，是的话直接从 HashMap 中取结果。如果没有，就遍历余下的所有石头，对于遍历到的石头，计算到当前石头的距离dist，如果距离小于 jump-1，接着遍历下一块石头；如果 dist 大于 jump+1，说明无法跳到下一块石头，m[key] 赋值为 false，并返回 false；如果在青蛙能跳到的范围中，调用递归函数，以新位置i为 pos，距离 dist 为 jump，如果返回 true 了，给 m[key] 赋值为 true，并返回 true。如果结束遍历给 m[key] 赋值为 false，并返回 false，参加代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCross</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; m;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(stones, <span class="number">0</span>, <span class="number">0</span>, m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones, <span class="type">int</span> pos, <span class="type">int</span> jump, unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt;&amp; m)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = stones.<span class="built_in">size</span>(), key = pos | jump &lt;&lt; <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (m.<span class="built_in">count</span>(key)) <span class="keyword">return</span> m[key];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = pos + <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> dist = stones[i] - stones[pos];</span><br><span class="line">            <span class="keyword">if</span> (dist &lt; jump - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (dist &gt; jump + <span class="number">1</span>) <span class="keyword">return</span> m[key] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">helper</span>(stones, i, dist, m)) <span class="keyword">return</span> m[key] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[key] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们也可以用迭代的方法来解，用一个 HashMap 来建立每个石头和在该位置上能跳的距离之间的映射，建立一个一维 dp 数组，其中 dp[i] 表示在位置为i的石头青蛙的弹跳力(只有青蛙能跳到该石头上，dp[i] 才大于0)，由于题目中规定了第一个石头上青蛙跳的距离必须是1，为了跟后面的统一，对青蛙在第一块石头上的弹跳力初始化为0(虽然为0，但是由于题目上说青蛙最远能到其弹跳力+1的距离，所以仍然可以到达第二块石头)。这里用变量k表示当前石头，然后开始遍历剩余的石头，对于遍历到的石头i，来找到刚好能跳到i上的石头k，如果i和k的距离大于青蛙在k上的弹跳力+1，则说明青蛙在k上到不了i，则k自增1。从k遍历到i，如果青蛙能从中间某个石头上跳到i上，更新石头i上的弹跳力和最大弹跳力。这样当循环完成后，只要检查最后一个石头上青蛙的最大弹跳力是否大于0即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCross</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, unordered_set&lt;<span class="type">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(stones.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        m[<span class="number">0</span>].<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; stones.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (dp[k] + <span class="number">1</span> &lt; stones[i] - stones[k]) ++k;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = k; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> t = stones[i] - stones[j];</span><br><span class="line">                <span class="keyword">if</span> (m[j].<span class="built_in">count</span>(t - <span class="number">1</span>) || m[j].<span class="built_in">count</span>(t) || m[j].<span class="built_in">count</span>(t + <span class="number">1</span>)) &#123;</span><br><span class="line">                    m[i].<span class="built_in">insert</span>(t);</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode404-Sum-of-Left-Leaves"><a href="#Leetcode404-Sum-of-Left-Leaves" class="headerlink" title="Leetcode404. Sum of Left Leaves"></a>Leetcode404. Sum of Left Leaves</h1><p>Find the sum of all left leaves in a given binary tree.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.</span><br></pre></td></tr></table></figure><br>求二叉树的所有左叶子节点的和，判断是不是左叶子节点，加到对列中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* temp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left)</span><br><span class="line">                q.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right &amp;&amp; (temp-&gt;right-&gt;left || temp-&gt;right-&gt;right))</span><br><span class="line">                q.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(!temp-&gt;left &amp;&amp; !temp-&gt;right)</span><br><span class="line">                 res += temp-&gt;val;</span><br><span class="line">	        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode405-Convert-a-Number-to-Hexadecimal"><a href="#Leetcode405-Convert-a-Number-to-Hexadecimal" class="headerlink" title="Leetcode405. Convert a Number to Hexadecimal"></a>Leetcode405. Convert a Number to Hexadecimal</h1><p>Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.</p>
<p>Note:</p>
<ol>
<li>All letters in hexadecimal (a-f) must be in lowercase.</li>
<li>The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character ‘0’; otherwise, the first character in the hexadecimal string will not be the zero character.</li>
<li>The given number is guaranteed to fit within the range of a 32-bit signed integer.</li>
<li>You must not use any method provided by the library which converts/formats the number to hex directly.</li>
</ol>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 26</span><br><span class="line">Output: &quot;1a&quot;</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -1</span><br><span class="line">Output: &quot;ffffffff&quot;</span><br></pre></td></tr></table></figure><br>十进制转十六进制，简单。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">toHex</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="type">char</span> digits[] = &#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            num = <span class="built_in">abs</span>(num);</span><br><span class="line">            num = ~num + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">while</span>(count --) &#123;</span><br><span class="line">            <span class="type">int</span> temp = <span class="number">15</span> &amp; num;</span><br><span class="line">            num = num &gt;&gt; <span class="number">4</span>;</span><br><span class="line">            res = digits[temp] + res;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            cout &lt;&lt; digits[temp] &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode406-Queue-Reconstruction-by-Height"><a href="#Leetcode406-Queue-Reconstruction-by-Height" class="headerlink" title="Leetcode406. Queue Reconstruction by Height"></a>Leetcode406. Queue Reconstruction by Height</h1><p>You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.</p>
<p>Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br></pre></td></tr></table></figure></p>
<p>Explanation:</p>
<ul>
<li>Person 0 has height 5 with no other people taller or the same height in front.</li>
<li>Person 1 has height 7 with no other people taller or the same height in front.</li>
<li>Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.</li>
<li>Person 3 has height 6 with one person taller or the same height in front, which is person 1.</li>
<li>Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.</li>
<li>Person 5 has height 7 with one person taller or the same height in front, which is person 1.</li>
<li>Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.</li>
</ul>
<p>这道题给了我们一个队列，队列中的每个元素是一个 pair，分别为身高和前面身高不低于当前身高的人的个数，让我们重新排列队列，使得每个 pair 的第二个参数都满足题意。首先来看一种超级简洁的方法，给队列先排个序，按照身高高的排前面，如果身高相同，则第二个数小的排前面。然后新建一个空的数组，遍历之前排好序的数组，然后根据每个元素的第二个数字，将其插入到 res 数组中对应的位置，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), [](vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>] || (a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : people) &#123;</span><br><span class="line">            res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>() + a[<span class="number">1</span>], a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode407-Trapping-Rain-Water-II"><a href="#Leetcode407-Trapping-Rain-Water-II" class="headerlink" title="Leetcode407. Trapping Rain Water II"></a>Leetcode407. Trapping Rain Water II</h1><p>Given an m x n integer matrix heightMap representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: After the rain, water is trapped between the blocks.</span><br><span class="line">We have two small pounds 1 and 3 units trapped.</span><br><span class="line">The total volume of water trapped is 4.</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/trap1-3d.jpg" alt=""></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/trap2-3d.jpg" alt=""></p>
<p>这道三维的，我们需要用 BFS 来做，解法思路很巧妙，下面我们就以题目中的例子来进行分析讲解，多图预警，手机流量党慎入：</p>
<p>首先我们应该能分析出，能装水的底面肯定不能在边界上，因为边界上的点无法封闭，那么所有边界上的点都可以加入 queue，当作 BFS 的启动点，同时我们需要一个二维数组来标记访问过的点，访问过的点我们用红色来表示，那么如下图所示：<br><img src="/img/20210704132900407_1.jpg" alt=""></p>
<p>我们再想想，怎么样可以成功的装进去水呢，是不是周围的高度都应该比当前的高度高，形成一个凹槽才能装水，而且装水量取决于周围最小的那个高度，有点像木桶原理的感觉，那么为了模拟这种方法，我们采用模拟海平面上升的方法来做，我们维护一个海平面高度 mx，初始化为最小值，从1开始往上升，那么我们 BFS 遍历的时候就需要从高度最小的格子开始遍历，那么我们的 queue 就不能使用普通队列了，而是使用优先级队列，将高度小的放在队首，最先取出，这样我们就可以遍历高度为1的三个格子，用绿色标记出来了，如下图所示：<br><img src="/img/20210704132900407_2.jpg" alt=""></p>
<p>如上图所示，向周围 BFS 搜索的条件是不能越界，且周围格子未被访问，那么可以看出上面的第一个和最后一个绿格子无法进一步搜索，只有第一行中间那个绿格子可以搜索，其周围有一个灰格子未被访问过，将其加入优先队列 queue 中，然后标记为红色，如下图所示：<br><img src="/img/20210704132900407_3.jpg" alt=""></p>
<p>那么优先队列 queue 中高度为1的格子遍历完了，此时海平面上升1，变为2，此时我们遍历优先队列 queue 中高度为2的格子，有3个，如下图绿色标记所示：<br><img src="/img/20210704132900407_4.jpg" alt=""></p>
<p>我们发现这三个绿格子周围的格子均已被访问过了，所以不做任何操作，海平面继续上升，变为3，遍历所有高度为3的格子，如下图绿色标记所示：<br><img src="/img/20210704132900407_5.jpg" alt=""></p>
<p>由于我们没有特别声明高度相同的格子在优先队列 queue 中的顺序，所以应该是随机的，其实谁先遍历到都一样，对结果没啥影响，我们就假设第一行的两个绿格子先遍历到，那么那么周围各有一个灰格子可以遍历，这两个灰格子比海平面低了，可以存水了，把存水量算出来加入结果 res 中，如下图所示：<br><img src="/img/20210704132900407_6.jpg" alt=""></p>
<p>上图中这两个遍历到的蓝格子会被加入优先队列 queue 中，由于它们的高度小，所以下一次从优先队列 queue 中取格子时，它们会被优先遍历到，那么左边的那个蓝格子进行BFS搜索，就会遍历到其左边的那个灰格子，由于其高度小于海平面，也可以存水，将存水量算出来加入结果 res 中，如下图所示：<br><img src="/img/20210704132900407_7.jpg" alt=""></p>
<p>等两个绿格子遍历结束了，它们会被标记为红色，蓝格子遍历会先被标记红色，然后加入优先队列 queue 中，由于其周围格子全变成红色了，所有不会有任何操作，如下图所示：<br><img src="/img/20210704132900407_8.jpg" alt=""></p>
<p>此时所有的格子都标记为红色了，海平面继续上升，继续遍历完优先队列 queue 中的格子，不过已经不会对结果有任何影响了，因为所有的格子都已经访问过了，此时等循环结束后返回res即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trapRainWater</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heights.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = heights.<span class="built_in">size</span>(), n = heights[<span class="number">0</span>].<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt; &gt; <span class="built_in">visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; q;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dir&#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || i == m<span class="number">-1</span> || j == <span class="number">0</span> || j == n<span class="number">-1</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;heights[i][j], i*n+j&#125;);</span><br><span class="line">                    visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="type">int</span> max_height = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; t = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> h = t.first, r = t.second / n, c = t.second % n;</span><br><span class="line">            max_height = <span class="built_in">max</span>(max_height, h);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">                <span class="type">int</span> x = r + dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> y = c + dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || visited[x][y])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (heights[x][y] &lt; max_height)</span><br><span class="line">                    res = res + (max_height - heights[x][y]);</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;heights[x][y], x*n+y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode409-Longest-Palindrome"><a href="#Leetcode409-Longest-Palindrome" class="headerlink" title="Leetcode409. Longest Palindrome"></a>Leetcode409. Longest Palindrome</h1><p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.</p>
<p>This is case sensitive, for example “Aa” is not considered a palindrome here.</p>
<p>Note:<br>Assume the length of given string will not exceed 1,010.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abccccdd&quot;</span><br><span class="line">Output: 7</span><br><span class="line">Explanation:</span><br><span class="line">One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7.</span><br></pre></td></tr></table></figure><br>先统计每个字母的个数，然后如果这个字母是偶数个的话，可以放到回文里，如果是奇数的话，先放进去个数减一个，然后如果现在回文长度是偶数，那还可以加一个。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ch[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s)</span><br><span class="line">            ch[c]++;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : ch) &#123;</span><br><span class="line">            ans += (i / <span class="number">2</span> * <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(ans % <span class="number">2</span>== <span class="number">0</span> &amp;&amp; i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                ans ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode410-Split-Array-Largest-Sum"><a href="#Leetcode410-Split-Array-Largest-Sum" class="headerlink" title="Leetcode410. Split Array Largest Sum"></a>Leetcode410. Split Array Largest Sum</h1><p>Given an array which consists of non-negative integers and an integer  m , you can split the array into  m  non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these  m  subarrays.</p>
<p>Note: Given  m  satisfies the following constraint: 1 ≤ m ≤ length(nums) ≤ 14,000.</p>
<p>Examples:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums = [7,2,5,10,8]</span><br><span class="line">m = 2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">18</span><br></pre></td></tr></table></figure></p>
<p>Explanation:</p>
<ul>
<li>There are four ways to split nums into two subarrays.</li>
<li>The best way is to split it into [7,2,5] and [10,8],</li>
<li>where the largest sum among the two subarrays is only 18.</li>
</ul>
<p>这道题给了我们一个非负数的数组 nums 和一个整数m，让把数组分割成m个非空的连续子数组，让最小化m个子数组中的最大值。</p>
<p>首先来分析，如果m和数组 nums 的个数相等，那么每个数组都是一个子数组，所以返回 nums 中最大的数字即可，如果m为1，那么整个 nums 数组就是一个子数组，返回 nums 所有数字之和，所以对于其他有效的m值，返回的值必定在上面两个值之间，所以可以用二分搜索法来做。用一个例子来分析，nums = [1, 2, 3, 4, 5], m = 3，将 left 设为数组中的最大值5，right 设为数字之和 15，然后算出中间数为 10，接下来要做的是找出和最大且小于等于 10 的子数组的个数，[1, 2, 3, 4], [5]，可以看到无法分为3组，说明 mid 偏大，所以让 right=mid，然后再次进行二分查找，算出 mid=7，再次找出和最大且小于等于7的子数组的个数，[1,2,3], [4], [5]，成功的找出了三组，说明 mid 还可以进一步降低，让 right=mid，再次进行二分查找，算出 mid=6，再次找出和最大且小于等于6的子数组的个数，[1,2,3], [4], [5]，成功的找出了三组，尝试着继续降低 mid，让 right=mid，再次进行二分查找，算出 mid=5，再次找出和最大且小于等于5的子数组的个数，[1,2], [3], [4], [5]，发现有4组，此时的 mid 太小了，应该增大 mid，让 left=mid+1，此时 left=6，right=6，循环退出了，返回 right 即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">splitArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            left = <span class="built_in">max</span>(left, (<span class="type">long</span>)nums[i]);</span><br><span class="line">            right += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">can_split</span>(nums, m, mid)) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">can_split</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">long</span> m, <span class="type">long</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> cnt = <span class="number">1</span>, curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            curSum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (curSum &gt; sum) &#123;</span><br><span class="line">                curSum = nums[i];</span><br><span class="line">                ++cnt;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的解法相对来说比较难想，在热心网友 perthblank 的提醒下，再来看一种 DP 的解法，相对来说，这种方法应该更容易理解一些。建立一个二维数组 dp，其中 dp[i][j] 表示将数组中前j个数字分成i组所能得到的最小的各个子数组中最大值，初始化为整型最大值，如果无法分为i组，那么还是保持为整型最大值。为了能快速的算出子数组之和，还是要建立累计和数组，难点就是在于推导状态转移方程了。</p>
<p>来分析一下，如果前j个数字要分成i组，那么i的范围是什么，由于只有j个数字，如果每个数字都是单独的一组，那么最多有j组；如果将整个数组看为一个整体，那么最少有1组，所以i的范围是[1, j]，所以要遍历这中间所有的情况，假如中间任意一个位置k，dp[i-1][k] 表示数组中前k个数字分成 i-1 组所能得到的最小的各个子数组中最大值，而 sums[j]-sums[k] 就是后面的数字之和，取二者之间的较大值，然后和 dp[i][j] 原有值进行对比，更新 dp[i][j] 为二者之中的较小值，这样k在 [1, j] 的范围内扫过一遍，dp[i][j] 就能更新到最小值，最终返回 dp[m][n] 即可，博主认为这道题所用的思想应该是之前那道题 Reverse Pairs 中解法二中总结的分割重现关系 (Partition Recurrence Relation)，由此看来很多问题的本质都是一样，但是披上华丽的外衣，难免会让人有些眼花缭乱了，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">splitArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span>&gt; <span class="title">sums</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;(n + <span class="number">1</span>, LONG_MAX));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i - <span class="number">1</span>; k &lt; j; ++k) &#123;</span><br><span class="line">                    <span class="type">long</span> val = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][k], sums[j] - sums[k]);</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode412-Fizz-Buzz"><a href="#Leetcode412-Fizz-Buzz" class="headerlink" title="Leetcode412. Fizz Buzz"></a>Leetcode412. Fizz Buzz</h1><p>Write a program that outputs the string representation of numbers from 1 to n.</p>
<p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">n = 15,</span><br><span class="line">Return:</span><br><span class="line">[</span><br><span class="line">    &quot;1&quot;,</span><br><span class="line">    &quot;2&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;4&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;7&quot;,</span><br><span class="line">    &quot;8&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;11&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;13&quot;,</span><br><span class="line">    &quot;14&quot;,</span><br><span class="line">    &quot;FizzBuzz&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br>太简单了浪费时间。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((i + <span class="number">1</span>) % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; (i + <span class="number">1</span>) % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&quot;FizzBuzz&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((i + <span class="number">1</span>) % <span class="number">3</span> == <span class="number">0</span>)   </span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&quot;Fizz&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((i + <span class="number">1</span>) % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&quot;Buzz&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode413-Arithmetic-Slices"><a href="#Leetcode413-Arithmetic-Slices" class="headerlink" title="Leetcode413. Arithmetic Slices"></a>Leetcode413. Arithmetic Slices</h1><p>An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p>
<p>For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences. Given an integer array nums, return the number of arithmetic subarrays of nums.</p>
<p>A subarray is a contiguous subsequence of the array.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,4]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
<p>这道题让我们算一种算数切片，说白了就是找等差数列，限定了等差数列的长度至少为3，那么[1,2,3,4]含有3个长度至少为3的算数切片，我们再来看[1,2,3,4,5]有多少个呢:<br>len = 3: [1,2,3], [2,3,4], [3,4,5]</p>
<p>len = 4: [1,2,3,4], [2,3,4,5]</p>
<p>len = 5: [1,2,3,4,5]</p>
<p>那么我们可以归纳出规律，长度为n的等差数列有1个，长度为n-1的等差数列有2个，… ，长度为3的等差数列有 n-2 个，那么总共就是 1 + 2 + 3 + … + n-2 ，此时就要祭出高斯求和公式了，长度为n的等差数列中含有长度至少为3的算数切片的个数为(n-1)(n-2)/2，那么题目就变成了找原数组中等差数列的长度，然后带入公式去算个数即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, len = <span class="number">2</span>, n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] - A[i - <span class="number">1</span>] == A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                ++len;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">2</span>) res += (len - <span class="number">1</span>) * (len - <span class="number">2</span>) * <span class="number">0.5</span>;</span><br><span class="line">                len = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">2</span>) res += (len - <span class="number">1</span>) * (len - <span class="number">2</span>) * <span class="number">0.5</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode414-Third-Maximum-Number"><a href="#Leetcode414-Third-Maximum-Number" class="headerlink" title="Leetcode414. Third Maximum Number"></a>Leetcode414. Third Maximum Number</h1><p>Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3, 2, 1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The third maximum is 1.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 2]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The third maximum does not exist, so the maximum (2) is returned instead.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [2, 2, 3, 1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: Note that the third maximum here means the third maximum distinct number.</span><br><span class="line">Both numbers with value 2 are both considered as second maximum.</span><br></pre></td></tr></table></figure><br>遍历数组，通过跟三个变量（max, mid, min）的比较，来交换它们之间数字。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">thirdMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> min = LONG_MIN, mid = LONG_MIN, max = LONG_MIN;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == max || nums[i] == mid)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; max) &#123;</span><br><span class="line">                min = mid;</span><br><span class="line">                mid = max;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; mid) &#123;</span><br><span class="line">                min = mid;</span><br><span class="line">                mid = nums[i];</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt;= min) &#123;</span><br><span class="line">                min = nums[i];</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(count &gt;= <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode415-Add-Strings"><a href="#Leetcode415-Add-Strings" class="headerlink" title="Leetcode415. Add Strings"></a>Leetcode415. Add Strings</h1><p>Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.</p>
<p>Note:</p>
<ul>
<li>The length of both num1 and num2 is &lt; 5100.</li>
<li>Both num1 and num2 contains only digits 0-9.</li>
<li>Both num1 and num2 does not contain any leading zero.</li>
<li>You must not use any built-in BigInteger library or convert the inputs to integer directly.</li>
</ul>
<p>简单模拟，做的及其纠结。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string nums1, string nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums<span class="number">1.l</span>ength() &lt; nums<span class="number">2.l</span>ength()) &#123;</span><br><span class="line">            string temp = nums1;</span><br><span class="line">            nums1 = nums2;</span><br><span class="line">            nums2 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = nums<span class="number">1.l</span>ength()<span class="number">-1</span>, j = nums<span class="number">2.l</span>ength()<span class="number">-1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i --, j --) &#123;</span><br><span class="line">            nums1[i] = nums1[i] + nums2[j] - <span class="number">48</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &gt; <span class="number">57</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                nums1[i] -= <span class="number">10</span>;</span><br><span class="line">                nums1[i - <span class="number">1</span>] = nums1[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &gt; <span class="number">57</span>) &#123;</span><br><span class="line">                nums1[i] -= <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                    nums1 = <span class="string">&quot;1&quot;</span> + nums1;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    nums1[i - <span class="number">1</span>] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums1[i] &gt; <span class="number">57</span>) &#123;</span><br><span class="line">                nums1[i] -= <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                    nums1 = <span class="string">&quot;1&quot;</span> + nums1;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    nums1[i - <span class="number">1</span>] ++;</span><br><span class="line">                i --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// computing lengths of both strings</span></span><br><span class="line">        <span class="type">int</span> num1length = num<span class="number">1.l</span>ength() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> num2length = num<span class="number">2.l</span>ength()- <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  solution string</span></span><br><span class="line">        string sol = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// remainder for when summing two numbers</span></span><br><span class="line">        <span class="type">int</span> remainder = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// while both strings haven&#x27;t been consumed </span></span><br><span class="line">        <span class="keyword">while</span> (num1length &gt;= <span class="number">0</span> || num2length &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// get current characters of iteration</span></span><br><span class="line">            <span class="type">int</span> current_num1 = (num1length &gt;= <span class="number">0</span>) ? num<span class="number">1.</span><span class="built_in">at</span>(num1length) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> current_num2 = (num2length &gt;= <span class="number">0</span>) ? num<span class="number">2.</span><span class="built_in">at</span>(num2length) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// appending sum and remainder from previous to solution string </span></span><br><span class="line">            <span class="type">int</span> sum = current_num1 + current_num2 + remainder;     </span><br><span class="line">            sol = std::<span class="built_in">to_string</span>(sum % <span class="number">10</span>) + sol;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// determining whether there&#x27;s a remainder for next sum</span></span><br><span class="line">            remainder = (sum &gt; <span class="number">9</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// decrementing for next addition</span></span><br><span class="line">            num1length--;</span><br><span class="line">            num2length--;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// append final remainder if there is one </span></span><br><span class="line">        sol = (remainder == <span class="number">1</span>) ? std::<span class="built_in">to_string</span>(<span class="number">1</span>) + sol : sol;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sol;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode416-Partition-Equal-Subset-Sum"><a href="#Leetcode416-Partition-Equal-Subset-Sum" class="headerlink" title="Leetcode416. Partition Equal Subset Sum"></a>Leetcode416. Partition Equal Subset Sum</h1><p>Given a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,5,11,5]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The array can be partitioned as [1, 5, 5] and [11].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,5]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The array cannot be partitioned into equal sum subsets.</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个数组，问这个数组能不能分成两个非空子集合，使得两个子集合的元素之和相同。那么想，原数组所有数字和一定是偶数，不然根本无法拆成两个和相同的子集合，只需要算出原数组的数字之和，然后除以2，就是 target，那么问题就转换为能不能找到一个非空子集合，使得其数字之和为 target。开始博主想的是遍历所有子集合，算和，但是这种方法无法通过 OJ 的大数据集合。于是乎，动态规划 Dynamic Programming 就是不二之选。定义一个一维的 dp 数组，其中 dp[i] 表示原数组是否可以取出若干个数字，其和为i。那么最后只需要返回 dp[target] 就行了。</p>
<p>初始化 dp[0] 为 true，由于题目中限制了所有数字为正数，就不用担心会出现和为0或者负数的情况。关键问题就是要找出状态转移方程了，需要遍历原数组中的数字，对于遍历到的每个数字 nums[i]，需要更新 dp 数组，既然最终目标是想知道 dp[target] 的 boolean 值，就要想办法用数组中的数字去凑出 target，因为都是正数，所以只会越加越大，加上 nums[i] 就有可能会组成区间 [nums[i], target] 中的某个值，那么对于这个区间中的任意一个数字j，如果 dp[j - nums[i]] 为 true 的话，说明现在已经可以组成 j-nums[i] 这个数字了，再加上 nums[i]，就可以组成数字j了，那么 dp[j] 就一定为 true。如果之前 dp[j] 已经为 true 了，当然还要保持 true，所以还要 ‘或’ 上自身，于是状态转移方程如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = dp[j] || dp[j - nums[i]]         (nums[i] &lt;= j &lt;= target)</span><br></pre></td></tr></table></figure></p>
<p>有了状态转移方程，就可以写出代码了，这里需要特别注意的是，第二个 for 循环一定要从 target 遍历到 nums[i]，而不能反过来，想想为什么呢？因为如果从 nums[i] 遍历到 target 的话，假如 nums[i]=1 的话，那么 [1, target] 中所有的 dp 值都是 true，因为 dp[0] 是 true，dp[1] 会或上 dp[0]，为 true，dp[2] 会或上 dp[1]，为 true，依此类推，完全使的 dp 数组失效了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>), target = sum &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = target; i &gt;= num; --i) &#123;</span><br><span class="line">                dp[i] = dp[i] || dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode417-Pacific-Atlantic-Water-Flow"><a href="#Leetcode417-Pacific-Atlantic-Water-Flow" class="headerlink" title="Leetcode417. Pacific Atlantic Water Flow"></a>Leetcode417. Pacific Atlantic Water Flow</h1><p>There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island’s left and top edges, and the Atlantic Ocean touches the island’s right and bottom edges.</p>
<p>The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).</p>
<p>The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell’s height is less than or equal to the current cell’s height. Water can flow from any cell adjacent to an ocean into the ocean.</p>
<p>Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]</span><br><span class="line">Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]</span><br></pre></td></tr></table></figure><br><img src="/img/waterflow-grid.jpg" alt=""></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: heights = [[2,1],[1,2]]</span><br><span class="line">Output: [[0,0],[0,1],[1,0],[1,1]]</span><br></pre></td></tr></table></figure></p>
<p>上面一条边和左边一条边代表的是太平洋，右边一条边和下边一条边代表的是大西洋。现在告诉你水往低处流，问哪些位置的水能同时流进太平洋和大西洋？</p>
<p>直接DFS求解。一般来说DFS需要有固定的起点，但是对于这个题，四条边界的每个位置都算作起点。</p>
<p>使用两个二维数组，分别记录每个位置的点能不能到达太平洋和大西洋。然后对4条边界进行遍历，看这些以这些边为起点能不能所有的地方。注意了，因为是从边界向中间去寻找，所以，这个时候是新的点要比当前的点海拔高才行。</p>
<p>最坏情况下的时间复杂度是O((M+N)*MN)，空间复杂度是O(MN)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights) &#123;</span><br><span class="line">        <span class="type">int</span> m = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> n = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">p_flags</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n ,<span class="literal">false</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">a_flags</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n ,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(heights, p_flags, i, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(heights, a_flags, i, n<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(heights, p_flags, <span class="number">0</span>,   i);</span><br><span class="line">            <span class="built_in">dfs</span>(heights, a_flags, m<span class="number">-1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="keyword">if</span> (p_flags[i][j] &amp;&amp; a_flags[i][j]) &#123;</span><br><span class="line">                    vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">                    t.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    t.<span class="built_in">push_back</span>(j);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; flags, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = heights.<span class="built_in">size</span>(), n = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        flags[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">4</span>; ii ++) &#123;</span><br><span class="line">            <span class="type">int</span> x = i + dirs[ii].first;</span><br><span class="line">            <span class="type">int</span> y = j + dirs[ii].second;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; !flags[x][y] &amp;&amp; heights[x][y] &gt;= heights[i][j]) &#123;</span><br><span class="line">                flags[x][y] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(heights, flags, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode419-Battleships-in-a-Board"><a href="#Leetcode419-Battleships-in-a-Board" class="headerlink" title="Leetcode419. Battleships in a Board"></a>Leetcode419. Battleships in a Board</h1><p>Given an 2D board, count how many battleships are in it. The battleships are represented with ‘X’s, empty slots are represented with ‘.’s. You may assume the following rules:<br>You receive a valid board, made of only battleships or empty slots.<br>Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.<br>At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.<br>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X..X</span><br><span class="line">...X</span><br><span class="line">...X</span><br></pre></td></tr></table></figure><br>In the above board there are 2 battleships.<br>Invalid Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...X</span><br><span class="line">XXXX</span><br><span class="line">...X</span><br></pre></td></tr></table></figure><br>This is an invalid board that you will not receive - as battleships will always have a cell separating between them.<br>Follow up:<br>Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?</p>
<p>利用最简单的方法找有多少个X块，这里用的遍历很方便。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countBattleships</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> y = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;y;j++)</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&lt;y<span class="number">-1</span> &amp;&amp; board[i][j<span class="number">+1</span>]==<span class="string">&#x27;X&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;x<span class="number">-1</span> &amp;&amp; board[i<span class="number">+1</span>][j]==<span class="string">&#x27;X&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    res++;</span><br><span class="line">	           &#125;</span><br><span class="line">	    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode421-Maximum-XOR-of-Two-Numbers-in-an-Array"><a href="#Leetcode421-Maximum-XOR-of-Two-Numbers-in-an-Array" class="headerlink" title="Leetcode421. Maximum XOR of Two Numbers in an Array"></a>Leetcode421. Maximum XOR of Two Numbers in an Array</h1><p>Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 &lt;= i &lt;= j &lt; n.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [3,10,5,25,2,8]</span><br><span class="line">Output: 28</span><br><span class="line">Explanation: The maximum result is 5 XOR 25 = 28.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70]</span><br><span class="line">Output: 127</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= nums.length &lt;= 2 * 105</li>
<li>0 &lt;= nums[i] &lt;= 231 - 1</li>
</ul>
<p>这个是求一个数组中任意两个元素的最大异或值，我们就要让最高位尽可能的不同，使用字典树解决这个问题。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> son[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">Node</span>() &#123;</span><br><span class="line">            son[<span class="number">0</span>] = son[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    vector&lt;Node&gt; nodes;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaximumXOR</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 让异或的结果最高位尽可能大</span></span><br><span class="line">        <span class="comment">// 从高位到低位考虑，ai当前这个位为0，那希望aj当前位为1</span></span><br><span class="line">        <span class="comment">// 用前缀树</span></span><br><span class="line">	        </span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	        </span><br><span class="line">        nodes.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">        <span class="built_in">insert</span>(a.<span class="built_in">back</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">           <span class="type">int</span> ans = <span class="built_in">query</span>(a[i]);</span><br><span class="line">           ret = <span class="built_in">max</span>(ret, ans);</span><br><span class="line">           <span class="built_in">insert</span>(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">	    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="type">int</span> t = (a &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nodes[id].son[t] == <span class="number">-1</span>) &#123;</span><br><span class="line">                nodes.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">                nodes[id].son[t] = nodes.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            id = nodes[id].son[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="type">int</span> b = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> b2 = b ^ <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nodes[id].son[b2] != <span class="number">-1</span>) &#123;</span><br><span class="line">               id = nodes[id].son[b2];</span><br><span class="line">               ret |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                id = nodes[id].son[b];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode423-Reconstruct-Original-Digits-from-English"><a href="#Leetcode423-Reconstruct-Original-Digits-from-English" class="headerlink" title="Leetcode423. Reconstruct Original Digits from English"></a>Leetcode423. Reconstruct Original Digits from English</h1><p>Given a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order.</p>
<p>Note:</p>
<ul>
<li>Input contains only lowercase English letters.</li>
<li>Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as “abc” or “zerone” are not permitted.</li>
<li>Input length is less than 50,000.</li>
</ul>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;owoztneoer&quot;</span><br><span class="line">Output: &quot;012&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;fviefuro&quot;</span><br><span class="line">Output: &quot;45&quot;</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一串英文字符串，是由表示数字的英文单词组成的，不过字符顺序是打乱的，让我们重建出数字。那么这道题的思路是先要统计出各个字符出现的次数，然后算出每个单词出现的次数，然后就可以重建了。由于题目中限定了输入的字符串一定是有效的，那么不会出现无法成功重建的情况，这里需要用个trick。</p>
<p>我们仔细观察这些表示数字的单词”zero”, “one”, “two”, “three”, “four”, “five”, “six”, “seven”, “eight”, “nine”，我们可以发现有些的单词的字符是独一无二的，比如z，只出现在zero中，还有w，u，x，g这四个单词，分别只出现在two，four，six，eight中，那么这五个数字的个数就可以被确定了，由于含有o的单词有zero，two，four，one，其中前三个都被确定了，那么one的个数也就知道了；由于含有h的单词有eight，three，其中eight个数已知，那么three的个数就知道了；由于含有f的单词有four，five，其中four个数已知，那么five的个数就知道了；由于含有s的单词有six，seven，其中six个数已知，那么seven的个数就知道了；由于含有i的单词有six，eight，five，nine，其中前三个都被确定了，那么nine的个数就知道了。</p>
<p>知道了这些问题就变的容易多了，我们按这个顺序”zero”, “two”, “four”, “six”, “eight”, “one”, “three”, “five”, “seven”, “nine”就能找出所有的个数了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">originalDigits</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        vector&lt;string&gt; words&#123;<span class="string">&quot;zero&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;four&quot;</span>, <span class="string">&quot;six&quot;</span>, <span class="string">&quot;eight&quot;</span>, <span class="string">&quot;one&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;five&quot;</span>, <span class="string">&quot;seven&quot;</span>, <span class="string">&quot;nine&quot;</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;, <span class="built_in">counts</span>(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; chars&#123;<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;i&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) ++counts[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = counts[chars[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; words[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                counts[words[i][j] - <span class="string">&#x27;a&#x27;</span>] -= cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cnt--) res += (nums[i] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode424-Longest-Repeating-Character-Replacement"><a href="#Leetcode424-Longest-Repeating-Character-Replacement" class="headerlink" title="Leetcode424. Longest Repeating Character Replacement"></a>Leetcode424. Longest Repeating Character Replacement</h1><p>Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.</p>
<p>Note:<br>Both the string’s length and k will not exceed 10 4.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;ABAB&quot;, k = 2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Replace the two &#x27;A&#x27;s with two &#x27;B&#x27;s or vice versa.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;AABABBA&quot;, k = 1</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Replace the one &#x27;A&#x27; in the middle with &#x27;B&#x27; and form &quot;AABBBBA&quot;.</span><br><span class="line">The substring &quot;BBBB&quot; has the longest repeating letters, which is 4.</span><br></pre></td></tr></table></figure></p>
<p>这道题给我们了一个字符串，说我们有k次随意置换任意字符的机会，让我们找出最长的重复字符的字符串。我们首先来想，如果没有k的限制，让我们求把字符串变成只有一个字符重复的字符串需要的最小置换次数，那么就是字符串的总长度减去出现次数最多的字符的个数。如果加上k的限制，我们其实就是求满足 (子字符串的长度减去出现次数最多的字符个数)&lt;=k 的最大子字符串长度即可，搞清了这一点，我们也就应该知道怎么用滑动窗口来解了吧。我们用一个变量 start 记录滑动窗口左边界，初始化为0，然后遍历字符串，每次累加出现字符的个数，然后更新出现最多字符的个数，然后我们判断当前滑动窗口是否满足之前说的那个条件，如果不满足，我们就把滑动窗口左边界向右移动一个，并注意去掉的字符要在 counts 里减一，直到满足条件，我们更新结果 res 即可。需要注意的是，当滑动窗口的左边界向右移动了后，窗口内的相同字母的最大个数貌似可能会改变啊，为啥这里不用更新 maxCnt 呢？这是个好问题，原因是此题让求的是最长的重复子串，maxCnt 相当于卡了一个窗口大小，我们并不希望窗口变小，虽然窗口在滑动，但是之前是出现过跟窗口大小相同的符合题意的子串，缩小窗口没有意义，并不会使结果 res 变大，所以我们才不更新 maxCnt 的，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">characterReplacement</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, maxCnt = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counts</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            maxCnt = <span class="built_in">max</span>(maxCnt, ++counts[s[i] - <span class="string">&#x27;A&#x27;</span>]);</span><br><span class="line">            <span class="keyword">while</span> (i - start + <span class="number">1</span> - maxCnt &gt; k) &#123;</span><br><span class="line">                --counts[s[start] - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">                ++start;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i - start + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode427-Construct-Quad-Tree"><a href="#Leetcode427-Construct-Quad-Tree" class="headerlink" title="Leetcode427. Construct Quad Tree"></a>Leetcode427. Construct Quad Tree</h1><p>Given a n * n matrix grid of 0’s and 1’s only. We want to represent the grid with a Quad-Tree.</p>
<p>Return the root of the Quad-Tree representing the grid.</p>
<p>Notice that you can assign the value of a node to True or False when isLeaf is False, and both are accepted in the answer.</p>
<p>A Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:</p>
<ul>
<li><code>val</code>: True if the node represents a grid of 1’s or False if the node represents a grid of 0’s. </li>
<li><code>isLeaf</code>: True if the node is leaf node on the tree or False if the node has the four children.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> boolean val;</span><br><span class="line">    <span class="keyword">public</span> boolean isLeaf;</span><br><span class="line">    <span class="keyword">public</span> Node topLeft;</span><br><span class="line">    <span class="keyword">public</span> Node topRight;</span><br><span class="line">    <span class="keyword">public</span> Node bottomLeft;</span><br><span class="line">    <span class="keyword">public</span> Node bottomRight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We can construct a Quad-Tree from a two-dimensional area using the following steps:</p>
<p>If the current grid has the same value (i.e all 1’s or all 0’s) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]</span><br><span class="line">Output: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]</span><br><span class="line">Explanation: All values in the grid are not the same. We divide the grid into four sub-grids.</span><br><span class="line">The topLeft, bottomLeft and bottomRight each has the same value.</span><br><span class="line">The topRight have different values so we divide it into 4 sub-grids where each has the same value.</span><br><span class="line">Explanation is shown in the photo below:</span><br></pre></td></tr></table></figure><br><img src="/img/e2tree.png" alt=""></p>
<p>这道题让我们根据一个二维数组来建立一棵四叉树，首先整个数组被分成了四等份，左上，左下，和右下部分内的值均相同，那么他们都是一个叶结点，而右上只有再四等分一下，才能使各自部分内的值相同，所以其就不是叶结点，而四等分后的每个区间才是叶结点。题目中限定了N的值一定是2的指数，就是说其如果可分的话，一定可以四等分，而之前说了，只有区间内的值不同时，才需要四等分，否则整体就当作一个叶结点。所以我们需要check四等分区间内的值是否相同，当然，我们可以将二维数组拆分为四个二维数组，但是那样可能不太高效，而且还占用额外空间，一个比较好的选择是用坐标变量来控制等分数组的范围，我们只需要一个起始点坐标，和区间的长度，就可以精确定位一个区间了。</p>
<p>比如说对于例子中的整个二维数组数组来说，知道起始点坐标 (0, 0)，还有长度8，就知道表示的是哪个区间。我们可以遍历这个区间上的其他所有的点，跟起点对比，只要有任何点跟起点不相同，则说明该区间是可分的，因为我们前面说了，只有一个区间上所有的值均相同，才能当作一个叶结点。只要有不同，就表示可以四分，那么我们就新建一个结点，这里的左上，左下，右上，和右下四个子结点就需要用过调用递归函数来实现了，实现原理都一样。</p>
<p>对于非叶结点，结点值可以是true或者false都没问题。如果某个区间上所有值均相同，那么就生成一个叶结点，结点值就跟区间值相同，isLeaf是true，四个子结点均为NULL即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">construct</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(grid, <span class="number">0</span>, <span class="number">0</span>, grid.<span class="built_in">size</span>()<span class="number">-1</span>, grid.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Node* <span class="title">build</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> r0, <span class="type">int</span> c0, <span class="type">int</span> r1, <span class="type">int</span> c1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r0 &gt; r1 || c0 &gt; c1)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">bool</span> isleaf = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> val = grid[r0][c0];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r0; i &lt;= r1; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = c0; j &lt;= c1; j ++)</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] != val) &#123;</span><br><span class="line">                    isleaf = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">if</span> (isleaf)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(val == <span class="number">1</span>, <span class="literal">true</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="type">int</span> mid1 = (r0+r1) / <span class="number">2</span>, mid2 = (c0+c1) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="literal">false</span>, <span class="literal">false</span>, </span><br><span class="line">                       <span class="built_in">build</span>(grid, r0, c0, mid1, mid2), </span><br><span class="line">                       <span class="built_in">build</span>(grid, r0, mid2<span class="number">+1</span>, mid1, c1),</span><br><span class="line">                       <span class="built_in">build</span>(grid, mid1<span class="number">+1</span>, c0, r1, mid2), </span><br><span class="line">                       <span class="built_in">build</span>(grid, mid1<span class="number">+1</span>, mid2<span class="number">+1</span>, r1, c1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode429-N-ary-Tree-Level-Order-Traversal"><a href="#Leetcode429-N-ary-Tree-Level-Order-Traversal" class="headerlink" title="Leetcode429. N-ary Tree Level Order Traversal"></a>Leetcode429. N-ary Tree Level Order Traversal</h1><p>Given an n-ary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>Note:</p>
<ul>
<li>The depth of the tree is at most 1000.</li>
<li>The total number of nodes is at most 5000.</li>
</ul>
<p>这道题给了我们一棵N叉树，让我们对其进行层序遍历。虽说现在每一个结点可能有很多个子结点，但其实处理的思路的都是一样的。子结点放到了一个children数组中，我们访问的时候只要遍历数组就行了。先来看迭代的写法，用到了队列queue来辅助，首先判断root是否为空，为空直接返回空数组，否则加入queue中。然后遍历queue，这里用的trick就是，要加个for循环，要将当前queue中的结点的个数统计下来，因为再加入下一层的结点时，queue的结点个数会增加，而在加入下一层结点之前，当前queue中的结点个数全都属于一层，所以我们要把层与层区分开来，将同一层的结点都放到一个数组out中，之后再放入结果res中，这种层序遍历的思想在迷宫遍历找最短路径的时候应用的也很多，是个必须要掌握的方法呢，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        queue&lt;Node*&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; out;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                out.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (!t-&gt;children.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> a : t-&gt;children) q.<span class="built_in">push</span>(a);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(out);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode430-Flatten-a-Multilevel-Doubly-Linked-List"><a href="#Leetcode430-Flatten-a-Multilevel-Doubly-Linked-List" class="headerlink" title="Leetcode430. Flatten a Multilevel Doubly Linked List"></a>Leetcode430. Flatten a Multilevel Doubly Linked List</h1><p>You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below.</p>
<p>Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</span><br><span class="line">Output: [1,2,3,7,8,11,12,9,10,4,5,6]</span><br></pre></td></tr></table></figure></p>
<p>Explanation:<br><img src="/img/20210704132900multilevellinkedlist.png" alt=""></p>
<p>The multilevel linked list in the input is as follows:<br><img src="/img/20210704132900multilevellinkedlistflattened.png" alt=""></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2,null,3]</span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure></p>
<p>Explanation:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The input multilevel linked list is as follows:</span><br><span class="line"></span><br><span class="line">  1---2---NULL</span><br><span class="line">  |</span><br><span class="line">  3---NULL</span><br></pre></td></tr></table></figure></p>
<p>这道题给了一个多层的双向链表，让我们压平成为一层的双向链表，题目中给了形象的图例，不难理解题意。根据题目中给的例子，我们可以看出如果某个结点有下一层双向链表，那么下一层双向链表中的结点就要先加入进去，如果下一层链表中某个结点还有下一层，那么还是优先加入下一层的结点，整个加入的机制是DFS的，就是有岔路先走岔路，走到没路了后再返回，这就是深度优先遍历的机制。好，那么既然是DFS，肯定优先考虑递归啦。方法有了，再来看具体怎么递归。由于给定的多层链表本身就是双向的，所以我们只需要把下一层的结点移到第一层即可，那么没有子结点的结点就保持原状，不作处理。只有对于那些有子结点的，我们需要做一些处理，由于子结点链接的双向链表要加到后面，所以当前结点之后要断开，再断开之前，我们用变量 next 指向下一个链表，然后对子结点调用递归函数，我们 suppose 返回的结点已经压平了，那么就只有一层，就相当于要把这一层的结点加到断开的地方，所以需要知道这层的最后一个结点的位置，我们用一个变量 last，来遍历到压平的这一层的末结点。现在就可以开始链接了，首先把子结点链到 cur 的 next，然后把反向指针 prev 也链上。此时 cur 的子结点 child 可以清空，然后压平的这一层的末节点 last 链上之前保存的 next 结点，如果 next 非空，那么链上反向结点 prev。这些操作完成后，我们就已经将压平的这一层完整的加入了之前层断开的地方，继续在之前层往下遍历即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        Node *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;child) &#123;</span><br><span class="line">                Node *next = cur-&gt;next;</span><br><span class="line">                Node *last = cur-&gt;child;</span><br><span class="line">                <span class="keyword">while</span> (last-&gt;next) last = last-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;child;</span><br><span class="line">                cur-&gt;next-&gt;prev = cur;</span><br><span class="line">                cur-&gt;child = <span class="literal">NULL</span>;</span><br><span class="line">                last-&gt;next = next;</span><br><span class="line">                <span class="keyword">if</span> (next) next-&gt;prev = last;    </span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode433-Minimum-Genetic-Mutation"><a href="#Leetcode433-Minimum-Genetic-Mutation" class="headerlink" title="Leetcode433. Minimum Genetic Mutation"></a>Leetcode433. Minimum Genetic Mutation</h1><p>A gene string can be represented by an 8-character long string, with choices from ‘A’, ‘C’, ‘G’, and ‘T’.</p>
<p>Suppose we need to investigate a mutation from a gene string start to a gene string end where one mutation is defined as one single character changed in the gene string.</p>
<p>For example, “AACCGGTT” —&gt; “AACCGGTA” is one mutation. There is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.</p>
<p>Given the two gene strings start and end and the gene bank bank, return the minimum number of mutations needed to mutate from start to end. If there is no such a mutation, return -1.</p>
<p>Note that the starting point is assumed to be valid, so it might not be included in the bank.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: start = &quot;AACCGGTT&quot;, end = &quot;AACCGGTA&quot;, bank = [&quot;AACCGGTA&quot;]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: start = &quot;AACCGGTT&quot;, end = &quot;AAACGGTA&quot;, bank = [&quot;AACCGGTA&quot;,&quot;AACCGCTA&quot;,&quot;AAACGGTA&quot;]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: start = &quot;AAAAACCC&quot;, end = &quot;AACCCCCC&quot;, bank = [&quot;AAAACCCC&quot;,&quot;AAACCCCC&quot;,&quot;AACCCCCC&quot;]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>先建立bank数组的距离场，这里距离就是两个字符串之间不同字符的个数。然后以start字符串为起点，向周围距离为1的点扩散，采用BFS搜索，每扩散一层，level自加1，当扩散到end字符串时，返回当前level即可。注意我们要把start字符串也加入bank中，而且此时我们也知道start的坐标位置，bank的最后一个位置，然后在建立距离场的时候，调用一个count子函数，用来统计输入的两个字符串之间不同字符的个数，注意dist[i][j]和dist[j][i]是相同，所以我们只用算一次就行了。然后我们进行BFS搜索，用一个visited集合来保存遍历过的字符串，注意检测距离的时候，dist[i][j]和dist[j][i]只要有一个是1，就可以了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMutation</span><span class="params">(string start, string end, vector&lt;string&gt;&amp; bank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bank.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        bank.<span class="built_in">push_back</span>(start);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, len = bank.<span class="built_in">size</span>();</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dist</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(len, <span class="number">0</span>));</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">+1</span>; j &lt; len; j ++)</span><br><span class="line">                dist[i][j] = <span class="built_in">cal_dist</span>(bank[i], bank[j]);</span><br><span class="line">        q.<span class="built_in">push</span>(len<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res ++;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">                <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                visited[t] = <span class="literal">true</span>;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j ++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((dist[t][j] != <span class="number">1</span> &amp;&amp; dist[j][t] != <span class="number">1</span>) || visited[j])</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    <span class="keyword">if</span> (bank[j] == end)</span><br><span class="line">                        <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cal_dist</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, len = a.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">            <span class="keyword">if</span> (a[i] != b[i])</span><br><span class="line">                cnt ++;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode434-Number-of-Segments-in-a-String"><a href="#Leetcode434-Number-of-Segments-in-a-String" class="headerlink" title="Leetcode434. Number of Segments in a String"></a>Leetcode434. Number of Segments in a String</h1><p>Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.</p>
<p>Please note that the string does not contain any non-printable characters.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;Hello, my name is John&quot;</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><br>判断一个句子中有几个段。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSegments</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;&quot;</span> || s == <span class="string">&quot; &quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                res ++;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; s.<span class="built_in">length</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>有一种简单做法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countSegments</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">	string word;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (ss &gt;&gt; word)</span><br><span class="line">		count++;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode435-Non-overlapping-Intervals"><a href="#Leetcode435-Non-overlapping-Intervals" class="headerlink" title="Leetcode435. Non-overlapping Intervals"></a>Leetcode435. Non-overlapping Intervals</h1><p>Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals = [[1,2],[2,3],[3,4],[1,3]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals = [[1,2],[1,2],[1,2]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一堆区间，让求需要至少移除多少个区间才能使剩下的区间没有重叠，那么首先要给区间排序，根据每个区间的 start 来做升序排序，然后开始要查找重叠区间，判断方法是看如果前一个区间的 end 大于后一个区间的 start，那么一定是重复区间，此时结果 res 自增1，我们需要删除一个，那么此时究竟该删哪一个呢，为了保证总体去掉的区间数最小，我们去掉那个 end 值较大的区间，而在代码中，我们并没有真正的删掉某一个区间，而是用一个变量 last 指向上一个需要比较的区间，我们将 last 指向 end 值较小的那个区间；如果两个区间没有重叠，那么此时 last 指向当前区间，继续进行下一次遍历，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, begin = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        begin = intervals[<span class="number">0</span>][<span class="number">0</span>], end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end &gt; intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                res ++;</span><br><span class="line">                <span class="keyword">if</span> (end &gt; intervals[i][<span class="number">1</span>])</span><br><span class="line">                    end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode436-Find-Right-Interval"><a href="#Leetcode436-Find-Right-Interval" class="headerlink" title="Leetcode436. Find Right Interval"></a>Leetcode436. Find Right Interval</h1><p>You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.</p>
<p>The right interval for an interval i is an interval j such that startj &gt;= endi and startj is minimized.</p>
<p>Return an array of right interval indices for each interval i. If no right interval exists for interval i, then put -1 at index i.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals = [[1,2]]</span><br><span class="line">Output: [-1]</span><br><span class="line">Explanation: There is only one interval in the collection, so it outputs -1.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals = [[3,4],[2,3],[1,2]]</span><br><span class="line">Output: [-1,0,1]</span><br><span class="line">Explanation: There is no right interval for [3,4].</span><br><span class="line">The right interval for [2,3] is [3,4] since start0 = 3 is the smallest start that is &gt;= end1 = 3.</span><br><span class="line">The right interval for [1,2] is [2,3] since start1 = 2 is the smallest start that is &gt;= end2 = 2.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals = [[1,4],[2,3],[3,4]]</span><br><span class="line">Output: [-1,2,-1]</span><br><span class="line">Explanation: There is no right interval for [1,4] and [3,4].</span><br><span class="line">The right interval for [2,3] is [3,4] since start2 = 3 is the smallest start that is &gt;= end1 = 3.</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一堆区间，让我们找每个区间的最近右区间，要保证右区间的 start 要大于等于当前区间的 end，由于区间的顺序不能变，所以我们不能给区间排序，我们需要建立区间的 start 和该区间位置之间的映射，由于题目中限定了每个区间的 start 都不同，所以不用担心一对多的情况出现。然后我们把所有的区间的 start 都放到一个数组中，并对这个数组进行降序排序，那么 start 值大的就在数组前面。然后我们遍历区间集合，对于每个区间，我们在数组中找第一个小于当前区间的 end 值的位置，如果数组中第一个数就小于当前区间的 end，那么说明该区间不存在右区间，结果 res 中加入-1；如果找到了第一个小于当前区间 end 的位置，那么往前推一个就是第一个大于等于当前区间 end 的 start，我们在 HashMap 中找到该区间的坐标加入结果 res 中即可，参见代码如下：（下边改进为二分搜索，速度快了十几倍）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRightInterval</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            map[intervals[i][<span class="number">0</span>]] = i;</span><br><span class="line">            start.<span class="built_in">push_back</span>(intervals[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(start.<span class="built_in">begin</span>(), start.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ress;</span><br><span class="line">        <span class="type">int</span> len = intervals.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> low = <span class="number">0</span>, high = len<span class="number">-1</span>, mid;</span><br><span class="line">            <span class="type">int</span> best = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">                mid = low + (high-low) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (start[mid] &lt; intervals[i][<span class="number">1</span>])</span><br><span class="line">                    low = mid<span class="number">+1</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    best = map[start[mid]];</span><br><span class="line">                    high = mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ress.<span class="built_in">push_back</span>(best);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ress;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode437-Path-Sum-III"><a href="#Leetcode437-Path-Sum-III" class="headerlink" title="Leetcode437. Path Sum III"></a>Leetcode437. Path Sum III</h1><p>You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p>
<p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</span><br><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">    5   -3</span><br><span class="line">   / \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> / \   \</span><br><span class="line">3  -2   1</span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure></p>
<p>这道题让我们求二叉树的路径的和等于一个给定值，说明了这条路径不必要从根节点开始，可以是中间的任意一段，而且二叉树的节点值也是有正有负。那么可以用递归来做，相当于先序遍历二叉树，对于每一个节点都有记录了一条从根节点到当前节点到路径，同时用一个变量 curSum 记录路径节点总和，然后看 curSum 和 sum 是否相等，相等的话结果 res 加1，不等的话继续查看子路径和有没有满足题意的，做法就是每次去掉一个节点，看路径和是否等于给定值，<strong>注意最后必须留一个节点，不能全去掉了，因为如果全去掉了，路径之和为0，而如果给定值刚好为0的话就会有问题</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, vector&lt;TreeNode*&gt;&amp; out, <span class="type">int</span> sum, <span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        cur += root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (cur == sum) ++ans;</span><br><span class="line">        out.<span class="built_in">push_back</span>(root);</span><br><span class="line">        <span class="type">int</span> t = cur;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; out.<span class="built_in">size</span>() - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">            t = t - out[i]-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (t == sum) </span><br><span class="line">                ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, out, sum, cur);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, out, sum, cur);</span><br><span class="line">        out.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; out;</span><br><span class="line">        <span class="built_in">dfs</span>(root, out, sum, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode438-Find-All-Anagrams-in-a-String"><a href="#Leetcode438-Find-All-Anagrams-in-a-String" class="headerlink" title="Leetcode438. Find All Anagrams in a String"></a>Leetcode438. Find All Anagrams in a String</h1><p>Given two strings s and p, return an array of all the start indices of p’s anagrams in s. You may return the answer in any order.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">Output: [0,6]</span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.</span><br><span class="line">The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abab&quot;, p = &quot;ab&quot;</span><br><span class="line">Output: [0,1,2]</span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index = 0 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class="line">The substring with start index = 1 is &quot;ba&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class="line">The substring with start index = 2 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们两个字符串s和p，让在s中找字符串p的所有变位次的位置，所谓变位次就是字符种类个数均相同但是顺序可以不同的两个词，那么肯定首先就要统计字符串p中字符出现的次数，然后从s的开头开始，每次找p字符串长度个字符，来验证字符个数是否相同，如果不相同出现了直接 break，如果一直都相同了，则将起始位置加入结果 res 中，参见代码如下：（不用<code>unordered_map</code>而是用vector会更快！）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; map, maps;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> lens = s.<span class="built_in">length</span>(), lenp = p.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++) &#123;</span><br><span class="line">            map[<span class="string">&#x27;a&#x27;</span> + i] = <span class="number">0</span>;</span><br><span class="line">            maps[<span class="string">&#x27;a&#x27;</span> + i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lenp; i ++) &#123;</span><br><span class="line">            map[p[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lenp &gt; lens) </span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lenp<span class="number">-1</span>; i ++)</span><br><span class="line">            maps[s[i]] ++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = lenp<span class="number">-1</span>; i &lt; lens; i ++) &#123;</span><br><span class="line">            maps[s[i]] ++;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j ++) </span><br><span class="line">                <span class="keyword">if</span> (maps[<span class="string">&#x27;a&#x27;</span> + j] != map[<span class="string">&#x27;a&#x27;</span> + j])</span><br><span class="line">                    <span class="keyword">break</span>;            </span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">26</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(i-lenp<span class="number">+1</span>);</span><br><span class="line">            maps[s[i-lenp<span class="number">+1</span>]] --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode441-Arranging-Coins"><a href="#Leetcode441-Arranging-Coins" class="headerlink" title="Leetcode441. Arranging Coins"></a>Leetcode441. Arranging Coins</h1><p>You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.</p>
<p>Given n, find the total number of full staircase rows that can be formed. n is a non-negative integer and fits within the range of a 32-bit signed integer.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = 5</span><br><span class="line">The coins can form the following rows:</span><br><span class="line">¤</span><br><span class="line">¤ ¤</span><br><span class="line">¤ ¤</span><br><span class="line"></span><br><span class="line">Because the 3rd row is incomplete, we return 2.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n = 8</span><br><span class="line"></span><br><span class="line">The coins can form the following rows:</span><br><span class="line">¤</span><br><span class="line">¤ ¤</span><br><span class="line">¤ ¤ ¤</span><br><span class="line">¤ ¤</span><br><span class="line"></span><br><span class="line">Because the 4th row is incomplete, we return 3.</span><br></pre></td></tr></table></figure><br>直接遍历即可，从1开始，如果剩下是数不能构成一行则返回。注意要先判断剩下的数是否满足，而不是累加以后再判断，这样可能会导致溢出。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, ans = n;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ans &gt;= i) &#123;</span><br><span class="line">        ans -= i;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>前 i 行完整的硬币数量为<code>i * (i + 1) / 2</code> ，前 i+1 行则为<code>(i + 2) * (i + 1) / 2</code>。所以<code>(i + 1)*i / 2 ≤ n &lt; (i + 2) * (i + 1) / 2</code>，所以<code>sqrt(2n + 0.25) - 1.5 &lt; n ≤ sqrt(2n + 0.25) - 0.5</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)(<span class="built_in">sqrt</span>(<span class="number">2</span> * (<span class="type">double</span>)n + <span class="number">0.25</span>) - <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode442-Find-All-Duplicates-in-an-Array"><a href="#Leetcode442-Find-All-Duplicates-in-an-Array" class="headerlink" title="Leetcode442. Find All Duplicates in an Array"></a>Leetcode442. Find All Duplicates in an Array</h1><p>Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.</p>
<p>You must write an algorithm that runs in O(n) time and uses only constant extra space.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,3,2,7,8,2,3,1]</span><br><span class="line">Output: [2,3]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,1,2]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure></p>
<p>这类问题的一个重要条件就是1 ≤ a[i] ≤ n (n = size of array)，不然很难在O(1)空间和O(n)时间内完成。首先来看一种正负替换的方法，这类问题的核心是就是找nums[i]和nums[nums[i] - 1]的关系，我们的做法是，对于每个nums[i]，我们将其对应的nums[nums[i] - 1]取相反数，如果其已经是负数了，说明之前存在过，我们将其加入结果res中即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> idx = <span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[idx] &lt; <span class="number">0</span>) res.<span class="built_in">push_back</span>(idx + <span class="number">1</span>);</span><br><span class="line">            nums[idx] = -nums[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>本题使用Set的数据结构对数组进行遍历，找到出现两次的元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; flags;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!s.<span class="built_in">count</span>(n))</span><br><span class="line">                s.<span class="built_in">insert</span>(n);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode443-String-Compression"><a href="#Leetcode443-String-Compression" class="headerlink" title="Leetcode443. String Compression"></a>Leetcode443. String Compression</h1><p>Given an array of characters, compress it in-place. The length after compression must always be smaller than or equal to the original array. Every element of the array should be a character (not int) of length 1. After you are done modifying the input array in-place, return the new length of the array.</p>
<p>Follow up:<br>Could you solve it using only O(1) extra space?</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">Return 6, and the first 6 characters of the input array should be: [&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">&quot;aa&quot; is replaced by &quot;a2&quot;. &quot;bb&quot; is replaced by &quot;b2&quot;. &quot;ccc&quot; is replaced by &quot;c3&quot;.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;a&quot;]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">Return 1, and the first 1 characters of the input array should be: [&quot;a&quot;]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Nothing is replaced.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">Return 4, and the first 4 characters of the input array should be: [&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;].</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Since the character &quot;a&quot; does not repeat, it is not compressed. &quot;bbbbbbbbbbbb&quot; is replaced by &quot;b12&quot;.</span><br><span class="line">Notice each digit has it&#x27;s own entry in the array.</span><br></pre></td></tr></table></figure><br>字符串压缩，坑很多，如果是只有一个字符的话就不用压缩，否则的话把字符和字符的数量都加到vector中，还要原地修改。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compress</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; chars)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> c = chars[<span class="number">0</span>], cc = c;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">1</span>, pointer = <span class="number">0</span>;</span><br><span class="line">        string nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; chars.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(chars[i] != c) &#123;</span><br><span class="line">                cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; cur &lt;&lt; endl;</span><br><span class="line">                chars[pointer++] = c;</span><br><span class="line">                nums = <span class="built_in">to_string</span>(cur);</span><br><span class="line">                <span class="keyword">if</span>(cur == <span class="number">1</span>) &#123;</span><br><span class="line">                    c = chars[i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">length</span>(); i ++) &#123;</span><br><span class="line">                    chars[pointer++] = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                cur = <span class="number">1</span>;</span><br><span class="line">                c = chars[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur ++;</span><br><span class="line">        &#125;</span><br><span class="line">        chars[pointer++] = c;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pointer;</span><br><span class="line">        &#125;</span><br><span class="line">        nums = <span class="built_in">to_string</span>(cur);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">length</span>(); i ++) &#123;</span><br><span class="line">            chars[pointer++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pointer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode445-Add-Two-Numbers-II"><a href="#Leetcode445-Add-Two-Numbers-II" class="headerlink" title="Leetcode445. Add Two Numbers II"></a>Leetcode445. Add Two Numbers II</h1><p>You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 = [7,2,4,3], l2 = [5,6,4]</span><br><span class="line">Output: [7,8,0,7]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">Output: [8,0,7]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 = [0], l2 = [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure></p>
<p>由于加法需要从最低位开始运算，而最低位在链表末尾，链表只能从前往后遍历，没法取到前面的元素，那怎么办呢？我们可以利用栈来保存所有的元素，然后利用栈的后进先出的特点就可以从后往前取数字了，我们首先遍历两个链表，将所有数字分别压入两个栈s1和s2中，我们建立一个值为0的res节点，然后开始循环，如果栈不为空，则将栈顶数字加入sum中，然后将res节点值赋为sum%10，然后新建一个进位节点head，赋值为sum/10，如果没有进位，那么就是0，然后我们head后面连上res，将res指向head，这样循环退出后，我们只要看res的值是否为0，为0返回res-&gt;next，不为0则返回res即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s1, s2;</span><br><span class="line">        ListNode *head = l1;</span><br><span class="line">        <span class="keyword">while</span>(head) &#123;</span><br><span class="line">            s<span class="number">1.</span><span class="built_in">push</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = l2;</span><br><span class="line">        <span class="keyword">while</span>(head) &#123;</span><br><span class="line">            s<span class="number">2.</span><span class="built_in">push</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s<span class="number">1.</span><span class="built_in">empty</span>() || !s<span class="number">2.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!s<span class="number">1.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">                sum += s<span class="number">1.</span><span class="built_in">top</span>();</span><br><span class="line">                s<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!s<span class="number">2.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">                sum += s<span class="number">2.</span><span class="built_in">top</span>();</span><br><span class="line">                s<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>, head);</span><br><span class="line">            sum /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">            head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum, head);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode447-Number-of-Boomerangs"><a href="#Leetcode447-Number-of-Boomerangs" class="headerlink" title="Leetcode447. Number of Boomerangs"></a>Leetcode447. Number of Boomerangs</h1><p>Given n points in the plane that are all pairwise distinct, a “boomerang” is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).</p>
<p>Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,0],[1,0],[2,0]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]</span><br></pre></td></tr></table></figure><br>给定 n 个两两各不相同的平面上的点，一个 “回旋镖” 是一个元组（tuple）的点（i,j,k），并且 i 和 j 的距离等于 i 和 k之间的距离（考虑顺序）。找出回旋镖的个数。你可以假设 n 不大于500，点的坐标范围在[-10000, 10000]（包括边界）。</p>
<p>抓住两组点 (x1,y1)、(x2,y2) 和 (x1,y1)、(x3,y3) 之间的距离相等这个信息：<code>distance = sqrt&#123;(x1-x2)^2+(y1-y2)^2&#125; = sqrt&#123;(x1-x3)^2+(y1-y3)^2&#125;</code></p>
<p>按照这种相等的距离，我们可以给所有点进行分类，相同距离的这些点（假设n个）可以构成一个排列组合中的排列：n*(n-1)个回旋镖。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfBoomerangs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;points.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                hash[<span class="built_in">pow</span>(points[i][<span class="number">0</span>]-points[j][<span class="number">0</span>],<span class="number">2</span>)+<span class="built_in">pow</span>(points[i][<span class="number">1</span>]-points[j][<span class="number">1</span>],<span class="number">2</span>)] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> d:hash)&#123;</span><br><span class="line">                ans += d.second*(d.second<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            hash.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode448-Find-All-Numbers-Disappeared-in-an-Array"><a href="#Leetcode448-Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="Leetcode448. Find All Numbers Disappeared in an Array"></a>Leetcode448. Find All Numbers Disappeared in an Array</h1><p>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><br>这道题让我们找出数组中所有消失的数，将nums[i]置换到其对应的位置nums[nums[i]-1]上去，比如对于没有缺失项的正确的顺序应该是[1, 2, 3, 4, 5, 6, 7, 8]，而我们现在却是[4,3,2,7,8,2,3,1]，我们需要把数字移动到正确的位置上去，比如第一个4就应该和7先交换个位置，以此类推，最后得到的顺序应该是[1, 2, 3, 4, 3, 2, 7, 8]，我们最后在对应位置检验，如果nums[i]和i+1不等，那么我们将i+1存入结果res中即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">                --i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode449-Serialize-and-Deserialize-BST"><a href="#Leetcode449-Serialize-and-Deserialize-BST" class="headerlink" title="Leetcode449. Serialize and Deserialize BST"></a>Leetcode449. Serialize and Deserialize BST</h1><p>Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.</p>
<p>The encoded string should be as compact as possible.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [2,1,3]</span><br><span class="line">Output: [2,1,3]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>The number of nodes in the tree is in the range [0, 104].</li>
<li>0 &lt;= Node.val &lt;= 104</li>
<li>The input tree is guaranteed to be a binary search tree.</li>
</ul>
<p>用队列来做，比较慢，但是很原生且具有通用性：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* temp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (temp) &#123;</span><br><span class="line">                res += <span class="built_in">to_string</span>(temp-&gt;val) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                q.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res += <span class="string">&quot;# &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">get_num</span>(data, pos));</span><br><span class="line">        pos ++;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* temp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (data[pos] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                temp-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">                pos ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                temp-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">get_num</span>(data, pos));</span><br><span class="line">                q.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            pos ++;</span><br><span class="line">            <span class="keyword">if</span> (data[pos] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                temp-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">                pos ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                temp-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">get_num</span>(data, pos));</span><br><span class="line">                q.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            pos ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">(string data, <span class="type">int</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(data[pos] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            res = res * <span class="number">10</span> + data[pos++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>层序遍历的非递归解法略微复杂一些，我们需要借助queue来做，本质是BFS算法，也不是很难理解，就是BFS算法的常规套路稍作修改即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        ostringstream os;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (t) &#123;</span><br><span class="line">            os &lt;&lt; t-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">            q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                os &lt;&lt; <span class="string">&quot;# &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> os.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="function">istringstream <span class="title">is</span><span class="params">(data)</span></span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        string val = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        is &gt;&gt; val;</span><br><span class="line">        TreeNode *res = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(val)), *cur = res;</span><br><span class="line">        q.<span class="built_in">push</span>(cur);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!(is &gt;&gt; val)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (val != <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">                cur = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(val));</span><br><span class="line">                q.<span class="built_in">push</span>(cur);</span><br><span class="line">                t-&gt;left = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!(is &gt;&gt; val)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (val != <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">                cur = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(val));</span><br><span class="line">                q.<span class="built_in">push</span>(cur);</span><br><span class="line">                t-&gt;right = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode450-Delete-Node-in-a-BST"><a href="#Leetcode450-Delete-Node-in-a-BST" class="headerlink" title="Leetcode450. Delete Node in a BST"></a>Leetcode450. Delete Node in a BST</h1><p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p>
<p>Basically, the deletion can be divided into two stages:</p>
<p>Search for a node to remove.<br>If the node is found, delete the node.<br>Follow up: Can you solve it with time complexity O(height of tree)?</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,3,6,2,4,null,7], key = 3</span><br><span class="line">Output: [5,4,6,2,null,null,7]</span><br><span class="line">Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.</span><br><span class="line">One valid answer is [5,4,6,2,null,null,7], shown in the above BST.</span><br><span class="line">Please notice that another valid answer is [5,2,6,null,4,null,7] and it&#x27;s also accepted.</span><br></pre></td></tr></table></figure><br><img src="/img/20210707103800.jpg" alt=""></p>
<p>这道题让我们删除二叉搜索树中的一个节点，难点在于删除完结点并补上那个结点的位置后还应该是一棵二叉搜索树。被删除掉的结点位置，不一定是由其的左右子结点补上，比如下面这棵树：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     7</span><br><span class="line">    / \</span><br><span class="line">   4   8</span><br><span class="line"> /   \   </span><br><span class="line">2     6</span><br><span class="line"> \   /</span><br><span class="line">  3 5</span><br></pre></td></tr></table></figure><br>如果要删除结点4，那么应该将结点5补到4的位置，这样才能保证还是 BST，那么结果是如下这棵树：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     7</span><br><span class="line">    / \</span><br><span class="line">   5   8</span><br><span class="line"> /   \   </span><br><span class="line">2     6</span><br><span class="line"> \   </span><br><span class="line">  3</span><br></pre></td></tr></table></figure><br>先来看一种递归的解法，首先判断根节点是否为空。由于 BST 的左&lt;根&lt;右的性质，使得可以快速定位到要删除的结点，对于当前结点值不等于 key 的情况，根据大小关系对其左右子结点分别调用递归函数。若当前结点就是要删除的结点，先判断若有一个子结点不存在，就将 root 指向另一个结点，如果左右子结点都不存在，那么 root 就赋值为空了，也正确。难点就在于处理左右子结点都存在的情况，需要在右子树找到最小值，即右子树中最左下方的结点，然后将该最小值赋值给 root，然后再在右子树中调用递归函数来删除这个值最小的结点，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; key)</span><br><span class="line">            root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; key)</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!root-&gt;left || !root-&gt;right)</span><br><span class="line">                root = root-&gt;left ? root-&gt;left : root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode* cur = root-&gt;right;</span><br><span class="line">                <span class="keyword">while</span>(cur-&gt;left)</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                root-&gt;val = cur-&gt;val;</span><br><span class="line">                root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, cur-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode451-Sort-Characters-By-Frequency"><a href="#Leetcode451-Sort-Characters-By-Frequency" class="headerlink" title="Leetcode451. Sort Characters By Frequency"></a>Leetcode451. Sort Characters By Frequency</h1><p>Given a string s, sort it in decreasing order based on the frequency of characters, and return the sorted string.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;tree&quot;</span><br><span class="line">Output: &quot;eert&quot;</span><br><span class="line">Explanation: &#x27;e&#x27; appears twice while &#x27;r&#x27; and &#x27;t&#x27; both appear once.</span><br><span class="line">So &#x27;e&#x27; must appear before both &#x27;r&#x27; and &#x27;t&#x27;. Therefore &quot;eetr&quot; is also a valid answer.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;cccaaa&quot;</span><br><span class="line">Output: &quot;aaaccc&quot;</span><br><span class="line">Explanation: Both &#x27;c&#x27; and &#x27;a&#x27; appear three times, so &quot;aaaccc&quot; is also a valid answer.</span><br><span class="line">Note that &quot;cacaca&quot; is incorrect, as the same characters must be together.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;Aabb&quot;</span><br><span class="line">Output: &quot;bbAa&quot;</span><br><span class="line">Explanation: &quot;bbaA&quot; is also a valid answer, but &quot;Aabb&quot; is incorrect.</span><br><span class="line">Note that &#x27;A&#x27; and &#x27;a&#x27; are treated as two different characters.</span><br></pre></td></tr></table></figure></p>
<p>竟然还要区分大小写，还要排序，那map等结构就不能用了，直接用数组。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">comp</span><span class="params">(pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; a, pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second || a.second == b.second &amp;&amp; a.first &lt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">frequencySort</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) </span><br><span class="line">            count[c] ++;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), [&amp;](<span class="type">char</span> a, <span class="type">char</span> b)&#123;</span><br><span class="line">            <span class="keyword">return</span> count[a] &gt; count[b] || count[a] == count[b] &amp;&amp; a &lt; b;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode452-Minimum-Number-of-Arrows-to-Burst-Balloons"><a href="#Leetcode452-Minimum-Number-of-Arrows-to-Burst-Balloons" class="headerlink" title="Leetcode452. Minimum Number of Arrows to Burst Balloons"></a>Leetcode452. Minimum Number of Arrows to Burst Balloons</h1><p>There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.</p>
<p>An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[1,2],[3,4],[5,6],[7,8]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[1,2],[2,3],[3,4],[4,5]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一堆大小不等的气球，用区间范围来表示气球的大小，可能会有重叠区间。然后我们用最少的箭数来将所有的气球打爆。那么这道题是典型的用贪婪算法来做的题，因为局部最优解就等于全局最优解，我们首先给区间排序，我们不用特意去写排序比较函数，因为默认的对于pair的排序，就是按第一个数字升序排列，如果第一个数字相同，那么按第二个数字升序排列，这个就是我们需要的顺序，所以直接用即可。然后我们将res初始化为1，因为气球数量不为0，所以怎么也得先来一发啊，然后这一箭能覆盖的最远位置就是第一个气球的结束点，用变量end来表示。然后我们开始遍历剩下的气球，如果当前气球的开始点小于等于end，说明跟之前的气球有重合，之前那一箭也可以照顾到当前的气球，此时我们要更新end的位置，end更新为两个气球结束点之间较小的那个，这也是当前气球和之前气球的重合点，然后继续看后面的气球；如果某个气球的起始点大于end了，说明前面的箭无法覆盖到当前的气球，那么就得再来一发，既然又来了一发，那么我们此时就要把end设为当前气球的结束点了，这样贪婪算法遍历结束后就能得到最少的箭数了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">comp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), comp);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>, end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end &gt;= points[i][<span class="number">0</span>])</span><br><span class="line">                end = <span class="built_in">min</span>(end, points[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res ++;</span><br><span class="line">                end = points[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode453-Minimum-Moves-to-Equal-Array-Elements"><a href="#Leetcode453-Minimum-Moves-to-Equal-Array-Elements" class="headerlink" title="Leetcode453. Minimum Moves to Equal Array Elements"></a>Leetcode453. Minimum Moves to Equal Array Elements</h1><p>Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[1,2,3]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Only three moves are needed (remember each move increments two elements):</span><br><span class="line">	[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个长度为n的数组，说是每次可以对 n-1 个数字同时加1，问最少需要多少次这样的操作才能让数组中所有的数字相等。那么想，为了快速的缩小差距，该选择哪些数字加1呢，不难看出每次需要给除了数组最大值的所有数字加1，这样能快速的到达平衡状态。但是这道题如果老老实实的每次找出最大值，然后给其他数字加1，再判断是否平衡，思路是正确，但是 OJ 不答应。正确的解法相当的巧妙，需要换一个角度来看问题，其实给 n-1 个数字加1，效果等同于给那个未被选中的数字减1，比如数组 [1，2，3]，给除去最大值的其他数字加1，变为 [2，3，3]，全体减1，并不影响数字间相对差异，变为 [1，2，2]，这个结果其实就是原始数组的最大值3自减1，那么问题也可能转化为，将所有数字都减小到最小值，这样难度就大大降低了，只要先找到最小值，然后累加每个数跟最小值之间的差值即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMoves</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> minn = INT_MAX, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums)</span><br><span class="line">            minn = <span class="built_in">min</span>(minn, i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums) </span><br><span class="line">            res += (i - minn);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode454-4Sum-II"><a href="#Leetcode454-4Sum-II" class="headerlink" title="Leetcode454. 4Sum II"></a>Leetcode454. 4Sum II</h1><p>Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:</p>
<ul>
<li>0 &lt;= i, j, k, l &lt; n</li>
<li>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</li>
</ul>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Explanation: The two tuples are:</p>
<ol>
<li>(0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0</li>
<li>(1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0</li>
</ol>
<p>这道题是之前那道 4Sum 的延伸，让我们在四个数组中各取一个数字，使其和为0。如果把A和B的两两之和都求出来，在 HashMap 中建立两数之和跟其出现次数之间的映射，那么再遍历C和D中任意两个数之和，只要看哈希表存不存在这两数之和的相反数就行了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mab, mcd;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                mab[nums1[i]+nums2[j]] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                res += mab[-nums3[i]-nums4[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>用两个 HashMap 分别记录 AB 和 CB 的两两之和出现次数，然后遍历其中一个 HashMap，并在另一个 HashMap 中找和的相反数出现的次数，更方便，但更慢。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mab, mcd;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                mab[nums1[i]+nums2[j]] ++;</span><br><span class="line">                mcd[nums3[i]+nums4[j]] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : mab)</span><br><span class="line">            res += (i.second * mcd[-i.first]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; index1,index2,index3;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; index4;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nums<span class="number">4.</span><span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            index1[nums1[i]]++;</span><br><span class="line">            index2[nums2[i]]++;</span><br><span class="line">            index3[nums3[i]]++;</span><br><span class="line">            index4[nums4[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; sums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp; it3 : index3)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp; it4 : index4)</span><br><span class="line">                sums[it<span class="number">3.f</span>irst+it<span class="number">4.f</span>irst] += it<span class="number">3.</span>second*it<span class="number">4.</span>second;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it1 = index<span class="number">1.</span><span class="built_in">begin</span>(); it1 != index<span class="number">1.</span><span class="built_in">end</span>(); ++it1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it2 = index<span class="number">2.</span><span class="built_in">begin</span>(); it2 != index<span class="number">2.</span><span class="built_in">end</span>(); ++it2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">long</span> t2 =  (<span class="type">long</span>) it1-&gt;first + (<span class="type">long</span>) it2-&gt;first;</span><br><span class="line">                <span class="type">int</span> ct2 =  it1-&gt;second * it2-&gt;second;</span><br><span class="line">                <span class="keyword">auto</span> pos = sums.<span class="built_in">find</span>(-t2);</span><br><span class="line">                <span class="keyword">if</span> (pos == sums.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                count += pos-&gt;second*ct2;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode455-Assign-Cookies"><a href="#Leetcode455-Assign-Cookies" class="headerlink" title="Leetcode455. Assign Cookies"></a>Leetcode455. Assign Cookies</h1><p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</p>
<p>Note:<br>You may assume the greed factor is always positive.<br>You cannot assign more than one cookie to one child.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3], [1,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. </span><br><span class="line">And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.</span><br><span class="line">You need to output 1.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2], [1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. </span><br><span class="line">You have 3 cookies and their sizes are big enough to gratify all of the children, </span><br><span class="line">	You need to output 2.</span><br></pre></td></tr></table></figure><br>有一堆饼干和一堆孩子，每个饼干大小为s[j]，每个孩子想要的大小为g[i]，求这堆饼干能满足至多多少个孩子？<br>很容易想到，每个孩子尽量拿到和他想要的大小差距最小的饼干，就能保证不会“浪费”大块饼干。因此把g和s排序后，把最相邻的饼干分给刚刚好满足的孩子，就能得到最大的满足数量了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; g.<span class="built_in">size</span>() &amp;&amp; j &lt; s.<span class="built_in">size</span>(); j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j] &gt;= g[i]) &#123;</span><br><span class="line">                count ++;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode456-132-Pattern"><a href="#Leetcode456-132-Pattern" class="headerlink" title="Leetcode456. 132 Pattern"></a>Leetcode456. 132 Pattern</h1><p>Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &lt; j &lt; k and nums[i] &lt; nums[k] &lt; nums[j].</p>
<p>Return true if there is a 132 pattern in nums, otherwise, return false.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no 132 pattern in the sequence.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [3,1,4,2]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a 132 pattern in the sequence: [1, 4, 2].</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-1,3,2,0]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].</span><br></pre></td></tr></table></figure></p>
<p>思路是维护一个栈和一个变量 third，其中 third 就是第三个数字，也是 pattern 132 中的2，初始化为整型最小值，栈里面按顺序放所有大于 third 的数字，也是 pattern 132 中的3，那么在遍历的时候，如果当前数字小于 third，即 pattern 132 中的1找到了，直接返回 true 即可，因为已经找到了，注意应该从后往前遍历数组。如果当前数字大于栈顶元素，那么将栈顶数字取出，赋值给 third，然后将该数字压入栈，这样保证了栈里的元素仍然都是大于 third 的，想要的顺序依旧存在，进一步来说，栈里存放的都是可以维持坐标 second &gt; third 的 second 值，其中的任何一个值都是大于当前的 third 值，如果有更大的值进来，那就等于形成了一个更优的 second &gt; third 的这样一个组合，并且这时弹出的 third 值比以前的 third 值更大，为什么要保证 third 值更大，因为这样才可以更容易的满足当前的值 first 比 third 值小这个条件，举个例子来说吧，比如 [2, 4, 2, 3, 5]，由于是从后往前遍历，所以后三个数都不会进入 while 循环，那么栈中的数字为 5, 3, 2（其中2为栈顶元素），此时 third 还是整型最小，那么当遍历到4的时候，终于4大于栈顶元素2了，那么 third 赋值为2，且2出栈。此时继续 while 循环，因为4还是大于新栈顶元素3，此时 third 赋值为3，且3出栈。现在栈顶元素是5，那么 while 循环结束，将4压入栈。下一个数字2，小于 third，则找到符合要求的序列 [2, 4, 3]，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find132pattern</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), third = INT_MIN;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; third)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; s.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                third = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode459-Repeated-Substring-Pattern"><a href="#Leetcode459-Repeated-Substring-Pattern" class="headerlink" title="Leetcode459. Repeated Substring Pattern"></a>Leetcode459. Repeated Substring Pattern</h1><p>Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abab&quot;</span><br><span class="line">Output: True</span><br><span class="line">Explanation: It&#x27;s the substring &quot;ab&quot; twice.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aba&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcabcabcabc&quot;</span><br><span class="line">Output: True</span><br><span class="line">Explanation: It&#x27;s the substring &quot;abc&quot; four times. (And the substring &quot;abcabc&quot; twice.)</span><br></pre></td></tr></table></figure><br>传统方法，挨个子字符串对比<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="type">int</span> length = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= length/<span class="number">2</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(length % i)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            temp = s.<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">            temp = <span class="built_in">gen</span>(temp, length/i);</span><br><span class="line">            <span class="keyword">if</span>(temp == s)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">gen</span><span class="params">(string temp, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(i--)</span><br><span class="line">            ans += temp;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>另一种做法，用dp。维护的一位数组dp[i]表示，到位置i-1为止的重复字符串的字符个数，不包括被重复的那个字符串，什么意思呢，我们举个例子，比如”abcabc”的dp数组为[0 0 0 0 1 2 3]，dp数组长度要比原字符串长度多一个。那么我们看最后一个位置数字为3，就表示重复的字符串的字符数有3个。如果是”abcabcabc”，那么dp数组为[0 0 0 0 1 2 3 4 5 6]，我们发现最后一个数字为6，那么表示重复的字符串为“abcabc”，有6个字符。那么怎么通过最后一个数字来知道原字符串是否由重复的子字符串组成的呢，首先当然是最后一个数字不能为0，而且还要满足dp[n] % (n - dp[n]) == 0才行，因为n - dp[n]是一个子字符串的长度，那么重复字符串的长度和肯定是一个子字符串的整数倍。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n<span class="number">+1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])</span><br><span class="line">                dp[++i] = ++j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                i ++;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                j = dp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n] &amp;&amp; (dp[n] % (n - dp[n]) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode461-Hamming-Distance"><a href="#Leetcode461-Hamming-Distance" class="headerlink" title="Leetcode461. Hamming Distance"></a>Leetcode461. Hamming Distance</h1><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance.</p>
<p>Note:<br>0 ≤ x, y &lt; 231.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: x = 1, y = 4</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">      ↑   ↑</span><br></pre></td></tr></table></figure><br>The above arrows point to positions where the corresponding bits are different.</p>
<p>求两个数的海明距离，就是判断其二进制有多少不一样的位<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> temp = x ^ y;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=temp;i&gt;<span class="number">0</span>;i=i&gt;&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>) res++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode462-Minimum-Moves-to-Equal-Array-Elements-II"><a href="#Leetcode462-Minimum-Moves-to-Equal-Array-Elements-II" class="headerlink" title="Leetcode462. Minimum Moves to Equal Array Elements II"></a>Leetcode462. Minimum Moves to Equal Array Elements II</h1><p>Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.</p>
<p>In one move, you can increment or decrement an element of the array by 1.</p>
<p>Test cases are designed so that the answer will fit in a 32-bit integer.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">Only two moves are needed (remember each move increments or decrements one element):</span><br><span class="line">[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,10,2,9]</span><br><span class="line">Output: 16</span><br></pre></td></tr></table></figure></p>
<p>这道题每次对任意一个数字加1或者减1，让我们用最少的次数让数组所有值相等。首先给数组排序，最终需要变成的相等的数字就是中间的数，如果数组有奇数个，那么就是最中间的那个数字；如果是偶数个，那么就是中间两个数的区间中的任意一个数字。而两端的数字变成中间的一个数字需要的步数实际上就是两端数字的距离。参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMoves2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = (<span class="type">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            res += nums[j--] - nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>既然有了上面的分析，我们知道实际上最后相等的数字就是数组的最中间的那个数字，那么我们在给数组排序后，直接利用坐标定位到中间的数字，然后算数组中每个数组与其的差的绝对值累加即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMoves2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, mid = nums[nums.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            res += <span class="built_in">abs</span>(num - mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的两种方法都给整个数组排序了，时间复杂度是O(nlgn)，其实我们并不需要给所有的数字排序，我们只关系最中间的数字，那么这个stl中自带的函数<code>nth_element</code>就可以完美的发挥其作用了，我们只要给出我们想要数字的位置，它就能在O(n)的时间内返回正确的数字，然后算数组中每个数组与其的差的绝对值累加即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMoves2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = nums.<span class="built_in">size</span>(), mid = n / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">nth_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + mid, nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res += <span class="built_in">abs</span>(nums[i] - nums[mid]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode463-Island-Perimeter"><a href="#Leetcode463-Island-Perimeter" class="headerlink" title="Leetcode463. Island Perimeter"></a>Leetcode463. Island Perimeter</h1><p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water.</p>
<p>Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).</p>
<p>The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[0,1,0,0],</span><br><span class="line"> [1,1,1,0],</span><br><span class="line"> [0,1,0,0],</span><br><span class="line"> [1,1,0,0]]</span><br><span class="line"></span><br><span class="line">Output: 16</span><br></pre></td></tr></table></figure><br>Explanation: The perimeter is the 16 yellow stripes in the image below:<br><img src="/img/20200617105700.png" alt=""></p>
<p>看一共有几条边，对每个格子进行遍历。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">islandPerimeter</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!grid[i][j])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                temp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span> || (j &gt; <span class="number">0</span> &amp;&amp; !grid[i][j<span class="number">-1</span>])) temp ++;</span><br><span class="line">                <span class="keyword">if</span>(j == n<span class="number">-1</span> || (j &lt; n<span class="number">-1</span> &amp;&amp; !grid[i][j<span class="number">+1</span>])) temp ++;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || (i &gt; <span class="number">0</span> &amp;&amp; !grid[i<span class="number">-1</span>][j])) temp ++;</span><br><span class="line">                <span class="keyword">if</span>(i == m<span class="number">-1</span> || (i &lt; m<span class="number">-1</span> &amp;&amp; !grid[i<span class="number">+1</span>][j])) temp ++;</span><br><span class="line">                </span><br><span class="line">                ans += temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode464-Can-I-Win"><a href="#Leetcode464-Can-I-Win" class="headerlink" title="Leetcode464. Can I Win"></a>Leetcode464. Can I Win</h1><p>In the “100 game,” two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.</p>
<p>What if we change the game so that players cannot re-use integers?</p>
<p>For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total &gt;= 100.</p>
<p>Given an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally.</p>
<p>You can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.</p>
<p>Example<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">maxChoosableInteger = 10</span><br><span class="line">desiredTotal = 11</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">No matter which integer the first player choose, the first player will lose.</span><br><span class="line">The first player can choose an integer from 1 up to 10.</span><br><span class="line">If the first player choose 1, the second player can only choose integers from 2 up to 10.</span><br><span class="line">The second player will win by choosing 10 and get a total = 11, which is &gt;= desiredTotal.</span><br><span class="line">Same with other integers chosen by the first player, the second player will always win.</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一堆数字，然后两个人，每人每次选一个数字，看数字总数谁先到给定值，有点像之前那道 Nim Game，但是比那题难度大。我刚开始想肯定说用递归啊，结果写完发现 TLE 了，后来发现我们必须要优化效率，使用 HashMap 来记录已经计算过的结果。我们首先来看如果给定的数字范围大于等于目标值的话，直接返回 true。如果给定的数字总和小于目标值的话，说明谁也没法赢，返回 false。然后我们进入递归函数，首先我们查找当前情况是否在 HashMap 中存在，有的话直接返回即可。我们使用一个整型数按位来记录数组中的某个数字是否使用过，我们遍历所有数字，将该数字对应的 mask 算出来，如果其和 used 相与为0的话，说明该数字没有使用过，我们看如果此时的目标值小于等于当前数字，说明已经赢了，或者调用递归函数，如果返回 false，说明也是第一个人赢了。为啥呢，因为当前已经选过数字了，此时就该对第二个人调用递归函数，只有返回的结果是 false，我们才能赢，所以此时我们 true，并返回 true。如果遍历完所有数字，标记 false，并返回 false，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canIWin</span><span class="params">(<span class="type">int</span> maxChoosableInteger, <span class="type">int</span> desiredTotal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxChoosableInteger &gt;= desiredTotal) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (maxChoosableInteger * (maxChoosableInteger + <span class="number">1</span>) / <span class="number">2</span> &lt; desiredTotal) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; m;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">canWin</span>(maxChoosableInteger, desiredTotal, <span class="number">0</span>, m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canWin</span><span class="params">(<span class="type">int</span> length, <span class="type">int</span> total, <span class="type">int</span> used, unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt;&amp; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.<span class="built_in">count</span>(used)) <span class="keyword">return</span> m[used];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> cur = (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="keyword">if</span> ((cur &amp; used) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (total &lt;= i + <span class="number">1</span> || !<span class="built_in">canWin</span>(length, total - (i + <span class="number">1</span>), cur | used, m)) &#123;</span><br><span class="line">                    m[used] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m[used] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode467-Unique-Substrings-in-Wraparound-String"><a href="#Leetcode467-Unique-Substrings-in-Wraparound-String" class="headerlink" title="Leetcode467. Unique Substrings in Wraparound String"></a>Leetcode467. Unique Substrings in Wraparound String</h1><p>Consider the string s to be the infinite wraparound string of “abcdefghijklmnopqrstuvwxyz”, so s will look like this: “…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….”.</p>
<p>Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s.</p>
<p>Note: p consists of only lowercase English letters and the size of p might be over 10000.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;a&quot;</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation: Only the substring &quot;a&quot; of string &quot;a&quot; is in the string s.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;cac&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two substrings &quot;a&quot;, &quot;c&quot; of string &quot;cac&quot; in the string s.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;zab&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: There are six substrings &quot;z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;za&quot;, &quot;ab&quot;, &quot;zab&quot; of string &quot;zab&quot; in the string s.</span><br></pre></td></tr></table></figure></p>
<p>这道题说有一个无限长的封装字符串，然后又给了我们另一个字符串p，问我们p有多少非空子字符串在封装字符串中。我们通过观察题目中的例子可以发现，由于封装字符串是26个字符按顺序无限循环组成的，那么满足题意的p的子字符串要么是单一的字符，要么是按字母顺序的子字符串。这道题遍历p的所有子字符串会TLE，因为如果p很大的话，子字符串很多，会有大量的满足题意的重复子字符串，必须要用到trick，而所谓技巧就是一般来说你想不到的方法。我们看abcd这个字符串，以d结尾的子字符串有abcd, bcd, cd, d，那么我们可以发现bcd或者cd这些以d结尾的字符串的子字符串都包含在abcd中，那么我们知道以某个字符结束的最大字符串包含其他以该字符结束的字符串的所有子字符串，说起来很拗口，但是理解了我上面举的例子就行。那么题目就可以转换为分别求出以每个字符(a-z)为结束字符的最长连续字符串就行了，我们用一个数组cnt记录下来，最后在求出数组cnt的所有数字之和就是我们要的结果啦，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findSubstringInWraproundString</span><span class="params">(string p)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (p[i] == p[i - <span class="number">1</span>] + <span class="number">1</span> || p[i - <span class="number">1</span>] - p[i] == <span class="number">25</span>)) &#123;</span><br><span class="line">                ++len;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                len = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[p[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="built_in">max</span>(cnt[p[i] - <span class="string">&#x27;a&#x27;</span>], len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(cnt.<span class="built_in">begin</span>(), cnt.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode468-Validate-IP-Address"><a href="#Leetcode468-Validate-IP-Address" class="headerlink" title="Leetcode468. Validate IP Address"></a>Leetcode468. Validate IP Address</h1><p>Given a string IP, return “IPv4” if IP is a valid IPv4 address, “IPv6” if IP is a valid IPv6 address or “Neither” if IP is not a correct IP of any type.</p>
<p>A valid IPv4 address is an IP in the form “x1.x2.x3.x4” where 0 &lt;= xi &lt;= 255 and xi cannot contain leading zeros. For example, “192.168.1.1” and “192.168.1.0” are valid IPv4 addresses but “192.168.01.1”, while “192.168.1.00” and “192.168@1.1” are invalid IPv4 addresses.</p>
<p>A valid IPv6 address is an IP in the form “x1:x2:x3:x4:x5:x6:x7:x8” where:</p>
<ul>
<li>1 &lt;= xi.length &lt;= 4</li>
<li>xi is a hexadecimal string which may contain digits, lower-case English letter (‘a’ to ‘f’) and upper-case English letters (‘A’ to ‘F’).</li>
<li>Leading zeros are allowed in xi.</li>
</ul>
<p>For example, “2001:0db8:85a3:0000:0000:8a2e:0370:7334” and “2001:db8:85a3:0:0:8A2E:0370:7334” are valid IPv6 addresses, while “2001:0db8:85a3::8A2E:037j:7334” and “02001:0db8:85a3:0000:0000:8a2e:0370:7334” are invalid IPv6 addresses.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: IP = &quot;172.16.254.1&quot;</span><br><span class="line">Output: &quot;IPv4&quot;</span><br><span class="line">Explanation: This is a valid IPv4 address, return &quot;IPv4&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: IP = &quot;2001:0db8:85a3:0:0:8A2E:0370:7334&quot;</span><br><span class="line">Output: &quot;IPv6&quot;</span><br><span class="line">Explanation: This is a valid IPv6 address, return &quot;IPv6&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: IP = &quot;256.256.256.256&quot;</span><br><span class="line">Output: &quot;Neither&quot;</span><br><span class="line">Explanation: This is neither a IPv4 address nor a IPv6 address.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: IP = &quot;2001:0db8:85a3:0:0:8A2E:0370:7334:&quot;</span><br><span class="line">Output: &quot;Neither&quot;</span><br></pre></td></tr></table></figure></p>
<p>巨难搞，就跟判断一个数是不是合法一样。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_number</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_char</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;F&#x27;</span>) || (<span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">validIPAddress</span><span class="params">(string IP)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isv4</span>(IP))</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;IPv4&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isv6</span>(IP))</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;IPv6&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isv4</span><span class="params">(string IP)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = IP.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> num_points = <span class="number">0</span>, number = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> is_begin = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">255</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (IP[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                num_points ++;</span><br><span class="line">                number = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (is_begin)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                is_begin = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">is_number</span>(IP[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; len<span class="number">-1</span> &amp;&amp; is_begin &amp;&amp; IP[i<span class="number">+1</span>] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; IP[i] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                is_begin = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; IP[i] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; IP[i<span class="number">-1</span>] == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                number = number * <span class="number">10</span> + IP[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">255</span> || num_points != <span class="number">3</span> || IP[len<span class="number">-1</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isv6</span><span class="params">(string IP)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = IP.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> num_points = <span class="number">0</span>, number = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> is_begin = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (IP[i] == <span class="string">&#x27;:&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (number &gt; <span class="number">4</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                num_points ++;</span><br><span class="line">                number = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (is_begin)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                is_begin = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                is_begin = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (!(<span class="built_in">is_number</span>(IP[i]) || <span class="built_in">is_char</span>(IP[i])) )</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                number ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num_points != <span class="number">7</span> || number &gt; <span class="number">4</span> || IP[len<span class="number">-1</span>] == <span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>内存占用最小的提交：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;Ofast&quot;</span>)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">auto</span> _ = [] () &#123;ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">validIPAddress</span><span class="params">(string <span class="type">const</span>&amp; IP)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">bool</span> isV6 = IP.<span class="built_in">find</span>(<span class="string">&#x27;:&#x27;</span>) != string::npos;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isV6) &#123;  <span class="comment">// Try to parse ipv6 </span></span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>, segments = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">auto</span> isValidHex = [](<span class="type">char</span> c) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">isdigit</span>(c) ||</span><br><span class="line">                    (<span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>) ||</span><br><span class="line">                    (<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> ptr = <span class="number">-1</span>, size = IP.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (ptr &lt; size &amp;&amp; segments &lt; <span class="number">8</span>) &#123;</span><br><span class="line">                ++ptr; <span class="comment">// skip leading &#x27;:&#x27;</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span> (ptr &lt; size &amp;&amp; IP[ptr] != <span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isValidHex</span>(IP[ptr]))</span><br><span class="line">                    ++ptr, ++count;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span> || count &gt; <span class="number">4</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    count = <span class="number">0</span>,</span><br><span class="line">                    ++segments;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (ptr == IP.<span class="built_in">size</span>() &amp;&amp; segments == <span class="number">8</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;IPv6&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// Try to parse ipv4 </span></span><br><span class="line">            <span class="type">int</span> segments = <span class="number">0</span>, number = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> ptr = <span class="number">-1</span>, size = IP.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (ptr &lt; size &amp;&amp; segments &lt; <span class="number">4</span>) &#123;</span><br><span class="line">                ++ptr; <span class="comment">// skip initial dot</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (ptr &lt; size &amp;&amp; IP[ptr] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    ++segments;</span><br><span class="line">                    ++ptr;</span><br><span class="line">                    <span class="keyword">if</span> (ptr == size || IP[ptr] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (ptr &lt; size &amp;&amp; IP[ptr] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                    <span class="keyword">if</span> (number &lt; <span class="number">250</span> &amp;&amp; <span class="built_in">isdigit</span>(IP[ptr])) &#123;</span><br><span class="line">                        ++count;</span><br><span class="line">                        number *= <span class="number">10</span>;</span><br><span class="line">                        number += IP[ptr] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        ++ptr;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &lt;= count &amp;&amp; count &lt;= <span class="number">4</span> &amp;&amp; <span class="number">1</span> &lt;= number &amp;&amp; number &lt;= <span class="number">255</span>) &#123;</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                    number = <span class="number">0</span>;</span><br><span class="line">                    ++segments;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (ptr == IP.<span class="built_in">size</span>() &amp;&amp; segments == <span class="number">4</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;IPv4&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode470-Implement-Rand10-Using-Rand7"><a href="#Leetcode470-Implement-Rand10-Using-Rand7" class="headerlink" title="Leetcode470. Implement Rand10() Using Rand7()"></a>Leetcode470. Implement Rand10() Using Rand7()</h1><p>Given the API rand7() that generates a uniform random integer in the range [1, 7], write a function rand10() that generates a uniform random integer in the range [1, 10]. You can only call the API rand7(), and you shouldn’t call any other API. Please do not use a language’s built-in random API.</p>
<p>Each test case will have one internal argument n, the number of times that your implemented function rand10() will be called while testing. Note that this is not an argument passed to rand10().</p>
<p>Follow up:</p>
<ul>
<li>What is the expected value for the number of calls to rand7() function?</li>
<li>Could you minimize the number of calls to rand7()?</li>
</ul>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: [2,8]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: [3,8,10]</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个随机生成 [1, 7] 内数字的函数<code>rand7()</code>，需要利用其来生成一个能随机生成 [1, 10] 内数字的函数<code>rand10()</code>，注意这里的随机生成的意思是等概率生成范围内的数字。这是一道很有意思的题目，由于<code>rand7()</code>只能生成1到7之间的数字，所以 8，9，10 这三个没法生成，那么怎么办？</p>
<p>大多数人可能第一个想法就是，再用一个呗，然后把两次的结果加起来，范围不就扩大了么，扩大成了 [2, 14] 之间，然后如果再减去1，范围不就是 [1, 13] 了么。想法不错，但是有个问题，这个范围内的每个数字生成的概率不是都相等的，为啥这么说呢，我们来举个简单的例子看下，就比如说<code>rand2()</code>，我们知道其可以生成两个数字1和2，且每个的概率都是 1/2。那么对于<code>(rand2() - 1) +</code>rand2()``呢，看一下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rand2() - 1 + rand()2  =   ?</span><br><span class="line">   1            1          1</span><br><span class="line">   1            2          2</span><br><span class="line">   2            1          2</span><br><span class="line">   2            2          3</span><br></pre></td></tr></table></figure></p>
<p>我们发现，生成数字范围 [1, 3] 之间的数字并不是等概率大，其中2出现的概率为 1/2，1和3分别为 1/4。这就不随机了。问题出在哪里了呢，如果直接相加，不同组合可能会产生相同的数字，比如 1+2 和 2+1 都是3。所以需要给第一个<code>rand2()</code>升一个维度，让其乘上一个数字，再相加。比如对于<code>(rand2() - 1) * 2 +</code>rand2()``，如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（rand2() - 1） * 2 + rand()2  =   ?</span><br><span class="line">     1                  1         1</span><br><span class="line">     1                  2         2</span><br><span class="line">     2                  1         3</span><br><span class="line">     2                  2         4</span><br></pre></td></tr></table></figure></p>
<p>这时右边生成的 1，2，3，4 就是等概率出现的了。这样就通过使用<code>rand2()</code>，来生成<code>rand4()</code>了。那么反过来想一下，可以通过<code>rand4()</code>来生成<code>rand2()</code>，其实更加简单，我们只需通过<code>rand4() % 2 + 1</code>即可，如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rand4() % 2 + 1 =  ?</span><br><span class="line">   1               2</span><br><span class="line">   2               1</span><br><span class="line">   3               2</span><br><span class="line">   4               1</span><br></pre></td></tr></table></figure></p>
<p>同理，我们也可以通过<code>rand6()</code>来生成<code>rand2()</code>，我们只需通过<code>rand6() % 2 + 1</code>即可，如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rand6() % 2 + 1 =  ?</span><br><span class="line">  1               2</span><br><span class="line">  2               1</span><br><span class="line">  3               2</span><br><span class="line">  4               1</span><br><span class="line">  5               2</span><br><span class="line">  6               1</span><br></pre></td></tr></table></figure></p>
<p>所以，回到这道题，我们可以先凑出<code>rand10*N()</code>，然后再通过<code>rand10*N() % 10 + 1</code>来获得<code>rand10()</code>。那么，只需要将<code>rand7()</code>转化为<code>rand10*N()</code>即可，根据前面的讲解，我们转化也必须要保持等概率，那么就可以变化为<code>(rand7() - 1) * 7 + rand7()</code>，就转为了<code>rand49()</code>。但是 49 不是 10 的倍数，不过 49 包括好几个 10 的倍数，比如 40，30，20，10 等。这里，我们需要把<code>rand49()</code>转为<code>rand40()</code>，需要用到<strong>拒绝采样</strong>Rejection Sampling。这种采样方法就是随机到需要的数字就接受，不是需要的就拒绝，并重新采样，这样还能保持等概率。</p>
<p>当用 <code>rand49()</code>生成一个 [1, 49] 范围内的随机数，如果其在 [1, 40] 范围内，我们就将其转为<code>rand10()</code>范围内的数字，直接对 10 去余并加1，返回即可。如果不是，则继续循环即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> num = (<span class="built_in">rand7</span>() - <span class="number">1</span>) * <span class="number">7</span> + <span class="built_in">rand7</span>();</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= <span class="number">40</span>) <span class="keyword">return</span> num % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们可以不用 while 循环，而采用调用递归函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = (<span class="built_in">rand7</span>() - <span class="number">1</span>) * <span class="number">7</span> + <span class="built_in">rand7</span>();</span><br><span class="line">        <span class="keyword">return</span> (num &lt;= <span class="number">40</span>) ? (num % <span class="number">10</span> + <span class="number">1</span>) : <span class="built_in">rand10</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode472-Concatenated-Words"><a href="#Leetcode472-Concatenated-Words" class="headerlink" title="Leetcode472. Concatenated Words"></a>Leetcode472. Concatenated Words</h1><p>Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.</p>
<p>A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;cat&quot;,&quot;cats&quot;,&quot;catsdogcats&quot;,&quot;dog&quot;,&quot;dogcatsdog&quot;,&quot;hippopotamuses&quot;,&quot;rat&quot;,&quot;ratcatdogcat&quot;]</span><br><span class="line">Output: [&quot;catsdogcats&quot;,&quot;dogcatsdog&quot;,&quot;ratcatdogcat&quot;]</span><br><span class="line">Explanation: &quot;catsdogcats&quot; can be concatenated by &quot;cats&quot;, &quot;dog&quot; and &quot;cats&quot;; </span><br><span class="line">&quot;dogcatsdog&quot; can be concatenated by &quot;dog&quot;, &quot;cats&quot; and &quot;dog&quot;; </span><br><span class="line">&quot;ratcatdogcat&quot; can be concatenated by &quot;rat&quot;, &quot;cat&quot;, &quot;dog&quot; and &quot;cat&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;cat&quot;,&quot;dog&quot;,&quot;catdog&quot;]</span><br><span class="line">Output: [&quot;catdog&quot;]</span><br></pre></td></tr></table></figure></p>
<p>这道题给了一个由单词组成的数组，某些单词是可能由其他的单词组成的，让我们找出所有这样的单词。我们首先把所有单词都放到一个unordered_set中，这样可以快速找到某个单词是否在数组中存在。对于当前要判断的单词，我们先将其从set中删去，然后调用之前的Word Break的解法。如果是可以拆分，那么我们就存入结果res中，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findAllConcatenatedWordsInADict</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (words.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">dict</span><span class="params">(words.begin(), words.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            dict.<span class="built_in">erase</span>(words[i]);</span><br><span class="line">            <span class="type">int</span> len = words[i].<span class="built_in">size</span>();</span><br><span class="line">            <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">flag</span><span class="params">(len<span class="number">+1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">            flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= len; j ++) </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; j; k ++)</span><br><span class="line">                    <span class="keyword">if</span> (flag[k] &amp;&amp; dict.<span class="built_in">count</span>(words[i].<span class="built_in">substr</span>(k, j-k))) &#123;</span><br><span class="line">                        flag[j] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag[len])</span><br><span class="line">                res.<span class="built_in">push_back</span>(words[i]);</span><br><span class="line">            dict.<span class="built_in">insert</span>(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode473-Matchsticks-to-Square"><a href="#Leetcode473-Matchsticks-to-Square" class="headerlink" title="Leetcode473. Matchsticks to Square"></a>Leetcode473. Matchsticks to Square</h1><p>Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.</p>
<p>Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,2,2,2]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,3,3,3,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You cannot find a way to form a square with all the matchsticks.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>The length sum of the given matchsticks is in the range of 0 to 10^9.</li>
<li>The length of the given matchstick array will not exceed 15.</li>
</ul>
<p>这道题让我们用数组中的数字来摆出一个正方形。这道题实际上是让我们将一个数组分成四个和相等的子数组。可以用优化过的递归来解，递归的方法基本上等于brute force。先给数组从大到小的顺序排序，这样大的数字先加，如果超过target了，就直接跳过了后面的再次调用递归的操作，效率会提高不少。我们建立一个长度为4的数组sums来保存每个边的长度和，我们希望每条边都等于target，数组总和的四分之一。然后我们遍历sums中的每条边，我们判断如果加上数组中的当前数字大于target，那么我们跳过，如果没有，我们就加上这个数字，然后对数组中下一个位置调用递归，如果返回为真，我们返回true，否则我们再从sums中对应位置将这个数字减去继续循环，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">makesquare</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>() || nums.<span class="built_in">size</span>() &lt; <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">4</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sums</span><span class="params">(<span class="number">4</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">rbegin</span>(), nums.<span class="built_in">rend</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(nums, sums, <span class="number">0</span>, sum / <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; sums, <span class="type">int</span> pos, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> sums[<span class="number">0</span>] == target &amp;&amp; sums[<span class="number">1</span>] == target &amp;&amp; sums[<span class="number">2</span>] == target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sums[i] + nums[pos] &gt; target) <span class="keyword">continue</span>;</span><br><span class="line">            sums[i] += nums[pos];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">helper</span>(nums, sums, pos + <span class="number">1</span>, target)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            sums[i] -= nums[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode474-Ones-and-Zeroes"><a href="#Leetcode474-Ones-and-Zeroes" class="headerlink" title="Leetcode474. Ones and Zeroes"></a>Leetcode474. Ones and Zeroes</h1><p>In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.</p>
<p>For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.</p>
<p>Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.</p>
<p>Note:</p>
<ul>
<li>The given numbers of 0s and 1s will both not exceed 100</li>
<li>The size of given string array won’t exceed 600.</li>
</ul>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: Array = &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m = 5, n = 3</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: Array = &#123;&quot;10&quot;, &quot;0&quot;, &quot;1&quot;&#125;, m = 1, n = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You could form &quot;10&quot;, but then you&#x27;d have nothing left. Better form &quot;0&quot; and &quot;1&quot;.</span><br></pre></td></tr></table></figure></p>
<p>这道题是一道典型的应用DP来解的题，我们需要建立一个二维的DP数组，其中<code>dp[i][j]</code>表示有i个0和j个1时能组成的最多字符串的个数，而对于当前遍历到的字符串，我们统计出其中0和1的个数为zeros和ones，然后<code>dp[i - zeros][j - ones]</code>表示当前的i和j减去zeros和ones之前能拼成字符串的个数，那么加上当前的zeros和ones就是当前<code>dp[i][j]</code>可以达到的个数，我们跟其原有数值对比取较大值即可，所以递推式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1);</span><br></pre></td></tr></table></figure><br>有了递推式，我们就可以很容易的写出代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (string str : strs) &#123;</span><br><span class="line">            <span class="type">int</span> zeros = <span class="number">0</span>, ones = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : str) (c == <span class="string">&#x27;0&#x27;</span>) ? ++zeros : ++ones;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= zeros; --i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= ones; --j) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - zeros][j - ones] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode475-Heaters"><a href="#Leetcode475-Heaters" class="headerlink" title="Leetcode475. Heaters"></a>Leetcode475. Heaters</h1><p>Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses.</p>
<p>Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.</p>
<p>So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.</p>
<p>Note:</p>
<ul>
<li>Numbers of houses and heaters you are given are non-negative and will not exceed 25000.</li>
<li>Positions of houses and heaters you are given are non-negative and will not exceed 10^9.</li>
<li>As long as a house is in the heaters’ warm radius range, it can be warmed.</li>
<li>All the heaters follow your radius standard and the warm radius will the same.</li>
</ul>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3],[2]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4],[1,4]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.</span><br></pre></td></tr></table></figure><br>思路：</p>
<ol>
<li>先对houses和heaters排序，result记录全局最小温暖半径，temp记录当前house的最小温暖半径。</li>
<li>依次为每个house查找最小的温暖半径（显然，每个house的最小半径只需考虑其左边最近的heaters和右边最近的heaters）。</li>
<li>对每一个house先查找位置不小于其位置的第一个heater，其位置为j。</li>
<li>若未找到，则当前house的最小温暖半径由左边最近的heaters决定。</li>
<li>若第一个heater的位置就不小于当前house的位置，则当前house的最小温暖半径由右边最近的heaters决定。</li>
<li>若找到的位置不小于当前house位置的第一个heater的位置大于当前house位置（若等于，则当前house的最小温暖半径等于0），则当前house的最小温暖半径是其与左边最近的heaters的距离和其与右边最近的heaters的距离的较小值。</li>
<li>若当前house的最小温暖半径大于全局result，则更新result。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRadius</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; houses, vector&lt;<span class="type">int</span>&gt;&amp; heaters)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(houses.<span class="built_in">begin</span>(), houses.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(heaters.<span class="built_in">begin</span>(), heaters.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> house = <span class="number">0</span>, heater = <span class="number">0</span>; house &lt; houses.<span class="built_in">size</span>(); house ++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(heater &lt; heaters.<span class="built_in">size</span>() &amp;&amp; heaters[heater] &lt; houses[house])</span><br><span class="line">                heater ++;</span><br><span class="line">            <span class="keyword">if</span>(heater == heaters.<span class="built_in">size</span>())</span><br><span class="line">                temp = houses[house] - heaters[heaters.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(heater == <span class="number">0</span>)</span><br><span class="line">                temp = heaters[<span class="number">0</span>] - houses[house];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(heaters[heater] &gt; houses[house])</span><br><span class="line">                temp = <span class="built_in">min</span>(heaters[heater] - houses[house], houses[house] - heaters[heater<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(temp &gt; res)</span><br><span class="line">                res = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode476-Number-Complement"><a href="#Leetcode476-Number-Complement" class="headerlink" title="Leetcode476. Number Complement"></a>Leetcode476. Number Complement</h1><p>Given a positive integer num, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: num = 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: num = 1</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.</span><br></pre></td></tr></table></figure><br>给定一个正整数，对该数的二进制表示形式，从最高位的1开始向后按位取反。如果我们能知道该数最高位的1所在的位置，就可以构造一个长度和该数据所占位置一样长的一个掩码mask，然后概述和mask进行异或即可。例如：5的二进制是101，我们的构造的掩码为mask=111，两者异或则为010，即是所要的结果。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findComplement</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> mask = <span class="number">1</span>, temp = num;</span><br><span class="line">        <span class="keyword">while</span>(temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mask = mask &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            temp = temp &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num^(mask<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode477-Total-Hamming-Distance"><a href="#Leetcode477-Total-Hamming-Distance" class="headerlink" title="Leetcode477. Total Hamming Distance"></a>Leetcode477. Total Hamming Distance</h1><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>
<p>Given an integer array nums, return the sum of Hamming distances between all the pairs of the integers in nums.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,14,2]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just</span><br><span class="line">showing the four bits relevant in this case).</span><br><span class="line">The answer will be:</span><br><span class="line">HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,14,4]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>这道题是之前那道 Hamming Distance 的拓展，由于有之前那道题的经验，我们知道需要用异或来求每个位上的情况，那么需要来找出某种规律来，比如看下面这个例子，4，14，2 和1：</p>
<p>4:     0 1 0 0</p>
<p>14:   1 1 1 0</p>
<p>2:     0 0 1 0</p>
<p>1:     0 0 0 1</p>
<p>先看最后一列，有三个0和一个1，那么它们之间相互的汉明距离就是3，即1和其他三个0分别的距离累加，然后在看第三列，累加汉明距离为4，因为每个1都会跟两个0产生两个汉明距离，同理第二列也是4，第一列是3。仔细观察累计汉明距离和0跟1的个数，可以发现其实就是0的个数乘以1的个数，发现了这个重要的规律，那么整道题就迎刃而解了，只要统计出每一位的1的个数即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalHammingDistance</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &amp; (<span class="number">1</span> &lt;&lt; i)) ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            res += cnt * (n - cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode478-Generate-Random-Point-in-a-Circle"><a href="#Leetcode478-Generate-Random-Point-in-a-Circle" class="headerlink" title="Leetcode478. Generate Random Point in a Circle"></a>Leetcode478. Generate Random Point in a Circle</h1><p>Given the radius and x-y positions of the center of a circle, write a function randPoint which generates a uniform random point in the circle.</p>
<p>Note:</p>
<ul>
<li>input and output values are in floating-point.</li>
<li>radius and x-y position of the center of the circle is passed into the class constructor.</li>
<li>a point on the circumference of the circle is considered to be in the circle.</li>
<li>randPoint returns a size 2 array containing x-position and y-position of the random point, in that order.</li>
</ul>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;Solution&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;]</span><br><span class="line">[[1,0,0],[],[],[]]</span><br><span class="line">Output: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;Solution&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;]</span><br><span class="line">[[10,5,-7.5],[],[],[]]</span><br><span class="line">Output: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]</span><br></pre></td></tr></table></figure></p>
<p>Explanation of Input Syntax:</p>
<ul>
<li>The input is two lists: the subroutines called and their arguments. Solution’s constructor has three arguments, the radius, x-position of the center, and y-position of the center of the circle. randPoint has no arguments. Arguments are always wrapped with a list, even if there aren’t any.</li>
</ul>
<p>这道题给了我们一个圆，包括中点位置和半径，让随机生成圆中的任意一个点。这里说明了圆上也当作是圆中，而且这里的随机意味着要等概率。</p>
<p>圆的方程表示为<code>(x - a) ^ 2 + (y - b) ^ 2 = r ^ 2</code>，这里的<code>(a, b)</code>是圆心位置，r为半径。那么如何生成圆中的任意位置呢，如果用这种方式来生成，先随机出一个x，随机出y的时候还要考虑其是否在圆中间，比较麻烦。继续回到高中时代，模糊的记忆中飘来了三个字，极坐标。是的，圆还可以用极坐标的形式来表示，只需随机出一个角度 theta，再随机出一个小于半径的长度，这样就可以得到圆中的坐标位置了。</p>
<p>先来生成 theta吧，由于一圈是 360 度，即 2pi，所以随机出一个 [0, 1] 中的小数，再乘以 2pi，就可以了。然后就是随机小于半径的长度，这里有个问题需要注意一下，这里并不是直接随机出一个 [0, 1] 中的小数再乘以半径r，而是要对随机出的 [0, 1] 中的小数取个平方根再乘以半径r。这是为啥呢，简单来说，是为了保证等概率。如果不用平方根的话，那么表示圆的时候<code>(len * cos(theta)) ^ 2 + (len * sin(theta) ^ 2</code>，这里就相当于对随机出的 [0, 1] 中的小数平方了，那么其就不是等概率的了，因为两个小于1的小数相乘了，其会更加靠近0，这就是为啥要平方一下的原因。最后在求点位置的时候要加上圆心的偏移即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(<span class="type">double</span> radius, <span class="type">double</span> x_center, <span class="type">double</span> y_center) &#123;</span><br><span class="line">        r = radius; centerX = x_center; centerY = y_center;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">randPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> theta = <span class="number">2</span> * M_PI * ((<span class="type">double</span>)<span class="built_in">rand</span>() / RAND_MAX);</span><br><span class="line">        <span class="type">double</span> len = <span class="built_in">sqrt</span>((<span class="type">double</span>)<span class="built_in">rand</span>() / RAND_MAX) * r;</span><br><span class="line">        <span class="keyword">return</span> &#123;centerX + len * <span class="built_in">cos</span>(theta), centerY + len * <span class="built_in">sin</span>(theta)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> r, centerX, centerY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这其实就是拒绝采样的经典应用，在一个正方形中有均匀分布的点，随机出其内切圆中的一个点，那么就是随机出x和y之后，然后算其平方和，如果小于等于r平方，说明其在圆内，可以返回其坐标，记得加上圆心偏移，否则重新进行采样。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(<span class="type">double</span> radius, <span class="type">double</span> x_center, <span class="type">double</span> y_center) &#123;</span><br><span class="line">        r = radius; centerX = x_center; centerY = y_center;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">randPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">double</span> x = (<span class="number">2</span> * (<span class="type">double</span>)<span class="built_in">rand</span>() / RAND_MAX - <span class="number">1.0</span>) * r;</span><br><span class="line">            <span class="type">double</span> y = (<span class="number">2</span> * (<span class="type">double</span>)<span class="built_in">rand</span>() / RAND_MAX - <span class="number">1.0</span>) * r;</span><br><span class="line">            <span class="keyword">if</span> (x * x + y * y &lt;= r * r) <span class="keyword">return</span> &#123;centerX + x, centerY + y&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> r, centerX, centerY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="480-Sliding-Window-Median"><a href="#480-Sliding-Window-Median" class="headerlink" title="480. Sliding Window Median"></a>480. Sliding Window Median</h1><p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p>
<p>Examples:</p>
<p>[2,3,4] , the median is 3</p>
<p>[2,3], the median is (2 + 3) / 2 = 2.5</p>
<p>Given an array nums , there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.</p>
<p>For example,</p>
<p>Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Window position                Median</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       1</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       -1</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       -1</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       3</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       5</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      6</span><br></pre></td></tr></table></figure><br>Therefore, return the median sliding window as [1,-1,-1,3,5,6].</p>
<p>Note:</p>
<ul>
<li>You may assume k is always valid, ie: 1 ≤ k ≤ input array’s size for non-empty array.</li>
</ul>
<p>这道题给了我们一个数组，还是滑动窗口的大小，让我们求滑动窗口的中位数。我想起来之前也有一道滑动窗口的题Sliding Window Maximum，于是想套用那道题的方法，可以用deque怎么也做不出，因为求中位数并不是像求最大值那样只操作deque的首尾元素。后来看到了史蒂芬大神的方法，原来是要用一个multiset集合，和一个指向最中间元素的iterator。我们首先将数组的前k个数组加入集合中，由于multiset自带排序功能，所以我们通过k/2能快速的找到指向最中间的数字的迭代器mid，如果k为奇数，那么mid指向的数字就是中位数；如果k为偶数，那么mid指向的数跟前面那个数求平均值就是中位数。当我们添加新的数字到集合中，multiset会根据新数字的大小加到正确的位置，然后我们看如果这个新加入的数字比之前的mid指向的数小，那么中位数肯定被拉低了，所以mid往前移动一个，再看如果要删掉的数小于等于mid指向的数(注意这里加等号是因为要删的数可能就是mid指向的数)，则mid向后移动一个。然后我们将滑动窗口最左边的数删掉，我们不能直接根据值来用erase来删数字，因为这样有可能删掉多个相同的数字，而是应该用lower_bound来找到第一个不小于目标值的数，通过iterator来删掉确定的一个数字，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line">        <span class="function">multiset&lt;<span class="type">double</span>&gt; <span class="title">ms</span><span class="params">(nums.begin(), nums.begin() + k)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> mid = <span class="built_in">next</span>(ms.<span class="built_in">begin</span>(), k /  <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; ; ++i) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>((*mid + *<span class="built_in">prev</span>(mid,  <span class="number">1</span> - k % <span class="number">2</span>)) / <span class="number">2</span>);        </span><br><span class="line">            <span class="keyword">if</span> (i == nums.<span class="built_in">size</span>()) <span class="keyword">return</span> res;</span><br><span class="line">            ms.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; *mid) --mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[i - k] &lt;= *mid) ++mid;</span><br><span class="line">            ms.<span class="built_in">erase</span>(ms.<span class="built_in">lower_bound</span>(nums[i - k]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假定窗口里已经排序了，前半部分是x，后半部分是y，用multiset能自动排序。两个集合的size顶多相差1。</p>
<p>a[i-k]在x中，从x中删除；若不在x中则从y中删除。x中的最大值挪到y中成为最小值。维护<code>x.size()-y.size()=1</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calc</span><span class="params">(<span class="type">const</span> multiset&lt;<span class="type">int</span>&gt;&amp; x, <span class="type">const</span> multiset&lt;<span class="type">int</span>&gt;&amp; y, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) <span class="keyword">return</span> *x.<span class="built_in">rbegin</span>();</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1.0</span> * *x.<span class="built_in">rbegin</span>() + *y.<span class="built_in">begin</span>()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(multiset&lt;<span class="type">int</span>&gt;&amp; x, multiset&lt;<span class="type">int</span>&gt;&amp; y, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.<span class="built_in">count</span>(val)) &#123;</span><br><span class="line">            x.<span class="built_in">erase</span>(x.<span class="built_in">find</span>(val));</span><br><span class="line">            <span class="keyword">if</span> (x.<span class="built_in">size</span>() &lt; y.<span class="built_in">size</span>() &amp;&amp; y.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> v = *y.<span class="built_in">begin</span>();</span><br><span class="line">                x.<span class="built_in">insert</span>(v);</span><br><span class="line">                y.<span class="built_in">erase</span>(y.<span class="built_in">find</span>(v));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        y.<span class="built_in">erase</span>(y.<span class="built_in">find</span>(val));</span><br><span class="line">        <span class="keyword">if</span> (x.<span class="built_in">size</span>() - y.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> v = *x.<span class="built_in">rbegin</span>();</span><br><span class="line">            x.<span class="built_in">erase</span>(x.<span class="built_in">find</span>(v));</span><br><span class="line">            y.<span class="built_in">insert</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(multiset&lt;<span class="type">int</span>&gt;&amp; x, multiset&lt;<span class="type">int</span>&gt;&amp; y, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.<span class="built_in">empty</span>() || val &lt; *x.<span class="built_in">rbegin</span>()) &#123;</span><br><span class="line">            x.<span class="built_in">insert</span>(val);</span><br><span class="line">            <span class="keyword">if</span> (x.<span class="built_in">size</span>() - y.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> v = *x.<span class="built_in">rbegin</span>();</span><br><span class="line">                x.<span class="built_in">erase</span>(x.<span class="built_in">find</span>(v));</span><br><span class="line">                y.<span class="built_in">insert</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        y.<span class="built_in">insert</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (y.<span class="built_in">size</span>() &gt; x.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> v = *y.<span class="built_in">begin</span>();</span><br><span class="line">            y.<span class="built_in">erase</span>(y.<span class="built_in">find</span>(v));</span><br><span class="line">            x.<span class="built_in">insert</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        multiset&lt;<span class="type">int</span>&gt; x, y;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// k 个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; k; i ++)</span><br><span class="line">            x.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k/<span class="number">2</span>; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> val = *x.<span class="built_in">rbegin</span>();</span><br><span class="line">            x.<span class="built_in">erase</span>(x.<span class="built_in">find</span>(val));</span><br><span class="line">            y.<span class="built_in">insert</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="built_in">calc</span>(x, y, k));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r = k; r &lt; n; l ++, r ++) &#123;</span><br><span class="line">            <span class="comment">// 先删除a[l-1]，这是上一个窗口的最小元素</span></span><br><span class="line">            <span class="built_in">remove</span>(x, y, a[l<span class="number">-1</span>]);</span><br><span class="line">            <span class="built_in">add</span>(x, y, a[r]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">calc</span>(x, y, k));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的方法用到了很多STL内置的函数，比如next，lower_bound啥的，下面我们来看一种不使用这些函数的解法。这种解法跟Find Median from Data Stream那题的解法很类似，都是维护了small和large两个堆，分别保存有序数组的左半段和右半段的数字，保持small的长度大于等于large的长度。我们开始遍历数组nums，如果i&gt;=k，说明此时滑动窗口已经满k个了，再滑动就要删掉最左值了，我们分别在small和large中查找最左值，有的话就删掉。然后处理增加数字的情况（分两种情况：1.如果small的长度小于large的长度，再看如果large是空或者新加的数小于等于large的首元素，我们把此数加入small中。否则就把large的首元素移出并加入small中，然后把新数字加入large。2.如果small的长度大于large，再看如果新数字大于small的尾元素，那么新数字加入large中，否则就把small的尾元素移出并加入large中，把新数字加入small中）。最后我们再计算中位数并加入结果res中，根据k的奇偶性来分别处理，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line">        multiset&lt;<span class="type">int</span>&gt; small, large;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (small.<span class="built_in">count</span>(nums[i - k])) small.<span class="built_in">erase</span>(small.<span class="built_in">find</span>(nums[i - k]));</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (large.<span class="built_in">count</span>(nums[i - k])) large.<span class="built_in">erase</span>(large.<span class="built_in">find</span>(nums[i - k]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (small.<span class="built_in">size</span>() &lt;= large.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (large.<span class="built_in">empty</span>() || nums[i] &lt;= *large.<span class="built_in">begin</span>()) small.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    small.<span class="built_in">insert</span>(*large.<span class="built_in">begin</span>());</span><br><span class="line">                    large.<span class="built_in">erase</span>(large.<span class="built_in">begin</span>());</span><br><span class="line">                    large.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt;= *small.<span class="built_in">rbegin</span>()) large.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    large.<span class="built_in">insert</span>(*small.<span class="built_in">rbegin</span>());</span><br><span class="line">                    small.<span class="built_in">erase</span>(--small.<span class="built_in">end</span>());</span><br><span class="line">                    small.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= (k - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k % <span class="number">2</span>) res.<span class="built_in">push_back</span>(*small.<span class="built_in">rbegin</span>());</span><br><span class="line">                <span class="keyword">else</span> res.<span class="built_in">push_back</span>(((<span class="type">double</span>)*small.<span class="built_in">rbegin</span>() + *large.<span class="built_in">begin</span>()) / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode481-Magical-String"><a href="#Leetcode481-Magical-String" class="headerlink" title="Leetcode481. Magical String"></a>Leetcode481. Magical String</h1><p>A magical string S consists of only ‘1’ and ‘2’ and obeys the following rules:</p>
<p>The string S is magical because concatenating the number of contiguous occurrences of characters ‘1’ and ‘2’ generates the string S itself.</p>
<p>The first few elements of string S is the following: S = “1221121221221121122……”</p>
<p>If we group the consecutive ‘1’s and ‘2’s in S, it will be:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 22 11 2 1 22 1 22 11 2 11 22 ……</span><br></pre></td></tr></table></figure></p>
<p>and the occurrences of ‘1’s or ‘2’s in each group are:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 2 1 1 2 1 2 2 1 2 2 ……</span><br></pre></td></tr></table></figure></p>
<p>You can see that the occurrence sequence above is the S itself.</p>
<p>Given an integer N as input, return the number of ‘1’s in the first N number in the magical string S.</p>
<p>Note: N will not exceed 100,000.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 6</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The first 6 elements of magical string S is &quot;12211&quot; and it contains three 1&#x27;s, so return 3.</span><br></pre></td></tr></table></figure></p>
<p>这道题介绍了一种神奇字符串，只由1和2组成，通过计数1组和2组的个数，又能生成相同的字符串。而让我们求前n个数字中1的个数。让我们按规律生成这个神奇字符串，只有生成了字符串的前n个字符，才能统计出1的个数。其实这道题的难点就是在于找到规律来生成字符串。</p>
<p>根据第三个数字2开始往后生成数字，此时生成两个1，然后根据第四个数字1，生成一个2，再根据第五个数字1，生成一个1，以此类推，生成的数字1或2可能通过异或3来交替生成，在生成的过程中同时统计1的个数即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">magicalString</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>, head = <span class="number">2</span>, tail = <span class="number">3</span>, num = <span class="number">1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (tail &lt; n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v[head]; ++i) &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(num);</span><br><span class="line">                <span class="keyword">if</span> (num == <span class="number">1</span> &amp;&amp; tail &lt; n) ++res;</span><br><span class="line">                ++tail;</span><br><span class="line">            &#125;</span><br><span class="line">            num ^= <span class="number">3</span>;</span><br><span class="line">            ++head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode482-License-Key-Formatting"><a href="#Leetcode482-License-Key-Formatting" class="headerlink" title="Leetcode482. License Key Formatting"></a>Leetcode482. License Key Formatting</h1><p>You are given a license key represented as a string S which consists only alphanumeric character and dashes. The string is separated into N+1 groups by N dashes.</p>
<p>Given a number K, we would want to reformat the strings such that each group contains exactly K characters, except for the first group which could be shorter than K, but still must contain at least one character. Furthermore, there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase.</p>
<p>Given a non-empty string S and a number K, format the string according to the rules described above.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;5F3Z-2e-9-w&quot;, K = 4</span><br><span class="line">Output: &quot;5F3Z-2E9W&quot;</span><br><span class="line">Explanation: The string S has been split into two parts, each part has 4 characters.</span><br><span class="line">Note that the two extra dashes are not needed and can be removed.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;2-5g-3-J&quot;, K = 2</span><br><span class="line">Output: &quot;2-5G-3J&quot;</span><br><span class="line">Explanation: The string S has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.</span><br></pre></td></tr></table></figure><br>Note:</p>
<ul>
<li>The length of string S will not exceed 12,000, and K is a positive integer.</li>
<li>String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).</li>
<li>String S is non-empty.</li>
</ul>
<p>繁琐的字符串拼接题。。。。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">licenseKeyFormatting</span><span class="params">(string S, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        string tmp, res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = S.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            tmp = (<span class="type">char</span>) <span class="built_in">toupper</span>(S[i]) + tmp;</span><br><span class="line">            <span class="keyword">if</span>(tmp.<span class="built_in">length</span>() == K) &#123;</span><br><span class="line">                res.<span class="built_in">insert</span>(<span class="number">0</span>, <span class="string">&quot;-&quot;</span> + tmp);</span><br><span class="line">                tmp.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">empty</span>() &amp;&amp; !res.<span class="built_in">empty</span>()) <span class="keyword">return</span> res.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">        res = tmp + res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode485-Max-Consecutive-Ones"><a href="#Leetcode485-Max-Consecutive-Ones" class="headerlink" title="Leetcode485. Max Consecutive Ones"></a>Leetcode485. Max Consecutive Ones</h1><p>Given a binary array, find the maximum number of consecutive 1s in this array.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,0,1,1,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The first two digits or the last three digits are consecutive 1s.</span><br><span class="line">    The maximum number of consecutive 1s is 3.</span><br></pre></td></tr></table></figure><br>计算最长的连续1<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, count = <span class="number">0</span>;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                res = count &gt; res ? count : res;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = count &gt; res ? count : res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode486-Predict-the-Winner"><a href="#Leetcode486-Predict-the-Winner" class="headerlink" title="Leetcode486. Predict the Winner"></a>Leetcode486. Predict the Winner</h1><p>Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.</p>
<p>Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 5, 2]</span><br><span class="line">Output: False</span><br><span class="line">Explanation: Initially, player 1 can choose between 1 and 2.   </span><br><span class="line">If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2).   </span><br><span class="line">So, final score of player 1 is 1 + 2 = 3, and player 2 is 5.   </span><br><span class="line">Hence, player 1 will never be the winner and you need to return False.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 5, 233, 7]</span><br><span class="line">Output: True</span><br><span class="line">Explanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.  </span><br><span class="line">Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= length of the array &lt;= 20.</li>
<li>Any scores in the given array are non-negative integers and will not exceed 10,000,000.</li>
<li>If the scores of both players are equal, then player 1 is still the winner.</li>
</ul>
<p>这道题给了一个小游戏，有一个数组，两个玩家轮流取数，说明了只能从开头或结尾取，问我们第一个玩家能赢吗。而且当前玩家赢返回 true 的条件就是递归调用下一个玩家输返回 false。这里需要一个变量来标记当前是第几个玩家，还需要两个变量来分别记录两个玩家的当前数字和，在递归函数里面，如果当前数组为空了，直接比较两个玩家的当前得分即可，如果数组中只有一个数字了，根据玩家标识来将这个数字加给某个玩家并进行比较总得分。如果数组有多个数字，分别生成两个新数组，一个是去掉首元素，一个是去掉尾元素，然后根据玩家标识分别调用不同的递归，只要下一个玩家两种情况中任意一种返回 false 了，那么当前玩家就可以赢了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">PredictTheWinner</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">canWin</span>(nums, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canWin</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> sum1, <span class="type">int</span> sum2, <span class="type">int</span> player)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> sum1 &gt;= sum2;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (player == <span class="number">1</span>) <span class="keyword">return</span> sum1 + nums[<span class="number">0</span>] &gt;= sum2;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (player == <span class="number">2</span>) <span class="keyword">return</span> sum2 + nums[<span class="number">0</span>] &gt; sum1;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; va = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums.<span class="built_in">begin</span>() + <span class="number">1</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vb = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (player == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> !<span class="built_in">canWin</span>(va, sum1 + nums[<span class="number">0</span>], sum2, <span class="number">2</span>) || !<span class="built_in">canWin</span>(vb, sum1 + nums.<span class="built_in">back</span>(), sum2, <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (player == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> !<span class="built_in">canWin</span>(va, sum1, sum2 + nums[<span class="number">0</span>], <span class="number">1</span>) || !<span class="built_in">canWin</span>(vb, sum1, sum2 + nums.<span class="built_in">back</span>(), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>两人依次拿，如果Player1赢，则Player1拿的&gt;Player2拿的。我们把Player1拿的视为”+”，把Player2拿的视为”-“，如果最后结果大于等于0则Player1赢。</p>
<p>因此对于递归来说，beg ~ end的结果为<code>max(nums[beg] - partition(beg + 1, end), nums[end] - partition(beg, end + 1))</code>；对于非递归来说<code>DP[beg][end]</code>表示即为beg ~ end所取的值的大小（最终与零比较）。</p>
<p>总结：</p>
<ol>
<li>该问题没有直接比较一个选手所拿元素的和值，而是把问题转换为两个选手所拿元素的差值。这一点很巧妙，是关键的一步。</li>
<li>找出递推表达式：<code>max(nums[beg] - partition(beg + 1, end), nums[end] - partition(beg, end + 1))</code></li>
<li>通过递推表达式构造递归算法是比较简单的。但是要构造一个非递归的算法难度较大。对于非递归算法，首先在dp中赋初始值，这是我们解题的第一步。在这个问题中，我们使用一个二位的数组dp来表示nums数组中任意开始和结束位置两人结果的差值。</li>
</ol>
<p>初始的时候，我们仅仅知道对角线上的值。<code>dp[i][i] = nums[i]</code>。</p>
<p>接下来既然是求任意的开始和结束，对于二维数组，那肯定是一个双层的循环。通过dp中已知的元素和动态规划的递推表达式，我们就可以构造出我们的需要的结果。非递归的方式是从小问题到大问题的过程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">PredictTheWinner</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end) <span class="keyword">return</span> nums[start];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> Math.max(nums[start]-helper(nums, start+<span class="number">1</span>, end), nums[end]-helper(nums, start, end-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>【java代码——递归2（保存中间状态）】<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">PredictTheWinner</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Integer</span>[nums.length][nums.length]) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end, Integer[][] dp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[start][end] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(start == end) <span class="keyword">return</span> nums[start];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> Math.max(nums[start]-helper(nums, start+<span class="number">1</span>,end, dp), nums[end]-helper(nums, start,end-<span class="number">1</span>, dp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[start][end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode488-祖玛游戏"><a href="#Leetcode488-祖玛游戏" class="headerlink" title="Leetcode488. 祖玛游戏"></a>Leetcode488. 祖玛游戏</h1><p>你正在参与祖玛游戏的一个变种。</p>
<p>在这个祖玛游戏变体中，桌面上有 一排 彩球，每个球的颜色可能是：红色 ‘R’、黄色 ‘Y’、蓝色 ‘B’、绿色 ‘G’ 或白色 ‘W’ 。你的手中也有一些彩球。</p>
<p>你的目标是 清空 桌面上所有的球。每一回合：</p>
<p>从你手上的彩球中选出 任意一颗 ，然后将其插入桌面上那一排球中：两球之间或这一排球的任一端。<br>接着，如果有出现 三个或者三个以上 且 颜色相同 的球相连的话，就把它们移除掉。<br>如果这种移除操作同样导致出现三个或者三个以上且颜色相同的球相连，则可以继续移除这些球，直到不再满足移除条件。<br>如果桌面上所有球都被移除，则认为你赢得本场游戏。<br>重复这个过程，直到你赢了游戏或者手中没有更多的球。<br>给你一个字符串 board ，表示桌面上最开始的那排球。另给你一个字符串 hand ，表示手里的彩球。请你按上述操作步骤移除掉桌上所有球，计算并返回所需的 最少 球数。如果不能移除桌上所有的球，返回 -1 。</p>
<p>示例 1：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：board = &quot;WRRBBW&quot;, hand = &quot;RB&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：无法移除桌面上的所有球。可以得到的最好局面是：</span><br><span class="line">- 插入一个 &#x27;R&#x27; ，使桌面变为 WRRRBBW 。WRRRBBW -&gt; WBBW</span><br><span class="line">- 插入一个 &#x27;B&#x27; ，使桌面变为 WBBBW 。WBBBW -&gt; WW</span><br><span class="line">桌面上还剩着球，没有其他球可以插入。</span><br></pre></td></tr></table></figure></p>
<p>示例 2：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：board = &quot;WWRRBBWW&quot;, hand = &quot;WRBRW&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：要想清空桌面上的球，可以按下述步骤：</span><br><span class="line">- 插入一个 &#x27;R&#x27; ，使桌面变为 WWRRRBBWW 。WWRRRBBWW -&gt; WWBBWW</span><br><span class="line">- 插入一个 &#x27;B&#x27; ，使桌面变为 WWBBBWW 。WWBBBWW -&gt; WWWW -&gt; empty</span><br><span class="line">只需从手中出 2 个球就可以清空桌面。</span><br></pre></td></tr></table></figure></p>
<p>示例 3：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：board = &quot;G&quot;, hand = &quot;GGGGG&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：要想清空桌面上的球，可以按下述步骤：</span><br><span class="line">- 插入一个 &#x27;G&#x27; ，使桌面变为 GG 。</span><br><span class="line">- 插入一个 &#x27;G&#x27; ，使桌面变为 GGG 。GGG -&gt; empty</span><br><span class="line">只需从手中出 2 个球就可以清空桌面。</span><br></pre></td></tr></table></figure></p>
<p>示例 4：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：board = &quot;RBYYBBRRB&quot;, hand = &quot;YRBGB&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：要想清空桌面上的球，可以按下述步骤：</span><br><span class="line">- 插入一个 &#x27;Y&#x27; ，使桌面变为 RBYYYBBRRB 。RBYYYBBRRB -&gt; RBBBRRB -&gt; RRRB -&gt; B</span><br><span class="line">- 插入一个 &#x27;B&#x27; ，使桌面变为 BB 。</span><br><span class="line">- 插入一个 &#x27;B&#x27; ，使桌面变为 BBB 。BBB -&gt; empty</span><br><span class="line">只需从手中出 3 个球就可以清空桌面。</span><br></pre></td></tr></table></figure></p>
<p>根据题目要求，桌面上最多有 1616 个球，手中最多有 55 个球；我们可以以任意顺序在 55 个回合中使用手中的球；在每个回合中，我们可以选择将手中的球插入到桌面上任意两球之间或这一排球的任意一端。</p>
<p>因为插入球的颜色和位置的选择是多样的，选择的影响也可能在多次消除操作之后才能体现出来，所以通过贪心方法根据当前情况很难做出全局最优的决策。实际每次插入一个新的小球时，并不保证插入后一定可以消除，因此我们需要搜索和遍历所有可能的插入方法，找到最小的插入次数。比如以下测试用例：</p>
<p>桌面上的球为 RRWWRRBBRR，手中的球为 WB，如果我们按照贪心法每次插入进行消除就会出现无法完全消除。因此，我们使用广度优先搜索来解决这道题。即对状态空间进行枚举，通过穷尽所有的可能来找到最优解，并使用剪枝的方法来优化搜索过程。</p>
<p>为什么使用广度优先搜索？<br>我们不妨规定，每一种不同的桌面上球的情况和手中球的情况的组合都是一种不同的状态。对于相同的状态，其清空桌面上球所需的回合数总是相同的；而不同的插入球的顺序，也可能得到相同的状态。因此，如果使用深度优先搜索，则需要使用记忆化搜索，以避免重复计算相同的状态。</p>
<p>因为只需要找出需要回合数最少的方案，因此使用广度优先搜索可以得到可以消除桌面上所有球的方案时就直接返回结果，而不需要继续遍历更多需要回合数更多的方案。而广度优先搜索虽然需要在队列中存储较多的状态，但是因为使用深度优先搜索也需要存储这些状态及这些状态对应的结果，因此使用广度优先搜索并不会需要更多的空间。</p>
<p>在算法的实现中，我们可以通过以下方法来实现广度优先：</p>
<p>使用队列来维护需要处理的状态队列，使用哈希集合存储已经访问过的状态。每一次取出队列中的队头状态，考虑其中所有可以插入球的方案，如果新方案还没有被访问过，则将新方案添加到队列的队尾。</p>
<p>下面，我们考虑剪枝条件：</p>
<p>第 1 个剪枝条件：手中颜色相同的球每次选择时只需要考虑其中一个即可<br>如果手中有颜色相同的球，那么插入这些球中的哪一个都没有区别。因此，手中颜色相同的球，我们只需要考虑其中一个即可。在具体的实现中，我们可以先将手中的球排序，如果当前遍历的球的颜色和上一个遍历的球的颜色相同，则跳过当前遍历的球。</p>
<p>第 2 个剪枝条件：只在连续相同颜色的球的开头位置或者结尾位置插入新的颜色相同的球<br>如果桌面上有一个红球，那么在其左侧和右侧插入一个新的红球没有区别；同理，如果桌面上有 2 个连续的红球，那么在其左侧、中间和右侧插入一个新的红球没有区别。因此，如果新插入的球和桌面上某组连续颜色相同的球（也可以是 1 个）的颜色相同，我们只需要考虑在其左侧插入新球的情况即可。在具体的实现中，如果新插入的球和插入位置左侧的球的颜色相同，则跳过这个位置。</p>
<p>第 3 个剪枝条件：只考虑放置新球后有可能得到更优解的位置<br>考虑插入新球的颜色与插入位置周围球的颜色的情况，在已经根据第 2 个剪枝条件剪枝后，还可能出现如下三种情况：插入新球与插入位置右侧的球颜色相同；插入新球与插入位置两侧的球颜色均不相同，且插入位置两侧的球的颜色不同；插入新球与插入位置两侧的球颜色均不相同，且插入位置两侧的球的颜色相同。</p>
<p>对于「插入新球与插入位置右侧的球颜色相同」的情况，这种操作可能可以构成连续三个相同颜色的球实现消除，是有可能得到更优解的。读者可以结合以下例子理解。</p>
<p>例如：桌面上的球为 WWRRBBWW，手中的球为 WWRB，答案为 2。</p>
<p>操作方法如下：WWRRBBWW -&gt; WW(R)RRBBWW -&gt; WWBBWW -&gt; WW(B)BBWW -&gt; WWWW “”。</p>
<p>对于「插入新球与插入位置两侧的球颜色均不相同，且插入位置两侧的球的颜色不同」的情况，这种操作可以将连续相同颜色的球拆分到不同的组合中消除，也是有可能得到更优解的。读者可以结合以下例子理解。</p>
<p>例如：桌面上的球为 RRWWRRBBRR，手中的球为 WB，答案为 2。</p>
<p>操作方法如下：RRWWRRBBRR→RRWWRRBBR(W)R→RRWWRR(B)BBRWR→RRWWRRRWR→RRWWWR→RRR→””。</p>
<p>对于「插入新球与插入位置两侧的球颜色均不相同，且插入位置两侧的球的颜色相同」的情况，这种操作并不能对消除顺序产生任何影响。如插入位置旁边的球可以消除的话，那么这种插入方法与直接将新球插入到与之颜色相同的球的旁边没有区别。因此，这种操作不能得到比「插入新球与插入位置右侧的球颜色相同」更好的情况，得到更优解。读者可以结合以下例子理解。</p>
<p>例如：桌面上的球为 WWRRBBWW，手中的球为 WWRB，答案为 2。</p>
<p>操作方法如下：WWRRBBWW→WWRRBB(R)WW→WWRRB(B)BRWW→WWRRRWW→WWWW→””。</p>
<p>细节</p>
<p>题目规定了如果在消除操作后，如果导致出现了新的连续三个或者三个以上颜色相同的球，则继续消除这些球，直到不再满足消除条件，实际消除时我们可以利用栈的特性，每次遇到连续可以消除的球时，我们就将其从栈中弹出。在实现中，我们可以在遍历桌面上的球时，使用列表维护遍历过的每种球的颜色和连续数量，从而通过一次遍历消除连续三个或者三个以上颜色相同的球。具体地：</p>
<p>使用 visited_ball 维护遍历过的每种球的颜色和连续数量，设其中最后一个颜色 last_color，其连续数量为last_num；遍历桌面上的球，设当前遍历到的球为cur_ball，其颜色为cur_color。</p>
<ul>
<li>首先，判断：如果visited_ball 不为空，且cur_color 与last_color 不同，则判断：如果last_num 大于等于 3，则从visited_ball 中移除last_color 和last_num。</li>
<li>接着，判断：如果visited_ball 为空，或cur_color 与last_color 不同，则向visited_ball 添加cur_color 及连续数量 1；</li>
<li>否则，累加last_num。</li>
<li>最后，根据列表中维护的每种球的颜色和连续数量，重新构造桌面上的球的组合即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    string board;</span><br><span class="line">    string hand;</span><br><span class="line">    <span class="type">int</span> step;</span><br><span class="line">    <span class="built_in">State</span>(<span class="type">const</span> string &amp; board, <span class="type">const</span> string &amp; hand, <span class="type">int</span> step) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;board = board;</span><br><span class="line">        <span class="keyword">this</span>-&gt;hand = hand;</span><br><span class="line">        <span class="keyword">this</span>-&gt;step = step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">clean</span><span class="params">(<span class="type">const</span> string &amp; s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&gt; st;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; c != st.<span class="built_in">back</span>().first &amp;&amp; st.<span class="built_in">back</span>().second &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || c != st.<span class="built_in">back</span>().first) &#123;</span><br><span class="line">                st.<span class="built_in">push_back</span>(&#123;c,<span class="number">1</span>&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">back</span>().second++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">back</span>().second &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            st.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; st.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; st[i].second; ++j) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(st[i].first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinStep</span><span class="params">(string board, string hand)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;string&gt; visited;</span><br><span class="line">        <span class="built_in">sort</span>(hand.<span class="built_in">begin</span>(), hand.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        visited.<span class="built_in">insert</span>(board + <span class="string">&quot; &quot;</span> + hand);</span><br><span class="line">        queue&lt;State&gt; qu;</span><br><span class="line">        qu.<span class="built_in">push</span>(<span class="built_in">State</span>(board, hand, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            State curr = qu.<span class="built_in">front</span>();</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; curr.hand.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="comment">// 第 1 个剪枝条件: 当前选择的球的颜色和前一个球的颜色相同</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; curr.hand[j] == curr.hand[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= curr.board.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                    <span class="comment">// 第 2 个剪枝条件: 只在连续相同颜色的球的开头位置插入新球</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; curr.board[i - <span class="number">1</span>] == curr.hand[j]) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 第 3 个剪枝条件: 只在以下两种情况放置新球</span></span><br><span class="line">                    <span class="type">bool</span> choose = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">//   第 1 种情况 : 当前球颜色与后面的球的颜色相同</span></span><br><span class="line">                    <span class="keyword">if</span> (i &lt; curr.board.<span class="built_in">size</span>() &amp;&amp; curr.board[i] == curr.hand[j]) &#123;</span><br><span class="line">                        choose = <span class="literal">true</span>;</span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="comment">//   第 2 种情况 : 当前后颜色相同且与当前颜色不同时候放置球</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i &lt; curr.board.<span class="built_in">size</span>() &amp;&amp; curr.board[i - <span class="number">1</span>] == curr.board[i] &amp;&amp; curr.board[i] != curr.hand[j])&#123;</span><br><span class="line">                        choose = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (choose) &#123;</span><br><span class="line">                        string new_board = <span class="built_in">clean</span>(curr.board.<span class="built_in">substr</span>(<span class="number">0</span>, i) + curr.hand[j] + curr.board.<span class="built_in">substr</span>(i));</span><br><span class="line">                        string new_hand = curr.hand.<span class="built_in">substr</span>(<span class="number">0</span>, j) + curr.hand.<span class="built_in">substr</span>(j + <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span> (new_board.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> curr.step + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (!visited.<span class="built_in">count</span>(new_board + <span class="string">&quot; &quot;</span> + new_hand)) &#123;</span><br><span class="line">                            qu.<span class="built_in">push</span>(<span class="built_in">State</span>(new_board, new_hand, curr.step + <span class="number">1</span>));</span><br><span class="line">                            visited.<span class="built_in">insert</span>(new_board + <span class="string">&quot; &quot;</span> + new_hand);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode491-Increasing-Subsequences"><a href="#Leetcode491-Increasing-Subsequences" class="headerlink" title="Leetcode491. Increasing Subsequences"></a>Leetcode491. Increasing Subsequences</h1><p>Given an integer array nums, return all the different possible increasing subsequences of the given array with at least two elements. You may return the answer in any order.</p>
<p>The given array may contain duplicates, and two equal integers should also be considered a special case of increasing sequence.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,6,7,7]</span><br><span class="line">Output: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,4,3,2,1]</span><br><span class="line">Output: [[4,4]]</span><br></pre></td></tr></table></figure></p>
<p>这道题让我们找出所有的递增子序列，应该不难想到，这题肯定是要先找出所有的子序列，从中找出递增的。首先来看一种迭代的解法，对于重复项的处理，最偷懒的方法是使用 TreeSet，利用其自动去处重复项的机制，然后最后返回时再转回 vector 即可。由于是找递增序列，所以需要对递归函数做一些修改，首先题目中说明了递增序列数字至少两个，所以只有子序列个数大于等于2时，才加入结果。然后就是要递增，如果之前的数字大于当前的数字，那么跳过这种情况，继续循环，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        set&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="built_in">helper</span>(nums, <span class="number">0</span>, s, res);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt; s, set&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">            res.<span class="built_in">insert</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">back</span>() &gt; nums[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            s.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">helper</span>(nums, i<span class="number">+1</span>, s, res);</span><br><span class="line">            s.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode492-Construct-the-Rectangle"><a href="#Leetcode492-Construct-the-Rectangle" class="headerlink" title="Leetcode492. Construct the Rectangle"></a>Leetcode492. Construct the Rectangle</h1><p>For a web developer, it is very important to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:</p>
<ol>
<li>The area of the rectangular web page you designed must equal to the given target area.</li>
<li>The width W should not be larger than the length L, which means L &gt;= W.</li>
<li>The difference between length L and width W should be as small as possible.</li>
</ol>
<p>You need to output the length L and the width W of the web page you designed in sequence.<br>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: [2, 2]</span><br><span class="line">Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. </span><br><span class="line">But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.</span><br></pre></td></tr></table></figure><br>构造矩形，并不断比较长宽差，差距最小的保留输出<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">constructRectangle</span><span class="params">(<span class="type">int</span> area)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ii = <span class="built_in">sqrt</span>(area);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        res.<span class="built_in">push_back</span>(area);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ii; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = area / i;</span><br><span class="line">            <span class="keyword">if</span>(temp * i == area) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(res[<span class="number">0</span>]-res[<span class="number">1</span>]) &gt; <span class="built_in">abs</span>(temp - i)) &#123;</span><br><span class="line">                    res[<span class="number">0</span>] = i;</span><br><span class="line">                    res[<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res[<span class="number">0</span>] &lt; res[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="type">int</span> temp = res[<span class="number">0</span>];</span><br><span class="line">            res[<span class="number">0</span>] = res[<span class="number">1</span>];</span><br><span class="line">            res[<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode493-Reverse-Pairs"><a href="#Leetcode493-Reverse-Pairs" class="headerlink" title="Leetcode493. Reverse Pairs"></a>Leetcode493. Reverse Pairs</h1><p>Given an array nums, we call (i, j) an  important reverse pair  if i &lt; j and nums[i] &gt; 2*nums[j].</p>
<p>You need to return the number of important reverse pairs in the given array.</p>
<p>Example1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,2,3,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,4,3,5,1]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>The length of the given array will not exceed 50,000.</li>
<li>All the numbers in the input array are in the range of 32-bit integer.</li>
</ul>
<p>一种方法叫分割重现关系 (Partition Recurrence Relation)，用式子表示是 T(i, j) = T(i, m) + T(m+1, j) + C。这里的C就是处理合并两个部分的子问题，那么用文字来描述就是“已知翻转对的两个数字分别在子数组 nums[i, m] 和 nums[m+1, j] 之中，求满足要求的翻转对的个数”，这里翻转对的两个条件中的顺序条件已经满足，就只需要找到满足大小关系的的数对即可。如果两个子数组是有序的，那么我们可以用双指针的方法在线性时间内就可以统计出符合题意的翻转对的个数。要想办法产生有序的子数组，那么这就和 MergeSort 的核心思想完美匹配了。我们知道混合排序就是不断的将数组对半拆分成子数组，拆到最小的数组后开始排序，然后一层一层的返回，最后原数组也是有序的了。这里我们在混合排序的递归函数中，对有序的两个子数组进行统计翻转对的个数，区间 [left, mid] 和 [mid+1, right] 内的翻转对儿个数就被分别统计出来了，此时还要统计翻转对儿的两个数字分别在两个区间中的情况，那么i遍历 [left, mid] 区间所有的数字，j则从 mid+1 开始检测，假如 nums[i] 大于 nums[j] 的二倍，则这两个数字就是翻转对，此时j再自增1，直到不满足这个条件停止，则j增加的个数就是符合题意的翻转对的个数，所以用当前的j减去其初始值 mid+1 即为所求，然后再逐层返回</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeSort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">mergeSort</span>(nums, left, mid) + <span class="built_in">mergeSort</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left, j = mid + <span class="number">1</span>; i &lt;= mid; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt;= right &amp;&amp; nums[i] / <span class="number">2.0</span> &gt; nums[j]) ++j;</span><br><span class="line">            res += j - (mid + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>() + left, nums.<span class="built_in">begin</span>() + right + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode494-目标和"><a href="#Leetcode494-目标和" class="headerlink" title="Leetcode494. 目标和"></a>Leetcode494. 目标和</h1><p>给你一个整数数组 nums 和一个整数 target 。</p>
<p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p>
<p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p>
<p>示例 1：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1], target = 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3 。</span><br><span class="line">-1 + 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 = 3</span><br></pre></td></tr></table></figure></p>
<p>示例 2：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], target = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个数组，和一个目标值，让给数组中每个数字加上正号或负号，然后求和要和目标值相等，求有多少中不同的情况。那么对于这种求多种情况的问题，博主最想到的方法使用递归来做。从第一个数字，调用递归函数，在递归函数中，分别对目标值进行加上当前数字调用递归，和减去当前数字调用递归，这样会涵盖所有情况，并且当所有数字遍历完成后，若目标值为0了，则结果 res 自增1，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">helper</span>(nums, S, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">long</span> S, <span class="type">int</span> start, <span class="type">int</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S == <span class="number">0</span>) ++res;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">helper</span>(nums, S - nums[start], start + <span class="number">1</span>, res);</span><br><span class="line">        <span class="built_in">helper</span>(nums, S + nums[start], start + <span class="number">1</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们对上面的递归方法进行优化，使用 memo 数组来记录中间值，这样可以避免重复运算，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> S)</span> </span>&#123;</span><br><span class="line">        vector&lt;unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(nums, S, <span class="number">0</span>, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">long</span> sum, <span class="type">int</span> start, vector&lt;unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == nums.<span class="built_in">size</span>()) <span class="keyword">return</span> sum == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[start].<span class="built_in">count</span>(sum)) <span class="keyword">return</span> memo[start][sum];</span><br><span class="line">        <span class="type">int</span> cnt1 = <span class="built_in">helper</span>(nums, sum - nums[start], start + <span class="number">1</span>, memo);</span><br><span class="line">        <span class="type">int</span> cnt2 = <span class="built_in">helper</span>(nums, sum + nums[start], start + <span class="number">1</span>, memo);</span><br><span class="line">        <span class="keyword">return</span> memo[start][sum] = cnt1 + cnt2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode495-Teemo-Attacking"><a href="#Leetcode495-Teemo-Attacking" class="headerlink" title="Leetcode495. Teemo Attacking"></a>Leetcode495. Teemo Attacking</h1><p>Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly duration seconds. More formally, an attack at second t will mean Ashe is poisoned during the inclusive time interval [t, t + duration - 1]. If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end duration seconds after the new attack.</p>
<p>You are given a non-decreasing integer array timeSeries, where timeSeries[i] denotes that Teemo attacks Ashe at second timeSeries[i], and an integer duration.</p>
<p>Return the total number of seconds that Ashe is poisoned.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: timeSeries = [1,4], duration = 2</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Teemo&#x27;s attacks on Ashe go as follows:</span><br><span class="line">- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.</span><br><span class="line">- At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.</span><br><span class="line">Ashe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: timeSeries = [1,2], duration = 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Teemo&#x27;s attacks on Ashe go as follows:</span><br><span class="line">- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.</span><br><span class="line">- At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3.</span><br><span class="line">Ashe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total.</span><br></pre></td></tr></table></figure></p>
<p>直接使用贪心算法，比较相邻两个时间点的时间差，如果小于duration，就加上这个差，如果大于或等于，就加上duration即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPoisonedDuration</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; timeSeries, <span class="type">int</span> duration)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> last = <span class="number">-1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; timeSeries.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeSeries[i] &lt;= last) &#123;</span><br><span class="line">                <span class="keyword">if</span> (timeSeries[i] + duration &gt; last) &#123;</span><br><span class="line">                    res = res + (timeSeries[i] + duration - last <span class="number">-1</span>);</span><br><span class="line">                    last = timeSeries[i] + duration - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res += duration;</span><br><span class="line">                last = timeSeries[i] + duration - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode496-Next-Greater-Element-I"><a href="#Leetcode496-Next-Greater-Element-I" class="headerlink" title="Leetcode496. Next Greater Element I"></a>Leetcode496. Next Greater Element I</h1><p>You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2.</p>
<p>The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">Output: [-1,3,-1]</span><br><span class="line">Explanation:</span><br><span class="line">    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.</span><br><span class="line">    For number 1 in the first array, the next greater number for it in the second array is 3.</span><br><span class="line">    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [2,4], nums2 = [1,2,3,4].</span><br><span class="line">Output: [3,-1]</span><br><span class="line">Explanation:</span><br><span class="line">    For number 2 in the first array, the next greater number for it in the second array is 3.</span><br><span class="line">    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.</span><br></pre></td></tr></table></figure></p>
<p>在num2中找到num1的每个元素，然后从这个元素往后找一个比它大的数，用标志位控制即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> first = nums<span class="number">1.</span><span class="built_in">size</span>(), second = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="type">bool</span> find;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; first; i ++)&#123;</span><br><span class="line">            find = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; second; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i] == nums2[j])</span><br><span class="line">                    find = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(find &amp;&amp; nums1[i] &lt; nums2[j])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == second)</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                res.<span class="built_in">push_back</span>(nums2[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode498-Diagonal-Traverse"><a href="#Leetcode498-Diagonal-Traverse" class="headerlink" title="Leetcode498. Diagonal Traverse"></a>Leetcode498. Diagonal Traverse</h1><p>Given an m x n matrix mat, return an array of all the elements of the array in a diagonal order.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [1,2,4,7,5,3,6,8,9]</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/20210710152100.jpg" alt=""></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat = [[1,2],[3,4]]</span><br><span class="line">Output: [1,2,3,4]</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个mxn大小的数组，让我们进行对角线遍历，先向右上，然后左下，再右上，以此类推直至遍历完整个数组，题目中的例子和图示也能很好的帮我们理解。由于移动的方向不再是水平或竖直方向，而是对角线方向，那么每移动一次，横纵坐标都要变化，向右上移动的话要坐标加上[-1, 1]，向左下移动的话要坐标加上[1, -1]，那么难点在于我们如何处理越界情况，越界后遍历的方向怎么变换。向右上和左下两个对角线方向遍历的时候都会有越界的可能，但是除了左下角和右上角的位置越界需要改变两个坐标之外，其余的越界只需要改变一个。那么我们就先判断要同时改变两个坐标的越界情况，即在右上角和左下角的位置。如果在右上角位置还要往右上走时，那么要移动到它下面的位置的，那么如果col超过了n-1的范围，那么col重置为n-1，并且row自增2，然后改变遍历的方向。同理如果row超过了m-1的范围，那么row重置为m-1，并且col自增2，然后改变遍历的方向。然后我们再来判断一般的越界情况，如果row小于0，那么row重置0，然后改变遍历的方向。同理如果col小于0，那么col重置0，然后改变遍历的方向。参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mat.<span class="built_in">empty</span>() || mat[<span class="number">0</span>].<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, dir = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dirs&#123;&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> m = mat.<span class="built_in">size</span>(), n = mat[<span class="number">0</span>].<span class="built_in">size</span>(), size = m*n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(mat[x][y]);</span><br><span class="line">            x += dirs[dir][<span class="number">0</span>];</span><br><span class="line">            y += dirs[dir][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= m) &#123; x = m - <span class="number">1</span>; y += <span class="number">2</span>; dir = <span class="number">1</span> - dir; &#125;</span><br><span class="line">            <span class="keyword">if</span> (y &gt;= n) &#123; y = n - <span class="number">1</span>; x += <span class="number">2</span>; dir = <span class="number">1</span> - dir; &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;  x = <span class="number">0</span>; dir = <span class="number">1</span> - dir; &#125;</span><br><span class="line">            <span class="keyword">if</span> (y &lt; <span class="number">0</span>) &#123;  y = <span class="number">0</span>; dir = <span class="number">1</span> - dir; &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode500-Keyboard-Row"><a href="#Leetcode500-Keyboard-Row" class="headerlink" title="Leetcode500. Keyboard Row"></a>Leetcode500. Keyboard Row</h1><p>Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]</span><br><span class="line">Output: [&quot;Alaska&quot;, &quot;Dad&quot;]</span><br></pre></td></tr></table></figure><br>给出n个字符串，从而判断每个字符串中的字符石头来自美式键盘上的同一行，若来自同一行，返回该string。过程将键盘上的每行字符存储到相应的vector或者数组中，然后循环Input中的每个string，并且循环string中的每个char，从而进行比较。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        std::unordered_set &lt;<span class="type">char</span>&gt; row1=&#123;<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>&#125;;</span><br><span class="line">        std::unordered_set &lt;<span class="type">char</span>&gt; row2=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">        std::unordered_set &lt;<span class="type">char</span>&gt; row3=&#123;<span class="string">&#x27;z&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;m&#x27;</span>&#125;;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        </span><br><span class="line">          <span class="keyword">for</span>(string word : words) &#123;</span><br><span class="line">            <span class="type">bool</span> d1=<span class="literal">true</span>, d2=<span class="literal">true</span>, d3=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : word) &#123;</span><br><span class="line">                <span class="keyword">if</span>(d1) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> re = row<span class="number">1.f</span>ind(<span class="built_in">tolower</span>(c));</span><br><span class="line">                    <span class="keyword">if</span>(re == row<span class="number">1.</span><span class="built_in">end</span>())</span><br><span class="line">                        d1 = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(d2) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> re = row<span class="number">2.f</span>ind(<span class="built_in">tolower</span>(c));</span><br><span class="line">                    <span class="keyword">if</span>(re == row<span class="number">2.</span><span class="built_in">end</span>())</span><br><span class="line">                        d2 = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(d3) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> re = row<span class="number">3.f</span>ind(<span class="built_in">tolower</span>(c));</span><br><span class="line">                    <span class="keyword">if</span>(re == row<span class="number">3.</span><span class="built_in">end</span>())</span><br><span class="line">                        d3 = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(d1||d2||d3)</span><br><span class="line">                res.<span class="built_in">push_back</span>(word);    </span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/12/Leetcode301_400/" rel="prev" title="Leetcode301 - 400">
      <i class="fa fa-chevron-left"></i> Leetcode301 - 400
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/26/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82TCP%E5%8D%8F%E8%AE%AE%EF%BC%9A%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/" rel="next" title="彻底弄懂TCP协议：从三次握手说起">
      彻底弄懂TCP协议：从三次握手说起 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode401-Binary-Watch"><span class="nav-number">1.</span> <span class="nav-text">Leetcode401. Binary Watch</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode402-Remove-K-Digits"><span class="nav-number">2.</span> <span class="nav-text">Leetcode402. Remove K Digits</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode403-Frog-Jump"><span class="nav-number">3.</span> <span class="nav-text">Leetcode403. Frog Jump</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode404-Sum-of-Left-Leaves"><span class="nav-number">4.</span> <span class="nav-text">Leetcode404. Sum of Left Leaves</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode405-Convert-a-Number-to-Hexadecimal"><span class="nav-number">5.</span> <span class="nav-text">Leetcode405. Convert a Number to Hexadecimal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode406-Queue-Reconstruction-by-Height"><span class="nav-number">6.</span> <span class="nav-text">Leetcode406. Queue Reconstruction by Height</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode407-Trapping-Rain-Water-II"><span class="nav-number">7.</span> <span class="nav-text">Leetcode407. Trapping Rain Water II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode409-Longest-Palindrome"><span class="nav-number">8.</span> <span class="nav-text">Leetcode409. Longest Palindrome</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode410-Split-Array-Largest-Sum"><span class="nav-number">9.</span> <span class="nav-text">Leetcode410. Split Array Largest Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode412-Fizz-Buzz"><span class="nav-number">10.</span> <span class="nav-text">Leetcode412. Fizz Buzz</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode413-Arithmetic-Slices"><span class="nav-number">11.</span> <span class="nav-text">Leetcode413. Arithmetic Slices</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode414-Third-Maximum-Number"><span class="nav-number">12.</span> <span class="nav-text">Leetcode414. Third Maximum Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode415-Add-Strings"><span class="nav-number">13.</span> <span class="nav-text">Leetcode415. Add Strings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode416-Partition-Equal-Subset-Sum"><span class="nav-number">14.</span> <span class="nav-text">Leetcode416. Partition Equal Subset Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode417-Pacific-Atlantic-Water-Flow"><span class="nav-number">15.</span> <span class="nav-text">Leetcode417. Pacific Atlantic Water Flow</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode419-Battleships-in-a-Board"><span class="nav-number">16.</span> <span class="nav-text">Leetcode419. Battleships in a Board</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode421-Maximum-XOR-of-Two-Numbers-in-an-Array"><span class="nav-number">17.</span> <span class="nav-text">Leetcode421. Maximum XOR of Two Numbers in an Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode423-Reconstruct-Original-Digits-from-English"><span class="nav-number">18.</span> <span class="nav-text">Leetcode423. Reconstruct Original Digits from English</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode424-Longest-Repeating-Character-Replacement"><span class="nav-number">19.</span> <span class="nav-text">Leetcode424. Longest Repeating Character Replacement</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode427-Construct-Quad-Tree"><span class="nav-number">20.</span> <span class="nav-text">Leetcode427. Construct Quad Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode429-N-ary-Tree-Level-Order-Traversal"><span class="nav-number">21.</span> <span class="nav-text">Leetcode429. N-ary Tree Level Order Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode430-Flatten-a-Multilevel-Doubly-Linked-List"><span class="nav-number">22.</span> <span class="nav-text">Leetcode430. Flatten a Multilevel Doubly Linked List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode433-Minimum-Genetic-Mutation"><span class="nav-number">23.</span> <span class="nav-text">Leetcode433. Minimum Genetic Mutation</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode434-Number-of-Segments-in-a-String"><span class="nav-number">24.</span> <span class="nav-text">Leetcode434. Number of Segments in a String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode435-Non-overlapping-Intervals"><span class="nav-number">25.</span> <span class="nav-text">Leetcode435. Non-overlapping Intervals</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode436-Find-Right-Interval"><span class="nav-number">26.</span> <span class="nav-text">Leetcode436. Find Right Interval</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode437-Path-Sum-III"><span class="nav-number">27.</span> <span class="nav-text">Leetcode437. Path Sum III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode438-Find-All-Anagrams-in-a-String"><span class="nav-number">28.</span> <span class="nav-text">Leetcode438. Find All Anagrams in a String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode441-Arranging-Coins"><span class="nav-number">29.</span> <span class="nav-text">Leetcode441. Arranging Coins</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode442-Find-All-Duplicates-in-an-Array"><span class="nav-number">30.</span> <span class="nav-text">Leetcode442. Find All Duplicates in an Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode443-String-Compression"><span class="nav-number">31.</span> <span class="nav-text">Leetcode443. String Compression</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode445-Add-Two-Numbers-II"><span class="nav-number">32.</span> <span class="nav-text">Leetcode445. Add Two Numbers II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode447-Number-of-Boomerangs"><span class="nav-number">33.</span> <span class="nav-text">Leetcode447. Number of Boomerangs</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode448-Find-All-Numbers-Disappeared-in-an-Array"><span class="nav-number">34.</span> <span class="nav-text">Leetcode448. Find All Numbers Disappeared in an Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode449-Serialize-and-Deserialize-BST"><span class="nav-number">35.</span> <span class="nav-text">Leetcode449. Serialize and Deserialize BST</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode450-Delete-Node-in-a-BST"><span class="nav-number">36.</span> <span class="nav-text">Leetcode450. Delete Node in a BST</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode451-Sort-Characters-By-Frequency"><span class="nav-number">37.</span> <span class="nav-text">Leetcode451. Sort Characters By Frequency</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode452-Minimum-Number-of-Arrows-to-Burst-Balloons"><span class="nav-number">38.</span> <span class="nav-text">Leetcode452. Minimum Number of Arrows to Burst Balloons</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode453-Minimum-Moves-to-Equal-Array-Elements"><span class="nav-number">39.</span> <span class="nav-text">Leetcode453. Minimum Moves to Equal Array Elements</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode454-4Sum-II"><span class="nav-number">40.</span> <span class="nav-text">Leetcode454. 4Sum II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode455-Assign-Cookies"><span class="nav-number">41.</span> <span class="nav-text">Leetcode455. Assign Cookies</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode456-132-Pattern"><span class="nav-number">42.</span> <span class="nav-text">Leetcode456. 132 Pattern</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode459-Repeated-Substring-Pattern"><span class="nav-number">43.</span> <span class="nav-text">Leetcode459. Repeated Substring Pattern</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode461-Hamming-Distance"><span class="nav-number">44.</span> <span class="nav-text">Leetcode461. Hamming Distance</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode462-Minimum-Moves-to-Equal-Array-Elements-II"><span class="nav-number">45.</span> <span class="nav-text">Leetcode462. Minimum Moves to Equal Array Elements II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode463-Island-Perimeter"><span class="nav-number">46.</span> <span class="nav-text">Leetcode463. Island Perimeter</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode464-Can-I-Win"><span class="nav-number">47.</span> <span class="nav-text">Leetcode464. Can I Win</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode467-Unique-Substrings-in-Wraparound-String"><span class="nav-number">48.</span> <span class="nav-text">Leetcode467. Unique Substrings in Wraparound String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode468-Validate-IP-Address"><span class="nav-number">49.</span> <span class="nav-text">Leetcode468. Validate IP Address</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode470-Implement-Rand10-Using-Rand7"><span class="nav-number">50.</span> <span class="nav-text">Leetcode470. Implement Rand10() Using Rand7()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode472-Concatenated-Words"><span class="nav-number">51.</span> <span class="nav-text">Leetcode472. Concatenated Words</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode473-Matchsticks-to-Square"><span class="nav-number">52.</span> <span class="nav-text">Leetcode473. Matchsticks to Square</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode474-Ones-and-Zeroes"><span class="nav-number">53.</span> <span class="nav-text">Leetcode474. Ones and Zeroes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode475-Heaters"><span class="nav-number">54.</span> <span class="nav-text">Leetcode475. Heaters</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode476-Number-Complement"><span class="nav-number">55.</span> <span class="nav-text">Leetcode476. Number Complement</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode477-Total-Hamming-Distance"><span class="nav-number">56.</span> <span class="nav-text">Leetcode477. Total Hamming Distance</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode478-Generate-Random-Point-in-a-Circle"><span class="nav-number">57.</span> <span class="nav-text">Leetcode478. Generate Random Point in a Circle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#480-Sliding-Window-Median"><span class="nav-number">58.</span> <span class="nav-text">480. Sliding Window Median</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode481-Magical-String"><span class="nav-number">59.</span> <span class="nav-text">Leetcode481. Magical String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode482-License-Key-Formatting"><span class="nav-number">60.</span> <span class="nav-text">Leetcode482. License Key Formatting</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode485-Max-Consecutive-Ones"><span class="nav-number">61.</span> <span class="nav-text">Leetcode485. Max Consecutive Ones</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode486-Predict-the-Winner"><span class="nav-number">62.</span> <span class="nav-text">Leetcode486. Predict the Winner</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode488-%E7%A5%96%E7%8E%9B%E6%B8%B8%E6%88%8F"><span class="nav-number">63.</span> <span class="nav-text">Leetcode488. 祖玛游戏</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode491-Increasing-Subsequences"><span class="nav-number">64.</span> <span class="nav-text">Leetcode491. Increasing Subsequences</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode492-Construct-the-Rectangle"><span class="nav-number">65.</span> <span class="nav-text">Leetcode492. Construct the Rectangle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode493-Reverse-Pairs"><span class="nav-number">66.</span> <span class="nav-text">Leetcode493. Reverse Pairs</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode494-%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="nav-number">67.</span> <span class="nav-text">Leetcode494. 目标和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode495-Teemo-Attacking"><span class="nav-number">68.</span> <span class="nav-text">Leetcode495. Teemo Attacking</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode496-Next-Greater-Element-I"><span class="nav-number">69.</span> <span class="nav-text">Leetcode496. Next Greater Element I</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode498-Diagonal-Traverse"><span class="nav-number">70.</span> <span class="nav-text">Leetcode498. Diagonal Traverse</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode500-Keyboard-Row"><span class="nav-number">71.</span> <span class="nav-text">Leetcode500. Keyboard Row</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
