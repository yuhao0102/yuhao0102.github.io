<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="第一章  结构化绑定结构化绑定允许你使用对象的成员或者说元素来初始化多个变量。 举个例子，假如你定义了一个包含两个不同成员的结构：123456struct MyStruct &#123;  int i &#x3D; 0;  std::string s;&#125;;MyStruct ms;只需使用下面的声明，你就可以将这个结构体的成员直接绑定到新名字上1auto [u,v] &#x3D; ms;在这里，名字u和v就被">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 17 指南">
<meta property="og:url" content="http://yoursite.com/2022/03/06/cpp17guide/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="第一章  结构化绑定结构化绑定允许你使用对象的成员或者说元素来初始化多个变量。 举个例子，假如你定义了一个包含两个不同成员的结构：123456struct MyStruct &#123;  int i &#x3D; 0;  std::string s;&#125;;MyStruct ms;只需使用下面的声明，你就可以将这个结构体的成员直接绑定到新名字上1auto [u,v] &#x3D; ms;在这里，名字u和v就被">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/2022/03/06/public/fig5-1.jpg">
<meta property="og:image" content="http://yoursite.com/2022/03/06/public/fig5-2.jpg">
<meta property="og:image" content="http://yoursite.com/2022/03/06/public/fig8-1.jpg">
<meta property="article:published_time" content="2022-03-06T09:00:00.000Z">
<meta property="article:modified_time" content="2022-03-17T01:46:52.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2022/03/06/public/fig5-1.jpg">

<link rel="canonical" href="http://yoursite.com/2022/03/06/cpp17guide/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>C++ 17 指南 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/03/06/cpp17guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ 17 指南
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-06 17:00:00" itemprop="dateCreated datePublished" datetime="2022-03-06T17:00:00+08:00">2022-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-17 09:46:52" itemprop="dateModified" datetime="2022-03-17T09:46:52+08:00">2022-03-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第一章-结构化绑定"><a href="#第一章-结构化绑定" class="headerlink" title="第一章  结构化绑定"></a>第一章  结构化绑定</h1><p>结构化绑定允许你使用对象的成员或者说元素来初始化多个变量。</p>
<p>举个例子，假如你定义了一个包含两个不同成员的结构：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  std::string s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyStruct ms;</span><br></pre></td></tr></table></figure><br>只需使用下面的声明，你就可以将这个结构体的成员直接绑定到新名字上<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> [u,v] = ms;</span><br></pre></td></tr></table></figure><br>在这里，名字u和v就被称为结构化绑定（structured bindings）。在某种程度上，它们分解了对象并用来初始化自己（在有些地方它们也被称为分解声明（decompose  declarations））。</p>
<p>结构化绑定对于那些返回结构体或者数组的函数来说尤其有用。举个例子，假设你有一个返回结构体的函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyStruct <span class="title">getStruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> MyStruct&#123;<span class="number">42</span>, <span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>你可以直接为函数返回的数据成员赋予两个局部名字：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>[id,val] = <span class="built_in">getStruct</span>(); <span class="comment">// id and val name i and s of returned struct</span></span><br></pre></td></tr></table></figure><br>在这里，id和val分别表示返回的数据成员i和s。它们的类型分别是int和<code>std::string</code> ，可以当新变量使用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (id &gt; <span class="number">30</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用结构化绑定的好处是可以直接通过名字访问值，并且由于名字可以传递语义信息，使得代码可读性也大大提高。</p>
<p>下面的示例展示了结构化绑定如何改善代码可读性。在没有结构化绑定的时候，要想迭代处理<code>std::map&lt;&gt;</code>的所有元素，需要这么写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : mymap) &#123;</span><br><span class="line">  std::cout &lt;&lt; elem.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; elem.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>代码中的elem是表示键和值的<code>std::pair</code>，它们在<code>std::pair</code>中分别用first和second表示，你可以使用这两个名字去访问键和值。使用结构化绑定后，代码可读性大大提高：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key,val] : mymap) &#123;</span><br><span class="line">  std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以直接使用每个元素的键和值，key和value清晰的表示了它们的语义。</p>
<h2 id="1-1-结构化绑定的细节"><a href="#1-1-结构化绑定的细节" class="headerlink" title="1.1 结构化绑定的细节"></a>1.1 结构化绑定的细节</h2><p>为了理解结构化绑定，了解其中设计的一个匿名变量是很重要的。结构化绑定引入的新名字都是指代的这个匿名变量的成员/元素的。</p>
<h3 id="绑定到匿名变量"><a href="#绑定到匿名变量" class="headerlink" title="绑定到匿名变量"></a>绑定到匿名变量</h3><p>初始化代码的最精确的行为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> [u,v] = ms;</span><br></pre></td></tr></table></figure><br>可以看成我们初始化一个匿名变量e，然后让结构化绑定u和v成为这个新对象的别名，类似下面：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> e = ms;</span><br><span class="line">aliasname u = e.i;</span><br><span class="line">aliasname v = e.s;</span><br></pre></td></tr></table></figure><br>注意u和v不是<code>e.i</code>和<code>e.s</code>的引用。它们只是这两个成员的别名。因此，<code>decltype(u)</code>的类型与成员i的类型一致，<code>decltype(v)</code>的类型与成员s的类型一致。因为匿名变量e没有名字，所以我们不能直接访问这个已经初始化的变量。所以<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; u &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v &lt;&lt; ✬\n✬;</span><br></pre></td></tr></table></figure><br>输出<code>e.i</code>和<code>e.s</code>的值，它们是<code>ms.i</code>和<code>ms.s</code>的一份拷贝。</p>
<p>e和结构化绑定的存活时间一样长，当结构化绑定离开作用域时，e也会析构。</p>
<p>这样做的后果，除非使用引用，否则修改通过结构化绑定的值不会影响到初始化它的对象（反之亦然）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyStruct ms&#123;<span class="number">42</span>,<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [u,v] = ms;</span><br><span class="line">ms.i = <span class="number">77</span>;</span><br><span class="line">std::cout &lt;&lt; u;    <span class="comment">// prints 42</span></span><br><span class="line">u = <span class="number">99</span>;</span><br><span class="line">std::cout &lt;&lt; ms.i; <span class="comment">// prints 77</span></span><br></pre></td></tr></table></figure><br>u和<code>ms.i</code>地址是不一样的。</p>
<p>当对返回值使用结构化绑定的时候，上面的规则一样成立。下面代码的初始化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> [u,v] = <span class="built_in">getStruct</span>();</span><br></pre></td></tr></table></figure><br>和我们使用<code>getStruct()</code>的返回值初始化匿名变量e，然后用u和v作为e的成员别名效果一样，类似下面：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> e = <span class="built_in">getStruct</span>();</span><br><span class="line">aliasname u = e.i;</span><br><span class="line">aliasname v = e.s;</span><br></pre></td></tr></table></figure><br>换句话说，结构化绑定将绑定到一个新的对象，它由返回值初始化，而不是直接绑定到返回值本身。</p>
<p>对于匿名变量e，内存地址和对齐也是存在的，以至于如果成员有对齐，结构化绑定也会有对齐。比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> [u,v] = ms;</span><br><span class="line"><span class="built_in">assert</span>(&amp;((MyStruct*)&amp;u)-&gt;s == &amp;v); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><br><code>((MyStruct*)&amp;u)</code>会产生一个指向匿名变量的指针。</p>
<h3 id="使用修饰符"><a href="#使用修饰符" class="headerlink" title="使用修饰符"></a>使用修饰符</h3><p>我们在结构化绑定过程中使用一些修饰符，如const和引用。再次强调，这些修饰符修饰的是匿名变量e。虽说是对匿名变量使用修饰符，但是通常也可以看作对结构化绑定使用修饰符，尽管存在一些额例外。</p>
<p>下面的例子中，我们对结构化绑定使用const引用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; [u,v] = ms; <span class="comment">// a reference, so that u/v refer to ms.i/ms.s</span></span><br></pre></td></tr></table></figure><br>这里，匿名变量被声明为const引用，这意味着对ms使用const引用修饰，然后再将u和v作为i和s的别名。后续对ms成员的修改会直接影响到u和v：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ms.i = <span class="number">77</span>;      <span class="comment">// affects the value of u</span></span><br><span class="line">std::cout &lt;&lt; u; <span class="comment">// prints 77</span></span><br></pre></td></tr></table></figure><br>如果使用非const引用，你甚至可以通过对结构化绑定的修改，影响到初始化它的对象：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyStruct ms&#123;<span class="number">42</span>,<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span>&amp; [u,v] = ms;       <span class="comment">// the initialized entity is a reference to ms</span></span><br><span class="line">ms.i = <span class="number">77</span>;              <span class="comment">// affects the value of u</span></span><br><span class="line">std::cout &lt;&lt; u;         <span class="comment">// prints 77</span></span><br><span class="line">u = <span class="number">99</span>;                 <span class="comment">// modifies ms.i</span></span><br><span class="line">std::cout &lt;&lt; ms.i;      <span class="comment">// prints 99</span></span><br></pre></td></tr></table></figure><br>如果初始化对象是临时变量，对它使用结构化绑定，此时临时值的生命周期会扩展：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyStruct <span class="title">getStruct</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; [a,b] = <span class="built_in">getStruct</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure></p>
<h3 id="修饰符并非修饰结构化绑定"><a href="#修饰符并非修饰结构化绑定" class="headerlink" title="修饰符并非修饰结构化绑定"></a>修饰符并非修饰结构化绑定</h3><p>如题，修饰符修饰的是匿名变量。它们没必要修饰结构化绑定。事实上：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; [u,v] = ms;  <span class="comment">// a reference, so that u/v refer to ms.i/ms.s</span></span><br></pre></td></tr></table></figure><br>u和v都没有声明为引用。上面只是对匿名变量e的引用。u和v的类型需要ms的成员一致。根据我们最开始的定义可以知道，<code>decltype(u)</code>是int，<code>decltype(v)</code>是<code>std::string</code>。</p>
<p>当指定对齐宽度的时候也有一些不同。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alignas</span>(<span class="number">16</span>) <span class="keyword">auto</span> [u,v] = ms;</span><br></pre></td></tr></table></figure><br>在这里，我们将初始化后的匿名对象对齐而不是结构化绑定u和v。这意味着u作为第一个成员，被强制对齐到16位，而v不是。</p>
<p>同样的原因，尽管使用了auto，结构化绑定的类型也不会类型退化（术语退化（decay）描述的是当参数值传递的时候发生的类型转换，这意味着数组会转换为指针，最外面的修饰符如const和引用会被忽略）。例如，如果我们有一个包含多个原生数组的结构体：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> x[<span class="number">6</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> y[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>然后<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S s1&#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> [a, b] = s1; <span class="comment">// a and b get the exact member types</span></span><br></pre></td></tr></table></figure><br>a的类型仍然是<code>const char[6]</code>。原因仍然是修饰符并非修饰结构化绑定而是修饰初始化结构化绑定的对象。这一点和使用auto初始化新对象很不一样，它会发生类型退化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a2 = a;    <span class="comment">// a2 gets decayed type of a</span></span><br></pre></td></tr></table></figure></p>
<h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>即将介绍到，结构化绑定也支持移动语义。在下面的声明中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyStruct ms = &#123; <span class="number">42</span>, <span class="string">&quot;Jim&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; [v,n] = std::<span class="built_in">move</span>(ms);  <span class="comment">// entity is rvalue reference to ms</span></span><br></pre></td></tr></table></figure><br>结构化绑定v和n指向匿名变量中的成员，该匿名变量是ms的右值引用。ms仍然持有它的值:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;ms.s: &quot;</span> &lt;&lt; ms.s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints &quot;Jim&quot;</span></span><br></pre></td></tr></table></figure><br>但是你可以移动赋值n，它与<code>ms.s</code>关联：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string s = std::<span class="built_in">move</span>(n); <span class="comment">// moves ms.s to s</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ms.s: &quot;</span> &lt;&lt; ms.s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints unspecified value</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;n: &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints unspecified value</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;s: &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints &quot;Jim&quot;</span></span><br></pre></td></tr></table></figure><br>通常，移动后的对象的状态是有效的，只是包含了未指定的值（unspecified value）。因此，输出它的值是没有问题的，但是不能断言输出的东西一定是什么。</p>
<p>这一点和直接移动ms的值给匿名变量稍有不同：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyStruct ms = &#123; <span class="number">42</span>, <span class="string">&quot;Jim&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> [v,n] = std::<span class="built_in">move</span>(ms); <span class="comment">// new entity with moved-from values from ms</span></span><br></pre></td></tr></table></figure><br>此时匿名对象是一个新对象，它用移动后的ms的值来初始化。所以ms失去了他们的值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;ms.s: &quot;</span> &lt;&lt; ms.s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints unspecified value</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;n: &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints &quot;Jim&quot;</span></span><br></pre></td></tr></table></figure><br>你仍然可以移动n并赋值，或者用它赋予一个新的值，但是不会影响<code>ms.s</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string s = std::<span class="built_in">move</span>(n); <span class="comment">// moves n to s</span></span><br><span class="line">n = <span class="string">&quot;Lara&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ms.s: &quot;</span> &lt;&lt; ms.s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints unspecified value</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;n: &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints &quot;Lara&quot;</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;s: &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints &quot;Jim&quot;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="1-2-结构化绑定可以在哪使用"><a href="#1-2-结构化绑定可以在哪使用" class="headerlink" title="1.2 结构化绑定可以在哪使用"></a>1.2 结构化绑定可以在哪使用</h2><p>原则上，结构化绑定可以用于公有成员，原始C-style数组，以及“似若tuple”的对象：</p>
<ul>
<li>如果结构体或者类中，所有非静态数据成员都是public，那么你可以使用结构化绑定来绑定非静态数据成员</li>
<li>对于原生数组，你可以使用结构化绑定来绑定每个元素</li>
<li>对于任何类型，你都可以使用似若tuple的API来进行绑定。对于类型type，API可以粗糙的概括为下列内容：<ul>
<li><code>std::tuple_size&lt;type&gt;::value</code>返回元素数量</li>
<li><code>std::tupel_element&lt;idx,type&gt;::type</code>返回第idx个元素的类型</li>
<li>一个全局的或者成员函数<code>get&lt;idx&gt;()</code>返回第idx个元素的值</li>
</ul>
</li>
</ul>
<p>如果结构体或者累提供这些似若tuple的API，那么就可以使用它们。</p>
<p>任何情况下都要求元素或者数据成员的数量必须匹配结构化绑定的名字的个数。你不能跳过任何一个元素，也不能使用同一个名字两次。但是你可以看使用非常段的名字如”_”（很多程序员倾向于用下划线，但是也有些人讨厌它，不允许它出现在全局命名空间中），但是在一个作用域它也只能出现一次：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> [_,val1] = <span class="built_in">getStruct</span>(); <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">auto</span> [_,val2] = <span class="built_in">getStruct</span>(); <span class="comment">// ERROR: name _ already used</span></span><br></pre></td></tr></table></figure><br>嵌套或者非平坦的对象分解是不支持的。（译注：指的是形如OCaml等语言的这种<code>let a,(b,c) = (3,(4,2));;</code>模式匹配能力）</p>
<p>接下来的章节讨论本节列表提到的各种情况。</p>
<h3 id="1-2-1-结构体和类"><a href="#1-2-1-结构体和类" class="headerlink" title="1.2.1 结构体和类"></a>1.2.1 结构体和类</h3><p>到目前为止，已经演示了很多关于结构体和类的简单示例了。</p>
<p>如果类和结构体用到了继承，那么结构化绑定的使用就很受限了。所有非静态数据成员必须出现在同一个类。（换句话说，这些数据成员要么全是该类的，要么全是基类的）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span> : B &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> [x, y] = D1&#123;&#125;; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span> : B &#123;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> [i, j, k] = D2&#123;&#125;; <span class="comment">// Compile-Time ERROR</span></span><br></pre></td></tr></table></figure></p>
<h3 id="1-2-1-原生数组"><a href="#1-2-1-原生数组" class="headerlink" title="1.2.1 原生数组"></a>1.2.1 原生数组</h3><p>下面的代码使用有两个元素的C-style数组初始化x和y：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">47</span>, <span class="number">11</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> [x, y] = arr; <span class="comment">// x and y are ints initialized by elems of arr</span></span><br><span class="line"><span class="keyword">auto</span> [z] = arr; <span class="comment">// ERROR: number of elements doesn’t fit</span></span><br></pre></td></tr></table></figure><br>这种方式只能出现在数组长度已知的情况下。如果将数组作为参数传递，这样写就行不通，因为数组作为参数传递会发生类型退化，变成指针类型。</p>
<p>C++允许我们返回带长度的数组引用，如果有函数返回这种带长度的数组引用，那么也可以使用结构化绑定：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">getArr</span><span class="params">()</span> -&gt; <span class="title">int</span><span class="params">(&amp;)</span>[2]</span>; <span class="comment">// getArr() returns reference to raw int array</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> [x, y] = <span class="built_in">getArr</span>(); <span class="comment">// x and y are ints initialized by elems of returned array</span></span><br></pre></td></tr></table></figure><br>你也可以对<code>std::array</code>使用结构化绑定，但是这需要使用似若tuple的API，这也是下一节的内容。</p>
<h3 id="1-2-3-std-paor-std-tuple和std-array"><a href="#1-2-3-std-paor-std-tuple和std-array" class="headerlink" title="1.2.3 std::paor,std::tuple和std::array"></a>1.2.3 <code>std::paor</code>,<code>std::tuple</code>和<code>std::array</code></h3><p>结构化绑定是可扩展的，你可以为任何类型添加结构化绑定机制。标准库为<code>std::paor</code>,<code>std::tuple</code>和<code>std::array</code>都添加了该机制。</p>
<h4 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a><code>std::array</code></h4><p>举个例子，下面的<code>getArray()</code>将返回四个元素的<code>std::array&lt;&gt;</code>，并用它初始化i，j，k和l。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::array&lt;<span class="type">int</span>,4&gt; <span class="title">getArray</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> [i,j,k,l] = <span class="built_in">getArray</span>(); <span class="comment">// i,j,k,l name the 4 elements of the copied return value</span></span><br></pre></td></tr></table></figure><br>i，j，k和l分别绑定到<code>getArray()</code>返回的四个元素上。</p>
<p>写操作也是支持的，但这要求用来初始化结构化绑定的值不是一个临时的返回值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>,4&gt; stdarr &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span>&amp; [i,j,k,l] = stdarr;</span><br><span class="line">i += <span class="number">10</span>; <span class="comment">// modifies std::array[0]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="std-tuple"><a href="#std-tuple" class="headerlink" title="std::tuple"></a><code>std::tuple</code></h4><p>下面的代码使用<code>getTuple()</code>返回有三个元素的<code>std::tuple&lt;&gt;</code>来初始化a，b和c：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;<span class="type">char</span>,<span class="type">float</span>,std::string&gt; <span class="title">getTuple</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> [a,b,c] = <span class="built_in">getTuple</span>();    <span class="comment">// a,b,c have types and values of returned tuple</span></span><br></pre></td></tr></table></figure></p>
<h4 id="std-pair"><a href="#std-pair" class="headerlink" title="std::pair"></a><code>std::pair</code></h4><p>另一个例子是处理关联型/无序型容器的<code>insert()</code>调用的返回值，使用结构化绑定使代码可读性更强，可以清晰的表达自己的意图，而不是依赖于<code>std::tuple</code>通用的first和second：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; coll;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> [pos,ok] = coll.<span class="built_in">insert</span>(&#123;<span class="string">&quot;new&quot;</span>,<span class="number">42</span>&#125;);</span><br><span class="line"><span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">  <span class="comment">// if insert failed, handle error using iterator pos:</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在C++17之前，必须使用下面的代码检查返回数据：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ret = coll.<span class="built_in">insert</span>(&#123;<span class="string">&quot;new&quot;</span>,<span class="number">42</span>&#125;);</span><br><span class="line"><span class="keyword">if</span> (!ret.second)&#123;</span><br><span class="line">  <span class="comment">// if insert failed, handle error using iterator ret.first</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意，在这个例子中，C++17甚至还提供一种表达力更强的带初始化的if：</p>
<h4 id="为pair和tuple的结构化绑定赋值"><a href="#为pair和tuple的结构化绑定赋值" class="headerlink" title="为pair和tuple的结构化绑定赋值"></a>为pair和tuple的结构化绑定赋值</h4><p>在声明了结构化绑定之后，通常你不能一次性修改全部结构化绑定，因为结构化绑定是一次性声明所有而不是一次性使用所有。然而，如果重新赋的值是<code>std::pair&lt;&gt;</code>或者<code>std::tuple&lt;&gt;</code>那么你可以使用<code>std::tie()</code>。</p>
<p>也就是说，你可以写出下面的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;<span class="type">char</span>,<span class="type">float</span>,std::string&gt; <span class="title">getTuple</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> [a,b,c] = <span class="built_in">getTuple</span>(); <span class="comment">// a,b,c have types and values of returned tuple</span></span><br><span class="line">...</span><br><span class="line">std::<span class="built_in">tie</span>(a,b,c) = <span class="built_in">getTuple</span>(); <span class="comment">// a,b,c get values of next returned tuple</span></span><br></pre></td></tr></table></figure><br>这种方式在实现循环调用且每次循环赋予一对返回值的过程中尤其有用，比如下面子啊循环中使用searcher的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::boyer_moore_searcher bm&#123;sub.<span class="built_in">begin</span>(), sub.<span class="built_in">end</span>()&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [beg, end] = <span class="built_in">bm</span>(text.<span class="built_in">begin</span>(), text.<span class="built_in">end</span>());</span><br><span class="line">  beg != text.<span class="built_in">end</span>();</span><br><span class="line">  std::<span class="built_in">tie</span>(beg,end) = <span class="built_in">bm</span>(end, text.<span class="built_in">end</span>())) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-3-为结构化绑定提供似若tuple的API"><a href="#1-3-为结构化绑定提供似若tuple的API" class="headerlink" title="1.3 为结构化绑定提供似若tuple的API"></a>1.3 为结构化绑定提供似若tuple的API</h2><p>前面提到过，只要你的类型实现了似若tuple的API，那么就可以针对该类型使用结构化绑定，就和标准库的<code>std::pair&lt;&gt;</code>,<code>std::tuple&lt;&gt;</code>和<code>std::array&lt;&gt;</code>意义。</p>
<h4 id="只读结构化绑定"><a href="#只读结构化绑定" class="headerlink" title="只读结构化绑定"></a>只读结构化绑定</h4><p>下面的代码展示了如何为类型Customer添加结构化绑定功能，Customer的定义如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lang/customer1.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// for std::move()</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string first;</span><br><span class="line">  std::string last;</span><br><span class="line">  <span class="type">long</span> val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Customer</span> (std::string f, std::string l, <span class="type">long</span> v)</span><br><span class="line">      : <span class="built_in">first</span>(std::<span class="built_in">move</span>(f)), <span class="built_in">last</span>(std::<span class="built_in">move</span>(l)), <span class="built_in">val</span>(v) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::string <span class="title">getFirst</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::string <span class="title">getLast</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>我们可以提供似若tuple的API：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lang/structbind1.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;customer1.hpp&quot;</span> #<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// for tuple-like API</span></span></span><br><span class="line"><span class="comment">// provide a tuple-like API for class Customer for structured bindings:</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::tuple_size&lt;Customer&gt; &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> value = <span class="number">3</span>; <span class="comment">// we have 3 attributes</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::tuple_element&lt;<span class="number">2</span>, Customer&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="type">long</span>; <span class="comment">// last attribute is a long</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;std::<span class="type">size_t</span> Idx&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::tuple_element&lt;Idx, Customer&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = std::string; <span class="comment">// the other attributes are strings</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// define specific getters:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;std::<span class="type">size_t</span>&gt; <span class="keyword">auto</span> <span class="title">get</span><span class="params">(<span class="type">const</span> Customer&amp; c)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">auto</span> <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(<span class="type">const</span> Customer&amp; c) &#123; <span class="keyword">return</span> c.<span class="built_in">getFirst</span>(); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">auto</span> <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(<span class="type">const</span> Customer&amp; c) &#123; <span class="keyword">return</span> c.<span class="built_in">getLast</span>(); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">auto</span> <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(<span class="type">const</span> Customer&amp; c) &#123; <span class="keyword">return</span> c.<span class="built_in">getValue</span>(); &#125;</span><br></pre></td></tr></table></figure><br>代码Customer有三个成员，还有为三个成员准备的getter：</p>
<ul>
<li>表示first name的成员，<code>std::string</code>类型</li>
<li>表示last nane的成员，<code>std::string</code>类型</li>
<li>表示value的成员，long类型</li>
</ul>
<p>获取Customer成员个数的函数是<code>std::tuple_size</code>的特化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::tuple_size&lt;Customer&gt; &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> value = <span class="number">3</span>; <span class="comment">// we have 3 attributes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>获取成员类型的函数是<code>std::tuple_element</code>的特化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::tuple_element&lt;<span class="number">2</span>, Customer&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="type">long</span>; <span class="comment">// last attribute is a long</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;std::<span class="type">size_t</span> Idx&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::tuple_element&lt;Idx, Customer&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = std::string; <span class="comment">// the other attributes are strings</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>第三个成员类型是long，需要为它（index 2）编写全特化代码。其它成员是<code>std::stinrg</code>类型，部分特化（比全特化优先级低）即可。这里指定的类型与<code>decltype</code>产生的类型一致。</p>
<p>最终，我们在同一个命名空间为Customer类型定义相应的<code>get&lt;&gt;()</code>函数重载：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;std::<span class="type">size_t</span>&gt; <span class="keyword">auto</span> <span class="title">get</span><span class="params">(<span class="type">const</span> Customer&amp; c)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">auto</span> <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(<span class="type">const</span> Customer&amp; c) &#123; <span class="keyword">return</span> c.<span class="built_in">getFirst</span>(); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">auto</span> <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(<span class="type">const</span> Customer&amp; c) &#123; <span class="keyword">return</span> c.<span class="built_in">getLast</span>(); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">auto</span> <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(<span class="type">const</span> Customer&amp; c) &#123; <span class="keyword">return</span> c.<span class="built_in">getValue</span>(); &#125;</span><br></pre></td></tr></table></figure><br>在这里，我们声明了模板函数，然后为所有情况都写出来对应的全特化形式。</p>
<p>注意，模板函数的全特化必须与模板函数的签名一致（也包括一致的返回类型）。原因是我们只提供了特定的“实现”，而不是声明新的函数。下面的代码不能通过编译：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;std::<span class="type">size_t</span>&gt; <span class="keyword">auto</span> <span class="title">get</span><span class="params">(<span class="type">const</span> Customer&amp; c)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; std::string <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(<span class="type">const</span> Customer&amp; c) &#123; <span class="keyword">return</span> c.<span class="built_in">getFirst</span>(); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; std::string <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(<span class="type">const</span> Customer&amp; c) &#123; <span class="keyword">return</span> c.<span class="built_in">getLast</span>(); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="type">long</span> <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(<span class="type">const</span> Customer&amp; c) &#123; <span class="keyword">return</span> c.<span class="built_in">getValue</span>(); &#125;</span><br></pre></td></tr></table></figure><br>通过使用新的<strong>编译时if特性</strong>，我们可以所有特化形式的<code>get&lt;&gt;()</code>组合到一个函数里面：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;std::<span class="type">size_t</span> I&gt; <span class="keyword">auto</span> <span class="title">get</span><span class="params">(<span class="type">const</span> Customer&amp; c)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(I &lt; <span class="number">3</span>);</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(I == <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">getFirst</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (I == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">getLast</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="comment">// I == 2</span></span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">getValue</span>();</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>有了这些API，就能对Customer的对象使用结构化绑定了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Customer <span class="title">c</span><span class="params">(<span class="string">&quot;Tim&quot;</span>, <span class="string">&quot;Starr&quot;</span>, <span class="number">42</span>)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> [f, l, v] = c;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;f/l/v: &quot;</span> &lt;&lt; f &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">// modify structured bindings:</span></span><br><span class="line">  std::string s = std::<span class="built_in">move</span>(f);</span><br><span class="line">  l = <span class="string">&quot;Waters&quot;</span>;</span><br><span class="line">  v += <span class="number">10</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;f/l/v: &quot;</span> &lt;&lt; f &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;c: &quot;</span> &lt;&lt; c.<span class="built_in">getFirst</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">  &lt;&lt; c.<span class="built_in">getLast</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c.<span class="built_in">getValue</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;s: &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>和往常一样，结构化绑定f，l和v是新的匿名变量的成员的别名，新的匿名变量经由c初始化。初始化为每个成员调用相应的getter函数。因此，在初始化后，修改c不会影响到结构化绑定（反之亦然）。所以，程序的输出如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f/l/v: Tim Starr <span class="number">42</span></span><br><span class="line">f/l/v:  Waters <span class="number">52</span></span><br><span class="line">c: Tim Starr <span class="number">42</span></span><br><span class="line">s: Tim</span><br></pre></td></tr></table></figure><br>你也可以在迭代一个由Customer元素构成的vector的过程中使用结构化绑定：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Customer&gt; coll;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [first, last, val] : coll) &#123;</span><br><span class="line">  std::cout &lt;&lt; first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; last &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对结构化绑定使用<code>decltype</code>仍然回产出它的类型，而不是匿名变量的类型。这意味着<code>decltype(first)</code>是<code>const std::string</code>。</p>
<h4 id="允许针对结构化绑定的写操作"><a href="#允许针对结构化绑定的写操作" class="headerlink" title="允许针对结构化绑定的写操作"></a>允许针对结构化绑定的写操作</h4><p>似若tuple的API可以可以使用产生引用的函数。这使得我们可以允许针对结构化绑定的写操作发生。考虑下面的代码，它为Customer提供了读取和修改成员的API：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lang/customer2.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// for std::move()</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string first;</span><br><span class="line">  std::string last;</span><br><span class="line">  <span class="type">long</span> val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Customer</span> (std::string f, std::string l, <span class="type">long</span> v)</span><br><span class="line">      : <span class="built_in">first</span>(std::<span class="built_in">move</span>(f)), <span class="built_in">last</span>(std::<span class="built_in">move</span>(l)), <span class="built_in">val</span>(v) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> std::string&amp; <span class="title">firstname</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::string&amp; <span class="title">firstname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> std::string&amp; <span class="title">lastname</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::string&amp; <span class="title">lastname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="title">value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">long</span>&amp; <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>要支持读写操作，我们还得为常量引用和非常量引用准备getter重载：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lang/structbind2.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;customer2.hpp&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt; utility&gt;</span> <span class="comment">// for tuple-like API</span></span></span><br><span class="line"><span class="comment">// provide a tuple-like API for class Customer for structured bindings:</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">std</span>::tuple_size&lt;Customer&gt; &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> value = <span class="number">3</span>; <span class="comment">// we have 3 attributes</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">std</span>::tuple_element&lt;<span class="number">2</span>, Customer&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="type">long</span>; <span class="comment">// last attribute is a long</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> Idx&gt; <span class="keyword">struct</span> <span class="title class_">std</span>::tuple_element&lt;Idx, Customer&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = std::string; <span class="comment">// the other attributes are strings</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// define specific getters:</span></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> I&gt; <span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">get</span><span class="params">(Customer &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(I &lt; <span class="number">3</span>);</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(I == <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">firstname</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (I == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">lastname</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// I == 2</span></span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> I&gt; <span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">get</span><span class="params">(<span class="type">const</span> Customer &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(I &lt; <span class="number">3</span>);</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(I == <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">firstname</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (I == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">lastname</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// I == 2</span></span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> I&gt; <span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">get</span><span class="params">(Customer &amp;&amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(I &lt; <span class="number">3</span>);</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(I == <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(c.<span class="built_in">firstname</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (I == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(c.<span class="built_in">lastname</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// I == 2</span></span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>你应该写出这三个重载，来处理常量对象，非常量对象，以及可移动对象。为了返回引用，你应该使用<code>decltype(auto)</code>。</p>
<p>还是之前那样，我们可以使用新的<strong>编译时if特性</strong>，来简化我们的实现，尤其是getter的返回类型不一样时，它更有用。没有编译时if特性，我们只能写出所有的全特化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;std::<span class="type">size_t</span>&gt; <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">get</span><span class="params">(Customer&amp; c)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(Customer&amp; c) &#123; <span class="keyword">return</span> c.<span class="built_in">firstname</span>(); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(Customer&amp; c) &#123; <span class="keyword">return</span> c.<span class="built_in">lastname</span>(); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(Customer&amp; c) &#123; <span class="keyword">return</span> c.<span class="built_in">value</span>(); &#125;</span><br></pre></td></tr></table></figure><br>模板函数声明的签名必须与全特化的一致（包括返回类型）。下面的代码不能编译：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;std::<span class="type">size_t</span>&gt; <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">get</span><span class="params">(Customer&amp; c)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; std::string&amp; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(Customer&amp; c) &#123; <span class="keyword">return</span> c.<span class="built_in">firstname</span>(); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; std::string&amp; <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(Customer&amp; c) &#123; <span class="keyword">return</span> c.<span class="built_in">lastname</span>(); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="type">long</span>&amp; <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(Customer&amp; c) &#123; <span class="keyword">return</span> c.<span class="built_in">value</span>(); &#125;</span><br></pre></td></tr></table></figure><br>做完这些后，你就能使用结构化绑定读取或者修改Customer的成员了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;structbind2.hpp&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Customer <span class="title">c</span><span class="params">(<span class="string">&quot;Tim&quot;</span>, <span class="string">&quot;Starr&quot;</span>, <span class="number">42</span>)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> [f, l, v] = c;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;f/l/v: &quot;</span> &lt;&lt; f &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="comment">// modify structured bindings via references:</span></span><br><span class="line">  <span class="keyword">auto</span> &amp;&amp;[f2, l2, v2] = c;</span><br><span class="line">  std::string s = std::<span class="built_in">move</span>(f2);</span><br><span class="line">  f2 = <span class="string">&quot;Ringo&quot;</span>;</span><br><span class="line">  v2 += <span class="number">10</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;f2/l2/v2: &quot;</span> &lt;&lt; f2 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; l2 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;c: &quot;</span> &lt;&lt; c.<span class="built_in">firstname</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c.<span class="built_in">lastname</span>() &lt;&lt; ✬ ✬ &lt;&lt; c.<span class="built_in">value</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;s: &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>它会输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f/l/v: Tim Starr 42</span><br><span class="line">f2/l2/v2: Ringo Starr 52</span><br><span class="line">c: Ringo Starr 52</span><br><span class="line">s: Tim</span><br></pre></td></tr></table></figure></p>
<h2 id="1-4-后记"><a href="#1-4-后记" class="headerlink" title="1.4 后记"></a>1.4 后记</h2><p>结构化绑定最初由Herb Sutter，Bjarne Stroustrup和Gabriel Dos Reis在<a href="https://wg21.link/p0144r0">https://wg21.link/p0144r0</a>中提出，当时使用花括号而不是方括号。最后这个特性的公认措辞是由Jens Maurer在<a href="https://wg21.link/p0217r3">https://wg21.link/p0217r3</a>中给出。</p>
<h1 id="第二章-带初始化的if和switch"><a href="#第二章-带初始化的if和switch" class="headerlink" title="第二章 带初始化的if和switch"></a>第二章 带初始化的if和switch</h1><p>现在<strong>if</strong>和<strong>switch</strong>控制结构允许我们在普通的条件语句或者选择语句之外再指定一个初始化语句。</p>
<p>比如，你可以这样写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (status s = <span class="built_in">check</span>(); s != status::success) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中初始化语句是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status s = <span class="built_in">check</span>();</span><br></pre></td></tr></table></figure><br>它初始化s，然后用if判断s是否是有效状态。</p>
<h2 id="2-1-带初始化的if"><a href="#2-1-带初始化的if" class="headerlink" title="2.1 带初始化的if"></a>2.1 带初始化的if</h2><p>任何在if语句内初始化的值的生命周期都持续到then代码块或者else代码块（如果有的话）的最后。比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::ofstream strm = <span class="built_in">getLogStrm</span>(); coll.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    strm &lt;&lt; <span class="string">&quot;&lt;no data&gt;\n&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : coll) &#123;</span><br><span class="line">        strm &lt;&lt; elem &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// strm no longer declared</span></span><br></pre></td></tr></table></figure><br>strm的析构函数回在then代码块或者else代码块的最后调用。</p>
<p>另一个例子是执行一些依赖某些条件的任务的时候使用锁：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::lock_guard&lt;std::mutex&gt; lg&#123;collMutex&#125;; !coll.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; coll.<span class="built_in">front</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为有<strong>类模板参数推导</strong>，也可以这样写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::lock_guard lg&#123;collMutex&#125;; !coll.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; coll.<span class="built_in">front</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>任何情况下，上面的代码都等价于：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lg&#123;collMutex&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!coll.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; coll.<span class="built_in">front</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>区别在于lg是在if语句的作用域中定义的，因此与条件在相同的作用域（声明性区域）中，就像for循环中初始化的情况一样。</p>
<p>任何被初始化的对象都必须有一个名字。否则，初始化语句会长久一个立即销毁大的临时值。举个例子，初始化一个没有名字的lock guard，其后的条件检查不是在加锁环境下进行的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::lock_guard&lt;std::mutex&gt;&#123;collMutex&#125;; <span class="comment">// run-time ERROR:</span></span><br><span class="line">        !coll.<span class="built_in">empty</span>()) &#123; <span class="comment">// - no longer locked</span></span><br><span class="line">    std::cout &lt;&lt; coll.<span class="built_in">front</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// - no longer locked</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>一般来说，一个<code>_</code>作为名字也是可以的（一些程序员喜欢它，另一些讨厌它因为它污染全局命名空间）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::lock_guard&lt;std::mutex&gt; _&#123;collMutex&#125;; <span class="comment">// OK, but...</span></span><br><span class="line">    !coll.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  std::cout &lt;&lt; coll.<span class="built_in">front</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来是第三个例子，考虑一段代码，插入新元素到map或者unordered map。你可以检查操作是否成功，就像下面一样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; coll;</span><br><span class="line">... </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> [pos, ok] = coll.<span class="built_in">insert</span>(&#123;<span class="string">&quot;new&quot;</span>, <span class="number">42</span>&#125;); !ok) &#123;</span><br><span class="line">  <span class="comment">// if insert failed, handle error using iterator pos:</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> &amp;[key, val] = *pos;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;already there: &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这段代码还是用了结构化绑定，给返回值和元素插入的位置pos分别赋予了名字，而不是first和second。在C++17前，上面相应的检查必须像下面一样规范：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ret = coll.<span class="built_in">insert</span>(&#123;<span class="string">&quot;new&quot;</span>, <span class="number">42</span>&#125;);</span><br><span class="line"><span class="keyword">if</span> (!ret.second) &#123;</span><br><span class="line">  <span class="comment">// if insert failed, handle error using iterator ret.first</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> &amp;elem = *(ret.first);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;already there: &quot;</span> &lt;&lt; elem.first &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意这种带if的初始化也能用于编译时if特性。</p>
<h2 id="2-2-带初始化的switch"><a href="#2-2-带初始化的switch" class="headerlink" title="2.2 带初始化的switch"></a>2.2 带初始化的switch</h2><p>使用带初始化的switch语句允许我们在检查条件并决定控制流跳转到哪个case执行之前初始化一个对象。</p>
<p>比如，我们可以先初始化一个<strong>文件系统路径</strong>，再根据路径的类型选择对应的处理方式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::filesystem;</span><br><span class="line">... </span><br><span class="line"><span class="keyword">switch</span> (path <span class="built_in">p</span>(name); <span class="built_in">status</span>(p).<span class="built_in">type</span>()) &#123;</span><br><span class="line"><span class="keyword">case</span> file_type::not_found:</span><br><span class="line">  std::cout &lt;&lt; p &lt;&lt; <span class="string">&quot; not found\n&quot;</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> file_type::directory:</span><br><span class="line">  std::cout &lt;&lt; p &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : std::filesystem::<span class="built_in">directory_iterator</span>(p)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;- &quot;</span> &lt;&lt; e.<span class="built_in">path</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  std::cout &lt;&lt; p &lt;&lt; <span class="string">&quot; exists\n&quot;</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>初始化的p能在整个switch语句中使用。</p>
<h2 id="2-3-后记"><a href="#2-3-后记" class="headerlink" title="2.3 后记"></a>2.3 后记</h2><p>带初始化的if和switch最初由Thomas Koppe在<a href="https://wg21.link/p0305r0">https://wg21.link/p0305r0</a>中提出，当时只有带初始化的if没有带初始化的switch。最后这个特性的公认措辞是由Thomas Koppe在<a href="https://wg21.link/p0305r1">https://wg21.link/p0305r1</a>中给出。</p>
<h1 id="第三章-内联变量"><a href="#第三章-内联变量" class="headerlink" title="第三章 内联变量"></a>第三章 内联变量</h1><p>C++的一个优点是它支持header-only（译注：即只有头文件）的库。然而，截止C++17，header-only的库也不能有全局变量或者对象出现。</p>
<p>C++17后，你可以在头文件中使用inline定义变量，如果这个变量被多个翻译单元（translation unit）使用，它们都会指向相同对象：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">inline</span> std::string name = <span class="string">&quot;&quot;</span>; <span class="comment">// OK since C++17</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> MyClass myGlobalObj; <span class="comment">// OK even if included/defined by multiple CPP files</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-1-内联变量的动机"><a href="#3-1-内联变量的动机" class="headerlink" title="3.1 内联变量的动机"></a>3.1 内联变量的动机</h2><p>C++不允许在class内部初始化非const静态成员：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="type">static</span> std::string name = <span class="string">&quot;&quot;</span>;  <span class="comment">// Compile-Time ERROR</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在class外面定义这个变量定义这个变量，且变量定义是在头文件中，多个CPP文件包含它，仍然会引发错误：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="type">static</span> std::string name; <span class="comment">// OK</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">MyClass::name = <span class="string">&quot;&quot;</span>; <span class="comment">// Link ERROR if included by multiple CPP files</span></span><br></pre></td></tr></table></figure><br>根据一处定义规则（one definition 入了，ODR），每个翻译单元只能定义变量最多一次。</p>
<p>即便有预处理保护（译注：也叫头文件保护，header guard）也没有用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYHEADER_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYHEADER_HPP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="type">static</span> std::string name; <span class="comment">// OK</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">MyClass.name = <span class="string">&quot;&quot;</span>; <span class="comment">// Link ERROR if included by multiple CPP files</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><br>不是因为头文件可能被包含多次，问题是两个不同的CPP如果都包含这个头文件，那么<code>MyClass.name</code>可能定义两次。</p>
<p>同样的原因，如果你在头文件中定义一个变量，你会得到一个链接时错误：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">MyClass myGlobalObject; <span class="comment">// Link ERROR if included by multiple CPP files</span></span><br></pre></td></tr></table></figure></p>
<h4 id="临时解决方案"><a href="#临时解决方案" class="headerlink" title="临时解决方案"></a>临时解决方案</h4><p>这里有一些临时的应对措施：</p>
<ul>
<li>你可以在class/struct内初始化一个static const整型数据成员：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> trace = <span class="literal">false</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>你可以定义一个返回局部static对象的内联函数：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> std::string name = <span class="string">&quot;initial value&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>你可以定义一个static成员函数返回它的值：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">getMyGlobalObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> std::string myGlobalObject = <span class="string">&quot;initial value&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> myGlobalObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>你可以使用变量模板（C++14及以后）：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = std::string&gt;</span><br><span class="line">T myGlobalObject = <span class="string">&quot;initial value&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li>你可以继承一个包含static成员的类模板：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Dummy&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassStatics</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Dummy&gt;</span><br><span class="line">std::string MyClassStatics&lt;Dummy&gt;::name = <span class="string">&quot;initial value&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> MyClassStatics&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
但是这些方法都有不小的负载，可读性也比较差，想要使用全局变量也比较困难。除此之外，全局变量的初始化可能会推迟到它第一次使用的时候，这使得应用程序不能在启动的时候把对象初始化好。（比如用一个对象监控进程）。</li>
</ul>
<h2 id="3-2-使用内联变量"><a href="#3-2-使用内联变量" class="headerlink" title="3.2 使用内联变量"></a>3.2 使用内联变量</h2><p>现在，有了inline，你可以在头文件中定义一个全局可用的变量，它可以被多个CPP文件包含：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">inline</span> std::string name = <span class="string">&quot;&quot;</span>; <span class="comment">// OK since C++17</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> MyClass myGlobalObj; <span class="comment">// OK even if included/defined by multiple CPP files</span></span><br></pre></td></tr></table></figure><br>初始化发生在第一个包含该头文件的翻译单元。</p>
<p>形式化来说，在变量前使用inline和将函数声明为inline有相同的语义：</p>
<ul>
<li>如果每个定义都是相同的，那么它可以在多个翻译单元定义</li>
<li>它必须在使用它的每个翻译单元中定义</li>
</ul>
<p>两者都是通过包含来自同一头文件的定义来实现的。最终程序的行为就像是只有一个变量。</p>
<p>你甚至可以在头文件中定义原子类型的变量：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> std::atomic&lt;<span class="type">bool</span>&gt; ready&#123;<span class="literal">false</span>&#125;;</span><br></pre></td></tr></table></figure><br>注意，对于<code>std::atomic</code>，通常在定义它的时候你还得初始化它。</p>
<p>这意味着，你仍然必须保证在你初始化它之前类型是完全的（complete）。比如，如果一个struct或者class有一个static成员，类型是自身，那么该成员只能在该类型被声明后才能使用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyType</span> &#123;</span><br><span class="line">  <span class="type">int</span> value;</span><br><span class="line">  <span class="built_in">MyType</span>(<span class="type">int</span> i) : value&#123;i&#125; &#123;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// one static object to hold the maximum value of this type:</span></span><br><span class="line">  <span class="type">static</span> MyType max; <span class="comment">// can only be declared here</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> MyType MyType::max&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><br>参见另一个使用内联变量的例子，它会<strong>使用头文件跟踪所有new调用</strong>。</p>
<h2 id="3-3-constexpr隐式包含inline"><a href="#3-3-constexpr隐式包含inline" class="headerlink" title="3.3 constexpr隐式包含inline"></a>3.3 constexpr隐式包含inline</h2><p>对于static数据成员，constexpr现在隐式包含inline的语义，所以下面的声明在C++17后会<strong>定义</strong>static数据成员n：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> n = <span class="number">5</span>; <span class="comment">// C++11/C++14: declaration</span></span><br><span class="line">                              <span class="comment">// since C++17: definition</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>换句话说，它与下面的代码一样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> &#123;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在C++17之前,有时候你也可以只声明不定义。考虑下面的声明：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>如果不需要<code>D::n</code>的定义，这就足够了，例如，<code>D::n</code>只通过值传递的话：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; D::n; <span class="comment">// OK (ostream::operator&lt;&lt;(int) gets D::n by value)</span></span><br></pre></td></tr></table></figure><br>如果<code>D::n</code>是传引用到非内联函数，并且/或者函数调用没有优化，那么就是无效的。比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">inc</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">inc</span>(D::n); <span class="comment">// usually an ERROR</span></span><br></pre></td></tr></table></figure><br>这段代码违背了一处定义规则（ODR）。当使用带优化的编译器构建时，它可能正常工作，或者抛出链接时错误指出缺少定义。当使用不带优化的编译器时，几乎可以确定这段代码会由于缺少<code>D::n</code>的定义而拒绝编译：</p>
<p>因此，在C++17前，你不得不在相同的翻译单元定义<code>D::n</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> D::n; <span class="comment">// C++11/C++14: definition</span></span><br><span class="line">                    <span class="comment">// since C++17: redundant declaration (deprecated)</span></span><br></pre></td></tr></table></figure><br>当使用C++17构建，在class中的声明本身就是一个定义，所以这段代码就算没有前面的定义也是有效的。前面的定义也是可以的，但是已经废弃。</p>
<h2 id="3-4-内联变量和thread-local"><a href="#3-4-内联变量和thread-local" class="headerlink" title="3.4 内联变量和thread_local"></a>3.4 内联变量和thread_local</h2><p>使用thread_local你可以让每个线程拥有一个内联变量：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadData</span> &#123;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">static</span> <span class="keyword">thread_local</span> std::string name; <span class="comment">// unique name per thread</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">thread_local</span> std::vector&lt;std::string&gt; cache; <span class="comment">// one cache per thread</span></span><br></pre></td></tr></table></figure><br>为了演示一个完整的例子，考虑下面的头文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lang/inlinethreadlocal.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyData</span> &#123;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">static</span> std::string gName = <span class="string">&quot;global&quot;</span>; <span class="comment">// unique in program</span></span><br><span class="line">  <span class="keyword">inline</span> <span class="type">static</span> <span class="keyword">thread_local</span> std::string tName = <span class="string">&quot;tls&quot;</span>; <span class="comment">// unique per thread</span></span><br><span class="line">  std::string lName = <span class="string">&quot;local&quot;</span>; <span class="comment">// for each object</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; msg &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;- gName: &quot;</span> &lt;&lt; gName &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;- tName: &quot;</span> &lt;&lt; tName &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;- lName: &quot;</span> &lt;&lt; lName &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">thread_local</span> MyData myThreadData; <span class="comment">// one object per thread</span></span><br></pre></td></tr></table></figure><br>你可以在有<code>main()</code>的翻译单元使用它：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lang/inlinethreadlocal1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inlinethreadlocal.hpp&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  myThreadData.<span class="built_in">print</span>(<span class="string">&quot;main() begin:&quot;</span>);</span><br><span class="line">  myThreadData.gName = <span class="string">&quot;thread1 name&quot;</span>;</span><br><span class="line">  myThreadData.tName = <span class="string">&quot;thread1 name&quot;</span>;</span><br><span class="line">  myThreadData.lName = <span class="string">&quot;thread1 name&quot;</span>;</span><br><span class="line">  myThreadData.<span class="built_in">print</span>(<span class="string">&quot;main() later:&quot;</span>);</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(foo)</span></span>;</span><br><span class="line">  t.<span class="built_in">join</span>();</span><br><span class="line">  myThreadData.<span class="built_in">print</span>(<span class="string">&quot;main() end:&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>你可以在另一个定义<code>foo()</code>的翻译单元使用头文件，其中<code>foo()</code>被不同的线程调用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lang/inlinethreadlocal2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inlinethreadlocal.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  myThreadData.<span class="built_in">print</span>(<span class="string">&quot;foo() begin:&quot;</span>);</span><br><span class="line">  myThreadData.gName = <span class="string">&quot;thread2 name&quot;</span>;</span><br><span class="line">  myThreadData.tName = <span class="string">&quot;thread2 name&quot;</span>;</span><br><span class="line">  myThreadData.lName = <span class="string">&quot;thread2 name&quot;</span>;</span><br><span class="line">  myThreadData.<span class="built_in">print</span>(<span class="string">&quot;foo() end:&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>程序的输出如下：<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">main() begin:</span><br><span class="line">- gName: global</span><br><span class="line">- tName: tls</span><br><span class="line">- lName: local</span><br><span class="line">main() later:</span><br><span class="line">- gName: thread1 name</span><br><span class="line">- tName: thread1 name</span><br><span class="line">- lName: thread1 name</span><br><span class="line">foo() begin:</span><br><span class="line">- gName: thread1 name</span><br><span class="line">- tName: tls</span><br><span class="line">- lName: local</span><br><span class="line">foo() end:</span><br><span class="line">- gName: thread2 name</span><br><span class="line">- tName: thread2 name</span><br><span class="line">- lName: thread2 name</span><br><span class="line">main() end:</span><br><span class="line">- gName: thread2 name</span><br><span class="line">- tName: thread1 name</span><br><span class="line">- lName: thread1 name</span><br></pre></td></tr></table></figure></p>
<h2 id="3-5-后记"><a href="#3-5-后记" class="headerlink" title="3.5 后记"></a>3.5 后记</h2><p>David Krauss的文档<a href="https://wg21.link/n4147">https://wg21.link/n4147</a>是内联变量产生的动机。内联变量最初由Hal Finkel和Richard Smith在<a href="https://wg21.link/n4424">https://wg21.link/n4424</a>中提出。最后这个特性的公认措辞是由Hal Finkel和Richard Smith在<a href="https://wg21.link/p0386r2"> https://wg21.link/p0386r2</a>中给出。</p>
<h1 id="第四章-聚合扩展"><a href="#第四章-聚合扩展" class="headerlink" title="第四章 聚合扩展"></a>第四章 聚合扩展</h1><p>C++中有一种初始化对象的方式叫做聚合初始化（aggregate initialization），它允许用花括号聚集多个值来初始化。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">  std::string name;</span><br><span class="line">  <span class="type">double</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Data x&#123;<span class="string">&quot;test1&quot;</span>, <span class="number">6.778</span>&#125;;</span><br></pre></td></tr></table></figure><br>从C++17开始，聚合还支持带基类的数据结构，所以下面这种数据结构用列表初始化也是允许的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MoreData</span> : Data &#123;</span><br><span class="line">  <span class="type">bool</span> done;</span><br><span class="line">&#125;;</span><br><span class="line">MoreData y&#123;&#123;<span class="string">&quot;test1&quot;</span>, <span class="number">6.778</span>&#125;, <span class="literal">false</span>&#125;;</span><br></pre></td></tr></table></figure><br>正如你看到的，聚合初始化现在支持嵌套的花括号传给基类的成员来初始化。</p>
<p>对于带有成员的子对象的初始化，如果基类或子对象只有一个值，则可以跳过嵌套的大括号：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoreData y&#123;<span class="string">&quot;test1&quot;</span>, <span class="number">6.778</span>, <span class="literal">false</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-1-扩展聚合初始化的动机"><a href="#4-1-扩展聚合初始化的动机" class="headerlink" title="4.1 扩展聚合初始化的动机"></a>4.1 扩展聚合初始化的动机</h2><p>如果没有这项特性的话，继承一个类之后就不能使用聚合初始化了，需要你为新类定义一个构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cpp14Data</span> : Data &#123;</span><br><span class="line">  <span class="type">bool</span> done;</span><br><span class="line">  <span class="built_in">Cpp14Data</span> (<span class="type">const</span> std::string&amp; s, <span class="type">double</span> d, <span class="type">bool</span> b)</span><br><span class="line">      : Data&#123;s,d&#125;, done&#123;b&#125; &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Cpp14Data y&#123;<span class="string">&quot;test1&quot;</span>, <span class="number">6.778</span>, <span class="literal">false</span>&#125;;</span><br></pre></td></tr></table></figure><br>现在，有了这个特性我们可以自由的使用嵌套的花括号，如果只传递一个值还可以省略它：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MoreData x&#123;&#123;<span class="string">&quot;test1&quot;</span>, <span class="number">6.778</span>&#125;, <span class="literal">false</span>&#125;; <span class="comment">// OK since C++17</span></span><br><span class="line">MoreData y&#123;<span class="string">&quot;test1&quot;</span>, <span class="number">6.778</span>, <span class="literal">false</span>&#125;; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><br>注意，因为它现在是聚合体，其它初始化方式也是可以的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MoreData u; <span class="comment">// OOPS: value/done are uninitialized</span></span><br><span class="line">MoreData z&#123;&#125;; <span class="comment">// OK: value/done have values 0/false</span></span><br></pre></td></tr></table></figure><br>如果这个看起来太危险了，你还是最好提供一个构造函数。</p>
<h2 id="4-2-使用扩展的聚合初始化"><a href="#4-2-使用扩展的聚合初始化" class="headerlink" title="4.2 使用扩展的聚合初始化"></a>4.2 使用扩展的聚合初始化</h2><p>关于这个特性的常见用法是列表初始化一个C风格的数据结构，该数据结构继承自一个类，然后添加了一些数据成员或者操作。比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">  <span class="type">double</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PData</span> : Data &#123;</span><br><span class="line">  <span class="type">bool</span> critical;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; ✬[✬ &lt;&lt; name &lt;&lt; ✬,✬ &lt;&lt; value &lt;&lt; <span class="string">&quot;]\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PData y&#123;&#123;<span class="string">&quot;test1&quot;</span>, <span class="number">6.778</span>&#125;, <span class="literal">false</span>&#125;;</span><br><span class="line">y.<span class="built_in">print</span>();</span><br></pre></td></tr></table></figure><br>这里里面的花括号会传递给基类Data的数据成员。</p>
<p>你可以跳过一些初始值。这种情况下这些元素是零值初始化（zero initalized）（调用默认构造函数或者将基本数据类型初始化为0，false或者nullptr）。比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PData a&#123;&#125;;          <span class="comment">// zero-initialize all elements</span></span><br><span class="line">PData b&#123;&#123;<span class="string">&quot;msg&quot;</span>&#125;&#125;;   <span class="comment">// same as &#123;&#123;&quot;msg&quot;,0.0&#125;,false&#125;</span></span><br><span class="line">PData c&#123;&#123;&#125;, <span class="literal">true</span>&#125;;  <span class="comment">// same as &#123;&#123;nullptr,0.0&#125;,true&#125;</span></span><br><span class="line">PData d;            <span class="comment">// values of fundamental types are unspecified</span></span><br></pre></td></tr></table></figure><br>注意使用空的花括号和不使用花括号的区别。</p>
<ul>
<li>a零值初始化所有成员，所以name被默认构造，double value被初始化为0.0，bool flag被初始化为false。</li>
<li>d只调用name的默认构造函数。所有其它的成员都没用被初始化，所以值是未指定的（unspecified）。</li>
</ul>
<p>你也可以继承非聚合体来创建一个聚合体。比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyString</span> : std::string &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;&lt;undefined&gt;\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="built_in">c_str</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyString x&#123;&#123;<span class="string">&quot;hello&quot;</span>&#125;&#125;;</span><br><span class="line">MyString y&#123;<span class="string">&quot;world&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><br>甚至还可以继承多个非聚合体：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : std::string, std::complex&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">  std::string data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>然后使用下面的代码初始化它们：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D&lt;<span class="type">float</span>&gt; s&#123;&#123;<span class="string">&quot;hello&quot;</span>&#125;, &#123;<span class="number">4.5</span>,<span class="number">6.7</span>&#125;, <span class="string">&quot;world&quot;</span>&#125;;        <span class="comment">// OK since C++17</span></span><br><span class="line">D&lt;<span class="type">float</span>&gt; t&#123;<span class="string">&quot;hello&quot;</span>, &#123;<span class="number">4.5</span>, <span class="number">6.7</span>&#125;, <span class="string">&quot;world&quot;</span>&#125;;         <span class="comment">// OK since C++17</span></span><br><span class="line">std::cout &lt;&lt; s.data;                              <span class="comment">// outputs: ”world”</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">static_cast</span>&lt;std::string&gt;(s);         <span class="comment">// outputs: ”hello”</span></span><br><span class="line">std::cout &lt;&lt; <span class="keyword">static_cast</span>&lt;std::complex&lt;<span class="type">float</span>&gt;&gt;(s); <span class="comment">// outputs: (4.5,6.7)</span></span><br></pre></td></tr></table></figure><br>内部花括号的值（initializer_lists）会传递给基类，其传递顺序遵循基类声明的顺序。</p>
<p>这项新特性还有助于用很少的代码定义<strong>lambdas重载</strong>。</p>
<h2 id="4-3-聚合体定义"><a href="#4-3-聚合体定义" class="headerlink" title="4.3 聚合体定义"></a>4.3 聚合体定义</h2><p>总结一下，C++17的聚合体（aggregate）定义如下：</p>
<ul>
<li>是个数组</li>
<li>或者是个类类型（class，struct，union），其中<ul>
<li>没有用户声明的构造函数或者explicit构造函数</li>
<li>没有使用using声明继承的构造函数</li>
<li>没有private或者protected的非static数据成员</li>
<li>没有virtual函数</li>
<li>没有virtual，private或者protected基类</li>
</ul>
</li>
</ul>
<p>为了让聚合体可以使用，还要求聚合体没有private或者protected基类成员或者构造函数在初始化的时候使用。</p>
<p>C++17还引入了一种新的type trait即<code>is_aggregate&lt;&gt;</code>来检查一个类型是否是聚合体：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : std::string, std::complex&lt;T&gt; &#123;</span><br><span class="line">  std::string data;</span><br><span class="line">&#125;;</span><br><span class="line">D&lt;<span class="type">float</span>&gt; s&#123;&#123;<span class="string">&quot;hello&quot;</span>&#125;, &#123;<span class="number">4.5</span>,<span class="number">6.7</span>&#125;, <span class="string">&quot;world&quot;</span>&#125;; <span class="comment">// OK since C++17</span></span><br><span class="line">std::cout &lt;&lt; std::is_aggregate&lt;<span class="keyword">decltype</span>(s)&gt;::value; <span class="comment">// outputs: 1 (true)</span></span><br></pre></td></tr></table></figure></p>
<h2 id="4-4-向后不兼容"><a href="#4-4-向后不兼容" class="headerlink" title="4.4 向后不兼容"></a>4.4 向后不兼容</h2><p>注意，下面示例中的代码将不再能通过编译：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lang/aggr14.cpp</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">struct</span> <span class="title class_">Derived</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Base</span>() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Derived d1&#123;&#125;; <span class="comment">// ERROR since C++17</span></span><br><span class="line">  Derived d2; <span class="comment">// still OK (but might not initialize)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>C++17之前，Derived不是一个聚合体，所以：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived d1&#123;&#125;;</span><br></pre></td></tr></table></figure><br>调用Derived隐式定义的默认构造函数，它默认调用基类Base的默认构造函数。虽然基类的默认构造函数是private，但是通过子类的默认构造函数调用它是有效的，因为子类被声明为一个friend类。</p>
<p>C++17开始，Derived是一个聚合体，没有隐式的默认构造函数。所以这个初始化被认为是聚合初始化，聚合初始化不允许调用基类的默认构造函数。不管基类是不是friend都不行。</p>
<h2 id="4-5-后记"><a href="#4-5-后记" class="headerlink" title="4.5 后记"></a>4.5 后记</h2><p>内联变量最初由Oleg Smolsky在<a href="https://wg21.link/n4404">https://wg21.link/n4404</a>中提出。最后这个特性的公认措辞是由Oleg Smolsky在<a href="https://wg21.link/p0017r1"> https://wg21.link/p0017r1</a>中给出。</p>
<p>新的type trait即<code>std::is_aggregate&lt;&gt;</code>最初作为美国国家机构对C++ 17标准化的评论而引入。（参见<a href="https://wg21.link/lwg2911">https://wg21.link/lwg2911</a>）</p>
<h1 id="第五章-强制拷贝消除或者传递unmaterialized对象"><a href="#第五章-强制拷贝消除或者传递unmaterialized对象" class="headerlink" title="第五章 强制拷贝消除或者传递unmaterialized对象"></a>第五章 强制拷贝消除或者传递unmaterialized对象</h1><p>本章的主题可以从两个角度来看：</p>
<ul>
<li>C++17引入了新的规则，在确定条件下可以强制消除拷贝：以前临时对象传值或者返回临时对象期间发生的拷贝操作的消除是可选的，现在是强制的。</li>
<li>因此，我们处理传递未具体化对象的值以进行初始化<br>我将从技术上介绍这个特性，然后讨论具体化（materialization）的效果和相关术语。</li>
</ul>
<h2 id="5-1-临时量强制拷贝消除的动机"><a href="#5-1-临时量强制拷贝消除的动机" class="headerlink" title="5.1 临时量强制拷贝消除的动机"></a>5.1 临时量强制拷贝消除的动机</h2><p>标准伊始，C++就明确允许一些拷贝操作可以被省略（消除），不调用拷贝构造函数会失去可能存在的副作用，从而可能影响程序的行为，即便这样也在所不惜。强制拷贝消除的场景之一是使用临时对象初始化新对象。这个情况经常发生，尤其是以值传递方式将临时对象传递给一个函数，或者函数返回临时对象。举个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(MyClass param)</span> </span>&#123; <span class="comment">// param is initialized by passed argument</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">MyClass <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">MyClass</span>(); <span class="comment">// returns temporary</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">foo</span>(<span class="built_in">MyClass</span>());       <span class="comment">// pass temporary to initialize param</span></span><br><span class="line">  MyClass x = <span class="built_in">bar</span>();    <span class="comment">// use returned temporary to initialize x</span></span><br><span class="line">  <span class="built_in">foo</span>(<span class="built_in">bar</span>());           <span class="comment">// use returned temporary to initialize param</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但是，由于这些拷贝消除优化不是强制的，要拷贝的对象必须提供隐式或显式的拷贝或移动构造函数。也就是说，尽管拷贝/移动构造函数一般不会调用，但是也必须存在。如果没有定义拷贝/移动构造函数，那么代码不能通过编译。</p>
<p>因此，下面MyClass的定义的代码编译不了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// no copy/move constructor defined:</span></span><br><span class="line">  <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">MyClass</span>(MyClass&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这里没有拷贝构造函数就足够了，因为仅当没有用户声明的拷贝构造（或者拷贝赋值运算符）时移动构造函数才隐式可用。</p>
<p>C++17后，临时变量初始化新对象期间发生的拷贝是强制消除的。事实上，在后面我们会看到，我们简单的传值作为实参初始化或者返回一个值，该值会接下来用于具体化（materalize）一个新对象。</p>
<p>这意味着就算MyClass类完全没有表示启用拷贝操作，上面的例子也能通过编译。</p>
<p>然而，请注意其他可选的拷贝消除仍然是可选的，仍然要求一个可调用的拷贝或者移动构造函数，比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  MyClass obj;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> obj;    <span class="comment">// still requires copy/move support</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这里，<code>foo()</code>里面的obj是一个带名字的变量（即左值（lvalue））。所以会发生命名的返回值优化（named return value optimization，NRVO），它要求类型支持拷贝或者移动操作。即便obj是一个参数也仍然如此：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">bar</span><span class="params">(MyClass obj)</span> <span class="comment">// copy elision for passed temporaries</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> obj; <span class="comment">// still requires copy/move support</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>传递一个临时量（即纯右值（prvalue））到函数作为实参，不会发生拷贝/移动操作，但是返回这个参数仍然需要拷贝/移动操作，因为返回的对象有名字。</p>
<p>作为这一改变的部分，值范畴（value categories）修改和新增了很多术语。</p>
<h2 id="5-2-临时量强制拷贝消除的好处"><a href="#5-2-临时量强制拷贝消除的好处" class="headerlink" title="5.2 临时量强制拷贝消除的好处"></a>5.2 临时量强制拷贝消除的好处</h2><p>强制拷贝消除的一个好处是，很明显，如果拷贝操作开心较大时会得到更好的性能。虽然移动语言显著减少了拷贝开销，但是完全不执行拷贝能极大的提示性能。这可能会减少使用出参（译注：所谓出参即可out parameter，是指使用参数来传递返回信息，通常是一个指针或者引用）代替返回一个值（假设这个值是由返回语句创建的）的需求。</p>
<p>另一个好处是现在只要写一个工厂函数它总是能工作，因为现在的工厂函数可以返回对象，即便对象不允许拷贝/移动。比如，考虑下面的泛型工厂函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lang/factory.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">T <span class="title">create</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> T&#123;std::forward&lt;Args&gt;(args)...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个函数现在甚至可以用于<code>std::atomic&lt;&gt;</code>这种类型，该类型既没有定义拷贝构造函数也没有定义移动构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lang/factory.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;factory.hpp&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">create</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; up = create&lt;std::unique_ptr&lt;<span class="type">int</span>&gt;&gt;(<span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">42</span>&#125;);</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; ai = create&lt;std::atomic&lt;<span class="type">int</span>&gt;&gt;(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个特性带来的另一个效果是，如果类有显式delete的移动构造函数，你现在可以返回临时值，然后用它初始化对象：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CopyOnly</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CopyOnly</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CopyOnly</span>(<span class="type">int</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CopyOnly</span>(<span class="type">const</span> CopyOnly&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">CopyOnly</span>(CopyOnly&amp;&amp;) = <span class="keyword">delete</span>; <span class="comment">// explicitly deleted</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">CopyOnly <span class="title">ret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CopyOnly&#123;&#125;; <span class="comment">// OK since C++17</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CopyOnly x = <span class="number">42</span>; <span class="comment">// OK since C++17</span></span><br></pre></td></tr></table></figure><br>x的初始化代码在C++17之前是无效的，因为拷贝初始化需要将42转换为一个临时对象，然后临时对象原则上需要提供一个移动构造函数，尽管不会用到它。（）</p>
<h2 id="5-3-值范畴的解释"><a href="#5-3-值范畴的解释" class="headerlink" title="5.3 值范畴的解释"></a>5.3 值范畴的解释</h2><p>强制拷贝消除带来的额外工作是值范畴（value categories）的一些修改。</p>
<h3 id="5-3-1-值范畴"><a href="#5-3-1-值范畴" class="headerlink" title="5.3.1 值范畴"></a>5.3.1 值范畴</h3><p>在C++中的每个表达式都有一个值范畴。这个值范畴描述了表达式可以做什么。</p>
<h4 id="值范畴的历史"><a href="#值范畴的历史" class="headerlink" title="值范畴的历史"></a>值范畴的历史</h4><p>从C语言历史的角度来看，在赋值语句中只有lvalue（左值）和rvalue（右值）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><br>表达式x是lvalue，因为它可以出现在赋值语句的左边，表达式42是rvalue，因为它只能出现在赋值语句的右边。但是因为ANSI-C，事情变得更复杂一些，因为x如果声明为<code>const int</code>就不能在赋值语句的左边了，但是它仍然是个（不具可修改性的）lvalue。</p>
<p>C++11我们有了可移动的对象，这些对象在语义上是只能出现在赋值语句右边，但是可以被修改，因为赋值语句可以盗取它们的值。基于这个原因，新的值范畴xvalue被引入，并且之前的值范畴rvalue有了新名字即prvalue。</p>
<h4 id="C-11的值范畴"><a href="#C-11的值范畴" class="headerlink" title="C++11的值范畴"></a>C++11的值范畴</h4><p>C++11后，值范畴如图5.1描述的那样：我们的核心值范畴是lvalue，prvalue（pure rvalue，纯右值），xvalue（eXpiring value，将亡值）。组合得到的值范畴有：glvalue（generalized lvalue，泛化左值，是lvalue和xvalue的结合）以及rvalue（是xvalue和prvalue的结合）。</p>
<p><img src="../public/fig5-1.jpg" align="center"/></p>
<p align="center">图5.1 C++11后的值范畴</p>

<p>lvalue的例子有：</p>
<ul>
<li>一个表达式只包含变量，函数或者成员的名字</li>
<li>一个表达式是字符串字面值</li>
<li>内置一元操作符<code>*</code>的结果（即对原生指针解引用）</li>
<li>返回左值引用（<code>type&amp;</code>）的函数的返回值</li>
</ul>
<p>prvalue的例子有：</p>
<ul>
<li>除字符串字面值外的其他字面值（或者用户定义的字面值，其中与之关联的字面值操作符的返回类型标示值的范畴）</li>
<li>内置一元操作符<code>&amp;</code>的结果（即获取表达式地址）</li>
<li>内置算术运算符的结果</li>
<li>返回值的函数的返回值</li>
</ul>
<p>xvalue的例子有：</p>
<ul>
<li>返回右值引用（<code>type&amp;&amp;</code>，尤其是返回<code>std::move()</code>）的函数的返回值</li>
<li>右值引用到对象类型的转换</li>
</ul>
<p>大概来说：</p>
<ul>
<li>所有使用名字的表达式是lvalue</li>
<li>所有字符串字面值表达式是lvalue</li>
<li>所有其他字面值（4.2，true，nullptr）是prvalue</li>
<li>所有临时变量（尤其是返回值的函数返回的对象）是prvalue</li>
<li><code>std::move()</code>的结果是xvalue</li>
</ul>
<p>举个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X v;</span><br><span class="line"><span class="type">const</span> X c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> X&amp;)</span></span>;   <span class="comment">// accepts an expression of any value category</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(X&amp;&amp;)</span></span>;        <span class="comment">// accepts prvalues and xvalues only, but is a better match</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(v);               <span class="comment">// passes a modifiable lvalue to the first f()</span></span><br><span class="line"><span class="built_in">f</span>(c);               <span class="comment">// passes a non-modifiable lvalue to the first f()</span></span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">X</span>());             <span class="comment">// passes a prvalue to the second f()</span></span><br><span class="line"><span class="built_in">f</span>(std::<span class="built_in">move</span>(v));    <span class="comment">// passes an xvalue to the second f()</span></span><br></pre></td></tr></table></figure><br>值得强调的是，严格来说，glvalue，prvalue和xvalue是针对表达式的， 不是针对值的（这意味着这些值用词不当）。举个例子，一个变量本身不是一个lvalue，只有一个变量放到表达式里才标示这个变量是lvalue：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">3</span>; <span class="comment">// x here is a variable, not an lvalue</span></span><br><span class="line"><span class="type">int</span> y = x; <span class="comment">// x here is an lvalue</span></span><br></pre></td></tr></table></figure><br>第一个语句中3是prvalue，它用来初始化变量x（不是lvalue）。第二个语句中x是lvalue（对它求值会会发现它包含值3）。然后作为lvallue的x转换为prvalue，用来初始化变量y。</p>
<h3 id="5-3-2-C-17的值范畴"><a href="#5-3-2-C-17的值范畴" class="headerlink" title="5.3.2 C++17的值范畴"></a>5.3.2 C++17的值范畴</h3><p>C++17没有改变既有的值范畴，但是阐述了它们的语义（如图5.2所示）</p>
<p><img src="../public/fig5-2.jpg" align="center"/></p>
<p align="center">图5.1 C++17后的值范畴</p>

<p>现在解释值范畴的主要方式是认为我们有两类表达式：</p>
<ul>
<li>glvalue：对象/函数位置的表达式</li>
<li>prvalue：初始化表达式<br>xvalue被认为是一个特殊的位置，表示有一个变量它的资源可以重用（通常因为它接近它的生命周期结尾）。</li>
</ul>
<p>C++17引入了一个新术语，具体化（materialization），表示在某个时刻一个prvalue成为临时对象。因此，临时变量具体化转换（temporary materialization conversion）是指prvalue到xvalue的转换。</p>
<p>任何时刻，期待出现glvalue（lvalue或xvalue）的地方出现prvalue都是有效的，创建一个临时变量并通过prvalue初始化，然后prvallue被替换为xvalue。因此在上面的例子中，严格来说：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> X&amp; p)</span></span>; <span class="comment">// accepts an expression of any value category,</span></span><br><span class="line">                    <span class="comment">// but expects a glvalue</span></span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">X</span>());             <span class="comment">// passes a prvalue materialized as xvalue</span></span><br></pre></td></tr></table></figure><br>因为例子中的<code>f()</code>有一个引用参数，它期待一个glvalue实参。然而，表达式<code>X()</code>是一个prvalue。临时具体化规则因此生效，表达式<code>X()</code>转换为一个xvalue并使用默认构造函数初始化临时变量。</p>
<p>注意具体化不意味着我们创建了一个新的/不同的对象。lvalue引用仍然绑定xvalue和prvalue，虽然后者总是转换到xvalue。</p>
<p>在这些改变后，拷贝消除意义非凡，因为prvalue不再要求可移动，我们只传递一个初始值，这个值迟早会具体化然后初始化一个对象。</p>
<h2 id="5-4-未具体化返回值传递"><a href="#5-4-未具体化返回值传递" class="headerlink" title="5.4 未具体化返回值传递"></a>5.4 未具体化返回值传递</h2><p>未具体化返回值传递是指所有形式的返回临时对象（prvalue）的值：</p>
<ul>
<li>当返回一个不是字符串字面值的字面值：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;    <span class="comment">// return int by value</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当返回类型为临时变量的值或者使用auto：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;   <span class="comment">// return deduced type by value</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> MyType&#123;...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当返回临时对象，并且类型用<code>decltype(auto)</code>推导：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f3</span><span class="params">()</span> </span>&#123;   <span class="comment">// return temporary from return statement by value</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> MyType&#123;...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
记住如果用于初始化的表达式（这里是返回语句）会创建一个临时变量（prvalue），那么用<code>decltype(auto)</code>声明的类型是值。</li>
</ul>
<p>上述所有形式我们都返回一个prvalue的值，我们不需要任何拷贝/移动的支持。</p>
<h2 id="5-5-后记"><a href="#5-5-后记" class="headerlink" title="5.5 后记"></a>5.5 后记</h2><p>强制拷贝消除最初由Richard Smith在<a href="https://wg21.link/p0135r0">https://wg21.link/p0135r0</a>中提出。最后这个特性的公认措辞是由Richard Smith在<a href="https://wg21.link/p0135r1">https://wg21.link/p0135r1</a>中给出。</p>
<h1 id="第六章-Lambda扩展"><a href="#第六章-Lambda扩展" class="headerlink" title="第六章 Lambda扩展"></a>第六章 Lambda扩展</h1><p>C++11引入了lambda，C++14引入了泛型lambda，这是一个成功的故事。lambda允许我们将功能指定为参数，这让定制函数的行为变得更加容易。</p>
<p>C++ 17进一步改进，允许lambda用在更多的地方。</p>
<h2 id="6-1-constexpr-lambda"><a href="#6-1-constexpr-lambda" class="headerlink" title="6.1 constexpr lambda"></a>6.1 constexpr lambda</h2><p>自C++17后，只要可能，lambda就隐式地用constexpr修饰。也就是说，任何lambda都可以用于编译时上下文，前提是它使用的特性对编译时上下文有效（例如，仅字符串字面值，无静态变量，无virutal变量，无try/catch，无new/delete）。</p>
<p>举个例子，你可以传一个值给lambda，然后用计算的结果作为编译时的<code>std::array&lt;&gt;</code>大小：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> squared = [](<span class="keyword">auto</span> val) &#123; <span class="comment">// implicitly constexpr since C++17</span></span><br><span class="line">  <span class="keyword">return</span> val*val;</span><br><span class="line">&#125;;</span><br><span class="line">std::array&lt;<span class="type">int</span>,squared(5)&gt; a; <span class="comment">// OK since C++17 =&gt; std::array&lt;int,25&gt;</span></span><br></pre></td></tr></table></figure><br>如果在不允许constexpr的上下文使用这个特性就不行，但是你仍然可以在运行时傻姑娘上下文使用lambda：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">he lambda in run-time contexts:</span><br><span class="line"><span class="keyword">auto</span> squared2 = [](<span class="keyword">auto</span> val) &#123;      <span class="comment">// implicitly constexpr since C++17</span></span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> calls = <span class="number">0</span>;             <span class="comment">// OK, but disables lambda for constexpr contexts</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> val*val;</span><br><span class="line">&#125;;</span><br><span class="line">std::array&lt;<span class="type">int</span>,squared2(5)&gt; a;      <span class="comment">// ERROR: static variable in compile-time context</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">squared2</span>(<span class="number">5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;   <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><br>要知道是否一个lambda在一个编译时上下文有效，你可以将它声明为constexpr：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> squared3 = [](<span class="keyword">auto</span> val) <span class="keyword">constexpr</span> &#123;    <span class="comment">// OK since C++17</span></span><br><span class="line">  <span class="keyword">return</span> val*val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>还可以指定返回类型，语法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> squared3i = [](<span class="type">int</span> val) <span class="keyword">constexpr</span> -&gt; <span class="type">int</span> &#123; <span class="comment">// OK since C++17</span></span><br><span class="line">  <span class="keyword">return</span> val*val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>constexpr对于函数的一般规则仍然有效：如果lambda在运行时上下文中使用，相应的功能在运行时执行。</p>
<p>然而，在不允许编译时上下文的地方使用constexpr lambda会得到一个编译时错误：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> squared4 = [](<span class="keyword">auto</span> val) <span class="keyword">constexpr</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> calls=<span class="number">0</span>; <span class="comment">// ERROR: static variable in compile-time context</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> val*val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>如果lambda式显式或隐式的constexpr，那么函数调用操作符也会是constexpr。换句话说，下面的定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> squared = [](<span class="keyword">auto</span> val) &#123; <span class="comment">// implicitly constexpr since C++17</span></span><br><span class="line">  <span class="keyword">return</span> val*val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>会转换为闭包类型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompilerSpecificName</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(T val)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> val*val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>生成的闭包类型的函数调用操作符是自动附加constexpr的。在C++17中，如果lambda显式定义为constexpr或者隐式定义为constexpr（就像这个例子），那么生成的函数调用运算符也会是constexpr。</p>
<h2 id="6-2-传递this的拷贝到lambda"><a href="#6-2-传递this的拷贝到lambda" class="headerlink" title="6.2 传递this的拷贝到lambda"></a>6.2 传递this的拷贝到lambda</h2><p>当在成员函数中使用lambda时，你不能隐式的访问调用这个成员函数的对象的成员。也就是说，在lambda内部，如果不捕获this，那么你不能使用这个对象的成员：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> l1 = [] &#123; std::cout &lt;&lt; name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;; <span class="comment">// ERROR</span></span><br><span class="line">        <span class="keyword">auto</span> l2 = [] &#123; std::cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;; <span class="comment">// ERROR</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>C++11和C++14中可以传this引用或者传this值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> l1 = [<span class="keyword">this</span>] &#123; std::cout &lt;&lt; name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;; <span class="comment">// OK</span></span><br><span class="line">        <span class="keyword">auto</span> l2 = [=] &#123; std::cout &lt;&lt; name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;; <span class="comment">// OK</span></span><br><span class="line">        <span class="keyword">auto</span> l3 = [&amp;] &#123; std::cout &lt;&lt; name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;; <span class="comment">// OK</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>然而，问题是即使是传递this的值，其底层捕获的仍然是引自对象（即只有<em>指针</em>被拷贝）。如果lambda的生命周期超过了对象的生命周期，这就会出现问题。一个重要的例子是当用lambda为新线程定义task，它应该使用对象的拷贝来避免任何并发或者生命周期问题。另一个原因可能只是传递一个对象的副本当前状态。</p>
<p>C++14有一个临时的解决方案，但是它读起来不好，工作起来也不好：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> l1 = [thisCopy=*<span class="keyword">this</span>] &#123; std::cout &lt;&lt; thisCopy.name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>举个例子，就算使用<code>=</code>或<code>&amp;</code>捕获了对象，开发者仍然可能不小心用到<code>this</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> l1 = [&amp;, thisCopy=*<span class="keyword">this</span>] &#123;</span><br><span class="line">            thisCopy.name = <span class="string">&quot;new name&quot;</span>;</span><br><span class="line">            std::cout &lt;&lt; name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// OOPS: still the old name</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>C++17开始，你可以显式地通过<code>*this</code>说明你想捕获当前对象的复制：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> l1 = [*<span class="keyword">this</span>] &#123; std::cout &lt;&lt; name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>捕获<code>*this</code>意味着当前对象的复制传递到了lambda。</p>
<p>在捕获了<code>*this</code>的情况下你仍然可以捕获其他this，只要没有与其他的发生冲突：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> l2 = [&amp;, *<span class="keyword">this</span>] &#123; ... &#125;;     <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">auto</span> l3 = [<span class="keyword">this</span>, *<span class="keyword">this</span>] &#123; ... &#125;;  <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure><br>这里一个完整的例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lang/lambdathis.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">const</span> std::string&amp; s) : <span class="built_in">name</span>(s) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">startThreadWithCopyOfThis</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// start and return new thread using this after 3 seconds:</span></span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line">        <span class="function">std::thread <span class="title">t</span><span class="params">([*<span class="keyword">this</span>] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(<span class="number">3</span>s);</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::thread t;</span><br><span class="line">    &#123;</span><br><span class="line">        Data d&#123;<span class="string">&quot;c1&quot;</span>&#125;;</span><br><span class="line">        t = d.<span class="built_in">startThreadWithCopyOfThis</span>();</span><br><span class="line">    &#125; <span class="comment">// d is no longer valid</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>lambda用<code>*this</code>获取对象拷贝，即d。因此，即便是d的析构函数被调用后线程再使用传递的对象也没有问题。</p>
<p>如果我们使用<code>[this],[=]</code>或<code>[&amp;]</code>捕获this，线程会产生未定义行为，因为在lambda打印name时，lambda使用的是已经析构后的对象的成员。</p>
<h2 id="6-3-捕获引用"><a href="#6-3-捕获引用" class="headerlink" title="6.3 捕获引用"></a>6.3 捕获引用</h2><p>通过使用新的utility库函数，你现在可以<strong>捕获const对象引用</strong>。</p>
<h2 id="6-4-后记"><a href="#6-4-后记" class="headerlink" title="6.4 后记"></a>6.4 后记</h2><p>constexpr最初由 Faisal Vali, Ville Voutilainen和Gabriel Dos Reis在<a href="https://wg21.link/n4487">https://wg21.link/n4487</a>中提出。最后这个特性的公认措辞是由Faisal Vali, Jens<br>Maurer和Richard Smith在<a href="https://wg21.link/p0170r1">https://wg21.link/p0170r1</a>中给出。</p>
<p>捕获<code>*this</code>最初由H. Carter Edwards, Christian Trott, Hal Finkel, Jim Reus, Robin Maffeo和Ben Sander在<a href="https://wg21.link/p0018r0">https://wg21.link/p0018r0</a>中提出。最后这个特性的公认措辞是由 H. Carter Edwards, Daveed Vandevoorde, Christian Trott, Hal Finkel,<br>Jim Reus, Robin Maffeo和Ben Sander在<a href="https://wg21.link/p0180r3">https://wg21.link/p0180r3</a>中给出。</p>
<h1 id="第七章-新属性和属性相关特性"><a href="#第七章-新属性和属性相关特性" class="headerlink" title="第七章 新属性和属性相关特性"></a>第七章 新属性和属性相关特性</h1><p>C++11开始，你可以指定属性（attribute，一种规范的注解，可以启用或者禁用一些warning）。C++17还引入了新的属性。此外，属性现在可以在更多的地方使用，并且有一些额外的便利。</p>
<h2 id="7-1-nodiscard-属性"><a href="#7-1-nodiscard-属性" class="headerlink" title="7.1 [[nodiscard]]属性"></a>7.1 <code>[[nodiscard]]</code>属性</h2><p>新属性<code>[[nodiscard]]</code>用于鼓励编译器，当发现函数返回值没有被使用的时候，产生一个warning。</p>
<p>通常，这个属性可以用于通知一些返回值没有使用的错误行为。错误行为可能是：</p>
<ul>
<li><strong>内存泄漏</strong>，比如没有使用已经分配并返回的内存</li>
<li><strong>不符合期望，或者非直观行为</strong>，比如没有使用返回值时候可能产生的一些不同寻常/不符合期望的行为</li>
<li><strong>不必要的负载</strong>，比如如果没有使用返回值，这个调用过程相当于无操作。</li>
</ul>
<p>这是一些例子，它们展示了这个属性的是有用的：</p>
<ul>
<li>分配资源必须由另一个函数释放的函数应标记为<br><code>[[nodiscard]]</code>。 一个典型的例子是分配内存的函数，例如<code>malloc()</code>或分配器的成员函数<code>allocate()</code>。<br>但是请注意，某些函数可能会返回一个值，后续无需再针对这个值做其他调用。 例如，程序员调用大小为零字节的C函数<code>realloc(0</code>以释放内存，这个函数的返回值就不必保存以后再调用<code>free()</code></li>
<li>一个关于不使用返回值那么函数的行为将会改变的例子是<code>std::async</code>（由C++11引入）。它的目的是异步启动任务，并返回一个句柄以等待其结束（并使用结果）。当返回值没使用时，这个调用会成为同步调用，因为未使用的返回值的析构函数会立即调用，即立刻开始等待任务结束。 因此，不使用返回值会与<code>std::async()</code>的设计目的相矛盾。 这种情况下用<code>[[nodiscard]]</code>让编译器对此发出警告。</li>
<li>另一个例子是成员函数<code>empty()</code>，它检查对象是否没有元素。程序员有时候可能错误的调用这个函数来清空容器（译注：即误以为empty做动词）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cont.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure>
这种对<code>empty()</code>的误用可以被检查出来，因为它的返回值没有被使用。将成员函数标注这个属性即可：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  [[nodiscard]] <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
尽管这个是C++17引入的，但是标准库至今都没有使用它。对于C++17来说，应用此功能的建议来得太晚了。因此关于这个特性的关键动机，即为<code>std::async()</code>的声明添加现在都没有完成。对于上述所有示例，下一个C++标准将附带相应的修复程序（具体参见已经接受的提案<a href="https://wg21.link/p0600r1">https://wg21.link/p0600r1</a>）。为了使代码更具可移植性，你应该使用它，而不是使用不可移植的方式（比如gcc或者clang的<code>[[gnu:warn_unused_result]]</code>）来标注函数。当定义<code>operator new()</code>时你应该为函数标记<code>[[nodiscard]]</code>。</li>
</ul>
<h2 id="7-2-maybe-unused-属性"><a href="#7-2-maybe-unused-属性" class="headerlink" title="7.2 [[maybe_unused]]属性"></a>7.2 <code>[[maybe_unused]]</code>属性</h2><p>新属性<code>[[maybe_unused]]</code>可以用来避免编译器为未被使用的名字或者对象发出警告。</p>
<p>这个属性可以用在类声明上、类型定义<code>typedef</code>或者<code>using</code>上、变量、非静态数据成员、函数、枚举类型或者枚举值。</p>
<p>这个属性的一个应用是标记那些不是必要的参数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> val, [[maybe_unused]] std::string msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">  <span class="built_in">log</span>(msg);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>另一个例子是标记可能不会使用的成员<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  [[maybe_unused]] <span class="type">char</span> makeLargerSize[<span class="number">100</span>];</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>注意，你不能为一个语句标注<code>[[maybe_unused]]</code>。基于这个原因，你不能使用让<code>[[maybe_unused]]</code>与<code>[[nodiscard]]</code>相见：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">foo</span>(); <span class="comment">// WARNING: return value not used</span></span><br><span class="line">  [[maybe_unused]] <span class="built_in">foo</span>(); <span class="comment">// ERROR: attribute not allowed here</span></span><br><span class="line">  [[maybe_unused]] <span class="keyword">auto</span> x = <span class="built_in">foo</span>(); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="7-3-fallthrough-属性"><a href="#7-3-fallthrough-属性" class="headerlink" title="7.3 [[fallthrough]]属性"></a>7.3 <code>[[fallthrough]]</code>属性</h2><p>新属性<code>[[fallthrough]]</code>可以让编译器不警告那些switch中的某个case没有break，导致其他case被相继执行的情况。</p>
<p>比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">commentPlace</span><span class="params">(<span class="type">int</span> place)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (place) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;very &quot;</span>;</span><br><span class="line">      [[fallthrough]];</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;well\n&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;OK\n&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>传递1会输出<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">very well</span><br></pre></td></tr></table></figure><br>同时执行了case 1和case 2。</p>
<p>注意这个属性必须被用在空语句中。因此，你需要在它尾巴上加个分号。</p>
<p>在switch的最后一条语句使用这个属性是不允许的。</p>
<h2 id="7-4-通用属性扩展"><a href="#7-4-通用属性扩展" class="headerlink" title="7.4 通用属性扩展"></a>7.4 通用属性扩展</h2><p>下面的特性在C++17zhong被启用：</p>
<ol>
<li>现在允许为namespace标记属性。比如，你可以像下面代码一样弃用一个命名空间：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> [[deprecated]] DraftAPI &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
也可以用于inline namespace和匿名namespace。</li>
<li>枚举值现在也可以标注属性。</li>
</ol>
<p>比如，你可以引入新的枚举值代替原有的枚举值，然后弃用原有枚举值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">City</span> &#123; Berlin = <span class="number">0</span>,</span><br><span class="line">                  NewYork = <span class="number">1</span>,</span><br><span class="line">                  Mumbai = <span class="number">2</span>, Bombay [[deprecated]] = Mumbai,</span><br><span class="line">                  ... &#125;;</span><br></pre></td></tr></table></figure><br>Mumbai和Bombay都表示相同的city数值，但是Bombay已经弃用。注意标记枚举值时，语法上需要将属性放到枚举值名字的后面。</p>
<ol>
<li>用户定义的属性它们通常在自己的namespace定义，你现在可以使用using来避免重复书写namespace。换句话说，以前写法是：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[MyLib::WebService, MyLib::RestService, MyLib::<span class="built_in">doc</span>(<span class="string">&quot;html&quot;</span>)]] <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
现在你可以这么写：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="keyword">using</span> MyLib: WebService, RestService, <span class="built_in">doc</span>(<span class="string">&quot;html&quot;</span>)]] <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
注意用了using之后再书写namespace前缀会出错的：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="keyword">using</span> MyLib: MyLib::<span class="built_in">doc</span>(<span class="string">&quot;html&quot;</span>)]] <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="7-5-后记"><a href="#7-5-后记" class="headerlink" title="7.5 后记"></a>7.5 后记</h2><p>这三个属性最初由Andrew Tomazos在<a href="https://wg21.link/p0068r0">https://wg21.link/p0068r0</a>中提出。最后<code>[[nodiscard]]</code>的公认措辞是由Andrew Tomazos在<a href="https://wg21.link/p0189r1">https://wg21.link/p0189r1</a>中给出。<code>[[maybe_unused]]</code>的公认措辞是由Andrew Tomazos在<a href="https://wg21.link/p0212r1">https://wg21.link/p0212r1</a>中给出。<code>[[fallthrough]]</code>的公认措辞是由Andrew Tomazos在<a href="https://wg21.link/p0188r1">https://wg21.link/p0188r1</a>中给出。</p>
<p>允许namespace和枚举值标注属性这个特性最初由 Richard Smith在<a href="https://wg21.link/n4196">https://wg21.link/n4196</a>中提出。最后的公认措辞是由 Richard Smith在<a href="https://wg21.link/n4266">https://wg21.link/n4266</a>中给出。</p>
<p>属性允许使用using这个特性最初由J. Daniel Garcia, Luis M. Sanchez, Massimo<br>Torquati, Marco Danelutto和Peter Sommerlad在<a href="https://wg21.link/p0028r0">https://wg21.link/p0028r0</a>中提出。最后的公认措辞是由J. Daniel Garcia and Daveed Vandevoorde在<a href="https://wg21.link/P0028R4">https://wg21.link/P0028R4</a>中给出。</p>
<h1 id="第八章-其他语言特性"><a href="#第八章-其他语言特性" class="headerlink" title="第八章 其他语言特性"></a>第八章 其他语言特性</h1><p>有一些小的C++核心语言特性改动，它们会在本章描述。</p>
<h2 id="8-1-嵌套命名空间"><a href="#8-1-嵌套命名空间" class="headerlink" title="8.1 嵌套命名空间"></a>8.1 嵌套命名空间</h2><p>最早这个提案是在2003年提出的，C++标准委员会现在终于最终接受了它：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A::B::C &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>它等价于:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">  <span class="keyword">namespace</span> B &#123;</span><br><span class="line">    <span class="keyword">namespace</span> C &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>嵌套的inline命名空间还不支持。这是因为如果用了inline就不知道到底inline是针对最后一个还是对所有命名空间使用。</p>
<h2 id="8-2-定于表达式求值顺序"><a href="#8-2-定于表达式求值顺序" class="headerlink" title="8.2 定于表达式求值顺序"></a>8.2 定于表达式求值顺序</h2><p>很多代码库和C++书籍包含的代码首先给出符合直觉的假设，然后代码上看起来是有效的，但是严格来讲，这些代码可能产生未定义行为。一个例子是使用寻找并替换子字符串：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;I heard it even works if you don&#x27;t believe&quot;</span>;</span><br><span class="line">s.<span class="built_in">replace</span>(<span class="number">0</span>,<span class="number">8</span>,<span class="string">&quot;&quot;</span>).<span class="built_in">replace</span>(s.<span class="built_in">find</span>(<span class="string">&quot;even&quot;</span>),<span class="number">4</span>,<span class="string">&quot;sometimes&quot;</span>)</span><br><span class="line">                 .<span class="built_in">replace</span>(s.<span class="built_in">find</span>(<span class="string">&quot;you don✬t&quot;</span>),<span class="number">9</span>,<span class="string">&quot;I&quot;</span>);</span><br></pre></td></tr></table></figure><br>直觉上看起来这段代码是有效的，它将前8个字符替换为空，“even”替换为“sometimes”，将“you don’t”替换为“I”：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it sometimes works <span class="keyword">if</span> I believe</span><br></pre></td></tr></table></figure><br>然而，在C++17之前，结果是不保证的，因为，虽然<code>find()</code>调用返回从何处开始替换，但是当整个语句执行并且在结果被需要之前，这个调用可能在任何时候执行。实际上，所有<code>find()</code>，即计算待替换的起始索引，都可能在任何替换发生前被执行，因此结果是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it sometimes works <span class="keyword">if</span> I believe</span><br></pre></td></tr></table></figure><br>其他结果也是可能的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it sometimes workIdon’t believe</span><br><span class="line">it even worsometiIdon’t believe</span><br><span class="line">it even worsometimesf youIlieve</span><br></pre></td></tr></table></figure><br>另一个例子是使用输出运算符来打印计算后的表达式的值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; <span class="built_in">g</span>() &lt;&lt; <span class="built_in">h</span>();</span><br></pre></td></tr></table></figure><br>通常的假设是<code>f()</code>在<code>g()</code>之前被调用，两者又都在<code>h()</code>之前被调用。然而，这个假设是错误的。<code>f()</code>，<code>g()</code>和<code>h()</code>可以按任意顺序调用，这可能导致一些奇怪的，甚至是糟糕的结果，尤其是当这些调用互相依赖时</p>
<p>具体来说，考虑下面的例子，在C++17之前，这段代码会产生未定义行为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line">std::cout &lt;&lt; ++i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; --i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><br>在C++17之前，他可能输出<code>1 0</code>，也可能输出<code>0 -1</code>，甚至是<code>0 0</code>。不管i是int还是用户定义的类型，都可能这样。（对于基本类型，一些编译器至少会warning这个问题）。</p>
<p>要修复这个未定义行为，一些运算符/操作符的求值被挑战，因此现在它们有确定的求值顺序：</p>
<ul>
<li>对于<ul>
<li><code>e1 [ e2 ]</code></li>
<li><code>e1 . e2</code></li>
<li><code>e1 .* e2</code></li>
<li><code>e1 -&gt;* e2</code></li>
<li><code>e1 &lt;&lt; e2</code></li>
<li><code>e1 &gt;&gt; e2</code><br>e1保证在e2之前求值，它们的求值顺序是从左至右。</li>
</ul>
</li>
</ul>
<p>然而，相同函数的不同实参的求值顺序仍然是未定义的。即：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e<span class="number">1.f</span>(a1,a2,a3)</span><br></pre></td></tr></table></figure><br>e1保证在a1 a2 a3之前求值。但是a1 a2 a3的求职顺序仍然是未定义的。</p>
<ul>
<li>所有赋值运算符<ul>
<li><code>e2 = e1</code></li>
<li><code>e2 += e1</code></li>
<li><code>e2 *= e1</code></li>
<li><code>...</code><br>右手边的e1会先于左手变的e2被求值。</li>
</ul>
</li>
<li>最后，new表达式中<ul>
<li><code>new Type(e)</code><br>分配行为保证在e之前求值，初始化新的值保证在任何使用初始化的值之前被求值。</li>
</ul>
</li>
</ul>
<p>上述所有保证对基本类型和用户定义类型都有效。</p>
<p>这样做的效果是，C++17后：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;I heard it even works if you don&#x27;t believe&quot;</span>;</span><br><span class="line">s.<span class="built_in">replace</span>(<span class="number">0</span>,<span class="number">8</span>,<span class="string">&quot;&quot;</span>).<span class="built_in">replace</span>(s.<span class="built_in">find</span>(<span class="string">&quot;even&quot;</span>),<span class="number">4</span>,<span class="string">&quot;sometimes&quot;</span>)</span><br><span class="line">                 .<span class="built_in">replace</span>(s.<span class="built_in">find</span>(<span class="string">&quot;you don✬t&quot;</span>),<span class="number">9</span>,<span class="string">&quot;I&quot;</span>);</span><br></pre></td></tr></table></figure><br>保证会改变s的值，变成：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it always works if you use C++17</span><br></pre></td></tr></table></figure><br>因此，每个<code>find()</code>之前的替换都会在<code>find()</code>之前被求值。</p>
<p>另一个结果是，下面的语句<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line">std::cout &lt;&lt; ++i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; --i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><br>其输出保证是<code>1 0</code>。</p>
<p>然而，对于其他大多数运算符而言，求值顺序仍然未定义。举个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i++ + i; <span class="comment">// still undefined behavior</span></span><br></pre></td></tr></table></figure><br>这里右手变的i可能在递增之前或者递增之后传递给左手变。</p>
<p>另一个使用new表达式求值顺序的例子是<strong>在传值之前插入空格的函数</strong>。</p>
<h4 id="向后兼容"><a href="#向后兼容" class="headerlink" title="向后兼容"></a>向后兼容</h4><p>新的求值顺序的保证可能影响既有程序的输出。这不是理论上可能，是真的。考虑下面的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print10elems</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; v.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">7</span>, <span class="number">14</span>, <span class="number">21</span>, <span class="number">28</span>&#125;;</span><br><span class="line">        <span class="built_in">print10elems</span>(vec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123; <span class="comment">// handle standard exception</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;EXCEPTION: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; <span class="comment">// handle any other exception</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;EXCEPTION of unknown type\n&quot;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为这里的<code>vector&lt;&gt;</code>只有4个元素，程序会在<code>print10elems()</code>的循环中，调用<code>at()</code>时遇到无效索引抛出异常：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; v.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><br>在C++17之前，可能输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">value: 7</span><br><span class="line">value: 14</span><br><span class="line">value: 21</span><br><span class="line">value: 28</span><br><span class="line">EXCEPTION: ...</span><br></pre></td></tr></table></figure><br>因为<code>at()</code>可以在”value “输出之前求值，所以对于错误的索引可能直接跳过不输出”value “。</p>
<p>自C++17之后，保证输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">value: 7</span><br><span class="line">value: 14</span><br><span class="line">value: 21</span><br><span class="line">value: 28</span><br><span class="line">value: EXCEPTION: ...</span><br></pre></td></tr></table></figure><br>因为”value “一定在<code>at()</code>调用之前执行。</p>
<h2 id="8-3-宽松的基于整数的枚举初始化"><a href="#8-3-宽松的基于整数的枚举初始化" class="headerlink" title="8.3 宽松的基于整数的枚举初始化"></a>8.3 宽松的基于整数的枚举初始化</h2><p>对于有固定基本类型的枚举，C++17允许你使用带数值的列表初始化。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unscoped enum with underlying type:</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MyInt</span> : <span class="type">char</span> &#123; &#125;;</span><br><span class="line">MyInt i1&#123;<span class="number">42</span>&#125;;     <span class="comment">// C++17 OK (C++17之前错误)</span></span><br><span class="line">MyInt i2 = <span class="number">42</span>;    <span class="comment">// 仍然错误</span></span><br><span class="line"><span class="function">MyInt <span class="title">i3</span><span class="params">(<span class="number">42</span>)</span></span>;     <span class="comment">// 仍然错误</span></span><br><span class="line">MyInt i4 = &#123;<span class="number">42</span>&#125;;  <span class="comment">// 仍然错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Weekday</span> &#123; mon, tue, wed, thu, fri, sat, sun &#125;;</span><br><span class="line">Weekday s1&#123;<span class="number">0</span>&#125;;    <span class="comment">// C++17 OK (C++17之前错误)</span></span><br><span class="line">Weekday s2 = <span class="number">0</span>;   <span class="comment">// 仍然错误</span></span><br><span class="line"><span class="function">Weekday <span class="title">s3</span><span class="params">(<span class="number">0</span>)</span></span>;    <span class="comment">// 仍然错误</span></span><br><span class="line">Weekday s4 = &#123;<span class="number">0</span>&#125;; <span class="comment">// 仍然错误</span></span><br></pre></td></tr></table></figure><br>类似的，如果Weekday有基本类型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scoped enum with specified underlying type:</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Weekday</span> : <span class="type">char</span> &#123; mon, tue, wed, thu, fri, sat, sun &#125;;</span><br><span class="line">Weekday s1&#123;<span class="number">0</span>&#125;;    <span class="comment">// C++17 OK (C++17之前错误)</span></span><br><span class="line">Weekday s2 = <span class="number">0</span>;   <span class="comment">// 仍然错误</span></span><br><span class="line"><span class="function">Weekday <span class="title">s3</span><span class="params">(<span class="number">0</span>)</span></span>;    <span class="comment">// 仍然错误</span></span><br><span class="line">Weekday s4 = &#123;<span class="number">0</span>&#125;; <span class="comment">// 仍然错误</span></span><br></pre></td></tr></table></figure><br>对于没有指定基本类型的未限域枚举（不带class的enum），你仍然不能使用带数值的列表初始化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Flag</span> &#123; bit1=<span class="number">1</span>, bit2=<span class="number">2</span>, bit3=<span class="number">4</span> &#125;;</span><br><span class="line">Flag f1&#123;<span class="number">0</span>&#125;; <span class="comment">// 仍然错误</span></span><br></pre></td></tr></table></figure><br>注意，列表初始化还是不允许变窄（narrowing），因此你不能传递浮点值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyInt</span> : <span class="type">char</span> &#123; &#125;;</span><br><span class="line">MyInt i5&#123;<span class="number">42.2</span>&#125;; <span class="comment">// 仍然错误</span></span><br></pre></td></tr></table></figure><br>之所以提出这个特性，是想实现一种技巧，即基于原有的整数类型定义另一种新的枚举类型，就像上面MyInt一样。</p>
<p>实际上，C++17的标准库中的<code>std::byte</code>也提供这个功能，它直接使用了这个特性。</p>
<h2 id="8-4-修复带auto和直接列表初始化一起使用产生的矛盾行为"><a href="#8-4-修复带auto和直接列表初始化一起使用产生的矛盾行为" class="headerlink" title="8.4 修复带auto和直接列表初始化一起使用产生的矛盾行为"></a>8.4 修复带auto和直接列表初始化一起使用产生的矛盾行为</h2><p>C++11引入了统一初始化后，结果证明它和auto搭配会不幸地产生反直觉的矛盾行为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x&#123;<span class="number">42</span>&#125;;      <span class="comment">// initializes an int</span></span><br><span class="line"><span class="type">int</span> y&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;   <span class="comment">// ERROR</span></span><br><span class="line"><span class="keyword">auto</span> a&#123;<span class="number">42</span>&#125;;     <span class="comment">// initializes a std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> b&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">// OK: initializes a std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure><br>这些使用直接列表初始化（direct list initialization，不带<code>=</code>的花括号）造成的前后不一致行为已经得到修复，现在程序行为如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x&#123;<span class="number">42</span>&#125;;      <span class="comment">// initializes an int</span></span><br><span class="line"><span class="type">int</span> y&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;   <span class="comment">// ERROR</span></span><br><span class="line"><span class="keyword">auto</span> a&#123;<span class="number">42</span>&#125;;     <span class="comment">// initializes an int now</span></span><br><span class="line"><span class="keyword">auto</span> b&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">// ERROR now</span></span><br></pre></td></tr></table></figure><br>注意这是一个非常大的改变，甚至可能悄悄的改变程序的行为。出于这个原因，编译器接受这个改变，但是通常也提供C++11版本的模式。对于主流编译器，比如Visual Studio 2015，g++5和clang3.8同时接受两种模式。</p>
<p>还请注意拷贝列表初始化（copy list initialization，带<code>=</code>的花括号）的行为是不变的，当使用auto时初始化一个<code>std::initializer_list&lt;&gt;</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> c = &#123;<span class="number">42</span>&#125;; <span class="comment">// still initializes a std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> d = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">// still OK: initializes a std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure><br>因此，现在的直接列表初始化（不带<code>=</code>）和拷贝列表初始化（带<code>=</code>）有另一个显著区别：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a&#123;<span class="number">42</span>&#125;; <span class="comment">// initializes an int now</span></span><br><span class="line"><span class="keyword">auto</span> c = &#123;<span class="number">42</span>&#125;; <span class="comment">// still initializes a std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure><br>推荐的方式是总是使用直接列表初始化（不带<code>=</code>的花括号）来初始化变量和对象。</p>
<h2 id="8-5-十六进制浮点字面值"><a href="#8-5-十六进制浮点字面值" class="headerlink" title="8.5 十六进制浮点字面值"></a>8.5 十六进制浮点字面值</h2><p>C++17标准化了十六进制的浮点值字面值（有些编译器早已在C++17之前就支持了）。这种方式尤其适用于要求精确的浮点表示（对于双精度浮点值，没法保证精确值的存在）。</p>
<p>举个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lang/hexfloat.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// init list of floating-point values:</span></span><br><span class="line">  std::initializer_list&lt;<span class="type">double</span>&gt; values&#123;</span><br><span class="line">      <span class="number">0x1p4</span>, <span class="comment">// 16</span></span><br><span class="line">      <span class="number">0xA</span>, <span class="comment">// 10</span></span><br><span class="line">      <span class="number">0xAp2</span>, <span class="comment">// 40</span></span><br><span class="line">      <span class="number">5e0</span>, <span class="comment">// 5</span></span><br><span class="line">      <span class="number">0x1.4p+2</span>, <span class="comment">// 5</span></span><br><span class="line">      <span class="number">1e5</span>, <span class="comment">// 100000</span></span><br><span class="line">      <span class="number">0x1.86Ap+16</span>, <span class="comment">// 100000</span></span><br><span class="line">      <span class="number">0xC.68p+2</span>, <span class="comment">// 49.625</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// print all values both as decimal and hexadecimal value:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">double</span> d : values) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;dec: &quot;</span> &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; std::defaultfloat &lt;&lt; d</span><br><span class="line">              &lt;&lt; <span class="string">&quot; hex: &quot;</span> &lt;&lt; std::hexfloat &lt;&lt; d &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个程序使用不同的方式定义了不同的浮点值，其中包括使用十六进制浮点记法。新的记法是base为2的科学表示法：</p>
<ul>
<li>significant/mantissa写作十六进制方式</li>
<li>exponent写作数值方式，解释为base为2</li>
</ul>
<p>比如说，<code>0xAp2</code>是指定数值40（10乘以2的次方）。这个值也可以表示为<code>0x1.4p+5</code>，表示1.25乘以32（0.4是十六进制的四分之一，2的5次方是32）。</p>
<p>程序输出如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dec: 16     hex: 0x1p+4</span><br><span class="line">dec: 10     hex: 0x1.4p+3</span><br><span class="line">dec: 40     hex: 0x1.4p+5</span><br><span class="line">dec: 5      hex: 0x1.4p+2</span><br><span class="line">dec: 5      hex: 0x1.4p+2</span><br><span class="line">dec: 100000 hex: 0x1.86ap+16</span><br><span class="line">dec: 100000 hex: 0x1.86ap+16</span><br><span class="line">dec: 49.625 hex: 0x1.8dp+5</span><br></pre></td></tr></table></figure><br>如你说见，这个例子的浮点记法早已在C++11的<code>std::hexfloat</code>操作符上就已经支持了。</p>
<h2 id="8-6-UTF-8字符串字面值"><a href="#8-6-UTF-8字符串字面值" class="headerlink" title="8.6 UTF-8字符串字面值"></a>8.6 UTF-8字符串字面值</h2><p>C++11支持以u8前缀表示的UTF-8字符串字面值。然而，这个前缀对于字符是不支持的。C++17修复了这个问题，你现在可以这样写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">u8&#x27;6&#x27;</span>; <span class="comment">// character 6 with UTF-8 encoding value</span></span><br></pre></td></tr></table></figure><br>样可以保证字符值是UTF-8中字符‘6’的值。你可以使用所有的7bits US-ASCII字符，对于这些字符，UTF-8代码具有相同的值。换句话说，用这个指定的值和US-ASCII、ISO Latin-1、ISO-8859-15和基本Windows字符集的值都是一样的。通常，你的源代码的字符都会被解释为US-ASCII/UTF-8，所以前缀不是很重要。变量c的值几乎总是54（十六进制的36）。</p>
<p>对于源码中的字符和字符串字面值，C++标准化了你可以使用哪些字符，但是没有标准化这些字符对应的值。这些值取决于源代码字符集。当编译器生成可执行程序时，它会使用运行时字符集。源代码字符集集合总是7bits的US-ASCII，并且运行时字符集通常和源代码字符集一样。对于任何C++程序，有没有u8前缀这些字符和字符串字面值都是一样的。但是在很少见的情况下，可能不是这样。比如老式的IBM主机，仍然使用EBCDIC字符集，在这个字符集中字符‘6’的值是246（十六进制F6）。如果程序使用EBCDIC字符集，那么c的值将会是246而不是54，并且在UTF-8编码的平台上运行该程序时可能输出”¨o”，因为它对应ASCII值的246.在这种情况下前缀可能是必要的。</p>
<p>注意u8只能用于单个字符和UTF-8单字节字符。下面的初始化：<br><img src="../public/fig8-1.jpg" alt=""><br>是不被允许的，因为这个德语字符在UTF-8是双字节，即195和182（十六进制C3 B6）。</p>
<p>总结来熟哦，所有允许的字符和字符串字面值如下：</p>
<ul>
<li>单字节US-ASCII和UTF-8可以使用<strong>u8</strong></li>
<li>双字节的UTF-16可以使用<strong>u</strong></li>
<li>四字节的UTF-32可以使用<strong>U</strong></li>
<li>没有指定编码的宽字符可以使用<strong>l</strong>，它可能是两字节也可能是四字节</li>
</ul>
<h2 id="8-7-异常声明成为类型的一部分"><a href="#8-7-异常声明成为类型的一部分" class="headerlink" title="8.7 异常声明成为类型的一部分"></a>8.7 异常声明成为类型的一部分</h2><p>C++17开始异常处理声明成为一个函数的类型的一部分。也就是说，下面的两个函数现在有不同的类型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">// different type</span></span><br></pre></td></tr></table></figure><br>在C++17之前，这两个函数的类型是相同的。</p>
<p>这样的后果是，现在的编译器会检查是否你将不抛异常的函数传递给抛异常的函数指针：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*fp)() <span class="keyword">noexcept</span>;  <span class="comment">// pointer to function that doesn’t throw</span></span><br><span class="line">fp = f2;                <span class="comment">// OK</span></span><br><span class="line">fp = f1;                <span class="comment">// ERROR since C++17</span></span><br></pre></td></tr></table></figure><br>给抛异常的函数指针传递不抛异常的函数仍然有效：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*fp2)();  <span class="comment">// pointer to function that might throw</span></span><br><span class="line">fp2 = f2;       <span class="comment">// OK</span></span><br><span class="line">fp2 = f1;       <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><br>所以，这个新的特性不会破坏哪些没有使用noexcept作为函数指针的一部分的那些程序。</p>
<p>异常声明有无不能作为重载函数的依据：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure><br>注意，其他规则是不受影响的。举个例子，下面的代码中你还是不能忽略基类noexcept声明：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// ERROR: does not override</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>子类的<code>foo()</code>的类型与基类的<code>foo()</code>类型不一致，所以不允许重载，这个代码不能通过编译。即便没有指定override修饰符，还是不能编译，因为我们不能用更宽松的抛异常的版本来重载不抛异常的严格版本。</p>
<h4 id="使用条件异常声明"><a href="#使用条件异常声明" class="headerlink" title="使用条件异常声明"></a>使用条件异常声明</h4><p>当使用条件异常声明时，函数的类型取决于条件为true还是false：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">sizeof</span>(<span class="type">int</span>)&lt;<span class="number">4</span>)</span></span>; <span class="comment">// same type as either f1() or f2()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">sizeof</span>(<span class="type">int</span>)&gt;=<span class="number">4</span>)</span></span>; <span class="comment">// different type than f3()</span></span><br></pre></td></tr></table></figure><br>在这里，当代码编译时<code>f3()</code>的类型取决于条件：</p>
<ul>
<li>如果<code>sizeof(int)</code>为4（或者更多），最终的签名是<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>;    <span class="comment">// same type as f1()</span></span><br></pre></td></tr></table></figure></li>
<li>如果<code>sizeof(int)</code>小于4，最终签名是：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span></span>;     <span class="comment">// same type as f2()</span></span><br></pre></td></tr></table></figure>
因为<code>f4()</code>的异常条件与<code>f3()</code>相反，所以<code>f4()</code>的类型总是与<code>f3()</code>不一样（即保证<code>f3()</code>抛异常它就不抛，<code>f3()</code>不抛它就抛）。</li>
</ul>
<p>老式的空异常声明仍然可以使用，但是C++17已经标为废弃：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f5</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">// same as void f5() noexcept but deprecated</span></span><br></pre></td></tr></table></figure><br>动态的异常声明已经不再支持（它们在C++11时已经标为废弃）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f6</span><span class="params">()</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>; <span class="comment">// ERROR: invalid since C++17</span></span><br></pre></td></tr></table></figure></p>
<h4 id="对泛型库的影响"><a href="#对泛型库的影响" class="headerlink" title="对泛型库的影响"></a>对泛型库的影响</h4><p>让noexcept成为类型的一部分可能对一些泛型库造成影响。</p>
<p>比如，下面的程序截止C++14是有效的，但是在C++17中无法编译：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lang/noexceptcalls.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call</span><span class="params">(T op1, T op2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">op1</span>();</span><br><span class="line">    <span class="built_in">op2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f1()\n&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f2()\n&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">call</span>(f1, f2); <span class="comment">// ERROR since C++17</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>原因是C++17中<code>f1()</code>和<code>f2()</code>的类型不一样，编译器在实例化模板调用<code>call()</code>的时候不能为两个类型找到相同的类型T。</p>
<p>在C++17下，你不得不用两个类型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call</span><span class="params">(T1 op1, T2 op2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">op1</span>();</span><br><span class="line">  <span class="built_in">op2</span>();</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line">如果你想，或者不得不重载所有可能的函数类型，你需要付出双倍。来看`std::is_function&lt;&gt;`，主要的函数模板定义如下，通常T不是函数：</span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">// primary template (in general type T is no function):</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">is_function</span> : std::false_type &#123; &#125;;</span><br></pre></td></tr></table></figure><br>这个模板继承自<code>std::false_type</code>，所以<code>is_function&lt;T&gt;::value</code>通常产生false。</p>
<p>对于那些的确是函数的类型，需要偏特化，它继承自<code>std::true_type</code>，所以成员value的值是true：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// partial specializations for all function types:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_function</span>&lt;<span class="built_in">Ret</span> (Params...)&gt; : std::true_type &#123; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_function</span>&lt;<span class="built_in">Ret</span> (Params...) <span class="type">const</span>&gt; : std::true_type &#123; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_function</span>&lt;<span class="built_in">Ret</span> (Params...) &amp;&gt; : std::true_type &#123; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_function</span>&lt;<span class="built_in">Ret</span> (Params...) <span class="type">const</span> &amp;&gt; : std::true_type &#123; &#125;;</span><br></pre></td></tr></table></figure><br>C++17之前，它已经有24个偏特化来，因为函数可能有const和volatile修饰符，也可能有lvalue和rvalue引用修饰符，你重载的函数需要可变参数模板类型。</p>
<p>C++17后，偏特化的数量将会翻倍，因为有了新的noexcept修饰符，所以现在有48个：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// partial specializations for all function types with noexcept:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_function</span>&lt;<span class="built_in">Ret</span> (Params...) <span class="keyword">noexcept</span>&gt; : std::true_type &#123; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_function</span>&lt;<span class="built_in">Ret</span> (Params...) <span class="type">const</span> <span class="keyword">noexcept</span>&gt; : std::true_type &#123; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_function</span>&lt;<span class="built_in">Ret</span> (Params...) &amp; <span class="keyword">noexcept</span>&gt; : std::true_type &#123; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_function</span>&lt;<span class="built_in">Ret</span> (Params...) <span class="type">const</span>&amp; <span class="keyword">noexcept</span>&gt; : std::true_type &#123; &#125;;</span><br></pre></td></tr></table></figure><br>没有实现noexcept重载的库可能编译不了一些代码，因为它们可能用了noexcept。</p>
<h2 id="8-8-单参数的static-assert"><a href="#8-8-单参数的static-assert" class="headerlink" title="8.8 单参数的static_assert"></a>8.8 单参数的static_assert</h2><p>C++17开始，之前<code>static_assert()</code>必须传的错误消息参数现在变成可选了。这意味着最后的诊断性消息完全平台特定。比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="comment">// OK since C++11:</span></span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_default_constructible&lt;T&gt;::value,</span><br><span class="line">                <span class="string">&quot;class C: elements must be default-constructible&quot;</span>);</span><br><span class="line">                <span class="comment">// OK since C++17:</span></span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_default_constructible_v&lt;T&gt;);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>没有传消息的断言使用了新的type trait后缀<code>_v</code>。</p>
<h2 id="8-9-预处理条件-has-include"><a href="#8-9-预处理条件-has-include" class="headerlink" title="8.9 预处理条件__has_include"></a>8.9 预处理条件<code>__has_include</code></h2><p>C++17扩展了预处理起，可以检查一个特定的头文件是否被include。比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __has_include(<span class="string">&lt;filesystem&gt;</span>)</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> HAS_FILESYSTEM 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __has_include(<span class="string">&lt;experimental/filesystem&gt;</span>)</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;experimental/filesystem&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> HAS_FILESYSTEM 1</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> FILESYSTEM_IS_EXPERIMENTAL 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __has_include(<span class="string">&quot;filesystem.hpp&quot;</span>) # <span class="keyword">include</span> <span class="string">&quot;filesystem.hpp&quot;</span> # <span class="keyword">define</span> HAS_FILESYSTEM 1</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> FILESYSTEM_IS_EXPERIMENTAL 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> HAS_FILESYSTEM #<span class="keyword">if</span> __has_include(<span class="string">&lt;filesystem&gt;</span>)</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> HAS_FILESYSTEM 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __has_include(<span class="string">&lt;experimental/filesystem&gt;</span>)</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;experimental/filesystem&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> HAS_FILESYSTEM 1</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> FILESYSTEM_IS_EXPERIMENTAL 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __has_include(<span class="string">&quot;filesystem.hpp&quot;</span>) # <span class="keyword">include</span> <span class="string">&quot;filesystem.hpp&quot;</span> # <span class="keyword">define</span> HAS_FILESYSTEM 1</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> FILESYSTEM_IS_EXPERIMENTAL 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> HAS_FILESYSTEM 0</span></span><br><span class="line">#endif0</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><br>如果<code>#include</code>成功则<code>__has_include(...)</code>会求值为1(true)。如果不成功则没有什么影响。</p>
<h2 id="8-10-后记"><a href="#8-10-后记" class="headerlink" title="8.10 后记"></a>8.10 后记</h2><p>嵌套namespace定义最初由Jon Jagger在2003年于<a href="https://wg21.link/n1524">https://wg21.link/n1524</a>提出。Robert Kawulak在2014年于<a href="https://wg21.link/n4026">https://wg21.link/n4026</a>提出了新的提案。最后这个特性的公认措辞是由Robert Kawulak 和 Andrew Tomazos在<a href="https://wg21.link/n4230">https://wg21.link/n4230</a>中给出。</p>
<p>重新定义后的求值顺序最初由Gabriel Dos Reis, Herb Sutter和Jonathan Caves在<a href="https://wg21.link/n4228">https://wg21.link/n4228</a>中提出。最后这个特性的公认措辞是由Gabriel Dos Reis, Herb Sutter和Jonathan Caves在<a href="https://wg21.link/p0145r3">https://wg21.link/p0145r3</a>中给出。</p>
<p>更宽松的枚举初始化最初由Gabriel Dos Reis在<a href="https://wg21.link/p0138r0">https://wg21.link/p0138r0</a>中提出。最后这个特性的公认措辞是由Gabriel Dos Reis在<a href="https://wg21.link/p0138r2">https://wg21.link/p0138r2</a>中给出。</p>
<p>修复带auto和直接列表初始化一起使用产生的矛盾行为最初由Ville Voutilainen在<a href="https://wg21.link/n3681"> https://wg21.link/n3681</a>和<a href="https://wg21.link/3912">https://wg21.link/3912</a>中提出。最后这个特性的公认措辞是由 James Dennett在<a href="https://wg21.link/n3681">https://wg21.link/n3681</a>中给出。</p>
<p>十六进制浮点值最初由Thomas Koppe在<a href="https://wg21.link/p0245r0">https://wg21.link/p0245r0</a>中提出。最后这个特性的公认措辞是由Thomas Koppe在<a href="https://wg21.link/p0245r1">https://wg21.link/p0245r1</a>中给出。</p>
<p>UTF-8字符串字面值最初由 Richard Smith在<a href="https://wg21.link/n4197">https://wg21.link/n4197</a>中提出。最后这个特性的公认措辞是由 Richard Smith在<a href="https://wg21.link/n4267">https://wg21.link/n4267</a>中给出。</p>
<p>异常声明成为类型的一部分最初由Jens Maurer在<a href="https://wg21.link/n4320">https://wg21.link/n4320</a>中提出。最后这个特性的公认措辞是由Jens Maurer在<a href="https://wg21.link/p0012r1">https://wg21.link/p0012r1</a>中给出。</p>
<p>单参数的static_assert的公认措辞是由Walter E. Brown在<a href="https://wg21.link/n3928">https://wg21.link/n3928</a>中给出。</p>
<p>预处理条件<code>__has_include</code>最初由Clark Nelson和RichardSmith在<a href="https://wg21.link/p0061r0">https://wg21.link/p0061r0</a>中作为其中一部分提出。最后这个特性的公认措辞是由Clark Nelson和RichardSmith在<a href="https://wg21.link/p0061r1">https://wg21.link/p0061r1</a>中给出。</p>
<h1 id="第九章-类模板参数推导"><a href="#第九章-类模板参数推导" class="headerlink" title="第九章 类模板参数推导"></a>第九章 类模板参数推导</h1><p>C++17之前，你必须显式指定类模板的所有模板参数类型。比如，你不能忽略这里的double：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::complex&lt;<span class="type">double</span>&gt; c&#123;<span class="number">5.1</span>,<span class="number">3.3</span>&#125;;</span><br></pre></td></tr></table></figure><br>也不能忽略第二次的<code>std::mutex</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mx;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mx)</span></span>;</span><br></pre></td></tr></table></figure><br>C++17开始，必须显式指定类模板的所有模板参数类型这个限制变得宽松了。有了类模板参数推导（class template argument deduction，CTAD）技术，如果构造函数可以推导出所有模板参数，那么你可以跳过显式指定模板实参。</p>
<p>比如：</p>
<ul>
<li>你可以这样声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::complex c&#123;<span class="number">5.1</span>,<span class="number">3.3</span>&#125;; <span class="comment">// OK: std::complex&lt;double&gt; deduced</span></span><br></pre></td></tr></table></figure></li>
<li>你可以这样实现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mx;</span><br><span class="line">std::lock_guard lg&#123;mx&#125;; <span class="comment">// OK: std::lock_guard&lt;std_mutex&gt; deduced</span></span><br></pre></td></tr></table></figure></li>
<li>你甚至可以让容器推导其元素的类型：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector v1 &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// OK: std::vector&lt;int&gt; deduced</span></span><br><span class="line">std::vector v2 &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;; <span class="comment">// OK: std::vector&lt;const char*&gt; deduced</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="9-1-使用类模板参数推导"><a href="#9-1-使用类模板参数推导" class="headerlink" title="9.1 使用类模板参数推导"></a>9.1 使用类模板参数推导</h2><p>只要传给构造函数的实参可以用来推导类型模板参数，那么就可以使用类模板参数推导技术。该技术支持所有初始化方式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::complex c1&#123;<span class="number">1.1</span>, <span class="number">2.2</span>&#125;; <span class="comment">// deduces std::complex&lt;double&gt;</span></span><br><span class="line"><span class="function">std::complex <span class="title">c2</span><span class="params">(<span class="number">2.2</span>, <span class="number">3.3</span>)</span></span>; <span class="comment">// deduces std::complex&lt;double&gt;</span></span><br><span class="line">std::complex c3 = <span class="number">3.3</span>; <span class="comment">// deduces std::complex&lt;double&gt;</span></span><br><span class="line">std::complex c4 = &#123;<span class="number">4.4</span>&#125;; <span class="comment">// deduces std::complex&lt;double&gt;</span></span><br><span class="line">````</span><br><span class="line">c3和c4的初始化方式是可行的，因为你可以传递一个值来初始化`std::complex&lt;&gt;`，这对于推导出模板参数T来说足够了，它会被用于实数和虚数部分：</span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">complex</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">complex</span><span class="params">(<span class="type">const</span> T&amp; re = T(), <span class="type">const</span> T&amp; im = T())</span></span>;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>假设有如下声明<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::complex c1&#123;<span class="number">1.1</span>, <span class="number">2.2</span>&#125;;</span><br></pre></td></tr></table></figure><br>编译器会在调用的地方找到构造函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">complex</span><span class="params">(<span class="type">const</span> T&amp; re = T(), <span class="type">const</span> T&amp; im = T())</span></span>;</span><br></pre></td></tr></table></figure><br>因为两个参数T都是double，所以编译器推导出T是double，然后编译下面的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">complex&lt;<span class="type">double</span>&gt;::<span class="built_in">complex</span>(<span class="type">const</span> <span class="type">double</span>&amp; re = <span class="built_in">double</span>(),</span><br><span class="line">                         <span class="type">const</span> <span class="type">double</span>&amp; im = <span class="built_in">double</span>());</span><br></pre></td></tr></table></figure><br>注意模板参数必须是无歧义、可推导的。因此，下面的初始化是有问题的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::complex c5&#123;<span class="number">5</span>,<span class="number">3.3</span>&#125;; <span class="comment">// ERROR: attempts to int and double as T</span></span><br></pre></td></tr></table></figure><br>对于模板来说，不会在推导模板参数的时候做类型转换。</p>
<p>对于可变参数模板的类模板参数推导也是支持的。比如，<code>std::tuple&lt;&gt;</code>定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">tuple</span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">tuple</span><span class="params">(<span class="type">const</span> Types&amp;...)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这个声明：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::tuple t&#123;<span class="number">42</span>, <span class="string">&#x27;x&#x27;</span>, <span class="literal">nullptr</span>&#125;;</span><br></pre></td></tr></table></figure><br>推导出的类型是<code>std::tuple&lt;int, char, std::nullptr_t&gt;</code>。</p>
<p>你也可以推导出非类型模板参数。举个例子，像下面例子中传递一个数组，在推导模板参数的时候可以同时推导出元素类型和数组大小：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> SZ&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MyClass</span> (<span class="built_in">T</span>(&amp;)[SZ]) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">MyClass <span class="title">mc</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>; <span class="comment">// deduces T as const char and SZ as 6</span></span><br></pre></td></tr></table></figure><br>SZ推导为6，因为模板参数类型传递了一个六个字符的字符串字面值。</p>
<p>你甚至可以推导出<strong>用作基类的lambda</strong>的类型，或者推导出<strong>auto模板参数</strong>类型。</p>
<h3 id="9-1-1-默认拷贝"><a href="#9-1-1-默认拷贝" class="headerlink" title="9.1.1 默认拷贝"></a>9.1.1 默认拷贝</h3><p>如果类模板参数推导发现一个行为更像是拷贝初始化，它就倾向于这么认为。比如，在用一个元素初始化<code>std::vector</code>后：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector v1&#123;<span class="number">42</span>&#125;; <span class="comment">// vector&lt;int&gt; with one element</span></span><br></pre></td></tr></table></figure><br>用这个vector去初始化另一个vector：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector v2&#123;v1&#125;; <span class="comment">// v2 also is vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure><br>v2会被解释为<code>vector&lt;int&gt;</code>而不是<code>vector&lt;vector&lt;int&gt;&gt;</code></p>
<p>又比如，这个规则适用于下面所有初始化形式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector <span class="title">v3</span><span class="params">(v1)</span></span>; <span class="comment">// v3 also is vector&lt;int&gt;</span></span><br><span class="line">std::vector v4 = &#123;v1&#125;; <span class="comment">// v4 also is vector&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> v5 = std::vector&#123;v1&#125;; <span class="comment">// v5 also is vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure><br>如果传递多个元素时，就不能被解释为拷贝初始化，此时initializer list的类型会成为新vector的元素类型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector vv&#123;v, v&#125;; <span class="comment">// vv is vector&lt;vector&lt;int&gt;&gt;</span></span><br></pre></td></tr></table></figure><br>那么问题来了，如果传递可变参数模板，那么类模板参数推导会发生什么：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">make_vector</span><span class="params">(<span class="type">const</span> Args&amp;... elems)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::vector&#123;elems...&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="built_in">make_vector</span>(v, v); <span class="comment">// vector&lt;vector&lt;int&gt;&gt;</span></span><br><span class="line"><span class="keyword">auto</span> x2 = <span class="built_in">make_vector</span>(v); <span class="comment">// vector&lt;int&gt; or vector&lt;vector&lt;int&gt;&gt; ?</span></span><br></pre></td></tr></table></figure><br>当前，不同的编译器有不同的处理方式，这个问题还在讨论中。</p>
<h3 id="9-1-2-推导lambda的类型"><a href="#9-1-2-推导lambda的类型" class="headerlink" title="9.1.2 推导lambda的类型"></a>9.1.2 推导lambda的类型</h3><p>有了类模板参数推导，我们现在终于可以用lambda的类型实例化类模板类。举个例子，我们可以提供一个泛型类，然后包装一下callback，并统计调用了多少次callback：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tmpl/classarglambda.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// for std::forward()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CB&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountCalls</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  CB callback; <span class="comment">// callback to call</span></span><br><span class="line">  <span class="type">long</span> calls = <span class="number">0</span>; <span class="comment">// counter for calls</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CountCalls</span>(CB cb) : <span class="built_in">callback</span>(cb) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    ++calls;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">callback</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="title">count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calls;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这里，构造函数接受一个callback，然后包装一下，用它的类型来推导出模板参数CB。比如，我们可以传一个lambda：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CountCalls <span class="title">sc</span><span class="params">([](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">return</span> x &gt; y;</span></span></span><br><span class="line"><span class="params"><span class="function">             &#125;)</span></span>;</span><br></pre></td></tr></table></figure><br>这意味着sc的类型被推导为<code>CountCalls&lt;TypeOfTheLambda&gt;</code>。</p>
<p>通过这种方式，我们可以计算传递给排序函数的sc的调用次数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),</span><br><span class="line">          td::<span class="built_in">ref</span>(sc));</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;sorted with &quot;</span> &lt;&lt; sc.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; calls\n&quot;</span>;</span><br></pre></td></tr></table></figure><br>包装后的lambda通过引用的方式传递给排序函数，因为如若不然<code>std::sort()</code>只会计算传递给他的lambda的拷贝的调用，毕竟是传值的方式。</p>
<p>然而，我没可以传递包装后的lambda给<code>std::for_each</code>，因为这个算法可以返回传递给他的callback的拷贝：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fo = std::for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),</span><br><span class="line">                        <span class="built_in">CountCalls</span>([](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">                                      std::cout &lt;&lt; <span class="string">&quot;elem: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                        &#125;));</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;output with &quot;</span> &lt;&lt; fo.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; calls\n&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="9-1-3-非部分类模板参数推导"><a href="#9-1-3-非部分类模板参数推导" class="headerlink" title="9.1.3 非部分类模板参数推导"></a>9.1.3 非部分类模板参数推导</h3><p>不像函数模板那样，类模板参数不能部分推导（显示模板参数的一部分）。比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3 = T2&gt;</span><br><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">C</span> (T1 x = T1&#123;&#125;, T2 y = T2&#123;&#125;, T3 z = T3&#123;&#125;) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// all deduced:</span></span><br><span class="line"><span class="function">C <span class="title">c1</span><span class="params">(<span class="number">22</span>, <span class="number">44.3</span>, <span class="string">&quot;hi&quot;</span>)</span></span>; <span class="comment">// OK: T1 is int, T2 is double, T3 is const char*</span></span><br><span class="line"><span class="function">C <span class="title">c2</span><span class="params">(<span class="number">22</span>, <span class="number">44.3</span>)</span></span>; <span class="comment">// OK: T1 is int, T2 and T3 are double</span></span><br><span class="line"><span class="function">C <span class="title">c3</span><span class="params">(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;guy&quot;</span>)</span></span>; <span class="comment">// OK: T1, T2, and T3 are const char*</span></span><br><span class="line"><span class="comment">// only some deduced:</span></span><br><span class="line"><span class="function">C&lt;string&gt; <span class="title">c4</span><span class="params">(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;my&quot;</span>)</span></span>; <span class="comment">// ERROR: only T1 explicitly defined</span></span><br><span class="line">C&lt;&gt; <span class="built_in">c5</span>(<span class="number">22</span>, <span class="number">44.3</span>); <span class="comment">// ERROR: neither T1 not T2 explicitly defined</span></span><br><span class="line">C&lt;&gt; <span class="built_in">c6</span>(<span class="number">22</span>, <span class="number">44.3</span>, <span class="number">42</span>); <span class="comment">// ERROR: neither T1 nor T2 explicitly defined</span></span><br><span class="line"><span class="comment">// all specified:</span></span><br><span class="line">C&lt;string,string,<span class="type">int</span>&gt; c7; <span class="comment">// OK: T1,T2 are string, T3 is int</span></span><br><span class="line"><span class="function">C&lt;<span class="type">int</span>,string&gt; <span class="title">c8</span><span class="params">(<span class="number">52</span>, <span class="string">&quot;my&quot;</span>)</span></span>; <span class="comment">// OK: T1 is int,T2 and T3 are strings</span></span><br><span class="line"><span class="function">C&lt;string,string&gt; <span class="title">c9</span><span class="params">(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span></span>; <span class="comment">// OK: T1,T2,T3 are strings</span></span><br></pre></td></tr></table></figure><br>因为第三个模板参数类型有默认值，所以如果已经指定了第二个就可以省略第三个。</p>
<p>如果i想知道为什么不支持偏特化，下面是造成这个抉择的原因：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">42</span>, <span class="number">43</span>)</span></span>; <span class="comment">// still ERROR</span></span><br></pre></td></tr></table></figure><br><code>std::tuple</code>是一个可变参数模板，所以你可以指定任意数量的参数。在这种情况下，到底是认为这是只指定了一个类型的而导致的错误还是有意为之很难说清。看起来是有问题的。后期有更多考量后，偏特化也有可能加入C++标准。尽管目前没有。</p>
<p>不幸的是，缺少部分特化就不能解决一个常见代码需求。对于关联容器的排序规则，或者无序容器的hash函数，我们仍然不能简单的传一个lambda：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::set&lt;Cust&gt; <span class="title">coll</span><span class="params">([](<span class="type">const</span> Cust&amp; x, <span class="type">const</span> Cust&amp; y) &#123; <span class="comment">// still ERROR</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">return</span> x.name() &gt; y.name();</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure><br>我们还是得指定lambda的类型，因此需要像下面这样写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sortcrit = [](<span class="type">const</span> Cust&amp; x, <span class="type">const</span> Cust&amp; y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="built_in">name</span>() &gt; y.<span class="built_in">name</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::set&lt;Cust, <span class="title">decltype</span><span class="params">(sortcrit)</span>&gt; <span class="title">coll</span><span class="params">(sortcrit)</span></span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure></p>
<h3 id="9-1-4-类模板参数推导代替便捷的工具函数。"><a href="#9-1-4-类模板参数推导代替便捷的工具函数。" class="headerlink" title="9.1.4 类模板参数推导代替便捷的工具函数。"></a>9.1.4 类模板参数推导代替便捷的工具函数。</h3><p>有了类模板参数推导，我们可以不再使用那些目的仅是推导传的参数的类型的便捷工具函数。</p>
<p>最明显的是<code>make_pair</code>，他允许我们不指定传的参数的类型。比如，对于v：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br></pre></td></tr></table></figure><br>我们可以使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = std::<span class="built_in">make_pair</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><br>来代替<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;<span class="keyword">typename</span> std::vector&lt;<span class="type">int</span>&gt;::iterator,<span class="keyword">typename</span> std::vector&lt;<span class="type">int</span>&gt;::iterator&gt; <span class="built_in">p</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><br>现在，<code>make_pair()</code>不再需要了，可以直接这么写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::pair <span class="title">p</span><span class="params">(v.begin(), v.end())</span></span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="第十一章-折叠表达式"><a href="#第十一章-折叠表达式" class="headerlink" title="第十一章 折叠表达式"></a>第十一章 折叠表达式</h1><p>自C++17起, 其特性有支持带一个(可带有初始值的)参数包(parameter pack)的所有实参能使用二元操作符并计算结果.</p>
<p>例如, 下列的函数能返回所有传入实参的和:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foldSum</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (... + args); <span class="comment">// ((arg1 + arg2) + arg3)...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意, return 表达式里的括号是折叠表达式的一部分并且不能省略.</p>
<p>函数调用 <code>foldSum(47, 11, val, -1);</code> 使模版实例化并执行: <code>return 47 + 11 + val + -1;</code>.</p>
<p>函数调用 <code>foldSum(std::string(&quot;hello&quot;), &quot;world&quot;, &quot;!&quot;);</code> 使模版实例化为: <code>return std::string(&quot;hello&quot;) + &quot;world&quot; + &quot;!&quot;;</code></p>
<p>还要注意, 折叠表达式实参的次序可以不同并且效果也不一样 (可能看起有点反直觉): 例如写成 <code>(... + args)</code> 的结果则是 <code>((arg1 + arg2) + arg3)...</code>, 该含义是重复地“往后添加”(post-adds)东西. 你也可以写成 <code>(args + ...)</code>, 该含义是重复地“往前添加”(pre-adds)东西, 因此其结果为: <code>(arg1 + (arg2 + arg3))...</code>.</p>
<h2 id="11-1-折叠表达式的目的"><a href="#11-1-折叠表达式的目的" class="headerlink" title="11.1 折叠表达式的目的"></a>11.1 折叠表达式的目的</h2><p>折叠表达式避免了需要递归地去实例化模版并作用于一个参数包的所有形参. 在 C++17 之前, 你必须这样实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foldSumRec</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foldSumRec</span><span class="params">(T1 arg1, Ts... otherArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 + <span class="built_in">foldSumRec</span>(otherArgs...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的一种实现不仅写起来繁琐, 并且它也给 C++ 编译器造成负担. 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foldSum</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (... + args); <span class="comment">// ((arg1 + arg2) + arg3)...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于程序员和编译器双方的工作明显有所减少.</p>
<h2 id="11-2-折叠表达式的使用"><a href="#11-2-折叠表达式的使用" class="headerlink" title="11.2 折叠表达式的使用"></a>11.2 折叠表达式的使用</h2><p>给定形参 <code>args</code> 和一个操作符 <code>op</code>, C++17 允许我们写成</p>
<ul>
<li>要么是<strong>一元左折叠</strong>(unary left fold)<br><code>( ... op args)</code>, 它将展开为: <code>(...(arg1 op arg2) op ... argN-1) op argN)</code></li>
<li>要么是<strong>一元右折叠</strong>(unary right fold)<br><code>(args op ...)</code>, 它将展开为: <code>(arg1 op (arg2 op ... (argN-1 op argN)...)</code></li>
</ul>
<p>其中括号是必需的. 但是, 括号和省略号 (…) 不必用空格隔开.</p>
<p>比起知道左和右折叠表达式的预期结果, 理解两者的差别更重要. 例如, 甚至在使用 <code>+</code> 操作符时就有可能出现不同的效果. 在使用左折叠表达式时:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foldSumL</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (... + args); <span class="comment">// ((arg1 + arg2) + arg3)...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>foldSumL(1, 2, 3)</code> 则计算出 <code>((1 + 2) + 3)</code>. 这也意味着下列示例代码是能被编译的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in">foldSumL</span>(std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>), <span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 编译通过.</span></span><br></pre></td></tr></table></figure>
<p>记住操作符 <code>+</code> 用于标准字符串类型则至少有一个操作数是 <code>std::string</code> 类型. 因为使用了左折叠表达式, 则函数第一次调用将计算 <code>std::string(&quot;hello&quot;) + &quot;world&quot;</code>, 其返回结果为一个 <code>std::string</code> 类型的字符串, 因此再加上字面形式的字符串 <code>&quot;!&quot;</code> 也是有效的.</p>
<p>然而, 以下的函数调用:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in">foldSumL</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, std::<span class="built_in">string</span>(<span class="string">&quot;!&quot;</span>)) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 编译报错.</span></span><br></pre></td></tr></table></figure>
<p>将不能被编译, 因为其计算得到 <code>((&quot;hello&quot; + &quot;world&quot;) + std::string(&quot;!&quot;))</code>, 而两个字面形式的字符串是不允许用操作符 <code>+</code> 进行拼接的. </p>
<p>然而, 我们可以将实现改成:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foldSumL</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...); <span class="comment">// (arg1 + (arg2 + arg3))...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>foldSumL(1, 2, 3)</code> 则计算出 <code>(1 + (2 + 3))</code>. 这意味着下列示例代码就不再能被编译:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in">foldSumL</span>(std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>), <span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 编译报错.</span></span><br></pre></td></tr></table></figure>
<p>而以下的函数调用现在能被编译:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in">foldSumL</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, std::<span class="built_in">string</span>(<span class="string">&quot;!&quot;</span>)) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 编译通过.</span></span><br></pre></td></tr></table></figure>
<p>因为几乎在所有情况下, 计算的次序都是从左至右, 通常, 参数包的左折叠语法(参数在末尾)应该更受青睐(除非它没有作用):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(... + args); <span class="comment">// 更受青睐的折叠表达式语法</span></span><br></pre></td></tr></table></figure>
<h3 id="11-2-1-空参数包的处理"><a href="#11-2-1-空参数包的处理" class="headerlink" title="11.2.1 空参数包的处理"></a>11.2.1 空参数包的处理</h3><p>如果一个折叠表达式使用了空参数包, 则应用以下规则:</p>
<ul>
<li>如果使用了操作符 <code>&amp;&amp;</code>, 则其值为 <code>true</code>.</li>
<li>如果使用了操作符 <code>||</code>, 则其值为 <code>false</code>.</li>
<li>如果使用了操作符 <code>,</code>, 则其值是 <code>void()</code>.</li>
<li>其他操作符的调用则是不良形式 (ill-formed).</li>
</ul>
<p>对于所有其他情况 (一般而言) 你可以添加一个初始值: 给定一个参数包 <code>args</code>, 一个初始值 <code>value</code> 和一个操作符 <code>op</code>, C++17 也允许我们写成:</p>
<ul>
<li>要么一个<strong>二元左折叠</strong>(binary left fold)<br><code>(value op ... op args)</code>, 它将展开为: <code>((...((value op arg1) op arg2) op ... op argN-1) op argN)</code><br>— 要么一个<strong>二元右折叠</strong>(binary right fold)<br><code>(args op ... op value)</code>, 它将展开为: <code>(arg1 op (arg2 op ... op (argN-1 op (argN op value))...))</code></li>
</ul>
<p>在省略号两边的操作符 <code>op</code> 必须相同.</p>
<p>例如, 下列定义允许传递一个空参数包</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foldSum</span><span class="params">(T... s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span> + ... + s); <span class="comment">// sizeof...(s) == 0 的情况也可行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在概念上, 不论我们添加 <code>0</code> 作为首个操作数或最后一个操作数应该都无所谓. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foldSum</span><span class="params">(T... s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (s + ... + <span class="number">0</span>); <span class="comment">// sizeof...(s) == 0 的情况也可行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但对于一元折叠表达式<strong>其不同的计算次序则比预期结果更重要</strong>, 而二元左折叠表达式则更受青睐:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(value + ... + args); <span class="comment">// 更受青睐的二元折叠表达式语法</span></span><br></pre></td></tr></table></figure>
<p>还有, 首个操作数可能是特别的, 比如这个例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里, 重要的是首次调用是传递给 <code>print()</code> 的第一个实参的输出, 其返回的输出流作用于其它输出的调用. 其它实现可能无法编译甚至得到发生无法预料的事情. 例如, 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; (args &lt;&lt; ... &lt;&lt; <span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>调用<code>print(1)</code> 将编译通过但打印出的值 <code>1</code> 会向左移10位 (<code>&#39;\n&#39;</code> 的值通常为 <code>10</code>), 因此输出的结果为 <code>1024</code>.</p>
<p>注意, 在这个例子 <code>print()</code> 中没有空格分隔参数包的各个元素. 这样的调用 <code>print(&quot;hello&quot;, 42, &quot;world&quot;)</code> 将会打印 <code>hello42world</code>.</p>
<p>为了用空格将传入的元素分隔开, 你需要一个helper函数以确保除了第一个实参之外在打印前加上空格. 例如, 用以下 helper 函数模版 <code>spaceBefore()</code> 可以办到:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tmpl/addspace.hpp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">spaceBefore</span><span class="params">(<span class="type">const</span> T&amp; arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> First&amp; firstarg, <span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; firstarg;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; <span class="built_in">spaceBefore</span>(args)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里, <code>(std::cout &lt;&lt; ... &lt;&lt; spaceBefore(args))</code> 这个折叠表达式展开成: <code>(std::cout &lt;&lt; spaceBefore(arg1) &lt;&lt; spaceBefore(arg2) &lt;&lt; ...)</code></p>
<p>因此, 在参数包 <code>args</code> 中每个元素都调用一个helper函数, 在返回被传递的实参之前打印出一个空格字符, 写入输出流 <code>std::cout</code> 里. 为了确保这不会应用到第一个实参, 我们添加了额外的首个形参并且不对其使用 <code>spaceBefore()</code>.</p>
<p>注意, 参数包的输出的计算需要所有输出在左边.</p>
<p>我们也能在<code>print()</code>里面使用lambda来定义<code>spaceBefore()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> First&amp; firstarg, <span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; firstarg;</span><br><span class="line">    <span class="keyword">auto</span> spaceBefore = [](<span class="type">const</span> <span class="keyword">auto</span>&amp; arg) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;&#x27;;</span></span><br><span class="line"><span class="string">        return arg;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    (std::cout &lt;&lt; ... &lt;&lt; spaceBefore(args)) &lt;&lt; &#x27;</span>\n<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>然而, 注意 lambda 通过值返回对象, 这意味着将创建传入实参的没必要的拷贝. 避免不必要拷贝的方式是通过显式声明lambda的返回类型要为<code>const auto&amp;</code>或<code>decltype(auto)</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> First&amp; firstarg, <span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; firstarg;</span><br><span class="line">    <span class="keyword">auto</span> spaceBefore = [](<span class="type">const</span> <span class="keyword">auto</span>&amp; arg) -&gt; <span class="type">const</span> <span class="keyword">auto</span>&amp; &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;&#x27;;</span></span><br><span class="line"><span class="string">        return arg;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    (std::cout &lt;&lt; ... &lt;&lt; spaceBefore(args)) &lt;&lt; &#x27;</span>\n<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果你不能够将这些语句组合成这样一条语句, 那你用的C++就不能称为真正的C++:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> First&amp; firstarg, <span class="type">const</span> Args&amp; ...args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; firstarg;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; [](<span class="type">const</span> <span class="keyword">auto</span>&amp; arg) -&gt; <span class="keyword">decltype</span>(<span class="keyword">auto</span>) &#123;</span><br><span class="line">                             std::cout &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                             <span class="keyword">return</span> arg;</span><br><span class="line">                          &#125;(args)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过, 一种更简单实现<code>print()</code>的方式是使用一个lambda打印空格和实参并将其传递给一个一元折叠表达式(脚注: 感谢 Barry Revzin 提出来):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(First first, <span class="type">const</span> Args&amp; ...args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; first;</span><br><span class="line">    <span class="keyword">auto</span> outWithSpace = [](<span class="type">const</span> <span class="keyword">auto</span>&amp; arg) &#123;</span><br><span class="line">                            std::cout &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; arg;</span><br><span class="line">                        &#125;;</span><br><span class="line">    (..., <span class="built_in">outWithSpace</span>(args));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过使用一个额外的用<strong><code>auto</code>声明的模版参数</strong>, 我们可以使<code>print()</code>更灵活地将字符类型的分隔符, 字符串或任意其它可打印的类型参数化.</p>
<h3 id="11-2-2-已支持的操作符"><a href="#11-2-2-已支持的操作符" class="headerlink" title="11.2.2 已支持的操作符"></a>11.2.2 已支持的操作符</h3><p>除了<code>.</code>, <code>-&gt;</code>, 和 <code>[]</code> 这些操作符之外, 你可以使用所有二元操作符作用于折叠表达式.</p>
<h4 id="折叠的函数调用"><a href="#折叠的函数调用" class="headerlink" title="折叠的函数调用"></a>折叠的函数调用</h4><p>折叠表达式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tmpl/foldcalls.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变数目的基类模版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Bases&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiBase</span> : <span class="keyword">private</span> Bases...</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用所有基类的 print()</span></span><br><span class="line">        (..., Bases::<span class="built_in">print</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::print()\n&quot;</span>; &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::print()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::print()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MultiBase&lt;A, B, C&gt; mb;</span><br><span class="line">    mb.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里,</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Bases&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiBase</span> : <span class="keyword">private</span> Bases...</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>允许我们用可变数目的基类初始化对象: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MultiBase&lt;A, B, C&gt; mb;</span><br></pre></td></tr></table></figure>
<p>并且使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(..., Base::<span class="built_in">print</span>());</span><br></pre></td></tr></table></figure>
<p>这个折叠表达式被展开为调用每一个基类的<code>print</code>. 这个折叠表达式展开后如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(A::<span class="built_in">print</span>(), B::<span class="built_in">print</span>(), C::<span class="built_in">print</span>());</span><br></pre></td></tr></table></figure>
<p>然而, 注意到<code>,</code>操作符的性质与我们使用左折叠表达式或右折叠表达式没什么关系. 这些函数总是从左往右被调用. 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Base::<span class="built_in">print</span>(), ...);</span><br></pre></td></tr></table></figure>
<p>这个括号只是将调用组合起来, 因此第一个<code>print()</code>和其它两个<code>print()</code>的结果组合了一起如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A::<span class="built_in">print</span>(), (B::<span class="built_in">print</span>(), C::<span class="built_in">print</span>());</span><br></pre></td></tr></table></figure>
<p>但因为<code>,</code>操作符的计算次序总是从左向右, 仍然是在括号里面两个为一组的函数调用之前先调用第一个函数, 并且仍然是中间的函数在右边函数之前调用.</p>
<p>尽管如此, 这就像左表达式的结果并且能跟其计算次序匹配上, 还是建议在折叠多个函数调用时使用左折叠表达式.</p>
<h4 id="组合Hash函数"><a href="#组合Hash函数" class="headerlink" title="组合Hash函数"></a>组合Hash函数</h4><p>一个使用<code>,</code>操作符组合Hash值的例子. 这个例子如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hashCombine</span><span class="params">(std::<span class="type">size_t</span>&amp; seed, <span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    seed ^= std::<span class="built_in">hash</span>&lt;T&gt;()(val) + <span class="number">0x9e3779b9</span> + (seed &lt;&lt; <span class="number">6</span>) + (seed &gt;&gt; <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Type&gt;</span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">combineHashValue</span><span class="params">(<span class="type">const</span> Type&amp; ...args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="type">size_t</span> seed = <span class="number">0</span>;           <span class="comment">// 初始种子</span></span><br><span class="line">    (..., <span class="built_in">hashCombine</span>(seed, args)); <span class="comment">// hashCombine() 调用链</span></span><br><span class="line">    <span class="keyword">return</span> seed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">combinedHashValue</span><span class="params">(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="number">42</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>中间的这条语句展开成:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">hashCombine</span>(seed, <span class="string">&quot;Hello&quot;</span>), <span class="built_in">hashCombine</span>(seed, <span class="string">&quot;World&quot;</span>)), <span class="built_in">hashCombine</span>(seed, <span class="number">42</span>));</span><br></pre></td></tr></table></figure>
<p>使用这个定义, 我们可以容易地为一个某个类型的对象定义一个新的Hash函数, 例如 <code>Customer</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomerHash</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Customer&amp; c)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">combineHashValue</span>(c.<span class="built_in">getFirstname</span>(), c.<span class="built_in">getLastname</span>(), c.<span class="built_in">getValue</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以将 <code>Customers</code> 放入一个 <code>std::unordered_set</code> 的容器:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_set&lt;Customer, CustomerHash&gt; coll;</span><br></pre></td></tr></table></figure>
<h4 id="折叠的路径遍历"><a href="#折叠的路径遍历" class="headerlink" title="折叠的路径遍历"></a>折叠的路径遍历</h4><p>你也可以使用折叠表达式去遍历一个二叉树的路径通过操作符<code>-&gt;*</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tmpl/foldtraverse.cpp</span></span><br><span class="line"><span class="comment">// 定义二叉树结构和用于遍历的helper函数.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> i = <span class="number">0</span>) : <span class="built_in">value</span>(i), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> left = &amp;Node::left;</span><br><span class="line"><span class="keyword">auto</span> right = &amp;Node::right;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用折叠表达式遍历树:</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...TP&gt;</span><br><span class="line"><span class="function">Node* <span class="title">traverse</span><span class="params">(T np, TP... paths)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (np -&gt;* ... -&gt;* paths); <span class="comment">// np -&gt;* path1 -&gt;* path2 ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始二叉树的结构:</span></span><br><span class="line">    Node* root = <span class="keyword">new</span> Node&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    root-&gt;left = <span class="keyword">new</span> Node&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    root-&gt;left-&gt;right = <span class="keyword">new</span> Node&#123;<span class="number">2</span>&#125;;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 遍历二叉树:</span></span><br><span class="line">    Node* node = <span class="built_in">traverse</span>(root, left, right);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里,</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(np -&gt;* ... -&gt;* paths)</span><br></pre></td></tr></table></figure>
<p>使用一个折叠表达式从<code>np</code>开始去遍历可变数目的<code>paths</code>的元素. 当调用:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">traverse</span>(root, left, right);</span><br></pre></td></tr></table></figure>
<p>这个折叠表达式的调用展开成:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root-&gt;left-&gt;right</span><br></pre></td></tr></table></figure>
<h3 id="11-2-3-使用折叠表达式作用于类型"><a href="#11-2-3-使用折叠表达式作用于类型" class="headerlink" title="11.2.3 使用折叠表达式作用于类型"></a>11.2.3 使用折叠表达式作用于类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tmpl/ishomogeneous.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查传递的类型是否为同一类:</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> ...TN&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsHomogeneous</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = (std::is_same&lt;T1, TN&gt;::value &amp;&amp; ...);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查传递的实参是否有相同类型:</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> ...TN&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">isHomogeneous</span><span class="params">(T1, TN...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (std::is_same&lt;T1, TN&gt;::value &amp;&amp; ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类型 trait <code>IsHomogeneous&lt;&gt;</code> 可被使用如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IsHomogeneous&lt;<span class="type">int</span>, Size, <span class="keyword">decltype</span>(<span class="number">42</span>)&gt;::value</span><br></pre></td></tr></table></figure>
<p>此情况下, 这个初始化成员变量<code>value</code>的折叠表达式展开成:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::is_same&lt;<span class="type">int</span>, MyType&gt;::value &amp;&amp; std::is_same&lt;<span class="type">int</span>, <span class="keyword">decltype</span>(<span class="number">42</span>)&gt;::value</span><br></pre></td></tr></table></figure>
<p>这个函数模版<code>isHomogeneous&lt;&gt;()</code> 可被使用如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isHomogeneous</span>(<span class="number">43</span>, <span class="number">-1</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">nullptr</span>)</span><br></pre></td></tr></table></figure>
<p>此情况下, 这个初始化成员变量<code>value</code>的折叠表达式展开成:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::is_same&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::value &amp;&amp; std::is_same&lt;<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span>*&gt;::value &amp;&amp; std::is_same&lt;<span class="type">int</span>, std::<span class="type">nullptr_t</span>&gt;::value</span><br></pre></td></tr></table></figure>
<p>通常, 操作符<code>&amp;&amp;</code>是短路的(第一<code>false</code>则终止计算).</p>
<p>在标准库里的<strong><code>std::arary&lt;&gt;</code>的推导规则</strong>使用这种特性.</p>
<h2 id="11-3-后记"><a href="#11-3-后记" class="headerlink" title="11.3 后记"></a>11.3 后记</h2><p>折叠表达式最初由Andrew Sutton和Richard Smith在<a href="https://wg21.link/n4191">https://wg21.link/n4191</a>中提出. 最后这个特性的公认措辞由Andrew Sutton和Richard Smith在<a href="https://wg21.link/n4295">https://wg21.link/n4295</a>中制定的. Thibaut Le Jehan 在 <a href="https://wg21.link/n0036">https://wg21.link/n0036</a> 中提出了删除对操作符<code>*</code>, <code>+</code>, <code>&amp;</code>和<code>|</code>支持空参数包的情况.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/30/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="prev" title="leveldb源码分析">
      <i class="fa fa-chevron-left"></i> leveldb源码分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/07/Intel_TBB/" rel="next" title="Intel Thread Building Blocks (TBB)">
      Intel Thread Building Blocks (TBB) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A"><span class="nav-number">1.</span> <span class="nav-text">第一章  结构化绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%E7%9A%84%E7%BB%86%E8%8A%82"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 结构化绑定的细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%88%B0%E5%8C%BF%E5%90%8D%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">绑定到匿名变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.1.2.</span> <span class="nav-text">使用修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%B9%B6%E9%9D%9E%E4%BF%AE%E9%A5%B0%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A"><span class="nav-number">1.1.3.</span> <span class="nav-text">修饰符并非修饰结构化绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="nav-number">1.1.4.</span> <span class="nav-text">移动语义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 结构化绑定可以在哪使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1 结构体和类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-%E5%8E%9F%E7%94%9F%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.1 原生数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-std-paor-std-tuple%E5%92%8Cstd-array"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3 std::paor,std::tuple和std::array</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#std-array"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">std::array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#std-tuple"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">std::tuple</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#std-pair"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">std::pair</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BApair%E5%92%8Ctuple%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%E8%B5%8B%E5%80%BC"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">为pair和tuple的结构化绑定赋值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E4%B8%BA%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%E6%8F%90%E4%BE%9B%E4%BC%BC%E8%8B%A5tuple%E7%9A%84API"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 为结构化绑定提供似若tuple的API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AA%E8%AF%BB%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">只读结构化绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%81%E8%AE%B8%E9%92%88%E5%AF%B9%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%E7%9A%84%E5%86%99%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">允许针对结构化绑定的写操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E5%90%8E%E8%AE%B0"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 后记</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%B8%A6%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84if%E5%92%8Cswitch"><span class="nav-number">2.</span> <span class="nav-text">第二章 带初始化的if和switch</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%B8%A6%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84if"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 带初始化的if</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%B8%A6%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84switch"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 带初始化的switch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E5%90%8E%E8%AE%B0"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 后记</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E8%81%94%E5%8F%98%E9%87%8F"><span class="nav-number">3.</span> <span class="nav-text">第三章 内联变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%86%85%E8%81%94%E5%8F%98%E9%87%8F%E7%9A%84%E5%8A%A8%E6%9C%BA"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 内联变量的动机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B4%E6%97%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">3.1.0.1.</span> <span class="nav-text">临时解决方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E4%BD%BF%E7%94%A8%E5%86%85%E8%81%94%E5%8F%98%E9%87%8F"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 使用内联变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-constexpr%E9%9A%90%E5%BC%8F%E5%8C%85%E5%90%ABinline"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 constexpr隐式包含inline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E5%86%85%E8%81%94%E5%8F%98%E9%87%8F%E5%92%8Cthread-local"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 内联变量和thread_local</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E5%90%8E%E8%AE%B0"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 后记</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%81%9A%E5%90%88%E6%89%A9%E5%B1%95"><span class="nav-number">4.</span> <span class="nav-text">第四章 聚合扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E6%89%A9%E5%B1%95%E8%81%9A%E5%90%88%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%8A%A8%E6%9C%BA"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 扩展聚合初始化的动机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E4%BD%BF%E7%94%A8%E6%89%A9%E5%B1%95%E7%9A%84%E8%81%9A%E5%90%88%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 使用扩展的聚合初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E8%81%9A%E5%90%88%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 聚合体定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E5%90%91%E5%90%8E%E4%B8%8D%E5%85%BC%E5%AE%B9"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 向后不兼容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-%E5%90%8E%E8%AE%B0"><span class="nav-number">4.5.</span> <span class="nav-text">4.5 后记</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%BA%E5%88%B6%E6%8B%B7%E8%B4%9D%E6%B6%88%E9%99%A4%E6%88%96%E8%80%85%E4%BC%A0%E9%80%92unmaterialized%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.</span> <span class="nav-text">第五章 强制拷贝消除或者传递unmaterialized对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E4%B8%B4%E6%97%B6%E9%87%8F%E5%BC%BA%E5%88%B6%E6%8B%B7%E8%B4%9D%E6%B6%88%E9%99%A4%E7%9A%84%E5%8A%A8%E6%9C%BA"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 临时量强制拷贝消除的动机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E4%B8%B4%E6%97%B6%E9%87%8F%E5%BC%BA%E5%88%B6%E6%8B%B7%E8%B4%9D%E6%B6%88%E9%99%A4%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 临时量强制拷贝消除的好处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E5%80%BC%E8%8C%83%E7%95%B4%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 值范畴的解释</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-%E5%80%BC%E8%8C%83%E7%95%B4"><span class="nav-number">5.3.1.</span> <span class="nav-text">5.3.1 值范畴</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E8%8C%83%E7%95%B4%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">值范畴的历史</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-11%E7%9A%84%E5%80%BC%E8%8C%83%E7%95%B4"><span class="nav-number">5.3.1.2.</span> <span class="nav-text">C++11的值范畴</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2-C-17%E7%9A%84%E5%80%BC%E8%8C%83%E7%95%B4"><span class="nav-number">5.3.2.</span> <span class="nav-text">5.3.2 C++17的值范畴</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E6%9C%AA%E5%85%B7%E4%BD%93%E5%8C%96%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%A0%E9%80%92"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 未具体化返回值传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-%E5%90%8E%E8%AE%B0"><span class="nav-number">5.5.</span> <span class="nav-text">5.5 后记</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-Lambda%E6%89%A9%E5%B1%95"><span class="nav-number">6.</span> <span class="nav-text">第六章 Lambda扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-constexpr-lambda"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 constexpr lambda</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E4%BC%A0%E9%80%92this%E7%9A%84%E6%8B%B7%E8%B4%9D%E5%88%B0lambda"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 传递this的拷贝到lambda</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E6%8D%95%E8%8E%B7%E5%BC%95%E7%94%A8"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 捕获引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E5%90%8E%E8%AE%B0"><span class="nav-number">6.4.</span> <span class="nav-text">6.4 后记</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%96%B0%E5%B1%9E%E6%80%A7%E5%92%8C%E5%B1%9E%E6%80%A7%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7"><span class="nav-number">7.</span> <span class="nav-text">第七章 新属性和属性相关特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-nodiscard-%E5%B1%9E%E6%80%A7"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 [[nodiscard]]属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-maybe-unused-%E5%B1%9E%E6%80%A7"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 [[maybe_unused]]属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-fallthrough-%E5%B1%9E%E6%80%A7"><span class="nav-number">7.3.</span> <span class="nav-text">7.3 [[fallthrough]]属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-%E9%80%9A%E7%94%A8%E5%B1%9E%E6%80%A7%E6%89%A9%E5%B1%95"><span class="nav-number">7.4.</span> <span class="nav-text">7.4 通用属性扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-%E5%90%8E%E8%AE%B0"><span class="nav-number">7.5.</span> <span class="nav-text">7.5 后记</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="nav-number">8.</span> <span class="nav-text">第八章 其他语言特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-%E5%B5%8C%E5%A5%97%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">8.1.</span> <span class="nav-text">8.1 嵌套命名空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-%E5%AE%9A%E4%BA%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="nav-number">8.2.</span> <span class="nav-text">8.2 定于表达式求值顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9"><span class="nav-number">8.2.0.1.</span> <span class="nav-text">向后兼容</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-%E5%AE%BD%E6%9D%BE%E7%9A%84%E5%9F%BA%E4%BA%8E%E6%95%B4%E6%95%B0%E7%9A%84%E6%9E%9A%E4%B8%BE%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">8.3.</span> <span class="nav-text">8.3 宽松的基于整数的枚举初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-%E4%BF%AE%E5%A4%8D%E5%B8%A6auto%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E4%BA%A7%E7%94%9F%E7%9A%84%E7%9F%9B%E7%9B%BE%E8%A1%8C%E4%B8%BA"><span class="nav-number">8.4.</span> <span class="nav-text">8.4 修复带auto和直接列表初始化一起使用产生的矛盾行为</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%B5%AE%E7%82%B9%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="nav-number">8.5.</span> <span class="nav-text">8.5 十六进制浮点字面值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6-UTF-8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="nav-number">8.6.</span> <span class="nav-text">8.6 UTF-8字符串字面值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-7-%E5%BC%82%E5%B8%B8%E5%A3%B0%E6%98%8E%E6%88%90%E4%B8%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86"><span class="nav-number">8.7.</span> <span class="nav-text">8.7 异常声明成为类型的一部分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%BC%82%E5%B8%B8%E5%A3%B0%E6%98%8E"><span class="nav-number">8.7.0.1.</span> <span class="nav-text">使用条件异常声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E6%B3%9B%E5%9E%8B%E5%BA%93%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">8.7.0.2.</span> <span class="nav-text">对泛型库的影响</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-8-%E5%8D%95%E5%8F%82%E6%95%B0%E7%9A%84static-assert"><span class="nav-number">8.8.</span> <span class="nav-text">8.8 单参数的static_assert</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-9-%E9%A2%84%E5%A4%84%E7%90%86%E6%9D%A1%E4%BB%B6-has-include"><span class="nav-number">8.9.</span> <span class="nav-text">8.9 预处理条件__has_include</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-10-%E5%90%8E%E8%AE%B0"><span class="nav-number">8.10.</span> <span class="nav-text">8.10 后记</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%8E%A8%E5%AF%BC"><span class="nav-number">9.</span> <span class="nav-text">第九章 类模板参数推导</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-%E4%BD%BF%E7%94%A8%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%8E%A8%E5%AF%BC"><span class="nav-number">9.1.</span> <span class="nav-text">9.1 使用类模板参数推导</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-1-%E9%BB%98%E8%AE%A4%E6%8B%B7%E8%B4%9D"><span class="nav-number">9.1.1.</span> <span class="nav-text">9.1.1 默认拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-2-%E6%8E%A8%E5%AF%BClambda%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">9.1.2.</span> <span class="nav-text">9.1.2 推导lambda的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-3-%E9%9D%9E%E9%83%A8%E5%88%86%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%8E%A8%E5%AF%BC"><span class="nav-number">9.1.3.</span> <span class="nav-text">9.1.3 非部分类模板参数推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-4-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%8E%A8%E5%AF%BC%E4%BB%A3%E6%9B%BF%E4%BE%BF%E6%8D%B7%E7%9A%84%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E3%80%82"><span class="nav-number">9.1.4.</span> <span class="nav-text">9.1.4 类模板参数推导代替便捷的工具函数。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">10.</span> <span class="nav-text">第十一章 折叠表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1-%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="nav-number">10.1.</span> <span class="nav-text">11.1 折叠表达式的目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2-%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">10.2.</span> <span class="nav-text">11.2 折叠表达式的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-1-%E7%A9%BA%E5%8F%82%E6%95%B0%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">10.2.1.</span> <span class="nav-text">11.2.1 空参数包的处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-2-%E5%B7%B2%E6%94%AF%E6%8C%81%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">10.2.2.</span> <span class="nav-text">11.2.2 已支持的操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%98%E5%8F%A0%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">10.2.2.1.</span> <span class="nav-text">折叠的函数调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88Hash%E5%87%BD%E6%95%B0"><span class="nav-number">10.2.2.2.</span> <span class="nav-text">组合Hash函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%98%E5%8F%A0%E7%9A%84%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86"><span class="nav-number">10.2.2.3.</span> <span class="nav-text">折叠的路径遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-3-%E4%BD%BF%E7%94%A8%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%9C%E7%94%A8%E4%BA%8E%E7%B1%BB%E5%9E%8B"><span class="nav-number">10.2.3.</span> <span class="nav-text">11.2.3 使用折叠表达式作用于类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-3-%E5%90%8E%E8%AE%B0"><span class="nav-number">10.3.</span> <span class="nav-text">11.3 后记</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
