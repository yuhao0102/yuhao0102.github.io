<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="UNIX基础知识UNIX体系结构从严格意义上说，可将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境。我们通常将这种软件称为内核(kermel)，因为它相对较小，而且位于环境的核心。 内核的接口被称为系统调用(systemcall)。公用函数库构建在系统调用接口之上，应用程序既可使用公用函数库，也可使用系统调用。 文件和目录文件系统UNIX文件系统是目录和文件的一种层次结构，所有东西">
<meta property="og:type" content="article">
<meta property="og:title" content="UNIX高级编程 笔记">
<meta property="og:url" content="http://yoursite.com/2021/05/13/UNIX%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%20%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="UNIX基础知识UNIX体系结构从严格意义上说，可将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境。我们通常将这种软件称为内核(kermel)，因为它相对较小，而且位于环境的核心。 内核的接口被称为系统调用(systemcall)。公用函数库构建在系统调用接口之上，应用程序既可使用公用函数库，也可使用系统调用。 文件和目录文件系统UNIX文件系统是目录和文件的一种层次结构，所有东西">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/1620962971.jpg">
<meta property="og:image" content="http://yoursite.com/img/20210515010759.png">
<meta property="og:image" content="http://yoursite.com/img/20210515011014.png">
<meta property="og:image" content="http://yoursite.com/img/20210515094251.png">
<meta property="og:image" content="http://yoursite.com/img/20210515101810.png">
<meta property="og:image" content="http://yoursite.com/img/20210516123303.png">
<meta property="og:image" content="http://yoursite.com/img/20210516231147.png">
<meta property="og:image" content="http://yoursite.com/img/20210516231950.png">
<meta property="og:image" content="http://yoursite.com/img/20210517004519.png">
<meta property="og:image" content="http://yoursite.com/img/1621242103.jpg">
<meta property="og:image" content="http://yoursite.com/img/1621244305.jpg">
<meta property="og:image" content="http://yoursite.com/img/20210517115638.png">
<meta property="og:image" content="http://yoursite.com/img/20210518121754.png">
<meta property="og:image" content="http://yoursite.com/img/20210518122502.png">
<meta property="og:image" content="http://yoursite.com/img/20210522143654.png">
<meta property="og:image" content="http://yoursite.com/img/20210522150750.png">
<meta property="og:image" content="http://yoursite.com/img/20210522151557.png">
<meta property="og:image" content="http://yoursite.com/img/20210522152120.png">
<meta property="og:image" content="http://yoursite.com/img/20210522173047.png">
<meta property="og:image" content="http://yoursite.com/img/20210522173933.png">
<meta property="og:image" content="http://yoursite.com/img/20210522174418.png">
<meta property="og:image" content="http://yoursite.com/img/20210522200334.png">
<meta property="og:image" content="http://yoursite.com/img/1621849003.jpg">
<meta property="og:image" content="http://yoursite.com/img/20210524233035.png">
<meta property="og:image" content="http://yoursite.com/img/20210525002706.png">
<meta property="og:image" content="http://yoursite.com/img/1621926192.jpg">
<meta property="og:image" content="http://yoursite.com/img/1621927476.jpg">
<meta property="og:image" content="http://yoursite.com/img/20210525234012.png">
<meta property="og:image" content="http://yoursite.com/img/1621993686.jpg">
<meta property="og:image" content="http://yoursite.com/img/1622104996.jpg">
<meta property="og:image" content="http://yoursite.com/img/1622122627.jpg">
<meta property="og:image" content="http://yoursite.com/img/1622123793.jpg">
<meta property="og:image" content="http://yoursite.com/img/20210528000140.png">
<meta property="og:image" content="http://yoursite.com/img/1622445555.jpg">
<meta property="og:image" content="http://yoursite.com/img/1622621887.jpg">
<meta property="og:image" content="http://yoursite.com/img/1622627160.jpg">
<meta property="og:image" content="http://yoursite.com/img/1622640114.jpg">
<meta property="og:image" content="http://yoursite.com/img/1622641438.jpg">
<meta property="og:image" content="http://yoursite.com/img/1622642397.jpg">
<meta property="og:image" content="http://yoursite.com/img/1622643609.jpg">
<meta property="og:image" content="http://yoursite.com/img/20210602112207.png">
<meta property="og:image" content="http://yoursite.com/img/20210604122019.png">
<meta property="og:image" content="http://yoursite.com/img/20210604124542.png">
<meta property="og:image" content="http://yoursite.com/img/1622869817.jpg">
<meta property="og:image" content="http://yoursite.com/img/1622943429.jpg">
<meta property="og:image" content="http://yoursite.com/img/1623034862.jpg">
<meta property="og:image" content="http://yoursite.com/img/1623067638.jpg">
<meta property="article:published_time" content="2021-05-13T13:00:00.000Z">
<meta property="article:modified_time" content="2022-12-26T10:14:38.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/1620962971.jpg">

<link rel="canonical" href="http://yoursite.com/2021/05/13/UNIX%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%20%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>UNIX高级编程 笔记 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/resume.pdf" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">128</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/13/UNIX%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%20%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          UNIX高级编程 笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-13 21:00:00" itemprop="dateCreated datePublished" datetime="2021-05-13T21:00:00+08:00">2021-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-26 18:14:38" itemprop="dateModified" datetime="2022-12-26T18:14:38+08:00">2022-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="UNIX基础知识"><a href="#UNIX基础知识" class="headerlink" title="UNIX基础知识"></a>UNIX基础知识</h1><h2 id="UNIX体系结构"><a href="#UNIX体系结构" class="headerlink" title="UNIX体系结构"></a>UNIX体系结构</h2><p>从严格意义上说，可将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境。我们通常将这种软件称为内核(kermel)，因为它相对较小，而且位于环境的核心。</p>
<p>内核的接口被称为系统调用(systemcall)。公用函数库构建在系统调用接口之上，应用程序既可使用公用函数库，也可使用系统调用。</p>
<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>UNIX文件系统是目录和文件的一种层次结构，所有东西的起点是称为根(root)的目录，这个目录的名称是一个字符“/“。</p>
<p>目录(directory)是一个包含目录项的文件。在逻辑上，可以认为每个目录项都包含一个文件名，同时还包含说明该文件属性的信息。文件属性是指文件类型(是普通文件还是目录等)、文件大小、文件所有者、文件权限(其他用户能否访问该文件)以及文件最后的修改时间等。<code>stat</code>和<code>fstat</code>函数返回包含所有文件属性的一个信息结构。</p>
<h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><p>目录中的各个名字称为文件名(filename)。只有斜线(/)和空字符这两个字符不能出现在文件名中。斜线用来分隔构成路径名的各文件名，空字符则用来终止一个路径名。</p>
<p>创建新目录时会自动创建了两个文件名：<code>.</code>(称为点)和<code>..</code>(称为点点)。点指向当前目录，点点指向父目录。在最高层次的根目录中，点点与点相同。现今，几乎所有商业化的UNIX文件系统都支<br>持超过255个字符的文件名。</p>
<h3 id="路径名"><a href="#路径名" class="headerlink" title="路径名"></a>路径名</h3><p>由斜线分隔的一个或多个文件名组成的序列(也可以斜线开头)构成路径名(pathname)，以斜线开头的路径名称为绝对路径名(absolute pathname)，否则称为相对路径名(relative pathname)。相对路径名指向相对于当前目录的文件。文件系统根的名字(/)是一个特殊的绝对路径名，它不包含文件名。</p>
<p>不难列出一个目录中所有文件的名字，以下命令的简要实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> arge, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    DIR *dp;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dirent</span> *dirp;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">err_quif</span>(<span class="string">&quot;usage: ls directory_nane&quot;</span>) <span class="function">a</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">((dp = opendir(argv[<span class="number">1</span>])) == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">        <span class="title">err_ays</span> <span class="params">(<span class="string">&quot;can&#x27;t open %s&quot;</span>, argv[<span class="number">1</span>])</span></span>;</span><br><span class="line">    <span class="keyword">while</span> ((dirp = <span class="built_in">readdir</span>(dp)) !- <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printe</span>(<span class="string">&quot;%s\n&quot;</span>, dirp-&gt;d_name);</span><br><span class="line">    <span class="built_in">closedir</span>(dp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个20行的程序中，有很多细节需要考虑。</p>
<ul>
<li>首先，其中包含了一个头文件<code>apue.h</code>。本书中几乎每一个程序都包含此头文件。它包含了某些标准系统头文件，定义了许多常量及函数原型。</li>
<li>接下来，我们包含了一个系统头文件dirent.h。以便使用<code>opendir</code>和<code>readdir</code>的函数原型，以及<code>dirent</code>结构的定义。在其他一些系统里，这些定义被分成多个头文件。</li>
<li><code>main</code>函数的声明使用了ISO C标准所使用的风格</li>
<li>程序获取命令行的第1个参数<code>argv[1]</code>作为要列出其各个目录项的目录名。</li>
<li>因为各种不同UNIX系统目录项的实际格式是不一样的，所以使用函数<code>opendir</code>、<code>readdir</code>和<code>closedir</code>对目录进行处理。</li>
<li><code>opendir</code>函数返回指向<code>DIR</code>结构的指针，我们将该指针传送给<code>readdir</code>函数。然后，在循环中调用<code>readdir</code>来读每个目录项。它返回一个指向<code>dirent</code>结构的指针，而当目录中已无目录项可读时则返回null指针。在<code>dirent</code>结构中取出的只是每个目录项的名字(<code>d_name</code>)。使用该名字，此后就可用<code>stat</code>函数以获得该文件的所有属性。</li>
<li>当程序将结束时，它以参数0调用函数<code>exit()</code>。函数<code>exit()</code>终止程序。按惯例，参数0的意思是正常结束，参数值1~255则表示出错。</li>
</ul>
<h3 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h3><p>每个进程都有一个工作目录(working directory)，有时称其为当前工作目录(current working directory)，所有相对路径名都从工作目录开始解释。进程可以用<code>chdir</code>函数更改其工作目录。</p>
<h3 id="起始目录"><a href="#起始目录" class="headerlink" title="起始目录"></a>起始目录</h3><p>登录时，工作目录设置为起始目录(home directory)，该起始目录从口令文件中相应用户的登录项中取得</p>
<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>文件描述符(flle descriptor)通常是一个小的非负整数，内核用以标识一个特定进程正在访间的文件。当内核打开一个现有文件或创建一个新文件时，它都返回一个文件描述符。在读、写文件时，可以使用这个文件描述符。</p>
<h3 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h3><p>按惯例，每当运行一个新程序时，所有的shell都为其打开了个文件描述符，即标准输入(standard input)、标准输出(standard output)以及标准错误(standarderror)。如果不做特殊处理，则这3个描述符都链接向终端。</p>
<h3 id="不带缓冲的I-O"><a href="#不带缓冲的I-O" class="headerlink" title="不带缓冲的I/O"></a>不带缓冲的I/O</h3><p>函数<code>open</code>、<code>read</code>，<code>write</code>、<code>lseek</code>以及<code>close</code>提供了不带缓冲的I/O。这些函数都使用文件描述符。</p>
<p>如果愿意从标准输入读，并向标准输出写，则所示的程序可用于复制任一UNIX普通文件<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFSIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> buf [BUFFSIZE];</span><br><span class="line">    <span class="keyword">while</span> ((n = <span class="built_in">read</span>(STDIN_FILENO, buf, BUFFSIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">write</span>(STDOUT_FILENO, buf, n) != n)</span><br><span class="line">            <span class="built_in">exc_syn</span>(<span class="string">&quot;write exror&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">    <span class="built_in">exif</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>头文件<code>&lt;unistd.h&gt;</code>(<code>apue.h</code>中包含了此头文件)及两个常量<code>STDIN_FILENO</code>和<code>STDOUT_FILENO</code>是POSIX标准的一部分，头文件<code>&lt;unistd.h&gt;</code>包含了很多UNIX系统服务的函数原型，</p>
<p>两个常量<code>STDIN_FILENO</code>和<code>STDOUT_FILENO</code>定义在<code>&lt;unistd.h&gt;</code>头文件中，它们指定了标准输入和标准输出的文件描述符。在POSIX标准中，它们的值分别是0和1，但是考虑到可读性，我们将使用这些名字来表示这些常量</p>
<p><code>read</code>函数返回读取的字节数，此值用作要写的字节数。当到达输入文件的尾时，<code>read</code>返回0，程序停止执行。如果发生了一个读错误，<code>read</code>返回-1。出错时大多数系统函数返回-1。</p>
<h3 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h3><p>标准I/O函数为那些不带缓冲的I/O函数提供了一个带缓冲的接口。使用标准I/O函数无需担心如何选取最佳的缓冲区大小使用标准I/O函数还简化了对输入行的处理。例如，<code>fgets</code>函数读取一个完整的行，而<code>read</code>函数读取指定字节数。</p>
<p>我们最熟悉的标准I/O函数是<code>printf</code>。在调用<code>printf</code>的程序中，总是包含<code>&lt;stdio.h&gt;</code>，该头文件包括了所有标准I/O函数的原型。</p>
<p>下面的程序的功能类似于前一个调用了<code>read</code>和<code>write</code>的程序。它将标准输入复制到标准输出，也就能复制任一UNIX普通文件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c = <span class="built_in">getc</span>(stdin)) != EOF)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">putc</span>(c, stdout) == EOF)</span><br><span class="line">        <span class="built_in">exr_sys</span>(<span class="string">&quot;output exror&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ferror</span>(stdin))</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;input error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数<code>getc</code>一次读取一个字符，然后函数<code>putc</code>将此字符写到标准输出。读到输入的最后一个字节时，<code>getc</code>返回常量EOF(该常量在<code>&lt;stdio.h&gt;</code>中定义)。标准I/O常量<code>stdin</code>和<code>stdout</code>也在头文件<code>&lt;stdio.h&gt;</code>中定义，它们分别表示标准输入和标准输出。</p>
<h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>程序(program)是一个存储在磁盘上某个目录中的可执行文件。内核使用exec函数(7个<code>exec</code>函数之一)，将程序读入内存，并执行程序。</p>
<h3 id="进程和进程ID"><a href="#进程和进程ID" class="headerlink" title="进程和进程ID"></a>进程和进程ID</h3><p>程序的执行实例被称为进程(process)。某些操作系统用任务(task)表示正在被执行的程序，UNIX系统确保每个进程都有一个难一的数字标识符，称为进程ID(process ID)。进程ID总是一个非负整数。</p>
<p>程序用于打印进程ID<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world from process ID sid\n&quot;</span>, (<span class="type">long</span>)<span class="built_in">getpid</span>());</span><br><span class="line">    <span class="built_in">exif</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此程序运行时，它调用函数<code>getpid</code>得到其进程ID。<code>getpid</code>返回一个<code>pid_t</code>数据类型。</p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>有3个用于进程控制的主要函数：<code>fork</code>、<code>exec</code>和<code>waitpid</code>。</p>
<p>该程序从标准输入读取命令，然后执行这些命令。它类似于shell程序的基本实施部分。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span>    buf[MAXLINE];   <span class="comment">/* from apue.h */</span></span><br><span class="line">    <span class="type">pid_t</span>   pid;</span><br><span class="line">    <span class="type">int</span>     status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%% &quot;</span>);  <span class="comment">/* print prompt (printf requires %% to print %) */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fgets</span>(buf, MAXLINE, stdin) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">/* replace newline with null */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">err_sys</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;      <span class="comment">/* child */</span></span><br><span class="line">            <span class="built_in">execlp</span>(buf, buf, (<span class="type">char</span> *)<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">err_ret</span>(<span class="string">&quot;couldn&#x27;t execute: %s&quot;</span>, buf);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">127</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* parent */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = <span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">err_sys</span>(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%% &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个30行的程序中，有很多功能需要考虑，</p>
<ul>
<li>用标准I/O函数<code>fgets</code>从标准输入一次读取一行。当键入文件结束符(通常是Ctrl+D)作为行的第一个字符时，fgets返回一个null指针，于是循环停止，进程也就终止。</li>
<li>因为<code>fgets</code>返回的每一行都以换行符终止，后随一个null字节，因此用标准C函数strlen计算此字符串的长度，然后用一个null字节替换换行符。这样做是因为<code>execlp</code>函数要求的参数是以null结束的而不是以换行符结束的</li>
<li>调用fork创建一个新进程。新进程是调用进程的一个副本，我们称调用进程为父进程，新创建的进程为子进程。fork对父进程返回新的子进程的进程ID(一个非负整数)，对子进程则返回0。因为fork创建一个新进程，所以说它被调用一次(由父进程)，但返回两次(分别在父进程中和在子进程中)。</li>
<li>在子进程中，调用<code>execlp</code>以执行从标准输入读入的命令。这就用新的程序文件替换了子进程原先执行的程序文件。</li>
<li>子进程调用<code>execlp</code>执行新程序文件，而父进程希望等待子进程终止，这是通过调用<code>waitpid</code>实现的，其参数指定要等待的进程(即pid参数是子进程ID)。<code>waitpid</code>函数返回子进程的终止状态(<code>status</code>变量)。</li>
<li>该程序的最主要限制是不能向所执行的命令传递参数。例如不能指定要列出目录项的目录名，</li>
</ul>
<h3 id="线程和线程ID"><a href="#线程和线程ID" class="headerlink" title="线程和线程ID"></a>线程和线程ID</h3><p>通常，一个进程只有一个控制线程(thread)——某一时刻执行的一组机器指令。多个控制线程也可以充分利用多处理器系统的并行能力。</p>
<p>一个进程内的所有线程共享同一地址空间、文件描述符、找以及与进程相关的属性。因为它们能访问同一存储区，所以各线程在访问共享数据时需要采取同步措施以避免不一致性。与进程相同，线程也用ID标识。但是，线程ID只在它所属的进程内起作用。一个进程中的线程ID在另一个进程中没有意义。</p>
<p>控制线程的函数与控制进程的函数类似，但另有一套，线程模型是在进程模型建立很久之后才被引入到UNIX系统中的，然而这两种模型之间存在复杂的交互。</p>
<h2 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h2><p>当UNIX系统函数出错时，通常会返回一个负值，而且整型变量errno通常被设置为具有特定信息的值，文件<code>&lt;errno.h&gt;</code>中定义了errno以及可以赋与它的各种常量。这些常量都以字符<code>E</code>开头。</p>
<p>POSIX和ISO C将errno定义为一个符号，它扩展成为一个可修改的整形左值(Ivalue)。它可以是一个包含出错编号的整数，也可以是一个返回出错编号指针的函数。以前使用的定义是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> errno;</span><br></pre></td></tr></table></figure></p>
<p>但是在支持线程的环境中，多个线程共享进程地址空间，每个线程都有属于它自己的局部errno以避免一个线程干扰另一个线程。例如，Linux支持多线程存取errno，将其定义为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> *_errno_location(vold),</span><br><span class="line"><span class="meta">#detine errno (*_errno_location())</span></span><br></pre></td></tr></table></figure></p>
<p>对于errno应当注意两条规则。第一条规则是：如果没有出错，其值不会被侧程清除。因此，仅当函数的返回值指明出错时，才检验其值。第二条规则是：任何函数都不会将errno值设置为0，而且在<code>&lt;errno.h&gt;</code>中定义的所有常量都不为0。</p>
<p>C标准定义了两个函数，它们用于打印出错信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strerror</span> <span class="params">(<span class="type">int</span> errnum)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>strerror</code>函数将<code>errnum</code>(通常就是<code>errno</code>值)映射为一个出错消息字符串，并且返回此字符串的指针。</p>
<p><code>perror</code>函数基于<code>errno</code>的当前值，在标准错误上产生一条出错消息，然后返回。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">perror</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>它首先输出由msg指向的字符串，然后是一个冒号，一个空格，接着是对应于errno值的出错消息，最后是一个换行符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> cerrno.b&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;EACCES: %s\n&quot;</span>, <span class="built_in">strerror</span>(BACCES));</span><br><span class="line">    errno = ENOENT;</span><br><span class="line">    <span class="built_in">perror</span>(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可将在<code>&lt;errno.h&gt;</code>中定义的各种出错分成两类；致命性的和非致命性的。对于致命性的错误，无法执行恢复动作。最多能做的是在用户屏幕上打印出一条出错消息或者将一条出错消息写入日志文件中，然后退出。对于非致命性的出错，有时可以较妥善地进行处理。</p>
<p>大多数非致命性出错是暂时的(如资源短缺)，当系统中的活动较少时，这种出错很可能不会发生。与资源相关的非致命性出情包括：EAGAIN、ENFILE、ENOBUFS、ENOLCK、ENOSPC、EWOULDBLOCK，有时ENOMEM也是非致命性出错。当EBUSY指明共享资源正在使用时，也可将它作为非致命性出错处理。当EINTR中断一个慢速系统调用时，可将它作为非致命性出错处理。</p>
<p>对于资源相关的非致命性出错的典型恢复操作是延迟一段时间，然后重试。一些应用使用指数补偿算法，在每次选代中等待更长时间。</p>
<h2 id="用户标识"><a href="#用户标识" class="headerlink" title="用户标识"></a>用户标识</h2><h3 id="用户ID"><a href="#用户ID" class="headerlink" title="用户ID"></a>用户ID</h3><p>口令文件登录项中的用户ID(userID)是一个数值，它向系统标识各个不同的用户。系统管理员在确定一个用户的登录名的同时，确定其用户ID。用户不能更改其用户ID。</p>
<p>用户ID为O的用户为根用户(root)或超级用户(superuser)。在口令文件中，通常有一个登录项，其登录名为root。我们称这种用户的特权为超级用户特权。如果一个进程具有超级用户特权，则大多数文件权限检查都不再进行。某些操作系统功能只向超级用户提供。</p>
<p>口令文件登录项也包括用户的组D(group ID)，它是一个数值。组ID也是由系统管理员在指定用户登录名时分配的。组被用于将若干用户集合到项目或部门中去。这种机制允许同组的各个成员之间共享资源。组文件将组名映射为数值的组ID。组文件通常是/etc/group。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printe</span> (<span class="string">&quot;uid = %d, gid = %d\n&quot;</span>, <span class="built_in">getuid</span>(), <span class="built_in">getgid</span>());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="附属组ID"><a href="#附属组ID" class="headerlink" title="附属组ID"></a>附属组ID</h3><p>除了在口令文件中对一个登录名指定一个组ID外，大多数UNIX系统版本还允许一个用户属于另外一些组。这一功能是从4.2BSD开始的，它允许一个用户属于多至16个其他的组。登录时，读文件/etc/group。寻找列有该用户作为其成员的前16个记录项就可以得到该用户的附属组ID(supplementary group ID)。</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号(signa)用于通知进程发生了某种情况。进程有以下3种处理信号的方式。</p>
<ol>
<li>忽略信号。有些信号表示硬件异常，例如，除以0或访问进程地址空间以外的存储单元等，因为这些异常产生的后果不确定，所以不推荐使用这种处理方式。</li>
<li>按系统默认方式处理。对于除数为0。系统默认方式是终止该进程。</li>
<li>提供一个函数，信号发生时调用该函数，这被称为捕捉该信号。通过提供自编的函数，我们就能知道什么时候产生了信号，并按期望的方式处理它。</li>
</ol>
<p>很多情况都会产生信号，终端键盘上有两种产生信号的方法，分别称为<strong>中断键</strong>(通常是Delete键成<code>Ctrl+C</code>)和<strong>退出键</strong>(通常是<code>Ctrl+\</code>)，它们被用于中断当前运行的进程。</p>
<p>另一种产生信号的方法是调用kill函数。在一个进程中调用此函数就可向另一个进程发送一个信号。当然这样做也有些限制：当向一个进程发送信号时，我们必须是那个进程的所有者或者是超级用户。</p>
<p>为了能捕捉到信号，程序需要调用signal函数，其中指定了当产生SIGINT信号时要调用的函数的名字。函数名为<code>sig_int</code>，当其被调用时，只是打印一条消息，然后打印一个新提示符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ays/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">statie <span class="type">void</span> <span class="title">sig_int</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">/* our signal-catching function */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE]; <span class="comment">/* trom apue.h */</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGINT, sig_int) == SIG_ERR)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%% &quot;</span>);  <span class="comment">/* print prompt (printf requires %% to print %) */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fgets</span>(buf, MAXLINE, stdin) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">/* replace newline with null */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">err_sys</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;      <span class="comment">/* child */</span></span><br><span class="line">            <span class="built_in">execlp</span>(buf, buf, (<span class="type">char</span> *)<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">err_ret</span>(<span class="string">&quot;couldn&#x27;t execute: %s&quot;</span>, buf);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">127</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* parent */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = <span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">err_sys</span>(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%% &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sig_int</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;interrupt\n %%&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="时间值"><a href="#时间值" class="headerlink" title="时间值"></a>时间值</h2><p>历史上，UNIX系统使用过两种不同的时间值。</p>
<ol>
<li>日历时间。该值是自协调世界时(Coordinated Universal Time, UTC) 1970年1月1日00:00:00这个特定时间以来所经过的秒数累计值。这<br>些时间值可用于记录文件最近一次的修改时间等，系统基本数据类型<code>time_t</code>用于保存这种时间值。</li>
<li>进程时间。也被称为CPU时间，用以度量进程使用的中央处理器资源。进程时间以时钟滴答计算。每秒钟曾经取为50、60或100个时钟滴答。系统基本数据类型<code>clock_t</code>保存这种时间值。</li>
</ol>
<p>当度量一个进程的执行时间时，UNIX系统为一个进程维护了3个进程时间值：</p>
<ul>
<li>时钟时间：时钟时间又称为墙上时钟时间，它是进程运行的时间总量，其值与系统中同时运行的进程数有关。</li>
<li>用户CPU时间：用户CPU时间是执行用户指令所用的时间量。</li>
<li>系统CPU时间：系统CPU时间是为该进程执行内核程序所经历的时间。</li>
</ul>
<p>例如，每当一个进程执行一个系统服务时，如read或write，在内核内执行该服务所花费的时间就计入该进程的系统CPU时间，用户CPU时间和系统CPU时间之和常被称为CPU时间，要取得任一进程的时钟时间、用户时间和系统时间是很容易的一只要执行命令<code>time(1)</code>，其参数是要度量其执行时间的命令，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ed /usr/include</span><br><span class="line">$ <span class="keyword">time</span> -p grep _POSIX_SOURCE  */*.h &gt; /dev/null</span><br><span class="line">real 0m0.81s</span><br><span class="line">user 0m0.11s</span><br><span class="line">sys 0m0.07s</span><br></pre></td></tr></table></figure></p>
<h2 id="系统调用和库函数"><a href="#系统调用和库函数" class="headerlink" title="系统调用和库函数"></a>系统调用和库函数</h2><p>所有的操作系统都提供多种服务的入口点。这些入口点被称为系统调用。Linux3.2.0提供了380个系统调用，FreeBSD8.0提供的系统调用超过450个。</p>
<p>UNIX所使用的技术是为每个系统调用在标准C库中设置一个具有同样名字的函数。用户进程用标准C调用序列来调用这些函数，然后，函数又用系统所要求的技术调用相应的内核服务。</p>
<p>以存储空间分配函数malloc为例。UNIX系统调用中处理存储空间分配的是sbrk(2)，它不是一个通用的存储器管理器。它按指定字节数增加或减少进程地址空间。如何管理该地址空间却取决于进程。存储空间分配函数malloc(3)实现一种特定类型的分配，如果我们不喜欢其操作方式，则可以定义自己的malloc函数，它很可能将使用sbrk系统调用。两者职责不同，内核中的系统调用分配一块空间给进程，而库函数malloc则在用户层次管理这一空间。</p>
<p>系统调用和库函数之间的另一个差别是：系统调用通常提供一种最小接口，而库函数通常提供比较复杂的功能。我们从sbrk系统调用和malloc库函数之间的差别中可以看到这一点。进程控制系统调用(tork、exec和wait)通常由用户应用程序直接调用。但是为了简化某些常见的情况， UNIX系统也提供了一些库函数，如system和popen。</p>
<h1 id="文件I-O"><a href="#文件I-O" class="headerlink" title="文件I/O"></a>文件I/O</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>UNIX系统中的大多数文件I/O只需用到5个函数：<code>open</code>、<code>read</code>、<code>write</code>、<code>lseek</code>、<code>close</code>。本章描述的函数经常被称为不带缓冲的I/O (unbuffered I/O。术语不带缓冲指的是每个read和write都调用内核中的一个系统调用。</p>
<h2 id="文件描述符-1"><a href="#文件描述符-1" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>对于内核而言。所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。当读、写一个文件时，使用<code>open</code>或<code>creat</code>返回的文件描述符标识该文件，将其作为参数传送给<code>read</code>或<code>write</code>。</p>
<p>按照惯例，UNIX系统shell把文件描述符0与进程的标准输入关联，文件描述符1与标准输出关联，文件描述符2与标准错误关联。这是各种shell以及很多应用程序使用的惯例，与UNIX内核无关。应当把它们替换成符号常量<code>STDIN_FILENO</code>、<code>STDOUT_FILENO</code>和<code>STDERR_FILENO</code>以提高可读性。这些常量都在头文件<code>&lt;unistd.h&gt;</code>中定义，文件描述符的变化范围是0~<code>OPEN_MAX-1</code>。</p>
<h2 id="函数open和openat"><a href="#函数open和openat" class="headerlink" title="函数open和openat"></a>函数open和openat</h2><p>调用open或openat函数可以打开或创建一个文件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> oflag, .... <span class="comment">/* mode_t mode */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">openat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> oflag, ...<span class="comment">/* mode_t mode */</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>两函数的返回值：若成功，返回文件描述符；若出错，返回-1。</p>
<p>我们将最后一个参数写为<code>...</code>。ISO C用这种方法表明余下的参数的数量及其类型是可变的。对于open函数而言，仅当创建新文件时才使用最后这个参数。在函数原型中将此参数放置在注释中。</p>
<p>path参数是要打开或创建文件的名字。oflag参数可用来说明此函数的多个选项。用下列一个或多个常量进行“或”运算构成oflag参数(这些常量在头文件<code>&lt;fcntl.h&gt;</code>中定义)。</p>
<ul>
<li><code>O_RDONLY</code>：只读打开。</li>
<li><code>O_WRONLY</code>：只写打开。</li>
<li><code>O_RDWR</code>：读、写打开。</li>
<li><code>O_EXEC</code>：只执行打开。</li>
<li><code>O_SEARCH</code>：只搜索打开(应用于目录)。</li>
</ul>
<p>大多数实现将<code>O_RDONLY</code>定义为0，<code>O_WRONLY</code>定义为1，<code>O_RDWR</code>定义为2。<code>O_SEARCH</code>常量的目的在于在目录打开时验证它的搜索权限。对目录的文件描述符的后续操作就不需要再次检查对该目录的搜索权限。</p>
<p>在这5个常量中必须指定一个且只能指定一个。下列常量则是可选的。</p>
<ul>
<li><code>O_APPEND</code>：每次写时都追加到文件的尾端。</li>
<li><code>O_CLOEXEC</code>：把<code>FD_CIOEXEC</code>常量设置为文件描述符标志。</li>
<li><code>O_CREAT</code>：若此文件不存在则创建它。使用此选项时，open函数需同时说明第3个参数mode，用mode指定该新文件的访问权限位</li>
<li><code>O_DIRECTORY</code>：如果path引用的不是目录，则出错。</li>
<li><code>O_EXCL</code>：如果同时指定了<code>O_CREAT</code>，而文件已经存在，则出错。用此可以测试一个文件是否存在，如果不存在，则创建此文件，这使测试和创建两者成为一个原子操作。</li>
<li><code>O_NOCTTY</code>：如果path引用的是终端设备，则不将该设备分配作为此进程的控制终端。</li>
<li><code>O_NOFOLLOW</code>：如果path引用的是一个符号链接，则出错。</li>
<li><code>O_NONBLOCK</code>：如果path引用的是一个FIFO、一个块特殊文件或一个字符特殊文件，则此选项为文件的本次打开操作和后续的I/O操作设置非阻塞方式。</li>
<li><code>O_SYNC</code>：使每次write等待物理I／O操作完成，包括由该write操作引起的文件属性更新所需的I／O</li>
<li><code>O_TRUNC</code>：如果此文件存在，而且为只写或读-写成功打开，则将其长度截断为0</li>
<li><code>0_TTY_INIT</code>：如果打开一个还未打开的终端设备，设置非标准termios参数值，使其符合Single UNIX Specification。</li>
</ul>
<p>下面两个标志也是可选的。</p>
<ul>
<li><code>O_DSYNC</code>：使每次write要等待物理I／O操作完成，但是如果该写操作并不影响读取刚写入的数据，则不需等待文件属性被更新，<ul>
<li><code>O_DSYNC</code>和<code>O_SYNC</code>标志有微妙的区别。仅当文件属性需要更断以反映文件数据变化时，<code>O_DSYNC</code>标志才影响文件属性。而设置<code>O_SYNC</code>标志后，教据和属性总是同步更新。当文件用<code>O_DSYN</code>标志打开，在重写其现有的部分内容时，文件时间属性不会同步更新，与此相反，如果文件是用<code>O_SYNC</code>标志打开，那么对该文件的每一次write都将在write返回前更新文件时间，这与是否改写现有字节或追加写文件无关。</li>
</ul>
</li>
<li><code>O_RSYNC</code>：使每一个以文件描述符作为参数进行的read操作等待，直至所有对文件同一部分挂起的写操作都完成</li>
</ul>
<p>由open和openat函数返回的文件描述符一定是最小的未用描述符数值。这一点被某些应用程序用来在标准输入、标准输出或标准错误上打开新的文件。例如，一个应用程序可以先关闭标准输出(通常是文件描述符1)，然后打开另一个文件，执行打开操作前就能了解到该文件一定会在文件描述符1上打开。</p>
<p><code>fd</code>参数把open和openat函数区分开，共有3种可能性。</p>
<ol>
<li>path参数指定的是绝对路径名，在这种情况下，后参数被忽略，openat函数就相当于open函数。</li>
<li>path参数指定的是相对路径名，后参数指出了相对路径名在文件系统中的开始地址。fd参数是通过打开相对路径名所在的目录来获取。</li>
<li>path参数指定了相对路径名，fd参数具有特殊值<code>AT_FDCWD</code>。在这种情况下，路径名在当前工作目录中获取，openat函数在操作上与open函数类似。</li>
</ol>
<p><code>openat</code>希望解决两个问题。</p>
<ul>
<li>让线程可以使用相对路径名打开目录中的文件，而不再只能打开当前工作目录。</li>
<li>可以避免time of-check-to-time-of-use(TOCTTOU)错误。</li>
</ul>
<p>TOCTTOU错误的基本思想是：如果有两个基于文件的函数调用，其中第二个调用依赖于第一个调用的结果，那么程序是脆弱的。因为两个调用并不是原子操作，在两个函数调用之间文件可能改变了，这样也就造成了第一个调用的结果就不再有效，使得程序最终的结果是错误的。文件系统命名空间中的TOCTTOU错误通常处理的就是那些颠覆文件系统权限的小把戏，这些小把戏通过骗取特权程序降低特权文件的权限控制或者让特权文件打开一个安全漏洞等方式进行。</p>
<h3 id="文件名和路径名截断"><a href="#文件名和路径名截断" class="headerlink" title="文件名和路径名截断"></a>文件名和路径名截断</h3><p>在POSIX.1中，常量<code>_POSIX_NO_TRUNC</code>决定是要截断过长的文件名或路径名，还是返回一个出错。用<code>fpathconf</code>或<code>pathconf</code>来查询目录具体支持何种行为，到底是截断过长的文件名还是返回出错。若<code>_POSIX_NO_TRUNC</code>有效，则在整个路径名超过<code>PATH_MAX</code>，或路径名中的任一文件名超过<code>NAME_MAX</code>时，出错返回，并将errno设置为<code>ENAMETOOLONG</code>。</p>
<h2 id="函数creat"><a href="#函数creat" class="headerlink" title="函数creat"></a>函数creat</h2><p>也可调用creat函数创建一个新文件，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">creat</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> path, <span class="type">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>返回值：若成功，返回为只写打开的文件描述符；若出错，返回-1。<br>注意，此函数等效于：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(ptsh, O_WRONLY | O_CREAT | O_TRUNC, mode);</span><br></pre></td></tr></table></figure></p>
<p>creat的一个不足之处是它以只写方式打开所创建的文件。在提供open的新版本之前，如果要创建一个临时文件，并要先写该文件，然后又读该文件，则必须先调用<code>creat</code>、<code>close</code>，然后再调用<code>open</code>。现在则可用下列方式调用open实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span> (path, O_RDWR | O_CREAT | O_TRUNC, mode);</span><br></pre></td></tr></table></figure></p>
<p>63</p>
<h2 id="函数close"><a href="#函数close" class="headerlink" title="函数close"></a>函数close</h2><p>可调用close函数关闭一个打开文件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span> <span class="params">(<span class="type">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><br>返回值：若成功，返回0；若出错，返回-1。</p>
<p>关闭一个文件时还会释放该进程加在该文件上的所有记录锁。当一个进程终止时，内核自动关闭它所有的打开文件。很多程序都利用了这一功能而不显式地用close关闭打开文件。</p>
<h2 id="函数lseek"><a href="#函数lseek" class="headerlink" title="函数lseek"></a>函数lseek</h2><p>每个打开文件都有一个与其相关联的“当前文件偏移量”(current file offset)。它通常是一个非负整数，用以度量从文件开始处计算的字节数。通常，读、写操作都从当前文件偏移量处开始，并使偏移量增加所读写的字节数。按系统默认的情况，当打开一个文件时，除非指定<code>O_APPEND</code>选项，否则该偏移量被设置为0。可以调用<code>lseek</code>显式地为一个打开文件设置偏移量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">off_t</span> <span class="title">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offuet, <span class="type">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure><br>返回值：若成功，返回新的文件偏移量；若出错，返回为-1。</p>
<p>对参数<code>offset</code>的解释与参数<code>whence</code>的值有关</p>
<ul>
<li>若<code>whence</code>是<code>SEEK_SET</code>，则将该文件的偏移量设置为距文件开始处<code>offset</code>个字节。</li>
<li>若<code>whence</code>是<code>SEEK CUR</code>，则将该文件的偏移量设置为其当前值加<code>offset</code>，<code>offset</code>可为正或负。</li>
<li>若<code>whence</code>是<code>SEEK_END</code>，则将该文件的偏移量设置为文件长度加<code>offset</code>，<code>offset</code>可正可负。</li>
</ul>
<p>若<code>lseek</code>成功执行，则返回新的文件偏移量，为此可以用下列方式确定打开文件的当前偏移量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> currpos;</span><br><span class="line">currpos = lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br></pre></td></tr></table></figure></p>
<p>这种方法也可用来确定所涉及的文件是否可以设置偏移量。如果文件描述符指向的是一个管道、FIFO或网络套接字，则<code>lseek</code>返回-1，并将<code>errno</code>设置为<code>ESPIPE</code>。</p>
<p>3个符号常量<code>SEEK_SET</code>、<code>SEBK_CUR</code>和<code>SEEK_END</code>是在System V中引入的。在System V之前，<code>whence</code>被指定为0(绝对偏移量)、1(相对于当前位置的偏移量)或2(相对文件尾端的偏移量)。</p>
<p>在<code>lseek</code>中的字符l表示长整型。在引入<code>off_t</code>教据类型之前，<code>offset</code>参数和返回值是长整型的。</p>
<p>所示的程序用于测试对其标准输入能否设置偏移量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">lseek</span>(STDIN_FILENO, <span class="number">0</span>, SEEK_CUR) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cannot seek\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;seek OK\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常，文件的当前偏移量应当是一个非负整数，但是，某些设备也可能允许负的偏移量。但对于普通文件，其偏移量必须是非负值。因为偏移量可能是负值，所以在比较lseek的返回值时应当谨慎，不要测试它是否小于0，而要测试它是否等于-1。</p>
<p>文件偏移量可以大于文件的当前长度，在这种情况下，对该文件的下一次写将加长该文件，并在文件中构成一个空洞，这一点是允许的。位于文件中但没有写过的字节都被读为0。文件中的空洞并不要求在磁盘上占用存储区。具体处理方式与文件系统的实现有关，当定位到超出文件尾端之后写时，对于新写的数据需要分配磁盘块，但是对于原文件尾端和新开始写位置之间的部分则不需要分配磁盘块。</p>
<p>所示的程序用于创建一个具有空洞的文件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> buf1[] = <span class="string">&quot;abcdefghij&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf2[] = <span class="string">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span>((fd = <span class="built_in">creat</span>(<span class="string">&quot;File.hole&quot;</span>, FILE_MODE)) &lt; <span class="number">0</span>)</span><br><span class="line">       <span class="built_in">err_sys</span> (<span class="string">&quot;creat error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">write</span>(fd, buf1, <span class="number">10</span>) != <span class="number">10</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;buti write error&quot;</span>);</span><br><span class="line">    <span class="comment">/*oftset now = 10 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">lseek</span>(fd, <span class="number">16384</span>, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;lseek exroz&quot;</span>);</span><br><span class="line">    <span class="comment">/*offset now = 16384 */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">write</span>(fd, buf2, <span class="number">10</span>) != <span class="number">10</span>)</span><br><span class="line">        <span class="built_in">exr_sys</span>(<span class="string">&quot;buf2 write excor&quot;</span>),</span><br><span class="line">    <span class="comment">/*oftset now = 16394 */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行该程序得到：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">$ ls -l file.hoel</span><br><span class="line">-rw-r--r-- 1 sar    16394 Nov 25 01:01 file.hole</span><br><span class="line">$ od -c file.hole</span><br><span class="line">0000000 a b c d e f g h i j \0 \0 \0 \0 \0 \0</span><br><span class="line">0000020 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0</span><br><span class="line">*</span><br><span class="line">0040000 A B C D E F G H I J</span><br><span class="line">0040012</span><br></pre></td></tr></table></figure></p>
<p>使用od(1)命令观察该文件的实际内容。命令行中的<code>-c</code>标志表示以字符方式打印文件内容。从中可以看到，文件中间的30个未写入字节都被读成0。每一行开始的一个7位数是以八进制形式表示的字节偏移量。</p>
<p>因为<code>lseek</code>使用的偏移量是用<code>off_t</code>类型表示的，所以允许具体实现根据各自特定的平台自行选择大小合适的数据类型。现今大多数平台提供两组接口以处理文件偏移量。一组使用32位文件偏移量，另一组则使用64位文件偏移量。</p>
<p>Single UNIX Specification向应用程序提供了一种方法，使其通过sysconf函数确定支持何种环境。图总结了定义的sysconf常量。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项名称</th>
<th>说明</th>
<th>mame参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>_POSIX_V7_ILP32_OFF32</td>
<td>int、long、指针和ott_t类型是32位</td>
<td>_SC_V7_ILP32_OFF32</td>
</tr>
<tr>
<td>_POSIX_V7_ILP32_OFFBIG</td>
<td>int、long、指针类型是32位。off_t类型至少是64位</td>
<td>_SC_V7_ILP32_OFFBIG</td>
</tr>
<tr>
<td>_POSIX_V7_LP64_OFF64</td>
<td>int类型是32位,long、指针和off_t是64位</td>
<td>_SC_V7_LP64_OFF64</td>
</tr>
<tr>
<td>_POSIX_V7_LP64_OFFBIG</td>
<td>int类型是32位，long、指针和off_t类型至少是64位</td>
<td>_SC_V7_LP64_OFFBIG</td>
</tr>
</tbody>
</table>
</div>
<p>C99编译器要求使用<code>getconf(1)</code>命令将所期望的数据大小模型映射为编译和链接程序所需的标志。根据每个平台支持环境的不同，可能需要不同的标志和库。</p>
<h2 id="函数read"><a href="#函数read" class="headerlink" title="函数read"></a>函数read</h2><p>调用read函数从打开文件中读数据，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, vold *buf, <span class="type">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>如read成功，则返回读到的字节数。如已到达文件的尾端，则返回0。有多种情况可使实际读到的字节数少于要求读的字节数：</p>
<ul>
<li>读普通文件时，在读到要求字节数之前已到达了文件尾端。例如，若在到达文件尾端之前有30个字节，而要求读100个字节，则read返回30。下一次再调用read时，它将返回0(文件尾端)。</li>
<li>当从终端设备读时，通常一次最多读一行</li>
<li>当从网络读时，网络中的缓冲机制可能造成返回值小于所要求读的字节数。</li>
<li>当从管道或FIFO读时，如着管道包含的字节少于所需的数量，那么read将只返回实际可用的字节数。</li>
<li>当从某些面向记录的设备读时，一次最多返回一个记录。</li>
<li>当一信号造成中断，而已经读了部分数据量时。</li>
</ul>
<p>读操作从文件的当前偏移量处开始，在成功返回之前，该偏移量将增加实际读到的字节数。POSIX.1从几个方面对read函数的原型做了更改。经典的原型定义是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf, <span class="type">unsigned</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>首先，为了与ISO C一致，第2个参数由<code>char*</code>改为<code>void*</code>。在ISO C中，类型<code>void*</code>用于表示通用指针。</li>
<li>其次，返回值必须是一个带符号整型(<code>ssize_t</code>)，以保证能够返回正整数字节数、0(表示文件尾端)或-1(出错)。</li>
<li>最后，第3个参数在历史上是一个无符号整型，这允许一个16位的实现一次读或写的数据可以多达65534个字节。</li>
</ul>
<h2 id="函数write"><a href="#函数write" class="headerlink" title="函数write"></a>函数write</h2><p>调用write函数向打开文件写数据<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>其返回值通常与参数nbytes的值相同，否则表示出错。write出错的一个常见原因是磁盘已写满，或者超过了一个给定进程的文件长度限制。</p>
<p>对于普通文件，写操作从文件的当前偏移量处开始。如果在打开该文件时，指定了<code>O_APPEND</code>选项，则在每次写操作之前，将文件偏移量设置在文件的当前结尾处。在一次成功写之后，该文件偏移量增加实际写的字节数。</p>
<h2 id="I-O的效率"><a href="#I-O的效率" class="headerlink" title="I/O的效率"></a>I/O的效率</h2><p>图3-5程序只使用read和write函数复制一个文件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFSIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> buf[BUFFSIZE];</span><br><span class="line">    <span class="keyword">while</span>((n = <span class="built_in">read</span>(STDIN_FILENO, buf, BUFFSIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">write</span>(STDOUT_FILENO, buf, n) != n)</span><br><span class="line">            <span class="built_in">err_sys</span>(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_ays</span> (<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">    <span class="built_in">exif</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于该程序应注意以下几点。</p>
<ul>
<li>它从标准输入读，写至标准输出，这就假定在执行本程序之前，这些标准输入、输出已由shell安排好。</li>
<li>考虑到进程终止时，UNIX系统内核会关闭进程的所有打开的文件描述符，所以此程序并不关闭输入和输出文件。</li>
<li>对UNIX系统内核而言，文本文件和二进制代码文件并无区别，所以本程序对这两种文件都有效。</li>
</ul>
<p>让我们先用各种不同的BUFFSIZE值来运行此程序。图显示了用20种不同的缓冲区长度，读516581760字节的文件所得到的结果。<br><img src="/img/1620962971.jpg" alt=""></p>
<p>读文件的标准输出被重新定向到<code>/dev/null</code>上。此测试所用的文件系统是Linux ext4文件系统，其磁盘块长度为4096字节。这也证明了系统CPU时间的几个最小值差不多出现在<code>BUFFSIZE</code>为4096及以后的位置，继续增加缓冲区长度对此时间几乎没有影响。</p>
<p>大多数文件系统为改善性能都采用某种预读(read ahcad)技术。当检测到正进行顺序读取时，系统就试图读入比应用所要求的更多数据。并假想应用很快就会读这些数据。预读的效果可以从图中看出，缓冲区长度小至32字节时的时钟时间与拥有较大缓冲区长度时的时钟时间几乎一样。</p>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>内核使用3种数据结构表示打开文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响。</p>
<ul>
<li>每个进程在进程表中都有一个记录项，记录项中包含一张打开文件描述符表，可将其视为一个矢量，每个描述符占用一项。与每个文件描述符相关联的是：<ul>
<li>文件描述符标志(<code>close_on_exec</code>)</li>
<li>指向一个文件表项的指针</li>
</ul>
</li>
<li>内核为所有打开文件维持一张文件表。每个文件表项包含：<ul>
<li>文件状态标志(读、写、添写、同步和非阻塞等)</li>
<li>当前文件偏移量</li>
<li>指向该文件v节点表项的指针</li>
</ul>
</li>
<li>每个打开文件(或设备)都有一个v节点(v-node)结构。v节点包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，v节点还包含了该文件的i节点(i-node，索引节点)。这些信息是在打开文件时从磁盘上读入内存的。</li>
</ul>
<p>图显示了一个进程对应的3张表之间的关系。该进程有两个不同的打开文件，一个文件从标准输入打开(文件描述符0)，另一个从标准输出打开(文件描述符为1)。<br><img src="/img/20210515010759.png" alt=""></p>
<p>创建v节点结构的目的是对在一个计算机系统上的多文体系统类型提供支持。Sun把这种文件系统称为虚拟文件系统(Virtual File System)，把与文件系统无关的i节点部分称为V节点。</p>
<p>Linux没有将相关数据结构分为i节点和v节点，而是采用了一个与文件系统相关的i节点和一个与文件系统无关的i节点。</p>
<p>如果两个独立进程各自打开了同一文件，则有图中所示的关系。<br><img src="/img/20210515011014.png" alt=""></p>
<p>我们假定第一个进程在文件描述符3上打开该文件，而另一个进程在文件描述符4上打开该文件。打开该文件的每个进程都获得各自的一个文件表项，但对一个给定的文件只有一个v节点表项。之所以每个进程都获得自己的文件表项，是因为这可以使每个进程都有它自己的对该文件的当前偏移量。</p>
<ul>
<li>在完成每个write后，在文件表项中的当前文件偏移量即增加所写入的字节数。如果这导致当前文件偏移量超出了当前文件长度，则将i节点表项中的当前文件长度设置为当前文件偏移量。</li>
<li>如果用<code>O_APPEND</code>标志打开一个文件，则相应标志也被设置到文件表项的文件状态标志中。每次对这种具有追加写标志的文件执行写操作时，文件表项中的当前文件偏移量首先会被设置为i节点表项中的文件长度。这就使得每次写入的数据都追加到文件的当前尾端处。</li>
<li>若一个文件用<code>lseek</code>定位到文件当前的尾端，则文件表项中的当前文件偏移量被设置为i节点表项中的当前文件长度。</li>
<li>lseek函数只修改文件表项中的当前文件偏移量，不进行任何I／O操作。</li>
</ul>
<p>可能有多个文件描述符项指向同一文件表项。在fork后也发生同样的情况，此时父进程、子进程各自的每一个打开文件描述符共享同一个文件表项。</p>
<p>注意，文件描述符标志和文件状态标志在作用范围方面的区别，前者只用于一个进程的一个描述符，而后者则应用于指向该给定文件表项的任何进程中的所有描述符。</p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><h3 id="追加到一个文件"><a href="#追加到一个文件" class="headerlink" title="追加到一个文件"></a>追加到一个文件</h3><p>考虑一个进程，它要将数据追加到一个文件尾端。早期的UNIX系统版本并不支持open的<code>O_APPEND</code>选项，所以程序被编写成下列形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">lseek</span>(fd, OL, <span class="number">2</span>) &lt; <span class="number">0</span>) <span class="comment">/*position to EOF */</span></span><br><span class="line">    <span class="built_in">err_sys</span>(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">write</span>(fd, buf, <span class="number">100</span>) != <span class="number">100</span>) <span class="comment">/* and write */</span></span><br><span class="line">    <span class="built_in">err_sys</span>(<span class="string">&quot;write error&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>对单个进程而言，这段程序能正常工作，但若有多个进程同时使用这种方法将数据追加写到同一文件，则会产生问题。</p>
<p>假定有两个独立的进程A和B都对同一文件进行追加写操作。每个进程都已打开了该文件，但未使用<code>O_APPEND</code>标志，此时，每个进程都有它自己的文件表项，但是共享一个v节点表项。假定进程A调用了<code>lseek</code>，它修改了当前偏移量，然后内核切换进程，进程B执行<code>lseek</code>也修改了当前偏移量设置为1500字节。这样造成了两个进程写入数据的重叠。</p>
<p>解决方法是使这<code>lseek</code>和<code>write</code>两个操作对于其他进程而言成为一个原子操作。UNIX系统为这样的操作提供了一种原子操作方法，即在打开文件时设置<code>O_APPEND</code>标志，这样做使得内核在每次写操作之前，都将进程的当前偏移量设置到该文件的尾漏处，于是在每次写之前就不再需要调用<code>lseek</code>。</p>
<h3 id="函数pread和pwrite"><a href="#函数pread和pwrite" class="headerlink" title="函数pread和pwrite"></a>函数pread和pwrite</h3><p>Single UNIX Specification包括了XSI扩展，该扩展允许原子性地定位并执行I/O。<code>pread</code>和<code>pwrite</code>就是这种扩展。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uniatd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">pread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，读到的字节数，若已到文件尾，返回0；若出错，返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">pwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回已写的字节数， 若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>调用<code>pread</code>相当于调用<code>lseek</code>后调用<code>read</code>，但是<code>pread</code>又与这种顺序调用有下列重要区别。</p>
<ul>
<li>调用pread时，无法中断其定位和读操作。</li>
<li>不更新当前文件偏移量。</li>
</ul>
<p>调用pwrite相当于调用<code>lseek</code>后调用<code>write</code>，但也与它们有类似的区别。</p>
<h3 id="创建一个文件"><a href="#创建一个文件" class="headerlink" title="创建一个文件"></a>创建一个文件</h3><p>对open函数的<code>O_CREAT</code>和<code>O_EXCL</code>选项，当同时指定这两个选项，而该文件又已经存在时，open将失败。我们曾提及检查文件是否存在和创建文件这两个操作是作为一个原子操作执行的。如果没有这样一个原子操作，那么可能会编写下列程序段：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((fd = <span class="built_in">open</span>(pathname, O_WRONLY)) &lt; O) &#123;</span><br><span class="line">    <span class="keyword">if</span>(errno = ENOENT) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((fd = <span class="built_in">creat</span>(path, mode)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">err_sys</span> (<span class="string">&quot;creat ecror&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果在open和creat之间，另一个进程创建了该文件，就会出现问题。若在这两个函数调用之间，另一个进程创建了该文件，并且写入了一些数据。然后，原先进程执行这段程序中的creat，这时，刚由另一进程写入的数据就会被擦去。</p>
<p>一般而言，原子操作(atomic operation)指的是由多步组成的一个操作。如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。</p>
<h2 id="函数dup和dup2"><a href="#函数dup和dup2" class="headerlink" title="函数dup和dup2"></a>函数dup和dup2</h2><p>下面两个函数都可用来复制一个现有的文件描述符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup</span> <span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup2</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> fd2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两函数的返回值。若成功，返回新的文件描述符，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>由dup返回的新文件描述符一定是当前可用文件描述符中的最小数值。对于dup2，可以用<code>fd2</code>参数指定新描述符的值。如果<code>fd2</code>已经打开，则先将其关闭。如若<code>fd</code>等于<code>fd2</code>，则dup2返回<code>fd2</code>，而不关闭它。否则，<code>fd2</code>的<code>FD_CLOEXEC</code>文件描述符标志就被清除，这样fd2在进程调用exec时是打开状态。</p>
<p>这些函数返回的新文件描述符与参数fd共享同一个文件表项，如图所示。<br><img src="/img/20210515094251.png" alt=""></p>
<p>在此图中，我们假定进程启动时执行了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newfd = <span class="built_in">dup</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>当此函数开始执行时，假定下一个可用的描述符是3(这是非常可能的，因为0, 1和2都由shell打开)。因为两个描述符指向同一文件表项，所以它们共享同一文件状态标志(读、写、追加等)以及同一当前文件偏移量。</p>
<p>复制一个描述符的另一种方法是使用<code>fcntl</code>函数。实际上，调用<code>dup(fd);</code>等效于<code>fcntl(fd, F_DUPFD, 0);</code>，而调用<code>dup2(fd, fd2);</code>等效于<code>close(fd2); fcntl(fd, E_DUPFD, fd2);</code>。在后一种情况下，<code>dup2</code>并不完全等同于<code>close</code>加上<code>fcnt1</code>。它们之间的区别具体如下。</p>
<ol>
<li><code>dup2</code>是一个原子操作，而<code>close</code>和<code>fcnt1</code>包括两个函数调用。有可能在<code>close</code>和<code>fcnt1</code>之间调用了信号捕获函数，它可能修改文件描述符。如果不同的线程改变了文件描述符的话也会出现相同的问题。</li>
<li><code>dup2</code>和<code>fcntl</code>有一些不同的errno。</li>
</ol>
<h2 id="函数sync、fsync和fdatasync"><a href="#函数sync、fsync和fdatasync" class="headerlink" title="函数sync、fsync和fdatasync"></a>函数sync、fsync和fdatasync</h2><p>传统的UNIX系统实现在内核中设有缓冲区高速缓存或页高速缓存，大多数磁盘I/O都通过缓冲区进行。当我们向文件写入数据时，内核通常先将数据复制到缓冲区中，然后排入队列，晚些时候再写入磁盘。这种方式被称为延迟写(delayed write)。</p>
<p>通常，当内核需要重用缓冲区来存放其他磁盘块数据时，它会把所有延迟写数据块写入磁盘。为了保证磁盘上实际文件系统与缓冲区中内容的一致性，UNIX系统提供了<code>sync</code>、<code>fsync</code>和<code>fdatasync</code>三个函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fsync</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fdatasync</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sync</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>sync</code>只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束，通常，称为<code>update</code>的系统守护进程周期性地调用(一般每隔30秒)<code>sync</code>函数。这就保证了定期冲洗(flush)内核的块缓冲区。命令<code>sync(1)</code>也调用<code>sync</code>函数。</p>
<p><code>fsync</code>函数只对由文件描述符<code>fd</code>指定的一个文件起作用，并且等待写磁盘操作结束才返回。<code>fsync</code>可用于数据库这样的应用程序，这种应用程序需要确保修改过的块立即写到磁盘上。</p>
<p><code>fdatasync</code>函数类似于<code>fsync</code>，但它只影响文件的数据部分。而除数据外，<code>fsync</code>还会同步更新文件的属性。</p>
<h2 id="函数fcntl"><a href="#函数fcntl" class="headerlink" title="函数fcntl"></a>函数fcntl</h2><p>fcntl函数可以改变已经打开文件的属性，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcnti.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="comment">/* int arg */</span>)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，则依赖于cmd(见下)，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>第3个参数总是一个整数，与上面所示函数原型中的注释部分对应。<code>fcntl</code>函数有以下5种功能</p>
<ol>
<li>复制一个已有的描述符(cmd=<code>F_DUPFD</code>或<code>F_DUPFD_CLOEXEC</code>).</li>
<li>获取/设置文件描述符标志(cmd=<code>F_GETFD</code>或<code>F_SETFD</code>).</li>
<li>获取/设置文件状态标志(cmd=<code>F_GETFL</code>或<code>F_SETFL</code>).</li>
<li>获取/设置异步I/O所有权(cmd=<code>F_GETOWN</code>或<code>F_SETOWN</code>)。</li>
<li>获取/设置记录锁(cmd=<code>F_GETLK</code>、<code>F_SETLK</code>或<code>F_SETLKW</code>).</li>
</ol>
<ul>
<li><code>F_DUPFD</code>：复制文件描述符fd。新文件描述符作为函数值返回。它是尚未打开的各描述符中大于或等于第3个参数值(取为整型值)中各值的最小值。新描述符与后共享同一文件表项。但是，新描述符有它自己的一套文件描述符标志，其<code>FD_CLOEXEC</code>文件描述符标志被清除</li>
<li><code>F_DUPFD_CLOEXEC</code>：复制文件描述符，设置与新描述符关联的FD_CLOEXEC文件描述符标志的值，返回新文件描述符</li>
<li><code>F_GETFD</code>：对应于fd的文件描述符标志作为函数值返回。当前只定义了一个文件描述符标志<code>FD_CLOEXEC</code></li>
<li><code>F_SETFD</code>：对于fd设置文件描述符标志。新标志值按第3个参数(取为整型值)设置</li>
<li><code>F_GETFL</code>：对应于fd的文件状态标志作为函数值返回。我们在说明open函数时，已描述了文件状态标志。</li>
</ul>
<p><img src="/img/20210515101810.png" alt=""></p>
<p>遗憾的是，5个访问方式标志(<code>O_RDONLY</code>、<code>O_WRONLY</code>、<code>O_RDWR</code>、<code>O_EXEC</code>、<code>O_SEARCH</code>)并不各占1位。这5个值互斥，一个文件的访问方式只能取这5个值之一。因此首先必须用屏蔽字<code>O_ACCMODE</code>取得访问方式位，然后将结果与这5个值中的每一个相比较</p>
<ul>
<li><code>F_SETFL</code>：将文件状态标志设置为第3个参数的值(取为整型值)。可以更改的几个标志是：<code>O_APPEND</code>、<code>O_NONBLOCK</code>、<code>O_SYNC</code>、<code>O_DSYNC</code>、<code>O_RSYNC</code>、<code>O_FSYNC</code>、<code>O_ASYNC</code>。</li>
<li><code>F_GETOWN</code>：获取当前接收SIGIO和SIGURG信号的进程ID或进程组ID</li>
<li><code>F_SETOWN</code>：设置接收SIGIO和SIGURG信号的进程ID或进程组ID。正的arg指定一个进程ID，负的arg表示等于arg绝对值的一个进程组ID</li>
</ul>
<p><code>fcntl</code>的返回值与命令有关。如果出错，所有命令都返回-1，如果成功则返回某个其他值。下列4个命令有特定返回值：<code>F_DUPFD</code>、<code>F_GETFD</code>、<code>F_GETFL</code>、<code>F_GETOWN</code>。第1个命令返回新的文件描述符，第2个和第3个命令返回相应的标志，最后一个命令返回一个正的进程ID或负的进程组ID</p>
<p>所示程序的第1个参数指定文件描述符，并对于该描述符打印其所选择的文件标志说明<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">err_quit</span>(<span class="string">&quot;usage; a.out &lt;descriptort&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((val = <span class="built_in">fcntl</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]), F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fcntl error for id io&quot;</span>, <span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">switch</span> (val &amp; O_ACCMODE) &#123;</span><br><span class="line">    <span class="keyword">case</span> O_RDONLY:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read only&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_WRONLY:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write only&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_RDWR:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read write&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">err_dump</span>(<span class="string">&quot;unknown access mode&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val &amp; O_APPEND)</span><br><span class="line">        <span class="built_in">printt</span>(<span class="string">&quot;, append&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (val &amp; O_NONBLOCK)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;, nonblocking&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(val &amp; O_SYNC)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;, synchronous writes&quot;</span>);</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> !defined(_POSIX_C_SOURCE) &amp;&amp; defined (O_FSYNC) &amp;&amp; (O_FSYNC != 0_SYNC)</span></span><br><span class="line">    <span class="keyword">if</span> (val &amp; O_FSYNC)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;, synchronous writes&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="built_in">exif</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，我们使用了功能测试宏<code>_POSIX_C_SOURCE</code>，并且条件编译了POSIX.1中没有定义的文件访问标志。</p>
<p>在修改文件描述符标志或文件状态标志时必须谨慎，先要获得现在的标志值，然后按照期望修改它，最后设置新标志值。不能只是执行<code>F_SETFD</code>或<code>F_SETFL</code>命令，这样会关闭以前设置的标志位。下程序对于一个文件描述符设置一个或多个文件状态标志的函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_fl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> flags)</span> </span>&#123;<span class="comment">/* flags are tile status flags to turn on */</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">if</span>((val = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fcntl F_GETFL error&quot;</span>);</span><br><span class="line">    val |= flags;    <span class="comment">/*turn on flags */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fcntl</span>(fd, F_SETFL, val) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fcntl F_SETTL error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果将中间的一条语句改为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val &amp;= ~flags;</span><br><span class="line"><span class="comment">/*turn flags off */</span></span><br></pre></td></tr></table></figure></p>
<p>就构成另一个函数，我们称为<code>clr_fl</code>，并将在后面某些例子中用到它。此语句使当前文件状态标志值val与flags的反码进行逻辑”与”运算。</p>
<p>在UNIX系统中，通常write只是将数据排入队列，而实际的写磁盘操作则可能在以后的某个时刻进行。而数据库系统则需要使用<code>O_SYNC</code>，这样一来，当它从write返回时就知道数据已确实写到了磁盘上，以免在系统异常时产生数据丢失程序运行时，设置<code>O_SYNC</code>标志会增加系统时间和时钟时间。</p>
<p>比较<code>fsync</code>和<code>fdatasync</code>，两者都更新文件内容，用了<code>O_SYNC</code>标志，每次写入文件时都更新文件内容。每一种调用的性能依赖很多因素，包括底层的操作系统实现、磁盘驱动器的速度以及文件系统的类型。</p>
<p>我们的程序在一个描述符(标准输出)上进行操作，但是根本不知道由shell打开的相应文件的文件名。因为这是shell打开的，因此不能在打开时按我们的要求设置<code>O_SYNC</code>标志。使用<code>fcntl</code>，我们只需要知道打开文件的描述符，就可以修改描述符的属性。在讲解非阻塞管道时还会用到<code>fcntl</code>，因为对于管道，我们所知的只有其描述符。</p>
<h2 id="函数ioctl"><a href="#函数ioctl" class="headerlink" title="函数ioctl"></a>函数ioctl</h2><p><code>ioctl</code>函数一直是I/O操作的杂物箱。终端I/O是使用<code>ioctl</code>最多的地方<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span> <span class="comment">/* asp and Linux */</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> request, ...)</span></span>;</span><br><span class="line"><span class="comment">//返回值，若出错，返回-1，若成功，返回其他值</span></span><br></pre></td></tr></table></figure></p>
<p><code>ioctl</code>函数是Single UNIX Specification标准的一个扩展部分。UNIX系统实现用它进行很多杂项设备操作。有些实现甚至将它扩展到用于普通文件。</p>
<p>对于ISO C原型，它用省略号表示其余参数。但是，通常只有另外一个参数，它常常是指向一个变量或结构的指针。通常，还要求另外的设备专用头文件。例如，除POSIX.1所说明的基本操作之外，终端I/O的<code>ioctl</code>命令都需要头文件<code>&lt;termios.h&gt;</code>。</p>
<p>每个设备驱动程序可以定义它自己专用的一组<code>ioctl</code>命令，系统则为不同种类的设备提供通用的<code>ioctl</code>命令。图中总结了FreeBSD支持的通用<code>ioctl</code>命令的一些类别。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类别</th>
<th>常量名</th>
<th>头文件</th>
<th>ioctl数</th>
</tr>
</thead>
<tbody>
<tr>
<td>盘标号</td>
<td>DIOxxx</td>
<td><code>&lt;sys/disklabel.h&gt;</code></td>
<td>4</td>
</tr>
<tr>
<td>文件I/O</td>
<td>FIOxxx</td>
<td><code>&lt;sys/filio.h&gt;</code></td>
<td>14</td>
</tr>
<tr>
<td>磁带I/O</td>
<td>MTIOxxx</td>
<td><code>&lt;sys/mtio.h&gt;</code></td>
<td>11</td>
</tr>
<tr>
<td>套接字I/O</td>
<td>SIOxxx</td>
<td><code>&lt;sys/sockio.k&gt;</code></td>
<td>73</td>
</tr>
<tr>
<td>终端I/O</td>
<td>TIOxxx</td>
<td><code>&lt;aya/ttycom.h&gt;</code></td>
<td>43</td>
</tr>
</tbody>
</table>
</div>
<p>磁带操作使我们可以在磁带上写一个文件结束标志、倒带、越过指定个数的文件或记录等，对这些设备进行操作最容易的方法就是使用<code>ioctl</code>。</p>
<h2 id="dev-fd"><a href="#dev-fd" class="headerlink" title="/dev/fd"></a>/dev/fd</h2><p>较新的系统都提供名为<code>/dev/fd</code>的目录，其目录项是名为0、1、2等的文件。打开文件<code>/dev/fd/n</code>等效于复制操述符n(假定描述符n是打开的)。</p>
<p>在下列函数调用中；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/fd/0&quot;</span>, node);</span><br></pre></td></tr></table></figure></p>
<p>大多数系统忽略它所指定的mode，而另外一些系统则要求mode必须是所引用的文件(在这里是标准输入)初始打开时所使用的打开模式的一个子集。因为上面的打开等效于<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = <span class="built_in">dup</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>所以描述符<code>0</code>和<code>fd</code>共享同一文件表项。例如，若描述符0先前被打开为只读，那么我们也只能对fd进行读操作。即使系统忽略打开模式，而且下列调用是成功的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/fd/0&quot;</span>, O_RDWR);</span><br></pre></td></tr></table></figure></p>
<p>我们仍然不能对fd进行写操作。</p>
<p>Linux实现中的/dev/fd是个例外。它把文件描述符映射成指向底层物理文件的符号链接。例如，当打开<code>/dev/fd/0</code>时，事实，上正在打开与标准输入关联的文件，因此返回的新文件描述符的模式与<code>/dev/fd</code>文件描述符的模式其实并不相关。</p>
<p>我们也可以用<code>/dev/fd</code>作为路径名参数调用<code>creat</code>，这与调用<code>open</code>时用<code>O_CREAT</code>作为第2个参数作用相同。例如，若一个程序调用<code>creat</code>，并且路径名参数是<code>/dev/fd/1</code>，那么该程序仍能工作。</p>
<p>某些系统提供路径名<code>/dev/stdin</code>、<code>/dev/stdout</code>和<code>/dev/stderr</code>，这些等效于<code>/dev/fd/0</code>、<code>/dev/fd/1</code>和<code>/dev/fd/2</code>。<code>/dev/fd</code>文件主要由shell使用，它允许使用路径名作为调用参数的程序，能用处理其他路径名的相同方式处理标准输入和输出。例如，<code>cat(1)</code>命令对其命令行参数采取了一种特殊处理，它将单独的一个字符“-”解释为标准输入。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter file2 | <span class="built_in">cat</span> file1 - file3 | lpr</span><br></pre></td></tr></table></figure></p>
<p>首先<code>cat</code>读<code>file1</code>，按着读其标准输入(也就是<code>filter file2</code>命令的输出)，然后读<code>file3</code>，如果支持<code>/dev/fd</code>，则可以删除cat对“-”的特殊处理，于是我们就可键入下列命令行；<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter file2 | <span class="built_in">cat</span> file1 /dev/fd/0 file3 | lpr</span><br></pre></td></tr></table></figure></p>
<p>作为命令行参数的“-”特指标准输入或标准输出，这已由很多程序采用。但是这会带来一些问题，例如，如果用”-”指定第一个文件，那么看来就像指定了命令行的一个选项。<code>/dev/fd</code>则提高了文件名参数的一致性，也更加清晰。</p>
<h1 id="文件和目录-1"><a href="#文件和目录-1" class="headerlink" title="文件和目录"></a>文件和目录</h1><h2 id="函数stat、fstat、fstatat和lstat"><a href="#函数stat、fstat、fstatat和lstat" class="headerlink" title="函数stat、fstat、fstatat和lstat"></a>函数stat、fstat、fstatat和lstat</h2><p>本章主要讨论4个stat函数以及它们的返回信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *restrict pathmame, <span class="keyword">struct</span> stat *restrict buf)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *restrict pathmame, <span class="keyword">struct</span> stat *restrict buf)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fatatat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *restrict pathname, <span class="keyword">struct</span> stat *restrict buf, <span class="type">int</span> flag)</span></span>;</span><br><span class="line">所有<span class="number">4</span>个函数的返回值，若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-2</span></span><br></pre></td></tr></table></figure></p>
<p>一旦给出pathname，<code>stat</code>函数将返回与此命名文件有关的信息结构。<code>fstat</code>函数获得已在描述符<code>fd</code>上打开文件的有关信息。<code>lstat</code>函数类似于<code>stat</code>，但是当命名的文件是一个符号链接时，<code>lstat</code>返回该符号链接的有关信息，而不是由该符号链接引用的文件的信息。</p>
<p><code>fstatat</code>函数为一个相对于当前打开目录(由<code>fd</code>参数指向)的路径名返回文件统计信息。<code>flag</code>参数控制着是否跟随着一个符号链接。当<code>AT_SYMLINK_NOFOLLOW</code>标志被设置时，<code>fstatat</code>不会跟随符号链接，而是返回符号链接本身的信息。否则，在默认情况下，返同的是符号链接所指向的实际文件的信息。如果<code>fd</code>参数的值是<code>AT_FDCWD</code>，并且<code>pathname</code>参数是一个相对路径名，<code>fstatat</code>会计算相对于当前目录的pathname参数。如果pathname是一个绝对路径，后参数就会被忽略。这两种情况下，根据<code>flag</code>的取值，<code>fstatat</code>的作用就跟<code>stat</code>或<code>lstat</code>一样。</p>
<p>第2个参数<code>buf</code>是一个指针，它指向一个我们必须提供的结构。函数来填充由<code>buf</code>指向的结构。结构的实际定义可能随具体实现有所不同，但其基本形式是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span> &#123;</span><br><span class="line"><span class="type">mode_t</span>  st_mode;     <span class="comment">/* file type &amp; mode (permiosions) */</span></span><br><span class="line"><span class="type">ino_t</span>   st_ino;      <span class="comment">/* i-node number (serial number) */</span></span><br><span class="line"><span class="type">dev_t</span>   st_dev;      <span class="comment">/* device number (file system) */</span></span><br><span class="line"><span class="type">dev_t</span>   st_rdev;     <span class="comment">/* device nunber for special files */</span></span><br><span class="line"><span class="type">nlink_t</span> st_nlink;    <span class="comment">/* number of links */</span></span><br><span class="line"><span class="type">uid_t</span>   st_uid;      <span class="comment">/* user ID of owner */</span></span><br><span class="line"><span class="type">gid_t</span>   st_gid;      <span class="comment">/* group ID of owner */</span></span><br><span class="line"><span class="type">off_t</span>   st_sizes</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tinespec</span> st_atime; <span class="comment">/* time of last access */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span> st_mtime; <span class="comment">/* time of last modification */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tinespec</span> st_ctime; <span class="comment">/* time of last tille status change */</span></span><br><span class="line"><span class="type">blksize_t</span> st_blksizes     <span class="comment">/* best I/O block size */</span></span><br><span class="line"><span class="type">blkcnt_t</span>  st_blocks;      <span class="comment">/* number of disk blocks allocated */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>timespec</code>结构类型按照秒和纳秒定义了时间，至少包括下面两个字段：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> tv_sec;</span><br><span class="line"><span class="type">long</span>   tv_nsec;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>stat</code>函数最多的地方可能就是<code>ls -l</code>命令，用其可以获得有关一个文件的所有信息。</p>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>至此我们已经介绍了两种不同的文件类型：普通文件和目录。UNIX系统的大多数文件是普通文件或目录，但是也有另外一些文件类型。文件类型包括如下几种，</p>
<ul>
<li><strong>普通文件</strong>(regular file)。这是最常用的文件类型，这种文件包含了某种形式的数据。至于这种数据是文本还是二进制数据，对于UNIX内核而言并无区别。对普通文件内容的解释由处理该文件的应用程序进行。<ul>
<li>一个值得注意的例外是二进制可执行文件。为了执行程序，内被必须理解其格式。</li>
</ul>
</li>
<li><strong>目录文件</strong>(directory file)。这种文件包含了其他文件的名字以及指向与这些文件有关信息的指针。对一个目录文件具有读权限的任进程都可以读该目录的内容，但只有内核可以直接写目录文件。</li>
<li><strong>块特殊文件</strong>(block special file)。这种类型的文件提供对设备(如磁盘)带缓冲的访问，每次访问以固定长度为单位进行。</li>
<li><strong>字符特殊文件</strong>(character special fle)，这种类型的文件提供对设备不带缓冲的访问，每次访问长度可变。系统中的所有设备要么是字符特殊文件，要么是块特殊文件。</li>
<li><strong>FIFO</strong>。这种类型的文件用于进程间通信，有时也称为命名管道(named pipe)。</li>
<li><strong>套接字</strong>(socket)。这种类型的文件用于进程间的网络通信。套接字也可用于在一台宿主机上进程之间的非网络通信。</li>
<li><strong>符号链接</strong>(symbolic link)。这种类型的文件指向另一个文件。</li>
</ul>
<p>文件类型信息包含在<code>stat</code>结构的<code>st_mode</code>成员中。可以用表中的宏确定文件类型。这些宏的参数都是<code>stat</code>结构中的<code>st_mode</code>成员。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>宏</th>
<th>文件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S_ISREG()</code></td>
<td>管通文件</td>
</tr>
<tr>
<td><code>S_ISDIR()</code></td>
<td>目录文件</td>
</tr>
<tr>
<td><code>S_ISCHR()</code></td>
<td>字符特殊文件</td>
</tr>
<tr>
<td><code>S_ISBLK()</code></td>
<td>块特殊文件</td>
</tr>
<tr>
<td><code>S_ISFIFO()</code></td>
<td>管道或FIFO</td>
</tr>
<tr>
<td><code>S_ISLNK()</code></td>
<td>符号链接</td>
</tr>
<tr>
<td><code>S_ISSOCK()</code></td>
<td>套楼字</td>
</tr>
</tbody>
</table>
</div>
<p>POSIX.1允许实现将进程间通信(IPC)对象(如消息队列和信号量等)说明为文件。表中的宏可用来从<code>stat</code>结构中确定IPC对象的类型。这些宏与上表中的不同，它们的参数并非<code>st_mode</code>，而是指向<code>stat</code>结构的指针。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>宏</th>
<th>对象的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S_TYPEISMQ()</code></td>
<td>消息队列</td>
</tr>
<tr>
<td><code>S_TYPEISSEM()</code></td>
<td>信号量</td>
</tr>
<tr>
<td><code>S_TYPEISSHM()</code></td>
<td>共享存储对象</td>
</tr>
</tbody>
</table>
</div>
<p>程序取其命令行参数，然后针对每一个命令行参数打印其文件类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> buf;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i ++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: &quot;</span>, argv[i]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">lstat</span>(argv[i], &amp;buf) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err.<span class="built_in">ret</span>(<span class="string">&quot;lstat error&quot;</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">S_ISREG</span>(buf.st_mode))</span><br><span class="line">        ptr = <span class="string">&quot;regular&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">S_ISDIR</span>(buf.st_mode))</span><br><span class="line">        ptr = <span class="string">&quot;directory&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">S_ISCHR</span>(buf.st_mode))</span><br><span class="line">        ptr = <span class="string">&quot;chacacter special&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">S_ISBLK</span>(buf.st_mode))</span><br><span class="line">        ptr = <span class="string">&quot;block special&quot;</span>,</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">S_ISFIFO</span>(buf.st_mode))</span><br><span class="line">        ptr = <span class="string">&quot;fifo&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">S_ISLNK</span>(buf.st_mode))</span><br><span class="line">        ptr = <span class="string">&quot;symbolic link&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">S_ISSOCK</span>(buf.st_mode))</span><br><span class="line">        ptr = <span class="string">&quot;Socket&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    ptz = <span class="string">&quot;*** unknown mode ***&quot;</span>;</span><br><span class="line">    <span class="built_in">printl</span>(<span class="string">&quot;%s\n&quot;</span>, ptr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>早期的UNIX版本并不提供<code>S_ISxxx</code>宏，于是就需要将<code>st_mode</code>与屏蔽字<code>S_IFMT</code>进行逻辑“与”运算，然后与名为<code>S_IFxxx</code>的常量相比较。大多数系统在文件<code>&lt;sys/stat.h&gt;</code>中定义了此屏蔽字和相关的常量。如若查看此文件，则可找到<code>S_ISDIR</code>宏定义为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S_ISDIR (mode) (((mode) &amp; S_IFMT) == S_IFDIR)</span></span><br></pre></td></tr></table></figure></p>
<h2 id="设置用户ID和设置组ID"><a href="#设置用户ID和设置组ID" class="headerlink" title="设置用户ID和设置组ID"></a>设置用户ID和设置组ID</h2><p>与一个进程相关联的ID有6个或更多</p>
<ul>
<li>我们实际上是谁<ul>
<li>实际用户ID</li>
<li>实际组ID</li>
</ul>
</li>
<li>用于文件访问权限检查<ul>
<li>有效用户ID</li>
<li>有效组ID</li>
<li>附属组ID</li>
</ul>
</li>
<li><p>由exec通数保存</p>
<ul>
<li>保存的设置用户ID</li>
<li>保存的设置组ID</li>
</ul>
</li>
<li><p>实际用户ID和实际组ID标识我们究竟是谁。这两个字段在登录时取自口令文件中的登录项。通常，在一个登录会话期间这些值并不改变，但是超级用户进程有方法改变它们。</p>
</li>
<li>有效用户ID、有效组ID以及附属组ID决定了我们的文件访问权限。</li>
<li>保存的设置用户ID和保存的设置组ID在执行一个程序时包含了有效用户ID和有效组ID的副本。</li>
</ul>
<p>通常，有效用户ID等于实际用户ID，有效组ID等于实际组ID。每个文件有一个所有者和组所有者，所有者由<code>stat</code>结构中的<code>st_uid</code>指定，组所有者则由<code>st_gid</code>指定。</p>
<p>当执行一个程序文件时，进程的有效用户ID通常就是实际用户ID，有效组ID通常是实际组ID。但是可以在文件模式字(<code>st_mode</code>)中设置一个特殊标志，其含义是“当执行此文件时，将进程的有效用户ID设置为文件所有者的用户ID(<code>st_uid</code>)”。与此相类似，在文件模式字中可以设置另一位。它将执行此文件的进程的有效组ID设置为文件的组所有者ID(<code>st_gid</code>)。在文件模式字中的这两位被称为设置用户ID(set-user-ID)位和设置组ID(set-group-ID)位。</p>
<h2 id="文件访问权限"><a href="#文件访问权限" class="headerlink" title="文件访问权限"></a>文件访问权限</h2><p><code>st_mode</code>值也包含了对文件的访问权限位。当提及文件时，指的是前面所提到的任何类型的文件。所有文件类型(目录、字符特别文件等)都有访问权限(access permission)。每个文件有9个访问权限位，可将它们分成3类：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>st_mode屏蔽</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>S_IRUSR</td>
<td>用户读</td>
</tr>
<tr>
<td>S_IWUSR</td>
<td>用户写</td>
</tr>
<tr>
<td>S_IXUSR</td>
<td>用户执行</td>
</tr>
<tr>
<td>S_IRGRP</td>
<td>组读</td>
</tr>
<tr>
<td>S_IWGRP</td>
<td>组写</td>
</tr>
<tr>
<td>S_IXGRP</td>
<td>组执行</td>
</tr>
<tr>
<td>S_IROTH</td>
<td>其他读</td>
</tr>
<tr>
<td>S_IWOTH</td>
<td>其他写</td>
</tr>
<tr>
<td>S_IXOTH</td>
<td>其他执行</td>
</tr>
</tbody>
</table>
</div>
<p>在前3行中，术语用户指的是文件所有者(owner)。<code>chmod(1)</code>命令用于修改这9个权限位。该命令允许我们用u表示用户(所有者)，用g表示组，用o表示其他。</p>
<p>3类访问权限(即读、写及执行)以各种方式由不同的函数使用。我们将这些不同的使用方式汇总在下面。</p>
<ul>
<li>第一个规则是，我们用名字打开任一类型的文件时，对该名字中包含的每一个目录，包括它可能隐含的当前工作目录都应具有执行权限。这就是为什么对于目录其执行权限位常被称为搜索位的原因。<ul>
<li>例如，为了打开文件<code>/usr/include/stdio.h</code>，需要对目录<code>/</code>、<code>/usr</code>和<code>/usr/inciude</code>具有执行权限。然后，需要具有对文件本身的适当权限，这取决于以何种模式打开它。</li>
<li>如果当前目录是<code>/usr/include</code>，那么为了打开文件<code>stdio.h</code>，需要对当前目录有执行权限。这是隐含当前目录的一个示例，打开<code>stdio.h</code>文件与打开<code>./stdio.h</code>作用相同。</li>
<li>注意，对于目录的读权限和执行权限的意义是不相同的。读权限允许我们读目录，获得在该目录中所有文件名的列表。当一个目录是我们要访问文件的路径名的一个组成部分时，对该目录的执行权限使我们可通过该目录(也就是搜索该目录)，寻找一个特定的文件名</li>
</ul>
</li>
<li>对于一个文件的读权限决定了我们是否能够打开现有文件进行读操作。</li>
<li>对于一个文件的写权限决定了我们是否能够打开现有文件进行写操作。</li>
<li>为了在open函数中对一个文件指定<code>O_TRUNC</code>标志，必须对该文件具有写权限。</li>
<li>为了在一个目录中创建一个新文件，必须对该目录具有写权限和执行权限。</li>
<li>为了删除一个现有文件，必须对包含该文件的目录具有写权限和执行权限。对该文件本身则不需要有读、写权限。</li>
<li>如果用7个<code>exec</code>函数中的任何一个执行某个文件，都必须对该文件具有执行权限。该文件还必须是一个普通文件。</li>
</ul>
<p>进程每次打开、创建或删除一个文件时，内核就进行文件访问权限测试，而这种测试可能涉及文件的所有者(<code>st_uid</code>和<code>st_gid</code>)、进程的有效ID(有效用户ID和有效组ID)以及进程的附属组ID(若支持的话)。两个所有者ID是文件的性质，而两个有效ID和附属组ID则是进程的性质。内核进行的测试具体如下。</p>
<ol>
<li>若进程的有效用户D是0(超级用户)，则允许访问。这给予了超级用户对整个文件系统进行处理的最充分的自由。</li>
<li>若进程的有效用户ID等于文件的所有者ID(也就是进程拥有此文件)，那么如果所有者适当的访问权限位被设置，则允许访问；否则拒绝访问。适当的访问权限位指的是，若进程为读而打开该文件，则用户读位应为1；若进程为写而打开该文件，则用户写位应为1；若进程将执行该文件，则用户执行位应为1.</li>
<li>若进程的有效组ID或进程的附属组ID之一等于文件的组D，那么如果组适当的访问权限位被设置，则允许访问：否则拒绝访问，</li>
<li>若其他用户适当的访问权限位被设置，则允许访问：否则拒绝访问。</li>
</ol>
<p>按顺序执行这4步。注意，如果进程拥有此文件(第2步)，则按用户访问权限批准或拒绝该进程对文件的访问——不查看组访问权限。类似地，若进程并不拥有该文件。但进程属于某个适当的组，则按组访问权限批准或拒绝该进程对文件的访问——不查看其他用户的访问权限。</p>
<h2 id="新文件和目录的所有权"><a href="#新文件和目录的所有权" class="headerlink" title="新文件和目录的所有权"></a>新文件和目录的所有权</h2><p>新文件的用户ID设置为进程的有效用户ID。关于组ID，POSIX.1允许实现选择下列之一作为新文件的组ID。</p>
<ol>
<li>新文件的组D可以是进程的有效组ID.</li>
<li>新文件的组ID可以是它所在目录的组ID.</li>
</ol>
<p>使用POSIX.I所允许的第二个选项(继承目录的组ID)使得在某个目录下创建的文件和目录都具有该目录的组ID。于是文件和目录的组所有权从该点向下传递。</p>
<h2 id="函数access和faccessat"><a href="#函数access和faccessat" class="headerlink" title="函数access和faccessat"></a>函数access和faccessat</h2><p>当用open函数打开一个文件时，内核以进程的有效用户ID和有效组ID为基础执行其访问权限测试。有时，进程也希望按其实际用户ID和实际组ID来测试其访问能力。即使一个进程可能已经通过设置用户ID以超级用户权限运行，它仍可能想验证其实际用户能否访问一个给定的文件。<code>access</code>和<code>faccessat</code>函数是按实际用户ID和实际组ID进行访问权限测试的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathmame, <span class="type">int</span> mode)</span>:</span></span><br><span class="line"><span class="function">int faccessat(int fd, const char *pathname, int mode, int flag);</span></span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>其中，如果测试文件是否已经存在，<code>mode</code>就为<code>F_OK</code>；否则<code>mode</code>是表中所列常量的按位或。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>mode</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>R_OK</td>
<td>测试读权限</td>
</tr>
<tr>
<td>W_OK</td>
<td>测试写权限</td>
</tr>
<tr>
<td>X_OK</td>
<td>测试执行权限</td>
</tr>
</tbody>
</table>
</div>
<p><code>faccessat</code>函数与<code>access</code>函数在下面两种情况下是相同的：一种是<code>pathname</code>参数为绝对路径，另一种是<code>fd</code>参数取值为<code>AT_FDCWD</code>而<code>pathname</code>参数为相对路径。否则，<code>faccessat</code>计算相对于打开目录(由fd参数指向)的<code>pathname</code>。</p>
<p><code>flag</code>参数可以用于改变<code>faccessat</code>的行为，如果<code>flag</code>设置为<code>AT_EACCESS</code>，访问检查用的是调用进程的有效用户ID和有效组ID，而不是实际用户ID和实际组ID。</p>
<p>下文显示了<code>access</code>函数的使用方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">err_quit</span>(<span class="string">&quot;usage: a.out &lt;pathname&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">access</span>(argv[<span class="number">1</span>], R_OK) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_ret</span> (<span class="string">&quot;access error for %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read access OK\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_ret</span>(<span class="string">&quot;open error for %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open for reading OK\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在本例中，尽管open函数能打开文件，但通过设置用户ID程序可以确定实际用户不能正常读指定的文件。</p>
<h2 id="函数umask"><a href="#函数umask" class="headerlink" title="函数umask"></a>函数umask</h2><p><code>umask</code>函数为进程设置文件模式创建屏蔽字，并返回之前的值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">mode_t</span> <span class="title">umask</span> <span class="params">(<span class="type">mode_t</span> cmask)</span></span>;</span><br><span class="line"><span class="comment">// 返回值。之前的文件模式创建屏蔽字</span></span><br></pre></td></tr></table></figure></p>
<p>其中，参数<code>cmask</code>是之前列出的9个常量(<code>S_IRUSR</code>、<code>S_IWUSR</code>等)中的若干个按位“或”构成的。</p>
<p>在进程创建一个新文件或新目录时，就一定会使用文件模式创建屏蔽字。在文件模式创建屏蔽字中为1的位，在文件mode中的相应位一定被关闭。</p>
<p>程序创建了两个文件，创建第一个时，umask值为0，创建第二个时，umask值禁止所有组和其他用户的访问权限<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fenti.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RWRWRW(S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">umask</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">creat</span>(<span class="string">&quot;foo&quot;</span>, RWRWRW) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;creat error for foo&quot;</span>);</span><br><span class="line">    <span class="built_in">umask</span>(S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">creat</span>(<span class="string">&quot;bar&quot;</span>, RWRWRW) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_ays</span>(<span class="string">&quot;creat error for bar&quot;</span>);</span><br><span class="line">    <span class="built_in">exif</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>若运行此程序可得如下结果，从中可见访问权限位是如何设置的。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">umask</span>         ;先打印当前文件模式创建屏蔽字</span><br><span class="line">002</span><br><span class="line">$ ./a.out</span><br><span class="line">$ <span class="built_in">ls</span> -l foo bar</span><br><span class="line">-rw------- 1 sar 0 Dec 7 21:20 bar</span><br><span class="line">-rw-rw-rw- 1 sar 0 Dec 7 21:20 foo</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">umask</span>     ;观察文件模式创建屏蔽字是否更改</span><br><span class="line">002</span><br></pre></td></tr></table></figure></p>
<p>UNIX系统的大多数用户从不处理他们的umask值。通常在登录时，由shell的启动文件设置一次，然后，再不改变。尽管如此，当编写创建新文件的程序时，如果我们想确保指定的访问权限位已经激活，那么必须在进程运行时修改umask值。例如，如果我们想确保任何用户都能读文件，则应将umask设置为0。否则，当我们的进程运行时，有效的umask值可能关闭该权限位。</p>
<p>用户可以设置umask值以控制他们所创建文件的默认权限。该值表示成八进制数，一位代表一种要屏蔽的权限。设置了相应位后，它所对应的权限就会被拒绝。常用的几种umask值是002、022和027。002阻止其他用户写入你的文件，022阻止同组成员和其他用户写入你的文件，027阻止同组成员写你的文件以及其他用户读、写或执行你的文件。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>屏蔽位</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0400</td>
<td>用户读</td>
</tr>
<tr>
<td>0200</td>
<td>用户写</td>
</tr>
<tr>
<td>0100</td>
<td>用户执行</td>
</tr>
<tr>
<td>0040</td>
<td>组读</td>
</tr>
<tr>
<td>0020</td>
<td>组写</td>
</tr>
<tr>
<td>0010</td>
<td>组执行</td>
</tr>
<tr>
<td>0004</td>
<td>其他读</td>
</tr>
<tr>
<td>0002</td>
<td>其他写</td>
</tr>
<tr>
<td>0001</td>
<td>其他执行</td>
</tr>
</tbody>
</table>
</div>
<h2 id="函数chmod、fchmod和fchmodat"><a href="#函数chmod、fchmod和fchmodat" class="headerlink" title="函数chmod、fchmod和fchmodat"></a>函数chmod、fchmod和fchmodat</h2><p><code>chmod</code>、<code>fchmod</code>和<code>fchmodat</code>这3个函数使我们可以更改现有文件的访问权限。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ays/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fchmod</span><span class="params">(<span class="type">int</span> fd, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fchmodat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode, <span class="type">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 3个函数返回值：若成功，返回0；若出错。返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>chmod</code>函数在指定的文件上进行操作，而<code>fchmod</code>函数则对已打开的文件进行操作。<code>fchmodat</code>函数与<code>chmod</code>函数在下面两种情况下是相同的：一种是<code>pathname</code>参数为绝对路径，另一种是<code>fd</code>参数取值为<code>AT_FDCWD</code>而<code>pathname</code>参数为相对路径。否则，<code>fchmodat</code>计算相对于打开目录(由<code>fd</code>参数指向)的<code>pathname</code>。<code>flag</code>参数可以用于改变<code>fchmodat</code>的行为，当设置了<code>AT_SYMLINK_NOFOLLOW</code>标志时，<code>fchmodat</code>并不会跟随符号链接。</p>
<p>为了改变一个文件的权限位，进程的有效用户D必须等于文件的所有者ID，或者该进程必须具有超级用户权限。参数mode是常量的按位或。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>mode</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>S_ISUID</td>
<td>执行时设置用户D</td>
</tr>
<tr>
<td>S_ISGID</td>
<td>执行时设置组D</td>
</tr>
<tr>
<td>S_ISVTX</td>
<td>保存正文(粘着位)</td>
</tr>
<tr>
<td>S_IRWXU</td>
<td>用户(所有者)读、写和执行</td>
</tr>
<tr>
<td>S_IRUSR</td>
<td>用户(所有者)读</td>
</tr>
<tr>
<td>S_IWUSR</td>
<td>用户(所有者)写</td>
</tr>
<tr>
<td>S_IXUSR</td>
<td>用户(所有者)执行</td>
</tr>
<tr>
<td>S_IRWXG</td>
<td>组读、写和执行</td>
</tr>
<tr>
<td>S_IRGRP</td>
<td>组读</td>
</tr>
<tr>
<td>S_IWGRP</td>
<td>组写</td>
</tr>
<tr>
<td>S_IXGRP</td>
<td>组执行</td>
</tr>
<tr>
<td>S_IRWXO</td>
<td>其他读、写和执行</td>
</tr>
<tr>
<td>S_IROTH</td>
<td>其他读</td>
</tr>
<tr>
<td>S_IWOTH</td>
<td>其他写</td>
</tr>
<tr>
<td>S_IXOTH</td>
<td>其他执行</td>
</tr>
</tbody>
</table>
</div>
<p>注意，有9项是取自之前的9个文件访问权限位。我们另外加了6个，它们是两个设置ID常量(<code>S_ISUID</code>和<code>S_ISGID</code>)、保存正文常量(<code>S_ISVTX</code>)以及3个组合常量(<code>S_IRWXU</code>、<code>S_IRWXG</code>和<code>S_IRWXO</code>)。</p>
<p>程序修改了这两个文件的模式，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> statbuf;</span><br><span class="line">    <span class="comment">/* turn on set-group-ID and turn off group-execute */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stat</span>(<span class="string">&quot;foo&quot;</span>, &amp;statbuf) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_ays</span>(<span class="string">&quot;stat error for foo&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">chmod</span>(<span class="string">&quot;foo&quot;</span>, (statbuf.st_mode &amp; ~S_IXGRP) | S_ISGID) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span> (<span class="string">&quot;chmod error for foo&quot;</span>);</span><br><span class="line">    <span class="comment">/* set absolute mode to &quot;rw-r--r--&quot; */</span> </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">chmod</span>(<span class="string">&quot;bar&quot;</span>, S_IRUSR | S_IWUSR I S_IRGRP | S_IROTH) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">exr_sys</span>(<span class="string">&quot;chmod error for bar&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>在运行程序后，这两个文件的最后状态是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l foo bax</span><br><span class="line">-rw-r--r-- 1 sar    0 Dec 7 21:20  bar</span><br><span class="line">-rw-rwSrw- 1 sar    0 Dec 7 21:20  foo</span><br></pre></td></tr></table></figure></p>
<p>在本例中，不管文件bar的当前权限位如何，我们都将其权限设置为一个绝对值。对文件foo，我们相对于其当前状态设置权限。为此，先调用<code>stat</code>获得其当前权限，然后修改它。我们显式地打开了设置组ID位、关闭了组执行位。</p>
<p><code>chmod</code>函数在下列条件下自动清除两个权限位。</p>
<ul>
<li>Solaris等系统对用于普通文件的粘着位赋予了特殊含义，在这些系统上如果我们试图设置普通文件的粘着位(<code>S_ISVTX</code>)，且又没有超级用户权限，那么<code>mode</code>中的粘着位自动被关闭。这意味着只有超级用户才能设置普通文件的粘着位。这样做的理由是防止恶意用户设置粘着位，由此影响系统性能。</li>
<li>新创建文件的组ID可能不是谓用进程所属的组。特别地，如果新文件的组ID不等于进程的有效组ID或者进程附属组ID中的一个，而且进程没有超级用户权限，那么设置组ID位会被自动被关闭。这就防止了用户创建一个设置组ID文件，而该文件是由并非该用户所属的组拥有的。</li>
</ul>
<h2 id="粘着位"><a href="#粘着位" class="headerlink" title="粘着位"></a>粘着位</h2><p><code>S_ISVTX</code>如果一个可执行程序文件的这一位被设置了，那么当该程序第一次被执行，在其终止时，程序正文部分的一个副本仍被保存在交换区(程序的正文部分是机器指令)。</p>
<p>这使得下次执行该程序时能较快地将其装载入内存。其原因是：通常的UNIX文件系统中，文件的各数据块很可能是随机存放的，相比较而言，交换区是被作为一个连续文件来处理的。对于在交换区中可以同时存放的设置了粘着位的文件数是有限制的，以免过多占用交换区空间，但无论如何这是一个有用的技术。因为在系统再次自举前，文件的正文部分总是在交换区中，这正是名字中“粘着”的由来。后来的UNIX版本称它为<strong>保存正文位</strong>(saved-textbit)，因此也就有了常量<code>S_ISVTX</code>。</p>
<p>如果对一个目录设置了粘着位，只有对该目录具有写权限的用户并且满足下列条件之一，才能删除或重命名该目录下的文件：</p>
<ul>
<li>拥有此文件；</li>
<li>拥有此目录：</li>
<li>是超级用户。</li>
</ul>
<p>目录<code>/tmp</code>和<code>/var/tmp</code>是设置粘着位的典型候选者，任何用户都可在这两个目录中创建文件。任一用户(用户、组和其他)对这两个目录的权限通常都是读、写和执行。但是用户不应能删除或重命名属于其他人的文件，为此在这两个目录的文件模式中都设置了粘着位。</p>
<h2 id="函数chown、fchown、fchownat和1chown"><a href="#函数chown、fchown、fchownat和1chown" class="headerlink" title="函数chown、fchown、fchownat和1chown"></a>函数chown、fchown、fchownat和1chown</h2><p>下面几个<code>chown</code>函数可用于更改文件的用户ID和组ID。如果两个参数<code>owner</code>或<code>group</code>中的任意一个是-1，则对应的ID不变。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathnome, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fchown</span><span class="params">(<span class="type">int</span> fd, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fchownat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *pathrame, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group, <span class="type">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lchown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pariname, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="comment">// 4个函数的返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>除了所引用的文件是符号链接以外，这4个函数的操作类似。在符号链接情况下，<code>lchown</code>和<code>fchownat</code>(设置了<code>AT_SYMLINK_NOFOLLOW</code>标志)更改符号链接本身的所有者，而不是该符号链接所指向的文件的所有者。</p>
<p><code>fchown</code>函数改变<code>fd</code>参数指向的打开文件的所有者，既然它在一个已打开的文件上操作，就不能用于改变符号链接的所有者，<code>fchownat</code>函数与<code>chown</code>或者<code>lchown</code>函数在下面两种情况下是相同的；一种是<code>pathname</code>参数为绝对路径，另一种是<code>fd</code>参数取值为<code>AT_PDCND</code>而<code>pathname</code>参数为相对路径。在这两种情况下，如果<code>flag</code>参数中设置了<code>AT_SYMLINK_NOFOLLOW</code>标志，<code>fchownat</code>与<code>lchown</code>行为相同，如果flag参数中清除了<code>AT_SYMLINK_NOFOLLOW</code>标志，则<code>fchownat</code>与<code>chown</code>行为相同。如果<code>fd</code>参数设置为打开目录的文件描述符，并且<code>pathname</code>参数是一个相对路径名，<code>fchownat</code>函数计算相对于打开目录的pathname。</p>
<p><code>_POSIX_CHOWN_RESTRICTED</code>常量可选地定义在头文件<code>&lt;unistd.h&gt;</code>中，而且总是可以用<code>pathconf</code>或<code>fpathconf</code>函数进行查询。此选项还与所引用的文件有关一可在每个文件系统基础上，使该选项起作用或不起作用。在下文中，如提及“若<code>_POSIX_CHOWN_RESTRICTED</code>生效”，则表示“这适用于我们正在淡及的文件”，而不管该实际常量是否在头文件中定义。</p>
<p>若<code>_POSIX_CHOWN_RESTRICTED</code>对指定的文件生效，则</p>
<ol>
<li>只有超级用户进程能更改该文件的用户ID:</li>
<li>如果进程拥有此文件(其有效用户ID等于该文件的用户ID)，参数owner等于-1或文件的用户ID，并且参数group等于进程的有效组ID成进程的附属组ID之一，那么一个非超级用户进程可以更改该文件的组ID</li>
</ol>
<p>这意味着，当<code>_POSIX_CHOWN_RESTRICTED</code>有效时，不能更改其他用户文件的用户ID。你可以更改你所拥用的文件的组ID，但只能改到你所属的组。如果这些函数由非超级用户进程调用，则在成功返回时，该文件的设置用户ID位和设置组ID位都被清除。</p>
<h2 id="文件长度"><a href="#文件长度" class="headerlink" title="文件长度"></a>文件长度</h2><p><code>stat</code>结构成员<code>st_size</code>表示以字节为单位的文件的长度。此字段只对普通文件、目录文件和符号链接有意义。</p>
<p>对于普通文件，其文件长度可以是0，在开始读这种文件时，将得到文件结束(end-of-file)指示。对于目录，文件长度通常是一个数(如16或512)的整倍数。</p>
<p>对于符号链接，文件长度是在文件名中的实际字节数。例如，在下面的例子中，文件长度7就是路径名<code>usr/lib</code>的长度：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx 1 root  7 Sep 25 07:14 lib -&gt; usr/1ib</span><br></pre></td></tr></table></figure></p>
<p>(注意，因为符号链接文件长度总是由<code>st_size</code>指示，所以它并不包含通常C语言用作名字结尾的null字节。)</p>
<p>现今，大多数现代的UNIX系统提供字段<code>st_blksize</code>和<code>st_blocks</code>。其中，第一个是对文件I/O较合适的块长度，第二个是所分配的实际512字节块块数。为了提高效率，标准I/O库也试图一次读、写<code>st_blksize</code>个字节。</p>
<h3 id="文件中的空洞"><a href="#文件中的空洞" class="headerlink" title="文件中的空洞"></a>文件中的空洞</h3><p>我们提及普通文件可以包含空洞。空洞是由所设置的偏移量超过文件尾端，并写入了某些数据后造成的。作为一个例子，考虑下列情况：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l core</span><br><span class="line">-rw-r--r-- 8483248 Nov 18 12:18 core</span><br><span class="line">$ <span class="built_in">du</span> -s core </span><br><span class="line">272 core</span><br></pre></td></tr></table></figure></p>
<p>文件core的长度稍稍超过8MB，可是du命令报告该文件所使用的磁盘空间总量是272个512字节块(即139264字节)。很明显，此文件中有很多空洞。</p>
<p>对于没有写过的字节位置，read函数读到的字节是0。如果执行下面的命令，可以看出正常的I/O操作读整个文件长度：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">wc</span> -c core</span><br><span class="line">8483248 core</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>带-c选项的wc(l)命令计算文件中的字符数(字节)。</p>
</blockquote>
<p>如果使用实用程序(如cat(1)复制这个文件，那么所有这些空洞都会被填满，其中所有实际数据字节皆填写为0。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> core &gt; core.copy</span><br><span class="line">$ <span class="built_in">ls</span> -l oore*</span><br><span class="line">-rw-r--r-- 1 sar 8483248 Nov 18 12:18 core</span><br><span class="line">-rw-rw-r-- 1 sar 8483248 Nov 18 12:27 core.copy</span><br><span class="line">$ <span class="built_in">du</span> -s core*</span><br><span class="line">272     core</span><br><span class="line">16592   core.copy</span><br></pre></td></tr></table></figure></p>
<p>从中可见，新文件所用的实际字节数是8495 104(512 x 16592)。此长度与<code>ls</code>命令报告的长度不同，其原因是，文件系统使用了若干块以存放指向实际数据块的各个指针。</p>
<h2 id="文件截断"><a href="#文件截断" class="headerlink" title="文件截断"></a>文件截断</h2><p>有时我们需要在文件尾端处截去一些数据以缩短文件。将一个文件的长度截断为0是一个特例，在打开文件时使用<code>O_TRUNC</code>标志可以做到这一点。为了截断文件可以调用函数<code>truncate</code>和<code>ftruncate</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *puthoume, <span class="type">ott_t</span> lempth)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ftruncate</span><span class="params">(<span class="type">int</span> fd, off_c length)</span> i</span></span><br><span class="line"><span class="function">两个函数的返回值，若成功，返回0；若出错。返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>这两个函数将一个现有文件长度裁断为length。如果该文件以前的长度大于length，则超过length以外的数据就不再能访问。如果以前的长度小于length，文件长度将增加，在以前的文件尾端和新的文件尾端之间的数据将读作0(也就是可能在文件中创建了一个空洞)。</p>
<h2 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h2><p>目前，正在使用的UNIX文件系统有多种实现。例如. Solaris支持多种不同类型的磁盘文件系统：传统的基于BSD的UNIX文件系统(称为UFS)，读、写DOS格式软盘的文件系统(称为PCFS)，以及读CD的文件系统(称为HSFS)。UFS是以Berkeiey快速文件系统为基础的。</p>
<p>我们可以把一个磁盘分成一个或多个分区。每个分区可以包含一个文件系统，i节点是固定长度的记录项，它包含有关文件的大部分信息。<br><img src="/img/20210516123303.png" alt=""></p>
<p>如果更仔细地观察一个柱面组的i节点和数据块部分，则可以看到下图中所示的情况。</p>
<p>在图中有两个目录项指向同一个i节点。每个i节点中都有一个链接计数，其值是指向该i节点的目录项数。只有当链接计数减少至0时，才可删除该文件。这也是为什么删除一个目录项的函数被称之为unlink而不是delete的原因。在<code>stat</code>结构中，链接计数包含在<code>st_nlink</code>成员中，其基本系统数据类型是<code>nlink_t</code>。这种链接类型称为硬链接。<br><img src="/img/20210516231147.png" alt=""></p>
<p>另外一种链接类型称为符号链接(symbolic link)。符号链接文件的实际内容(在数据块中)包含了该符号链接所指向的文件的名字。在下面的例子中，目录项中的文件名是3个字符的字符串lib，而在该文件中包含了7个字节的数据<code>usr/lib</code>:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx l root      7 sep 25 07:14 lib -&gt; /urs/lib</span><br></pre></td></tr></table></figure></p>
<p>该i节点中的文件类型是<code>S_IFLNK</code>，于是系统知道这是一个符号链接。</p>
<p>i节点包含了文件有关的所有信息，文件类型、文件访问权限位、文件长度和指向文件数据块的指针等。<code>stat</code>结构中的大多数信息都取自1节点。只有两项重要数据存放在目录项中：文件名和i节点编号。i节点编号的数据类型是<code>ino_t</code>。</p>
<p>因为目录项中的节点编号指向同一文件系统中的相应节点，一个目录项不能指向另一个文件系统的i节点。</p>
<p>当在不更换文件系统的情况下为一个文件重命名时，该文件的实际内容并未移动，只需构造一个指向现有i节点的新目录项，并删除老的目录项。链接计数不会改变。例如，为将文件<code>/usr/lib/foo</code>重命名为<code>/usr/foo</code>，如果目录<code>/usr/lib</code>和<code>/usr</code>在同一文件系统中，则文件foo的内容无需移动。</p>
<p>假定我们在工作目录中构造了一个新目录：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> testdir</span><br></pre></td></tr></table></figure></p>
<p>下图显示了其结果。注意，该图显式地显示了<code>.</code>和<code>..</code>目录项。编号为2549的i节点，其类型字段表示它是一个目录，链接计数为2。任何一个叶目录(不包含任何其他目录的目录)的链接计数总是2。数值2来自于命名该目录(testdir)的目录项以及在该目录中的<code>.</code>项。</p>
<p>编号为1267的i节点，其类型字段表示它是一个目录，链接计数大于或等于3。它大于或等于3的原因是，至少有3个目录项指向它一个是命名它的目录项，第二个是在该目录中的<code>.</code>项，第三个是在其子目录testdir中的<code>..</code>项。注意，在父目录中的每一个子目录都使该父目录的链接计数增加1。<br><img src="/img/20210516231950.png" alt=""></p>
<h2 id="函数1ink、linkat、unlink、unlinkat和remove"><a href="#函数1ink、linkat、unlink、unlinkat和remove" class="headerlink" title="函数1ink、linkat、unlink、unlinkat和remove"></a>函数1ink、linkat、unlink、unlinkat和remove</h2><p>如上节所述。任何一个文件可以有多个目录项指向其i节点。创建一个指向现有文件的链接的方法是使用<code>link</code>函数或<code>linkat</code>函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *existingpath, <span class="type">const</span> chaz *newpath)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">linkat</span><span class="params">(<span class="type">int</span> efd, <span class="type">const</span> <span class="type">char</span> *existingpash, <span class="type">int</span> nfd, <span class="type">const</span> <span class="type">char</span> *newpath, <span class="type">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值。若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>这两个函数创建一个新目录项newpath，它引用现有文件existingpath。如果newpath已经存在，则返回出错。只创建newpath中的最后一个分量，路径中的其他部分应当已经存在。</p>
<p>对于<code>linkat</code>函数，现有文件是通过efd和existingpath参数指定的，新的路径名是通过nfd和newpath参数指定的。默认情况下，如果两个路径名中的任一个是相对路径，那么它需要通过相对于对应的文件描述符进行计算。如果两个文件描述符中的任一个设置为<code>AT_FDCWD</code>，那么相应的路径名(如果它是相对路径)就通过相对于当前目录进行计算。如果任一路径名是绝对路径，相应的文件描述符参数就会被忽略</p>
<p>当现有文件是符号链接时，由flag参数来控制<code>linkat</code>函数是创建指向现有符号链接的链接还是创建指向现有符号链接所指向的文件的链接。如果在flag参数中设置了<code>AT_SYMLINK_FOLLOW</code>标志，就创建指向符号链接目标的链接。如果这个标志被清除了，则创建一个指向符号链接本身的链接。</p>
<p>创建新目录项和增加链接计数应当是一个原子操作。虽然POSIX.1允许实现支持跨越文件系统的链接，但是大多数实现要求现有的和新建的两个路径名在同一个文件系统中。如果实现支持创建指向一个目录的硬链接，那么也仅限于超级用户才可以这样做。其理由是这样做可能在文件系统中形成循环，大多数处理文件系统的实用程序都不能处理这种情况。因此，很多文件系统实现不允许对于目录的硬链接</p>
<p>为了剩除一个现有的目录项，可以调用unlink函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">unlink</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">unlinkat</span> <span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *pathnome, <span class="type">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值。若成功。返回0，若出错。返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>这两个函数删除目录项，并将由pathname所引用文件的链接计数减1。如果对该文件还有其他链接，则仍可通过其他链接访问该文件的数据。如果出错，则不对该文件做任何更改。我们在前面已经提及，为了解除对文件的链接，必须对包含该目录项的目录具有写和执行权限。如果对该目录设置了粘着位，则对该目录必须具有写权限，并且具备下面三个条件之一：</p>
<ul>
<li>拥有该文件：</li>
<li>拥有该目录：</li>
<li>具有超级用户权限。</li>
</ul>
<p>只有当链接计数达到0时，该文件的内容才可被删除。另一个条件也会阻止删除文件的内容——只要有进程打开了该文件，其内容也不能剩除。关闭一个文件时，内核首先检查打开该文件的进程个数：如果这个计数达到0，内核再去检查其链接计数：如果计数也是0，那么就删除该文件的内容。</p>
<p>如果pathname参数是相对路径名，那么unlinkat函数计算相对于由fd文件描述符参数代表的目录的路径名。如果fd参数设置为<code>AT_FDCWD</code>，那么通过相对于调用进程的当前工作目录来计算路径名。如果pathname参数是绝对路径名，那么fd参数被忽略。</p>
<p>flag参数给出了一种方法，使调用进程可以改变<code>unlinkat</code>函数的默认行为，当<code>AT_REMOVEDIR</code>标志被设置时，<code>unlinkat</code>函数可以类似于rmdir一样删除目录。如果这个标志被清除，<code>unlinkat</code>与<code>unlink</code>执行同样的操作。</p>
<p>程序打开一个文件，然后解除它的链接。执行该程序的进程然后睡眠15秒，接着就终止<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcnt1.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (open(<span class="string">&quot;tempfile&quot;</span>, O_RDWR) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (unlink(<span class="string">&quot;tempfile&quot;</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            err_sys (<span class="string">&quot;unlink error&quot;</span>);</span><br><span class="line">    printt(<span class="string">&quot;flle unlinked\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">15</span>);</span><br><span class="line">    printt(<span class="string">&quot;done\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>运行该程序，其结果是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l tempfile   <span class="comment">#查看文件大小</span></span><br><span class="line">-rw-r-----  1 sar  413265408 Jan 21 07:14 tempfile</span><br><span class="line">$ <span class="built_in">df</span> / home        <span class="comment">#检查可用磁盘空间</span></span><br><span class="line">Filesystem lK-blocks    Used Avallable Use% Mounted on</span><br><span class="line">/dev/hda4   11021440 1956332   9065108 18%  /home</span><br><span class="line">$ ./a.out &amp;        <span class="comment">#在后台运行程序</span></span><br><span class="line">1364               <span class="comment">#shell打印其进程ID</span></span><br><span class="line">$ file unlinked    <span class="comment">#解除文件链接</span></span><br><span class="line"><span class="built_in">ls</span> -l tempfile     <span class="comment">#观察文件是否仍然存在</span></span><br><span class="line"><span class="built_in">ls</span>: tempfile: No such tile or directory    <span class="comment">#目录项已剩除</span></span><br><span class="line">$ <span class="built_in">df</span> /home         <span class="comment">#检查可用磁盘空间有无变化</span></span><br><span class="line">Filesystem lK-blocks    Used Available Use% Mounted on</span><br><span class="line">/dev/hda4   11021440 1956332  9065108 18%    /home</span><br><span class="line">$ <span class="keyword">done</span>             <span class="comment">#程序执行结束，关闭所有打开文件</span></span><br><span class="line"><span class="built_in">df</span> /home           <span class="comment">#现在，应当有更多可用磁盘空间</span></span><br><span class="line">Filesysten lK-blocks    Used Available Use% mounted on</span><br><span class="line">/dev/hda4   11021440 1552352   9469088 15% /home</span><br><span class="line"><span class="comment">#现在，394.1MB磁盘空间可用</span></span><br></pre></td></tr></table></figure></p>
<p>unlink的这种特性经常被程序用来确保即使是在程序崩溃时，它所创建的临时文件也不会遭留下来。进程用open或creat创建一个文件，然后立即调用unlink，因为该文件仍旧是打开的，所以不会将其内容删除，只有当进程关闭该文件或终止时(在这种情况下，内核关闭该进程所打开的全部文件)，该文件的内容才被剥除，如果pathname是符号链接，那么uniink删除该符号链接，而不是删除由该链接所引用的文件。给出符号链接名的情况下，没有一个函数能剩除由该链接所引用的文件。</p>
<p>如果文件系统支持的话，超级用户可以调用<code>unlink</code>，其参数pathname指定一个目录，但是通常应当使用rmdir函数，而不使用unlink这种方式。</p>
<p>我们也可以用<code>remove</code>函数解除对一个文件或目录的链接。对于文件，<code>remove</code>的功能与<code>unlink</code>相同。对于目录，<code>remove</code>的功能与<code>rmdir</code>相同。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">remove</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>ISO C指定<code>remove</code>函数删除一个文件，这更改了UNIX历来使用的名字<code>unlink</code>，其原因是实现C标准的大多数察UNIX系统并不支持文件链接；</p>
<h2 id="函数rename和renameat"><a href="#函数rename和renameat" class="headerlink" title="函数rename和renameat"></a>函数rename和renameat</h2><p>文件或目录可以用rename函数或者renameat函数进行重命名。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rename</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *oldname, <span class="type">const</span> <span class="type">char</span> *newname)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">renameat</span> <span class="params">(<span class="type">int</span> oldfd, <span class="type">const</span> <span class="type">char</span> *oldname, <span class="type">int</span> newfd, <span class="type">const</span> <span class="type">char</span> *newname)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值。若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>根据oldname是指文件、目录还是符号链接，有几种情况需要加以说明。我们也必须说明如果newname已经存在时将会发生什么。</p>
<ol>
<li>如果oldname指的是一个文件而不是目录，那么为该文件或符号链接重命名。在这种情况下，如果newname已存在，则它不能引用一个目录。如果newname已存在，而且不是一个目录，则先将该目录项删除然后将oldname重命名为newname。对包含oldname的目录以及包含newname的目录，调用进程必须具有写权限，因为将更改这两个目录。</li>
<li>如若oldname指的是一个目录，那么为该目录重命名。如果newname已存在，则它必须引用一个目录，而且该目录应当是空目录。如果newname存在(而且是一个空目录)，则先将其剩除，然后将oldname重命名为newname。另外，当为一个目录重命名时，newname不能包含oldname作为其路径前缀。例如，不能将<code>/usr/foo</code>重命名为<code>/usr/foo/testdir</code>，因为旧名字(<code>/usr/foo</code>)是新名字的路径前缀，因而不能将其删除。</li>
<li>如着oldname成newname引用符号链接，则处理的是符号链接本身，而不是它所引用的文件。</li>
<li>不能对<code>.</code>和<code>..</code>重命名。更确切地说， <code>.</code>和<code>..</code>都不能出现在oldname和newname的最后部分。</li>
<li>作为一个特例，如果oldname和newname引用同一文件，则函数不做任何更改而成功返回。</li>
</ol>
<p>如若newname已经存在，则调用进程对它需要有写权限(如同剧除情况一样)。另外，调用进程将删除oldname目录项，并可能要创建newname目录项，所以它需要对包含oldname及包含newname的目录具有写和执行权限。</p>
<p>除了当oldname或newname指向相对路径名时，其他情况下<code>renameat</code>函数与<code>rename</code>函数功能相同，如果oldhame参数指定了相对路径，就相对于<code>oldfd</code>参数引用的目录来计算oldname。类似地，如果newname指定了相对路径，就相对于<code>newfd</code>引用的目录来计算newname。<code>oldfd</code>或<code>newfd</code>参数(或两者)都能设置成<code>AT_FDCWD</code>，此时相对于当前目录来计算相应的路径名。</p>
<h2 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h2><p>符号链接是对一个文件的间接指针，硬链接直接指向文件的i节点。引入符号链接的原因是为了避开硬链接的限制：</p>
<ul>
<li>硬链接通常要求链接和文件位于同一文件系统中，</li>
<li>只有超级用户才能创建指向目录的硬链接(在底层文件系统支持的情况下)。</li>
</ul>
<p>对符号链接以及它指向何种对象并无任何文件系统限制，任何用户都可以创建指向目录的符号链接。符号链接一般用于将一个文件或整个目录结构移到系统中另一个位置。当使用以名字引用文件的函数时，应当了解该函数是否处理符号链接。也就是该函数是否跟随符号链接到达它所链接的文件。如若该函数具有处理符号链接的功能，则其路径名参数引用由符号链接指向的文件。否则，一个路径名参数引用链接本身，而不是由该链接指向的文件。</p>
<p>下表列出了本章中所说明的各个函数是否处理符号链接。在表中没有列出<code>mkdir</code>、<code>mkinfo</code>、<code>mknod</code>和<code>rmdir</code>这些函数，其原因是，当路径名是符号链接时，它们都出错返回。以文件描述符作为参数的一些函数(如<code>fstat</code>、<code>fchmod</code>等)也未在该表中列出，其原因是，对符号链接的处理是由返回文件描述符的函数(通常是<code>open</code>)进行的。<code>chown</code>是否跟随符号链接取决于实现。</p>
<p><img src="/img/20210517004519.png" alt=""></p>
<p>上表的一个例外是，同时用<code>O_CREAT</code>和<code>O_EXCL</code>两者调用<code>open</code>函数。在此情况下，若路径名引用符号链接，<code>open</code>将出错返回，errno设置为<code>EEXIST</code>，这种处理方式的意图是堵寨一个安全性漏洞，以防止具有特权的进程被诱骗写错误的文件。</p>
<p>使用符号链接可能在文件系统中引入循环。大多数查找路径名的函数在这种情况发生时都将出错返回，errno值为<code>ELOOP</code>。</p>
<p>用<code>open</code>打开文件时，如果传递给<code>open</code>函数的路径名指定了一个符号链接，那么<code>open</code>跟随此链接到达所指定的文件。若此符号链接所指向的文件并不存在，则<code>open</code>返回出错，表示它不能打开该文件。这可能会使不熟悉符号链接的用户感到迷惑，例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ln</span> -s /no/such/file myfile    <span class="comment">#创建一个符号链接</span></span><br><span class="line">$ <span class="built_in">ls</span> myfile</span><br><span class="line">myfile</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> myfile    <span class="comment">#试图查看该文件</span></span><br><span class="line"><span class="built_in">cat</span>: myfile: No such tile or directory</span><br><span class="line">$ <span class="built_in">ls</span> -l myfile  <span class="comment"># 尝试-l选项</span></span><br><span class="line">lrwxrwxrwx 1 sar 13 Jan 22 00:26 myfile -&gt; /no/such/file</span><br></pre></td></tr></table></figure></p>
<p>文件myfile存在，但cat却称没有这一文件。其原因是myfile是个符号链接，由该符号链接所指向的文件并不存在。ls命令的<code>-l</code>选项给我们两个提示：第一个字符是<code>l</code>，它表示这是一个符号链接，而<code>-&gt;</code>也表明这是一个符号链接。<code>ls</code>命令还有另一个选项<code>-F</code>，它会在符号链接的文件名后加一个<code>@</code>符号，在未使用<code>-l</code>选项时，这可以帮助我们识别出符号链接。</p>
<h2 id="创建和读取符号链接"><a href="#创建和读取符号链接" class="headerlink" title="创建和读取符号链接"></a>创建和读取符号链接</h2><p>可以用<code>symlink</code>或<code>symlinkat</code>函数创建一个符号链接。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">symlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *actualpath, <span class="type">const</span> <span class="type">char</span> *sympath)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">symlinkat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *actualpath, <span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *sympath)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值。若成功，返回0，若出错。返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>函数创建了一个指向<code>actualpath</code>的新目录项<code>sympath</code>。在创建此符号链接时，并不要求<code>actualpath</code>已经存在。并且，<code>actualpath</code>和<code>sympath</code>并<br>不需要位于同一文件系统中。</p>
<p><code>symlinkat</code>函数与<code>symlink</code>函数类似，但<code>sympath</code>参数根据相对于打开文件描述符引用的目录(由<code>fd</code>参数指定)进行计算。如果<code>sympath</code>参数指定的是绝对路径或者<code>fd</code>参数设置了<code>AT_FDCWD</code>值，那么<code>symlinkat</code>就等同于<code>symlink</code>函数。</p>
<p>因为<code>open</code>函数跟随符号链接，所以需要有一种方法打开该链接本身，并读该链接中的名字。<code>readlink</code>和<code>readlinkat</code>函数提供了这种功能。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.b&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">readlink</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *restriet parhname, <span class="type">char</span> *restrict buf, <span class="type">size_t</span> bufsize)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">readlinkat</span> <span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* restrict pathrame, <span class="type">char</span> *restrict buf, <span class="type">size_t</span> bufsize)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回读取的字节数，若出错。返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>两个函数组合了<code>open</code>、<code>read</code>和<code>close</code>的所有操作。如果函数成功执行，则返回读入buf的字节数。在buf中返回的符号链接的内容不以null字节终止。当<code>pathname</code>参数指定的是绝对路径名或者<code>fd</code>参数的值为<code>AT_FDCWD</code>，<code>readlinkat</code>函数的行为与<code>readlink</code>相同。但是，如果<code>fd</code>参数是一个打开目录的有效文件描述符并且<code>pathname</code>参数是相对路径名，则<code>readlinkat</code>计算相对于由<code>fd</code>代表的打开目录的路径名。</p>
<h2 id="文件的时间"><a href="#文件的时间" class="headerlink" title="文件的时间"></a>文件的时间</h2><p>每个文件属性所保存的实际精度依赖于文件系统的实现。对于把时间戳记录在秒级的文件系统来说，纳秒这个字段就会被填充为0。对于时间戳的记录精度高于秒级的文件系统来说，不足秒的值被转换成纳秒并记录在纳秒这个字段中。对每个文件维护3个时间字段，它们的意义示于表。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>例子</th>
<th>ls(l)选项</th>
</tr>
</thead>
<tbody>
<tr>
<td>st_atim</td>
<td>文件数据的最后访问时间</td>
<td>read</td>
<td>-u</td>
</tr>
<tr>
<td>st_ntim</td>
<td>文件教据的最后修改时间</td>
<td>write</td>
<td>默认</td>
</tr>
<tr>
<td>st_ctim</td>
<td>节点状态的最后更改时间</td>
<td>chmod、chown</td>
<td>-c</td>
</tr>
</tbody>
</table>
</div>
<p>注意，修改时间(<code>st_mtim</code>)和状态更改时间(<code>st_ctim</code>)之间的区别。修改时间是文件内容最后一次被修改的时间。状态更改时间是该文件的i节点最后一次被修改的时间。因为i节点中的所有信息都是与文件的实际内容分开存放的，所以，要记录文件数据修改时间和更改i节点中信息的时间。</p>
<p>图列出了我们已说明过的各种函数对这3个时间的作用。增加、删除或修改目录项会影响到它所在目录相关的3个时间。这就是在图中包含两列的原因，其中一列是与该文件(或目录)相关的3个时间，另一列是与所引用的文件(或目录)的父目录相关的3个时间。例如，创建一个新文件影响到包含此新文件的目录，也影响该新文件的i节点。但是，读或写一个文件只影响该文件的i节点，而对目录则无影响。<br><img src="/img/1621242103.jpg" alt=""></p>
<h2 id="函数futimens、utimensat和utimes"><a href="#函数futimens、utimensat和utimes" class="headerlink" title="函数futimens、utimensat和utimes"></a>函数futimens、utimensat和utimes</h2><p>一个文件的访问和修改时间可以用以下几个函数更改。<code>futimens</code>和<code>utimensat</code>函数可以指定纳秒级精度的时间戳。用到的数据结构是与<code>stat</code>函数族相同的<code>timespec</code>结构。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">futimens</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">utimensat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>], <span class="type">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值，若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>这两个函数的<code>times</code>数组参数的第一个元素包含访问时间，第二元素包含修改时间。这两个时间值是日历时间。不足秒的部分用纳秒表示，时间戳可以按下列4种方式之一进行指定：</p>
<ol>
<li>如果<code>times</code>参数是一个空指针，则访问时间和修改时间两者都设置为当前时间。</li>
<li>如果<code>times</code>参数指向两个<code>timespec</code>结构的数组，任一数组元素的<code>tv_nsec</code>字段的值为<code>UTIME_NOW</code>，相应的时间戳就设置为当前时间，忽略相应的<code>tv_sec</code>字段。</li>
<li>如果<code>times</code>参数指向两个<code>timespec</code>结构的数组，任一数组元素的<code>tv_nsec</code>字段的值为<code>UTIME_OMIT</code>，相应的时间戳保持不变，忽略相应的<code>tv_sec</code>字段。</li>
<li>如果<code>rimes</code>参数指向两个<code>timespec</code>结构的数组，且<code>tv_nsec</code>字段的值为既不是<code>UTIME_NOW</code>也不是<code>UTIME_OMIT</code>，在这种情况下，相应的时间戳设置为相应的<code>tv_sec</code>和<code>tv_nsec</code>字段的值。</li>
</ol>
<p>执行这些函数所要求的优先权取决于times参数的值。</p>
<ul>
<li>如果<code>times</code>是一个空指针，或者任一<code>tv_nsec</code>字段设为<code>UTIME_NOW</code>，则进程的有效用户ID必须等于该文件的所有者ID进程对该文件必须具有写权限，或者进程是一个超级用户进程。</li>
<li>如果<code>times</code>是非空指针，并且任一<code>tv_nsec</code>字段的值既不是<code>UTIME_NOW</code>也不是<code>UTIME_OMIT</code>，则进程的有效用户ID必须等于该文件的所有者ID，或者进程必须是一个超级用户进程。对文件只具有写权限是不够的</li>
<li>如果<code>times</code>是非空指针，并且两个<code>tv_nec</code>字段的值都为<code>UTIME_OMIT</code>，就不执行任何的权限检查</li>
</ul>
<p><code>futimens</code>函数需要打开文件来更改它的时间，<code>utimensat</code>函数提供了一种使用文件名更改文件时间的方法。<code>pathname</code>参数是相对于<code>fd</code>参数进行计算的，<code>fd</code>要么是打开目录的文件描述符，要么设置为特殊值<code>AT_FDCWD</code>。如果<code>pathname</code>指定了绝对路径，那么<code>fd</code>参数被忽略，<code>utimensat</code>的<code>flag</code>参数可用于进一步修改默认行为，如果设置了<code>AT_SYMLINK_NOFOLLOW</code>标志，则符号链接本身的时间就会被修改。默认的行为是跟随符号链接，并把文件的时间改成符号链接的时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">utimes</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="keyword">struct</span> timeval times[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="comment">// 函数返回值。若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>utimes</code>函数对路径名进行操作。<code>times</code>参数是指向包含两个时间戳(访问时间和修改时间)元素的数组的指针，两个时间戳是用秒和微妙表示的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> &#123;</span><br><span class="line"><span class="type">time_t</span> tv_sec; <span class="comment">/* seconds */</span></span><br><span class="line"><span class="type">long</span> tv_usec; <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意，我们不能对状态更改时间<code>st_ctim</code>(i节点最近被修改的时间)指定一个值，因为调用<code>utimes</code>函数时，此字段会被自动更新。</p>
<p>程序使用带<code>O_TRUNC</code>选项的<code>open</code>函数将文件长度截断为0，但并不更改其访问时间及修改时间。为了做到这一点，首先用<code>stat</code>函数得到这些时间，然后截断文件，最后再用<code>futimens</code>函数重置这两个时间。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, fd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> statbuf;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span> times[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">stat</span>(argv[i], &amp;statbuf) &lt; <span class="number">0</span>) &#123; <span class="comment">/* fetch current times */</span></span><br><span class="line">            <span class="built_in">err_ret</span>(<span class="string">&quot;%s: stat error&quot;</span>, argv[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(argv[i], O_RDWR | O_TRUNC)) &lt; <span class="number">0</span>) &#123; <span class="comment">/*truncate */</span></span><br><span class="line">            <span class="built_in">err_ret</span>(<span class="string">&quot;%s: open error&quot;</span>, argv[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        times[<span class="number">0</span>] = statbuf.st_atin;</span><br><span class="line">        times[<span class="number">1</span>] = statbuf.st_mtim;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">futimens</span>(fd, times) &lt; <span class="number">0</span>) <span class="comment">/* reset times */</span></span><br><span class="line">            <span class="built_in">err_ret</span> (<span class="string">&quot;%s: futinens error&quot;</span>, argv[i]);</span><br><span class="line">        <span class="built_in">close</span> (fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数mkdir-mkdirat和rmdir"><a href="#函数mkdir-mkdirat和rmdir" class="headerlink" title="函数mkdir, mkdirat和rmdir"></a>函数mkdir, mkdirat和rmdir</h2><p>用<code>mkdir</code>和<code>mkdirat</code>函数创建目录，用<code>rmdir</code>函数删除目录。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ays/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkdirat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值。若成功，返回0;若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>这两个函数创建一个新的空目录。其中<code>.</code>和<code>..</code>目录项是自动创建的。所指定的文件访问权限<code>mode</code>由进程的文件模式创建屏蔽字修改。常见的错误是指定与文件相同的<code>mode</code>(只指定读、写权限)。但是，对于目录通常至少要设置一个执行权限位，以允许访问该目录中的文件名。</p>
<p><code>mkdirat</code>函数与<code>mkdir</code>函数类似。当<code>fd</code>参数具有特殊值<code>AT_FDCWD</code>或者<code>pathname</code>参数指定了绝对路径名时，<code>mkdirat</code>与<code>mkdir</code>完全一样。否则，<code>fd</code>参数是一个打开目录，相对路径名根据此打开目录进行计算。</p>
<p>用<code>rmdir</code>函数可以删除一个空目录。空目录是只包含<code>.</code>和<code>..</code>这两项的目录。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>如果调用此函数使目录的链接计数成为0，并且也没有其他进程打开此目录，则释放由此目录占用的空间。如果在链接计数达到0时，有一个或多个进程打开此目录，则在此函数返回前删除最后一个链接及<code>.</code>和<code>..</code>项。另外，在此目录中不能再创建新文件。但是在最后一个进程关闭它之前并不释放此目录。</p>
<h2 id="读目录"><a href="#读目录" class="headerlink" title="读目录"></a>读目录</h2><p>对某个目录具有访问权限的任一用户都可以读该目录，但是，为了防止文件系统产生混乱，只有内核才能写目录。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function">DIR *<span class="title">fdopendir</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值：若成功，返回指针，若出错，返回NULL</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span> *<span class="built_in">readdir</span>(DIR *dp);</span><br><span class="line"><span class="comment">// 返回值。若成功，返回指针；若在目录尾或出错，返回NULL</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rewinddir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">closedir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功。返回0；若出错，返回-1</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">telldir</span><span class="params">(DIR* dp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，与中关联的目录中的当前位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">seekdir</span> <span class="params">(DIR* dp, <span class="type">long</span> loc)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>fdopendir</code>函数提供了一种方法，可以把打开文件描述符转换成目录处理函数需要的<code>DIR</code>结构。定义在头文件<code>&lt;dirent.h&gt;</code>中的<code>dirent</code>结构与实现有关。实现对此结构所做的定义至少包含下列两个成员：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ino_t</span> d_ino;   <span class="comment">/* i-node number */</span></span><br><span class="line"><span class="type">char</span> d_name[]; <span class="comment">/* null-terninated tilename */</span></span><br></pre></td></tr></table></figure></p>
<p>注意，<code>d_name</code>项的大小并没有指定，但必须保证它能包含至少<code>NAME_MAX</code>个字节(不包含终止null字节)。因为文件名是以null字节结束的，所以在头文件中如何定义数组<code>d_name</code>并无多大关系，数组大小并不表示文件名的长度。</p>
<p><code>DIR</code>结构是一个内部结构，上述7个函数用这个内部结构保存当前正在被读的目录的有关信息。其作用类似于<code>FILE</code>结构。<code>FILE</code>结构由标准I/O库维护。</p>
<p><code>opendir</code>执行初始化操作，使第一个<code>readdir</code>返回目录中的第一个目录项。<code>DIR</code>结构由<code>fdopendir</code>创建时，<code>readdir</code>返回的第一项取决于传给<code>fdopendir</code>函数的文件描述符相关联的文件偏移量。注意，目录中各目录项的顺序与实现有关。它们通常并不按字母顾序排列。</p>
<p>我们将使用这些对目录进行操作的例程编写一个遍历文件层次结构的程序，其目的是得到各种类型的文件计数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* function type that is called for each filename */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span>	<span class="type">int</span>	<span class="title">Myfunc</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="keyword">struct</span> stat *, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Myfunc	myfunc;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span>		<span class="title">myftw</span><span class="params">(<span class="type">char</span> *, Myfunc *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span>		<span class="title">dopath</span><span class="params">(Myfunc *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span>	nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>		ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">		<span class="built_in">err_quit</span>(<span class="string">&quot;usage:  ftw  &lt;starting-pathname&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">myftw</span>(argv[<span class="number">1</span>], myfunc);		<span class="comment">/* does it all */</span></span><br><span class="line"></span><br><span class="line">	ntot = nreg + ndir + nblk + nchr + nfifo + nslink + nsock;</span><br><span class="line">	<span class="keyword">if</span> (ntot == <span class="number">0</span>)</span><br><span class="line">		ntot = <span class="number">1</span>;		<span class="comment">/* avoid divide by 0; print 0 for all counts */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;regular files  = %7ld, %5.2f %%\n&quot;</span>, nreg,</span><br><span class="line">	  nreg*<span class="number">100.0</span>/ntot);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;directories    = %7ld, %5.2f %%\n&quot;</span>, ndir,</span><br><span class="line">	  ndir*<span class="number">100.0</span>/ntot);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;block special  = %7ld, %5.2f %%\n&quot;</span>, nblk,</span><br><span class="line">	  nblk*<span class="number">100.0</span>/ntot);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;char special   = %7ld, %5.2f %%\n&quot;</span>, nchr,</span><br><span class="line">	  nchr*<span class="number">100.0</span>/ntot);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;FIFOs          = %7ld, %5.2f %%\n&quot;</span>, nfifo,</span><br><span class="line">	  nfifo*<span class="number">100.0</span>/ntot);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;symbolic links = %7ld, %5.2f %%\n&quot;</span>, nslink,</span><br><span class="line">	  nslink*<span class="number">100.0</span>/ntot);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sockets        = %7ld, %5.2f %%\n&quot;</span>, nsock,</span><br><span class="line">	  nsock*<span class="number">100.0</span>/ntot);</span><br><span class="line">	<span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Descend through the hierarchy, starting at &quot;pathname&quot;.</span></span><br><span class="line"><span class="comment"> * The caller&#x27;s func() is called for every file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	FTW_F	1		<span class="comment">/* file other than directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	FTW_D	2		<span class="comment">/* directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	FTW_DNR	3		<span class="comment">/* directory that can&#x27;t be read */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	FTW_NS	4		<span class="comment">/* file that we can&#x27;t stat */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>	*fullpath;		<span class="comment">/* contains full pathname for every file */</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> pathlen;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span>					<span class="comment">/* we return whatever func() returns */</span></span><br><span class="line"><span class="built_in">myftw</span>(<span class="type">char</span> *pathname, Myfunc *func)</span><br><span class="line">&#123;</span><br><span class="line">	fullpath = <span class="built_in">path_alloc</span>(&amp;pathlen);	<span class="comment">/* malloc PATH_MAX+1 bytes */</span></span><br><span class="line">										<span class="comment">/* (&#123;Prog pathalloc&#125;) */</span></span><br><span class="line">	<span class="keyword">if</span> (pathlen &lt;= <span class="built_in">strlen</span>(pathname)) &#123;</span><br><span class="line">		pathlen = <span class="built_in">strlen</span>(pathname) * <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> ((fullpath = <span class="built_in">realloc</span>(fullpath, pathlen)) == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">err_sys</span>(<span class="string">&quot;realloc failed&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">strcpy</span>(fullpath, pathname);</span><br><span class="line">	<span class="keyword">return</span>(<span class="built_in">dopath</span>(func));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Descend through the hierarchy, starting at &quot;fullpath&quot;.</span></span><br><span class="line"><span class="comment"> * If &quot;fullpath&quot; is anything other than a directory, we lstat() it,</span></span><br><span class="line"><span class="comment"> * call func(), and return.  For a directory, we call ourself</span></span><br><span class="line"><span class="comment"> * recursively for each name in the directory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span>					<span class="comment">/* we return whatever func() returns */</span></span><br><span class="line"><span class="built_in">dopath</span>(Myfunc* func)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">stat</span>		statbuf;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">dirent</span>	*dirp;</span><br><span class="line">	DIR				*dp;</span><br><span class="line">	<span class="type">int</span>				ret, n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">lstat</span>(fullpath, &amp;statbuf) &lt; <span class="number">0</span>)	<span class="comment">/* stat error */</span></span><br><span class="line">		<span class="keyword">return</span>(<span class="built_in">func</span>(fullpath, &amp;statbuf, FTW_NS));</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">S_ISDIR</span>(statbuf.st_mode) == <span class="number">0</span>)	<span class="comment">/* not a directory */</span></span><br><span class="line">		<span class="keyword">return</span>(<span class="built_in">func</span>(fullpath, &amp;statbuf, FTW_F));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * It&#x27;s a directory.  First call func() for the directory,</span></span><br><span class="line"><span class="comment">	 * then process each filename in the directory.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((ret = <span class="built_in">func</span>(fullpath, &amp;statbuf, FTW_D)) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(ret);</span><br><span class="line"></span><br><span class="line">	n = <span class="built_in">strlen</span>(fullpath);</span><br><span class="line">	<span class="keyword">if</span> (n + NAME_MAX + <span class="number">2</span> &gt; pathlen) &#123;	<span class="comment">/* expand path buffer */</span></span><br><span class="line">		pathlen *= <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> ((fullpath = <span class="built_in">realloc</span>(fullpath, pathlen)) == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">err_sys</span>(<span class="string">&quot;realloc failed&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fullpath[n++] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">	fullpath[n] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((dp = <span class="built_in">opendir</span>(fullpath)) == <span class="literal">NULL</span>)	<span class="comment">/* can&#x27;t read directory */</span></span><br><span class="line">		<span class="keyword">return</span>(<span class="built_in">func</span>(fullpath, &amp;statbuf, FTW_DNR));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((dirp = <span class="built_in">readdir</span>(dp)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(dirp-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span>  ||</span><br><span class="line">		    <span class="built_in">strcmp</span>(dirp-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;		<span class="comment">/* ignore dot and dot-dot */</span></span><br><span class="line">		<span class="built_in">strcpy</span>(&amp;fullpath[n], dirp-&gt;d_name);	<span class="comment">/* append name after &quot;/&quot; */</span></span><br><span class="line">		<span class="keyword">if</span> ((ret = <span class="built_in">dopath</span>(func)) != <span class="number">0</span>)		<span class="comment">/* recursive */</span></span><br><span class="line">			<span class="keyword">break</span>;	<span class="comment">/* time to leave */</span></span><br><span class="line">	&#125;</span><br><span class="line">	fullpath[n<span class="number">-1</span>] = <span class="number">0</span>;	<span class="comment">/* erase everything from slash onward */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">closedir</span>(dp) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">err_ret</span>(<span class="string">&quot;can&#x27;t close directory %s&quot;</span>, fullpath);</span><br><span class="line">	<span class="keyword">return</span>(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">myfunc</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="keyword">struct</span> stat *statptr, <span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">	<span class="keyword">case</span> FTW_F:</span><br><span class="line">		<span class="keyword">switch</span> (statptr-&gt;st_mode &amp; S_IFMT) &#123;</span><br><span class="line">		<span class="keyword">case</span> S_IFREG:	nreg++;		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFBLK:	nblk++;		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFCHR:	nchr++;		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFIFO:	nfifo++;	<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFLNK:	nslink++;	<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFSOCK:	nsock++;	<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFDIR:	<span class="comment">/* directories should have type = FTW_D */</span></span><br><span class="line">			<span class="built_in">err_dump</span>(<span class="string">&quot;for S_IFDIR for %s&quot;</span>, pathname);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FTW_D:</span><br><span class="line">		ndir++;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FTW_DNR:</span><br><span class="line">		<span class="built_in">err_ret</span>(<span class="string">&quot;can&#x27;t read directory %s&quot;</span>, pathname);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FTW_NS:</span><br><span class="line">		<span class="built_in">err_ret</span>(<span class="string">&quot;stat error for %s&quot;</span>, pathname);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">err_dump</span>(<span class="string">&quot;unknown type %d for pathname %s&quot;</span>, type, pathname);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数chdir、fchdir和getcwd"><a href="#函数chdir、fchdir和getcwd" class="headerlink" title="函数chdir、fchdir和getcwd"></a>函数chdir、fchdir和getcwd</h2><p>每个进程都有一个当前工作目录，此目录是搜索所有相对路径名的起点。当用户登录到UNIX系统时，其当前工作目录通常是口令文件(<code>/etc/passwd</code>)中该用户登录项的第6个字段一用户的起始目录(home directory)。当前工作目录是进程的一个属性，起始目录则是登录名的一个属性。进程调用<code>chdir</code>或<code>fchdir</code>函数可以更改当前工作目录。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathame)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fchdir</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>在这两个函数中，分别用<code>pathname</code>或打开文件描述符来指定新的当前工作目录。</p>
<p>因为当前工作目录是进程的一个属性，所以它只影响调用<code>chdir</code>的进程本身，而不影响其他进程。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">chdir</span>(<span class="string">&quot;/tmp&quot;</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;chdir failed&quot;</span>);</span><br><span class="line">    <span class="built_in">printe</span>(<span class="string">&quot;chdir to /tmp succeeded\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果编译图4-23程序，并且调用其可执行目标代码文件mycd，则可以得到下列结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/usr/lib</span><br><span class="line">$ mycd</span><br><span class="line"><span class="built_in">chdir</span> to /tmp succeeded</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/usr/lib</span><br></pre></td></tr></table></figure></p>
<p>从中可以看出，执行mycd命令的shell的当前工作目录并没有改变，这是shell执行程序工作方式的一个副作用。每个程序运行在独立的进程中，shell的当前工作目录并不会随着程序调用<code>chdir</code>而改变。</p>
<p>为了改变shell进程自己的工作目录，shell应当直接调用chdir函数，为此，cd命令内建在shell中，因为内核必须维护当前工作目录的信息，所以我们应能获取其当前值。遗憾的是，内核为每个进程只保存指向该目录v节点的指针等目录本身的信息，并不保存该目录的完整路径名。</p>
<p>函数<code>getcwd</code>从当前工作目录(<code>.</code>)开始，用<code>..</code>找到其上一级目录，然后读其目录项，直到该目录项中的i节点编号与工作目录i节点编号相同，这样地就找到了其对应的文件名，逐层上移，直到遇到根，这样就得到了当前工作目录完整的绝对路径名。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回buf，若出错，返回NULL</span></span><br></pre></td></tr></table></figure></p>
<p>必须向此函数传递两个参数，一个是缓冲区地址<code>buf</code>，另一个是缓冲区的长度<code>size</code>(以字节为单位)。该缓冲区必须有足够的长度以容纳绝对路径名再加上一个终止null字节，否则返回出错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span>	*ptr;</span><br><span class="line">	<span class="type">size_t</span>		size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">chdir</span>(<span class="string">&quot;/usr/spool/uucppublic&quot;</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;chdir failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">	ptr = <span class="built_in">path_alloc</span>(&amp;size);	<span class="comment">/* our own function */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">getcwd</span>(ptr, size) == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;getcwd failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;cwd = %s\n&quot;</span>, ptr);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在更换工作目录之前，我们可以调用<code>getcwd</code>函数先将其保存起来。在完成了处理后，就可将所保存的原工作目录路径名作为调用参数传送给<code>chdir</code>。<code>fchdir</code>函数向我们提供了一种完成此任务的便捷方法。</p>
<p>在更换到文件系统中的不同位置前，无需调用<code>getcwd</code>函数，而是使用<code>open</code>打开当前工作目录，然后保存其返回的文件描述符。当希望回到原工作目录时，只要简单地将该文件描述符传送给<code>fchdir</code>。</p>
<h2 id="设备特殊文件"><a href="#设备特殊文件" class="headerlink" title="设备特殊文件"></a>设备特殊文件</h2><p><code>st_dev</code>和<code>st_rdev</code>这两个字段经常引起混淆</p>
<ul>
<li>每个文件系统所在的存储设备都由其主、次设备号表示。设备号所用的数据类型是基本系统数据类型<code>dev_t</code>。主设备号标识设备驱动程序；次设备号标识特定的子设备。</li>
<li>我们通常可以使用两个宏；<code>major</code>和<code>minor</code>来访问主、次设备号，大多数实现都定义这两个宏。这就意味着我们无需关心这两个数是如何存放在<code>dev_t</code>对象中的。</li>
<li>系统中与每个文件名关联的<code>st_dev</code>值是文件系统的设备号，该文件系统包含了这一文件名以及与其对应的i节点。</li>
<li>只有字符特殊文件和块特殊文件才有<code>st_rdev</code>值。此值包含实际设备的设备号。</li>
</ul>
<p>程序为每个命令行参数打印设备号，另外，若此参数引用的是字符特殊文件或块特殊文件，则还打印该特殊文件的<code>st_rdev</code>值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>			i;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">stat</span>	buf;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s: &quot;</span>, argv[i]);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">stat</span>(argv[i], &amp;buf) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">err_ret</span>(<span class="string">&quot;stat error&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;dev = %d/%d&quot;</span>, <span class="built_in">major</span>(buf.st_dev),  <span class="built_in">minor</span>(buf.st_dev));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">S_ISCHR</span>(buf.st_mode) || <span class="built_in">S_ISBLK</span>(buf.st_mode)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; (%s) rdev = %d/%d&quot;</span>,</span><br><span class="line">					(<span class="built_in">S_ISCHR</span>(buf.st_mode)) ? <span class="string">&quot;character&quot;</span> : <span class="string">&quot;block&quot;</span>,</span><br><span class="line">					<span class="built_in">major</span>(buf.st_rdev), <span class="built_in">minor</span>(buf.st_rdev));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="文件访问权限位小结"><a href="#文件访问权限位小结" class="headerlink" title="文件访问权限位小结"></a>文件访问权限位小结</h2><p>我们已经说明了所有文件访问权限位，其中某些位有多种用途。列出了所有这些权限位，以及它们对普通文件和目录文件的作用。最后9个常量还可以分成如下3组：</p>
<ul>
<li><code>S_IRWXU</code> = <code>S_IRUSR</code> | <code>S_IWUSR</code> | <code>S_IXUSR</code></li>
<li><code>S_IRWXG</code> = <code>S_IRGRP</code> | <code>S_IWGRP</code> | <code>S_IXGRP</code></li>
<li><code>S_IRWXO</code> = <code>S_IROTH</code> | <code>S_IWOTH</code> | <code>S_IXOTH</code></li>
</ul>
<p><img src="/img/1621244305.jpg" alt=""></p>
<h1 id="标准I-O库"><a href="#标准I-O库" class="headerlink" title="标准I/O库"></a>标准I/O库</h1><h2 id="流和FILE对象"><a href="#流和FILE对象" class="headerlink" title="流和FILE对象"></a>流和FILE对象</h2><p>对于标准I/O库，它们的操作是围绕流(stream)进行的。当用标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相关联。对于ASCII字符集，一个字符用一个字节表示。标准I/O文件流可用于单字节或多字节字符集。流的定向(stream’s orientation)决定了所读、写的字符是单字节还是多字节的。当一个流最初被创建时，它并没有定向。如若在未定向的流上使用一个多字节I/O函数(见<code>&lt;wchar.h&gt;</code>)，则将该流的定向设置为宽定向的。若在未定向的流上使用一个单字节I/O函数，则将该流的定向设为字节定向的。只有两个函数可改变流的定向。<code>freopen</code>函数清除一个流的定向；<code>fwide</code>函数可用于设置流的定向。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fwide</span> <span class="params">(FILE *fp， <span class="type">int</span> mode)</span></span>;</span><br><span class="line"><span class="comment">// 返回值。若流是宽定向的，返回正值：若流是字节定向的，返回负值，若流是未定向的，返回0</span></span><br></pre></td></tr></table></figure></p>
<p>根据<code>mode</code>参数的不同值，<code>fwide</code>函数执行不同的工作。</p>
<ul>
<li>如若<code>mode</code>参数值为负，<code>fwide</code>将试图使指定的流是字节定向的。</li>
<li>如若<code>mode</code>参数值为正，<code>fwide</code>将试图使指定的流是宽定向的。</li>
<li>如若<code>mode</code>参数值为0，<code>fwide</code>将不试图设置流的定向，但返回标识该流定向的值。</li>
</ul>
<p>注意，<code>fwide</code>并不改变已定向流的定向。还应注意的是，<code>fwide</code>无出错返回。</p>
<p>当打开一个流时，标准I/O函数<code>fopen</code>返回一个指向<code>FILE</code>对象的指针。该对象通常是一个结构，它包含了标准I/O库为管理该流需要的所有信息，包括用于实际I/O的文件描述符、指向用于该流缓冲区的指针、缓冲区的长度、当前在缓冲区中的字符数以及出错标志等。应用程序没有必要检验<code>FILE</code>对象。为了引用一个流，需将<code>FILE</code>指针作为参数传递给每个标准I/O函数。在本书中，我们称指向<code>FILE</code>对象的指针(类型为<code>FILE*</code>)为文件指针。</p>
<h2 id="标准输入、标准输出和标准错误-1"><a href="#标准输入、标准输出和标准错误-1" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h2><p>对一个进程预定义了3个流，并且这3个流可以自动地被进程使用，它们是：<strong>标准输入</strong>、<strong>标准输出</strong>和<strong>标准错误</strong>。这些流引用的文件与文件描述符<code>STDIN_FILENO</code>，<code>STDOUT_FILENO</code>和<code>STDERR_FILENO</code>所引用的相同。这3个标准I/O流通过预定义文件指针<code>stdin</code>、<code>stdout</code>和<code>stderr</code>加以引用。这3个文件<br>指针定义在头文件<code>&lt;stdio.h&gt;</code>中。</p>
<h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>标准I/O库提供缓冲的目的是尽可能减少使用<code>read</code>和<code>write</code>调用的次数。它也对每个I/O流自动地进行缓冲管理。标准I/O提供了以下3种类型的缓冲：</p>
<ul>
<li>全缓冲。在这种情况下，在填满标准I/O缓冲区后才进行实际操作。对于驻留在磁盘上的文件通常是由标准I/O库实施全缓冲的。在一个流上执行第一次I/O操作时，相关标准I/O函数通常调用<code>malloc</code>获得需使用的缓冲区，<code>flush</code>说明标准I/O缓冲区的写操作。缓冲区可由标准I/O例程自动flush，或者可以调用函数<code>fflush</code>冲洗一个流。</li>
<li>行缓冲。在这种情况下，当在输入和输出中遇到换行符时，标准I/O库执行I/O操作。这允许我们一次输出一个字符，但只有在写了一行之后才进行实际I/O操作。当流涉及一个终端时(如标准输入和标准输出)，通常使用行缓冲。<ul>
<li>对于行缓冲有两个限制。第一，因为标准I/O库用来收集每一行的缓冲区的长度是固定的，所以只要填满了缓冲区，那么即使还没有写一个换行符，也进行I/O操作。</li>
<li>第二，任何时候只要通过标准I/O库要求从(a)一个不带缓冲的流，或者(b)一个行缓冲的流得到输入数据，那么就会flush所有行缓冲输出流。很明显，从一个不带缓冲的流中输入需要从内核获得数据。</li>
</ul>
</li>
<li>不带缓冲。标准I/O库不对字符进行缓冲存储。例如，用标准I/O函数<code>fputs</code>写15个字符到不带缓冲的流中，我们就期望这15个字符能立即输出。</li>
</ul>
<p>标准错误流stderr通常是不带缓冲的，这就使得出错信息可以尽快显示出来，而不管它们是否含有一个换行符。</p>
<p>ISOC要求下列缓冲特征。</p>
<ul>
<li>当且仅当标准输入和标准输出并不指向交互式设备时，它们才是全缓冲的。</li>
<li>标准错误决不会是全缓冲的。</li>
</ul>
<p>但是，这并没有告诉我们如果标准输入和标准输出指向交互式设备时，它们是不带缓冲的还是行缓冲的；以及标准错误是不带缓冲的还是行缓冲的。很多系统默认使用下列类型的缓冲：</p>
<ul>
<li>标准错误是不带缓冲的</li>
<li>若是指向终端设备的流，则是行缓冲的；否则是全缓冲的。</li>
</ul>
<p>对任何一个给定的流，如果我们并不喜欢这些系统默认，则可调用下列两个函数中的一个更改缓冲类型<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setbuf</span><span class="params">(FILE *restrict fp， <span class="type">char</span> *restrict buf)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setvbuf</span><span class="params">(FILE *restrict fp， <span class="type">char</span> *restrict buf， <span class="type">int</span> mode， <span class="type">size_t</span> site)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回非0</span></span><br></pre></td></tr></table></figure></p>
<p>这些函数一定要在流已被打开后调用，因为每个函数都要求一个有效的文件指针作为它们的第一个参数，而且也应在对该流执行任何一个其他操作之前调用。</p>
<p>可以使用<code>setbuf</code>函数打开或关闭缓冲机制。为了带缓冲进行I/O，参数<code>buf</code>必须指向一个长度为<code>BUFSIZ</code>的缓冲区(该常量定义在<code>&lt;stdio.h&gt;</code>中)。通常在此之后该流就是全缓冲的，但是如果该流与一个终端设备相关，那么某些系统也可将其设置为行缓冲的。为了关闭缓冲，将<code>buf</code>没置为NULL。</p>
<p>使用<code>setvbuf</code>，我们可以精确地说明所需的缓冲类型。这是用<code>mode</code>参数实现的：</p>
<ul>
<li><code>_IOFBF</code>：全缓冲</li>
<li><code>_IOLBF</code>：行缓冲</li>
<li><code>_IONBF</code>：不带缓冲</li>
</ul>
<p>如果指定一个不带缓冲的流，则忽略<code>buf</code>和<code>size</code>参数。如果指定全缓冲或行缓冲，则<code>buf</code>和<code>size</code>可选择地指定一个缓冲区及其长度。如果该流是带缓冲的，而buf是NULL，则标准I/O库将自动地为该流分配适当长度的缓冲区。适当长度指的是由常量<code>BUFSIZ</code>所指定的值。</p>
<p>图5-1列出了这两个函数的动作，以及它们的各个选项。<br><img src="/img/20210517115638.png" alt=""></p>
<p>要了解，如果在一个函数内分配一个自动变量类的标准I/O缓冲区。则从该函数返回之前，必须关闭该流。另外，其些实现将缓冲区的一部分用于存放它自己的<br>管理操作信息，所以可以存放在缓冲区中的实际数据字节数少于size。一般而言，应由系统选择缓冲区的长度，并自动分配缓冲区。</p>
<p>任何时候，我们都可强制冲洗一个流<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fflush</span> <span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0，若出错，返回EOF</span></span><br></pre></td></tr></table></figure></p>
<p>此函数使该流所有未写的数据都被传送至内核。作为一种特殊情形，如若<code>fp</code>是NULL，则此函数将导致所有输出流被冲洗。</p>
<h2 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h2><p>下列3个函数打开一个标准I/O流。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *restrict pathname， <span class="type">const</span> <span class="type">char</span> *restrict type)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *restrict pathname， <span class="type">const</span> <span class="type">char</span> *restrict type， FILE *restrict fp)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="type">int</span> fd， <span class="type">const</span> <span class="type">char</span> *type)</span></span>;</span><br><span class="line"><span class="comment">// 3个函数的返回值：若成功，返回文件指针；若出错，返回NULL</span></span><br></pre></td></tr></table></figure></p>
<p>这3个函数的区别如下。</p>
<ol>
<li><code>fopen</code>函数打开路径名为pathname的一个指定的文件。</li>
<li><code>freopen</code>函数在一个指定的流上打开一个指定的文件，如果该流已经打开，则先关闭该流。若该流已经定向，则使用<code>freopen</code>清除该定向。此函数一般用于将一个指定的文件打开为一个预定义的流：标准输入、标准输出或标准错误。</li>
<li><code>fdopen</code>函数取一个已有的文件描述符(我们可能从<code>open</code>、<code>dup</code>、<code>dup2</code>、<code>fcntl</code>、<code>pipe</code>、<code>socket</code>、<code>socketpair</code>、<code>accept</code>函数得到此文件描述符)，并使一个标准的I/O流与该描述符相结合。此函数常用于由创建管道和网络通信通道函数返回的描述符，因为这些特殊类型的文件不能用标准I/O函数<code>fopen</code>打开，所以我们必须先调用设备专用函数以获得一个文件描述符，然后用<code>fdopen</code>使一个标准I/O流与该描述符相结合。</li>
</ol>
<p><code>fopen</code>和<code>freopen</code>是ISO C的所属部分。而ISO C并不涉及文件描述符，所以仅有POSIX.1具有<code>fdopen</code>。</p>
<p><code>type</code>参数指定对该I/O流的读、写方式，ISO C规定<code>type</code>参数可以有15种不同的值，如表所示。</p>
<p><img src="/img/20210518121754.png" alt=""></p>
<p>使用字符b作为<code>type</code>的一部分，这使得标准I/O系统可以区分文本文件和二进制文件。因为UNIX内核并不对这两种文件进行区分，所以在UNIX系统环境下指定字符b作为<code>type</code>的一部分实际上并无作用。</p>
<p>对于<code>fdopen</code>，<code>type</code>参数的意义稍有区别。因为该描述符已被打开，所以<code>fdopen</code>为写而打开并不截断该文件。另外，标准I/O追加写方式也不能用于创建该文件，当用追加写类型打开一个文件后，每次写都将数据写到文件的当前尾端处。如果有多个进程用标准I/O追加写方式打开同一文件，那么来自每个进程的数据都将正确地写到文件中。</p>
<p>在涉及多个进程时，为了正确地支持追加写方式，该文件必须用<code>O_APPEND</code>标志打开。在每次写前，做一次<code>lseek</code>操作同样也不能正确工作。</p>
<p>当以读和写类型打开一个文件时(type中+号)，具有下列限制。</p>
<ul>
<li>如果中间没有<code>fflush</code>、<code>fseek</code>、<code>fsetpos</code>或<code>rewind</code>，则在输出的后面不能直接跟随输入。</li>
<li>如果中间没有<code>fseek</code>、<code>fsetpos</code>或<code>rewind</code>，或者一个输入操作没有到达文件尾端，则在输入操作之后不能直接跟随输出。</li>
</ul>
<p>图中列出了打开一个流的6种不同的方式。<br><img src="/img/20210518122502.png" alt=""></p>
<p>注意，在指定<code>w</code>或<code>a</code>类型创建一个新文件时，我们无法说明该文件的访问权限位。POSIX.I要求实现使用如下的权限位集来创建文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH</span><br></pre></td></tr></table></figure></p>
<p>除非流引用终端设备，否则按系统默认，流被打开时是全缓冲的。若流引用终端设备，则该流是行缓冲的。一旦打开了流，那么在对该流执行任何操作之前，如果希望，则可使用前节所述的<code>setbuf</code>和<code>setvbuf</code>改变缓冲的类型。</p>
<p>调用<code>fclose</code>关闭一个打开的流<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功。返回0；若出错，返回EOF</span></span><br></pre></td></tr></table></figure></p>
<p>在该文件被关闭之前，冲洗缓冲中的输出数据。缓冲区中的任何输入数据被丢弃。如果标准I/O库已经为该流自动分配了一个缓冲区，则释放此缓冲区。当一个进程正常终止时，则所有带未写缓冲数据的标准I/O流都被冲洗，所有打开的标准I/O流都被关闭。</p>
<h2 id="读和写流"><a href="#读和写流" class="headerlink" title="读和写流"></a>读和写流</h2><p>一旦打开了流，则可在3种不同类型的非格式化I/O中进行选择，对其进行读、写操作。</p>
<ol>
<li>每次一个字符的I/O，一次读或写一个字符，如果流是带缓冲的，则标准I/O函数处理所有缓冲。</li>
<li>每次一行的I/O。如果想要一次读或写一行，则使用<code>fgets</code>和<code>fputs</code>。每行都以一个换行符终止。当调用<code>fgets</code>时，应说明能处理的最大行长。</li>
<li>直接I/O。<code>fread</code>和<code>fwrite</code>函数支持这种类型的I/O。每次I/O操作读或写某种数量的对象，而每个对象具有指定的长度。这两个函数常用于从二进制文件中每次读或写一个结构。</li>
</ol>
<p>直接I/O也被称为：二进制I/O、一次一个对象I/O、面向记录的I/O或面向结构的I/O。</p>
<h3 id="输入函数"><a href="#输入函数" class="headerlink" title="输入函数"></a>输入函数</h3><p>以下3个函数可用于一次读一个字符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getchar</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 3个函数的返回值，若成功，返回下一个字符；若已到达文件尾或出错，返回EOF</span></span><br></pre></td></tr></table></figure></p>
<p>函数<code>getchar</code>等同于<code>getc(stdin)</code>。前两个函数的区别是，<code>getc</code>可被实现为宏，而<code>fgetc</code>不能实现为宏。这意味着以下几点。</p>
<ol>
<li><code>getc</code>的参数不应当是具有副作用的表达式，因为它可能会被计算多次。</li>
<li>因为<code>fgetc</code>一定是个函数，所以可以得到其地址。这就允许将<code>fgetc</code>的地址作为一个参数传送给另一个函数。</li>
<li>调用<code>fgetc</code>所需时间很可能比调用<code>getc</code>要长，因为调用函数所需的时间通常长于调用宏。</li>
</ol>
<p>这3个函数在返回下一个字符时，将其unsigned char类型转换为int类型。说明为无符号的理由是，如果最高位为1也不会使返回值为负。要求整型返回值的理由是，这样就可以返回所有可能的字符值再加。上一个已出错或已到达文件尾端的指示值。在<code>&lt;stdio.h&gt;</code>中的常量<code>EOF</code>被要求是一个负值，其值经常是-1。这就意味着不能将这3个函数的返回值存放在一个字符变量中，以后还要将这些函数的返回值与常量<code>EOF</code>比较。</p>
<p>注意，不管是出错还是到达文件尾端，这3个函数都返回同样的值。为了区分这两种不同的情况，必须调用<code>ferror</code>或<code>feof</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ferror</span> <span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值：若条件为真，返回非0(真)；否则。返回0(假)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearerr</span><span class="params">(FILE *fp)</span>:</span></span><br></pre></td></tr></table></figure></p>
<p>在大多数实现中，为每个流在FILE对象中维护了两个标志；</p>
<ul>
<li>出错标志：</li>
<li>文件结束标志</li>
</ul>
<p>调用<code>clearerr</code>可以清除这两个标志。从流中读取数据以后，可以调用<code>ungetc</code>将字符再压送回流中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ungete</span><span class="params">(<span class="type">int</span> c， FILE *fp)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回c。若出错，返回EOF</span></span><br></pre></td></tr></table></figure></p>
<p>压送回到流中的字符以后又可从流中读出，但读出字符的顺序与压送回的顺序相反。不能回送EOF。但是当已经到达文件尾端时，仍可以回送一个字符。下次读将返回该字符，再读则返回EOF。之所以能这样做的原因是，一次成功的<code>ungetc</code>调用会清除该流的文件结束标志。</p>
<p>当正在读一个输入流，并进行某种形式的切词或记号切分操作时，会经常用到回送字符操作。如果标准I/O库不提供回送能力，就需将该字符存放到一个我们自己的变量中，并设置一个标志以便判别在下一次需要一个字符时是调用<code>getc</code>，还是从我们自己的变量中取用这个字符，用<code>ungetc</code>压送回字符时，并没有将它们写到底层文件或设备中，而是将它们写回标准I/O库的波缓冲区中。</p>
<h3 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h3><p>对应于上面所述的每个输入函数都有一个输出函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">putc</span><span class="params">(<span class="type">int</span> c， FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputc</span><span class="params">(<span class="type">int</span> c， FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">putchar</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="comment">// 3个函数返回值。若成功，返回c；若出错，返回EOF</span></span><br></pre></td></tr></table></figure></p>
<p>与输入函数一样，<code>putchar(c)</code>等同于<code>putc(c， stdout)</code>，<code>putc</code>可被实现为宏，而<code>fputc</code>不能实现为宏。</p>
<h2 id="每次一行I-O"><a href="#每次一行I-O" class="headerlink" title="每次一行I/O"></a>每次一行I/O</h2><p>下面两个函数提供每次输入一行的功能。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">fgets</span><span class="params">(<span class="type">char</span> *restrict buf， <span class="type">int</span> n， FILE *restrict fp)</span>:</span></span><br><span class="line"><span class="function">char *gets(char *buf);</span></span><br><span class="line"><span class="comment">// 两个函数返回值，若成功，返回byf，着已到达文件尾端或出错，返回NULL</span></span><br></pre></td></tr></table></figure></p>
<p>这两个函数都指定了缓冲区的地址，读入的行将送入其中。<code>gets</code>从标准输入读，而<code>fgets</code>则从指定的流读。对于<code>fgets</code>，必须指定缓冲的长度<code>n</code>。此函数一直读到下一个换行符为止，但是不超过<code>n-1</code>个字符，读入的字符被送入缓冲区。该缓冲区以null字节结尾。如若该行包括最后一个换行符的字符数超过<code>n-1</code>。则<code>fgets</code>只返回一个不完整的行，但是，缓冲区总是以null字节结尾，对fgets的下一次调用会继续读该行。</p>
<p><code>gets</code>是一个不推荐使用的函数。其问题是调用者在使用<code>gets</code>时不能指定缓冲区的长度。这样就可能造成缓冲区溢出(如若该行长于缓冲区长度)，写到缓冲区之后的存储空间中，从而产生不可预料的后果。<code>gets</code>与<code>fgets</code>的另一个区别是，<code>gets</code>并不将换行符存入缓冲区中。</p>
<p>虽然ISO C要求提供<code>gets</code>，但请使用<code>fgets</code>，而不要使用<code>gets</code>。</p>
<p><code>fputs</code>和<code>puts</code>提供每次输出一行的功能<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *restrict str， FILE *restrict fp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值，若成功，返回非负值；若出错，返回EOF</span></span><br></pre></td></tr></table></figure></p>
<p>函数<code>puts</code>将一个以null字节终止的字符串写到指定的流，尾端的终止符null不写出。注意，这并不一定是每次输出一行，因为字符串不需要换行符作为最后一个非null字节。通常，在null字节之前是一个换行符，但并不要求总是如此。</p>
<p><code>puts</code>将一个以null字节终止的字符串写到标准输出，终止符不写出。但是，<code>puts</code>随后又将一个换行符写到标准输出。</p>
<h2 id="标准I-O的效率"><a href="#标准I-O的效率" class="headerlink" title="标准I/O的效率"></a>标准I/O的效率</h2><p>下面的程序使用<code>getc</code>和<code>putc</code>将标准输入复制到标准输出。这两个例程可以实现为宏。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="keyword">while</span> ((c = getc(<span class="built_in">stdin</span>)) != EOF)</span><br><span class="line">	<span class="keyword">if</span> (putc(c， <span class="built_in">stdout</span>) == EOF)</span><br><span class="line">		err_sys (<span class="string">&quot;output error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(ferror (<span class="built_in">stdin</span>))</span><br><span class="line">		err_sys(<span class="string">&quot;input error&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二进制I-O"><a href="#二进制I-O" class="headerlink" title="二进制I/O"></a>二进制I/O</h2><p>提供了下列两个函数以执行二进制I/O操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *<span class="keyword">restrict</span> ptr， <span class="type">size_t</span> size， <span class="type">size_t</span> nobj， FILE *<span class="keyword">restrict</span> fp)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *<span class="keyword">restrict</span> ptr， <span class="type">size_t</span> size， <span class="type">size_t</span> nobj， FILE *<span class="keyword">restrict</span> fp)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：读或写的对象数</span></span><br></pre></td></tr></table></figure></p>
<p>这些函数有以下两种常见的用法。</p>
<p>读或写一个二进制数组。例如，为了将一个浮点数组的第2~5个元素写至一文件上，可以编写如下程序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> data[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">if</span>(fwrite(&amp;data[<span class="number">2</span>]， aizeof(<span class="type">float</span>), <span class="number">4</span>， fp) != <span class="number">4</span>)</span><br><span class="line">	err_sys(<span class="string">&quot;fwrite error&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>其中，指定<code>size</code>为每个数组元素的长度，<code>nobj</code>为欲写的元素个数。</p>
<p>读或写一个结构。例如，可以编写如下程序；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">short</span> count;</span><br><span class="line">	<span class="type">long</span> total;</span><br><span class="line">	<span class="type">char</span> name[NAMESIZE];</span><br><span class="line">&#125; item;</span><br><span class="line"><span class="keyword">if</span> (fwrite(&amp;item， <span class="keyword">sizeof</span>(item), <span class="number">1</span>， fp) != <span class="number">1</span>)</span><br><span class="line">	err_sys(<span class="string">&quot;fwrite error&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>其中，指定<code>size</code>为结构的长度，<code>nobj</code>为1 (要写的对象个数)，将这两个例子结合起来就可读或写一个结构数组。为了做到这一点，<code>size</code>应当是该结构的<code>sizeof</code>，<code>noby</code>应是该数组中的元素个数。</p>
<p><code>fread</code>和<code>fwrite</code>返回读或写的对象数。对于读，如果出错或到达文件尾端，则此数字可以少于<code>nobj</code>。在这种情况，应调用<code>ferror</code>或<code>feof</code>以判断究竟是那一种情况。对于写，如果返回值少于所要求的<code>nobj</code>，则出错，使用二进制I/O的基本问题是，它只能用于读在同一系统上已写的数据。</p>
<p>当在一个系统上写的数据，要在另一个系统上进行处理时，这两个函数可能就不能正常工作，其原因是：</p>
<ul>
<li>在一个结构中，同一成员的偏移最可能随编译程序和系统的不同而不同(由于不同的对齐要求)。<ul>
<li>某些编译程序使结构中的各成员紧密包装(这可以节省存储空间，而运行性能则可能有所下降)；</li>
<li>或者准确对齐(以便在运行时易于存取结构中的各成员)。</li>
<li>这意味着即使在同一个系统上，一个结构的二进制存放方式也可能因编译程序选项的不同而不同。</li>
</ul>
</li>
<li>用来存储多字节整数和浮点值的二进制格式在不同的系统结构间也可能不同。</li>
</ul>
<h2 id="定位流"><a href="#定位流" class="headerlink" title="定位流"></a>定位流</h2><p>有3种方法定位标准I/O流。</p>
<ul>
<li><code>ftell</code>和<code>fseek</code>函数。这两个函数都假定文件的位置可以存放在一个长整型中。</li>
<li><code>ftello</code>和<code>fseeko</code>函数。这两个函数使文件偏移量可以不必一定使用长整型。它们使用<code>off_t</code>数据类型代替了长整型。</li>
<li><code>fgetpos</code>和<code>fsetpos</code>函数。这两个函数使用一个抽象数据类型<code>fpos_t</code>记录文件的位置。这种数据类型可以根据需要定义为一个足够大的数，用以记录文件位置。</li>
</ul>
<p>需要移植到非UNIX系统上运行的应用程序应当使用<code>fgetpos</code>和<code>fsetpos</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">ftell</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回当前文件位置指示；若出错，返回-1L</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fseek</span><span class="params">(FILE *fp， <span class="type">long</span> offset， <span class="type">int</span> whence)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rewind</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>对于一个二进制文件，其文件位置指示器是从文件起始位置开始度量，并以字节为度量单位的。<code>ftell</code>用于二进制文件时，其返回值就是这种字节位置。为了用<code>fseek</code>定位一个二进制文件，必须指定一个字节<code>offset</code>，以及解释这种偏移量的方式。<code>whence</code>的值与<code>lseek</code>函数的相同：<code>SEEK_SET</code>表示从文件的起始位置开始，<code>SEEK_CUR</code>表示从当前文件位置开始，<code>SEEK_END</code>表示从文件的尾端开始。</p>
<p>对于文本文件，它们的文件当前位置可能不以简单的字节偏移量来度量。这主要也是在非UNIX系统中，它们可能以不同的格式存放文本文件。为了定位一个文本文件，<code>whence</code>一定要是<code>SEEK_SET</code>。而且<code>offset</code>只能有两种值，0(后退到文件的起始位置)，或是对该文件的<code>ftell</code>所返回的值。使用<code>rewind</code>函数也可将一个流设置到文件的起始位置。</p>
<p>除了偏移量的类型是<code>off_t</code>而非<code>long</code>以外，<code>ftello</code>函数与<code>ftell</code>相同，<code>fseeko</code>函数与<code>fseek</code>相同。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">off_t</span> <span class="title">ftello</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回当前文件位置，若出错，返回(off_t)-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fseeko</span><span class="params">(FILE *fp， <span class="type">off_t</span> offset， <span class="type">int</span> whence)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>实现可将<code>off_t</code>类型定义为长于32位。</p>
<p><code>fgetpos</code>和<code>fsetpos</code>两个函数是ISO C标准引入的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fgetpos</span><span class="params">(FILE *restrict fp， fpos_e *restrict pos)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fsetpos</span><span class="params">(FILE *fp， <span class="type">const</span> <span class="type">fpos_t</span> *pos)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值。若成功。返回0:若出错，返回非0</span></span><br></pre></td></tr></table></figure></p>
<p><code>fgetpos</code>将文件位置指示器的当前值存入由<code>pos</code>指向的对象中。在以后调用<code>fsetpos</code>时，可以使用此值将流重新定位至该位置</p>
<h2 id="格式化I-O"><a href="#格式化I-O" class="headerlink" title="格式化I/O"></a>格式化I/O</h2><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p>格式化输出是由5个printf函数来处理的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *restrict format， ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fprintf</span><span class="params">(FILE *restzict fp， <span class="type">const</span> <span class="type">char</span> *restrict format， ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dprintf</span><span class="params">(<span class="type">int</span> fd， <span class="type">const</span> <span class="type">char</span> *restrict format， ...)</span></span>;</span><br><span class="line"><span class="comment">// 3个函数返回值：若成功，返回输出字符数：若输出出错，返回负值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sprintf</span><span class="params">(<span class="type">char</span> *restrict buf， <span class="type">const</span> <span class="type">char</span> *restrict format， ...)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回存入数组的字符数；若编码出错，返回负值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">snprintr</span><span class="params">(<span class="type">char</span> *restrict buf， <span class="type">size_t</span> m， <span class="type">const</span> <span class="type">char</span> *restrict format， ...)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若缓冲区足够大，返回将要存入数组的字符数；若编码出错，返回负值</span></span><br></pre></td></tr></table></figure></p>
<p><code>printf</code>将格式化数据写到标准输出，<code>fprintf</code>写至指定的流，<code>dprintf</code>写至指定的文件描述符，<code>sprintf</code>将格式化的字符送入数组<code>buf</code>中。<code>sprintf</code>在该数组的尾端自动加一个null字节，但该字符不包括在返回值中。</p>
<p>注意，<code>sprintf</code>函数可能会造成由<code>buf</code>指向的缓冲区的溢出。为了解决这种缓冲区溢出问题，引入了<code>snprintf</code>函数。在该函数中，缓冲区长度是一个显式参数，超过缓冲区尾的所有字符都被丢弃。如果缓冲区足够大，<code>snprintf</code>函数就会返回写入缓冲区的字符数。与<code>sprintf</code>相同，该返回值不包括结尾的null字节。若<code>snprintf</code>函数返回小于缓冲区长度n的正值，那么没有截断输出。若发生了一个编码的错误，<code>snprintf</code>返回负值。</p>
<p>虽然<code>dprintf</code>不处理文件指针，但我们仍然把它包括在处理格式化输出的函数中。注意，使用<code>dprintf</code>不需要调用<code>fdopen</code>将文件描述符转换为文件指针。</p>
<p>格式说明控制其余参数如何编写，以后又如何显示。每个参数按照转换说明编写，转换说明以百分号<code>%</code>开始，除转换说明外，格式字符串中的其他字符将按原样，不经任何修改被复制输出。转换说明有4个可选择的部分，下面将它们都示于方括号中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[flags] [fldwidth] [precision] [lenmodifier]convtype</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>‘</code></td>
<td>(撇号)将整数按千位分组字符</td>
</tr>
<tr>
<td><code>-</code></td>
<td>在字段内左对齐输出</td>
</tr>
<tr>
<td><code>+</code></td>
<td>总是显示带符号转换的正负号</td>
</tr>
<tr>
<td><code>(空格)</code></td>
<td>如果第一个字符不是正负号，则在其前面加上一个空格</td>
</tr>
<tr>
<td><code>#</code></td>
<td>指定另一种转换形式(例如。对于十六进制格式，加0x前缀</td>
</tr>
<tr>
<td><code>0</code></td>
<td>添加前号0(而非空格)进行填充</td>
</tr>
</tbody>
</table>
</div>
<p><code>fldwidth</code>说明最小字段宽度。转换后参数字符数若小于宽度，则多余字符位置用空格填充。字段宽度是一个非负十进制数，或是一个星号<code>*</code>。<code>precision</code>说明整型转换后最少输出数字位数、浮点数转换后小数点后的最少位数、 字符串转换后最大字节数。精度是一个点<code>.</code>，其后跟随一个可选的非负十进制数或一个星号<code>*</code>。</p>
<p>宽度和精度字段两者皆可为<code>*</code>。此时，一个整型参数指定宽度或精度的值。该整型参数正好位于被转换的参数之前。<code>lenmodifier</code>说明参数长度。其可能的值示于表中。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>长度修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>hh</td>
<td>将相应的参数按signed或unsigned char类型输出</td>
</tr>
<tr>
<td>h</td>
<td>将相应的参数按signed成unelgned short类型输出</td>
</tr>
<tr>
<td>l</td>
<td>将相应的参数按signed或unsigned long或宽字符类型输出</td>
</tr>
<tr>
<td>ll</td>
<td>将相应的参数按signed或unsigned long long类型输出</td>
</tr>
<tr>
<td>j</td>
<td>intmax_t或uintmax_t</td>
</tr>
<tr>
<td>z</td>
<td>size_t</td>
</tr>
<tr>
<td>t</td>
<td>ptrdiff_t</td>
</tr>
<tr>
<td>L</td>
<td>long double</td>
</tr>
</tbody>
</table>
</div>
<p><code>convtype</code>不是可选的。它控制如何解释参数。下表中列出了各种转换类型字符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>转换类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>d、i</td>
<td>有符号十进制</td>
</tr>
<tr>
<td>o</td>
<td>无符号八进制</td>
</tr>
<tr>
<td>u</td>
<td>无符号十进制</td>
</tr>
<tr>
<td>x、X</td>
<td>无符号十六进制</td>
</tr>
<tr>
<td>f、F</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td>e、E</td>
<td>指数格式双精度浮点数</td>
</tr>
<tr>
<td>g、G</td>
<td>根据转换后的值解释为f、F、e或E</td>
</tr>
<tr>
<td>a、A</td>
<td>十六进制指数格式双精度浮点数</td>
</tr>
<tr>
<td>c</td>
<td>字符(若带长度修饰符l，为宽字符)</td>
</tr>
<tr>
<td>s</td>
<td>字符串(若带长度修饰符l，为宽字符)</td>
</tr>
<tr>
<td>p</td>
<td>指向void的指针</td>
</tr>
<tr>
<td>n</td>
<td>到目前为止，此printf调用输出的字符的数目将被写入到指针所指向的带符号整型中</td>
</tr>
<tr>
<td>%</td>
<td>一个%字符</td>
</tr>
<tr>
<td>C</td>
<td>宽字符(XSI扩展，等效于lc)</td>
</tr>
<tr>
<td>S</td>
<td>宽字符串(XSI扩展，等效于ls)</td>
</tr>
</tbody>
</table>
</div>
<p>下列5种<code>printf</code>族的变体类似于上面的5种，但是可变参数表(…)替换成了arg。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vprintf</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format， va_list arg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfprintf</span> <span class="params">(FILE *<span class="keyword">restrict</span> fp， <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format， va_list arg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vdprintf</span><span class="params">(<span class="type">int</span> fd， <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format， va_list arg)</span>;</span><br><span class="line"><span class="comment">// 所有3个函数返回值，若成功，返回输出字符数；若输出出错，返回负值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *<span class="keyword">restrict</span> buf， <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format， va_list arg)</span>;</span><br><span class="line"><span class="comment">// 函数返回值。若成功，返回存入数组的字符数，若编码出错，返回负值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vsnprintf</span> <span class="params">(<span class="type">char</span> *<span class="keyword">restrict</span> buf， <span class="type">size_t</span> m， <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format， va_list arg)</span>;</span><br><span class="line"><span class="comment">// 函数返回值。若缓冲区足够大，返回存入数组的字特数：若编码出错，返回负值</span></span><br></pre></td></tr></table></figure></p>
<h3 id="格式化输入"><a href="#格式化输入" class="headerlink" title="格式化输入"></a>格式化输入</h3><p>执行格式化输入处理的是3个<code>scanf</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format， ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp， <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format， ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> buf， <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format， ...)</span>;</span><br><span class="line"><span class="comment">// 3个函数返回值，赋值的输入项数：若输入出错或在任一转换前已到达文件尾墙，返回EOF</span></span><br></pre></td></tr></table></figure></p>
<p>scanf族用于分析输入字符串，并将字符序列转换成指定类型的变量。在格式之后的各参数包含了变量的地址，用转换结果对这些变量赋值。</p>
<p>格式说明控制如何转换参数，以便对它们赋值。转换说明以<code>*</code>字符开始。除转换说明和空白字符外，格式字符串中的其他字符必须与输入匹配。若有一个字符不匹配，则停止后续处理，不再读输入的其余部分。</p>
<p>一个转换说明有3个可选择的部分，下面将它们都示于方括号中：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[*| [fldwidth] [m] [lenmodifier)convtype</span><br></pre></td></tr></table></figure></p>
<p>可选择的星号<code>*</code>用于抑制转换。按照转换说明的其余部分对输入进行转换，但转换结果并不存放在参数中。</p>
<p><code>fldwidth</code>说明最大宽度(即最大字符数)。<code>lenmodifier</code>说明要用转换结果赋值的参数大小。由<code>printf</code>函数族支持的长度修饰符同样得到scanf族函数的支持。</p>
<p><code>convtype</code>字段类似于<code>printf</code>族的转换类型字段，但两者之间还有些差别。一个差别是，作为一种选项，输入中带符号的可赋予无符号类型。例如，输入流中的-1可被转换成4294967295赋予无符号整型变量。</p>
<p>在字段宽度和长度修饰符之间的可选项<code>m</code>是赋值分配符。它可以用于<code>%c</code>、<code>%s</code>以及<code>%[</code>转换符，迫使内存缓冲区分配空间以接纳转换字符串。在这种情况下，相关的参数必须是指针地址，分配的缓冲区地址必须复制给该指针。如果调用成功，该缓冲区不再使用时，由调用者负责通过调用<code>free</code>函数来释放该缓冲区。</p>
<p>与<code>printf</code>族相同，<code>scanf</code>族也使用由<code>&lt;stdarg.h&gt;</code>说明的可变长度参数表。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format， va_list arg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfscant</span><span class="params">(FILE *<span class="keyword">restrict</span> fp， <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format， va_list arg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vsscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> buf， <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format， va_list arg)</span>;</span><br><span class="line"><span class="comment">// 3个函数返回值，指定的输入项目数；若输入出错或在任一转换前文件结束。返回EOF</span></span><br></pre></td></tr></table></figure></p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>在UNIX中，标准I/O库最终都要调用第3章中说明的I/O例程，每个标准I/O流都有一个与其相关联的文件描述符，可以对一个流调用<code>fileno</code>函数以获得其描述符。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fileno</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="comment">// 返回值：与该流相关联的文件描述符</span></span><br></pre></td></tr></table></figure></p>
<p>如果要调用<code>dup</code>或<code>fcntl</code>等函数，则需要此函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>	<span class="title function_">pr_stdio</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, FILE *)</span>;</span><br><span class="line"><span class="type">int</span>		<span class="title function_">is_unbuffered</span><span class="params">(FILE *)</span>;</span><br><span class="line"><span class="type">int</span>		<span class="title function_">is_linebuffered</span><span class="params">(FILE *)</span>;</span><br><span class="line"><span class="type">int</span>		<span class="title function_">buffer_size</span><span class="params">(FILE *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE	*fp;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fputs</span>(<span class="string">&quot;enter any character\n&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">if</span> (getchar() == EOF)</span><br><span class="line">		err_sys(<span class="string">&quot;getchar error&quot;</span>);</span><br><span class="line">	<span class="built_in">fputs</span>(<span class="string">&quot;one line to standard error\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line"></span><br><span class="line">	pr_stdio(<span class="string">&quot;stdin&quot;</span>,  <span class="built_in">stdin</span>);</span><br><span class="line">	pr_stdio(<span class="string">&quot;stdout&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	pr_stdio(<span class="string">&quot;stderr&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;/etc/passwd&quot;</span>, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;fopen error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (getc(fp) == EOF)</span><br><span class="line">		err_sys(<span class="string">&quot;getc error&quot;</span>);</span><br><span class="line">	pr_stdio(<span class="string">&quot;/etc/passwd&quot;</span>, fp);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pr_stdio</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name， FILE *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;stream = %s， &quot;</span>, name);</span><br><span class="line">	<span class="keyword">if</span> (is_unbuffered(fp))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;unbuffered&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (is_linebuffered(fp))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;line buffered&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">/* if neither of above */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fully buffered&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;, buffer size = %d\n&quot;</span>, buffer_size(fp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The following is nonportable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_IO_UNBUFFERED)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">is_unbuffered</span><span class="params">(FILE *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(fp-&gt;_flags &amp; _IO_UNBUFFERED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">is_linebuffered</span><span class="params">(FILE *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(fp-&gt;_flags &amp; _IO_LINE_BUF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">buffer_size</span><span class="params">(FILE *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(__SNBF)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">is_unbuffered</span><span class="params">(FILE *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(fp-&gt;_flags &amp; __SNBF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">is_linebuffered</span><span class="params">(FILE *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(fp-&gt;_flags &amp; __SLBF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">buffer_size</span><span class="params">(FILE *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(fp-&gt;_bf._size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_IONBF)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LP64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _flag __pad[4]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ptr __pad[1]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _base __pad[2]</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">is_unbuffered</span><span class="params">(FILE *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(fp-&gt;_flag &amp; _IONBF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">is_linebuffered</span><span class="params">(FILE *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(fp-&gt;_flag &amp; _IOLBF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">buffer_size</span><span class="params">(FILE *fp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LP64</span></span><br><span class="line">	<span class="keyword">return</span>(fp-&gt;_base - fp-&gt;_ptr);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span>(BUFSIZ);	<span class="comment">/* just a guess */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> unknown stdio implementation!</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>注意，在打印缓冲状态信息之前，先对每个流执行I/O操作，第一个I/O操作通常就造成为该流分配缓冲区。</p>
<p>如果运行程序两次，一次使3个标准流与终端相连接，另一次使它们重定向到普通文件，则所得结果是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out   <span class="comment"># stdin， atdout和stderr都连至终端</span></span><br><span class="line">enter any character</span><br><span class="line"></span><br><span class="line">one line to standard error</span><br><span class="line">stream = stdin， line buffered， buffer size = 1024</span><br><span class="line">stream = atdout， line buffered， butter size = 1024</span><br><span class="line">stream = stderr， unbuffered， buffer size = 1</span><br><span class="line">stream = /etc/passwd， fully butfered， buffer 8120 = 4096</span><br><span class="line">$ ./a.out &lt; /etc/group &gt; std.out 2&gt; atd.ext</span><br><span class="line"><span class="comment"># 3个流都重定向，再次运行该程序</span></span><br><span class="line">$ <span class="built_in">cat</span> std.err</span><br><span class="line">one line to standard error</span><br><span class="line">$ <span class="built_in">cat</span> std.out</span><br><span class="line">enter any character</span><br><span class="line">stream = stdin， fully buffered， buffer size = 4096</span><br><span class="line">stream = stdout， fully buffered， buffer size = 4096</span><br><span class="line">strean = stderr， unbuffered， buffer size = 1</span><br><span class="line">stream = /etc/passwd， fully buffered， buffer size = 4096</span><br></pre></td></tr></table></figure></p>
<p>从中可见，该系统的默认是：当标准输入、输出连至终端时，它们是行缓冲的。行缓冲的长度是1024字节。注意，这并没有将输入、输出的行长限制为1024字节，这只是缓冲区的长度。如果要将2048字节的行写到标准输出，则要进行两次write系统调用。当将这两个流重新定向到普通文件时，它们就变成是全缓冲的，其缓冲区长度是该文件系统优先选用的I/O长度(从<code>stat</code>结构中得到的<code>st_blksize</code>值)。从中也可看到，标准错误如它所应该的那样是不带缓冲的，而普通文件按系统默认是全缓冲的。</p>
<h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><p>ISO C标准I/O库提供了两个函数以帮助创建临时文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">tmpnam</span><span class="params">(<span class="type">char</span> *ptr)</span>;</span><br><span class="line"><span class="comment">// 返回值，指向唯一路径名的指针</span></span><br><span class="line">FILE *<span class="title function_">tmptile</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回文件指针；若出错，返回NULL</span></span><br></pre></td></tr></table></figure></p>
<p><code>tmpnam</code>函数产生一个与现有文件名不同的一个有效路径名字符串。每次调用它时，都产生一个不同的路径名，最多调用次数是<code>TMP_MAX</code>。<code>TMP_MAX</code>定义在<code>&lt;stdio.h&gt;</code>中。虽然ISO C定义了<code>TMP_MAX</code>，但该标准只要求其值至少应为25。</p>
<p>若<code>ptr</code>是NULL，则所产生的路径名存放在一个静态区中，指向该静态区的指针作为函数值返回。后续调用<code>tmpnam</code>时，会重写该静态区(这意味着，如果我们调用此函数多次，而且想保存路径名，则我们应当保存该路径名的副本，而不是指针的副本)。如若<code>ptr</code>不是NULL，则认为它应该是指向长度至少是<code>L_tmpnam</code>个字符的数组(常量<code>L_tmpnam</code>定义在头文件<code>&lt;stdio.h&gt;</code>中)。所产生的路径名存放在该数组中，pr也作为函数值返回。</p>
<p><code>tmpfile</code>创建一个临时二进制文件(类型<code>wb+</code>)，在关闭该文件或程序结束时将自动删除这种文件。注意，UNIX对二进制文件不进行特殊区分。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">char</span> name[L_tmpnam]， line[MAX_LINE];</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, tmpnam(<span class="literal">NULL</span>) );</span><br><span class="line">	<span class="comment">/* tiret temp nane */</span></span><br><span class="line">	tmpnam(name);</span><br><span class="line">	<span class="comment">/*second temp name */</span></span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%s\n&quot;</span>, name);</span><br><span class="line">	<span class="keyword">if</span> ((fp = tmpfile()) == <span class="literal">NULL</span>)</span><br><span class="line">	<span class="comment">/*create temp file */</span></span><br><span class="line">	err_sys(<span class="string">&quot;tmpfile error&quot;</span>);</span><br><span class="line">	<span class="built_in">fputs</span>(<span class="string">&quot;one line of outputin&quot;</span>, fp);<span class="comment">/*write to temp file */</span></span><br><span class="line">	rewind(tp);</span><br><span class="line">	<span class="keyword">if</span> (fgets(line， <span class="keyword">sizeof</span>(line), fp) == <span class="literal">NULL</span>)</span><br><span class="line">	<span class="comment">/* then read it back */</span></span><br><span class="line">	err_sys (<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">	<span class="built_in">fputs</span>(line， <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="comment">/* print the line we wrote */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>tmpfile</code>函数经常使用的标准UNIX技术是先调用<code>tmpnam</code>产生一个唯一的路径名，然后，用该路径名创建一个文件，并立即<code>unlink</code>它。对一个文件解除链接并不删除其内容，关闭该文件时才删除其内容。而关闭文件可以是显式的，也可以在程序终止时自动进行。</p>
<p>Single UNIX Specification为处理临时文件定义了另外两个函数： <code>mkdtemp</code>和<code>mkstemp</code>，它们是XSI的扩展部分。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atd11b.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">mkdtemp</span><span class="params">(<span class="type">char</span> *template)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回指向目录名的指针；若出错，返回NULL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkstemp</span><span class="params">(<span class="type">char</span> *template)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回文件描述符，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>mkdtemp</code>函数创建了一个目录，该目录有一个唯一的名字；<code>mkstemp</code>函数创建了一个文件，该文件有一个唯一的名字。名字是通过template字符串进行选择的。这个字符串是后6位设置为xxxxxx的路径名。函数将这些占位符替换成不同的字符来构建一个唯一的路径名。如果成功的话，这两个函数将修改<code>template</code>字符串反映临时文件的名字。</p>
<p>由<code>mkdtemp</code>函数创建的目录使用下列访问权限位集：<code>S_IRUSR | S_IWUSR | S_IXUSR</code>。注意，调用进程的文件模式创建屏蔽字可以进一步限制这些权限。如果目录创建成功，<code>mkdtemp</code>返回新目录的名字。</p>
<p><code>mkstemp</code>函数以唯一的名字创建一个普通文件并，且打开该文件，该函数返回的文件描述符以读写方式打开。由<code>mkstemp</code>创建的文件使用访问权限位<code>S_IRUSR | S_IWUSR</code>。与<code>temptile</code>不同，<code>mkstemp</code>创建的临时文件并不会自动删除。如果希望从文件系统命名空间中删除该文件，必须自己对它解除链接。</p>
<p>使用<code>tmpnam</code>和<code>tempnam</code>至少有一个缺点：在返回唯一的路径名和用该名字创建文件之间存在一个时间窗口，在这个时间窗口中，另一进程可以用相间的名字创建文件。因此应该使用<code>tmpfile</code>和<code>mkstemp</code>函数，因为它们不存在这个问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">make_temp</span><span class="params">(<span class="type">char</span> *template)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>	good_template[] = <span class="string">&quot;/tmp/dirXXXXXX&quot;</span>;	<span class="comment">/* right way */</span></span><br><span class="line">	<span class="type">char</span>	*bad_template = <span class="string">&quot;/tmp/dirXXXXXX&quot;</span>;	<span class="comment">/* wrong way*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;trying to create first temp file...\n&quot;</span>);</span><br><span class="line">	make_temp(good_template);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;trying to create second temp file...\n&quot;</span>);</span><br><span class="line">	make_temp(bad_template);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">make_temp</span><span class="params">(<span class="type">char</span> *template)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>			fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span>	<span class="title">sbuf</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fd = mkstemp(template)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;can&#x27;t create temp file&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;temp name = %s\n&quot;</span>, template);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">if</span> (stat(template， &amp;sbuf) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (errno == ENOENT)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;file doesn&#x27;t exist\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			err_sys(<span class="string">&quot;stat failed&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file exists\n&quot;</span>);</span><br><span class="line">		unlink(template);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，得到：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">trying to create tirmt temp file...</span><br><span class="line">temp name = /tmp/dirUmBT7h</span><br><span class="line">file exists</span><br><span class="line">trying to create second temp file..</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure></p>
<p>两个模板字符串声明方式的不同带来了不同的运行结果。对于第一个模板，因为使用了数组，名字是在栈上分配的。但第二种情况使用的是指针，在这种情况下，只有指针自身驻留在栈上。编译器把字符串存放在可执行文件的只读段，当<code>mkstemp</code>函数试图修改字符申时，出现了段错误。</p>
<h2 id="内存流"><a href="#内存流" class="headerlink" title="内存流"></a>内存流</h2><p>我们已经看到，标准I/O库把数据缓存在内存中，因此每次一字符和每次一行的I/O更有效。我们也可以通过调用<code>setbuf</code>或<code>setvbuf</code>函数让I/O库使用我们自己的缓冲区。在SUSv4中支持了内存流。这就是标准I/O流，虽然仍使用FILE指针进行访问，但其实并没有底层文件。所有的I/O都是通过在缓冲区与主存之间来回传送字节来完成的。即便这些流看起来像文件流，它们的某些特征使其更适用于字符串操作。</p>
<p>有3个函数可用于内存流的创建，第一个是<code>fmemopen</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">fmemopen</span> <span class="params">(<span class="type">void</span> *<span class="keyword">restrict</span> buf， <span class="type">size_t</span> size， <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> type)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回流指针，若错误，返回NULL</span></span><br></pre></td></tr></table></figure></p>
<p><code>fmemopen</code>函数允许调用者提供缓冲区用于内存流：<code>buf</code>参数指向缓冲区的开始位置，<code>size</code>参数指定了缓冲区大小的字节数。如果<code>buf</code>参数为空， <code>fmemopen</code>函数分配<code>size</code>字节数的缓冲区。在这种情况下，当流关闭时缓冲区会被释放。</p>
<p><code>type</code>参数控制如何使用流。type可能的取值如表。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>type</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>r或rb</td>
<td>为读而打开</td>
</tr>
<tr>
<td>w或wb</td>
<td>为写而打开</td>
</tr>
<tr>
<td>a或ab</td>
<td>追加：为在第一个null字节处写而打开</td>
</tr>
<tr>
<td>r+或r+b或rb+</td>
<td>为读和写打开</td>
</tr>
<tr>
<td>w+或w+b或wb+</td>
<td>把文件截断至0长，为读和写而打开</td>
</tr>
<tr>
<td>a+或a+b或ab+</td>
<td>追加：为在第一个null字节处读和写打开</td>
</tr>
</tbody>
</table>
</div>
<p>注意，这些取值对应于基于文件的标准I/O流的type参数取值，但其中有些微小差别。第一，无论何时以追加写方式打开内存流时，当前文件位置设为缓冲区中的第一个null字节。如果缓冲区中不存在null字节，则当前位置就设为缓冲区结尾的后一个字节。当流并不是以追加写方式打开时，当前位置设为缓冲区的开始位置。因为追加写模式通过第一个null字节确定数据的尾端，内存流并不适合存储二进制数据(二进制数据在数据尾端之前就可能包含多个null字节)。</p>
<p>第二，如果buf参数是一个null指针，打开流进行读或者写都没有任何意义。因为在这种情况下缓冲区是通过<code>fmemopen</code>进行分配的，没有办法找到缓冲区的地址，只写方式打开流意味着无法读取已写入的数据，同样，以读方式打开流意味着只能读取那些我们无法写入的缓冲区中的数据。</p>
<p>第三，任何时候需要增加流缓冲区中数据量以及调用<code>fclose</code>、<code>fflush</code>、<code>fseek</code>、<code>fseeko</code>以及<code>fsetpos</code>时都会在当前位置写入一个null字节。</p>
<p>看一下对内存流的写入是如何在我们自己提供的缓冲区上进行操作的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSZ 48</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="type">char</span> buf[BSZ];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(buf， <span class="string">&#x27;a&#x27;</span>, BSZ<span class="number">-2</span>);</span><br><span class="line">	buf[BSZ<span class="number">-2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	buf[BSZ<span class="number">-1</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> ((fp = fmemopen(buf， BSZ， <span class="string">&quot;w+&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;fmemopen failed&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;initial buffer contents: %s\n&quot;</span>, buf);</span><br><span class="line">	<span class="built_in">fprintf</span>(fp， <span class="string">&quot;hello， world&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;before flush: %s\n&quot;</span>, buf);</span><br><span class="line">	fflush(fp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;after fflush: %s\n&quot;</span>, buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;len of string in buf = %ld\n&quot;</span>, (<span class="type">long</span>)<span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(buf， <span class="string">&#x27;b&#x27;</span>, BSZ<span class="number">-2</span>);</span><br><span class="line">	buf[BSZ<span class="number">-2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	buf[BSZ<span class="number">-1</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">	<span class="built_in">fprintf</span>(fp， <span class="string">&quot;hello， world&quot;</span>);</span><br><span class="line">	fseek(fp， <span class="number">0</span>， SEEK_SET);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;after  fseek: %s\n&quot;</span>, buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;len of string in buf = %ld\n&quot;</span>, (<span class="type">long</span>)<span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(buf， <span class="string">&#x27;c&#x27;</span>, BSZ<span class="number">-2</span>);</span><br><span class="line">	buf[BSZ<span class="number">-2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	buf[BSZ<span class="number">-1</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">	<span class="built_in">fprintf</span>(fp， <span class="string">&quot;hello， world&quot;</span>);</span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;after fclose: %s\n&quot;</span>, buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;len of string in buf = %ld\n&quot;</span>, (<span class="type">long</span>)<span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用于创建内存流的其他两个函数分别是<code>open_memstream</code>和<code>open_wmemstream</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">open_memstream</span><span class="params">(<span class="type">char</span> **bufp， <span class="type">size_t</span> *sizep)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wchar.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">open_wmemstream</span><span class="params">(<span class="type">wchar_t</span> **bufp， <span class="type">size_t</span> *sizep)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回流指针；若出错，返回NULL。</span></span><br></pre></td></tr></table></figure></p>
<p><code>open_memstream</code>函数创建的流是面向字节的，<code>open_wmemstream</code>函数创建的流是面向宽子节的。这两个函数与<code>fmemopen</code>的不同在于：</p>
<ul>
<li>创建的流只能打开；</li>
<li>不能指定自己的缓冲区，但可以分别通过<code>bufp</code>和<code>sizep</code>参数访问缓冲区地址和大小；</li>
<li>关闭流后需要自行释放缓冲区；</li>
<li>对流添加子节会增加缓冲区大小。</li>
</ul>
<p>但是在对缓冲区地址和大小使用必须遵循：</p>
<ul>
<li>缓冲区地址和长度只有在调用<code>fclose</code>或<code>fflush</code>后才有用；</li>
<li>这些值只有在下一次流写入或调用<code>fclose</code>前才有用。</li>
</ul>
<p>因为缓冲区可以增长，可能需要重新分配，所以缓冲区的内存地址在下一次调用<code>fclose</code>或<code>fflush</code>时会改变。</p>
<h1 id="系统数据文件和信息"><a href="#系统数据文件和信息" class="headerlink" title="系统数据文件和信息"></a>系统数据文件和信息</h1><h2 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h2><p>UNIX系统的正常运作需要使用大量与系统有关的数据文件，例如，口令文件<code>/etc/passwd</code>和组文件<code>/etc/group</code>就是经常被多个程序频繁使用的两个文件。由于历史原因，这些数据文件都是ASCII文本文件，并且使用标准I/O库读这些文件。但是，对于较大的系统，顺序扫描口令文件很花费时间，我们需要能够以非ASCII文本格式存放这些文件，但仍向使用其他文件格式的应用程序提供接口。</p>
<h2 id="口令文件"><a href="#口令文件" class="headerlink" title="口令文件"></a>口令文件</h2><p>UNIX系统口令文件包含了表中所示的各字段，这些字段包含在<code>&lt;pwd.h&gt;</code>中定义的<code>passwd</code>结构中。注意，POSIX.1只指定<code>passwd</code>结构包含的10个字段中的5个。大多数平台至少支持其中7个字段。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>说明</th>
<th><code>struct passwd</code>成员</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户名</td>
<td><code>char *pw_name</code></td>
</tr>
<tr>
<td>加密口令</td>
<td><code>char *pw_passed</code></td>
</tr>
<tr>
<td>数值用户ID</td>
<td><code>uid_t pw_uid</code></td>
</tr>
<tr>
<td>数值组ID</td>
<td><code>gid_t pw_gid</code></td>
</tr>
<tr>
<td>注释字段</td>
<td><code>char *pw_gecos</code></td>
</tr>
<tr>
<td>初始工作日录</td>
<td><code>char *pw_dir</code></td>
</tr>
<tr>
<td>初始shell</td>
<td><code>char *pw_shell</code></td>
</tr>
<tr>
<td>用户访问类</td>
<td><code>char *pw_class</code></td>
</tr>
<tr>
<td>下次更改口令时间</td>
<td><code>time_t pw_change</code></td>
</tr>
<tr>
<td>账户有效期时间</td>
<td><code>time_t pw_expire</code></td>
</tr>
</tbody>
</table>
</div>
<p>口令文件是<code>/etc/passwd</code>，而且是一个ASCII文件。每一行包含各字段，字段之间用冒号分隔。例如，在Linux中，该文件中可能有下列4行:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">squid:x:23:23::/vax/spool/squid:/dev/null</span><br><span class="line">nobody:x:65534:65534:Nobody:/home:/bin/sh</span><br><span class="line">sar:x:205:105:Stephen Rago:/home/sar:/bin/bash</span><br></pre></td></tr></table></figure></p>
<p>关于这些登录项，请注意下列各点:</p>
<ul>
<li>通常有一个用户名为root的登录项，其用户ID是0(超级用户)。</li>
<li>加密口令字段包含了一个占位符。较早期的UNIX系统版本中，该字段存放加密口令字。将加密口令字存放在一个人人可读的文件中是一 个安全性漏洞，所以现在将加密口令字存放在另一个文件中。</li>
<li>口令文件项中的某些字段可能是空。如果加密口令字段为空，这通常就意味着该用户没有口令。<code>squid</code>登录项有一空白字段:注释字段。空白注释字段不产生任何影响。</li>
<li>shell字段包含了一个可执行程序名，它被用作该用户的登录shell。若该字段为空，则取系统默认值，通常是<code>/bin/sh</code>。注意，squid登录项的该字段为/dev/nu11。显然，这是一个设备，不是可执行文件，将其用于此处的目的是，阻止任何人以用户squid的名义登录到该系统。</li>
<li>为了阻止一个特定用户登录系统，替代方法是，将<code>/bin/false</code>用作登录shell。它简单地以不成功(非0)状态终止，该shell将此种终止状态判断为假。另一种常见方法是，用<code>/bin/true</code>禁止一个账户。它所做的一切是以成功(0)状态终止。某些系统提供<code>nologin</code>命令，它打印可定制的出错信息，然后以非0状态终止</li>
<li>使用<code>nobody</code>用户名的一个目的是，使任何人都可登录至系统，但其用户ID(65534)和组ID(65534)不提供任何特权。该用户ID和组ID只能访问人人皆可读、写的文件。</li>
<li>提供<code>finger()</code>命令的某些UNIX系统支持注释字段中的附加信息。其中，各部分之间都用逗号分隔：用户姓名、办公室地点、办公室电话号码以及家庭电话号码等。另外，如果注释字段中的用户姓名是一个<code>&amp;</code>，则它被替换为登录名。例如，可以有下列记录:</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar:x:205:105:Steve Rago, SF 5-121, 555-1111, 555-2222:/home/sar:/bin/sh</span><br></pre></td></tr></table></figure>
<p>使用<code>finger</code>命令就可打印Steve Rago的有关信息。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ finger -p sar</span><br><span class="line">Login: sar</span><br><span class="line">Name: Steve Rago</span><br><span class="line">Directory: /home/sar</span><br><span class="line">shell: /bin/sh</span><br><span class="line">Office: SF 5-121， 555-1111</span><br></pre></td></tr></table></figure></p>
<p>某些系统提供了<code>vipw</code>命令，允许管理员使用该命令编辑口令文件。<code>vipw</code>命令串行化地更改口令文件，并且确保它所做的更改与其他相关文件保持一致。</p>
<p>POSIX.1定义了两个获取口令文件项的函数。在给出用户登录名或数值用户ID后，这两个函数就能查看相关项：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> passwd *<span class="title function_">getpwuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br><span class="line"><span class="keyword">struct</span> passwd *<span class="title function_">getpwnam</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">// 两个函数返回值。若成功。返回指针，若出错，返回NULL</span></span><br></pre></td></tr></table></figure></p>
<p><code>getpwuid</code>函数由ls(1)程序使用，它将inode节点中的数字用户ID映射为用户登录名。在键入登录名时，<code>getpwnam</code>函数由login(1)程序使用。</p>
<p>这两个函数都返回一个指向<code>passwd</code>结构的指针，该结构已由这两个函数在执行时填入信息。<code>passwd</code>结构通常是函数内部的静态变量，只要调用任一相关函数，其内容就会被重写。</p>
<p>如果要查看的只是登录名或用户ID，那么这两个POSIX.1函数能满足要求，但是也有些程序要查看整个口令文件。下列3个函数则可用于此种目的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> passwd *<span class="title function_">getpwent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setpwent</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回值，着成功，返回指针，着出错或到达文件尾端，返回NULL</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">endpwent</span> <span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>调用<code>getpwent</code>时，它返回口令文件中的下一个记录项。它返回一个由它填写好的<code>passwd</code>结构的指针。每次调用此函数时都重写该结构。在第一次调用该函数时，它打开它所使用的各个文件。在使用本函数时，对口令文件中各个记录项的安排顺序并无要求。</p>
<p>函数<code>setpwent</code>反绕它所使用的文件，<code>endpwent</code>则关闭这些文件。在使用<code>getpwent</code>查看完口令文件后，一定要调用<code>endpwent</code>关闭这些文件。<code>getpwent</code>知道什么时间应当打开它所使用的文件(第一次被调用时)，但是它并不知道何时关闭这些文件。</p>
<p>程序给出了<code>getpwnam</code>函数的一个实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> passwd *</span><br><span class="line"><span class="title function_">getpwnam</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">passed</span> *<span class="title">ptr</span>;</span></span><br><span class="line">	setpwent();</span><br><span class="line">	<span class="keyword">while</span> ((ptr = getpwent()) != <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, ptr-&gt;pw_name)  == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">/* found a match */</span></span><br><span class="line">	endpwent ();</span><br><span class="line">	<span class="keyword">return</span>(ptr);</span><br><span class="line">	<span class="comment">/* ptr is NULL if no natch found */</span></span><br></pre></td></tr></table></figure></p>
<p>在函数开始处调用<code>setpwent</code>是自我保护性的措施，以便确保如果调用者在此之前已经调用<code>getpwent</code>打开了有关文件情况下，反绕有关文件使它们定位到文件开始处。<code>getpwnam</code>和<code>getpwuid</code>完成后不应使有关文件仍处于打开状态，所以应调用<code>endpwent</code>关闭它们。</p>
<h2 id="阴影口令"><a href="#阴影口令" class="headerlink" title="阴影口令"></a>阴影口令</h2><p>加密口令是经单向加密算法处理过的用户口令副本。因为此算法是单向的，所以不能从加密口令猜测到原来的口令。对于一个加密口令，找不到一种算法可以将其反变换到明文口令。但是可以对口令进行猜测，将猜测的口令经单向算法变换成加密形式，然后将其与用户的加密口令相比较。</p>
<p>某些系统将加密口令存放在另一个通常称为<strong>阴影口令</strong>(shadow password)的文件中。该文件至少要包含用户名和加密口令，与该口令相关的其他信息也可存放在该文件中。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>说明</th>
<th><code>struct spwd</code>成员</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户登录名</td>
<td><code>char *op_namp</code></td>
</tr>
<tr>
<td>加密口令</td>
<td><code>char *sp_pwdp</code></td>
</tr>
<tr>
<td>上次更改口令以来经过的时间</td>
<td><code>int sp_lstchg</code></td>
</tr>
<tr>
<td>经多少天后允许更改</td>
<td><code>int sp_min</code></td>
</tr>
<tr>
<td>要求更改尚余天数</td>
<td><code>int sp_max</code></td>
</tr>
<tr>
<td>超期警告天数</td>
<td><code>int sp_warn</code></td>
</tr>
<tr>
<td>账户不活动之前尚余天数</td>
<td><code>int sp_inact</code></td>
</tr>
<tr>
<td>账户超期天数</td>
<td><code>int sp_expire</code></td>
</tr>
<tr>
<td>保留</td>
<td><code>unsigned int sp_flag</code></td>
</tr>
</tbody>
</table>
</div>
<p>只有用户登录名和加密口令这两个字段是必须的。其他的字段控制口令更改的频率，或者说口令的衰老以及账户仍然处于活动状态的时间。</p>
<p>阴影口令文件不应是一 般用户可以读取的。仅有少数几个程序需要访问加密口令，如<code>login(1)</code>和<code>passwd(1)</code>，这些程序常常是设置用户ID为root的程序。有了阴影口令后，普通口令文件<code>/etc/passwd</code>可由各用户自由读取。</p>
<p>有另一组函数可用于访问阴影口令文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shadow.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> sped *<span class="title function_">getspnan</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="keyword">struct</span> spwd *<span class="title function_">getspent</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 两个函数返回值，若成功，返回指针；若出错，返回NULL</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setspent</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">endspent</span> <span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="组文件"><a href="#组文件" class="headerlink" title="组文件"></a>组文件</h2><p>UNIX组文件包含了所示字段。这些字段包含在<code>&lt;grp.h&gt;</code>中所定义的group结构中。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>说明</th>
<th><code>struct group</code>成员</th>
</tr>
</thead>
<tbody>
<tr>
<td>组名</td>
<td><code>char *gr_name</code></td>
</tr>
<tr>
<td>加密口令</td>
<td><code>char *qr_passwd</code></td>
</tr>
<tr>
<td>数值组ID</td>
<td><code>int qr_gid</code></td>
</tr>
<tr>
<td>指向各用户名指针的数组</td>
<td><code>char **gr_mem</code></td>
</tr>
</tbody>
</table>
</div>
<p>字段<code>gr_mem</code>是一个指针数组，其中每个指针指向一个属于该组的用户名。该数组以null指针结尾。</p>
<p>可以用下列两个由POSIX.1定义的函数来查看组名或数值组ID.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> group *<span class="title function_">getgrgid</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br><span class="line"><span class="keyword">struct</span> group *<span class="title function_">getgrnam</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">// 两个函数返回值，若成功，返回指针，若出错，返回NULL</span></span><br></pre></td></tr></table></figure></p>
<p>如同对口令文件进行操作的函数一样，这两个函数通常也返回指向一个静态变量的指针，在每次调用时都重写该静态变量。</p>
<p>如果需要搜索整个组文件，则须使用另外几个函数。下列3个函数类似于针对口令文件的3个函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> group *<span class="title function_">getgrent</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回指针；若出错或到达文件尾，返回NULL</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setgrent</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">endgrent</span> <span class="params">(<span class="type">void</span>)</span>,</span><br></pre></td></tr></table></figure></p>
<p><code>setgrent</code>函数打开组文件(如若它尚末被打开)并反绕它。<code>getgrent</code>函数从组文件中读下一个记录，如若该文件尚未打开，则先打开它。<code>endgrent</code>函数关闭组文件。</p>
<h2 id="附属组ID-1"><a href="#附属组ID-1" class="headerlink" title="附属组ID"></a>附属组ID</h2><p>每个用户任何时候都只属于一个组。当用户登录时，系统就按口令文件记录项中的数值组ID，赋给他实际组ID，可以在任何时候执行<code>newgrp(1)</code>以更改组ID，如果<code>newgrp</code>命令执行成功，则实际组ID就更改为新的组ID，它将被用于后续的文件访问权限检查。执行不带任何参数的<code>newgrp</code>，则可返回到原来的组。</p>
<p>BSD引入了附属组ID(supplementary group ID)的概念。我们不仅可以属于口令文件记录项中组ID所对应的组，也可属于多至16个另外的组。文件访问权限检查相应被修改为：不仅将进程的有效组ID与文件的组D相比较，而且也将所有附属组ID与文件的组ID进行比较。</p>
<p>附属组ID是POSIX.1要求的特性。常量<code>NGROUPS_MAX</code>规定了附属组ID的数量，常用值是16。</p>
<p>使用附属组ID的优点是不必再显式地经常更改组。一个用户会参与多个项目，因此也就要同时属于多个组，此类情况是常有的。为了获取和设置附属组ID，提供了下列3个函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getgroups</span> <span class="params">(<span class="type">int</span> gidsetize, <span class="type">gid_t</span> grouplist[])</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回附属组ID数量；若出错，返回-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span> <span class="comment">/* on Linux */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">/* on FreeBSD， Mac os x， and Solaris */</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setgroups</span> <span class="params">(<span class="type">int</span> ngroups, <span class="type">const</span> <span class="type">gid_t</span> grouplist[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">initgroups</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *weemame， <span class="type">gid_t</span> bassgid)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功。返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>getgroups</code>将进程所属用户的各附属组ID填写到数组<code>grouplist</code>中，填写入该数组的附属组ID数最多为<code>gidsetsize</code>个。实际填写到数组中的附属组ID数由函数返回。作为一种特殊情况，如若<code>gidsetsize</code>为0，则函数只返回附属组ID数，而对数组<code>grouplist</code>则不做修改。</p>
<p><code>setgroups</code>可由超级用户调用以便为调用进程设置附属组ID表。<code>grouplist</code>是组ID数组，而<code>ngroups</code>说明了数组中的元素数。<code>ngroups</code>的值不能大于<code>NGROUPS_MAX</code>。通常，只有<code>initgroups</code>函数调用<code>setgroups</code>，<code>initgroups</code>读整个组文件，然后对<code>username</code>确定其组的成员关系。然后，它调用<code>setgroups</code>，以便为该用户初始化附属组ID表。因为<code>initgroups</code>要调用<code>setgroups</code>，所以只有超级用户才能调用<code>initgroups</code>。除了在组文件中找到username是成员的所有组，<code>initgroups</code>也在附属组ID表中包括了<code>basegid</code>。<code>basegid</code>是<code>username</code>在口令文件中的组ID。</p>
<h2 id="其他数据文件"><a href="#其他数据文件" class="headerlink" title="其他数据文件"></a>其他数据文件</h2><p>至此仅讨论了两个系统数据文件——口令文件和组文件。在日常操作中，UNIX系统还使用很多其他文件。记录各网络服务器所提供服务的数据文件(<code>/etc/services</code>)，记录协议信息的数据文件(<code>/etc/protocols</code>)，记录网络信息的数据文件(<code>/etc/networks</code>)。</p>
<p>对于每个数据文件至少有3个函数：</p>
<ul>
<li><code>get</code>函数：读下一个记录，如果需要，还会打开该文件。此种函数通常返回指向一个结构的指针。当已达到文件尾端时返回空指针。大多数<code>get</code>函数返回指向一个静态存储类结构的指针，如果要保存其内容，则需复制它</li>
<li><code>set</code>函数：打开相应数据文件(如果尚末打开)，然后反绕该文件。如果希望在相应文件起始处开始处理，则调用此函数</li>
<li><code>end</code>函数：关闭相应数据文件。如前所述，在结束了对相应数据文件的读、写操作后，总应调用此函数以关闭所有相关文件</li>
</ul>
<p>另外，如果数据文件支持某种形式的键搜索，则也提供搜索具有指定键的记录的例程。例如，对于口令文件，提供了两个按键进行搜索的程序：<code>getpwnam</code>寻找具有指定用户名的记录；<code>getpwuid</code>寻找具有指定用户ID的记录。</p>
<p>下表中列出了一些这样的例程，这些都是UNIX常用的。在表中列出了针对口令文件和组文件的函数。表中也列出了一些与网络有关的函数。对于表中列出的所有<br>数据文件都有get、set和end函数<br><img src="/img/20210522143654.png" alt=""></p>
<h2 id="登录账户记录"><a href="#登录账户记录" class="headerlink" title="登录账户记录"></a>登录账户记录</h2><p>大多数UNIX系统都提供下列两个数据文件：<code>utmp</code>文件记录当前登录到系统的各个用户；<code>wtmp</code>文件跟踪各个登录和注销事件。在V7中，每次写入这两个文件中的是包含下列结构的一个二进制记录：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utmp</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> ut_line[<span class="number">8</span>]， <span class="comment">/* tty line: &quot;ttyho&quot;, &quot;ttydo&quot;, &quot;ttypo&quot;, ... */</span></span><br><span class="line">	<span class="type">char</span> ut_name[<span class="number">8</span>]: <span class="comment">/* login nane */</span></span><br><span class="line">	<span class="type">long</span> ut_time;</span><br><span class="line">	<span class="comment">/* seconds since Epoch */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>登录时，login程序填写此类型结构， 然后将其写入到<code>utmp</code>文件中，同时也将其添写到<code>wtmp</code>文件中。注销时，<code>init</code>进程将<code>utmp</code>文件中相应的记录擦除(每个字节都填以null字节)，并将一个新记录添写到<code>wtmp</code>文件中。在<code>wtmp</code>文件的注销记录中，<code>ut_name</code>字段清除为0。在系统再启动时，以及更改系统时间和日期的前后，都在<code>wtmp</code>文件中追加写特殊的记录项。<code>who(1)</code>程序读取<code>utmp</code>文件，并以可读格式打印其内容，</p>
<h2 id="系统标识"><a href="#系统标识" class="headerlink" title="系统标识"></a>系统标识</h2><p>POSIX.1定义了<code>uname</code>函数，它返回与主机和操作系统有关的信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uname</span><span class="params">(<span class="keyword">struct</span> utsname *name)</span>;</span><br><span class="line"><span class="comment">// 返回值。着成功，返回非负值。着出错，返回一</span></span><br></pre></td></tr></table></figure></p>
<p>通过该函数的参数向其传递一个<code>utsname</code>结构的地址，然后该函数填写此结构。POSIX.1只定义了该结构中最少需提供的字段(它们都是字符数组)，而每个数组的长度则由实现确定。某些实现在该结构中提供了另外一些字段。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> sysname[];  <span class="comment">/* name of the operating system */</span></span><br><span class="line">	<span class="type">char</span> nodename[];  <span class="comment">/* name of this node */</span></span><br><span class="line">	<span class="type">char</span> release[];   <span class="comment">/* current release of operating system */</span></span><br><span class="line">	<span class="type">char</span> version[];   <span class="comment">/* current version of this release */</span></span><br><span class="line">	<span class="type">char</span> machine[];  <span class="comment">/* name of hardware type */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="时间和日期例程"><a href="#时间和日期例程" class="headerlink" title="时间和日期例程"></a>时间和日期例程</h2><p>由UNIX内核提供的基本时间服务是计算自协调世界时(Coordinated Universal Time，UCT)公元1970年1月1日00:00:00这一 特定时间以来经过的秒数。这种秒数是以数据类型<code>time_t</code>表示的，我们称它们为日历时间。日历时间包括时间和日期。UNIX在这方面与其他操作系统的区别是：</p>
<ol>
<li>以协调统一时间而非本地时间计时；</li>
<li>可自动进行转换，如变换到夏令时；</li>
<li>将时间和日期作为一个量值保存。</li>
</ol>
<p><code>time</code>函数返回当前时间和日期。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tine.h&gt;</span></span></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">time</span><span class="params">(<span class="type">time_t</span> *calptr)</span>;</span><br><span class="line"><span class="comment">// 返回值。若成功，返回时间值，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>时间值作为函数值返回。如果参数非空，则时间值也存放在由<code>calptr</code>指向的单元内。</p>
<p>POSXI.1的实时扩展增加了对多个系统时钟的支持。时钟通过<code>clockid_t</code>类型进行标识。下表给出了标准值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标识符</th>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CLOCK_REALTIME</code></td>
<td></td>
<td>实时系统时间</td>
</tr>
<tr>
<td><code>CLOCK_MONOTONIC</code></td>
<td><code>_POSIX_MONOTONIC_CLOCK</code></td>
<td>不带负跳数的实时系统时间</td>
</tr>
<tr>
<td><code>CLOCK_PROCESS_CPUTIMB_ID</code></td>
<td><code>_POSIX_CPUTIME</code></td>
<td>调用进程的CPU时间</td>
</tr>
<tr>
<td><code>CLOCK_THREAD_CPUTIME_ID</code></td>
<td><code>_POSIX_THREAD_CPUTIME</code></td>
<td>调用线程的CPU时间</td>
</tr>
</tbody>
</table>
</div>
<p><code>clock_gettime</code>函数可用于获取指定时钟的时间，返回的时间在<code>timespec</code>结构中，它把时间表示为秒和纳秒。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_gettime</span><span class="params">(<span class="type">clockid_t</span> clock_id, <span class="keyword">struct</span> timespec *tsp)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>当时钟ID设置为<code>CLOCK_REALTIME</code>时，<code>clock_gettime</code>函数提供了与<code>time</code>函数类似的功能，不过在系统支持高精度时间值的情况下，<code>clock_ gettime</code>可能比<code>time</code>函数得到更高精度的时间值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_getres</span> <span class="params">(<span class="type">clockid_t</span> clock_id, <span class="keyword">struct</span> timespec *tsp)</span>;</span><br><span class="line"><span class="comment">// 返回值。若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>clock_getres</code>函数把参数<code>tsp</code>指向的<code>timespec</code>结构初始化为与<code>clock_id</code>参数对应的时钟精度。例如，如果精度为1毫秒，则<code>tv_sec</code>字段就是0，<code>tv_nsec</code>字段就是1000000。</p>
<p>要对特定的时钟设置时间，可以调用<code>clock_settime</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_settime</span><span class="params">(<span class="type">clockid_t</span> clock_id， <span class="type">const</span> <span class="keyword">struct</span> timespec *ap)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>SUSv4指定<code>gettimeofday</code>函数现在已弃用。然而，一些程序仍然使用这个函数，因为与<code>time</code>函数相比，<code>gettimeofday</code>提供了更高的精度(可到微秒级)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gettimeofday</span><span class="params">(<span class="keyword">struct</span> timeval *<span class="keyword">restrict</span> tp, <span class="type">void</span> *<span class="keyword">restrict</span> tzp)</span>;</span><br><span class="line"><span class="comment">// 返回值。总是返回0</span></span><br></pre></td></tr></table></figure></p>
<p><code>tzp</code>的唯一合法值是NULL，其他值将产生不确定的结果。某些平台支持用<code>tzp</code>说明时区，但这完全依实现而定。</p>
<p><code>gettimeofday</code>函数以距特定时间(1970年1月1日00:00:00)的秒数的方式将当前时间存放在<code>tp</code>指向的<code>timeval</code>结构中，而该结构将当前时间表示为秒和微秒。一旦取得这种从上述特定时间经过的秒数的整型时间值后，通常要调用函数将其转换为分解的时间结构，然后调用另一个函数生成人们可读的时间和日期。图6-9说明了各种时间函数之间的关系。(图中以虚线表示的3个函数<code>localtime</code>、<code>mktime</code>和<code>strftime</code>都受到环境变量<code>TZ</code>的影响)</p>
<p>两个函数<code>localtime</code>和<code>gmtime</code>将日历时间转换成分解的时间，并将这些存放在一个<code>tm</code>结构中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span>     <span class="comment">/* a broken-down time */</span></span><br><span class="line">	<span class="type">int</span> tm_sec; <span class="comment">/* seconds after the minute: [0 - 60] */</span></span><br><span class="line">	<span class="type">int</span> tm_min; <span class="comment">/* minutes after the hour: [0 - 59] */</span></span><br><span class="line">	<span class="type">int</span> tm_hour;<span class="comment">/* hours after midnight: [0 - 23] */</span></span><br><span class="line">	<span class="type">int</span> tm_mday;<span class="comment">/* day of the month: [1 - 31] */</span></span><br><span class="line">	<span class="type">int</span> tm_mon; <span class="comment">/* months since January: [0 - 11] */</span></span><br><span class="line">	<span class="type">int</span> tm_year;<span class="comment">/* years since 1900 */</span></span><br><span class="line">	<span class="type">int</span> tm_wday;<span class="comment">/* days since Sunday: [0 - 6] */</span></span><br><span class="line">	<span class="type">int</span> tm_yday;<span class="comment">/* days since January 1: [0 - 365]  */</span></span><br><span class="line">	<span class="type">int</span> tm_isdst;<span class="comment">/* daylight saving time tiag: &lt;0， 0， &gt;0 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>秒可以超过59的理由是可以表示润秒。注意，除了月日字段，其他字段的值都以0开始。如果夏令时生效，则夏令时标志值为正。如果为非夏令时时间，则该标志值为0；如果此信息不可用，则其值为负。</p>
<p><img src="/img/20210522150750.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *calptr)</span>;</span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *calper)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：指向分解的tm结构的指针，若出错，返回NULL</span></span><br></pre></td></tr></table></figure>
<p><code>localtime</code>和<code>gmtime</code>之间的区别是：<code>localtime</code>将日历时间转换成本地时间，而<code>gmtime</code>则将日历时间转换成协调统一时间的年、月、日、时、分、<br>秒、周日分解结构。</p>
<p>函数<code>mktime</code>以本地时间的年、月、日等作为参数，将其变换成<code>time_t</code>值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">(<span class="keyword">struct</span> tm *tmptr)</span>;</span><br><span class="line"><span class="comment">// 返回值。若成功，返回日历时间，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>函数<code>strftime</code>是一个类似于<code>printf</code>的时间值函数。它非常复杂，可以通过可用的多个参数来定制产生的字符串。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strftime</span><span class="params">(<span class="type">char</span> *<span class="keyword">restrict</span> buf, <span class="type">size_t</span> maxsize,</span></span><br><span class="line"><span class="params">				<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format,</span></span><br><span class="line"><span class="params">				<span class="type">const</span> <span class="keyword">struct</span> tm *<span class="keyword">restrict</span> tmptr)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strftime_l</span><span class="params">(<span class="type">char</span> *<span class="keyword">restrict</span> buf, <span class="type">size_t</span> maxsize,</span></span><br><span class="line"><span class="params">				<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format,</span></span><br><span class="line"><span class="params">				<span class="type">const</span> <span class="keyword">struct</span> tm *<span class="keyword">restrict</span> tmptr, <span class="type">locale_t</span> locale)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值。若有空间。返回存入数组的字符数。否则，返回0</span></span><br></pre></td></tr></table></figure></p>
<p><code>strftime_l</code>允许调用者将区域指定为参数，除此之外，<code>strftime</code>和<code>strftime_l</code>函数是相同的。<code>strftime</code>使用通过<code>TZ</code>环境变量指定的区域。</p>
<p><code>tmptr</code>参数是要格式化的时间值，由一个指向分解时间值<code>tm</code>结构的指针说明。格式化结果存放在一个长度为<code>maxsize</code>个字符的<code>buf</code>数组中，如果<code>buf</code>长度足以存放格式化结果及一个null终止符，则该函数返回在<code>buf</code>中存放的字符数(不包括null终止符)；否则该函数返回0。</p>
<p><code>format</code>参数控制时间值的格式。如同<code>printf</code>函数一样，转换说明的形式是百分号之后跟一个特定字符。<code>format</code>中的其他字符则按原样输出。两个连续的百分号在输出中产生一个百分号。</p>
<p>与printf函数的不同之处是，每个转换说明产生一个不同的定长输出字符串，在<code>format</code>字符串中没有字段宽度修饰符。图中列出了37种ISO C规定的转换说明。<br><img src="/img/20210522151557.png" alt=""></p>
<p>程序演示了如何使用本章中讨论的多个时间函数。特别演示了如何使用<code>strftime</code>打印包含当前日期和时间的字符串。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">time_t</span> t;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tmp</span>;</span></span><br><span class="line">	<span class="type">char</span> buf1[<span class="number">16</span>];</span><br><span class="line">	<span class="type">char</span> buf2[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">	time(&amp;t);</span><br><span class="line">	tmp = localtime(&amp;t);</span><br><span class="line">	<span class="keyword">if</span> (strftime(buf1, <span class="number">16</span>, <span class="string">&quot;time and date: %r, %a %b %d, %Y&quot;</span>, tmp) == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;buffer length 16 is too small\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf1);</span><br><span class="line">	<span class="keyword">if</span> (strftime(buf2, <span class="number">64</span>, <span class="string">&quot;time and date: %r, %a %b %d, %Y&quot;</span>, tmp) == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;buffer length 64 is too small\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf2);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序的输出如下:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">buffer length 16 is too small</span><br><span class="line"><span class="keyword">time</span> and <span class="built_in">date</span>: 12:12:35 M, Thu Jan 19, 2012</span><br></pre></td></tr></table></figure></p>
<p><code>strptime</code>函数是<code>strftime</code>的反过来版本，把字符串时间转换成分解时间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strptime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> buf, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, <span class="keyword">struct</span> tm *<span class="keyword">restrict</span> tmptr)</span>;</span><br><span class="line"><span class="comment">// 返回值。指向上次解析的字符的下一个字符的指针；否则，返回NULL</span></span><br></pre></td></tr></table></figure></p>
<p><code>format</code>参数给出了<code>buf</code>参数指向的缓冲区内的字符串的格式。虽然与<code>strftime</code>函数的说明稍有不同，但格式说明是类似的。<code>strptime</code>函数转换说明符列在图6-12中。<br><img src="/img/20210522152120.png" alt=""></p>
<p>我们曾在前面提及，图6-9中以虚线表示的3个函数受到环境变量<code>TZ</code>的影响。这3个函数是<code>localtime</code>，<code>mktime</code>和<code>strftime</code>。如果定义了<code>TZ</code>，则这些函数将使用其值代替系统默认时区。如果<code>TZ</code>定义为空(即<code>TZ=&quot;&quot;</code>)，则使用协调统一时间UTC。</p>
<h1 id="迸程环境"><a href="#迸程环境" class="headerlink" title="迸程环境"></a>迸程环境</h1><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>C程序总是从main函数开始执行。main函数的原型是:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> angc, <span class="type">char</span> *argv[])</span>;</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>argc</code>是命令行参数的数目，<code>argv</code>是指向参数的各个指针所构成的数组。</p>
<p>当内核执行C程序时(使用一个exec函数)，在调用main前先调用一个特殊的启动例程。可执行程序文件将此启动例程指定为程序的起始地址一这是由连接<br>编辑器设置的，而连接编辑器则由C编译器调用。启动例程从内核取得命令行参数和环境变量值，然后为按上述方式调用main函数做好安排。</p>
<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>有8种方式使进程终止(termination)，其中5种为正常终止，它们是:</p>
<ol>
<li>从main返回;</li>
<li>调用<code>exit</code>;</li>
<li>调用<code>_exit</code>或<code>_Exit</code>;</li>
<li>最后一个线程从其启动例程返回;</li>
<li>从最后一个线程调用<code>pthread_exit</code>;。</li>
</ol>
<p>异常终止有3种方式，它们是</p>
<ol>
<li>调用<code>abort</code>;</li>
<li>接到一个信号;</li>
<li>最后一个线程对取消请求做出响应。</li>
</ol>
<p>上节提及的启动例程是这样编写的，使得从<code>main</code>返回后立即调用<code>exit</code>函数。如果将启动例程以C代码形式表示(实际上该例程常常用汇编语言编写)，则它调用main函数的形式可能是:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span> (main (argc, argv));</span><br></pre></td></tr></table></figure></p>
<h3 id="退出函数"><a href="#退出函数" class="headerlink" title="退出函数"></a>退出函数</h3><p>3个函数用于正常终止一个程序：<code>_exit</code>和<code>_Exit</code>立即进入内核，<code>exit</code>则先执行一些清理处理，然后返回内核。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"><span class="type">void</span> _Exit(<span class="type">int</span> stane);</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit (<span class="type">int</span> status);</span><br></pre></td></tr></table></figure></p>
<p>exit函数总是执行一个标准I/O库的清理关闭操作：对于所有打开流调用<code>fclose</code>函数。</p>
<p>3个退出函数都带一个整型参数，称为终止状态(或退出状态，exit status)。大多数UNIX系统shell都提供检查进程终止状态的方法。如果：</p>
<ul>
<li>调用这些函数时不带终止状态；</li>
<li>main执行了一个无返回值的return语句；</li>
<li>main没有声明返回类型为整型</li>
</ul>
<p>则该进程的终止状态是未定义的。但是，若main的返回类型是整型，并且main执行到最后一条语句时返回(隐式返回)，那么该进程的终止状态是0。</p>
<p>main函数返回一个整型值与用该值调用exit是等价的。于是在main函数中<code>exit(0);</code>等价于<code>return(0);</code>。</p>
<p>图中的程序是经典的“hello，world”实例。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main () &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对该程序进行编译，然后运行，则可见到其终止码是随机的。如果在不同的系统上编译该程序，我们很可能得到不同的终止码，这取决于main函数返回时栈和寄存器的内容:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c</span><br><span class="line">$ ./a.out</span><br><span class="line">hello, world</span><br><span class="line">$ <span class="built_in">echo</span> $?     <span class="comment">#打印终止状态</span></span><br><span class="line">13</span><br></pre></td></tr></table></figure></p>
<p>现在，我们启用1999 ISO C编译器扩展，则可见到终止码改变了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc-std=c99 hello.c   <span class="comment">#启用gcc的1999 ISO C扩展</span></span><br><span class="line">hello.c: 4: warning: <span class="built_in">return</span> <span class="built_in">type</span> defaults to <span class="string">&#x27;int&#x27;</span></span><br><span class="line">$ ./a.out</span><br><span class="line">hello, world</span><br><span class="line">$ <span class="built_in">echo</span> $?                <span class="comment">#打印终止状态</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<p>注意，当我们启用1999 ISO C扩展时，编译器发出警告消息。打印该警告消息的原因是：main函数的类型没有显式地声明为整型。如果我们增加了这一声明，那么此警告消息就不会出现。但是，如果我们使编译器所推荐的警告消息都起作用(使用<code>-wall</code>标志)，则可能见到类似于“control reaches end of nowoid function.”(控制到达非void函数的尾端)这样的警告消息。</p>
<p>将<code>main</code>声明为返回整型，但在<code>main</code>函数体内用<code>exit</code>代替<code>return</code>，对某些C编译器而言会产生不必要的警告信息，因为这些编译器并不了解<code>main</code>中的<code>exit</code>与<code>return</code>语句的作用相同。避开这种警告信息的一种方法是在<code>main</code>中使用<code>return</code>语句而不是<code>exit</code>。</p>
<h3 id="函数atexit"><a href="#函数atexit" class="headerlink" title="函数atexit"></a>函数atexit</h3><p>按照ISO C的规定，一个进程可以登记多至32个函数，这些函数将由<code>exit</code>自动调用。我们称这些函数为终止处理程序(exit  handler)，并调用<code>atexit</code>函数来登记这些函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atexit</span> <span class="params">(<span class="type">void</span> (*func) (<span class="type">void</span>))</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回非0</span></span><br></pre></td></tr></table></figure></p>
<p>其中，<code>atexit</code>的参数是一个函数地址，当调用此函数时无需向它传递任何参数，也不期望它返回一个值。<code>exit</code>调用这些函数的顺序与它们登记时候的顺序相反。同一函数如若登记多次，也会被调用多次。</p>
<p>ISOC要求，系统至少应支持32个终止处理程序，但实现经常会提供更多的支持。为了确定一个给定的平台支持的最大终止处理程序数，可以使用<code>sysconf</code>函数。</p>
<p><code>exit</code>首先调用各终止处理程序，然后关闭(通过<code>fclose</code>)所有打开流。POSIX.1扩展了ISO C标准，它说明，如若程序调用<code>exec</code>函数族中的任一函数，则将清除所有已安装的终止处理程序。图7-2显示了一个C程序是如何启动的，以及它终止的各种方式。<br><img src="/img/20210522173047.png" alt=""></p>
<p>注意，内核使程序执行的唯一方法是调用一个<code>exec</code>函数。进程自愿终止的唯一方法是显式或隐式地(通过调用<code>exit</code>)调用<code>_exit</code>或<code>_Exit</code>。进程也可非自愿地由一个信号使其终止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_exit1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_exit2</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (atexit (my_exit2) != <span class="number">0</span>)</span><br><span class="line">		err_sys (<span class="string">&quot;can&#x27;t register my_exit2&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (atexit (my_exit1) != <span class="number">0</span>)</span><br><span class="line">		err_sys (<span class="string">&quot;can&#x27;t register my_exit1&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (atexit (my_exit1) != <span class="number">0</span>)</span><br><span class="line">		err_ays(<span class="string">&quot;can&#x27;t register my_exiti&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;main is done\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_exit1</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	printt(<span class="string">&quot;tirat exit handler\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_exit2</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	printt(<span class="string">&quot;second exit handier\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行该程序产生<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">main is <span class="keyword">done</span></span><br><span class="line">first <span class="built_in">exit</span> handler</span><br><span class="line">first <span class="built_in">exit</span> handler</span><br><span class="line">second <span class="built_in">exit</span> handler</span><br></pre></td></tr></table></figure><br>终止处理程序每登记一次，就会被调用一次。在程序中，第一个终止处理程序被登记两次，所以也会被调用两次。注意，在<code>main</code>中没有调用<code>exit</code>，而是用了return语句。</p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>当执行一个程序时，调用exec的进程可将命令行参数传递给该新程序。这是UNIX shell的一部分常规操作。</p>
<p>程序将其所有命令行参数都回显到标准输出上。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc， <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;argv[%d]: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="环境表"><a href="#环境表" class="headerlink" title="环境表"></a>环境表</h2><p>每个程序都接收到一张环境表。与参数表一样，环境表也是一个字符指针数组，其中每个指针包含一个以null结束的C字符串的地址。全局变量<code>environ</code>则包含了该指针数组的地址:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br></pre></td></tr></table></figure></p>
<p>例如，如果该环境包含5个字符串，那么它看起来如图中所示。其中，每个字符串的结尾处都显式地有一个null字节。我们称<code>environ</code>为环境指针(environment pointer)，指针数组为环境表，其中各指针指向的字符串为环境字符串。<br><img src="/img/20210522173933.png" alt=""></p>
<p>按照惯例，环境由<code>name = value</code>这样的字符串组成，大多数预定义名完全由大写字母组成，但这只是一个惯例。</p>
<p>在历史上，大多数UNIX系统支持main函数带3个参数，其中第3个参数就是环境表地址:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *envp[])</span>;</span><br></pre></td></tr></table></figure></p>
<p>因为ISO C规定main函数只有两个参数，而且第3个参数与全局变量<code>environ</code>相比也没有带来更多益处，所以POSIX.1也规定应使用<code>environ</code>而不使用第3个参数。通常用<code>getenv</code>和<code>putenv</code>函数来访问特定的环境变量，而不是用<code>environ</code>变量。但是，如果要查看整个环境，则必须使用<code>environ</code>指针。</p>
<h2 id="C程序的存储空间布局"><a href="#C程序的存储空间布局" class="headerlink" title="C程序的存储空间布局"></a>C程序的存储空间布局</h2><p>历史沿袭至今，C程序一直由下列几部分组成:</p>
<ul>
<li>正文段。这是由CPU执行的机器指令部分。通常，正文段是可共享的，所以即使是频繁执行的程序在存储器中也只需有一个副本，另外，正文段常常是只读的，以防止程序由于意外面修改其指令。</li>
<li>初始化数据段。通常将此段称为数据段，它包含了程序中需明确地赋初值的变量。例如，C程序中任何函数之外的声明使此变量以其初值存放在初始化数据段中。</li>
<li>未初始化数据段。通常将此段称为bss段，这一名称来源于早期汇编程序一个操作符，意思是“由符号开始的块”(block started by symbol)，在程序开始执行之前，内核将此段中的数据初始化为0或空指针。函数外的声明使此变量存放在非初始化数据段中。</li>
<li>栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。每次函数调用时，其返回地址以及调用者的环境信息都存放在栈中。然后，最近被调用的函数在栈上为其自动和临时变量分配存储空间。通过以这种方式使用栈，C递归函数可以工作。递归函数每次调用自身时，就用一个新的栈帧，因此一次函数调用实例中的变量集不会影响另一次函数调用实例中的变量。</li>
<li>堆。通常在堆中进行动态存储分配。由于历史上形成的惯例，堆位于未初始化数据段和栈之间</li>
</ul>
<p><img src="/img/20210522174418.png" alt=""></p>
<p>图7-6显示了这些段的一种典型安排方式。这是程序的逻辑布局，虽然并不要求一个具体实现一定以这种方式安排其存储空间，但这是一种我们便于说明的典型安排。堆顶和栈项之间未用的虚地址空间很大。</p>
<blockquote>
<p>a.out中还有若干其他类型的段，如包含符号表的段、包含调试信息的授以及包含动态共享库链接表的段等。这些部分并不装载到进程执行的程序映像中。</p>
</blockquote>
<p>从图7-6还可注意到，未初始化数据段的内容并不存放在磁盘程序文件中。其原因是，内核在程序开始运行前将它们都设置为0.需要存放在磁盘程序文件中的段只有正文段和初始化数据段。</p>
<p><code>size()</code>命令报告正文段、数据段和bss段的长度(以字节为单位)。例如:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ size /usr/bin/cc</span><br><span class="line">text    data    bss     dec     hex   filename</span><br><span class="line">346919  3576    6680   357175  57337  /usz/bin/cc</span><br></pre></td></tr></table></figure><br>第4列和第5列是分别以十进制和十六进制表示的3段总长度。</p>
<h2 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h2><p>共享库使得可执行文件中不再需要包含公用的库函数，而只需在所有进程都可引用的存储区中保存这种库例程的一个副本。程序第一次执行或者第一次调用某个库函数时，用动态链接方法将程序与共享库函数相链接。这减少了每个可执行文件的长度，但增加了一些运行时间开销。这种时间开销发生在该程序第一次被执行时，或者每个共享库函数第一次被调用时。共享库的另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新连接编辑。</p>
<p>在不同的系统中，程序可能使用不同的方法说明是否要使用共享库，比较典型的有cc(1)和ld(1)命令的选项。作为长度方面发生变化的例子，先用无共享库方式创建下列可执行文件(典型的hello.c程序):<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -static hello.o.       <span class="comment">#阻止gcc使用共享库</span></span><br><span class="line">$ <span class="built_in">ls</span> -l a.out</span><br><span class="line">-rwxrwxr-x 1 sar 	879443 Sep 2 10:39 a.out</span><br><span class="line">$ size a.out</span><br><span class="line">text 	data 	bss 	dec 	hex 	filename</span><br><span class="line">787775	6128 	11272  805175  c4937 	  a.out</span><br></pre></td></tr></table></figure></p>
<p>如果再使用共享库编译此程序，则可执行文件的正文和数据段的长度都显著减小:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c 		<span class="comment">#gcc默认使用共享库</span></span><br><span class="line">$ <span class="built_in">ls</span> -l a.out</span><br><span class="line">-rwxrwxr-x 1 sar 	8378 Sep 2 10:39 a.out</span><br><span class="line">$ size a.out</span><br><span class="line">text 	data 	bss 	dec 	hex 	filename</span><br><span class="line">1176	504 	16  	1696  	6a0 	  a.out</span><br></pre></td></tr></table></figure></p>
<h2 id="存储空间分配"><a href="#存储空间分配" class="headerlink" title="存储空间分配"></a>存储空间分配</h2><p>ISO C说明了3个用于存储空间动态分配的函数。</p>
<ul>
<li><code>malloc</code>，分配指定字节数的存储区。此存储区中的初始值不确定。</li>
<li><code>calloc</code>，为指定数量指定长度的对象分配存储空间。该空间中的每一位(bit)都初始化为0。</li>
<li><code>realloc</code>，增加或减少以前分配区的长度。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，以便在尾端提供增加的存储区，而新增区域内的初始值则不确定。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nobj, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> newsize)</span>;</span><br><span class="line"><span class="comment">// 3个函数返回值：若成功，返回非空指针；若出错，返回NULL</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span> <span class="params">(<span class="type">void</span> *pr)</span>;</span><br></pre></td></tr></table></figure>
<p>这3个分配函数所返回的指针一定是适当对齐的，使其可用于任何数据对象。例如，在一个特定的系统上，如果最苛刻的对齐要求是，double必须在8的倍数地址单元处开始，那么这3个函数返回的指针都应这样对齐。</p>
<p>因为这3个alloc函数都返回通用指针<code>void*</code>，所以如果在程序中包括了<code>&lt;stdlib.h&gt;</code>(以获得函数原型)，那么当我们将这些函数返回的指针赋予一个不同类型的指针时，就不需要显式地执行强制类型转换。未声明函数的默认返回值为int，所以使用没有正确函数声明的强制类型转换可能会隐藏系统错误，因为int类型的长度与函数返回类型值的长度不同(本例中是指针)。</p>
<p>函数free释放pr指向的存储空间，被释放的空间通常被送入可用存储区池，以后，可在调用上述3个分配函数时再分配。</p>
<p><code>realloc</code>函数使我们可以增、减以前分配的存储区的长度(最常见的用法是增加该区)。例如，如果先为一个数组分配存储空间，该数组长度为512，然后在运行时填充它，但运行一段时间后发现该数组原先的长度不够用，此时就可调用<code>realloc</code>扩充相应存储空间。如果在该存储区后有足够的空间可供扩充，则可在原存储区位置上向高地址方向扩充，无需移动任何原先的内容，并返回与传给它相同的指针值。如果在原存储区后没有足够的空间，则<code>realloc</code>分配另一个足够大的存储区，将现存的512个元素数组的内容复制到新分配的存储区。然后，释放原存储区，返回新分配区的指针。因为这种存储区可能会移动位置，所以不应当使任何指针指在该区中。</p>
<p>这些分配例程通常用<code>sbrk(2)</code>系统调用实现，该系统调用扩充(或缩小)进程的堆。虽然<code>sbrk</code>可以扩充成缩小进程的存储空间，但是大多数<code>malloc</code>和<code>free</code>的实现都不减小进程的存储空间。释放的空间可供以后再分配，但将它们保持在<code>malloc</code>池中而不返回给内核。大多数实现所分配的存储空间比所要求的要稍大一 些，额外的空间用来记录管理信息一分配块的长度、指向下一个分配块的指针等。这就意味着，如果超过一个已分配区的尾端或者在已分配区起始位置之前进行写操作，则会改写另一块的管理记录信息。这种类型的错误是灾难性的，但是因为这种错误不会很快就暴露出来，所以也就很难发现。</p>
<p>在动态分配的缓冲区前或后进行写操作，破坏的可能不仅仅是该区的管理记录信息。在动态分配的缓冲区前后的存储空间很可能用于其他动态分配的对象。这些对象与破坏它们的代码可能无关，这造成寻求信息破坏的源头更加困难。</p>
<p>其他可能产生的致命性的错误是：释放一个已经释放了的块；调用free时所用的指针不是3个alloc函数的返回值等。如若一个进程调用<code>malloc</code>函数，但却忘记调用<code>free</code>函数，那么该进程占用的存储空间就会连续增加，这被称为<strong>泄漏</strong>(leakage)。如果不调用<code>free</code>函数释放不再使用的空间，那么进程地址空间长度就会慢慢增加，直至不再有空闲空间。此时，由于过度的换页开销，会造成性能下降。</p>
<h3 id="替代的存储空间分配程序"><a href="#替代的存储空间分配程序" class="headerlink" title="替代的存储空间分配程序"></a>替代的存储空间分配程序</h3><p>有很多可替代<code>malloc</code>和<code>free</code>的函数。某些系统已经提供替代存储空间分配函数的库。</p>
<h4 id="libmalloc"><a href="#libmalloc" class="headerlink" title="libmalloc"></a>libmalloc</h4><p>它提供了一套与ISO C存储空间分配函数相匹配的接口。libmalloc库包括<code>mallopt</code>函数，它使进程可以设置一些变量，并用它们来控制存储空间分配程序的操作。还可使用另一个名为<code>mallinfo</code>的函数，以对存储空间分配程序的操作进行统计。</p>
<h4 id="vmalloc"><a href="#vmalloc" class="headerlink" title="vmalloc"></a>vmalloc</h4><p>它允许进程对于不同的存储区使用不同的技术。除了一些<code>vmalloc</code>特有的函数外，该库也提供了ISO C存储空间分配函数的伤真器。</p>
<h4 id="quick-fit"><a href="#quick-fit" class="headerlink" title="quick-fit"></a>quick-fit</h4><p>历史上所使用的标准malloc算法是最佳适配或首次适配存储分配策略。quick-fit(快速适配)算法比上述两种算法快，但可能使用较多存储空间。该算法基于将存储空间分裂成各种长度的缓冲区，并将未使用的缓冲区按其长度组成不同的空闲区列表。现在许多分配程序都基于快速适配</p>
<h4 id="jemalloc"><a href="#jemalloc" class="headerlink" title="jemalloc"></a>jemalloc</h4><p><code>jemalloc</code>函数实现是FreeBSD 8.0中的默认存储空间分配程序，它是库函数malloc族在FreeBSD中的实现。它的设计具有良好的可扩展性， 可用于多处理器系统中使用多线程的应用程序。</p>
<h4 id="TCMalloc"><a href="#TCMalloc" class="headerlink" title="TCMalloc"></a>TCMalloc</h4><p>TCMalloc函数用于替代malloc函数族以提供高性能、高扩展性和高存储效率。从高速缓存中分配缓冲区以及释放缓冲区到高速缓存中时，它使用线程本地高速缓存来避免锁开销。它还有内置的堆检查程序和维分析程序帮助调试和分析动态存储的使用。</p>
<h4 id="函数alloca"><a href="#函数alloca" class="headerlink" title="函数alloca"></a>函数alloca</h4><p><code>alloca</code>的调用序列与malloc相同，但是它是在当前函数的栈帧上分配存储空间，而不是在堆中。其优点是，当函数返回时，自动释放它所使用的栈帧，所以不必再为释放空间而费心。其缺点是alloca函数增加了栈帧的长度，而某些系统在函数已被调用后不能增加栈帧长度，于是也就不能支持alloca函数。</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境字符串的形式是：<code>name=value</code></p>
<p>ISO C定义了一个函数<code>getenv</code>，可以用其取环境变量值，但是该标准又称环境的内容是由实现定义的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>:</span><br><span class="line"><span class="comment">// 返回值，指向与name关联的value的指针; 若未找到，返回NULL</span></span><br></pre></td></tr></table></figure></p>
<p>注意，此函数返回一个指针，它指向name-value字符串中的value。我们应当使用<code>getenv</code>从环境中取一个指定环境变量的值，而不是直接访问environ。</p>
<p>POSIX.1定义了某些环境变量。<br><img src="/img/20210522200334.png" alt=""></p>
<p>除了获取环境变量值，有时也需要设置环境变量。我们可能希望改变现有变量的值，或者是增加新的环境变量。遗憾的是，并不是所有系统都支持这种能力。</p>
<p>3个函数的原型是:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putenv</span><span class="params">(<span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="comment">// 函数返回值，若成功，返回0，若出错，返回非0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> rewrite)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unsetenv</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">// 两个函数返回值，若成功，返回0:若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>这3个函数的操作如下。</p>
<ul>
<li><code>putenv</code>取形式为name=value的字符串，将其放到环境表中。如果name已经存在，则先删除其原来的定义。</li>
<li><code>setenv</code>将name设置为value，如果在环境中name已经存在，那么<ul>
<li>若<code>rewrite</code>非0，则首先剩除其现有的定义;</li>
<li>若<code>rewrite</code>为0，则不删除其现有定义(name不设置为新的value，而且也不出错)。</li>
</ul>
</li>
<li><code>unsetenv</code>删除name的定义。 即使不存在这种定义也不算出错。</li>
</ul>
<p>注意，<code>putenv</code>和<code>setenv</code>之间的差别。<code>setenv</code>必须分配存储空间，以便依据其参数创建name-value字符串。<code>putenv</code>可以自由地将传递给它的参数字符串直接救到环境中。确实，许多实现就是这么做的，因此，将存放在栈中的字符串作为参数传递给<code>putenv</code>就会发生错误，其原因是，从当前函数返回时，其栈帧占用的存储区可能将被重用。</p>
<p>环境表(指向实际name-value字符串的指针数组)和环境字符串通常存放在进程存储空间的顶部(栈之上)。删除一个字符串很简单——只要先在环境表中找到该指针，然后将所有后续指针都向环境表首部顺次移动一个位置。但是增加一个字符串或修改一个现有的字符串就困难得多。环境表和环境字符串通常占用的是进程地址空间的顶部，所以它不能再向高地址方向扩展。同时也不能移动在它之下的各栈帧，所以它也不能向低地址方向扩展。两者组合使得该空间的长度不能再增加。</p>
<ul>
<li>如果修改一个现有的name:<ul>
<li>如果新value的长度少于或等于现有value的长度， 则只要将新字符串复制到原字符串所用的空间中；</li>
<li>如果新value的长度大于原长度，则必须调用malloc为新字符串分配空间，然后将新字符串复制到该空间中，接着使环境表中针对name的指针指向新分配区。</li>
</ul>
</li>
<li>如果要增加一个新的name，则操作就更加复杂。首先，必须调用malloc为name-value字符串分配空间，然后将该字符串复制到此空间中，<ul>
<li>如果这是第一次增加一个新name，则必须调用malloc为新的指针表分配空间。接着，将原来的环境表复制到新分配区，并将指向新name-value字符串的指针存放在该指针表的表尾，然后又将一个空指针存放在其后。最后使environ指向新指针表。</li>
<li>如果这不是第一次增加一个新name，则可知以前已调用ma11oc在堆中为环境表分配了空间，所以只要调用realloc，以分配比原空间多存放一个指针的空间。然后将指向新name-value字符串的指针存放在该表表尾，后面跟着一个空指针。</li>
</ul>
</li>
</ul>
<h2 id="函数setjmp和1ongjmp"><a href="#函数setjmp和1ongjmp" class="headerlink" title="函数setjmp和1ongjmp"></a>函数setjmp和1ongjmp</h2><p>在C中，goto语句是不能跨越函数的，而执行这种类型跳转功能的是函数<code>setjmp</code>和<code>longjmp</code>。这两个函数对于处理发生在很深层嵌套函数调用中的出错情况是非常有用的。</p>
<p>考虑程序。其主循环是从标准输入读一行，然后调用<code>do_line</code>处理该输入行。<code>do_line</code>函数调用<code>get_token</code>从该输入行中取下一个标记。一行中的第一个标记假定是一条某种形式的命令，switch语句就实现命令选择。对程序中示例的命令调用<code>cmd_add</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOK_ADD 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_line</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cmd_add</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get_token</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">char</span> line[MAXLINE];</span><br><span class="line">	<span class="keyword">while</span> (fgets(line, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">		do_line(line);	</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *tok_ptr;   <span class="comment">/* global pointer for get_token() */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_line</span> <span class="params">(<span class="type">char</span> *ptr)</span> &#123;    <span class="comment">/* process one line of input */</span></span><br><span class="line">	<span class="type">int</span> cmd;</span><br><span class="line">	tok_ptz = ptr;</span><br><span class="line">	<span class="keyword">while</span> ((cmd = get_token()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">switch</span>(cmd) &#123; 	<span class="comment">/* one case for each command */</span></span><br><span class="line">		<span class="keyword">case</span> TOK_ADD:</span><br><span class="line">			cand_add();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cmd_add</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> token;</span><br><span class="line">	token = get_token();   <span class="comment">/* rest of processing for this command */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get_token</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* fetch next token from line pointed to by tok_ptr */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序的骨架部分在读命令、确定命令的类型，然后调用相应函数处理每一条命令这类程序中是非常典型的。</p>
<p>自动变量的存储单元在每个函数的栈桢中。数组line在main的栈帧中，整型cmd在do_line的栈帧中，整型token在cmd_add的栈帧中。</p>
<p>如上所述，这种形式的栈安排是非常典型的，但并不要求非如此不可。栈并不一定要向低地址方向扩充。某些系统对栈并没有提供特殊的硬件支持，此时一个C<br>的实现可能要用链表实现栈帧。</p>
<p>解决这深层跳转的方法就是使用非局部goto一<code>setjmp</code>和<code>longjmp</code>函数。非局部指的是，这不是由普通的C语言goto语句在一个函数内实施的跳转，而是在栈上跳过若干调用帧，返回到当前函数调用路径上的某一个函数中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setjup</span><span class="params">(jmp_but env)</span>;</span><br><span class="line"><span class="comment">// 返回值，若直接调用，返回0；若从longjmp返回，则为非0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env， <span class="type">int</span> val)</span>;</span><br></pre></td></tr></table></figure></p>
<p>在希望返回到的位置调用setjmp，在本例中，此位置在main函数中。因为我们直接调用该函数，所以其返回值为0。<code>setjmp</code>参数<code>env</code>的类型是一 个特殊类型<code>jmp_buf</code>。这一数据类型是某种形式的数组，其中存放在调用<code>longjmp</code>时能用来恢复栈状态的所有信息。因为需在另一个函数中引用<code>env</code>变量，所以通常将<code>env</code>变量定义为全局变量。</p>
<p>当检查到一个错误时，则以两个参数调用<code>longjmp</code>函数。第一个就是在调用<code>setjmp</code>时所用的<code>env</code>第二个参数是具非0值的<code>val</code>，它将成为从<code>setjmp</code>处返回的值。使用第二个参数的原因是对于一个<code>setjmp</code>可以有多个<code>longjmp</code>。例如，可以在<code>cmd_add</code>中以<code>val</code>为1调用<code>longjmp</code>，也可在<code>get_token</code>中以<code>val</code>为2调用<code>longjmp</code>。在main函数中，<code>setjmp</code>的返回值就会是1或2，通过测试返回值就可判断造成返回的<code>longjmp</code>是在<code>cmd_add</code>还是在<code>get_token</code>中。</p>
<p>程序中给出了经修改过后的main和cmd_add函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOK_ADD 5</span></span><br><span class="line">jmp_buf jupbuffer;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">char</span> line[MAXLINE];</span><br><span class="line">	<span class="keyword">if</span> (setjmp(jmpbuffer) != <span class="number">0</span>)</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;error&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (fgets (line, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">		do_line(line);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">end_edd</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> token;</span><br><span class="line">	token = get_token();</span><br><span class="line">	<span class="keyword">if</span> (token &lt; <span class="number">0</span>) <span class="comment">/* an error has occurred */</span></span><br><span class="line">		longjmp(jmpbuffer, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">/* rest of processing for this command */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行main时，调用<code>setjmp</code>，它将所需的信息记入变量<code>jmpbuffer</code>中并返回0。然后调用<code>do_line</code>，它又调用<code>cmd_add</code>，假定在其中检测到一个错误。<code>longjmp</code>使栈反绕到执行main函数时的情况，也就是抛弃了<code>cmd_add</code>和<code>do_line</code>的栈帧。调用<code>longjmp</code>造成main中<code>setjmp</code>的返回，但是，这一次的返回值是1(longjmp的第二个参数)。</p>
<h2 id="函数getrlimit和setrlimit"><a href="#函数getrlimit和setrlimit" class="headerlink" title="函数getrlimit和setrlimit"></a>函数getrlimit和setrlimit</h2><p>每个进程都有一组资源限制，其中一些可以用<code>getrlimit</code>和<code>setrlimit</code>函数查询和更改。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getrlimit</span> <span class="params">(<span class="type">int</span> resource, <span class="keyword">struct</span> rlimit *rlptr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit *rlpr)</span>;</span><br><span class="line"><span class="comment">// 两个函数返回值，若成功，返回0，若出错，返回非0</span></span><br></pre></td></tr></table></figure></p>
<p>对这两个函数的每一次调用都指定一个资源以及一个指向下列结构的指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">	<span class="type">rlim_t</span> elim_cur; <span class="comment">/* soft limit: current limit */</span></span><br><span class="line">	<span class="type">rlim_t</span> rlim_max; <span class="comment">/* hard limit: maximum velue for rlim_cur */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在更改资源限制时，须遵循下列3条规则。</p>
<ol>
<li>任何一个进程都可将一个软限制值更改为小于或等于其硬限制值。</li>
<li>任何一个进程都可降低其硬限制值，但它必须大于或等于其软限制值。这种降低，对普通用户而言是不可逆的。</li>
<li>只有超级用户进程可以提高硬限制值。</li>
</ol>
<p>常量<code>RLIM_INFINITY</code>指定了一个无限量的限制。这两个函数的resource参数取下列值之一。</p>
<ul>
<li>RLIMIT_AS：进程总的可用存储空间的最大长度(字节)。这影响到sbrk函数和map函数。</li>
<li>RLIMIT_CORE：core文件的最大字节数，若其值为0则阻止创建core文件。</li>
<li>RLIMIT_CPU：CPU时间的最大量值(秒)，当超过此软限制时，向该进程发送SIGXCPU信号。</li>
<li>RLIMIT_DATA：数据段的最大字节长度。这是初始化数据、非初始以及堆的总和。</li>
<li>RLIMIT_FSIZE：可以创建的文件的最大字节长度。当超过此软限制时，则向该进程发送SIGXFSZ信号。</li>
<li>RLIMIT_MEMLOCK：一个进程使用mlock(2)能够锁定在存储空间中的最大字节长度。</li>
<li>RLIMIT_MSGQUEUE：进程为POSIX消息队列可分配的最大存储字节数。</li>
<li>RLIMIT_NICE：为了影响进程的调度优先级，nice值可设置的最大限制。</li>
<li>RLIMIT_NOFTLE：每个进程能打开的最多文件数。更改此限制将影响到syscont函数在参数<code>_SC_OPEN_MAX</code>中返回的值</li>
<li>RLIMIT_NPROC：每个实际用户ID可拥有的最大子进程数。更改此限制将影响到<code>sysconf</code>函数在参数<code>_SC_CHILD_MAX</code>中返回的值。</li>
<li>RLIMIT_NPTS：用户可同时打开的伪终端的最大数量。</li>
<li>RLIMIT_RSS：最大驻内存集字节长度(resident set size in bytes，RSS)、如果可用的物理存储器非常少，则内核将从进程处取回超过RSS的部分。</li>
<li>RLIMIT_SBSIZE：在任一给定时刻，一个用户可以占用的套接字缓冲区的最大长度。</li>
<li>RLIMIT_SIGPENDING：一个进程可排队的信号最大数量。这个限制是sigqueue函数实施的。</li>
<li>RLIMIT_STACK：栈的最大字节长度。</li>
<li>RLIMIT_SWAP：用户可消耗的交换空间的最大字节数。</li>
<li>RLIMIT_VMEM：这是RLIMIT_AS的同义词。</li>
</ul>
<p>资源限制影响到调用进程并由其子进程继承。这就意味着，为了影响一个用户的所有后续进程，需将资源限制的设置构造在shell之中。</p>
<p>程序打印由系统支持的所有资源当前的软限制和硬限制。为了在各种实现上编译该程序，我们已经条件地包括了各种不同的资源名。<code>rlim_t</code>类型必须足够大才能表示文件大小限制。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	doit(name)	pr_limits(#name, name)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>	<span class="title function_">pr_limits</span><span class="params">(<span class="type">char</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	RLIMIT_AS</span></span><br><span class="line">	doit(RLIMIT_AS);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	doit(RLIMIT_CORE);</span><br><span class="line">	doit(RLIMIT_CPU);</span><br><span class="line">	doit(RLIMIT_DATA);</span><br><span class="line">	doit(RLIMIT_FSIZE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	RLIMIT_MEMLOCK</span></span><br><span class="line">	doit(RLIMIT_MEMLOCK);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_MSGQUEUE</span></span><br><span class="line">	doit(RLIMIT_MSGQUEUE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_NICE</span></span><br><span class="line">	doit(RLIMIT_NICE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	doit(RLIMIT_NOFILE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	RLIMIT_NPROC</span></span><br><span class="line">	doit(RLIMIT_NPROC);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_NPTS</span></span><br><span class="line">	doit(RLIMIT_NPTS);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	RLIMIT_RSS</span></span><br><span class="line">	doit(RLIMIT_RSS);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	RLIMIT_SBSIZE</span></span><br><span class="line">	doit(RLIMIT_SBSIZE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_SIGPENDING</span></span><br><span class="line">	doit(RLIMIT_SIGPENDING);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	doit(RLIMIT_STACK);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_SWAP</span></span><br><span class="line">	doit(RLIMIT_SWAP);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	RLIMIT_VMEM</span></span><br><span class="line">	doit(RLIMIT_VMEM);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">pr_limits</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> resource)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span>		<span class="title">limit</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>	lim;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (getrlimit(resource, &amp;limit) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;getrlimit error for %s&quot;</span>, name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%-14s  &quot;</span>, name);</span><br><span class="line">	<span class="keyword">if</span> (limit.rlim_cur == RLIM_INFINITY) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(infinite)  &quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		lim = limit.rlim_cur;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%10lld  &quot;</span>, lim);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (limit.rlim_max == RLIM_INFINITY) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(infinite)&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		lim = limit.rlim_max;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%10lld&quot;</span>, lim);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">putchar</span>((<span class="type">int</span>)<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，在<code>doit</code>宏中使用了ISO C的字符串创建算符(#)，以便为每个资源名产生字符串值。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doit (RLIMIT_CORE);</span><br></pre></td></tr></table></figure></p>
<p>这将由C预处理程序扩展为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pr_limits(<span class="string">&quot;RLIMIT_CORE&quot;</span>, RLIMIT_CORE);</span><br></pre></td></tr></table></figure></p>
<p>在FreeBSD下运行此程序，得到:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">RLIMIT_AS      (infinite) (infinite)</span><br><span class="line">RLIMIT_CORE    (infinite) (infinite)</span><br><span class="line">RLIMIT_CPU     (infinite) (infinite)</span><br><span class="line">RLIMIT_DATA     536870912 536870912</span><br><span class="line">RLIMIT_FSIZE   (infinite) (infinite)</span><br><span class="line">RLIMIT_MEMLOCK (infinite) (infinite)</span><br><span class="line">RLIMIT_NOFILE   3520      3520</span><br><span class="line">RLIMIT_NPROC    1760      1760</span><br><span class="line">RLIMIT_NPTS    (infinite) (infinite)</span><br><span class="line">RLIMIT_RSS     (infinite) (infinite)</span><br><span class="line">RLIMIT_SBSIZE  (infinite) (infinite)</span><br><span class="line">RLIMIT_STACK    67108864 67108864</span><br><span class="line">RLIMIT_SWAP    (infinite) (infinite)</span><br><span class="line">RLIMIT_VMEM    (infinite) (infinite)</span><br></pre></td></tr></table></figure></p>
<h1 id="进程控制-1"><a href="#进程控制-1" class="headerlink" title="进程控制"></a>进程控制</h1><h2 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h2><p>每个进程都有一个非负整型表示的唯一进程ID。因为进程ID标识符总是唯一的，常将其用作其他标识符的一部分以保证其唯一性。</p>
<p>进程ID是可复用的。当一个进程终止后，其进程ID就成为复用的候选者。大多数UNIX系统实现延迟复用算法，使得赋予新建进程的ID不同于最近终止进程所使用的ID。这防止了将新进程误认为是使用同一ID的某个已终止的先前进程。</p>
<p>系统中有一些专用进程，但具体细节随实现而不同。ID为0的进程通常是调度进程，常常被称为<strong>交换进程</strong>(swapper)。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为<strong>系统进程</strong>。1通常是init进程，在自举过程结束时由内核调用。该进程的程序文件在UNIX的早期版本中是<code>/etc/init</code>，在较新版本中是<code>/sbin/init</code>。此进程负责在自举内核后启动一个UNIX系统。init通常读取与系统有关的初始化文件，并将系统引导到一个状态。init进程决不会终止。它是一个普通的用户进程，但是它以超级用户特权运行。</p>
<p>除了进程ID，每个进程还有一些其他标识符。下列函数返回这些标识符。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回值：调用进程的进程ID</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回值：调用进程的父进程ID</span></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getuid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回值：调用进程的实际用户ID</span></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">geteuid</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回值：调用进程的有效用户ID</span></span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getgid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回值：调用进程的实际组ID</span></span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getegid</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回值，调用进程的有效组ID</span></span><br></pre></td></tr></table></figure></p>
<p>注意，这些函数都没有出错返回。</p>
<h2 id="函数fork"><a href="#函数fork" class="headerlink" title="函数fork"></a>函数fork</h2><p>现有的进程可以调用<code>fork</code>函数创建一个新进程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回值：子进程返回0，父进程返回子进程ID；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>由fork创建的新进程被称为子进程(child process)。fork函数被调用一次，但返回两次。两次返回的区别是<strong>子进程的返回值是0</strong>，而父进程的返回值则是新建子进程的进程ID。将子进程ID返回给父进程的理由是：因为一个进程的子进程可以有多个，并且没有一个函数使一个进程可以获得其所有子进程的进程ID。<code>fork</code>使子进程得到返回值0的理由是：一个进程只会有一个父进程，所以子进程总是可以调用<code>getppid</code>以获得其父进程的进程ID(进程ID 0总是由内核交换进程使用，所以一个子进程的进程ID不可能为0)。</p>
<p>子进程和父进程继续执行<code>fork</code>调用之后的指令。子进程获得父进程数据空间、堆和栈的副本。注意，这是子进程所拥有的副本。父进程和子进程并不共享这些存储空间部分。父进程和子进程共享正文段。由于在<code>fork</code>之后经常跟随着<code>exec</code>，所以现在的很多实现并不执行一个父进程数据段、栈和堆的完全副本。作为替代，使用了<strong>写时复制</strong>(Copy-On-Write，COW)技术。这些区域由父进程和子进程共享，而且内核将它们的访问权限改变为只读。如果父进程和子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储系统中的一“页”。</p>
<p>Linux 3.2.0提供了另一种新进程创建函数<code>clone</code>系统调用，它允许调用者控制哪些部分由父进程和子进程共享。</p>
<p>程序演示了<code>fork</code>函数，从中可以看到子进程对变量所做的改变并不影响父进程中该变量的值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>		globvar = <span class="number">6</span>;		<span class="comment">/* external variable in initialized data */</span></span><br><span class="line"><span class="type">char</span>	buf[] = <span class="string">&quot;a write to stdout\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>		var;		<span class="comment">/* automatic variable on the stack */</span></span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	var = <span class="number">88</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">write</span>(STDOUT_FILENO, buf, <span class="built_in">sizeof</span>(buf)<span class="number">-1</span>) != <span class="built_in">sizeof</span>(buf)<span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;before fork\n&quot;</span>);	<span class="comment">/* we don&#x27;t flush stdout */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;		<span class="comment">/* child */</span></span><br><span class="line">		globvar++;				<span class="comment">/* modify variables */</span></span><br><span class="line">		var++;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">2</span>);				<span class="comment">/* parent */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;pid = %ld, glob = %d, var = %d\n&quot;</span>, (<span class="type">long</span>)<span class="built_in">getpid</span>(), globvar,</span><br><span class="line">	  var);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果执行此程序则得到：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">a write to stdout</span><br><span class="line">before fork</span><br><span class="line">pid = 430, glob = 7, var = 89    <span class="comment">#子进程的变量值改变了</span></span><br><span class="line">pid = 429, glob = 6, var = 88    <span class="comment">#父进程的变量值没有改变</span></span><br><span class="line">$ a.out &gt; temp.out</span><br><span class="line">$ <span class="built_in">cat</span> temp.out</span><br><span class="line">a write to atdout</span><br><span class="line">before fork</span><br><span class="line">pid = 432, glob = 7, var = 89</span><br><span class="line">before fork</span><br><span class="line">pid = 431, glob = 6, var = 80</span><br></pre></td></tr></table></figure></p>
<p>一般来说，在fork之后是父进程先执行还是子进程先执行是不确定的，这取决于内核所使用的调度算法。如果要求父进程和子进程之间相互同步，则要求某种形式的进程问通信。</p>
<p>当写标准输出时，我们将buf长度减去1作为输出字节数，这是为了避免将终止null字节写出。<code>strlen</code>计算不包含终止null字节的字符串长度，而<code>sizeof</code>则计算包括终止null字节的缓冲区长度。两者之间的另一个差别是，使用<code>strlen</code>需进行一次函数调用，而对于<code>sizeof</code>而言， 因为缓冲区已用已知字符串进行初始化，其长度是固定的，所以<code>sizeof</code>是在编译时计算缓冲区长度。</p>
<p>当以交互方式运行该程序时，只得到该<code>printf</code>输出的行一次，其原因是标准输出缓冲区由换行符冲洗。但是当将标准输出重定向到一个文件时，却得到<code>printf</code>输出行两次。其原因是，在<code>fork</code>之前调用了<code>printf</code>一次，但当调用<code>fork</code>时，该行数据仍在缓冲区中，然后在将父进程数据空间复制到子进程中时，该缓冲区数据也被复制到子进程中，此时父进程和子进程各自有了带该行内容的缓冲区。在<code>exit</code>之前的第二个<code>printf</code>将其数据追加到已有的缓冲区中。当每个进程终止时，其缓冲区中的内容都被写到相应文件中。</p>
<p>在重定向父进程的标准输出时，子进程的标准输出也被重定向。实际上，<code>fork</code>的一个特性是父进程的所有打开文件描述符都被复制到子进程中。我们说“复制”是因为对每个文件描述符来说，就好像执行了<code>dup</code>函数。父进程和子进程每个相同的打开描述符共享一个文件表项。考虑下述情况，一个进程具有了个不同的打开文件，它们是标准输入、标准输出和标准错误。在从<code>fork</code>返回时，我们有了如图8-2中所示的结构。</p>
<p>重要的一点是，父进程和子进程共享同一个文件偏移量。考虑下述情况：一个进程<code>fork</code>了一个子进程，然后等待子进程终止。假定，作为普通处理的一部分，父进程和子进程都向标准输出进行写操作。如果父进程的标准输出已重定向(很可能是由shell实现的)，那么子进程写到该标准输出时，它将更新与父进程共享的该文件的偏移量。在这个例子中，当父进程等待子进程时，子进程写到标准输出：而在子进程终止后，父进程也写到标准输出上，并且知道其输出会追加在子进程所写数据之后。如果父进程和子进程不共享同一文件偏移量，要实现这种形式的交互就要困难得多，可能需要父进程显式地动作。</p>
<p><img src="/img/1621849003.jpg" alt=""></p>
<p>如果父进程和子进程写同一描述符指向的文件，但又没有任何形式的同步(如使父进程等待子进程)，那么它们的输出就会相互混合(假定所用的描述符是在fork之前打开的)。</p>
<p>在<code>fork</code>之后处理文件搞述符有以下两种常见的情况，</p>
<ol>
<li>父进程等待子进程完成。在这种情况下，父进程无需对其描述符做任何处理。当子进程终止后，它曾进行过读、写操作的任一共享描述符的文件偏移量已做了相应更新。</li>
<li>父进程和子进程各自执行不同的程序段。在这种情况下，在fork之后，父进程和子进程各自关闭它们不需使用的文件损述符，这样就不会干扰对方使用的文件描述符。</li>
</ol>
<p>除了打开文件之外，父进程的很多其他属性也由子进程继承，包括：</p>
<ul>
<li>实际用户ID、实际组ID、有效用户ID、有效组ID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>会话ID</li>
<li>控制终端</li>
<li>设置用户ID标志和设置组D标志</li>
<li>当前工作目录</li>
<li>根目录</li>
<li>文件模式创建屏蔽字</li>
<li>信号屏蔽和安排</li>
<li>对任一打开文件描述符的执行时关闭(close-on-exec)标志</li>
<li>环境</li>
<li>连接的共享存储段</li>
<li>存储映像</li>
<li>资源限制</li>
</ul>
<p>父进程和子进程之间的区别具体知下。</p>
<ul>
<li>fork的返回值不同。</li>
<li>进程ID不同。</li>
<li>这两个进程的父进程ID不同：子进程的父进程ID是创建它的进程的ID，而父进程的父进程ID则不变。</li>
<li>子进程的<code>tms_utime</code>、<code>tms_stime</code>、<code>tms_cutime</code>和<code>tms_ustime</code>的值设置为0。</li>
<li>子进程不继承父进程设置的文件锁。</li>
<li>子进程的未处理闹钟被清除。</li>
<li>子进程的未处理信号集设置为空集。</li>
</ul>
<p>使fork失败的两个主要原因是：</p>
<ul>
<li>系统中已经有了太多的进程。</li>
<li>该实际用户ID的进程总数超过了系统限制。</li>
</ul>
<p>fork有以下两种用法：</p>
<ul>
<li>一个父进程希望复制自己，使父进程和子进程同时执行不同的代码段。父进程等待客户端的服务请求。当这种请求到达时，父进程调用<code>fork</code>，使子进程处理此请求。父进程则继续等待下一个服务请求。</li>
<li>一个进程要执行一个不同的程序。这对shell是常见的情况。在这种情况下，子进程从<code>fork</code>返回后立即调用<code>exec</code>。</li>
</ul>
<p>某些操作系统将<code>fork</code>之后执行<code>exec</code>组合成一个操作，称为<code>spawn</code>。Single UNIX Specification在高级实时选项组中确实包括了<code>spawn</code>接口。但是该接口并不想替换<code>fork</code>和<code>exec</code>。</p>
<h2 id="函数vfork"><a href="#函数vfork" class="headerlink" title="函数vfork"></a>函数vfork</h2><p><code>vfork</code>函数的调用序列和返回值与<code>fork</code>相同，但两者的语义不同。<code>vfork</code>函数用于创建一个新进程，而该新进程的目的是<code>exec</code>一个新程序。<code>vfork</code>与<code>fork</code>一样都创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用<code>exec</code>(或<code>exit</code>)，于是也就不会引用该地址空间。不过在子进程调用<code>exec</code>或<code>exit</code>之前，它在父进程的空间中运行。如果子进程修改数据(除了用于存放<code>vfork</code>返回值的变量)、进行函数调用、或者没有调用<code>exec</code>或<code>exit</code>就返回都可能会带来未知的结果。</p>
<p><code>vfork</code>和<code>fork</code>之间的另一个区别是，<code>vfork</code>保证子进程先运行，在它调用<code>exec</code>或<code>exit</code>之后父进程才可能被调度运行，当子进程调用这两个函数中的任意一个时，父进程会恢复运行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> globvar = <span class="number">6</span>;		<span class="comment">/* external variable in initialized data */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>		var;		<span class="comment">/* automatic variable on the stack */</span></span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	var = <span class="number">88</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;before vfork\n&quot;</span>);	<span class="comment">/* we don&#x27;t flush stdio */</span></span><br><span class="line">	<span class="keyword">if</span> ((pid = <span class="built_in">vfork</span>()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;vfork error&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;		<span class="comment">/* child */</span></span><br><span class="line">		globvar++;				<span class="comment">/* modify parent&#x27;s variables */</span></span><br><span class="line">		var++;</span><br><span class="line">		_exit(<span class="number">0</span>);				<span class="comment">/* child terminates */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* parent continues here */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;pid = %ld, glob = %d, var = %d\n&quot;</span>, (<span class="type">long</span>)<span class="built_in">getpid</span>(), globvar,</span><br><span class="line">	  var);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行该程序得到：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">betore vtork</span><br><span class="line">pid = 29039, glob = 7, var = 89</span><br></pre></td></tr></table></figure></p>
<p>子进程对变量做增1的操作，结果改变了父进程中的变量值。因为子进程在父进程的地址空间中运行，所以这并不令人惊讶。但是其作用的确与<code>fork</code>不同</p>
<h2 id="函数exit"><a href="#函数exit" class="headerlink" title="函数exit"></a>函数exit</h2><p>进程有5种正常终止及3种异常终止方式。5种正常终止方式具体如下。</p>
<ol>
<li>在<code>main</code>函数内执行return语句。</li>
<li>调用exit函数。此函数由ISO C定义，其操作包括调用各终止处理程序，然后关闭所有标准I/O流等。</li>
<li>调用<code>_exit</code>或<code>_Exit</code>函数。ISO C定义<code>_Exit</code>，其目的是为进程提供一种无需运行终止处理程序或信号处理程序而终止的方法。在UNIX系统中，<code>_Exit</code>和<code>_exit</code>是同义的。<code>_exit</code>函数由<code>exit</code>调用，它处理UNIX系统特定的细节。<code>_exit</code>是由POSIX.1说明的。</li>
<li>进程的最后一个线程在其启动例程中执行return语句。但是，该线程的返回值不用作进程的返回值。当最后一个线程从其启动例程返回时，该进程以终止状态0返回。</li>
<li>进程的最后一个线程调用<code>pthread_exit</code>函数。</li>
</ol>
<p>3种异常终止具体如下。</p>
<ol>
<li>调用<code>abort</code>。它产生SIGABRT信号。</li>
<li>当进程接收到某些信号时。信号可由进程自身、其他进程成内核产生。例如，若进程引用地址空间之外的存储单元、或者除以0，内核就会为该进程产生相应的信号。</li>
<li>最后一个线程对“取消”请求作出响应。默认情况下，“取消”以延迟方式发生：一个线程要求取消另一个线程，若干时间之后，目标线程终止。</li>
</ol>
<p>不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开描述符，释放它所使用的存储器等。</p>
<p>对上述任意一种终止情形，我们都希望终止进程能够通知其父进程它是如何终止的。对于3个终止函数(<code>exit</code>、<code>_exit</code>和<code>_Exit</code>)，实现这一点的方法是，将其退出状态(exitstatus)作为参数传送给函数。在异常终止情况，内核产生一个指示其异常终止原因的终止状态(termination status)。在任意一种情况下，该终止进程的父进程都能用<code>wait</code>或<code>waitpid</code>函数取得其终止状态。</p>
<p>注意，这里使用了“退出状态”和“终止状态”两个术语，以表示有所区别。在最后调用<code>exit</code>时，<strong>内核将退出状态转换成终止状态</strong>。如果子进程正常终止，则父进程可以获得子进程的退出状态。子进程将其终止状态返回给父进程。但是如果父进程在子进程之前终止，该子进程的父进程都改变为<code>init</code>进程。我们称这些进程由<code>init</code>进程收养。其操作过程大致是：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则该进程的父进程ID就更改为1(<code>init</code>进程的ID)。这种处理方法保证了每个进程有一个父进程。</p>
<p>如果子进程完全消失了，父进程在最终准备好检查子进程是否终止时是无法获取它的终止状态的。内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用<code>wait</code>或<code>waitpid</code>时，可以得到这些信息。这些信息至少包括进程ID、该进程的终止状态以及该进程使用的CPU时间总量。内核可以释放终止进程所使用的所有存储区，关闭其所有打开文件。在UNIX术语中，一个已经终止、但是其父进程尚未对其进行善后处理(获取终止子进程的有关信息、释放它仍占用的资源)的进程被称为<strong>僵死进程</strong>(zombie), <code>ps</code>命令将僵死进程的状态打印为Z。如果编写一个长期运行的程序，它<code>fork</code>了很多子进程，那么除非父进程等待取得子进程的终止状态，不然这些子进程终止后就会变成僵死进程。</p>
<p>由init进程收养的进程终止时会发生什么?init被编写成无论何时只要有一个子进程终止，<code>init</code>就会调用一个<code>wait</code>函数取得其终止状态。这样也就防止了在系统中塞满僵死进程。当提及“一个init的子进程”时，这指的可能是<code>init</code>直接产生的进程，也可能是其父进程已终止，由<code>init</code>收养的进程。</p>
<h2 id="函数wait和waitpid"><a href="#函数wait和waitpid" class="headerlink" title="函数wait和waitpid"></a>函数wait和waitpid</h2><p>当一个进程正常或异常终止时，内核就向其父进程发送<code>SIGCHLD</code>信号。因为子进程终止是个异步事件(这可以在父进程运行的任何时候发生)，所以这种信号也是内核向父进程发的异步通知。父进程可以选择忽略该信号，或者提供一个该信号发生时即被调用执行的函数(信号处理程序)。调用<code>wait</code>或<code>waitpid</code>的进程可能会发生：</p>
<ul>
<li>如果其所有子进程都还在运行，则阻塞。</li>
<li>如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。</li>
<li>如果它没有任何子进程，则立即出错返回。</li>
</ul>
<p>如果进程由于接收到SIGCHLD信号而调用<code>wait</code>，我们期望<code>wait</code>会立即返回。但是如果在随机时间点调用<code>wait</code>，则进程可能会阻塞。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span> <span class="params">(<span class="type">int</span> *statloc)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span> <span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *statioc, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">// 两个函数返回值：若成功，返回进程ID；若出错，返回0或-1</span></span><br></pre></td></tr></table></figure></p>
<p>这两个函数的区别如下。</p>
<ul>
<li>在一个子进程终止前，<code>wait</code>使其调用者阻塞，而<code>waitpid</code>有一选项，可使调用者不阻塞。</li>
<li><code>waitpid</code>并不等待在其调用之后的第一个终止子进程，它有着千个选项，可以控制它所等待的进程。</li>
</ul>
<p>如果子进程已经终止，并且是一个僵死进程，则<code>wait</code>立即返回并取得该子进程的状态；否则<code>wait</code>使其调用者阻塞，直到一个子进程终止。如调用者阻塞而且它有多个子进程，则在其某子进程终止时，<code>wait</code>就立即返回。因为<code>wait</code>返回终止子进程的进程ID，所以它总能了解是哪一个子进程终止了。</p>
<p>这两个函数的参数<code>statloc</code>是一个整型指针。如果<code>statloc</code>不是一个空指针，则终止进程的终止状态就存放在它所指向的单元内。如果不关心终止状态，则可将该参数指定为空指针。</p>
<p>依据传统，这两个函数返回的整型状态字是由实现定义的。其中某些位表示退出状态(正常返回)，其他位则指示信号编号(异常返回)，有一位指示是否产生了core文件等。POSIX.1规定，终止状态用定义在<code>&lt;sys/wait.h&gt;</code>中的各个宏来查看。有4个互斥的宏可用来取得进程终止的原因，它们的名字都以WIF开始。基于这4个宏中哪一个值为真，就可选用其他宏来取得退出状态、信号编号等。这4个互斥的宏示于图84中。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>宏</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>WIFEXITED(statu)</td>
<td>若为正常终止子进程返回的状态，则为真。对于这种情况可执行<code>WEXITSTATUS(status)</code>，获取了进程传送给<code>exit</code>或<code>exit</code>参数的低8位</td>
</tr>
<tr>
<td>WIFSIGNALED (status)</td>
<td>若为异常终止子进程返回的状态，则为真(接到一个不捕捉的信号)。对于这种情况，可执行<code>WTERMSIG(status)</code>，获取使子进程终止的信号编号。另外，有些实现定义宏<code>WCOREDUMP(statu)</code>，已产生终止进程的core文件，则它返回真</td>
</tr>
<tr>
<td>WIFSTOPPED (status)</td>
<td>若为当前智停子进程的返回的状态，则为真。对于这种情况，可执行<code>WSTOPSIG(status)</code>，获取使子进程暂停的信号编号</td>
</tr>
<tr>
<td>WIFCONTINUED (status)</td>
<td>若在作业控制暂停后已经继续的子进程返回了状态，则为真</td>
</tr>
</tbody>
</table>
</div>
<p>函数<code>pr_exit</code>使用宏以打印进程终止状态的说明。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pr_exit</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;normal termination, exit status = %d\n&quot;</span>, WEXITSTATUS (status));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED (status))</span><br><span class="line">		printt(<span class="string">&quot;abnormal termination, signal number = %d%s\n&quot;</span>, WTERMSIG(status),</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WCOREDUMP</span></span><br><span class="line">	WCOREDUMP(status) ? <span class="string">&quot;(core file generated)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (WIFSTOPPED(status))</span><br><span class="line">		printe(<span class="string">&quot;child stopped, signal number = %d\n&quot;</span>, WSTOPSIG(status));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序调用<code>pr_exit</code>函数，演示终止状态的各种值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line">	<span class="type">int</span>		status;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)				<span class="comment">/* child */</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">wait</span>(&amp;status) != pid)		<span class="comment">/* wait for child */</span></span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">	<span class="built_in">pr_exit</span>(status);				<span class="comment">/* and print its status */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)				<span class="comment">/* child */</span></span><br><span class="line">		<span class="built_in">abort</span>();					<span class="comment">/* generates SIGABRT */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">wait</span>(&amp;status) != pid)		<span class="comment">/* wait for child */</span></span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">	<span class="built_in">pr_exit</span>(status);				<span class="comment">/* and print its status */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)				<span class="comment">/* child */</span></span><br><span class="line">		status /= <span class="number">0</span>;				<span class="comment">/* divide by 0 generates SIGFPE */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">wait</span>(&amp;status) != pid)		<span class="comment">/* wait for child */</span></span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">	<span class="built_in">pr_exit</span>(status);				<span class="comment">/* and print its status */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行该程序可得：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">normal termination, <span class="built_in">exit</span> status = 7</span><br><span class="line">abnormal termination, signal number = 6 (core file generated)</span><br><span class="line">abnormal temination, signal number = 8 (core tile generated)</span><br></pre></td></tr></table></figure></p>
<p>现在，我们可以从<code>WTERMSIG</code>中打印信号编号。可以查看<code>&lt;signal.h&gt;</code>头文件验证<code>SIGABRT</code>的值为6，<code>SIGFPE</code>的值为8。</p>
<p>如果一个进程有几个子进程。那么只要有一个子进程终止，<code>wait</code>就返回。如果我们需要的是等待一个特定进程的函数。POSIX.1定义了<code>waitpid</code>函数以提供这种功能。对于<code>waitpid</code>函数中<code>pid</code>参数的作用解释如下，</p>
<ul>
<li><code>pid== -1</code>等待任一子进程。此种情况下，<code>waitpid</code>与<code>wait</code>等效。</li>
<li><code>pid&gt;0</code>等待进程ID与<code>pid</code>相等的子进程。</li>
<li><code>pid==0</code>等待组ID等于调用进程组ID的任一子进程。</li>
<li><code>pid&lt;-1</code>等待组ID等于<code>pid</code>绝对值的任一子进程。</li>
</ul>
<p><code>waitpid</code>函数返回终止子进程的进程ID，并将该子进程的终止状态存放在由<code>statloc</code>指向的存储单元中。对于<code>wait</code>，其唯一的出错是调用进程没有子进程(函数调用被一个信号中断时，也可能返回另一种出错)。但是对于<code>waitpid</code>，如果指定的进程或进程组不存在，或者参数<code>pid</code>指定的进程不是调用进程的子进程，都可能出错。</p>
<p><code>options</code>参数使我们能进一步控制<code>waitpid</code>的操作。此参数或者是0，或者是常量按位或运算的结果。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>WCONTINUED</td>
<td>若实现支持作业控制，那么由pid指定的任一子进程在停止后已经继续，但其状态尚未报告，则返回其状态</td>
</tr>
<tr>
<td>WNOHANG</td>
<td>若由pid指定的子进程并不是立即可用的，则waitpid不阻塞，此时其返回值为0</td>
</tr>
<tr>
<td>WUNTRACED</td>
<td>若某实现支持作业控制，而由pid指定的任一子进程已处于停止状态，并且其状态自停止以来还未报告过，则返回其状态。<code>WIFSTOPPED</code>宏确定返回值是否对应于一个停止的子进程</td>
</tr>
</tbody>
</table>
</div>
<p><code>waitpid</code>函数提供了<code>wait</code>函数没有提供的3个功能。</p>
<ol>
<li><code>waitpid</code>可等待一个特定的进程，而<code>wait</code>则返回任一终止子进程的状态。</li>
<li><code>waitpid</code>提供了一个<code>wait</code>的非阻塞版本。有时希望获取一个子进程的状态，但不想阻塞。</li>
<li><code>waitpid</code>通过<code>WUNTRACED</code>和<code>WCONTINUED</code>选项支持作业控制。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;		<span class="comment">/* first child */</span></span><br><span class="line">		<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);	<span class="comment">/* parent from second fork == first child */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We&#x27;re the second child; our parent becomes init as soon</span></span><br><span class="line"><span class="comment">		 * as our real parent calls exit() in the statement above.</span></span><br><span class="line"><span class="comment">		 * Here&#x27;s where we&#x27;d continue executing, knowing that when</span></span><br><span class="line"><span class="comment">		 * we&#x27;re done, init will reap our status.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		sleep(<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;second child, parent pid = %ld\n&quot;</span>, (<span class="type">long</span>)getppid());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) != pid)	<span class="comment">/* wait for first child */</span></span><br><span class="line">		err_sys(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We&#x27;re the parent (the original process); we continue executing,</span></span><br><span class="line"><span class="comment">	 * knowing that we&#x27;re not the parent of the second child.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个子进程调用<code>sleep</code>以保证在打印父进程ID时第一个子进程已终止。在<code>fork</code>之后，父进程和子进程都可继续执行，并且我们无法预知哪一个会先执行。在<code>fork</code>之后，如果不使第二个子进程休眠，那么它可能比其父进程先执行，于是它打印的父进程ID将是创建它的父进程， 而不是<code>init</code>进程(进程ID 1)。</p>
<p>执行图8-8程序得到：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">$ second child, parent pid = 1</span><br></pre></td></tr></table></figure></p>
<p>注意，当原先的进程(也就是exec本程序的进程)终止时，shell打印其提示符，这在第二个子进程打印其父进程ID之前。</p>
<h2 id="函数waitid"><a href="#函数waitid" class="headerlink" title="函数waitid"></a>函数waitid</h2><p><code>waitid</code>函数类似于<code>waitpid</code>，但提供了更多的灵活性。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">waitid</span><span class="params">(<span class="type">idtype_t</span> idtype, <span class="type">id_t</span> id, <span class="type">siginfo_t</span> *infop, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错：返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>与<code>waitpid</code>相似，<code>waitid</code>允许一个进程指定要等待的子进程。但它使用两个单独的参数表示要等待的子进程所属的类型，而不是将此与进程ID或进程组ID组合成一个参数。<code>id</code>参数的作用与<code>idtype</code>的值相关。该函数支持的<code>idtype</code>类型列在下表中。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>P_PID</td>
<td>等待一特定进程，id包含要等待子进程的进程ID</td>
</tr>
<tr>
<td>P_PGID</td>
<td>等待一特定进程组中的任一子进程，id包含要等待子进程的进程组ID</td>
</tr>
<tr>
<td>P_ALL</td>
<td>等待任一子进程，忽略id</td>
</tr>
</tbody>
</table>
</div>
<p><code>options</code>参数是各标志的按位或运算。这些标志指示调用者关注哪些状态变化。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>WCONTINUED</td>
<td>等待一进程，它以前曾被停止，此后又已继续，但其状态尚未报告</td>
</tr>
<tr>
<td>WEXITED</td>
<td>等特已退出的进程</td>
</tr>
<tr>
<td>WNOHANG</td>
<td>如无可用的子进程退出状态，立即返回而非阻塞</td>
</tr>
<tr>
<td>WNOWAIT</td>
<td>不破坏子进程退出状态。该子进程退出状态可由后续的wait，wastid或waitpid调用取得</td>
</tr>
<tr>
<td>WSTOPPED</td>
<td>等待一进程，它已经停止，但其状态尚未报告</td>
</tr>
</tbody>
</table>
</div>
<p><code>WCONTINUED</code>、<code>WEXITED</code>或<code>WSTOPPED</code>这3个常量之一必须在<code>options</code>参数中指定。</p>
<p><code>infop</code>参数是指向<code>siginfo</code>结构的指针。该结构包含了造成子进程状态改变有关信号的详细信息。</p>
<h2 id="函数wait3和wait4"><a href="#函数wait3和wait4" class="headerlink" title="函数wait3和wait4"></a>函数wait3和wait4</h2><p><code>wait3</code>和<code>wait4</code>两个函数提供的功能比POSIX.1函数<code>wait</code>、<code>waitpid</code>和<code>waitid</code>所提供功能的要多一个，这与附加参数有关。该参数允许内核返回由终止进程及其所有子进程使用的资源概况。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait3</span><span class="params">(<span class="type">int</span> *statloc, <span class="type">int</span> options, <span class="keyword">struct</span> rusage *rusage)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait4</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *statloc, <span class="type">int</span> options, <span class="keyword">struct</span> rusage *rusage)</span>;</span><br><span class="line"><span class="comment">// 两个函数返回值：若成功，返回进程ID；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>资源统计信息包括用户CPU时间总量、系统CPU时间总量、缺页次数、接收到信号的次数等。</p>
<h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><p>当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，我们认为发生了竞争条件(race condition)。如果在<code>fork</code>之后的某种逻辑显式或隐式地依赖于在<code>fork</code>之后是父进程先运行还是子进程先运行，那么<code>fork</code>函数就会是竞争条件活跃的滋生地。</p>
<p>如果一个进程希望等待一个子进程终止，则它必须调用wait函数中的一个。如果一个进程要等待其父进程终止，则可使用下列形式的循环：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getppid()!= <span class="number">1</span>)</span><br><span class="line">sleep(<span class="number">1</span>):</span><br></pre></td></tr></table></figure></p>
<p>这种形式的循环称为轮询(polling)，它的问题是浪费了CPU时间，因为调用者每隔1s都被唤醒，然后进行条件测试。</p>
<p>在父进程和子进程的关系中，常常出现下述情况。在<code>fork</code>之后，父进程和子进程都有一些事情要做。例如，父进程可能要用子进程ID更新日志文件中的一个记录，而子进程则可能要为父进程创建一个文件。在本例中，要求每个进程在执行完它的一套初始化操作后要通知对方，并且在继续运行之前，要等待另一方完成其初始化操作。这种情况可以用代码描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apse.h&quot;</span></span></span><br><span class="line">TELLWAIT(); <span class="comment">/* set things up for TELL_XXX&amp;WAIT_XXX */</span></span><br><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) </span><br><span class="line">	err_sys (<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;   <span class="comment">/*child*/</span></span><br><span class="line">	<span class="comment">/*child does whatever io necessary ...*/</span></span><br><span class="line">	TELL_PARENT (getppid()):</span><br><span class="line">	<span class="comment">/* tell parent we&#x27;re done*/</span></span><br><span class="line">	WAIT_PARENT(); <span class="comment">/* and wait fox parent*/</span></span><br><span class="line">	<span class="comment">/* and the child continues on its way */</span></span><br><span class="line">	<span class="built_in">exit</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* parent does whatever is necessary ...*/</span></span><br><span class="line">TELL_CNILD(pid);</span><br><span class="line"><span class="comment">/* tell child we&#x27;re done*/</span></span><br><span class="line">WAIT_CHILD();  <span class="comment">/* and wait for child*/</span></span><br><span class="line"><span class="comment">/* and the parent continues on its way ... */</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><br>假定在头文件<code>apue.h</code>中定义了需要使用的各个变量。5个例程<code>TELLWAIT</code>、<code>TELL_PARENT</code>、<code>TELL_CHILD</code>、<code>WAIT_PARENT</code>以及<code>WAIT_ CHILD</code>可以是宏，也可以是函数。</p>
<p>程序输出两个字符串：一个由子进程输出，另一个由父进程输出。因为输出依赖于内核使这两个进程运行的顺序及每个进程运行的时间长度，所以该程序包含了一个竞争条件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">charatatime</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">		charatatime(<span class="string">&quot;output from child\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		charatatime(<span class="string">&quot;output from parent\n&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">charatatime</span> <span class="params">(<span class="type">char</span> *str)</span> &#123;</span><br><span class="line">	<span class="type">char</span> *ptr;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>):</span><br><span class="line">	<span class="comment">/*set unbuffered */</span></span><br><span class="line">	<span class="keyword">for</span> (ptr = str; (c = *ptr++) != <span class="number">0</span>)</span><br><span class="line">		putc(c, <span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在程序中将标准输出设置为不带缓冲的，于是每个字符输出都需调用一次write。本例的目的是使内核能尽可能多次地在两个进程之间进行切换，以便演示竞争条件。下面的实际输出说明该程序的运行结果是会改变的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">ooutput from child</span><br><span class="line">utput from parent</span><br><span class="line">$ ./a.out</span><br><span class="line">ooutput from child</span><br><span class="line">utput trom parent</span><br><span class="line">$ ./a.out</span><br><span class="line">output from child</span><br><span class="line">output from parent</span><br></pre></td></tr></table></figure></p>
<p>修改程序，使其使用<code>TELL</code>和<code>WAIT</code>函数，于是形成了下边的程序。行首标以+号的行是新增加的行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">charatatine</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	TELL_WAIT();</span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		err_ays(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">		WAIT_PARENT();  <span class="comment">/* parent goes first*/</span></span><br><span class="line">		charatatime (<span class="string">&quot;output from child\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		charatatime (<span class="string">&quot;output trom parent\n&quot;</span>) i</span><br><span class="line">		TELL_CHILD(pid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">charatatime</span> <span class="params">(<span class="type">char</span> *str)</span> &#123;</span><br><span class="line">	<span class="type">char</span> *ptr;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	setbuf (<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">/*set unbuffered*/</span></span><br><span class="line">	<span class="keyword">for</span> (ptr = str; (c = *ptr++) != <span class="number">0</span>;)</span><br><span class="line">		putc(c, <span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行此程序则能得到所预期的输出——两个进程的输出不再交叉混合。上边的程序是使父进程先运行。如果将<code>fork</code>之后的行改成：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">	charatatime (<span class="string">&quot;output from child\n&quot;</span>);</span><br><span class="line">	TELL_PARENT (getppid());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	WAIT_CHILD();    <span class="comment">/*child goes first */</span></span><br><span class="line">	charatatime (<span class="string">&quot;output from parent\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>则子进程先运行。</p>
<h2 id="函数exec"><a href="#函数exec" class="headerlink" title="函数exec"></a>函数exec</h2><p>用<code>fork</code>函数创建新的子进程后，子进程往往要调用一种<code>exec</code>函数以执行另一个程序。当进程调用一种<code>exec</code>函数时，该进程执行的程序完全替换为新程序，而新程序则从其<code>main</code>函数开始执行。因为调用<code>exec</code>并不创建新进程，所以前后的进程ID并未改变。<code>exec</code>只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段。</p>
<p>有7种不同的<code>exec</code>函数可供使用，它们常常被统称为<code>exec</code>函数，我们可以使用这7个函数中的任一个。这些<code>exec</code>函数使得UNIX系统进程控制原语更加完善。用<code>fork</code>可以创建新进程，用<code>exec</code>可以初始执行新的程序。<code>exit</code>函数和<code>wait</code>函数处理终止和等待终止。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathmame, <span class="type">char</span> *<span class="type">const</span> angv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg0, ... <span class="comment">/* (char *)0, char *const envp[] */</span> )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *arg0, ... <span class="comment">/*(char *)0*/</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> angv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fexecve</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *<span class="type">const</span> angv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="comment">// 7个函数返回值：若出错，返回-1，若成功，不返回</span></span><br></pre></td></tr></table></figure></p>
<p>这些函数之间的第一个区别是前4个函数取路径名作为参数，后两个函数则取文件名作为参数，最后一个取文件描述符作为参数。当指定<code>flename</code>作为参数时：</p>
<ul>
<li>如果<code>filename</code>中包含<code>/</code>，则就将其视为路径名；</li>
<li>否则就按PATH环境变量，在它所指定的各目录中搜寻可执行文件。</li>
</ul>
<p><code>PATH</code>变量包含了一张目录表(称为路径前缀)，目录之间用冒号(:)分隔。例如，下列name-value环境字符串指定在4个目录中进行搜索。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=/bin:/ust/bin:/usr/local/bin:.</span><br></pre></td></tr></table></figure></p>
<p>最后的路径前缀<code>.</code>表示当前目录。(零长前缀也表示当前目录。在value的开始处可用<code>:</code>表示，在行中间则要用<code>::</code>表示，在行尾以<code>:</code>表示。)</p>
<p>如果<code>execlp</code>或<code>execvp</code>使用路径前缀中的一个找到了一个可执行文件，但是该文件不是由连接编辑器产生的机器可执行文件，则就认为该文件是一个shell脚本，于是试着调用<code>/bin/sh</code>，并以该    <code>filename</code>作为shell的输入。</p>
<p><code>fexecve</code>函数避免了寻找正确的可执行文件。而是依赖调用进程来完成这项工作。调用进程可以使用文件描述符验证所需要的文件并且无竞争地执行该文件。否则，拥有特权的恶意用户就可以在找到文件位置并且验证之后，但在调用进程执行该文件之前替换可执行文件(或可执行文件的部分路径)。</p>
<p>第二个区别与参数表的传递有关(l表示列表list，v表示矢量vector)。函数<code>execl</code>、<code>execlp</code>和<code>execle</code>要求将新程序的每个命令行参数都说明为一个单独的参数。这种参数表以空指针结尾。对于另外4个函数(<code>execv</code>、<code>execvp</code>、<code>execve</code>和<code>fexecve</code>)，则应先构造一个指向各参数的指针数组，然后将该数组地址作为这4个函数的参数。</p>
<p>在使用ISO C原型之前，对<code>execl</code>、<code>execle</code>和<code>execlp</code>三个函数表示命令行参数的一般方法是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *arg0, char *arg1, ..., char *argn, (char *)0</span><br></pre></td></tr></table></figure></p>
<p>这种语法显式地说明了最后一个命令行参数之后跟了一个空指针。如果用常量0来表示一个空指针，则必须将它强制转换为一个指针：否则它将被解释为整型参数。如果一个整型数的长度与<code>char *</code>的长度不同，那么<code>exec</code>函数的实际参数将出错。</p>
<p>最后一个区别与向新程序传递环境表相关。以e结尾的3个函数(<code>execle</code>、<code>execve</code>和<code>fexecve</code>)可以传递一个指向环境字符串指针数组的指针。其他4个函数则使用调用进程中的<code>environ</code>变量为新程序复制现有的环境。通常，一个进程允许将其环境传播给其子进程，但有时也有这种情况，进程想要为子进程指定某一个确定的环境。</p>
<p>在使用ISOC原型之前，<code>execle</code>的参数是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *pathname, <span class="type">char</span> *arg0, <span class="type">char</span> *argn, (<span class="type">char</span> *)<span class="number">0</span>, <span class="type">char</span> *envp[]</span><br></pre></td></tr></table></figure><br>从中可见，最后一个参数是指向环境字符串的各字符指针构成的数组的指针。而在ISO C原型中，所有命令行参数、空指针和<code>envp</code>指针都用省略号(…)表示。</p>
<p>这7个<code>exec</code>函数的参数很难记忆。函数名中的字符会给我们一些帮助。字母p表示该函数取<code>flename</code>作为参数，并且用PATH环境变量寻找可执行文件。字母l表示该函数取一个参数表，它与字母v互斥。v表示该函数取一个<code>arg[]</code>矢量。最后，字母e表示该函数取<code>envp[]</code>数组，而不使用当前环境。</p>
<p>每个系统对参数表和环境表的总长度都有一个限制。这种限制是由<code>ARG_MAX</code>给出的。在POSIX.1系统中，此值至少是4096字节。当使用shell的文件名扩充功能产生一个文件名列表时，可能会受到此值的限制。例如，命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep getrlimit /usr/share/man/*/*</span><br></pre></td></tr></table></figure></p>
<p>在某些系统上可能产生如下形式的shell错误：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Argument list too long</span><br></pre></td></tr></table></figure></p>
<p>为了摆脱对参数表长度的限制，我们可以使用<code>xargs(1)</code>命令，将长参数表断开成几部分。</p>
<p>前面曾提及，在执行<code>exec</code>后，进程ID没有改变。但新程序从调用进程继承了的下列属性：</p>
<ul>
<li>进程ID和父进程ID</li>
<li>实际用户ID和实际组ID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>会话ID</li>
<li>控制终端</li>
<li>闹钟尚余留的时间</li>
<li>当前工作日录</li>
<li>根目录</li>
<li>文件模式创建屏蔽字</li>
<li>文件锁</li>
<li>进程信号屏蔽</li>
<li>未处理信号</li>
<li>资源限制</li>
<li>nice值</li>
<li><code>tms_utime</code>、<code>tms_stime</code>、<code>tms_cutime</code>以及<code>tms_cstime</code>值</li>
</ul>
<p>对打开文件的处理与每个描述符的执行时关闭(close-on-exec)标志值有关。进程中每个打开描述符都有一个执行时关闭标志。若设置了此标志，则在执行<code>exec</code>时关闭该描述符；否则该描述符仍打开。除非特地用<code>fcntl</code>设置了该执行时关闭标志，否则系统的默认操作是在<code>exec</code>后仍保持这种描述符打开。</p>
<p>注意，在<code>exec</code>前后实际用户ID和实际组ID保持不变，而有效ID是否改变则取决于所执行程序文件的设置用户ID位和设置组ID位是否设置。如果新程序的设置用户ID位已设置，则有效用户ID变成程序文件所有者的ID；否则有效用户ID不变。对组ID的处理方式与此相同。</p>
<p>在很多UNIX实现中，这7个函数中只有<code>execve</code>是内核的系统调用。另外6个只是库函数，它们最终都要调用该系统调用。<br><img src="/img/20210524233035.png" alt=""></p>
<p>在这种安排中，库函数<code>execlp</code>和<code>execvp</code>使用PATH环境变量，查找第一个包含名为<code>filename</code>的可执行文件的路径名前缀。<code>fexecve</code>库函数使用<code>/proc</code>把文件措述符参数转换成路径名，<code>execve</code>用该路径名去执行程序。</p>
<p>程序演示了exec函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>	*env_init[] = &#123; <span class="string">&quot;USER=unknown&quot;</span>, <span class="string">&quot;PATH=/tmp&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;	<span class="comment">/* specify pathname, specify environment */</span></span><br><span class="line">		<span class="keyword">if</span> (execle(<span class="string">&quot;/home/sar/bin/echoall&quot;</span>, <span class="string">&quot;echoall&quot;</span>, <span class="string">&quot;myarg1&quot;</span>,</span><br><span class="line">				<span class="string">&quot;MY ARG2&quot;</span>, (<span class="type">char</span> *)<span class="number">0</span>, env_init) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">&quot;execle error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;	<span class="comment">/* specify filename, inherit environment */</span></span><br><span class="line">		<span class="keyword">if</span> (execlp(<span class="string">&quot;echoall&quot;</span>, <span class="string">&quot;echoall&quot;</span>, <span class="string">&quot;only 1 arg&quot;</span>, (<span class="type">char</span> *)<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">&quot;execlp error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>在该程序中先调用<code>execle</code>，它要求一个路径名和一个特定的环境。下一个调用的是<code>execlp</code>，它用一个文件名，并将调用者的环境传送给新程序。<code>execlp</code>在这里能够工作是因为目录<code>/home/sar/bin</code>是当前路径前缀之一。注意，我们将第一个参数(新程序中的<code>argv[0]</code>)设置为路径名的文件名分量。某些shell将此参数设置为完全的路径名。这只是一个惯例。我们可将<code>argv[0]</code>设置为任何字符串。当login命令执行shell时就是这样做的。在执行shell之前，login在<code>argv[0]</code>之前加一个<code>/</code>作为前缀，这向shell指明它是作为登录shell被调用的。登录shell将执行启动配置文件(start-up profile)命令，而非登录shell则不会执行这些命令。</p>
<h2 id="更改用户ID和更改组ID"><a href="#更改用户ID和更改组ID" class="headerlink" title="更改用户ID和更改组ID"></a>更改用户ID和更改组ID</h2><p>在UNIX系统中，特权(如能改变当前日期的表示法)以及访问控制(如能否读、写一个特定文件)，是基于用户ID和组ID的。当程序需要增加特权，或需要访问当前并不允许访问的资源时，我们需要更换自己的用户ID或组ID，使得新ID具有合适的特权或访问权限。与此类似，当程序需要降低其特权或阻止对某些资源的访问时，也需要更换用户ID或组ID，新ID不具有相应特权或访问这些资源的能力。</p>
<p>一般而言，在设计应用时，我们总是试图使用最小特权(least privilege)模型。依照此模型，我们的程序应当只具有为完成给定任务所需的最小特权。</p>
<p>可以用<code>setuid</code>函数设置实际用户ID和有效用户ID。与此类似，可以用<code>setgid</code>函数设置实际组ID和有效组ID。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br><span class="line"><span class="comment">// 两个函数返回值，若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>关于谁能更改ID有若干规则。现在先考虑更改用户ID的规则</p>
<ol>
<li>若进程具有超级用户特权，则<code>setuid</code>函数将实际用户ID、有效用户ID以及保存的设置用户ID(saved set-user-ID)设置为uid；</li>
<li>若进程没有超级用户特权，但是<code>uid</code>等于实际用户ID或保存的设置用户ID，则<code>setuid</code>只将有效用户ID设置为uid。不更改实际用户ID和保存的设置用户ID。</li>
<li>如果上面两个条件都不满足，则errno设置为EPERM，并返回-1。</li>
</ol>
<p>在此假定<code>_POSIX_SAVED_IDS</code>为真。如果没有提供这种功能。则上面所说的关于保存的设置用户ID部分都无效。</p>
<p>关于内核所维护的3个用户ID，还要注意以下几点。</p>
<ol>
<li>只有超级用户进程可以更改实际用户ID。通常，实际用户ID是在用户登录时，由<code>login(1)</code>程序设置的，而且决不会改变它。因为<code>login</code>是一个超级用户进程，当它调用<code>setuid</code>时，设置所有3个用户ID。</li>
<li>仅当对程序文件设置了设置用户ID位时，<code>exec</code>函数才设置有效用户ID。如果设置用户ID位没有设置，<code>exec</code>函数不会改变有效用户ID，而将维持其现有值。任何时候都可以调用<code>setuid</code>，将有效用户ID设置为实际用户ID或保存的设置用户ID。自然地，不能将有效用户ID设置为任一随机值。</li>
<li>保存的设置用户ID是由<code>exec</code>复制有效用户ID而得到的。如果设置了文件的设置用户ID位。则在<code>exec</code>根据文件的用户ID设置了进程的有效用户ID以后，这个副本就被保存起来了。</li>
</ol>
<h3 id="函数setreuid和sotregid"><a href="#函数setreuid和sotregid" class="headerlink" title="函数setreuid和sotregid"></a>函数setreuid和sotregid</h3><p>历史上，BSD支持<code>setreuid</code>函数，其功能是交换实际用户ID和有效用户ID的值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setreuid</span><span class="params">(<span class="type">uid_t</span> ruid, <span class="type">uid_t</span> exid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setregid</span><span class="params">(<span class="type">gid_t</span> rgid, <span class="type">gid_t</span> egid)</span>;</span><br><span class="line"><span class="comment">// 两个函数返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>如若其中任一参数的值为-1，则表示相应的ID应当保持不变。</p>
<p>规则很简单：一个非特权用户总能交换实际用户ID和有效用户ID。这就允许一个设置用户ID程序交换成用户的普通权限，以后又可再次交换回设置用户ID权限。POSIX.1引进了保存的设置用户ID特性后，允许一个非特权用户将其有效用户ID设置为保存的设置用户ID。</p>
<h3 id="函数seteuid和sotegid"><a href="#函数seteuid和sotegid" class="headerlink" title="函数seteuid和sotegid"></a>函数seteuid和sotegid</h3><p>POSIX.1包含了两个函数<code>seteuid</code>和<code>setegid</code>。它们类似于<code>setuid</code>和<code>setgid</code>，但只更改有效用户ID和有效组ID。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">seteuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setegid</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br><span class="line"><span class="comment">// 两个函数返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>一个非特权用户可将其有效用户ID设置为其实际用户ID或其保存的设置用户ID。对于一个特权用户则可将有效用户ID设置为uid。 </p>
<p>图中给出了本节所述的更改3个不同用户ID的各个函数。<br><img src="/img/20210525002706.png" alt=""></p>
<h3 id="组ID"><a href="#组ID" class="headerlink" title="组ID"></a>组ID</h3><p>本章中所说明的一切都以类似方式适用于各个组ID。附属组ID不受<code>setgid</code>、<code>setregid</code>和<code>setegid</code>函数的影响。</p>
<p>为了说明保存的设置用户ID特性的用法，先观察一个使用该特性的程序。我们所观察的是<code>at(1)</code>程序，它用于调度将来某个时刻要运行的命令。</p>
<p>为了防止被欺骗而运行不被允许的命令或读、写没有访问权限的文件，<code>at</code>命令和最终代表用户运行命令的守护进程必须在两种特权之间切换：用户特权和守护进程特权。下面列出了其工作步骤。</p>
<ul>
<li>程序文件是由root用户拥有的， 并且其设置用户ID位已设置。当我们运行此程序时，得到下列结果：<ul>
<li>实际用户ID=我们的用户ID(未改变)</li>
<li>有效用户ID=root</li>
<li>保存的设置用户ID=root</li>
</ul>
</li>
<li><code>at</code>程序做的第一件事就是降低特权，以用户特权运行。它调用<code>setuid</code>函数把有效用户D设置为实际用户ID。此时得到：<ul>
<li>实际用户ID=我们的用户ID(未改变)</li>
<li>有效用户ID=我们的用户ID</li>
<li>保存设置用户ID=root(未改变)</li>
</ul>
</li>
<li><code>at</code>程序以我们的用户特权运行，直到它需要访问控制哪些命令即将运行，这些命令需要何时运行的配置文件时，<code>at</code>程序的特权会改变，这些文件由为用户运行命令的守护进程持有。<code>at</code>命令调用<code>setuid</code>函数把有效用户ID设为root，因为<code>setuid</code>的参数等于保存的设置用户ID，所以这种调用是许可的。现在得到：<ul>
<li>实际用户ID-我们的用户ID(未改变)</li>
<li>有效用户ID=root</li>
<li>保存的设置用户ID=root(未改变)</li>
<li>因为有效用户ID是root，文件访问是允许的。</li>
</ul>
</li>
<li>修改文件从而记录了将要运行的命令以及它们的运行时间以后，<code>at</code>命令通过调用<code>seteusid</code>，把有效用户ID设置为用户ID，降低它的特权。防止对特权的误用。此时我们可以得到：<ul>
<li>实际用户ID=我们的用户ID(未改变)</li>
<li>有效用户ID=我们的用户ID</li>
<li>保存的设置用户ID=root(来改变)</li>
</ul>
</li>
<li>守护进程开始用root特权运行，代表用户运行命令，守护进程调用<code>fork</code>，子进程调用<code>setuid</code>将它的用户ID更改至我们的用户ID。因为子进程以root特权运行，更改了所有的ID，所以<ul>
<li>实际用户ID=我们的用户ID</li>
<li>有效用户ID=我们的用户ID</li>
<li>保存的设置用户ID=我们的用户ID</li>
</ul>
</li>
</ul>
<p>现在守护进程可以安全地代表我们执行命令，因为它只能访问我们通常可以访问的文件，我们没有额外的权限。</p>
<p>以这种方式使用保存的设置用户ID，只有在需要提升特权的时候，我们通过设置程序文件的设置用户ID而得到的额外权限。然而，其他时间进程在运行时只具有普通的权限。如果进程不能在其结束部分切换回保存的设置用户ID，那么就不得不在全部运行时间都保持额外的权限(这可能会造成麻烦)。</p>
<h2 id="解释器文件"><a href="#解释器文件" class="headerlink" title="解释器文件"></a>解释器文件</h2><p>所有现今的UNIX系统都支持解释器文件(interpreter file)。这种文件是文本文件，其起始行的形式是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! pathname [ optional-argument]</span></span><br></pre></td></tr></table></figure></p>
<p>在感叹号和pathname之间的空格是可选的。最常见的解释器文件以下列行开始：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br></pre></td></tr></table></figure></p>
<p>pathname通常是绝对路径名，对它不进行什么特殊的处理(不使用PATH进行路径搜索)。对这种文件的识别是由内核作为<code>exec</code>系统调用处理的一部分来完成的。内核使调用<code>exec</code>函数的进程实际执行的并不是该解释器文件，而是在该解释器文件第一行中pathname所指定的文件。一定要将解释器文件(文本文件，它以!开头)和解释器(由该解释器文件第一行中的pathname指定)区分开来。</p>
<p>让我们观察一个实例，从中可了解当被执行的文件是个解释器文件时，内核如何处理<code>exec</code>函数的参数及该解释器文件第一行的可选参数。程序调用<code>exec</code>执行一个解释器文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;			<span class="comment">/* child */</span></span><br><span class="line">		<span class="keyword">if</span> (execl(<span class="string">&quot;/home/sar/bin/testinterp&quot;</span>,</span><br><span class="line">				  <span class="string">&quot;testinterp&quot;</span>, <span class="string">&quot;myarg1&quot;</span>, <span class="string">&quot;MY ARG2&quot;</span>, (<span class="type">char</span> *)<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">&quot;execl error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)	<span class="comment">/* parent */</span></span><br><span class="line">		err_sys(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面先显示要被执行的该解释器文件的内容(只有一行)，接着是运行程序得到的结果。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /home/max/bin/teatinterp</span><br><span class="line"><span class="comment">#!/hone/sax/bin/echoarg foo</span></span><br><span class="line"></span><br><span class="line">$ ./a.out</span><br><span class="line">argv[0]: /home/sar/bin/echoarg</span><br><span class="line">argv[1]: foo</span><br><span class="line">argv[2]: /hone/sar/bin/testinterp</span><br><span class="line">argv[3]: myarg1</span><br><span class="line">argv[4]: MY ARG2</span><br></pre></td></tr></table></figure></p>
<p>程序<code>echoarg</code>(解释器)回显每一个命令行参数。注意，当内核<code>exec</code>解释器(<code>/home/sar/bin/echoarg</code>)时，<code>argv[0]</code>是该解释器的<code>pathname</code>，<code>argv[1]</code>是解释器文件中的可选参数，其余参数是<code>pathname</code>(<code>/home/sar/bin/testinterp</code>)以及所示的程序中调用<code>execl</code>的第2个和第3个参数(<code>myarg1</code>和<code>MY ARG2</code>)。调用<code>execl</code>时的<code>argv[1]</code>和<code>argv[2]</code>已右移了两个位置。注意，内核取<code>execl</code>调用中的<code>pathname</code>而非第一个参数(<code>testinterp</code>)，因为一般而言，<code>parhname</code>包含了比第一个参数更多的信息。</p>
<p>在解释器pathname后可跟随可选参数。如果一个解释器程序支持<code>-f</code>选项，那么在<code>pathname</code>后经常使用的就是<code>f</code>。例如，可以以下列方式执行<code>awk(1)</code>程序：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -f myfile</span><br></pre></td></tr></table></figure></p>
<p>它告诉<code>awk</code>从文件<code>myfile</code>中读<code>awk</code>程序。</p>
<p>在解释器文件中使用<code>-f</code>选项，可以写成：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/awk -f</span></span><br></pre></td></tr></table></figure></p>
<p>例如，下面展示了在<code>/usr/local/bin/awkexample</code>中的一个解释器文件程序。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/awk -f</span></span><br><span class="line"><span class="comment"># Note: on Solario, use nawk instead</span></span><br><span class="line">BEGIN &#123;</span><br><span class="line">	<span class="keyword">for</span> (i = 0; i &lt; ARGC; i ++)</span><br><span class="line">		prints <span class="string">&quot;ARGV[%d] = %s\n&quot;</span>, i, ARGV[i]</span><br><span class="line">	<span class="built_in">exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果路径前缀之一是<code>/usr/local/bin</code>。则可以用下列方式执行程序<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awkexample file1 FILENAME2 f3</span><br><span class="line">ARGV[0] = awk</span><br><span class="line">ARGV[1] = file1</span><br><span class="line">ARGV[2] = FILENAME2</span><br><span class="line">ARGV[3] = f3</span><br></pre></td></tr></table></figure></p>
<p>执行<code>/bin/awk</code>时，其命令行参数是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/awk -t /usr/local/bin/awkexample filel FILENAME2 f3</span><br></pre></td></tr></table></figure></p>
<p>解释器文件的路径名(<code>/usr/local/bin/awkexample</code>)被传送给解释器。因为不能期望解释器(在本例中是<code>/bin/awk</code>)会使用<code>PATH</code>变量定位该解释器文件，所以只传送其路径名中的文件名是不够的，要将解释器文件完整的路径名传送给解释器。当awk读解释器文件时，因为<code>#</code>是awk的注释字符，所以它忽略第一行。</p>
<p>由于下述理由，解释器文件是有用的：</p>
<ol>
<li>有些程序是用某种语言写的脚本，解释器文件可将这一事实隐藏起来。例如，只需使用下列命令行：<code>awkexample optional-arguments</code>，并不需要知道该程序实际上是一个<code>awk</code>脚本，否则就要<code>awk -f awkexample opriomal-arguments</code></li>
<li>解释器脚本在效率方面也提供了好处。为了运行<code>awk</code>程序，它调用<code>fork</code>、<code>exec</code>和<code>wait</code>。于是，用一个shell脚本代替解释器脚本需要更多的开销。</li>
<li>解释器脚本使我们可以使用除<code>/bin/sh</code>以外的其他shell来编写shell脚本。当<code>execlp</code>找到一个非机器可执行的可执行文件时，它总是调用<code>/bin/sh</code>来解释执行该文件。但是，用解释器脚本则可简单地写成：<code>#!/bin/csh</code></li>
</ol>
<h2 id="函数system"><a href="#函数system" class="headerlink" title="函数system"></a>函数system</h2><p>ISO C定义了<code>system</code>函数，但是其操作对系统的依赖性很强。POSIX.1包括了<code>system</code>接口，它扩展了ISO C定义，描述了<code>system</code>在POSIX.1环境中的运行行为。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmdstring)</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果<code>cmdstring</code>是一个空指针，则仅当命令处理程序可用时，<code>system</code>返回非0值，这一特征可以确定在一个给定的操作系统上是否支持<code>system</code>函数。在UNIX中，<code>system</code>总是可用的。因为<code>system</code>在其实现中调用了<code>fork</code>、<code>exec</code>和<code>waitpid</code>，因此有3种返回值。</p>
<ol>
<li><code>fork</code>失败或者<code>waitpid</code>返回除EINTR之外的出错，则<code>system</code>返回-1，并且设置errno以指示错误类型。</li>
<li>如果<code>exec</code>失败(表示不能执行shell), 则其返回值如同shell执行了exit(127)一样</li>
<li>否则所有3个函数(<code>fork</code>、<code>exec</code>和<code>waitpid</code>)都成功，那么<code>system</code>的返回值是shell的终止状态，其格式已在waitpid中说明。</li>
</ol>
<p>程序是<code>system</code>函数的一种实现。它对信号没有进行处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmdstring)</span>	<span class="comment">/* version without signal handling */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line">	<span class="type">int</span>		status;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cmdstring == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">1</span>);		<span class="comment">/* always a command processor with UNIX */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		status = <span class="number">-1</span>;	<span class="comment">/* probably out of processes */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;				<span class="comment">/* child */</span></span><br><span class="line">		execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmdstring, (<span class="type">char</span> *)<span class="number">0</span>);</span><br><span class="line">		_exit(<span class="number">127</span>);		<span class="comment">/* execl error */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;							<span class="comment">/* parent */</span></span><br><span class="line">		<span class="keyword">while</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (errno != EINTR) &#123;</span><br><span class="line">				status = <span class="number">-1</span>; <span class="comment">/* error other than EINTR from waitpid() */</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>shell的<code>-c</code>选项告诉shell程序取下一个命令行参数(在这里是cmdstring)作为命令输入(而不是从标准输入或从一个给定的文件中读命令)。shell对以null字节终止的命令字符串进行语法分析，将它们分成命令行参数。传递给shell的实际命令字符串可以包含任一有效的shell命令。例如，可以用&lt;和&gt;对输入和输出重定向。</p>
<p>如果不使用shell执行此命令，而是试图由我们自己去执行它，那将相当困难。首先，我们必须用<code>execlp</code>而不是<code>execl</code>。像shell那样使用PATH变量。我们必须将null字节终止的命令字符串分成各个命令行参数，以便调用<code>execlp</code>。最后，我们也不能使用任何一个shell元字符。</p>
<p>注意，我们调用<code>_exit</code>而不是<code>exit</code>。这是为了防止任一标准I/O缓冲(这些缓冲会在<code>fork</code>中由父进程复制到子进程)在子进程中被冲洗。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		status;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((status = system(<span class="string">&quot;date&quot;</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;system() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	pr_exit(status);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((status = system(<span class="string">&quot;nosuchcommand&quot;</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;system() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	pr_exit(status);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((status = system(<span class="string">&quot;who; exit 44&quot;</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;system() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	pr_exit(status);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序得到：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">Sat Feb 25 19:36:59 EST 2012</span><br><span class="line">normal termination, <span class="built_in">exit</span> status = 0</span><br><span class="line"></span><br><span class="line">sh: nosuchcomnand: <span class="built_in">command</span> not found</span><br><span class="line">normal termination, <span class="built_in">exit</span> atatus = 127</span><br><span class="line">sar console Jan 1 14:59</span><br><span class="line">sar ttys000 Feb 7 19:08</span><br><span class="line">sar ttys001 Jan 15 15:28</span><br><span class="line">sar ttys002 Jan 15 21:50</span><br><span class="line">sar ttys003 Jan 21 16:02</span><br><span class="line">nornal termination, <span class="built_in">exit</span> status = 44</span><br></pre></td></tr></table></figure></p>
<p>使用<code>system</code>而不是直接使用<code>fork</code>和<code>exec</code>的优点是：<code>system</code>进行了所需的各种出错处理以及各种信号处理。在UNIX的早期系统中没有<code>waitpid</code>函数，于是父进程用下列形式的语句等待子进程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((lastpid = wait(&amp;status)) != pid &amp;&amp; lastpid != <span class="number">-1</span>) ;</span><br></pre></td></tr></table></figure></p>
<p>如果调用<code>system</code>的进程在调用它之前已经生成子进程，那么将引起问题。因为上面的while语句一直循环执行。直到由<code>system</code>产生的子进程终止才停止，如果不是用pid标识的任一子进程在pid子进程之前终止，则它们的进程ID和终止状态都被while语句丢弃。实际上，由于<code>wait</code>不能等待一个指定的进程以及其他一些原因，POSIX.1才定义了<code>waitpid</code>函数。如果不提供<code>waitpid</code>函数，<code>popen</code>和<code>pclose</code>函数也会发生同样的问题。</p>
<p>如果在一个设置用户ID程序中调用<code>system</code>，那会发生什么呢?这是一个安全性方面的漏洞，决不应当这样做。程序是一个简单程序，它只是对其命令行参数调用<code>system</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		status;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;command-line argument required&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((status = system(argv[<span class="number">1</span>])) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;system() error&quot;</span>);</span><br><span class="line">	pr_exit(status);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将此程序编译成可执行目标文件<code>tsys</code>。我们给予<code>tsys</code>程序的超级用户权限在<code>system</code>中执行了<code>fork</code>和<code>exec</code>之后仍被保持下来。有些实现通过更改<code>/bin/sh</code>，当有效用户ID与实际用户ID不匹配时，将有效用户ID设置为实际用户ID，这样可以关闭上述安全漏洞。在这些系统中，上述示例的结果就不会发生。不管调用<code>system</code>的程序设置用户ID位状态如何，都会打印出相同的有效用户ID。</p>
<p>如果一个进程正以特殊的权限(设置用户ID或设置组ID)运行，它又想生成另一个进程执行另一个程序，则它应当直接使用<code>fork</code>和<code>exec</code>，而且在<code>fork</code>之后、<code>exec</code>之前要更改回普通权限。设置用户ID或设置组ID程序决不应调用system函数。</p>
<p>这种警告的一个理由是：<code>system</code>调用shell对命令字符串进行语法分析，而shell使用IFS变量作为其输入字段分隔符。早期的shell版本在被调用时不将此变量重置为普通字符集。这就允许一个恶意的用户在调用<code>system</code>之前设置IFS，造成<code>system</code>执行一个不同的程序。</p>
<h2 id="进程会计"><a href="#进程会计" class="headerlink" title="进程会计"></a>进程会计</h2><p>大多数UNIX系统提供了一个选项以进行<strong>进程会计</strong>(process accounting)处理。启用该选项后，每当进程结束时内核就写一个会计记录。典型的会计记录包含总量较小的二进制数据，一般包括命令名、所使用的CPU时间总量、用户ID和组ID、启动时间等。</p>
<p>一个至今没有说明的函数(<code>acct</code>)启用和禁用进程会计。唯一使用这一函数的是<code>accton(8)</code>命令。超级用户执行一个带路径名参数的<code>accton</code>命令启用会计处理。会计记录写到指定的文件中，在FreeBSD和MacOSX中，该文件通常是<code>/var/account/acct</code>；在Linux中，该文件是<code>/var/account/pacct</code>；在Solaris中，该文件是<code>/var/adm/pacct</code>。执行不带任何参数的<code>accton</code>命令则停止会计处理。会计记录结构定义在头文件<code>&lt;sys/acct.h&gt;</code>中，虽然每种系统的实现各不相同，但会计记录样式基本如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> u_short <span class="type">comp_t</span>;</span><br><span class="line"><span class="comment">/* 3-bit base 8 exponent;13-bit fraction*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">acct</span> &#123;</span><br><span class="line"><span class="type">char</span> ac_flag;   <span class="comment">/* flag (see Figuze 8.26) */</span></span><br><span class="line"><span class="type">char</span> ac_stat;   <span class="comment">/* ternination status (signal 6 core tlag only) */</span></span><br><span class="line">                <span class="comment">/*(Solaris only) */</span></span><br><span class="line"><span class="type">usd_t</span> ac_uid;   <span class="comment">/*real user ID*/</span></span><br><span class="line"><span class="type">gid_t</span> ac_gid;   <span class="comment">/* real group tD*/</span></span><br><span class="line"><span class="type">dev_t</span> ac_tty;   <span class="comment">/*controlling texminal*/</span></span><br><span class="line"><span class="type">time_t</span> ac_btime;<span class="comment">/*starting calendar time*/</span></span><br><span class="line"><span class="type">comp_t</span> ac_utime;<span class="comment">/*user cru time*/</span></span><br><span class="line"><span class="type">comp_t</span> ac_stime;<span class="comment">/* aystem cru time*/</span></span><br><span class="line"><span class="type">comp_t</span> ac_etime;<span class="comment">/*clapsed time*/</span></span><br><span class="line"><span class="type">comp_t</span> ac_mem;  <span class="comment">/*average memory usage*/</span></span><br><span class="line"><span class="type">coap_t</span> ac_io;   <span class="comment">/* bytes transferred (by read and write) */</span></span><br><span class="line">                <span class="comment">/* &quot;blocks&quot; on BSD systems*/</span></span><br><span class="line"><span class="type">comp_t</span> ac_rw;   <span class="comment">/* blocks read or written*/</span></span><br><span class="line">                <span class="comment">/* (not present on B80 systens) */</span></span><br><span class="line"><span class="type">char</span> ac_comm[<span class="number">8</span>];<span class="comment">/*comand name: [8] for solaris,&quot;</span></span><br><span class="line"><span class="comment">                /* [10] for Mac OS X, [16] for FreeBSD, and*/</span></span><br><span class="line">                <span class="comment">/* [17] for Linux*/</span></span><br></pre></td></tr></table></figure></p>
<p><code>ac_flag</code>成员记录了进程执行期间的某些事件。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>ac_flag</code></th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>AFORK</td>
<td>进程是由<code>fork</code>产生的，但从未调用<code>exec</code></td>
</tr>
<tr>
<td>ASU</td>
<td>进程使用超级用户特权</td>
</tr>
<tr>
<td>ACORE</td>
<td>进程转储core</td>
</tr>
<tr>
<td>AXSIG</td>
<td>进程由一个信号杀死</td>
</tr>
<tr>
<td>AEXPND</td>
<td>扩展的会计条目</td>
</tr>
<tr>
<td>ANVER</td>
<td>新记录格式</td>
</tr>
</tbody>
</table>
</div>
<p>会计记录所需的各个数据(各CPU时间、传输的字符数等)都由内核保存在进程表中，并在一个新进程被创建时初始化(如fork之后在子进程中)。进程终止时写一个会计记录。这产生两个后果。</p>
<ul>
<li>第一，我们不能获取永远不终止的进程的会计记录。像<code>init</code>这样的进程在系统生命周期中一直在运行，并不产生会计记录。这也同样适合于内核守护进程，它们通常不会终止。</li>
<li>第二，在会计文件中记录的顺序对应于进程终止的顺序，而不是它们启动的顺序。为了确定启动顺序，需要读全部会计文件，并按启动日历时间进行排序。这不是一种很完善的方法，因为在一个给定的秒中可能启动了多个进程。</li>
</ul>
<p>会计记录对应于进程而不是程序。在<code>fork</code>之后，内核为子进程初始化一个记录，而不是在一个新程序被执行时初始化。虽然<code>exec</code>并不创建一个新的会计记录，但相应记录中的命令名改变了，<code>AFORK</code>标志则被消除。这意味着，如果一个进程顺序执行了3个程序，只会写一个会计记录。在该记录中的命令名对应于程序C，但CPU时间是程序A、B和C之和。</p>
<p>为了得到某些会计数据以便查看，我们编写了测试程序。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;		<span class="comment">/* parent */</span></span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">2</span>);				<span class="comment">/* terminate with exit status 2 */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;		<span class="comment">/* first child */</span></span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">4</span>);</span><br><span class="line">		<span class="built_in">abort</span>();				<span class="comment">/* terminate with core dump */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;		<span class="comment">/* second child */</span></span><br><span class="line">		<span class="built_in">execl</span>(<span class="string">&quot;/bin/dd&quot;</span>, <span class="string">&quot;dd&quot;</span>, <span class="string">&quot;if=/etc/passwd&quot;</span>, <span class="string">&quot;of=/dev/null&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">7</span>);				<span class="comment">/* shouldn&#x27;t get here */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;		<span class="comment">/* third child */</span></span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">8</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);				<span class="comment">/* normal exit */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">6</span>);					<span class="comment">/* fourth child */</span></span><br><span class="line">	<span class="built_in">kill</span>(<span class="built_in">getpid</span>(), SIGKILL);	<span class="comment">/* terminate w/signal, no core dump */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">6</span>);					<span class="comment">/* shouldn&#x27;t get here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>运行该测试程序，然后从会计记录中选择一些字段并打印出来。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/acct.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(BSD)	<span class="comment">/* different structure in FreeBSD */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> acct acctv2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ac_flag ac_trailer.ac_flag</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FMT <span class="string">&quot;%-*.*s  e = %.0f, chars = %.0f, %c %c %c %c\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(HAS_AC_STAT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FMT <span class="string">&quot;%-*.*s  e = %6ld, chars = %7ld, stat = %3u: %c %c %c %c\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FMT <span class="string">&quot;%-*.*s  e = %6ld, chars = %7ld, %c %c %c %c\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(LINUX)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> acct acct_v3	<span class="comment">/* different structure in Linux */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(HAS_ACORE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACORE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(HAS_AXSIG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AXSIG 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(BSD)</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span></span></span><br><span class="line"><span class="function"><span class="title">compt2ulong</span><span class="params">(<span class="type">comp_t</span> comptime)</span>	<span class="comment">/* convert comp_t to unsigned long */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	val;</span><br><span class="line">	<span class="type">int</span>				exp;</span><br><span class="line"></span><br><span class="line">	val = comptime &amp; <span class="number">0x1fff</span>;	<span class="comment">/* 13-bit fraction */</span></span><br><span class="line">	exp = (comptime &gt;&gt; <span class="number">13</span>) &amp; <span class="number">7</span>;	<span class="comment">/* 3-bit exponent (0-7) */</span></span><br><span class="line">	<span class="keyword">while</span> (exp-- &gt; <span class="number">0</span>)</span><br><span class="line">		val *= <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">return</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">acct</span>		acdata;</span><br><span class="line">	FILE			*fp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">		<span class="built_in">err_quit</span>(<span class="string">&quot;usage: pracct filename&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((fp = <span class="built_in">fopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;can&#x27;t open %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">fread</span>(&amp;acdata, <span class="built_in">sizeof</span>(acdata), <span class="number">1</span>, fp) == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(FMT, (<span class="type">int</span>)<span class="built_in">sizeof</span>(acdata.ac_comm),</span><br><span class="line">			(<span class="type">int</span>)<span class="built_in">sizeof</span>(acdata.ac_comm), acdata.ac_comm,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(BSD)</span></span><br><span class="line">			acdata.ac_etime, acdata.ac_io,</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="built_in">compt2ulong</span>(acdata.ac_etime), <span class="built_in">compt2ulong</span>(acdata.ac_io),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(HAS_AC_STAT)</span></span><br><span class="line">			(<span class="type">unsigned</span> <span class="type">char</span>) acdata.ac_stat,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			acdata.ac_flag &amp; ACORE ? <span class="string">&#x27;D&#x27;</span> : <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">			acdata.ac_flag &amp; AXSIG ? <span class="string">&#x27;X&#x27;</span> : <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">			acdata.ac_flag &amp; AFORK ? <span class="string">&#x27;F&#x27;</span> : <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">			acdata.ac_flag &amp; ASU   ? <span class="string">&#x27;S&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ferror</span>(fp))</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BSD派生的平台不支持<code>ac_stat</code>成员，所以我们在支持该成员的平台上定义了<code>HAS_AC_STAT</code>常量。为了进行测试，执行下列操作步骤，</p>
<ol>
<li>成为超级用户，用<code>accton</code>命令启用会计处理。注意，当此命令结束时，会计处理已经启用，因此在会计文件中的第一个记录应来自这一命令。</li>
<li>终止超级用户shell，运行程序。这会追加6个记录到会计文件中(超级用户shell一个、父进程一个、4个子进程各一个)。在第二个子进程中，<code>execl</code>并不创建一个新进程，所以对第二个进程只有一个会计记录。</li>
<li>成为超级用户，停止会计处理。因为在<code>accton</code>命令终止时已经停止会计处理，所以不会在会计文件中增加一个记录。</li>
<li>运行程序，从会计文件中选出字段并打印。</li>
</ol>
<h2 id="用户标识-1"><a href="#用户标识-1" class="headerlink" title="用户标识"></a>用户标识</h2><p>任一进程都可以得到其实际用户ID和有效用户ID及组ID。但是，我们有时希望找到运行该程序用户的登录名。我们可以调用<code>getpwuid(getuid())</code>，但是如果一个用户有多个登录名，这些登录名又对应着同一个用户ID，又将如何呢? 系统通常记录用户登录时使用的名字，用<code>getlogin</code>函数可以获取此登录名<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getlogin</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回指向登录名字符串的指针，若出错，返回NULL</span></span><br></pre></td></tr></table></figure></p>
<p>如果调用此函数的进程没有连接到用户登录时所用的终端，则函数会失败。通常称这些进程为守护进程(daemon)。给出了登录名，就可用<code>getpwnam</code>在口令文件中查找用户的相应记录，从而确定其登录shell等。</p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>UNIX系统历史上对进程提供的只是基于调度优先级的粗粒度的控制。调度策略和调度优先级是由内核确定的。进程可以通过调整<code>nice</code>值选择以更低优先缓运行(通过调整<code>nice</code>值降低它对CPU的占有，因此该进程是“友好的”)。只有特权进程允许提高调度权限。POSIX实时扩展增加了在多个调度类别中选择的核口以进一步细调行为。</p>
<p>Single UNIX Specification 中<code>nice</code>值的范围在<code>0~(2*NZERO)-1</code>之间，有些实现支持<code>0~2*NZERO</code>。<code>nice</code>值越小，优先级越高。虽然这看起来有点倒退，但实际上是有道理的：你越友好，你的调度优先级就越低。<code>NZERO</code>是系统默认的<code>nice</code>值。</p>
<p>注意，定义<code>NZERO</code>的头文件因系统而异。除了头文件以外，Linux3.2.0可以通过非标准的<code>sysconf</code>参数(<code>_SC_NZERO</code>)来访问<code>NZERO</code>的值。</p>
<p>进程可以通过<code>nice</code>函数获取或更改它的<code>nice</code>值。使用这个函数，进程只能影响自己的<code>nice</code>值，不能影响任何其他进程的<code>nice</code>值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">nice</span><span class="params">(<span class="type">int</span> incr)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回新的nice值NZERO；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>incr</code>参数被增加到调用进程的<code>nice</code>值上。如果<code>incr</code>太大，系统直接把它降到最大合法值，不给出提示。类似地，如果<code>incr</code>太小，系统也会无声息地把它提高到最小合法值。由于-1是合法的成功返回值，在调用<code>nice</code>函数之前需要清楚<code>errno</code>，在<code>nice</code>函数返回-1时，需要检查它的值。如果<code>nice</code>调用成功，并且返回值为-1，那么<code>errno</code>仍然为0。如果<code>errno</code>不为0，说明<code>nice</code>调用失败。</p>
<p><code>getpriority</code>函数可以像<code>nice</code>函数那样用于获取进程的<code>nice</code>值，但是<code>getpriority</code>还可以获取一组相关进程的<code>nice</code>值<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">id_t</span> who)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功。返回-NZERO~NZERO-1之间的nice值；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>which</code>参数可以取以下三个值之一：<code>PRIO_PROCESS</code>表示进程，<code>PRIO_PGRP</code>表示进程组，<code>PRIO_USER</code>表示用户ID，<code>which</code>参数控制<code>who</code>参数是如何解释的，<code>who</code>参数选择感兴趣的一个或多个进程。如果<code>who</code>参数为0，表示调用进程、进程组或者用户(取决于<code>which</code>参数的值)。当<code>which</code>设为<code>PRIO_USER</code>并且<code>who</code>为0时，使用调用进程的实际用户ID。如果<code>which</code>参数作用于多个进程，则返回所有作用进程中优先级最高的(最小的<code>nice</code>值)。</p>
<p><code>setpriority</code>函数可用于为进程、进程组和属于特定用户ID的所有进程设置优先级。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">id_t</span> who, <span class="type">int</span> value)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>参数<code>which</code>和<code>who</code>与<code>getpriority</code>函数中相同。<code>value</code>增加到<code>NZERO</code>上，然后变为新的<code>nice</code>值。</p>
<p>程序度最了调整进程<code>nice</code>值的效果。两个进程并行运行，各自增加自己的计数器。父进程使用了默认的<code>nice</code>值，子进程以可选命令参数指定的调整后的<code>nice</code>值运行。运行10s后，两个进程都打印各自的计数值并终止。通过比较不同<code>nice</code>值的进程的计数值的差异，我们可以了解<code>nice</code>值时如何影响进程调度的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(MACOS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syslimits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(SOLARIS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(BSD)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/param.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> count;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> end;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">checktime</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">timeval</span>	tv;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (tv.tv_sec &gt;= end.tv_sec &amp;&amp; tv.tv_usec &gt;= end.tv_usec) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s count = %lld\n&quot;</span>, str, count);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line">	<span class="type">char</span>	*s;</span><br><span class="line">	<span class="type">int</span>		nzero, ret;</span><br><span class="line">	<span class="type">int</span>		adj = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">setbuf</span>(stdout, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(NZERO)</span></span><br><span class="line">	nzero = NZERO;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_SC_NZERO)</span></span><br><span class="line">	nzero = <span class="built_in">sysconf</span>(_SC_NZERO);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> NZERO undefined</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;NZERO = %d\n&quot;</span>, nzero);</span><br><span class="line">	<span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">		adj = <span class="built_in">strtol</span>(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">gettimeofday</span>(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line">	end.tv_sec += <span class="number">10</span>;	<span class="comment">/* run for 10 seconds */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;	<span class="comment">/* child */</span></span><br><span class="line">		s = <span class="string">&quot;child&quot;</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;current nice value in child is %d, adjusting by %d\n&quot;</span>,</span><br><span class="line">		  <span class="built_in">nice</span>(<span class="number">0</span>)+nzero, adj);</span><br><span class="line">		errno = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> ((ret = <span class="built_in">nice</span>(adj)) == <span class="number">-1</span> &amp;&amp; errno != <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">err_sys</span>(<span class="string">&quot;child set scheduling priority&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;now child nice value is %d\n&quot;</span>, ret+nzero);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;		<span class="comment">/* parent */</span></span><br><span class="line">		s = <span class="string">&quot;parent&quot;</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;current nice value in parent is %d\n&quot;</span>, <span class="built_in">nice</span>(<span class="number">0</span>)+nzero);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (++count == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">err_quit</span>(<span class="string">&quot;%s counter wrap&quot;</span>, s);</span><br><span class="line">		<span class="built_in">checktime</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行该程序两次：一次用默认的<code>nice</code>值，另一次用最高有效<code>nice</code>值(最低调度优先级)。程序运行在单处理器Linux系统上，以显示调度程序如何在不同nice值的进程间进行CPU的共享。否则，对于有空闲资源的系统，如多处理器系统(或多核CPU)，两个进程可能无需共享CPU(运行在不同的处理器上)，就无法看出具有不同nice值的两个进程的差异。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">NZERO 20</span><br><span class="line">current <span class="built_in">nice</span> value <span class="keyword">in</span> parent 10 20</span><br><span class="line">current <span class="built_in">nice</span> value <span class="keyword">in</span> child is 20, adjusting by 0</span><br><span class="line">now child <span class="built_in">nice</span> value is 20</span><br><span class="line">child count = 1859362</span><br><span class="line">parent count = 1845338</span><br><span class="line">$ ./a.out 20</span><br><span class="line">NZERO = 20</span><br><span class="line">current <span class="built_in">nice</span> value <span class="keyword">in</span> parent is 20</span><br><span class="line">current <span class="built_in">nice</span> vaiue <span class="keyword">in</span> child is 20, adjuating by 20</span><br><span class="line">now child <span class="built_in">nice</span> value is 39</span><br><span class="line">parent count = 3595709</span><br><span class="line">child count = 52111</span><br></pre></td></tr></table></figure></p>
<p>当两个进程的<code>nice</code>值相同时，父进程占用50.2%的CPU，子进程占用49.8%的CPU。可以看到，两个进程被有效地进行了平等对待。相比之下，当子进程有最高可能nice值(最低优先级)时，我们看到父进程占用98.5%的CPU，而子进程只占用1.5%的CPU。这些值取决于进程调度程序如何使用nice值。因此不同的UNIX系统会产生不同的CPU占用比。</p>
<h2 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h2><p>我们可以度量3个时间：墙上时钟时间、用户CPU时间和系统CPU时间。任一进程都可调用<code>times</code>函数获得它自己以及已终止子进程的上述值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">clock_t</span> <span class="title">times</span> <span class="params">(<span class="keyword">struct</span> tms *buf)</span>)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回流逝的墙上时钟时间，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>此函数填写由<code>buf</code>指向的<code>tms</code>结构，该结构定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tms</span> &#123;</span><br><span class="line">	<span class="type">clock_t</span> tms_utime; 	<span class="comment">/* user cpu time */</span></span><br><span class="line">	<span class="type">clock_t</span> tms_stime;  <span class="comment">/* system CPU time */</span></span><br><span class="line">	<span class="type">clock_t</span> tms_cutime; <span class="comment">/* user cru time, terninated children */</span></span><br><span class="line">	<span class="type">clock_t</span> tms_cstime; <span class="comment">/* aystem CPU time, terminated children */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，此结构没有包含墙上时钟时间。<code>times</code>函数返回墙上时钟时间作为其函数值。此值是相对于过去的某一时刻度量的，所以不能用其绝对值而必须使用其相对值。所有由此函数返回的<code>clock_t</code>值都用<code>_SC_CLK_TCK</code>(由sysconf函数返回的每秒时钟滴答数)转换成秒数。</p>
<p>程序将每个命令行参数作为shell命令串执行，对每个命令计时，并打印从<code>tms</code>结构取得的值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>	<span class="title">pr_times</span><span class="params">(<span class="type">clock_t</span>, <span class="keyword">struct</span> tms *, <span class="keyword">struct</span> tms *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>	<span class="title">do_cmd</span><span class="params">(<span class="type">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>		i;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">setbuf</span>(stdout, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">		<span class="built_in">do_cmd</span>(argv[i]);	<span class="comment">/* once for each command-line arg */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">do_cmd</span><span class="params">(<span class="type">char</span> *cmd)</span>		<span class="comment">/* execute and time the &quot;cmd&quot; */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tms</span>	tmsstart, tmsend;</span><br><span class="line">	<span class="type">clock_t</span>		start, end;</span><br><span class="line">	<span class="type">int</span>			status;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\ncommand: %s\n&quot;</span>, cmd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((start = <span class="built_in">times</span>(&amp;tmsstart)) == <span class="number">-1</span>)	<span class="comment">/* starting values */</span></span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;times error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((status = <span class="built_in">system</span>(cmd)) &lt; <span class="number">0</span>)			<span class="comment">/* execute command */</span></span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;system() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((end = <span class="built_in">times</span>(&amp;tmsend)) == <span class="number">-1</span>)		<span class="comment">/* ending values */</span></span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;times error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pr_times</span>(end-start, &amp;tmsstart, &amp;tmsend);</span><br><span class="line">	<span class="built_in">pr_exit</span>(status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">pr_times</span><span class="params">(<span class="type">clock_t</span> real, <span class="keyword">struct</span> tms *tmsstart, <span class="keyword">struct</span> tms *tmsend)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">long</span>		clktck = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (clktck == <span class="number">0</span>)	<span class="comment">/* fetch clock ticks per second first time */</span></span><br><span class="line">		<span class="keyword">if</span> ((clktck = <span class="built_in">sysconf</span>(_SC_CLK_TCK)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">err_sys</span>(<span class="string">&quot;sysconf error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  real:  %7.2f\n&quot;</span>, real / (<span class="type">double</span>) clktck);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  user:  %7.2f\n&quot;</span>,</span><br><span class="line">	  (tmsend-&gt;tms_utime - tmsstart-&gt;tms_utime) / (<span class="type">double</span>) clktck);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  sys:   %7.2f\n&quot;</span>,</span><br><span class="line">	  (tmsend-&gt;tms_stime - tmsstart-&gt;tms_stime) / (<span class="type">double</span>) clktck);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  child user:  %7.2f\n&quot;</span>,</span><br><span class="line">	  (tmsend-&gt;tms_cutime - tmsstart-&gt;tms_cutime) / (<span class="type">double</span>) clktck);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  child sys:   %7.2f\n&quot;</span>,</span><br><span class="line">	  (tmsend-&gt;tms_cstime - tmsstart-&gt;tms_cstime) / (<span class="type">double</span>) clktck);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="进程关系"><a href="#进程关系" class="headerlink" title="进程关系"></a>进程关系</h1><h2 id="终端登录"><a href="#终端登录" class="headerlink" title="终端登录"></a>终端登录</h2><p>当系统自举时，内核创建进程ID为1的进程，也就是<code>init</code>进程。<code>init</code>进程使系统进入多用户模式。<code>init</code>读取文件<code>/etc/ttys</code>，对每一个允许登录的终端设备，<code>init</code>调用一次<code>fork</code>，它所生成的子进程则<code>exec getty</code>程序。</p>
<p><code>getty</code>对终端设备调用<code>open</code>函数，以读、写方式将终端打开。<code>getty</code>输出“login:”之类的信息，并等待用户键入用户名。如果终端支持多种速度，则<code>getty</code>可以测试特殊字符以便适当地更改终端速度。当用户键入了用户名后，<code>getty</code>的工作就完成了。然后它以类似于下列的方式调用<code>login</code>程序：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execle(<span class="string">&quot;/bin/login&quot;</span>, <span class="string">&quot;login&quot;</span>, <span class="string">&quot;-p&quot;</span>, username, (char *)0, envp);</span><br></pre></td></tr></table></figure></p>
<p><code>init</code>以一个空环境调用<code>getty</code>，<code>getty</code>以终端名和在<code>gettytab</code>中说明的环境字符串为<code>login</code>创建一个环境(<code>envp</code>参数)。<code>-p</code>标志通知<code>login</code>保留传递给它的环境，也可将其他环境字符串加到该环境中，但是不要替换它。图9-2显示了<code>login</code>刚被调用后这些进程的状态。<br><img src="/img/1621926192.jpg" alt=""></p>
<p>因为最初的init进程具有超级用户特权，所以图9-2中的所有进程都有超级用户特权。图9.2中底部3个进程的进程ID相同，因为进程ID不会因执行exec而改变。并且，除了最初的<code>init</code>进程，所有进程的父进程ID均为1，<code>login</code>能处理多项工作。因为它得到了用户名，所以能调用<code>getpwnam</code>取得相应用户的口令文件登录项。然后调用<code>getpass(3)</code>以显示提示“Password:”，接着读用户键入的口令。它调用<code>crypt(3)</code>将用户键入的口令加密，并与该用户在阴影口令文件中登录项的<code>pw_passwd</code>字段相比较。</p>
<p>如果用户正确登录，login就将完成如下工作。</p>
<ul>
<li>将当前工作目录更改为该用户的起始目录(chdir)。</li>
<li>调用<code>chown</code>更改该终端的所有权，使登录用户成为它的所有者。</li>
<li>将对该终端设备的访问权限改变成“用户读和写”。</li>
<li>调用<code>setgid</code>及<code>initgroups</code>设置进程的组ID。</li>
<li>用login得到的所有信息初始化环境：起始目录(HOME)、shell(SHELL)、用户名(USER和LOGNAME)以及一个系统默认路径(PATH)。</li>
</ul>
<p><code>login</code>进程更改为登录用户的用户ID(setuid)并调用该用户的登录shell，其方式类似于：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-sh&quot;</span>, (char *)0);</span><br></pre></td></tr></table></figure></p>
<p><code>argv[0]</code>的第一个字符负号是一个标志，表示该shell被作为登录shell调用。shell可以查看此字符，并相应地修改其启动过程。</p>
<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><p>每个进程除了有一进程ID之外，还属于一个进程组。进程组是一个或多个进程的集合。通常，它们是在同一作业中结合起来的，同一进程组中的各进程接收来自同一终端的各种信号。每个进程组有一个唯一的进程组ID。进程组ID类似于进程ID一它是一个正整数，并可存放在<code>pid_t</code>数据类型中。函数<code>getpgrp</code>返回调用进程的进程组ID。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：调用进程的进程组ID</span></span><br></pre></td></tr></table></figure></p>
<p>每个进程组有一个组长进程。组长进程的进程组ID等于其进程ID。进程组组长可以创建一个进程组、创建该组中的进程，然后终止。只要在某个进程组中有一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。从进程组创建开始到其中最后一个进程离开为止的时间区间称为进程组的生命期。某个进程组中的最后一个进程可以终止，也可以转移到另一个进程组。</p>
<p>进程调用<code>setpgid</code>可以加入一个现有的进程组成者创建一个新进程组。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错：返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>setpgid</code>函数将<code>pid</code>进程的进程组ID设置为<code>pgid</code>。如果这两个参数相等，则由<code>pid</code>指定的进程变成进程组组长。如果<code>pid</code>是0，则使用调用者的进程ID。另外，如果<code>pgid</code>是0，则由<code>pid</code>指定的进程ID用作进程组ID。</p>
<p>一个进程只能为它自己或它的子进程设置进程组ID。在它的子进程调用了<code>exec</code>后，它就不再更改该子进程的进程组ID。</p>
<p>在大多数作业控制shell中，在fork之后调用此函数，使父进程设置其子进程的进程组ID，并且也使子进程设置其自己的进程组ID。这两个调用中有一个是冗余的，但让父进程和子进程都这样做可以保证，在父进程和子进程认为子进程已进入了该进程组之前，这确实已经发生了。如果不这样做，在<code>fork</code>之后，由于父进程和子进程运行的先后次序不确定，会因为子进程的组员身份取决于哪个进程首先执行而产生竞争条件。</p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话(session)是一个或多个进程组的集合。<br><img src="/img/1621927476.jpg" alt=""></p>
<p>通常是由shell的管道将几个进程编成一组的。例如，图9-6中的安排可能是由下列形式的shell命令形成的：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proc1 | proc2 &amp;</span><br><span class="line">proc3 | proc4 | proc5</span><br></pre></td></tr></table></figure></p>
<p>进程调用<code>setsid</code>函数建立一个新会话。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">setsid</span> <span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回进程组ID：若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话。具体会发生以下3件事。</p>
<ol>
<li>该进程变成新会话的会话首进程(session leader，会话首进程是创建该会话的进程)。此时，该进程是新会话中的唯一进程。</li>
<li>该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID。</li>
<li>该进程没有控制终端。如果在调用<code>setsid</code>之前该进程有一个控制终端，那么这种联系也被切断。</li>
</ol>
<p>如果该调用进程已经是一个进程组的组长，则此函数返回出错。为了保证不处于这种情况，通常先调用<code>fork</code>，然后使其父进程终止，而子进程则继续。因为子进程继承了父进程的进程组ID，而其进程ID则是新分配的，两者不可能相等，这就保证了子进程不是一个进程组的组长。Single UNIX Specification只说明了会话首进程，而没有类似于进程ID和进程组ID的会话ID。显然，会话首进程是具有唯一进程ID的单个进程，所以可以将会话首进程的进程ID视为会话ID。会话ID这一概念是由SVR4引入的。<code>getsid</code>函数返回会话首进程的进程组ID。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getsid</span> <span class="params">(<span class="type">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回会话首进程的进程组ID；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>如若<code>pid</code>是0，<code>getsid</code>返回调用进程的会话首进程的进程组ID。出于安全方面的考虑，一些实现有如下限制：如若<code>pid</code>并不属于调用者所在的会话，那么调用进程就不能得到该会话首进程的进程组ID。</p>
<p>P245</p>
<h2 id="控制终端"><a href="#控制终端" class="headerlink" title="控制终端"></a>控制终端</h2><p>会话和进程组还有一些其他特性。</p>
<ul>
<li>一个会话可以有一个控制终端(controlling terminal)。这通常是终端设备(在终端登录情况下)或伪终端设备(在网络登录情况下)。</li>
<li>建立与控制终端连接的会话首进程被称为控制进程(controlling process)。</li>
<li>一个会话中的几个进程组可被分成一个前台进程组(foreground process group)以及一个或多个后台进程组(background process group)。</li>
<li>如果一个会话有一个控制终端，则它有一个前台进程组，其他进程组为后台进程组。</li>
<li>无论何时健入终端的中断键(常常是Delete或Ctrl+C)，都会将中断信号发送至前台进程组的所有进程。</li>
<li>无论何时键入终端的退出键(常常是Crtl+<code>\</code>)，都会将退出信号发送至前台进程组的所有进程。</li>
<li>如果终端接口检测到调制解调器(或网络)已经断开连接，则将挂断信号发送至控制进程(会话首进程)。</li>
</ul>
<p><img src="/img/20210525234012.png" alt=""></p>
<p>通常，我们不必担心控制终端，登录时，将自动建立控制终端。</p>
<p>有时不管标准输入、标准输出是否重定向，程序都要与控制终端交互作用。保证程序能与控制终端对话的方法是open文件<code>/dev/tty</code>。在内核中，此特殊文件是控制终端的同义语。自然地，如果程序没有控制终端，则对于此设备的open将失败。</p>
<h2 id="函数tcgetpgrp、tcsetpgrp和tcgetsid"><a href="#函数tcgetpgrp、tcsetpgrp和tcgetsid" class="headerlink" title="函数tcgetpgrp、tcsetpgrp和tcgetsid"></a>函数tcgetpgrp、tcsetpgrp和tcgetsid</h2><p>需要有一种方法来通知内核哪一个进程组是前台进程组，这样，终端设备驱动程序就能知道将终端输入和终端产生的信号发送到何处。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">tcgetpgrp</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回前台进程组ID；若出错，返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tcsetpqrp</span><span class="params">(<span class="type">int</span> fd, <span class="type">pid_t</span> psrpid)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>函数<code>tcgetpgrp</code>返回前台进程组ID，它与在fd上打开的终端相关联。如果进程有一个控制终端，则该进程可以调用<code>tcsetpgrp</code>将前台进程组ID设置为<code>pgrpid</code>。<code>pgrpid</code>值应当是在同一会话中的一个进程组的ID。fd必须引用该会话的控制终端。大多数应用程序并不直接调用这两个函数。它们通常由作业控制shell调用。</p>
<p>给出控制TTY的文件描述符，通过<code>tcgetsid</code>函数，应用程序就能获得会话首进程的进程组ID。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">tcgetsid</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回会话首进程的进程组ID，若出错：返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>需要管理控制终端的应用程序可以调用<code>tcgetsid</code>函数识别出控制终端的会话首进程的会话ID(它等价于会话首进程的进程组ID)。</p>
<h1 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h1><p>作业控制允许在一个终端上启动多个作业(进程组)，它控制哪一个作业可以访问该终端以及哪些作业在后台运行。作业控制要求以下3种形式的支持。</p>
<ol>
<li>支持作业控制的shell。</li>
<li>内核中的终端驱动程序必须支持作业控制。</li>
<li>内核必须提供对某些作业控制信号的支持。</li>
</ol>
<p>从shell使用作业控制功能的角度观察，用户可以在前台或后台启动一个作业。一个作业只是几个进程的集合，通常是一个进程管道。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi main.c</span><br></pre></td></tr></table></figure></p>
<p>在前台启动了只有一个进程组成的作业。下面的命令;<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pr</span> *.c | lpr &amp;</span><br><span class="line">make all &amp;</span><br></pre></td></tr></table></figure></p>
<p>在后台启动了两个作业。这两个后台作业调用的所有进程都在后台运行。</p>
<p>当启动一个后台作业时，shell赋予它一个作业标识符，并打印一个或多个进程ID。下面的脚本显示了Kornshell是如何处理这一点的。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ make all &gt; Make.out a</span><br><span class="line">[1] 1475</span><br><span class="line">$ <span class="built_in">pr</span> *.c | lpr &amp;</span><br><span class="line">[2] 1490</span><br><span class="line">$ 键入回车</span><br><span class="line">[2] + Done   <span class="built_in">pr</span> *.c | lpr &amp;</span><br><span class="line">[1] + Done   make all &gt; Make.out &amp;</span><br></pre></td></tr></table></figure></p>
<p><code>make</code>是作业编号1，所启动的进程ID是1475。下一个管道是作业编号2。其第一个进程的进程ID是1490，当作业完成而且键入回车时，shell通知作业已经完成。键入回车是为了让shell打印其提示符，shell并不在任意时刻打印后台作业的状态改变——它只在打印其提示符让用户输入新的命令行之前才这样做。如果不这样处理，则当我们正输入一行时，它也可能输出，于是，就会引起混乱。</p>
<p>我们可以键入一个影响前台作业的特殊字符一挂起键(通常采用Ctrl+Z)，与终端驱动程序进行交互作用。键入此字符使终端驱动程序将信号SIGTSTP发送至前台进程组中的所有进程，后台进程组作业则不受影响。实际上有3个特殊字符可使终端驱动程序产生信号，并将它们发送至前台进程组，它们是：</p>
<ul>
<li>中断字符(一般采用Delete或Ctrl+C)产生<code>SIGINT</code>。</li>
<li>退出字符(一般采用Ctrl+<code>\</code>)产生<code>SIGQUIT</code>。</li>
<li>挂起字符(一般采用Ctrl+Z)产生<code>SIGTSTP</code>。</li>
</ul>
<p>终端驱动程序必须处理与作业控制有关的另一种情况。我们可以有一个前台作业，若干个后台作业，这些作业中哪一个接收我们在终端上键入的字符呢?只有前台作业接收终端输入。如果后台作业试图读终端，这并不是一个错误，但是终端驱动程序将检测这种情况，并且向后台作业发送信号SIGTTIN。该信号通常会停止此后台作业，而shell则向有关用户发出这种情况的通知，然后用户就可用shell命令将此作业转为前台作业运行，于是它就可读终端。</p>
<h2 id="shell执行程序"><a href="#shell执行程序" class="headerlink" title="shell执行程序"></a>shell执行程序</h2><p>让我们检验一下shell是如何执行程序的，以及这与进程组、控制终端和会话等概念的关系。为此，再次使用<code>ps</code>命令。</p>
<p>首先使用不支持作业控制的、在Solaris上运行的经典Bourne shell。如果执行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,ppid,prid,sid,<span class="built_in">comm</span></span><br></pre></td></tr></table></figure></p>
<p>则其输出可能是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PID PPID PGID BID COMMAND</span><br><span class="line">949  947  949 949 sh</span><br><span class="line">1774 949  949 949 ps</span><br></pre></td></tr></table></figure></p>
<p><code>ps</code>的父进程是shell，这正是我们所期望的，shell和<code>ps</code>命令两者位于同一会话和前台进程组(949)中。因为我们是用一个不支持作业控制的shell执行命令时得到该值的，所以称其为前台进程组。</p>
<p>如果在后台执行命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,ppid,paid, oid, <span class="built_in">comm</span> &amp;</span><br></pre></td></tr></table></figure></p>
<p>则唯一改变的值是命令的进程ID;<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PID PPID PGID SID COMMAND</span><br><span class="line">949  947  949 949 sh</span><br><span class="line">1812 949  949 949 ps</span><br></pre></td></tr></table></figure></p>
<p>因为这种shell不知道作业控制，所以没有将后台作业放入自己的进程组，也没有从后台作业处取走控制终端。</p>
<p>现在看一看Bourne shell如何处理管道。执行下列命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,ppid,pyid,sid,<span class="built_in">comm</span> | catl</span><br></pre></td></tr></table></figure></p>
<p>其输出是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PID PPID PGID SID COMMAND</span><br><span class="line">949  947  949 949 sh</span><br><span class="line">1823 949  949 949 catl</span><br><span class="line">1824 1823 949 949 ps</span><br></pre></td></tr></table></figure></p>
<p>注意，管道中的最后一个进程是shell的子进程，该管道中的第一个进程则是最后一个进程的子进程。从中可以看出，shell fork一个它自身的副本，然后此副本再为管道中的每条命令各fork一个进程。</p>
<p>如果在后台执行此管道<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid, ppid, paid, sid, <span class="built_in">comm</span> | catl &amp;</span><br></pre></td></tr></table></figure></p>
<p>则只改变进程ID。因为shell并不处理作业控制，后台进程的进程组ID仍是949，如何会话的进程组ID一样。</p>
<p>如果一个后台进程试图读其控制终端，则会发生什么呢?例如，若执行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; temp.foo &amp;</span><br></pre></td></tr></table></figure></p>
<p>在有作业控制时，后台作业被放在后台进程组，如果后台作业试图读控制终端，则会产生信号SIGTTIN。在没有作业控制时，其处理方法是： 如果该进程自己没有重定向标准输入，则shell自动将后台进程的标准输入重定向到/dev/null。读/dev/null则产生一个文件结束。这就意味着后台cat进程立即读到文件尾，并正常终止。</p>
<p>前面说明了对后台进程通过其标准输入访问控制终端的适当的处理方法，但是，如果一个后台进程打开/dev/tty并且读该控制终端，又将怎样呢?对此问题的回答是“看情况”。但是这很可能不是我们所期望的。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crypt &lt; salazies | lpr &amp;</span><br></pre></td></tr></table></figure></p>
<p>就是这样的一条管道。我们在后台运行它，但是crypt程序打开/dev/tty，更改终端的特性(禁止回显)，然后从该设备读，最后重置该终端特性。当执行这条后台管道时，crypt在终端上打印提示符“Password:”，但是shell读取了我们所输入的加密口令，并试图执行以加密口令为名称的命令。我们输送给shell的下一行则被crypt进程取为口令行，于是saiaries也就不能正确地被译码，结果将一堆无用的信息送到了打印机。在这里，我们有了两个进程，它们试图同时读同一设备，其结果则依赖于系统。前面说明的作业控制以较好的方式处理一个终端在多个进程间的转接。</p>
<p>返回到Bourneshell实例，在一条管道中执行3个进程，我们可以检验Bourne shell使用的进程控制方式<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,ppid,paid, sid, <span class="built_in">comm</span> | catl | cat2</span><br></pre></td></tr></table></figure></p>
<p>其输出为：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PID PPID PGID SID COMMAND</span><br><span class="line">949  947  949 949 sh</span><br><span class="line">1988 949  949 949 cat2</span><br><span class="line">1989 1988 949 949 ps</span><br><span class="line">1990 1988 949 949 cat1</span><br></pre></td></tr></table></figure></p>
<h1 id="信号-1"><a href="#信号-1" class="headerlink" title="信号"></a>信号</h1><h2 id="引言-2"><a href="#引言-2" class="headerlink" title="引言"></a>引言</h2><p>信号是软件中断。很多比较重要的应用程序都需处理信号，信号提供了一种处理异步事件的方法，例如，终端用户键入中断键，会通过信号机制停止一个程序，或及早终止管道中的下一个程序。</p>
<h2 id="信号概念"><a href="#信号概念" class="headerlink" title="信号概念"></a>信号概念</h2><p>首先，每个信号都有一个名字。这些名字都以3个字符SIG开头。例如，<code>SIGABRT</code>是夭折信号，当进程调用<code>abort</code>函数时产生这种信号。<code>SIGALRM</code>是闹钟信号，由<code>alarm</code>函数设置的定时器超时后将产生此信号。</p>
<p>在头文件<code>&lt;signal.h&gt;</code>中，信号名都被定义为正整数常量(信号编号)。实际上，实现将各信号定义在另一个头文件中，但是该头文件又包括在<code>&lt;signal.h&gt;</code>中。内核包括对用户级应用程序有意义的头文件，这被认为是一种不好的形式，所以如若应用程序和内核两者都需使用同一定义，那么就将有关信息放置在内核头文件中，然后用户级头文件再包括该内核头文件。</p>
<p>不存在编号为0的信号，<code>kill</code>函数对信号编号0有特殊的应用。POSIX.1将此种信号编号值称为空信号。很多条件可以产生信号。</p>
<ul>
<li>当用户按某些终端键时，引发终端产生的信号。在终端上按Delete键通常产生中断信号(SIGINT)。这是停止一个已失去控制程序的方法。</li>
<li>硬件异常产生信号：除数为0、无效的内存引用等。这些条件通常由硬件检测到，并通知内核。然后内核为该条件发生时正在运行的进程产生适当的信号。</li>
<li>进程调用<code>kill(2)</code>函数可将任意信号发送给另一个进程或进程组。自然，对此有所限制：接收信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级用户。</li>
<li>用户可用<code>kill(1)</code>命令将信号发送给其他进程。此命令只是<code>kill</code>函数的接口。常用此命令终止一个失控的后台进程。</li>
<li>当检测到某种软件条件已经发生，并应将其通知有关进程时也产生信号。这里指的不是硬件产生条件(如除以0)，而是软件条件。例如<code>SIGURG</code>(在网络连接上传来带外的数据)、<code>SIGPIPE</code>(在管道的读进程已终止后，一个进程写此管道)以及<code>SIGALRM</code>(进程所设置的定时器已经超时)。</li>
</ul>
<p>信号是异步事件的经典实例。产生信号的事件对进程而言：是随机出现的。进程不能简单地测试一个变量(如errno)来判断是否发生了一个信号，而是必须告诉内核”在此信号发生时，请执行下列操作”。</p>
<p>在某个信号出现时，可以告诉内核按下列3种方式之一进行处理，我们称之为信号的处理或与信号相关的动作。</p>
<ol>
<li>忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是<code>SIGKILL</code>和<code>SIGSTOP</code>。这两种信号不能被忽略的原因是它们向内核和超级用户提供了使进程终止或停止的可靠方法。另外，如果忽略某些由硬件异常产生的信号(如非法内存引用或除以0)，则进程的运行行为是未定义的。</li>
<li>捕捉信号。为了做到这一点，要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。</li>
<li>执行系统默认动作。注意，对大多数信号的系统默认动作是终止该进程</li>
</ol>
<p>图10-1列出了所有信号的名字，说明了哪些系统支持此信号以及对于这些信号的系统默认动作。在系统默认动作列，”终止+core”表示在进程当前工作目录的core文件中复制了该进程的内存映像(该文件名为core)。大多数UNIX系统调试程序都使用core文件检查进程终止时的状态。<br><img src="/img/1621993686.jpg" alt=""></p>
<p>在下列条件下不产生core文件：</p>
<ul>
<li>进程是设置用户ID的，而且当前用户并非程序文件的所有者；</li>
<li>进程是设置组ID的，而且当前用户并非该程序文件的组所有者；</li>
<li>用户没有写当前工作目录的权限；</li>
<li>文件已存在，而且用户对该文件设有写权限；</li>
<li>文件太大。</li>
</ul>
<p>core文件的权限(假定该文件在此之前并不存在)通常是用户读/写。</p>
<p>下面逐一说明这些信号。</p>
<ul>
<li><code>SIGABRT</code>：调用<code>abort</code>函数时产生此信号。进程异常终止。</li>
<li><code>SIGALRM</code>：当用<code>alarm</code>函数设置的定时器超时时，产生此信号。</li>
<li><code>SIGBUS</code>：指示一个实现定义的硬件故障。当出现某些类型的内存故障时，实现常常产生此种信号。</li>
<li><code>SIGCANCEL</code>：这是Solaris线程库内部使用的信号。它不适用于一般应用。</li>
<li><code>SIGCHLD</code>：在一个进程终止或停止时，<code>SIGCHLD</code>信号被送给其父进程。按系统默认，将忽略此信号。如果父进程希望被告知其子进程的这种状态改变，则应捕捉此信号。信号捕捉函数中通常要调用一种<code>wait</code>函数以取得子进程ID和其终止状态。</li>
<li><code>SIGCONT</code>：此作业控制信号发送给需要继续运行，但当前处于停止状态的进程。如果接收到此信号的进程处于停止状态，则系统默认动作是使该进程继续运行；否则默认动作是忽略此信号。</li>
<li><code>SIGEMT</code>：指示一个实现定义的硬件故障</li>
<li><code>SIGFPE</code>：此信号表示一个算术运算异常，如除以0、浮点溢出等。</li>
<li><code>SIGFREEZE</code>：此信号仅由Solaris定义。 它用于通知进程在冻结系统状态之前需要采取特定动作，例如当系统进入休眠或挂起状态时可能需要做这种处理。</li>
<li><code>SIGHUP</code>：如果终端接口检测到一个连接断开，则将此信号送给该终端相关的控制进程(会话首进程)。此信号被送给session结构中<code>s_leader</code>字段所指向的进程。仅当终端的CLOCAL标志没有设置时，在上述条件下才产生此信号。(如果所连接的终端是本地的，则设置该终端的CLOCAL标志。它告诉终端驱动程序忽略所有调制解调器的状态行。)</li>
<li><code>SIGILL</code>：此信号表示进程已执行一条非法硬件指令。</li>
<li><code>SIGINFO</code>：这是一种BSD信号，当用户按状态键(一般采用Ctrl+T)时，终端驱动程序产生此信号并发送至前台进程组中的每一个进程。此信号通常造成在终端上显示前台进程组中各进程的状态信息。</li>
<li><code>SIGINT</code>：当用户按中断键(一般采用Delete或Ctrl+C)时，终端驱动程序产生此信号并发送至前台进程组中的每一个进程。当一个进程在运行时失控，特别是它正在屏幕上产生大量不需要的输出时，常用此信号终止它。</li>
<li><code>SIGIO</code>：此信号指示一个异步I/O事件。对<code>SIGIO</code>的系统默认动作是终止或忽略。遭憾的是，这依赖于系统。</li>
<li><code>SIGIOT</code>：这指示一个实现定义的硬件故障。</li>
<li><code>SIGJVM1</code>：Solaris上为Java虚拟机预留的一个信号。</li>
<li><code>SIGJVM2</code>：Solaris上为Java虚拟机预留的另一个信号。</li>
<li><code>SIGKILL</code>：这是两个不能被捕捉或忽略信号中的一个。它向系统管理员提供了一种可以杀死任一进程的可靠方法。</li>
<li><code>SIGLOST</code>：运行在Solaris NFsv4客户系统中的进程，恢复阶段不能重新获得锁，此时将由这个信号通知该进程。</li>
<li><code>SIGLWP</code>：此信号由Solaris线程库内部使用，并不做一般使用。在FreeBSD中，SIGLMP是SIGTHR的别名。</li>
<li><code>SIGPIPE</code>：如果在管道的读进程已终止时写管道，则产生此信号。当类型为<code>SOCK_STREM</code>的套接字已不再连接时，进程写该套接字也产生此信号。</li>
<li><code>SIGPOLL</code>：这个信号在SUSv4中已被标记为弃用，将来的标准可能会将此信号移除。当在一个可轮询设备上发生一个特定事件时产生此信号。</li>
<li><code>SIGPROF</code>：这个信号在SUSw4中已被标记为弃用，将来的标准可能会将此信号移除。当<code>setitimer(2)</code>函数设置的梗概统计间隔定时器(profiling interval timer)已经超时时产生此信号。</li>
<li><code>SIGPWR</code>：这是一种依赖于系统的信号。它主要用于具有不间断电源(UPS)的系统。如果电源失效，则UPS起作用，而且通常软件会接到通知。在这种情况下，系统依靠蓄电池电源继续运行，所以无须做任何处理。但是如果蓄电池也将不能支持工作，则软件通常会再次接到通知，此时，系统必项使其各部分都停止运行。这时应当发送SIGPWR信号。</li>
<li><code>SIGQUIT</code>：当用户在终端上按退出键(一般采用Ctrl+<code>\</code>)时，中断驱动程序产生此信号，并发送给前台进程组中的所有进程。此信号不仅终止前台进程组<br>(如SIGINT所做的那样)，同时产生一个core文件。</li>
<li><code>SIGSEGV</code>：指示进程进行了一次无效的内存引用(通常说明程序有错，比如访问了一个未经初始化的指针)。</li>
<li><code>SIGSTKFLT</code>：此信号仅由Linux定义。它出现在Linux的早期版本，企图用于数学协处理器的栈故障。该信号并非由内核产生，但仍保留以向后兼容。</li>
<li><code>SIGSTOP</code>：这是一个作业控制信号，它停止一个进程。它类似于交互停止信号(<code>SIGTSTP</code>)，但是<code>SIGSTOP</code>不能被捕捉或忽略。</li>
<li><code>SIGSYS</code>：该信号指示一个无效的系统调用。由于某种未知原因，进程执行了一条机器指令，内核认为这是一条系统调用，但该指令指示系统调用类型的参数却是无效的。这种情况是可能发生的，例如，若用户编写了一道使用新系统调用的程序，然后运行该程序的二进制可执行代码，而所用的操作系统却是不支持该系统调用的较早版本，于是就出现上述情况。</li>
<li><code>SIGTERM</code>：这是由<code>kill</code>命令发送的系统默认终止信号。由于该信号是由应用程序捕获的，使用<code>SIGTERM</code>也让程序有机会在退出之前做好清理工作，从而优雅地终止(相对于<code>SIGKILL</code>而言。<code>SIGKILL</code>不能被捕捉或者忽略)。</li>
<li><code>SIGTHAW</code>：此信号仅由Solaris定义。在被挂起的系统恢复时，该信号用于通知相关进程，它们需要采取特定的动作。</li>
<li><code>SIGTHR</code>：FreeBSD线程库预留的信号，它的值定义或与<code>SIGLWP</code>相同。</li>
<li><code>SIGTRAP</code>：指示一个实现定义的硬件故障。</li>
<li><code>SIGTSTP</code>：交互停止信号，当用户在终端上按挂起键(一般采用Ctrl+Z)时，终端驱动程序产生此信号。该信号发送至前台进程组中的所有进程。速憾的是，停止具有不同的含义。当讨论作业控制和信号时，我们谈及停止和继续作业。但是，终端驱动程序一直使用术语“停止”表示用Cul+S字符终止终端输出，为了继续启动该终端输出，则用Ctrl+Q字符。为此，终端驱动程序称产生交互停止信号的字符为挂起字符，而非停止字符。</li>
<li><code>SIGTTIN</code>：当一个后台进程组进程试图读其控制终端时，终端驱动程序产生此信号。在下列例外情形下不产生此信号：<ul>
<li>读进程忽略或阻塞此信号；</li>
<li>读进程所属的进程组是孤儿进程组，此时读操作返回出错，errno设置为EIO。</li>
</ul>
</li>
<li><code>SIGTTOU</code>：当一个后台进程组进程试图写其控制终端时，终端驱动程序产生此信号。与上面所述的<code>SIGTTIN</code>信号不同，一个进程可以选择允许后台进程写控制终端。如果不允许后台进程写，则与<code>SIGTTIN</code>相似，也有两种特殊情况：<ul>
<li>写进程忽略或阻塞此信号；</li>
<li>写进程所属进程组是孤儿进程组。在第2种情况下不产生此信号，写操作返回出错，errno设置为EIO。</li>
</ul>
</li>
<li><code>SIGURG</code>：此信号通知进程已经发生一个紧急情况。在网络连接上接到带外的数据时，可选择地产生此信号。</li>
<li><code>SIGUSRI</code>：这是一个用户定义的信号，可用于应用程序，</li>
<li><code>SIGUSR2</code>：这是另一个用户定义的信号，与<code>SIGUSR1</code>相似，可用于应用程序。</li>
<li><code>SIGVTALRM</code>：当一个由<code>setitime(2)</code>函数设置的虚拟间隔时间已经超时时，产生此信号。</li>
<li><code>SIGWAITING</code>：此信号由Solaris线程库内部使用，不做他用。</li>
<li><code>SIGWINCH</code>：内核维持与每个终端或伪终端相关联窗口的大小。进程可以用<code>ioctl</code>函数得到成设置窗口的大小。如果进程用<code>ioctl</code>的设置窗口大小命令更改了窗口大小，则内核将<code>SIGWINCH</code>信号发送至前台进程组。</li>
<li><code>SIGXCPU</code>：Single UNIX Specification的XSI扩展支持资源限制的概念。如果进程超过了其软CPU时间限制，则产生此信号。</li>
<li><code>SIGXFSZ</code>：如果进程超过了其软文件长度限制，则产生此信号。</li>
<li><code>SIGXRES</code>：此信号仅由Solaris定义。可选择地使用此信号以通知进程超过了预配置的资源值。</li>
</ul>
<h2 id="函数signal"><a href="#函数signal" class="headerlink" title="函数signal"></a>函数signal</h2><p>UNIX系统信号机制最简单的接口是<code>signal</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> (*signal (<span class="type">int</span> signo, <span class="type">void</span> (*func) (<span class="type">int</span>)))(<span class="type">int</span>);</span><br><span class="line"><span class="comment">// 返回值：若成功，返回以前的信号处理配置。若出错：返回SIG_ERR</span></span><br></pre></td></tr></table></figure></p>
<p><code>signal</code>函数由ISO C定义。因为ISO C不涉及多进程、进程组以及终端I/O等，所以它对信号的定义非常含糊，以致于对UNIX系统而言几乎毫无用处。</p>
<p><code>signo</code>参数是信号名。<code>func</code>的值是常量<code>SIG_IGN</code>、常量<code>SIG_DFL</code>或当接到此信号后要调用的函数的地址。如果指定<code>SIG_IGN</code>，则向内核表示忽略此信号(记住有两个信号<code>SIGKILL</code>和<code>SIGSTOP</code>不能忽略)。如果指定<code>SIG_DFL</code>，则表示接到此信号后的动作是系统默认动作。当指定函数地址时，则在信号发生时，调用该函数，我们称这种处理为捕捉该信号，称此函数为<strong>信号处理程序</strong>(signal handler) 或<strong>信号捕捉函数</strong>(signal-catching function)。</p>
<p><code>signal</code>函数原型说明此函数要求两个参数，返回-一个函数指针，而该指针所指向的函数无返回值(void)。第一个参数<code>signo</code>是一个整型数，第二个参数是函数指针，它所指向的函数需要一个整型参数，无返回值。<code>signal</code>的返回值是一个函数地址，该函数有一个整型参数(即最后的(int))。用自然语言来描述也就是要向信号处理程序传送一个整型参数，而它却无返回值。</p>
<p>当调用<code>signal</code>设置信号处理程序时，第二个参数是指向该函数(也就是信号处理程序)的指针。<code>signal</code>的返回值则是指向在此之前的信号处理程序的指针。很多系统用附加的依赖于实现的参数来调用信号处理程序。本节开头所示的signal函数原型太复杂了，如果使用下面的typedef，则可使其简单一些。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedet <span class="type">void</span> <span class="title function_">Sigfunc</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后，可将signal函数原型写成：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sigfunc *<span class="title function_">signal</span> <span class="params">(<span class="type">int</span>, Sigfunc *)</span>;</span><br></pre></td></tr></table></figure></p>
<p>我们已将此<code>typedef</code>包括在<code>apue.h</code>文件中，并随本章中的函数一起使用。如果查看系统的头文件<code>&lt;signal.h&gt;</code>，则很可能会找到下列形式的声明：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_ERR (void (*)())-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_DFL (void (*)())0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_IGN (void (*)())1</span></span><br></pre></td></tr></table></figure></p>
<p>这些常量可用于表示“指向函数的指针，该函数要求一个整型参数，而且无返回值”。<code>signal</code>的第二个参数及其返回值就可用它们表示。这些常量所使用的3个值不一定是-1、0和1，但它们必须是3个值而决不能是任一函数的地址。大多数UNIX系统使用上面所示的值。</p>
<p>给出了一个简单的信号处理程序，它捕捉两个用户定义的信号并打印信号编号。它使调用进程在接到一信号前挂起。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_usr</span><span class="params">(<span class="type">int</span>)</span> <span class="comment">/* one handler for both signals */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (signal (SIGUSR1, sig_usr) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">&quot;can&#x27;t catch SIGUSR1&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (signal (SIGUSR2, sig_usr) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">&quot;can&#x27;t catch STGUSR2&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (; ;)</span><br><span class="line">		pause();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_usr</span><span class="params">(<span class="type">int</span> signo)</span> <span class="comment">/* arqunent is signal number */</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (signo == SIGUSR1)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;received SIGUSR1\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (signo == SIGUSR2)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;received SIGUSR2\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		err_dump(<span class="string">&quot;received signal %d\n&quot;</span>, signo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们使该程序在后台运行，并且用<code>kill(1)</code>命令将信号发送给它。注意，在UNIX系统中，杀死(<code>kill</code>)这个术语是不恰当的。<code>kill(1)</code>命令和<code>kill(2)</code>函数只是将一个信号发送给一个进程或进程组。该信号是否终止进程则取决于该信号的类型，以及进程是否安排了捕捉该信号。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$./a.out &amp;   在后台启动进程</span><br><span class="line">[1] 7216     作业控制thell打印作业编号和进程ID</span><br><span class="line">$ <span class="built_in">kill</span> -USR1 7226  向该进程发送SIGUSR1</span><br><span class="line">received SIGUSR1</span><br><span class="line">$ <span class="built_in">kill</span> -USR2 7216  向该进程发送SIGUSR2</span><br><span class="line">received SIGUSR2</span><br><span class="line">$ <span class="built_in">kill</span> 7216        向该进程发送SIGTERM</span><br><span class="line">[1]+ Terminated ./a.out</span><br></pre></td></tr></table></figure></p>
<p>因为执行程序的进程不捕捉SIGTERM信号，而对该信号的系统默认动作是终止，所以当向该进程发送SIGTERM信号后，该进程就终止.</p>
<h3 id="程序启动"><a href="#程序启动" class="headerlink" title="程序启动"></a>程序启动</h3><p>当执行一个程序时，所有信号的状态都是系统默认或忽略，通常所有信号都被设置为它们的默认动作，除非调用exec的进程忽略该信号。确切地讲， exec函数将原先设置为要捕捉的信号都更改为默认动作，其他信号的状态则不变(一个进程原先要捕捉的信号，当其执行一个新程序后，就不能再捕捉了，因为信号捕捉函数的地址很可能在所执行的新程序文件中已无意义)。</p>
<p>一个具体例子是一个交互，shell如何处理针对后台进程的中断和退出信号。对于一个非作业控制shell，当在后台执行一个进程时，例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc main.cc &amp;</span><br></pre></td></tr></table></figure></p>
<p>shell自动将后台进程对中断和退出信号的处理方式设置为忽略。于是， 当按下中断字符时就不会影响到后台进程。如果没有做这样的处理，那么当按下中断字符时，它不但终止前台进程，也终止所有后台进程。</p>
<p>很多捕捉这两个信号的交互程序具有下列形式的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sig_int</span><span class="params">(<span class="type">int</span>)</span>, <span class="title function_">sig_quit</span> <span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">it (signal (SIGINT, SIG_IGN) != SIGIGN)</span><br><span class="line">	signal (SIGINT, sig_int);</span><br><span class="line"><span class="keyword">if</span> (signal (SIGQUIT, SIG_IGN) != SIG_IGN)</span><br><span class="line">	signal (SIGQUIT, sig_quit);</span><br></pre></td></tr></table></figure></p>
<p>这样处理后，仅当<code>SIGINT</code>和<code>SIGQUIT</code>当前未被忽略时，进程才会捕捉它们。从<code>signal</code>的这两个调用中也可以看到这种函数的限制，不改变信号的处理方式就不能确定信号的当前处理方式。</p>
<h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>当一个进程调用fork时，其子进程继承父进程的信号处理方式。因为子进程在开始时复制了父进程内存映像，所以信号捕捉函数的地址在子进程中是有意义的。</p>
<h2 id="不可靠的信号"><a href="#不可靠的信号" class="headerlink" title="不可靠的信号"></a>不可靠的信号</h2><p>在早期的UNIX版本中(如V7)，信号是不可靠的。不可靠在这里指的是，信号可能会丢失：一个信号发生了，但进程却可能一直不知道这一 点。同时，进程对信号的控制能力也很差，它能捕捉信号或忽略它。有时用户希望通知内核阻塞某个信号：不要忽略该信号，在其发生时记住它，然后在进程做好了准备时再通知它。这种阻塞信号的能力当时并不具备。</p>
<p>早期版本在进程每次接到信号对其进行处理时，随即将该信号动作重置为默认值：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="title function_">sig_int</span><span class="params">()</span>;   <span class="comment">/*my signal handling function */</span></span><br><span class="line">...</span><br><span class="line">signal(SIGINT, sig_int) <span class="comment">/* establish handler */</span></span><br><span class="line">...</span><br><span class="line">sig_int() &#123;</span><br><span class="line">	signal (SIGINT, sig_int): <span class="comment">/* reestabliah handler for next time */</span></span><br><span class="line">							<span class="comment">/*process the signal */</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码的一个问题是：在信号发生之后到信号处理程序调用<code>signal</code>函数之间有一个时间窗口。在此段时间中，可能发生另一次中断信号。第二个信号会造成执行默认动作，而对中断信号的默认动作是终止该进程。这种类型的程序段在大多数情况下会正常工作，使得我们认为它们是正确无误的，而实际上却并非如此。</p>
<p>这些早期版本的另一个问题是：在进程不希望某种信号发生时，它不能关闭该信号。进程能做的一切就是忽略该信号。有时希望通知系统“阻止下列信号发生，如果它们确实产生了，请记住它们。”能够显现这种缺陷的的一个经典实例是下列程序段，它捕捉一个信号，然后设置一个表示该信号已发生的标志：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sig_int</span><span class="params">()</span>:</span><br><span class="line"><span class="comment">/* my signal handling function */</span></span><br><span class="line"><span class="type">int</span> sig_int_flags</span><br><span class="line"><span class="comment">/* set nonzero when signal oecurs */</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	signal (SIGINT, sig_int);</span><br><span class="line">	<span class="comment">/* establish handler */</span></span><br><span class="line">	<span class="keyword">while</span> (sig_int_flag == <span class="number">0</span>)</span><br><span class="line">		<span class="comment">/* go to sleep, waiting for signal */</span></span><br><span class="line">		pause();</span><br><span class="line">&#125;</span><br><span class="line">sig_int() &#123;</span><br><span class="line">	signal (SIGINT, sig_int);</span><br><span class="line">	<span class="comment">/* reestablish handler for next time */</span></span><br><span class="line">	sig_int_tiag = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* set flag for main loop to examine */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，进程调用<code>pause</code>函数使自己休眠，直到捕捉到一个信号。当捕提到信号时，信号处理程序将标志<code>sig_int_flag</code>设置为非0值。从信号处理程序返回后，内核自动将该进程唤醒，它检测到该标志为非0，然后执行它所需做的。但是这里有一个时间窗口，在此窗口中操作可能失误。如果在测试<code>sig_int_flag</code>之后、调用<code>pause</code>之前发生信号，则此进程在调用<code>pause</code>时可能将永久休眠(假定此信号不会再次产生)。于是，这次发生的信号也就丢失了。</p>
<h2 id="中断的系统调用"><a href="#中断的系统调用" class="headerlink" title="中断的系统调用"></a>中断的系统调用</h2><p>早期UNIX系统的一个特性是：如果进程在执行一个低速系统调用而阻塞期间捕捉到一个信号，则该系统调用就被中断不再继续执行。该系统调用返回出错，其errno设置为<code>EINTR</code>。这样处理是因为一个信号发生了，进程捕捉到它，这意味着已经发生了某种事情，所以是个好机会应当唤醒阻塞的系统调用。</p>
<p>为了支持这种特性，将系统调用分成两类：<strong>低速系统调用</strong>和<strong>其他系统调用</strong>。低速系统调用是可能会使进程永远阻塞的类系统调用，包括：</p>
<ul>
<li>如果某些类型文件(如读管道、终端设备和网络设备)的数据不存在，则读操作可能会使调用者永远阻塞；</li>
<li>如果这些数据不能被相同的类型文件立即接受，则写操作可能会使调用者永远阻塞；</li>
<li>在某种条件发生之前打开某些类型文件，可能会发生阻塞(例如要打开一个终端设备，需要先等待与之连接的调制解调器应答)；</li>
<li><code>pause</code>函数(按照定义，它使调用进程体眼直至捕捉到一个信号)和wait函数；</li>
<li>某些<code>ioctl</code>操作；</li>
<li>某些进程间通信函数。</li>
</ul>
<p>在这些低速系统调用中，一个值得注意的例外是与磁盘I/O有关的系统调用。虽然读、写一个磁盘文件可能暂时阻塞调用者(在磁盘驱动程序将请求排入队列，然后在适当时间执行请求期间)，但是除非发生硬件错误，I/O操作总会很快返回，并使调用者不再处于阻塞状态。</p>
<p>对于中断的<code>read</code>、<code>write</code>系统调用早期版本允许实现自行选择。如若read系统调用已接收并传送数据至应用程序缓冲区，但尚来接收到应用程序请求的全部数据，此时被中断，操作系统可以认为该系统调用失败，并将errno设置为EINTR；另一种处理方式是允许该系统调用成功返回，送回值是已接收到的数据量。与此类似，如若<code>write</code>已传输了应用程序缓冲区中的部分数据，然后被中断，操作系统可以认为该系统调用失败，并将errno设置为EINTR。另一种处理方式是允许该系统调用成功返回，返回值是已写部分的数据量。历史上，从System V派生的实现将这种系统调用视为失败，而BSD派生的实现则处理为部分成功返回。</p>
<p>与被中断的系统调用相关的问题是必须显式地处理出错返回。典型的代码序列(假定进行一个读操作，它被中断，我们希望重新启动它)如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">again:</span><br><span class="line">	<span class="keyword">if</span> ((n = read(fd, buf, BUFFSIZE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">			<span class="keyword">goto</span> again;  <span class="comment">/* just an interrupted aystem call */</span></span><br><span class="line">		<span class="comment">/* handle other errors */</span></span><br></pre></td></tr></table></figure></p>
<p>4.2BSD引进了某些被中断系统调用的自动重启动。自动重启动的系统调用包括，<code>ioctl</code>、<code>read</code>、<code>readv</code>、<code>write</code>、<code>writev</code>、<code>wait</code>、<code>waitpid</code>。如前所述，其中前5个函数只有对低速设备进行操作时才会被信号中断。而<code>wait</code>和<code>waitpid</code>在捕捉到信号时总是被中断。4.3BSD允许进程基于每个信号禁用此功能。POSIX.1要求只有中断信号的<code>SA_RESTART</code>标志有效时，实现才重启动系统调用。</p>
<p>4.2BSD引入自动重启动功能的一个理由是：有时用户并不知道所使用的输入、输出设备是否是低速设备。如果我们编写的程序可以用交互方式运行，则它可能读、写终端低速设备。如果在程序中捕捉信号，而且系统并不提供重启动功能，则对每次读、写系统调用就要进行是否出错返回的测试，如果是被中断的，则再调用读、写系统调用。</p>
<h2 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h2><p>进程捕捉到信号并对其进行处理时，进程正在执行的正常指令序列就被信号处理程序临时中断，它首先执行该信号处理程序中的指令。如果从信号处理程序返回，则继续执行在捕捉到信号时进程正在执行的正常指令序列。但在信号处理程序中，不能判断捕捉到信号时进程执行到何处。Single UNIX Specification说明了在信号处理程序中保证调用安全的函数。这些函数是可重入的并被称为是<strong>异步信号安全</strong>的(async-signal safe)。除了可重入以外，在信号处理操作期间，它会阻塞任何会引起不一致的信号发送。图10-4列出了这些异步信号安全的函数。<br><img src="/img/1622104996.jpg" alt=""></p>
<p>其他的大多数函数是不可重入的，因为：</p>
<ul>
<li>已知它们使用静态数据结构；</li>
<li>它们调用malloc或free；</li>
<li>它们是标准I/O函数。</li>
</ul>
<h2 id="SIGCLD语义"><a href="#SIGCLD语义" class="headerlink" title="SIGCLD语义"></a>SIGCLD语义</h2><p><code>SIGCLD</code>和<code>SIGCHLD</code>这两个信号很容易被混淆。<code>SIGCLD</code>是System V的一个信号名，其语义与名为<code>SIGCHLD</code>的BSD信号不同。POSIX.1采用BSD的<code>SIGCHLD</code>信号。BSD的<code>SIGCHLD</code>信号语义与其他信号的语文相类似，子进程状态改变后产生此信号，父进程需要调用一个<code>wait</code>函数以检测发生了什么。</p>
<p>对于<code>SIGCLD</code>的早期处理方式是：</p>
<ol>
<li>如果进程明确地将该信号的配置设置为<code>SIG_IGN</code>，则调用进程的子进程将不产生僵死进程。注意，这与其默认动作(<code>SIG_DFL</code>)“忽略”不同。子进程在终止时，将其状态丢弃。如果调用进程随后调用一个<code>wait</code>函数，那么它将阻塞直到所有子进程都终止，然后该<code>wait</code>会返回-1，并将其errno设置为<code>ECHILD</code>。</li>
<li>如果将<code>SIGCLD</code>的配置设置为捕捉，则内核立即检查是否有子进程准备好被等待，如果是这样，则调用<code>SIGCLD</code>处理程序，第2种方式改变了为此信号编写处理程序的方法，这一点可在下面的实例中看到。</li>
</ol>
<p>进入信号处理程序后，首先要调用<code>signal</code>函数以重新设置此信号处理程序(在信号被重置为其默认值时，它可能会丢失，立即重新设置可以减少此窗口时间)。下边展示了这一点。程序一行行地不断重复输出“SIGCLD received”，最后进程用完其栈空间并异常终止。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>	<span class="title function_">sig_cld</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (signal(SIGCLD, sig_cld) == SIG_ERR)</span><br><span class="line">		perror(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;		<span class="comment">/* child */</span></span><br><span class="line">		sleep(<span class="number">2</span>);</span><br><span class="line">		_exit(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pause();	<span class="comment">/* parent */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sig_cld</span><span class="params">(<span class="type">int</span> signo)</span>	<span class="comment">/* interrupts pause() */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line">	<span class="type">int</span>		status;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;SIGCLD received\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (signal(SIGCLD, sig_cld) == SIG_ERR)	<span class="comment">/* reestablish handler */</span></span><br><span class="line">		perror(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = wait(&amp;status)) &lt; <span class="number">0</span>)		<span class="comment">/* fetch child status */</span></span><br><span class="line">		perror(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;pid = %d\n&quot;</span>, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此程序的问题是，在信号处理程序的开始处调用<code>signal</code>，按照上述第2种方式，内核检查是否有需要等待的子进程(因为我们正在处理一个<code>SIGCLD</code>信号，所以确实有这种子进程)，所以它产生另一个对信号处理程序的调用。信号处理程序调用<code>signal</code>，整个过程再次重复。</p>
<p>为了解决这一问题，应当在调用<code>wait</code>取到子进程的终止状态后再调用<code>signal</code>。此时仅当其他子进程终止，内核才会再次产生此种信号。</p>
<h2 id="可靠信号术语和语义"><a href="#可靠信号术语和语义" class="headerlink" title="可靠信号术语和语义"></a>可靠信号术语和语义</h2><p>当一个信号产生时，内核通常在进程表中以某种形式设置一个标志。当对信号采取了这种动作时，我们说向进程递送了一个信号。在信号产生(generation)和递送(delivery)之间的时间间隔内，称信号是未决的(pending)。</p>
<p>进程可以选用“阻塞信号递送”。如果为进程产生了一个阻塞的信号，而且对该信号的动作是系统默认动作或捕捉该信号，则为该进程将此信号保持为未决状态，直到该进程对此信号解除了阻塞，或者将对此信号的动作更改为忽略。内核在递送一个原来被阻塞的信号给进程时(而不是在产生该信号时)，才决定对它的处理方式。于是进程在信号递送给它之前仍可改变对该信号的动作。进程调用<code>sigpending</code>函数来判定哪些信号是设置为阻塞并处于未决状态的。</p>
<p>POSIX.1允许系统递送该信号一次或多次。如果递送该信号多次，则称这些信号进行了排队。但是除非支持POSIX.1实时扩展，否则大多数UNIX并不对信号排队，而是只递送这种信号一次。</p>
<p>如果有多个信号要递送给一个进程，POSIX.1并没有规定这些信号的递送顺序。但是POSIX.1基础部分建议：在其他信号之前递送与进程当前状态有关的信号，如SIGSEGV。每个进程都有一个<strong>信号屏蔽字</strong>(signal mask)，它规定了当前要阻塞递送到该进程的信号集。对于每种可能的信号，该屏蔽字中都有一位与之对应。对于某种信号，若其对应位已设置，则它当前是被阻塞的。进程可以调用<code>sigprocmask</code>来检测和更改其当前信号屏蔽字。信号编号可能会超过一个整型所包含的二进制位数，因此POSIX.1定义了一个新数据类型<code>sigset_t</code>，它可以容纳一个信号集。例如，信号屏蔽字就存放在其中一个信号集中。</p>
<h2 id="函数kill和raise"><a href="#函数kill和raise" class="headerlink" title="函数kill和raise"></a>函数kill和raise</h2><p><code>kill</code>函数将信号发送给进程或进程组。<code>raise</code>函数则允许进程向自身发送信号。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span> <span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sigmo)</span> i</span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> signo)</span>;</span><br><span class="line"><span class="comment">// 两个函数返回值：若成功。返回0；若出错：返回-!</span></span><br></pre></td></tr></table></figure></p>
<p>调用<code>raise(signo)</code>等价于调用<code>kill(getpid(), signo);</code>。</p>
<p><code>kill</code>的<code>pid</code>参数有以下4种不同的情况</p>
<ul>
<li><code>pid&gt;0</code>：将该信号发送给进程ID为<code>pid</code>的进程。</li>
<li><code>pid==0</code>：将该信号发送给与发送进程属于同一进程组的所有进程(这些进程的进程组ID等于发送进程的进程组ID)，而且发送进程具有权限向这些进程发送信号。这里用的术语“所有进程”不包括实现定义的系统进程集。对于大多数UNIX系统，系统进程集包括内核进程和init(pid为1)。</li>
<li><code>pid&lt;0</code>：将该信号发送给其进程组ID等于pid绝对值，而且发送进程具有权限向其发送信号的所有进程。如前所述，所有进程并不包括系统进程集中的进程。</li>
<li><code>pid==-1</code>：将该信号发送给发送进程有权限向它们发送信号的所有进程。如前所述，所有进程不包括系统进程集中的进程。</li>
</ul>
<p>如前所述，进程将信号发送给其他进程需要权限。超级用户可将信号发送给任一进程。对于非超级用户，其基本规则是发送者的实际用户ID或有效用户ID必须等于接收者的实际用户ID 或有效用户ID。如果实现支持<code>_POSIX_SAVED_IDS</code>，则检查接收者的保存设置用户ID(而不是有效用户ID)。在对权限进行测试时也有一个特例：如果被发送的信号是<code>SIGCONT</code>，则进程可将它发送给属于同一会话的任一其他进程。POSIX.1将信号编号0定义为空信号。如果<code>signo</code>参数是0，则<code>kill</code>仍执行正常的错误检查，但不发送信号。这常被用来确定一个特定进程是否仍然存在。如果向一个并不存在的进程发送空信号，则<code>kill</code>返回-1，<code>errno</code>被设置为<code>ESRCH</code>。</p>
<p>还应理解的是，测试进程是否存在的操作不是原子操作。在<code>kill</code>向调用者返回测试结果时，原来已存在的被测试进程此时可能已经终止，所以这种测试并无多大价值。如果调用<code>kill</code>为调用进程产生信号，而且此信号是不被阻塞的，那么在<code>kill</code>返回之前，<code>signo</code>或者某个其他未决的、非阻塞信号被传送至该进程。</p>
<h2 id="函数alarm和pause"><a href="#函数alarm和pause" class="headerlink" title="函数alarm和pause"></a>函数alarm和pause</h2><p>使用<code>alarm</code>函数可以设置一个定时器(闹钟时间)，在将来的某个时刻该定时器会超时。当定时器超时时，产生<code>SIGALRM</code>信号。如果忽略或不捕捉此信号，则其默认动作是终止调用该<code>alarm</code>函数的进程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line"><span class="comment">// 返回值：0或以前设置的网钟时间的余留秒数</span></span><br></pre></td></tr></table></figure></p>
<p>参数<code>seconds</code>的值是产生信号<code>SIGALRM</code>需要经过的时钟秒数。当这一时刻到达时，信号由内核产生，由于进程调度的延迟，所以进程得到控制从而能够处理该信号还需要一个时间间隔。</p>
<p>每个进程只能有一个闹钟时间。如果在调用<code>alarm</code>时，之前已为该进程注册的闹钟时间还没有超时，则该闹钟时间的余留值作为本次<code>alarm</code>函数调用的值返回。以前注册的闹钟时间则被新值代替。如果有以前注册的尚未超过的周钟时间，而且本次调用的<code>seconds</code>值是0。则取消以前的闹钟时间，其余留值仍作为<code>alarm</code>函数的返回值。</p>
<p>虽然<code>SIGALRM</code>的默认动作是终止进程，但是大多数使用限钟的进程捕捉此信号。如果此时进程要终止，则在终止之前它可以执行所需的清理操作。如果我们想捕捉SIGALRM信号，则必须在调用<code>alarm</code>之前安装该信号的处理程序。如果我们先调用<code>alarm</code>，然后在我们能够安装<code>SIGALRM</code>处理程序之前已接到该信号，那么进程将终止。</p>
<p><code>pause</code>函数使调用进程挂起直至捕捉到一个信号。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> cunistd.h&gt;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回值：-1，errno设置为EINTR</span></span><br></pre></td></tr></table></figure></p>
<p>只有执行了一个信号处理程序并从其返回时，<code>pause</code>才返回。在这种情况下，<code>pause</code>返回-1，<code>errno</code>设置为<code>EINTR</code>。</p>
<p>使用<code>alarm</code>和<code>pause</code>，进程可使自己休眠一段指定的时间。<code>sleep1</code>函数看似提供了这种功能。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sig_alrm</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* nothing to do, just return to wake up the pause */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sleep1</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR)</span><br><span class="line">		<span class="keyword">return</span>(seconds);</span><br><span class="line">	alarm(seconds);		<span class="comment">/* start the timer */</span></span><br><span class="line">	pause();			<span class="comment">/* next caught signal wakes us up */</span></span><br><span class="line">	<span class="keyword">return</span>(alarm(<span class="number">0</span>));	<span class="comment">/* turn off timer, return unslept time */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种简单实现有以下3个问题，</p>
<ol>
<li>如果在调用<code>sleep1</code>之前，调用者已设置了闹钟，则它被<code>sleep1</code>函数中的第一次<code>alarm</code>调用擦除。可用下列方法更正这一点检查第一次调用<code>alarm</code>的返回值，如其值小于本次调用<code>alarm</code>的参数值，则只应等到已有的阔钟超时。如果之前设置的闹钟超时时间晚于本次设置值，则在<code>sleep1</code>函数返回之前，重置此闹钟，使其在之前闹钟的设定时间再次发生超时。</li>
<li>该程序中修改了对<code>SIGALRM</code>的配置。如果编写了一个函数供其他函数调用，则在该函数被调用时先要保存原配置，在该函数返回前再恢复原配置。更正这一点的方法是：保存<code>signal</code>函数的返回值，在返回前重置原配置。</li>
<li>在第一次调用<code>alarm</code>和<code>pause</code>之间有一个竞争条件。在一个繁忙的系统中，可能<code>alarm</code>在调用<code>pause</code>之前超时，并调用了信号处理程序。如果发生了这种情况，则在调用<code>pause</code>后，如果没有捕捉到其他信号，调用者将永远被挂起。</li>
</ol>
<p>有两种方法可以更正第3个问题。第一种方法是使用<code>setjmp</code>，另一种方法是使用<code>sigprocmask</code>和<code>sigsuspend</code>。</p>
<p>SVR2中的<code>sleep</code>实现使用了<code>setjmp</code>和<code>longjmp</code>，以避免前一个实例的第3个问题中说明的竞争条件。此函数的一个简化版本称为<code>sleep2</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> jmp_buf	env_alrm;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sig_alrm</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">	longjmp(env_alrm, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sleep2</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR)</span><br><span class="line">		<span class="keyword">return</span>(seconds);</span><br><span class="line">	<span class="keyword">if</span> (setjmp(env_alrm) == <span class="number">0</span>) &#123;</span><br><span class="line">		alarm(seconds);		<span class="comment">/* start the timer */</span></span><br><span class="line">		pause();			<span class="comment">/* next caught signal wakes us up */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(alarm(<span class="number">0</span>));		<span class="comment">/* turn off timer, return unslept time */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>sleep2</code>函数中却有另一个难以察觉的问题，它涉及与其他信号的交互。如果<code>SIGALRM</code>中断了某个其他信号处理程序，则调用<code>longjmp</code>会提早终止该信号处理程序。</p>
<p>除了用来实现<code>sleep</code>函数外，<code>alarm</code>还常用于对可能阻塞的操作设置时间上限值。例如，程序中有一个读低速设备的可能阻塞的操作，我们希望超过一定时间量后就停止执行该操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>	<span class="title function_">sig_alrm</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		n;</span><br><span class="line">	<span class="type">char</span>	line[MAXLINE];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">&quot;signal(SIGALRM) error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	alarm(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> ((n = read(STDIN_FILENO, line, MAXLINE)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">	alarm(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	write(STDOUT_FILENO, line, n);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sig_alrm</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* nothing to do, just return to interrupt the read */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种代码序列在很多UNIX应用程序中都能见到，但是这种程序有两个问题：</p>
<ul>
<li>在第一次<code>alarm</code>调用和<code>read</code>调用之间有一个竞争条件。如果内核在这两个函数调用之间使进程阻塞，不能占用处理机运行，而其时间长度又超过闹钟时间，则<code>read</code>可能永远阻塞。大多数这种类型的操作使用较长的闹钟时间，例如1分钟或更长一点，使这种问题不会发生，但无论如何这是一个竞争条件。</li>
<li>如果系统调用是自动重启动的，则当从<code>SIGALRM</code>信号处理程序返回时，<code>read</code>并不被中断。在这种情形下，设置时间限制不起作用。</li>
</ul>
<h2 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h2><p>我们需要有一个能表示多个信号信号集(signalser)的数据类型。我们将在<code>sigprocmask</code>类函数中使用这种数据类型，以便告诉内核不允许发生该信号集中的信号。如前所述，不同的信号的编号可能超过一个整型量所包含的位数，所以一般而言，不能用整型量中的一位代表一种信号，也就是不能用一个整型量表示信号集。POSIX.1定义数据类型<code>sigset_t</code>以包含一个信号集，并且定义了下列5个处理信号集的函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span> <span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span> <span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span> <span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signo)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span> <span class="params">(<span class="type">sigset_t</span> *ser, <span class="type">int</span> signo)</span>;</span><br><span class="line"><span class="comment">// 4个函数返回值：若成功，返回0；若出错，返回-1</span></span><br><span class="line"><span class="type">int</span> sigismember lconst <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> sigmo);</span><br><span class="line"><span class="comment">// 返回值：若真。返回1；若假，返回0</span></span><br></pre></td></tr></table></figure></p>
<p>函数<code>sigemptyset</code>初始化由<code>set</code>指向的信号集，清除其中所有信号。函数<code>sigfillset</code>初始化由<code>set</code>指向的信号集，使其包括所有信号。所有应用程序在使用信号集前，要对该信号集调用<code>sigemptyset</code>或<code>sigfillset</code>一次。这是因为C编译程序将不赋初值的外部变量和静态变量都初始化为0，而这是否与给定系统上信号集的实现相对应却并不清楚。一旦已经初始化了一个信号集，以后就可在该信号集中增、删特定的信号。函数<code>sigaddset</code>将一个信号添加到已有的信号集中，<code>sigdelset</code>则从信号集中删除一个信号。对所有以信号集作为参数的函数，总是以信号集地址作为向其传送的参数。</p>
<p>如果实现的信号数目少于一个整型最所包含的位数，则可用一位代表一个信号的方法实现信号集。<code>sigemptyset</code>函数将整型设置为0。<code>sigfillset</code>函数则将整型中的各位都设置为1。这两个函数可以在<code>&lt;signal.h&gt;</code>头文件中实现为宏：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> sigemptyset(ptr) (*(ptz) = 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sigfillset(ptr)(*(ptr) = (sigset_t)0, 0)</span></span><br></pre></td></tr></table></figure></p>
<p>注意，除了设置信号集中各位为1外，<code>sigfillset</code>必须返回0，所以使用C语言的逗号算符，它将逗号算符后的值作为表达式的值返回。</p>
<p>使用这种实现，<code>sigaddset</code>开启一位(将该位设置为1)，<code>sigdelset</code>则关闭一位(将该位设置为0)，<code>sigismember</code>测试一个指定的位。因为没有信号编号为0，所以从信号编号中减1以得到要处理位的位编号数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * &lt;signal.h&gt; usually defines NSIG to include signal number 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SIGBAD(signo)	((signo) <span class="string">&lt;= 0 || (signo) &gt;</span>= NSIG)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (SIGBAD(signo)) &#123;</span><br><span class="line">		errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	*<span class="built_in">set</span> |= <span class="number">1</span> &lt;&lt; (signo - <span class="number">1</span>);		<span class="comment">/* turn bit on */</span></span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (SIGBAD(signo)) &#123;</span><br><span class="line">		errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	*<span class="built_in">set</span> &amp;= ~(<span class="number">1</span> &lt;&lt; (signo - <span class="number">1</span>));	<span class="comment">/* turn bit off */</span></span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (SIGBAD(signo)) &#123;</span><br><span class="line">		errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>((*<span class="built_in">set</span> &amp; (<span class="number">1</span> &lt;&lt; (signo - <span class="number">1</span>))) != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可将这3个函数在<code>&lt;signal.h&gt;</code>中实现为各一行的宏，但是POSIX.1要求检查信号编号参数的有效性，如果无效则设置errno。在宏中实现这一点比函数要难。</p>
<h2 id="函数sigprocmask"><a href="#函数sigprocmask" class="headerlink" title="函数sigprocmask"></a>函数sigprocmask</h2><p>调用函数<code>sigprocmask</code>可以检测或更改，或同时进行检测和更改进程的信号屏蔽字。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="type">sigset_t</span> *<span class="keyword">restrict</span> oset)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0：若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>首先，若<code>oset</code>是非空指针，那么进程的当前信号屏蔽字通过<code>oset</code>返回。其次，若<code>set</code>是一个非空指针，则参数<code>how</code>指示如何修改当前信号屏蔽字。下表说明了<code>how</code>可选的值。<code>SIG_BLOCK</code>是或操作，而<code>SIG_SETMASK</code>则是赋值操作。注意，不能阻塞<code>SIGKILL</code>和<code>SIGSTOP</code>信号。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>how</code></th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SIG_BLOCK</code></td>
<td>该进程新的信号屏蔽字是其当前信号屏蔽字和<code>set</code>指向信号集的井集。<code>set</code>包含了希望阻塞的附加信号</td>
</tr>
<tr>
<td><code>SIG_UNBLOCK</code></td>
<td>该进程新的信号屏蔽字是其当前信号屏蔽字和<code>set</code>所指向信号集补整的交集。<code>set</code>包含了希望解除阻塞的信号</td>
</tr>
<tr>
<td><code>SIG_SETMASK</code></td>
<td>该进程新的信号屏蔽是<code>set</code>指向的值</td>
</tr>
</tbody>
</table>
</div>
<p>如果<code>set</code>是个空指针，则不改变该进程的信号屏蔽字，<code>how</code>的值也无意义。在调用<code>sigprocmask</code>后如果有任何未决的、不再阻塞的信号，则在<code>sigprocmask</code>返回前，至少将其中之一递送给该进程。</p>
<p><code>sigprocmask</code>是仅为单线程进程定义的。处理多线程进程中信号的屏蔽使用另一个函数。</p>
<h2 id="函数sigpending"><a href="#函数sigpending" class="headerlink" title="函数sigpending"></a>函数sigpending</h2><p><code>sigpending</code>函数返回一信号集，对于调用进程而言，其中的各信号是阻塞不能递送的，因而也一定是当前未决的。该信号集通过<code>set</code>参数返回。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错：返回-1</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>	<span class="title function_">sig_quit</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">sigset_t</span>	newmask, oldmask, pendmask;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (signal(SIGQUIT, sig_quit) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">&quot;can&#x27;t catch SIGQUIT&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Block SIGQUIT and save current signal mask.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sigemptyset(&amp;newmask);</span><br><span class="line">	sigaddset(&amp;newmask, SIGQUIT);</span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;SIG_BLOCK error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">5</span>);	<span class="comment">/* SIGQUIT here will remain pending */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sigpending(&amp;pendmask) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;sigpending error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (sigismember(&amp;pendmask, SIGQUIT))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\nSIGQUIT pending\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Restore signal mask which unblocks SIGQUIT.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;SIG_SETMASK error&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT unblocked\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">5</span>);	<span class="comment">/* SIGQUIT here will terminate with core file */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sig_quit</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;caught SIGQUIT\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (signal(SIGQUIT, SIG_DFL) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">&quot;can&#x27;t reset SIGQUIT&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进程阻塞<code>SIGQUIT</code>信号，保存了当前信号屏蔽字(以便以后恢复)，然后休眠5秒。在此期间所产生的退出信号<code>SIGQUIT</code>都被阻塞，不递送至该进程，直到该信号不再被阻塞。在5秒休眠结束后，检查该信号是否是未决的，然后将<code>SIGQUIT</code>设置为不再阻塞。</p>
<p>注意，在设置<code>SIGQUIT</code>为阻塞时，我们保存了老的屏蔽字。为了解除对该信号的阻塞，用老的屏蔽字重新设置了进程信号屏蔽字(<code>SIG_SETMASK</code>)、另一种方法是用<code>SIG_UNBLOCK</code>使阻塞的信号不再阻塞。但是，应当了解如果编写一个可能由其他人使用的函数，而且需要在函数中阻塞一个信号，则不能用<code>SIG_UNBLOCK</code>简单地解除对此信号的阻塞，这是因为此函数的调用者在调用本函数之前可能也阻塞了此信号。在这种情况下必须使用<code>SIG_SETMASK</code>将信号屏蔽字恢复为先前的值。这样也就能继续阻塞该信号。</p>
<p>在休眠期间如果产生了退出信号，那么此时该信号是未决的，但是不再受阻塞，所以在<code>sigprocmask</code>返回之前，它被递送到调用进程，从程序的输出中可以看到这一点：<code>SIGQUIT</code>处理程序(<code>sig_quit</code>)中的<code>printf</code>语句先执行，然后再执行<code>sigprocmask</code>之后的<code>printf</code>语句。然后该进程再休眠5秒。如果在此期间再产生退出信号，那么因为在上次捕捉到该信号时，已将其处理方式设置为默认动作，所以这一次它就会使该进程终止。</p>
<h2 id="函数sigaction"><a href="#函数sigaction" class="headerlink" title="函数sigaction"></a>函数sigaction</h2><p><code>sigaction</code>函数的功能是检查或修改(或检查并修改)与指定信号相关联的处理动作。此函数取代了UNIX早期版本使用的<code>signal</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signo, <span class="type">const</span> <span class="keyword">struct</span> sigaction *<span class="keyword">restrict</span> act, <span class="keyword">struct</span> sigaction *<span class="keyword">restrict</span> oact)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>其中，参数<code>signo</code>是要检测或修改其具体动作的信号编号。若<code>act</code>指针非空，则要修改其动作。如果<code>oact</code>指针非空，则系统经由<code>oact</code>指针返回该信号的上一个动作。此函数使用下列结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> (*sa_handler)(<span class="type">int</span>); <span class="comment">/* addr of signal handler, */</span></span><br><span class="line">							<span class="comment">/* or SIG_IGN, or SIG_DFL */</span></span><br><span class="line">	<span class="type">sigset_t</span> sa_mask;</span><br><span class="line">							<span class="comment">/* additional signals to block */</span></span><br><span class="line">	<span class="type">int</span> sa_flags;           <span class="comment">/* signal options */</span></span><br><span class="line">				           <span class="comment">/* aiternate nandler */</span></span><br><span class="line">	<span class="type">void</span> (*sa_sigaction) (<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当更改信号动作时，如果<code>sa_handler</code>字段包含一个信号捕捉函数的地址(不是常量<code>SIG_IGN</code>或<code>SIG_DEL</code>)，则<code>sa_mask</code>字段说明了一个信号集，在调用该信号捕捉函数之前，这一信号集要加到进程的信号屏蔽字中。仅当从信号捕捉函数返回时再将进程的信号屏蔽字恢复为原先值。这样，在调用信号处理程序时就能用塞某些信号。在信号处理程序被调用时，操作系统建立的新信号屏蔽字包括正被递送的信号。因此保证了在处理一个给定的信号时，如果这种信号再次发生，那么它会被阻塞到对前一个信号的处理结束为止。若同一种信号多次发生，通常并不将它们加入队列，所以如果在某种信号被阻塞时，它发生了5次，那么对这种信号解除阻塞后，其信号处理函数通常只会被调用一次。一旦对给定的信号设置了一个动作，那么在调用<code>sigaction</code>显式地改变它之前，该设置就一直有效。这种处理方式与早期的不可靠信号机制不同，符合POSIX.1在这方面的要求。<code>act</code>结构的<code>sa_flags</code>字段指定对信号进行处理的各个选项。图中详细列出了这些选项的意义。若该标志已定义在基本POSIX.1标准中，那么SUS列包含“。”；若该标志定义在基本POSIX.1标准的XSI扩展中，那么该列包含“XSI”。<br><img src="/img/1622122627.jpg" alt=""></p>
<p><code>sa_sigaction</code>字段是一个替代的信号处理程序，在<code>sigaction</code>结构中使用<code>了SA_SIGINFO</code>标志时，使用该信号处理程序。对于<code>sa_sigaction</code>字段和<code>sa_handler</code>字段两者，实现可能使用同一存储区，所以应用只能一次使用这两个字段中的一个。</p>
<p>通常，按下列方式调用信号处理程序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> signo)</span>;</span><br></pre></td></tr></table></figure></p>
<p>但是，如果设置了SA_SIGINFO标志，那么按下列方式调用信号处理程序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> signo, <span class="type">siginfo_t</span> *info, <span class="type">void</span> *context)</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>siginfo</code>结构包含了信号产生原因的有关信息。该结构的大致样式如下所示。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">siginfo</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> 	si_signo;      	<span class="comment">/* signal number */</span></span><br><span class="line">	<span class="type">int</span> 	si_ezrno;       <span class="comment">/* if nonzero, errno value from &lt;errno.h&gt; */</span></span><br><span class="line">	<span class="type">int</span> 	si_code;        <span class="comment">/* additional into (depends on signal) */</span></span><br><span class="line">	<span class="type">pid_t</span> 	si_pid;         <span class="comment">/* sending process ID */</span></span><br><span class="line">	<span class="type">uid_t</span>  	si_uid;         <span class="comment">/* sending process real user ID */</span></span><br><span class="line">	<span class="type">void</span> 	*si_addr;       <span class="comment">/* address that caused the fault */</span></span><br><span class="line">	<span class="type">int</span>  	si_status;      <span class="comment">/* exit value or signal number */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">sigval</span> <span class="title">si_vaive</span>;</span> <span class="comment">/* application-specitic value */</span></span><br><span class="line">	<span class="comment">/* possibly other tields also */</span></span><br></pre></td></tr></table></figure></p>
<p><code>sigval</code>联合包含下列字段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sival_int;</span><br><span class="line"><span class="type">void</span> *sival_ptr;</span><br></pre></td></tr></table></figure></p>
<p>应用程序在递送信号时，在<code>si_value.sival_int</code>中传递一个整型数或者在<code>si_value.sival_ptr</code>中传递一个指针值。</p>
<p>图10-17示出了对于各种信号的<code>si_code</code>值， 这些信号是由Single UNIX Specification定义的。注意，实现可定义附加的代码值。<br><img src="/img/1622123793.jpg" alt=""></p>
<p>若信号是<code>SIGCHLD</code>，则将设置<code>si_pid.si_status</code>和<code>si_uid</code>字段。若信号是<code>SIGBUS</code>、<code>SIGILL</code>、<code>SIGFPE</code>或<code>SIGSEGV</code>，则<code>si_addr</code>包含造成故障的根源地址，该地址可能并不准确。<code>si_errno</code>字段包含错误编号，它对应于造成信号产生的条件，并由实现定义。</p>
<p>信号处理程序的<code>context</code>参数是无类型指针，它可被强制类型转换为<code>ucontext_t</code>结构类型，该结构标识信号传递时进程的上下文。该结构至少包含下列字段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ucontext_t</span> *uc_link;    <span class="comment">/* pointer to context resumed when */</span></span><br><span class="line">						<span class="comment">/*this context returns */</span></span><br><span class="line"><span class="type">sigset_t</span> uc_sigmask;    <span class="comment">/* signals blocked when this context */</span></span><br><span class="line">						<span class="comment">/*is active */</span></span><br><span class="line"><span class="type">stack_t</span> uc_stack;       <span class="comment">/* stack used by this context */</span></span><br><span class="line"><span class="type">mcontext_t</span> uc_mcontext;<span class="comment">/*machine-specitie representation of */</span></span><br><span class="line">						<span class="comment">/* saved context */</span></span><br></pre></td></tr></table></figure></p>
<p><code>uc_stack</code>字段描述了当前上下文使用的栈，至少包括下列成员：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *ss_sp;     <span class="comment">/* stack base or pointer */</span></span><br><span class="line"><span class="type">size_t</span> no_size;  <span class="comment">/*stack size */</span></span><br><span class="line"><span class="type">int</span> ss_flags;    <span class="comment">/* flags */</span></span><br></pre></td></tr></table></figure></p>
<p>当实现支持实时信号扩展时，用<code>SA_SIGINFO</code>标志建立的信号处理程序将造成信号可靠地排队。一些保留信号可由实时应用使用。如果信号由<code>sigqueue</code>函数产生，那么<code>siginfo</code>结构能包含应用特有的数据。</p>
<h2 id="函数sigsetjmp和sig1ongjmp"><a href="#函数sigsetjmp和sig1ongjmp" class="headerlink" title="函数sigsetjmp和sig1ongjmp"></a>函数sigsetjmp和sig1ongjmp</h2><p>在信号处理程序中经常调用<code>longjmp</code>函数以返回到程序的主循环中，而不是从该处理程序返回。但是，调用<code>longjmp</code>有一个问题。当捕捉到一 一个信号时，进入信号捕捉函数，此时当前信号被自动地加到进程的信号屏蔽字中。这阻止了后来产生的这种信号中断该信号处理程序。</p>
<p><code>setjmp</code>和<code>longjmp</code>保存和恢复信号屏蔽字。为了允许两种形式并存，POSIX.1并没有指定<code>setjmp</code>和<code>longjmp</code>对信号屏蔽字的作用，而是定义了两个新函数<code>sigsetjmp</code>和<code>siglongjmp</code>。在信号处理程序中进行非局部转移时应当使用这两个函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> savemask)</span>;</span><br><span class="line"><span class="comment">// 返回值：若直接调用，返回0：若从siq1ongjmp调用返回，则返回非0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> val)</span>;</span><br></pre></td></tr></table></figure></p>
<p>这两个函数和<code>setjmp</code>、<code>longjmp</code>之间的唯一区别是<code>sigsetjmp</code>增加了一个参数。如果<code>savemask</code>非0，则<code>sigsetjmp</code>在<code>env</code>中保存进程的当前信号屏蔽字。调用<code>siglongjmp</code>时，如果带非0 <code>savemask</code>的<code>sigsetjmp</code>调用已经保存了<code>env</code>，则<code>siglongjmp</code>从其中恢复保存的信号屏蔽字。</p>
<p>程序演示了在信号处理程序被调用时，系统所设置的信号屏蔽字如何自动地包括刚被捕捉到的信号。此程序也示例说明了如何使用<code>sigsetjmp</code>和<code>siglongjmp</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>						<span class="title function_">sig_usr1</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>						<span class="title function_">sig_alrm</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">static</span> sigjmp_buf				jmpbuf;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span>	canjump;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (signal(SIGUSR1, sig_usr1) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">&quot;signal(SIGUSR1) error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">&quot;signal(SIGALRM) error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	pr_mask(<span class="string">&quot;starting main: &quot;</span>);		<span class="comment">/* &#123;Prog prmask&#125; */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sigsetjmp(jmpbuf, <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">		pr_mask(<span class="string">&quot;ending main: &quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	canjump = <span class="number">1</span>;	<span class="comment">/* now sigsetjmp() is OK */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ( ; ; )</span><br><span class="line">		pause();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sig_usr1</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">time_t</span>	starttime;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (canjump == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;		<span class="comment">/* unexpected signal, ignore */</span></span><br><span class="line"></span><br><span class="line">	pr_mask(<span class="string">&quot;starting sig_usr1: &quot;</span>);</span><br><span class="line"></span><br><span class="line">	alarm(<span class="number">3</span>);				<span class="comment">/* SIGALRM in 3 seconds */</span></span><br><span class="line">	starttime = time(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">for</span> ( ; ; )				<span class="comment">/* busy wait for 5 seconds */</span></span><br><span class="line">		<span class="keyword">if</span> (time(<span class="literal">NULL</span>) &gt; starttime + <span class="number">5</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	pr_mask(<span class="string">&quot;finishing sig_usr1: &quot;</span>);</span><br><span class="line"></span><br><span class="line">	canjump = <span class="number">0</span>;</span><br><span class="line">	siglongjmp(jmpbuf, <span class="number">1</span>);	<span class="comment">/* jump back to main, don&#x27;t return */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sig_alrm</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">	pr_mask(<span class="string">&quot;in sig_alrm: &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此程序演示了另一种技术，只要在信号处理程序中调用<code>siglongjmp</code>就应使用这种技术。仅在调用<code>sigsetjmp</code>之后才将变量<code>canjump</code>设置为非0值。在信号处理程序中检测此变量，仅当它为非0值时才调用<code>siglongjmp</code>。这提供了一种保护机制，使得在<code>jmpbuf</code> (跳转缓冲)尚未由<code>sigsetjmp</code>初始化时，防止调用信号处理程序。(在本程序中，<code>sigiongjmp</code>之后程序很快就结束，但是在较大的程序中，在<code>siglongjmp</code>之后的较长一段时间内，信号处理程序可能仍旧被设置)。在一般的C代码中(不是信号处理程序)，对于<code>longjmp</code>并不需要这种保护措施。但是，因为信号可能在任何时候发生，所以在信号处理程序中，需要这种保护措施。</p>
<p>在程序中使用了数据类型<code>sig_atomic_t</code>，这是由ISO C标准定义的变量类型，在写这种类型变量时不会被中断。这意味着在具有虚拟存储器的系统上，这种变量不会跨越页边界。可以用一条机器指令对其进行访问。这种类型的变量总是包括ISO类型修饰符<code>volatile</code>，其原因是：该变量将由两个不同的控制线程一<code>main</code>函数和异步执行的信号处理程序访问。</p>
<p>可将图10-21分成三部分，左面部分(对应于<code>main</code>)，中间部分(<code>sig_usr1</code>)和右面部分(<code>sig_alrm</code>)。在进程执行左面部分时，信号屏蔽字是0(没有信号是阻塞的)。而执行中间部分时，其信号屏蔽字是<code>SIGUSR1</code>。执行右面部分时，信号屏蔽字是<code>SIGUSR1 | SIGALRM</code>。<br><img src="/img/20210528000140.png" alt=""></p>
<p>执行程序，得到下面的输出：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$./a.out &amp; 在后台启动进程</span><br><span class="line">starting main:</span><br><span class="line">[1]  531</span><br><span class="line">$ <span class="built_in">kill</span> -USR1  531 作业控制shell打印其进程ID</span><br><span class="line">starting sig_usr1: SIGUSR1  向该进程发送SIGUSRI</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">in</span> sig_alrm: SIGUSRI SIGALRM</span><br><span class="line">finishing sig_usr1 SIGUSR1</span><br><span class="line">ending main</span><br><span class="line"></span><br><span class="line">[1] +   Done     ./a.out &amp;</span><br></pre></td></tr></table></figure></p>
<p>该输出与我们所期望的相同：当调用一个信号处理程序时，被捕捉到的信号加到进程的当前信号屏蔽字中，当从信号处理程序返回时，恢复原来的屏蔽字。另外，<code>siglongjmp</code>恢复了由<code>sigsetjmp</code>所保存的信号屏蔽字。</p>
<p>如果在Limux中将图10-20程序中的<code>sigsetjmp</code>和<code>siglongjmp</code>分别替换成<code>setjmp</code>和<code>longjmp</code>，则最后一行输出变成：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ending main: SIGUSRI</span><br></pre></td></tr></table></figure></p>
<p>这意味着在调用<code>setjmp</code>之后执行<code>main</code>函数时，其<code>SIGUSR1</code>是阻塞的。这多半不是我们所希望的。</p>
<h2 id="函数sigsuspend"><a href="#函数sigsuspend" class="headerlink" title="函数sigsuspend"></a>函数sigsuspend</h2><p>上面已经说明，更改进程的信号屏蔽字可以阻塞所选择的信号，或解除对它们的阻塞。使用这种技术可以保护不希望由信号中断的代码临界区。</p>
<p>如果在信号阻塞时，产生了信号，那么该信号的传递就被推迟直到对它解除了阻塞。对应用程序而言，该信号好像发生在解除对<code>SIGINT</code>的阻塞和<code>pause</code>之间(取决于内核如何实现信号)。如果发生了这种情况，或者如果在解除阻塞时刻和pause之间确实发生了信号，那么就会产生问题。因为可能不会再见到该信号，所以从这种意义上讲，在此时间窗口中发生的信号丢失了，这样就使得pause永远阻塞。这是早期的不可靠信号机制的另一个问题。</p>
<p>为了纠正此问题。需要在一个原子操作中先恢复信号屏蔽字，然后使进程休眠。这种功能是由<code>sigsuspend</code>函数所提供的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *sigmask)</span>;</span><br><span class="line"><span class="comment">// 返回值。-1，并将errno设置为EINTR</span></span><br></pre></td></tr></table></figure></p>
<p>进程的信号屏蔽字设置为由<code>sigmask</code>指向的值。 在捕捉到一个信号或发生了一个会终止该进程的信号之前，该进程被挂起。如果捕捉到一个信号面且从该信号处理程序返回，则<code>sigsuspend</code>返回，并且该进程的信号屏蔽字设置为调用<code>sigsuspend</code>之前的值。</p>
<p>注意，此函数没有成功返回值。如果它返回到调用者，则总是返回-1，并将errno设置为EINTR(表示一个被中断的系统调用)。</p>
<p>下面的程序显示了保护代码临界区，使其不被特定信号中断的正确方法。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>	<span class="title function_">sig_int</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">sigset_t</span>	newmask, oldmask, waitmask;</span><br><span class="line"></span><br><span class="line">	pr_mask(<span class="string">&quot;program start: &quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (signal(SIGINT, sig_int) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">&quot;signal(SIGINT) error&quot;</span>);</span><br><span class="line">	sigemptyset(&amp;waitmask);</span><br><span class="line">	sigaddset(&amp;waitmask, SIGUSR1);</span><br><span class="line">	sigemptyset(&amp;newmask);</span><br><span class="line">	sigaddset(&amp;newmask, SIGINT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Block SIGINT and save current signal mask.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;SIG_BLOCK error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Critical region of code.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	pr_mask(<span class="string">&quot;in critical region: &quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Pause, allowing all signals except SIGUSR1.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (sigsuspend(&amp;waitmask) != <span class="number">-1</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;sigsuspend error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	pr_mask(<span class="string">&quot;after return from sigsuspend: &quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Reset signal mask which unblocks SIGINT.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;SIG_SETMASK error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * And continue processing ...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	pr_mask(<span class="string">&quot;program exit: &quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sig_int</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">	pr_mask(<span class="string">&quot;\nin sig_int: &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>注意，当<code>sigsuspend</code>返回时，它将信号屏蔽字设置为调用它之前的值。在本例中，<code>SIGINT</code>信号将被阻塞。因此将信号屏蔽恢复为之前保存的值(<code>oldmask</code>)。</p>
<p><code>sigsuspend</code>的另一种应用是等待一个信号处理程序设置一个全局变量。程序用于捕捉中断信号和退出信号，但是希望仅当捕捉到退出信号时，才唤醒主例程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span>	quitflag;	<span class="comment">/* set nonzero by signal handler */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sig_int</span><span class="params">(<span class="type">int</span> signo)</span>	<span class="comment">/* one signal handler for SIGINT and SIGQUIT */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (signo == SIGINT)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\ninterrupt\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (signo == SIGQUIT)</span><br><span class="line">		quitflag = <span class="number">1</span>;	<span class="comment">/* set flag for main loop */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">sigset_t</span>	newmask, oldmask, zeromask;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (signal(SIGINT, sig_int) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">&quot;signal(SIGINT) error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (signal(SIGQUIT, sig_int) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">&quot;signal(SIGQUIT) error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	sigemptyset(&amp;zeromask);</span><br><span class="line">	sigemptyset(&amp;newmask);</span><br><span class="line">	sigaddset(&amp;newmask, SIGQUIT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Block SIGQUIT and save current signal mask.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;SIG_BLOCK error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (quitflag == <span class="number">0</span>)</span><br><span class="line">		sigsuspend(&amp;zeromask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * SIGQUIT has been caught and is now blocked; do whatever.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	quitflag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Reset signal mask which unblocks SIGQUIT.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;SIG_SETMASK error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>此程序的样本输出是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">^C        键入中断字符</span><br><span class="line">interrupt </span><br><span class="line">^C        再次健入中断字符</span><br><span class="line">interrupt </span><br><span class="line">^C        再一次</span><br><span class="line">interrupt</span><br><span class="line">^\$       用退出符终止</span><br></pre></td></tr></table></figure></p>
<p>可以用信号实现父、子进程之间的同步，这是信号应用的另一个实例。给出了<code>TELLWAIT</code>、<code>TELL_PARENT</code>、<code>TELL_CHILD</code>、<code>WAIT_PARENT</code>和<code>WAIT_CHILD</code>5个例程的实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> sigflag; <span class="comment">/* set nonzero by sig handler */</span></span><br><span class="line"><span class="type">static</span> <span class="type">sigset_t</span> newmask, oldmask, zeromask;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sig_usr</span><span class="params">(<span class="type">int</span> signo)</span>	<span class="comment">/* one signal handler for SIGUSR1 and SIGUSR2 */</span></span><br><span class="line">&#123;</span><br><span class="line">	sigflag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">TELL_WAIT</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (signal(SIGUSR1, sig_usr) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">&quot;signal(SIGUSR1) error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (signal(SIGUSR2, sig_usr) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">&quot;signal(SIGUSR2) error&quot;</span>);</span><br><span class="line">	sigemptyset(&amp;zeromask);</span><br><span class="line">	sigemptyset(&amp;newmask);</span><br><span class="line">	sigaddset(&amp;newmask, SIGUSR1);</span><br><span class="line">	sigaddset(&amp;newmask, SIGUSR2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Block SIGUSR1 and SIGUSR2, and save current signal mask */</span></span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;SIG_BLOCK error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">TELL_PARENT</span><span class="params">(<span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">	kill(pid, SIGUSR2);		<span class="comment">/* tell parent we&#x27;re done */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">WAIT_PARENT</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (sigflag == <span class="number">0</span>)</span><br><span class="line">		sigsuspend(&amp;zeromask);	<span class="comment">/* and wait for parent */</span></span><br><span class="line">	sigflag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reset signal mask to original value */</span></span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;SIG_SETMASK error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">TELL_CHILD</span><span class="params">(<span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">	kill(pid, SIGUSR1);			<span class="comment">/* tell child we&#x27;re done */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">WAIT_CHILD</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (sigflag == <span class="number">0</span>)</span><br><span class="line">		sigsuspend(&amp;zeromask);	<span class="comment">/* and wait for child */</span></span><br><span class="line">	sigflag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reset signal mask to original value */</span></span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;SIG_SETMASK error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中使用了两个用户定义的信号：<code>SIGUSR1</code>由父进程发送给子进程，<code>SIGUSR2</code>由子进程发送给父进程。</p>
<p>如果在等待信号发生时希望去休眠，则使用<code>sigsuspend</code>函数是非常适当的。</p>
<h2 id="函数abort"><a href="#函数abort" class="headerlink" title="函数abort"></a>函数abort</h2><p>前面已提及<code>abort</code>函数的功能是使程序异常终止。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 此函数不返回值</span></span><br></pre></td></tr></table></figure></p>
<p>此函数将<code>SIGABRT</code>信号发送给调用进程(进程不应忽略此信号)。ISO C规定，调用<code>abort</code>将向主机环境递送一个未成功终止的通知，其方法是调用<code>raise(SIGABRT)</code>函数。ISO C要求若捕捉到此信号而且相应信号处理程序返回，<code>abort</code>仍不会返回到其调用者。如果捕捉到此信号，则信号处理程序不能返回的唯一方法是它调用<code>exit</code>、<code>_exit</code>、<code>_Exit</code>、<code>longjmp</code>、<code>siglongjmp</code>。</p>
<p>让进程捕捉<code>SIGABRT</code>的意图是：在进程终止之前由其执行所需的清理操作。如果进程并不在信号处理程序中终止自己，POSIX.1声明当信号处理程序返回时，<code>abort</code>终止该进程。POSIX.1的要求是：如果<code>abort</code>调用终止进程，则它对所有打开标准I/O流的效果应当与进程终止前对每个流调用<code>fclose</code>相同。</p>
<p><code>abort</code>函数是按POSIX.1说明实现的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>			<span class="comment">/* POSIX-style abort() function */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">sigset_t</span>			mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>	<span class="title">action</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Caller can&#x27;t ignore SIGABRT, if so reset to default */</span></span><br><span class="line">	sigaction(SIGABRT, <span class="literal">NULL</span>, &amp;action);</span><br><span class="line">	<span class="keyword">if</span> (action.sa_handler == SIG_IGN) &#123;</span><br><span class="line">		action.sa_handler = SIG_DFL;</span><br><span class="line">		sigaction(SIGABRT, &amp;action, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (action.sa_handler == SIG_DFL)</span><br><span class="line">		fflush(<span class="literal">NULL</span>);			<span class="comment">/* flush all open stdio streams */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Caller can&#x27;t block SIGABRT; make sure it&#x27;s unblocked */</span></span><br><span class="line">	sigfillset(&amp;mask);</span><br><span class="line">	sigdelset(&amp;mask, SIGABRT);	<span class="comment">/* mask has only SIGABRT turned off */</span></span><br><span class="line">	sigprocmask(SIG_SETMASK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line">	kill(getpid(), SIGABRT);	<span class="comment">/* send the signal */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If we&#x27;re here, process caught SIGABRT and returned */</span></span><br><span class="line">	fflush(<span class="literal">NULL</span>);				<span class="comment">/* flush all open stdio streams */</span></span><br><span class="line">	action.sa_handler = SIG_DFL;</span><br><span class="line">	sigaction(SIGABRT, &amp;action, <span class="literal">NULL</span>);	<span class="comment">/* reset to default */</span></span><br><span class="line">	sigprocmask(SIG_SETMASK, &amp;mask, <span class="literal">NULL</span>);	<span class="comment">/* just in case ... */</span></span><br><span class="line">	kill(getpid(), SIGABRT);				<span class="comment">/* and one more time */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);	<span class="comment">/* this should never be executed ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先查看是否将执行默认动作，若是则冲洗所有标准I/O流。这并不等价于对所有打开的流调用<code>fclose</code>(因为只冲洗，并不关闭它们)，但是当进程终止时，系统会关闭所有打开的文件。如果进程捕捉此信号并返回，那么因为进程可能产生了更多的输出，所以再一次冲洗所有的流。不进行冲洗处理的唯一条件是如果进程捕捉此信号，然后调用<code>_exit</code>或<code>_Exit</code>。在这种情况下，任何来冲洗的内存中的标准I/O缓存都被丢弃。我们假定捕捉此信号，而且<code>_exit</code>或<code>_Exit</code>的调用者并不想要冲洗缓冲区。我们阻塞除<code>SIGABRT</code>外的所有信号，这样就可知如果对<code>kill</code>的调用返回了，则该进程一定已捕捉到该信号，并且也从该信号处理程序返回。</p>
<h2 id="函数system-1"><a href="#函数system-1" class="headerlink" title="函数system"></a>函数system</h2><p>POSIX.1要求<code>system</code>忽略<code>SIGINT</code>和<code>SIGQUIT</code>，阻塞<code>SIGCHLD</code>。在给出一个正确地处理这些信号的一个版本之前，先说明为什么要考虑信号处理。</p>
<p>程序是<code>system</code>函数的另一个实现，它进行了所要求的信号处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmdstring)</span>	<span class="comment">/* with appropriate signal handling */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span>				pid;</span><br><span class="line">	<span class="type">int</span>					status;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>	<span class="title">ignore</span>, <span class="title">saveintr</span>, <span class="title">savequit</span>;</span></span><br><span class="line">	<span class="type">sigset_t</span>			chldmask, savemask;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cmdstring == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">1</span>);		<span class="comment">/* always a command processor with UNIX */</span></span><br><span class="line"></span><br><span class="line">	ignore.sa_handler = SIG_IGN;	<span class="comment">/* ignore SIGINT and SIGQUIT */</span></span><br><span class="line">	sigemptyset(&amp;ignore.sa_mask);</span><br><span class="line">	ignore.sa_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (sigaction(SIGINT, &amp;ignore, &amp;saveintr) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (sigaction(SIGQUIT, &amp;ignore, &amp;savequit) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	sigemptyset(&amp;chldmask);			<span class="comment">/* now block SIGCHLD */</span></span><br><span class="line">	sigaddset(&amp;chldmask, SIGCHLD);</span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;chldmask, &amp;savemask) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		status = <span class="number">-1</span>;	<span class="comment">/* probably out of processes */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;			<span class="comment">/* child */</span></span><br><span class="line">		<span class="comment">/* restore previous signal actions &amp; reset signal mask */</span></span><br><span class="line">		sigaction(SIGINT, &amp;saveintr, <span class="literal">NULL</span>);</span><br><span class="line">		sigaction(SIGQUIT, &amp;savequit, <span class="literal">NULL</span>);</span><br><span class="line">		sigprocmask(SIG_SETMASK, &amp;savemask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmdstring, (<span class="type">char</span> *)<span class="number">0</span>);</span><br><span class="line">		_exit(<span class="number">127</span>);		<span class="comment">/* exec error */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;						<span class="comment">/* parent */</span></span><br><span class="line">		<span class="keyword">while</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">if</span> (errno != EINTR) &#123;</span><br><span class="line">				status = <span class="number">-1</span>; <span class="comment">/* error other than EINTR from waitpid() */</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* restore previous signal actions &amp; reset signal mask */</span></span><br><span class="line">	<span class="keyword">if</span> (sigaction(SIGINT, &amp;saveintr, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (sigaction(SIGQUIT, &amp;savequit, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;savemask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="system的返回值"><a href="#system的返回值" class="headerlink" title="system的返回值"></a>system的返回值</h3><p>注意<code>system</code>的返回值，它是shell的终止状态，但shell的终止状态并不总是执行命令字符串进程的终止状态。如果执行一条如<code>date</code>那样的简单命令，其终止状态是0。执行shell命令<code>exit 44</code>，则得终止状态44。在信号方面又如何呢?</p>
<p>Bourne shell有一个在其文档中没有说清楚的特性，其终止状态是128加上一个信号编号，该信号终止了正在执行的命令。用交互方式使用shell可以看到这一点。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sh       确保运行Bourneshell</span><br><span class="line">$ sh -c <span class="string">&quot;sleep 30&quot;</span> </span><br><span class="line">^C         键入中断符</span><br><span class="line">$ <span class="built_in">echo</span> $?  打印最后一条命令的终止状态</span><br><span class="line">130</span><br><span class="line">$ sh -c <span class="string">&quot;sleep 30&quot;</span> </span><br><span class="line">^\sh: 962 Quit - core dumped    键入退出符</span><br><span class="line">$ <span class="built_in">echo</span> $?   打印最后一条命令的终止状态</span><br><span class="line">131</span><br><span class="line">$ <span class="built_in">exit</span>      离开Bourne shell</span><br></pre></td></tr></table></figure></p>
<p>在所使用的系统中，<code>SIGINT</code>的值为2，<code>SIGQUIT</code>的值为3，于是给出shell终止状态130、131。</p>
<h2 id="函数sleep、nanosleep和clock-nanosleep"><a href="#函数sleep、nanosleep和clock-nanosleep" class="headerlink" title="函数sleep、nanosleep和clock_nanosleep"></a>函数sleep、nanosleep和clock_nanosleep</h2><p>两个sleep的实现都是有缺陷的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line"><span class="comment">// 返回值：0或未休眠完的秒数</span></span><br></pre></td></tr></table></figure></p>
<p>此函数使调用进程被挂起直到满足下面两个条件之一。</p>
<ol>
<li>已经过了seconds所指定的墙上时钟时间。</li>
<li>调用进程捕捉到一个信号并从信号处理程序返回。</li>
</ol>
<p>如同<code>alarm</code>信号一样，由于其他系统活动，实际返回时间比所要求的会迟一些。在第1种情形，返回值是0。当由于捕捉到某个信号sleep提早返回时(第2种情形)，返回值是未休眠完的秒数(所要求的时间减去实际休眠时间)。</p>
<p>尽管<code>sleep</code>可以用<code>alarm</code>函数实现，但这并不是必需的。如果使用<code>alarm</code>，则这两个函数之间可能相互影响。</p>
<p>给出的是一个POSIX.1 <code>sleep</code>函数的实现，它可靠地处理信号，避免了早期实现中的竞争条件，但是仍未处理与以前设置的闹钟的交互作用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">&quot;apue.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sig_alrm</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* nothing to do, just returning wakes up sigsuspend() */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>    <span class="title">newact</span>, <span class="title">oldact</span>;</span></span><br><span class="line">    <span class="type">sigset_t</span>            newmask, oldmask, suspmask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        unslept;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set our handler, save previous information */</span></span><br><span class="line">    newact.sa_handler = sig_alrm;</span><br><span class="line">    sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">    newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIGALRM, &amp;newact, &amp;oldact);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* block SIGALRM and save current signal mask */</span></span><br><span class="line">    sigemptyset(&amp;newmask);</span><br><span class="line">    sigaddset(&amp;newmask, SIGALRM);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);</span><br><span class="line"></span><br><span class="line">    alarm(seconds);</span><br><span class="line">    suspmask = oldmask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* make sure SIGALRM isn&#x27;t blocked */</span></span><br><span class="line">    sigdelset(&amp;suspmask, SIGALRM);</span><br><span class="line">    <span class="comment">/* wait for any signal to be caught */</span></span><br><span class="line">    sigsuspend(&amp;suspmask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* some signal has been caught, SIGALRM is now blocked */</span></span><br><span class="line"></span><br><span class="line">    unslept = alarm(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset previous action */</span></span><br><span class="line">    sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset signal mask, which unblocks SIGALRM */</span></span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>(unslept);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序中没有使用任何形式的非局部转移，所以对处理<code>SIGALRM</code>信号期间可能执行的其他信号处理程序没有任何影响。<code>nanosleep</code>函数与<code>sleep</code>函数类似，但提供了纳秒级的精度。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">nanosleep</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> timespec *reqtp, <span class="keyword">struct</span> timespec *remp)</span>;</span><br><span class="line"><span class="comment">// 返回值，若休眠到要求的时间，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>这个函数挂起调用进程，直到要求的时间已经超时或者某个信号中断了该函数。<code>reqtp</code>参数用秒和纳秒指定了需要休眠的时间长度。如果某个信号中断了休眠间隔，进程并没有终止，<code>remtp</code>参数指向的<code>timespec</code>结构就会被设置为未休眠完的时间长度。如果对未休眠完的时间并不感兴趣，可以把该参数置为NULL，如果系统并不支持纳秒这一精度，要求的时间就会取整。因为<code>nanosleep</code>函数并不涉及产生任何信号，所以不需要担心与其他函数的交互。</p>
<p>随着多个系统时钟的引入，需要使用相对于特定时钟的延迟时间来挂起调用线程。<code>clock_nanosleep</code>函数提供了这种功能，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_nanosleep</span> <span class="params">(<span class="type">clockid_t</span> clock_id, <span class="type">int</span> flag, <span class="type">const</span> <span class="keyword">struct</span> tinespec *reqtp, <span class="keyword">struct</span> timespec *remtp)</span>;</span><br><span class="line"><span class="comment">// 返回值：若休眠要求的时间，返回0；若出错，返回错误码</span></span><br></pre></td></tr></table></figure></p>
<p><code>clook_id</code>参数指定了计算延迟时间基于的时钟。<code>flags</code>参数用于控制延迟是相对的还是绝对的。<code>flags</code>为0时表示休眠时间是相对的，如果<code>flags</code>值设置为<code>TIMER_ABSTIME</code>，表示休眠时间是绝对的。其他的参数<code>reqtp</code>和<code>remtp</code>，与<code>nanosleep</code>函数中的相同。在时钟到达指定的绝对时间值以前，可以为其他的<code>clock_nanosleep</code>调用复用<code>reqtp</code>参数相同的值。</p>
<p>注意，除了出错返回，调用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clock_nanosleep (CLOCK_REALTIME, <span class="number">0</span>, reqtp, remtp);</span><br></pre></td></tr></table></figure><br>和调用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nanosleep (reqtp, remtp);</span><br></pre></td></tr></table></figure><br>的效果是相同的。使用相对休眠的问题是有些应用对休眠长度有精度要求，相对休眠时间会导致实际休眠时间比要求的长。例如，某个应用程序希望按固定的时间间隔执行任务，就必须获取当前时间，计算下次执行任务的时间，然后调用<code>nanosleep</code>。在获取当前时间和调用<code>nanosleep</code>之间，处理器调度和抢占可能会导致相对休眠时间超过实际需要的时间间隔。即便分时进程调度程序对休眠时间结束后是否会马上执行用户任务并没有给出保证，使用绝对时间还是改善了精度。</p>
<h2 id="函数sigqueue"><a href="#函数sigqueue" class="headerlink" title="函数sigqueue"></a>函数sigqueue</h2><p>通常一个信号带有一个位信息：信号本身。除了对信号排队以外，这些扩展允许应用程序在递交信号时传递更多的信息。这些信息嵌入在<code>siginfo</code>结构中。除了系统提供的信息，应用程序还可以向信号处理程序传递整数或者指向包含更多信息的缓冲区指针。使用排队信号必须做以下几个操作。</p>
<ol>
<li>使用<code>sigaction</code>函数安装信号处理程序时指定<code>SA_SIGINFO</code>标志，如果没有给出这个标志，信号会延迟，但信号是否进入队列要取决于具体实现。</li>
<li>在<code>sigaction</code>结构的<code>sa_sigaction</code>成员中(而不是通常的<code>sa_handler</code>字段)提供信号处理程序。实现可能允许用户使用<code>sa_handler</code>字段，但不能获取<code>sigqueue</code>函数发送出来的额外信息。</li>
<li>使用<code>sigqueue</code>函数发送信号。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;aigna1.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigqueue</span> <span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> signo, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>sigqueue</code>函数只能把信号发送给单个进程，可以使用<code>value</code>参数向信号处理程序传递整数和指针值，除此之外，<code>sigqueue</code>函数与<code>kill</code>函数类似。</p>
<p>信号不能被无限排队。回忆<code>SIGQUEUE_MAX</code>限制。到达相应的限制以后，<code>sigqueue</code>就会失败，将errno设为EAGAIN，随着实时信号的增强，引入了用于应用程序的独立信号集。这些信号的编号在<code>SIGRTMIN</code>~<code>SIGRTMAX</code>之间，包括这两个限制值。注意，这些信号的默认行为是终止进程。</p>
<h2 id="作业控制信号"><a href="#作业控制信号" class="headerlink" title="作业控制信号"></a>作业控制信号</h2><p>POSIX.1认为有以下6个与作业控制有关。</p>
<ul>
<li><code>SIGCHLD</code>：子进程已停止或终止。</li>
<li><code>SIGCONT</code>：如果进程已停止，则使其继续运行。</li>
<li><code>SIGSTOP</code>：停止信号(不能被捕捉或忽略)。</li>
<li><code>SIGTSTP</code>：交互式停止信号。</li>
<li><code>SIGTTIN</code>：后台进程组成员读控制终端。</li>
<li><code>SIGTTOU</code>：后台进程组成员写控制终端。</li>
</ul>
<p>除<code>SIGCHLD</code>以外，大多数应用程序并不处理这些信号，交互式shell则通常会处理这些信号的所有工作。当键入挂起字符(通常是Ctrl+Z)时，<code>SIGTSTP</code>被送至前台进程组的所有进程。当我们通知shell在前台或后台恢复运行一个作业时，shell向该作业中的所有进程发送<code>SIGCONT</code>信号。与此类似。如果向一个进程递送了<code>SIGTTIN</code>或<code>SIGTTOU</code>信号，则根据系统默认的方式，停止此进程，作业控制shell了解到这一点后就通知我们。</p>
<p>一个例外是管理终端的进程，例如，<code>vi(1)</code>编辑器。当用户要挂起它时，它需要能了解到这一点。这样就能将终端状态恢复到vi启动时的情况。另外，当在前台恢复它时，它需要将终端状态设置回它所希望的状态，并需要重新绘制终端屏幕。</p>
<p>在作业控制信号间有某些交互。当对一个进程产生4种停止信号(<code>SIGTSTP</code>、<code>SIGSTOP</code>、<code>SIGTTIN</code>或<code>SIGTTOU</code>)中的任意一种时，对该进程的任一未决<code>SIGCONT</code>信号就被丢弃。与此类似，当对一个进程产生<code>SIGCONT</code>信号时，对同一进程的任一未决停止信号被丢弃。</p>
<p>注意，如果进程是停止的，则<code>SIGCONT</code>的默认动作是继续该进程：否则忽略此信号。通常，对该信号无需做任何事情。当对一个停止的进程产生一个<code>SIGCONT</code>信号时，该进程就继续，即使该信号是被阻塞或忽略的也是如此。</p>
<p>程序演示了当一个程序处理作业控制时通常所使用的规范代码序列。该程序只是将其标准输入复制到其标准输出，而在信号处理程序中以注释形式给出了管理屏幕的程序所执行的典型操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	BUFFSIZE	1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sig_tstp</span><span class="params">(<span class="type">int</span> signo)</span>	<span class="comment">/* signal handler for SIGTSTP */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">sigset_t</span>	mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ... move cursor to lower left corner, reset tty mode ... */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Unblock SIGTSTP, since it&#x27;s blocked while we&#x27;re handling it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sigemptyset(&amp;mask);</span><br><span class="line">	sigaddset(&amp;mask, SIGTSTP);</span><br><span class="line">	sigprocmask(SIG_UNBLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	signal(SIGTSTP, SIG_DFL);	<span class="comment">/* reset disposition to default */</span></span><br><span class="line"></span><br><span class="line">	kill(getpid(), SIGTSTP);	<span class="comment">/* and send the signal to ourself */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we won&#x27;t return from the kill until we&#x27;re continued */</span></span><br><span class="line"></span><br><span class="line">	signal(SIGTSTP, sig_tstp);	<span class="comment">/* reestablish signal handler */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ... reset tty mode, redraw screen ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		n;</span><br><span class="line">	<span class="type">char</span>	buf[BUFFSIZE];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Only catch SIGTSTP if we&#x27;re running with a job-control shell.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (signal(SIGTSTP, SIG_IGN) == SIG_DFL)</span><br><span class="line">		signal(SIGTSTP, sig_tstp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (write(STDOUT_FILENO, buf, n) != n)</span><br><span class="line">			err_sys(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当程序启动时，仅当<code>SIGTSTP</code>信号的配置是<code>SIG_DFL</code>，它才安排捕捉该信号。其理由是：当此程序由不支持作业控制的shell (如<code>/bin/sh</code>)启动时，此信号的配置应当设置为<code>SIG_IGN</code>。实际上，shell并不显式地忽略此信号， 而是由<code>init</code>将这3个作业控制信号<code>SIGTSTP</code>、<code>SIGTTIN</code>和<code>SIGTTOU</code>设置为<code>SIG_IGN</code>。然后，这种配置由所有登录shell继承。只有作业控制shell才应将这3个信号重新设置为<code>SIG_DFL</code>。</p>
<p>当键入挂起字符时，进程接到<code>SIGTSTP</code>信号，然后调用该信号处理程序。此时，应当进行与终端有关的处理：将光标移到左下角、恢复终端工作方式等。在将<code>SIGTSTP</code>重置为默认值(停止该进程)，并且解除了对此信号的阻塞之后，进程向自己发送同一信号<code>SIGTSTP</code>。因为正在处理<code>SIGTSTP</code>信号，而在捕捉该信号期间系统自动地阻塞它，所以应当解除对此信号的阻塞。到达这一点时，系统停止该进程。仅当某个进程向该进程发送一个<code>SIGCONT</code>信号时，该进程才继续。我们不捕捉<code>SIGCONT</code>信号。该信号的默认配置是继续运行停止的进程，当此发生时，此程序如同从kill函数返回一样继续运行。当此程序继续运行时，将<code>SIGTSTP</code>信号重置为捕捉，并且做我们所希望做的终端处理。</p>
<h2 id="信号名和编号"><a href="#信号名和编号" class="headerlink" title="信号名和编号"></a>信号名和编号</h2><p>本节介绍如何在信号编号和信号名之间进行映射。某些系统提供数组<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *sys_siglist[]:</span><br></pre></td></tr></table></figure><br>数组下标是信号编号，数组中的元素是指向信号名符串的指针。</p>
<p>可以使用<code>psignal</code>函数可移植地打印与信号编号对应的字符串。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">psignal</span><span class="params">(<span class="type">int</span> signo, <span class="type">const</span> <span class="type">char</span> *msg)</span>:</span><br></pre></td></tr></table></figure></p>
<p>字符串<code>msg</code>(通常是程序名)输出到标准错误文件，后面跟随一个冒号和一个空格，再后面对该信号的说明，最后是一个换行符。如果<code>msg</code>为NULL，只有信号说明部分输出到标准错误文件。</p>
<p>如果在<code>sigaction</code>信号处理程序中有<code>siginfo</code>结构，可以使用<code>psiginfo</code>函数打印信号信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">psiginfo</span><span class="params">(<span class="type">const</span> <span class="type">siginfo_t</span> *info, <span class="type">const</span> <span class="type">char</span> *msg)</span>;</span><br></pre></td></tr></table></figure></p>
<p>它的工作方式与<code>psignal</code>函数类似。虽然这个函数访问除信号编号以外的更多信息，但不同的平台输出的这些额外信息可能有所不同。</p>
<p>如果只需要信号的字符描述部分，也不需要把它写到标准错误文件中(如可以写到日志文件中)，可以使用<code>strsignal</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strsignal</span><span class="params">(<span class="type">int</span> signo)</span>;</span><br><span class="line"><span class="comment">// 返回值：指向描述该信号的字符串的指针</span></span><br></pre></td></tr></table></figure></p>
<p>给出一个信号编号，<code>strsignal</code>将返回描述该信号的字符串。应用程序可用该字符串打印关于接收到信号的出错信息。</p>
<p>Solaris提供一对函数，一个函数将信号编号映射为信号名，另一个则反之。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sig2str</span><span class="params">(<span class="type">int</span> signo, <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">str2sig</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> *signop)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>在编写交互式程序，其中需接收和打印信号名和信号编号时，这两个函数是有用的。</p>
<p><code>sig2str</code>函数将给定信号编号翻译成字符串，并将结果存放在str指向的存储区。调用者必须保证该存储区足够大，可以保存最长字符串，包括终止null字节。Solaris在<code>&lt;signal.h&gt;</code>中包含了常量<code>SIG2STR_MAX</code>，它定义了最大字符串长度。该字符串包括不带“SIG”前缀的信号名。例如，SIGKILL被翻译为字符串“KILL”，并存放在str指向的存储缓冲区中。</p>
<p><code>str2sig</code>函数将给出的信号名翻译成信号编号，该信号编号存放在<code>signop</code>指向的整型中。名字要么是不带“SIG”前缀的信号名，要么是表示十进制信号编号的字符串(如“9”)。注意，<code>sig2str</code>和<code>str2sig</code>与常用的函数做法不同，当它们失败时，并不设置errno。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p>典型的UNIX进程可以看成只有一个控制线程：一个进程在某一时刻只能做一件事情。每个线程处理各自独立的任务有很多好处，通过为每种事件类型分配单独的处理线程，可以简化处理异步事件的代码。每个线程在进行事件处理时可以采用同步编程模式，同步编程模式要比异步编程模式简单得多。</p>
<p>多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享，而多个线程自动地可以访问相同的存储地址空间和文件播述符。</p>
<p>每个线程都包含有表示执行环境所必需的信息，其中包括进程中标识线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量以及线程私有数据。一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符。线程接口也称为“pthread”或“POSIX线程”。</p>
<p>POSIX线程的功能测试宏是<code>_POSTX_THREADS</code>。应用程序可以把这一个宏用于<code>#ifdef</code>测试，从而在编译时确定是否支持线程：也可以把<code>_SC_THREADS</code>常数用于调用<code>sysconf</code>函数，进而在运行时确定是否支持线程。</p>
<h2 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h2><p>就像每个进程有一个进程ID一样，每个线程也有一个线程ID。进程ID在整个系统中是唯一的，但线程ID不同，线程ID只有在它所属的进程上下文中才有意义。进程ID是用<code>pid_t</code>数据类型来表示的，是一个非负整数。线程ID是用<code>pthread_t</code>数据类型来表示的，实现的时候可以用一个结构来代表<code>pthread_t</code>数据类型，所以可移植的操作系统实现不能把它作为整数处理。因此必须使用一个函数来对两个线程ID进行比较。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span> <span class="params">(<span class="type">pthread_t</span> tid1, <span class="type">pthread_t</span> tid2)</span>;</span><br><span class="line"><span class="comment">// 返回值。若相等，返回非0数值；否则，返回0</span></span><br></pre></td></tr></table></figure></p>
<p>用结构表示<code>pthread_t</code>数据类型的后果是不能用一种可移植的方式打印该数据类型的值。在程序调试过程中打印线程ID有时是非常有用的， 而在其他情况下通常不需要打印线程ID。</p>
<p>线程可以通过调用<code>pthread_self</code>函数获得自身的线程ID。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthzead_self</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回值，调用线程的线程ID</span></span><br></pre></td></tr></table></figure></p>
<p>当线程需要识别以线程ID作为标识的数据结构时，<code>pthread_self</code>函数可以与<code>pthread_equal</code>函数一起使用。例如，主线程可能把工作任务放在一个队列中，用线程ID来控制每个工作线程处理哪些作业。主线程把新的作业放到一个工作队列中，由3个工作线程组成的线程池从队列中移出作业。主线程不允许每个线程任意处理从队列顶端取出的作业，而是由主线程控制作业的分配，主线程会在每个待处理作业的结构中放置处理该作业的线程ID，每个工作线程只能移出标有自己线程ID的作业。</p>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>在传统UNIX进程模型中，每个进程只有一个控制线程。从概念上讲，这与基于线程的模型中每个进程只包含一个线程是相同的。在POSIX线程(pthread)的情况下，程序开始运行时，它也是以单进程中的单个控制线程启动的。在创建多个控制线程以前，程序的行为与传统的进程并没有什么区别。新增的线程可以通过调用<code>pthread_create</code>函数创建。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span> <span class="params">(<span class="type">pthread_t</span> *<span class="keyword">restrict</span> tidp, <span class="type">const</span> <span class="type">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span><br><span class="line"><span class="params"><span class="type">void</span> *(*start_rtn) (<span class="type">void</span> *), <span class="type">void</span> *<span class="keyword">restrict</span> arg)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>当<code>pthread_create</code>成功返回时， 新创建线程的线程ID会被设置成<code>tidp</code>指向的内存单元。<code>attr</code>参数用于定制各种不同的线程属性。新创建的线程从<code>start_rtn</code>函数的地址开始运行， 该函数只有一个无类型指针参数<code>arg</code>。如果需要向<code>start_rtn</code>函数传递的参数有一个以上，那么需要把这些参数放到一个结构中，然后把这个结构的地址作为<code>arg</code>参数传入。</p>
<p>线程创建时并不能保证哪个线程会先运行，是新创建的线程，还是调用线程。新创建的线程可以访问进程的地址空间，并且继承调用线程的浮点环境和信号屏蔽字，但是该线程的挂起信号集会被清除。</p>
<p>注意，phread函数在调用失败时通常会返回错误码，它们并不像其他的POSIX函数—样设置errno。每个线程都提供errno的副本，这只是为了与使用errno的现有函数兼容。在线程中，从函数中返回错误码更为清晰整洁，不需要依赖那些随着函数执行不断变化的全局状态，这样可以把错误的范围限制在引起出错的函数中。</p>
<p>可以写一个小的测试程序来完成打印线程ID任务。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> ntid;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">printids</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">pid_t</span>           pid;</span><br><span class="line">        <span class="type">pthread_t</span>       tid;</span><br><span class="line"></span><br><span class="line">        pid = getpid();</span><br><span class="line">        tid = pthread_self();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s pid %lu tid %lu (0x%lx)\n&quot;</span>, s, (<span class="type">unsigned</span> <span class="type">long</span>)pid,</span><br><span class="line">          (<span class="type">unsigned</span> <span class="type">long</span>)tid, (<span class="type">unsigned</span> <span class="type">long</span>)tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">thr_fn</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        printids(<span class="string">&quot;new thread: &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>((<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">        err = pthread_create(&amp;ntid, <span class="literal">NULL</span>, thr_fn, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">            err_exit(err, <span class="string">&quot;can&#x27;t create thread&quot;</span>);</span><br><span class="line">        printids(<span class="string">&quot;main thread:&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个实例有两个特别之处，需要处理主线程和新线程之间的竞争。第一个特别之处在于，主线程需要休眠，如果主线程不休眼，它就可能会退出，这样新线程还没有机会运行，整个进程可能就已经终止了，这种行为特征依赖于操作系统中的线程实现和调度算法。</p>
<p>第二个特别之处在于新线程是通过调用<code>pthread_self</code>函数获取自己的线程ID的，而不是从共享内存中读出的，或者从线程的启动例程中以参数的形式接收到的。<code>pthread_create</code>函数会通过第一个参数(<code>tidp</code>)返回新建线程的线程ID。在这个例子中，主线程把新线程ID存放在<code>ntid</code>中，但是新建的线程并不能安全地使用它，如果新线程在主线程调用<code>pthread_create</code>返回之前就运行了，那么新线程看到的是未经初始化的<code>ntid</code>的内容，这个内容并不是正确的线程ID。</p>
<p>运行程序，得到：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">main thread: pid 20075 tid 1 (0x1)</span><br><span class="line">new thread: p1d 20075 tid 2 (0x2)</span><br></pre></td></tr></table></figure></p>
<p>正如我们期望的，两个线程的进程ID相同，但线程ID不同。在FreeBSD上运行程序，得到：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">main thread: pid 37396 tid 673190208 (0x28201140)</span><br><span class="line">new thread: pid 37396 tid 673200320 (0x28217140)</span><br></pre></td></tr></table></figure></p>
<p>也如我们期望的，两个线程有相同的进程ID。把它们转化成十六进制，就像前面提到的，FreeBSD使用指向线程数据结构的指针作为它的线程ID。</p>
<h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>如果进程中的任意线程调用了<code>exit</code>、<code>_Exit</code>或者<code>_exit</code>，那么整个进程就会终止。与此相类似，如果默认的动作是终止进程，那么，发送到线程的信号就会终止整个进程。</p>
<p>单个线程可以通过3种方式退出，因此可以在不终止整个进程的情况下，停止它的控制流。</p>
<ol>
<li>线程可以简单地从启动例程中返回，返回值是线程的退出码。</li>
<li>线程可以被同一进程中的其他线程取消。</li>
<li>线程调用<code>pthread_exit</code>。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span> <span class="params">(<span class="type">void</span> *rval_ptr)</span>:</span><br></pre></td></tr></table></figure>
<p><code>rval_ptr</code>参数是一个无类型指针，与传给启动例程的单个参数类似。进程中的其他线程也可以通过调用<code>pthread_join</code>函数访问到这个指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span> <span class="params">(<span class="type">pthread_t</span> thread_void **rval_ptr)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>调用线程将一直阻塞，直到指定的线程调用<code>pthread_exit</code>。从启动例程中返回或者被取消。如果线程简单地从它的启动例程返回，<code>rval_ptr</code>就包含返回码。如果线程被取消，由<code>rval_ptr</code>指定的内存单元就设置为<code>PTHREAD_CANCELED</code>。</p>
<p>可以通过调用<code>pthread_join</code>自动把线程置于分离状态，这样资源就可以恢复。如果线程已经处于分离状态，<code>pthread_join</code>调用就会失败，返回EINVAL，尽管这种行为是与具体实现相关的。</p>
<p>如果对线程的返回值并不感兴趣，那么可以把<code>rval_ptr</code>设置为NULL。在这种情况下，调用<code>pthread_join</code>函数可以等待指定的线程终止，但并不获取线程的终止状态。</p>
<p>程序展示了如何获取已终止的线程的退出码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">thr_fn1</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread 1 returning\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>((<span class="type">void</span> *)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">thr_fn2</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread 2 exiting\n&quot;</span>);</span><br><span class="line">        pthread_exit((<span class="type">void</span> *)<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span>                     err;</span><br><span class="line">        <span class="type">pthread_t</span>       tid1, tid2;</span><br><span class="line">        <span class="type">void</span>            *tret;</span><br><span class="line"></span><br><span class="line">        err = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thr_fn1, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                err_exit(err, <span class="string">&quot;can&#x27;t create thread 1&quot;</span>);</span><br><span class="line">        err = pthread_create(&amp;tid2, <span class="literal">NULL</span>, thr_fn2, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                err_exit(err, <span class="string">&quot;can&#x27;t create thread 2&quot;</span>);</span><br><span class="line">        err = pthread_join(tid1, &amp;tret);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                err_exit(err, <span class="string">&quot;can&#x27;t join with thread 1&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread 1 exit code %ld\n&quot;</span>, (<span class="type">long</span>)tret);</span><br><span class="line">        err = pthread_join(tid2, &amp;tret);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                err_exit(err, <span class="string">&quot;can&#x27;t join with thread 2&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread 2 exit code %ld\n&quot;</span>, (<span class="type">long</span>)tret);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行程序，得到的结果是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">thread 1 returning</span><br><span class="line">thread 2 exiting</span><br><span class="line">thread 1 <span class="built_in">exit</span> code 1</span><br><span class="line">thread 2 <span class="built_in">exit</span> code 2</span><br></pre></td></tr></table></figure></p>
<p>可以看到，当一个线程通过调用<code>pthread_exit</code>退出或者简单地从启动例程中返回时，进程中的其他线程可以通过调用<code>pthread_join</code>函数获得该线程的退出状态。</p>
<p><code>pthread_create</code>和<code>pthread_exit</code>函数的无类型指针参数可以传递的值不止一个，这个指针可以传递包含复杂信息的结构的地址，但是注意，这个结构所使用的内存在调用者完成调用以后必须仍然是有效的。例如，在调用线程的栈上分配了该结构，那么其他的线程在使用这个结构时内存内容可能已经改变了。又如，线程在自己的栈上分配了一个结构，然后把指向这个结构的指针传给<code>pthread_exit</code>，那么调用<code>pthread_join</code>的线程试图使用该结构时，这个核有可能已经被撤销，这块内存也已另作他用。</p>
<p>程序给出了用自动变量(分配在栈上)作为<code>pthread_exit</code>的参数时出现的问题。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> a, b, c, d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">printfoo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="keyword">struct</span> foo *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  structure at 0x%lx\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  foo.a = %d\n&quot;</span>, fp-&gt;a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  foo.b = %d\n&quot;</span>, fp-&gt;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  foo.c = %d\n&quot;</span>, fp-&gt;c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  foo.d = %d\n&quot;</span>, fp-&gt;d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">thr_fn1</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">foo</span>      <span class="title">foo</span> =</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">        printfoo(<span class="string">&quot;thread 1:\n&quot;</span>, &amp;foo);</span><br><span class="line">        pthread_exit((<span class="type">void</span> *)&amp;foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">thr_fn2</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread 2: ID is %lu\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)pthread_self());</span><br><span class="line">        pthread_exit((<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span>             err;</span><br><span class="line">        <span class="type">pthread_t</span>       tid1, tid2;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">foo</span>      *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line">        err = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thr_fn1, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                err_exit(err, <span class="string">&quot;can&#x27;t create thread 1&quot;</span>);</span><br><span class="line">        err = pthread_join(tid1, (<span class="type">void</span> *)&amp;fp);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                err_exit(err, <span class="string">&quot;can&#x27;t join with thread 1&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent starting second thread\n&quot;</span>);</span><br><span class="line">        err = pthread_create(&amp;tid2, <span class="literal">NULL</span>, thr_fn2, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                err_exit(err, <span class="string">&quot;can&#x27;t create thread 2&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        printfoo(<span class="string">&quot;parent:\n&quot;</span>, fp);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Linux上运行此程序，得到：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">thread 1:</span><br><span class="line">structure at 0x7f2c83682ed0</span><br><span class="line">foo.a = 1</span><br><span class="line">foo.b = 2</span><br><span class="line">foo.c = 3</span><br><span class="line">foo.d = 4</span><br><span class="line">parent starting second thread</span><br><span class="line">thread 2: ID is 139829159933636</span><br><span class="line">parent:</span><br><span class="line">structure at 0x7t2c83682ed0</span><br><span class="line">foo.a = -2090321472</span><br><span class="line">foo.b = 32556</span><br><span class="line">foo.c = 1</span><br><span class="line">foo.d = 0</span><br></pre></td></tr></table></figure></p>
<p>可以看到，当主线程访问这个结构时，结构的内容已经改变了。注意第二个线程(tid2)的栈是如何覆盖第一个线程的栈的。为了解决这个问题，可以使用全局结构，或者用<code>malloc</code>函数分配结构。</p>
<p>线程可以通过调用pthread_cancel函数来请求取消同一进程中的其他线程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span> <span class="params">(<span class="type">pthread_t</span> tid)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>在默认情况下，<code>pthread_cancel</code>函数会使得由<code>tid</code>标识的线程的行为表现为如同调用了参数为<code>PTHREAD_CANCELED</code>的<code>pthread_exit</code>函数，但是，线程可以选择忽略取消或者控制如何被取消。注意<code>pthread_cancel</code>并不等待线程终止，它仅仅提出请求。</p>
<p>线程可以安排它退出时需要调用的函数，这与进程在退出时可以用<code>atexit</code>函数安排退出是类似的。这样的函数称为<strong>线程清理处理程序</strong>(thread cleanup handier)，一个线程可以建立多个清理处理程序。处理程序记录在栈中，也就是说，它们的执行顺序与它们注册时相反。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_eleanup_push</span> <span class="params">(<span class="type">void</span> (*rtn) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_pop</span> <span class="params">(<span class="type">int</span> execute)</span>;</span><br></pre></td></tr></table></figure></p>
<p>当线程执行以下动作时，清理函数<code>rm</code>是由<code>pthread_cleanup_push</code>函数调度的，调用时只有一个参数<code>arg</code>：</p>
<ul>
<li>调用<code>pthread_exit</code>时：</li>
<li>响应取消请求时：</li>
<li>用非零<code>execute</code>参数调用<code>pthread_cleanup_pop</code>时。</li>
</ul>
<p>如果<code>execute</code>参数设置为0，清理函数将不被调用。不管发生上述哪种情况，<code>pthread_cleanup_pop</code>都将删除上次<code>pthread_cleanup_push</code>调用建立的清理处理程序.这些函数有一个限制，由于它们可以实现为宏，所以必须在与线程相同的作用域中以匹配对的形式使用。<code>pthread_cleanup_push</code>的宏定义可以包含字符<code>&#123;</code>，这种情况下，在<code>pthread_cleanup_pop</code>的定义中要有对应的匹配字符<code>&#125;</code>。</p>
<p>给出一个如何使用线程清理处理程序的例子，它描述了其中涉及的清理机制。注意，虽然我们从来没想过要传一个参数0给线程启动例程，但还是需要把<code>pthread_cleanup_pop</code>调用和<code>pthread_cleanup_push</code>调用匹配起来，否则，程序编译就可能通不过。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">cleanup</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cleanup: %s\n&quot;</span>, (<span class="type">char</span> *)arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">thr_fn1</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread 1 start\n&quot;</span>);</span><br><span class="line">        pthread_cleanup_push(cleanup, <span class="string">&quot;thread 1 first handler&quot;</span>);</span><br><span class="line">        pthread_cleanup_push(cleanup, <span class="string">&quot;thread 1 second handler&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread 1 push complete\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg)</span><br><span class="line">                <span class="keyword">return</span>((<span class="type">void</span> *)<span class="number">1</span>);</span><br><span class="line">        pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">        pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>((<span class="type">void</span> *)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">thr_fn2</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread 2 start\n&quot;</span>);</span><br><span class="line">        pthread_cleanup_push(cleanup, <span class="string">&quot;thread 2 first handler&quot;</span>);</span><br><span class="line">        pthread_cleanup_push(cleanup, <span class="string">&quot;thread 2 second handler&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread 2 push complete\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg)</span><br><span class="line">                pthread_exit((<span class="type">void</span> *)<span class="number">2</span>);</span><br><span class="line">        pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">        pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">        pthread_exit((<span class="type">void</span> *)<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span>             err;</span><br><span class="line">        <span class="type">pthread_t</span>       tid1, tid2;</span><br><span class="line">        <span class="type">void</span>            *tret;</span><br><span class="line"></span><br><span class="line">        err = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thr_fn1, (<span class="type">void</span> *)<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                err_exit(err, <span class="string">&quot;can&#x27;t create thread 1&quot;</span>);</span><br><span class="line">        err = pthread_create(&amp;tid2, <span class="literal">NULL</span>, thr_fn2, (<span class="type">void</span> *)<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                err_exit(err, <span class="string">&quot;can&#x27;t create thread 2&quot;</span>);</span><br><span class="line">        err = pthread_join(tid1, &amp;tret);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                err_exit(err, <span class="string">&quot;can&#x27;t join with thread 1&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>运行程序会得到：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">thread 1 start</span><br><span class="line">thread 1 push complete</span><br><span class="line">thread 2 start</span><br><span class="line">thread 2 push complete</span><br><span class="line">cleanup: thread 2 second handler</span><br><span class="line">cleanup: thread 2 first handler</span><br><span class="line">thread 1 <span class="built_in">exit</span> code 1</span><br><span class="line">thread 2 <span class="built_in">exit</span> code 2</span><br></pre></td></tr></table></figure></p>
<p>从输出结果可以看出，两个线程都正确地启动和退出了，但是只有第二个线程的清理处理程序被调用了。因此，如果线程是通过从它的启动例程中返回而终止的话，它的清理处理程序就不会被调用。还要注意，清理处理程序是按照与它们安装时相反的顺序被调用的。</p>
<p>在FreeBSD或者MacOSX上，<code>pthread_cleanup_push</code>是用宏实现的，而宏把某些上下文存放在栈上。当线程1在调用<code>pthread_cleanup_push</code>和调用<code>pthread_cleanup_pop</code>之间返回时，栈已被改写，而这两个平台在调用清理处理程序时就用了这个被改写的上下文。在Single UNIX Specification中，函数如果在调用<code>pthread_cleanup_push</code>和<code>pthread_cleanup_pop</code>之间返回，会产生未定义行为。唯一的可移植方法是调用<code>pthread_exit</code>。</p>
<p>现在，让我们了解一下线程函数和进程函数之间的相似之处。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>进程原语</th>
<th>线程原语</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fork</td>
<td>pthread_create</td>
<td>创建新的控制流</td>
</tr>
<tr>
<td>exit</td>
<td>pthread_exit</td>
<td>从现有的控制流中退出</td>
</tr>
<tr>
<td>waitpid</td>
<td>pthread_join</td>
<td>从控制流中得到退出状态</td>
</tr>
<tr>
<td>atexit</td>
<td>pthread_cancel_push</td>
<td>注册在退出控制流时调用的函数</td>
</tr>
<tr>
<td>getpid</td>
<td>pthread_self</td>
<td>获取控制流的ID</td>
</tr>
<tr>
<td>abort</td>
<td>pthread_cancel</td>
<td>请求控制流的非正常退出</td>
</tr>
</tbody>
</table>
</div>
<p>在默认情况下，线程的终止状态会保存直到对该线程调用<code>pthread_join</code>。如果线程已经被分离，线程的底层存储资源可以在线程终止时立即被收回。在线程被分离后，我们不能用<code>pthread_join</code>函数等待它的终止状态，因为对分离状态的线程调用<code>pthread_join</code>会产生未定义行为。可以调用<code>pthread_detach</code>分离线程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span> <span class="params">(<span class="type">pthread_t</span> sid)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；否则，返回情谈编号</span></span><br></pre></td></tr></table></figure></p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>当一个线程可以修改的变量，其他线程也可以读取或者修改的时候，我们就需要对这些线程进行同步，确保它们在访问变量的存储内容时不会访问到无效的值。在变量修改时间多于一个存储器访问周期的处理器结构中，当存储器读与存储器写这两个周期交叉时，这种不一致就会出现。</p>
<p>为了解决这个问题，线程不得不使用锁，同一时间只允许一个线程访问该变量。如果线程B希望读取变量，它首先要获取锁。同样，当线程A更新变量时，也需要获取同样的这把锁。这样，线程B在线程A释放锁以前就不能读取变量。</p>
<p>两个或多个线程试图在同一时间修改同一变量时，也需要进行同步。考虑变量增量操作的情况，增量操作通常分解为以下3步。</p>
<ol>
<li>从内存单元读入寄存器</li>
<li>在寄存器中对变量做增量操作，</li>
<li>把新的值写回内存单元</li>
</ol>
<p>如果两个线程试图几乎在同一时间对同一个变量做增量操作而不进行同步的话，结果就可能出现不一致。如果修改操作是原子操作，那么就不存在竞争。如果数据总是以顺序一致出现的，就不需要额外的同步。当多个线程观察不到数据的不一致时，那么操作就是顺序一致的。在现代计算机系统中，存储访问需要多个总线周期，多处理器的总线周期通常在多个处理器上是交叉的，所以我们并不能保证数据是顺序一致的。</p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>可以使用pthread的互斥接口来保护数据，确保同一时间只有一个线程访问数据。互斥量(mutex)从本质上说是一把锁，在访问共享资源前对互斥量进行设置(加锁)，在访问完成后释放(解锁)互斥量。对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程都会被阻塞，直到当前线程释放该互斥锁。如果释放互斥量时有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成可运行状态，第一个变为运行的线程就可以对互斥量加锁，其他线程就会看到互斥量依然是锁着的，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行。</p>
<p>只有将所有线程都设计成遵守相同数据访问规则的。互斥机制才能正常工作。操作系统并不会为我们做数据访问的申行化。如果允许其中的某个线程在没有得到锁的情况下也可以访问共享资源，那么即使其他的线程在使用共享资源前都申请锁，也还是会出现数据不一致的问题。</p>
<p>互斥变量是用<code>pthread_mutex_t</code>数据类型表示的。在使用互斥变量以前，必须首先对它进行初始化，可以把它设置为常量<code>PTHREAD_MUTEX_ INITIALIZER</code>(只适用于静态分配的互斥量)，也可以通过调用<code>pthread_mutex_init</code>函数进行初始化。如果动态分配互斥量(例如，通过调用<code>malloc</code>函数)，在释放内存前需要调用<code>pthread_mutex_destroy</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span> <span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span> <span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>要用默认的属性初始化互斥量，只需把<code>attr</code>设为NULL。</p>
<p>对互斥量进行加锁，需要调用<code>pthread_mutex_lock</code>。如果互斥量已经上锁，调用线程将阻塞直到互斥量被解锁。对互斥量解锁，需要调用<code>pthread_mutex_unlock</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> epthread.h&gt;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">// 所有函数的返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>如果线程不希望被阻塞，它可以使用<code>pthread_mutex_trylock</code>尝试对互斥量进行加锁。如果调用<code>pthread_mutex_trylock</code>时互斥量处于未锁住状态，那么<code>pthread_mutex_trylock</code>将锁住互斥量，不会出现阻塞直接返回0；否则<code>pthread_mutex_trylock</code>就会失败，不能锁住互斥量，返回EBUSY。</p>
<p>当一个以上的线程需要访问动态分配的对象时，我们可以在对象中嵌入引用计数，确保在所有使用该对象的线程完成数据访问之前，该对象内存空间不会被释放。</p>
<p>在使用该对象前，线程需要调用<code>foo_hold</code>对这个对象的引用计数加1。当对象使用完毕时，必须调用<code>foo_rele</code>释放引用。最后一个引用被释放时，对象所占的内存空间就被释放。在这个例子中，我们忽略了线程在调用<code>foo_hold</code>之前是如何找到对象的。如果有另一个线程在调用<code>foo_hold</code>时阻塞等待互斥锁，这时即使该对象引用计数为0，<code>foo_rele</code>释放该对象的内存仍然是不对的。可以通过确保对象在释放内存前不会被找到这种方式来避免上述问题。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">	<span class="type">int</span>             f_count;</span><br><span class="line">	<span class="type">pthread_mutex_t</span> f_lock;</span><br><span class="line">	<span class="type">int</span>             f_id;</span><br><span class="line">	<span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> foo *</span><br><span class="line"><span class="title function_">foo_alloc</span><span class="params">(<span class="type">int</span> id)</span> <span class="comment">/* allocate the object */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> foo))) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		fp-&gt;f_count = <span class="number">1</span>;</span><br><span class="line">		fp-&gt;f_id = id;</span><br><span class="line">		<span class="keyword">if</span> (pthread_mutex_init(&amp;fp-&gt;f_lock, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">free</span>(fp);</span><br><span class="line">			<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* ... continue initialization ... */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">foo_hold</span><span class="params">(<span class="keyword">struct</span> foo *fp)</span> <span class="comment">/* add a reference to the object */</span></span><br><span class="line">&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;fp-&gt;f_lock);</span><br><span class="line">	fp-&gt;f_count++;</span><br><span class="line">	pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">foo_rele</span><span class="params">(<span class="keyword">struct</span> foo *fp)</span> <span class="comment">/* release a reference to the object */</span></span><br><span class="line">&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;fp-&gt;f_lock);</span><br><span class="line">	<span class="keyword">if</span> (--fp-&gt;f_count == <span class="number">0</span>) &#123; <span class="comment">/* last reference */</span></span><br><span class="line">		pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">		pthread_mutex_destroy(&amp;fp-&gt;f_lock);</span><br><span class="line">		<span class="built_in">free</span>(fp);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>如果线程试图对同一个互斥量加锁两次，那么它自身就会陷入死锁状态，但是使用互斥量时，还有其他不太明显的方式也能产生死锁。例如，程序中使用一个以上的互斥量时，如果允许一个线程一直占有第一个互斥量，并且在试图锁住第二个互斥量时处于阻塞状态，但是拥有第二个互斥最的线程也在试图锁住第一个互斥量。因为两个线程都在相互请求另一个线程拥有的资源，所以这两个线程都无法向前运行，于是就产生死锁。</p>
<p>可以通过仔细控制互斥量加锁的顺序来避免死锁的发生。例如，假设需要对两个互斥量A和B同时加锁。如果所有线程总是在对互斥量B加锁之前锁住互斥量A，那么使用这两个互斥量就不会产生死锁(当然在其他的资源上仍可能出现死锁)。可能出现的死锁只会发生在一个线程试图锁住另一个线程以相反的顺序锁住的互斥量。</p>
<p>可以先释放占有的锁，然后过一段时间再试。这种情况可以使用<code>pthread_mutex_trylock</code>接口避免死锁。如果已经占有某些锁而且<code>pthread_mutex_trylock</code>接口返回成功，那么就可以前进。但是，如果不能获取锁，可以先释放已经占有的锁，做好清理工作，然后过一段时间再重新试。</p>
<p>在同时需要两个互斥量时，总是让它们以相同的顺序加锁，这样可以避免死锁。第二个互斥量维护着一个用于跟踪<code>foo</code>数据结构的散列列表。这样<code>hashlock</code>互斥量既可以保护<code>foo</code>数据结构中的散列表fh，又可以保护散列链字段<code>e_next</code>。<code>foo</code>结构中的<code>t_lock</code>互斥量保护对<code>foo</code>结构中的其他字段的访问。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NHASH 29</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH(id) (((unsigned long)id)%NHASH)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">fh</span>[<span class="title">NHASH</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> hashlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">	<span class="type">int</span>             f_count;</span><br><span class="line">	<span class="type">pthread_mutex_t</span> f_lock;</span><br><span class="line">	<span class="type">int</span>             f_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">foo</span>     *<span class="title">f_next</span>;</span> <span class="comment">/* protected by hashlock */</span></span><br><span class="line">	<span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> foo *</span><br><span class="line"><span class="title function_">foo_alloc</span><span class="params">(<span class="type">int</span> id)</span> <span class="comment">/* allocate the object */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">foo</span>	*<span class="title">fp</span>;</span></span><br><span class="line">	<span class="type">int</span>			idx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> foo))) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		fp-&gt;f_count = <span class="number">1</span>;</span><br><span class="line">		fp-&gt;f_id = id;</span><br><span class="line">		<span class="keyword">if</span> (pthread_mutex_init(&amp;fp-&gt;f_lock, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">free</span>(fp);</span><br><span class="line">			<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		idx = HASH(id);</span><br><span class="line">		pthread_mutex_lock(&amp;hashlock);</span><br><span class="line">		fp-&gt;f_next = fh[idx];</span><br><span class="line">		fh[idx] = fp;</span><br><span class="line">		pthread_mutex_lock(&amp;fp-&gt;f_lock);</span><br><span class="line">		pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">		<span class="comment">/* ... continue initialization ... */</span></span><br><span class="line">		pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">foo_hold</span><span class="params">(<span class="keyword">struct</span> foo *fp)</span> <span class="comment">/* add a reference to the object */</span></span><br><span class="line">&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;fp-&gt;f_lock);</span><br><span class="line">	fp-&gt;f_count++;</span><br><span class="line">	pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> foo *</span><br><span class="line"><span class="title function_">foo_find</span><span class="params">(<span class="type">int</span> id)</span> <span class="comment">/* find an existing object */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">foo</span>	*<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;hashlock);</span><br><span class="line">	<span class="keyword">for</span> (fp = fh[HASH(id)]; fp != <span class="literal">NULL</span>; fp = fp-&gt;f_next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fp-&gt;f_id == id) &#123;</span><br><span class="line">			foo_hold(fp);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">	<span class="keyword">return</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">foo_rele</span><span class="params">(<span class="keyword">struct</span> foo *fp)</span> <span class="comment">/* release a reference to the object */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">foo</span>	*<span class="title">tfp</span>;</span></span><br><span class="line">	<span class="type">int</span>			idx;</span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;fp-&gt;f_lock);</span><br><span class="line">	<span class="keyword">if</span> (fp-&gt;f_count == <span class="number">1</span>) &#123; <span class="comment">/* last reference */</span></span><br><span class="line">		pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">		pthread_mutex_lock(&amp;hashlock);</span><br><span class="line">		pthread_mutex_lock(&amp;fp-&gt;f_lock);</span><br><span class="line">		<span class="comment">/* need to recheck the condition */</span></span><br><span class="line">		<span class="keyword">if</span> (fp-&gt;f_count != <span class="number">1</span>) &#123;</span><br><span class="line">			fp-&gt;f_count--;</span><br><span class="line">			pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">			pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* remove from list */</span></span><br><span class="line">		idx = HASH(fp-&gt;f_id);</span><br><span class="line">		tfp = fh[idx];</span><br><span class="line">		<span class="keyword">if</span> (tfp == fp) &#123;</span><br><span class="line">			fh[idx] = fp-&gt;f_next;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (tfp-&gt;f_next != fp)</span><br><span class="line">				tfp = tfp-&gt;f_next;</span><br><span class="line">			tfp-&gt;f_next = fp-&gt;f_next;</span><br><span class="line">		&#125;</span><br><span class="line">		pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">		pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">		pthread_mutex_destroy(&amp;fp-&gt;f_lock);</span><br><span class="line">		<span class="built_in">free</span>(fp);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fp-&gt;f_count--;</span><br><span class="line">		pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分配函数现在锁住了散列列表锁，把新的结构添加到了散列桶中，而且在对散列列表的锁解锁之前，先锁定了新结构中的互斥量。因为新的结构是放在全局列表中的，其他线程可以找到它，所以在初始化完成之前，需要阻塞其他线程试图访问新结构。</p>
<p><code>foo_find</code>函数锁住散列列表锁，然后搜索被请求的结构。如果找到了，就增加其引用计数并返回指向该结构的指针。注意，加锁的顺序是，先在<code>foo_find</code>函数中锁定散列列表锁，然后再在<code>foo_hold</code>函数中锁定<code>foo</code>结构中的<code>f_lock</code>互斥量。</p>
<p>现在有了两个锁以后，<code>foo_rele</code>函数就变得更加复杂了。如果这是最后一个引用，就需要对这个结构互斥量进行解锁，因为我们需要从散列列表中删除这个结构，这样才可以获取散列列表锁，然后重新获取结构互斥量。从上一次获得结构互斥量以来我们可能被阻塞着，所以需要重新检查条件，判断是否还需要释放这个结构。如果另一个线程在我们为满足锁顺序而阻塞时发现了这个结构并对其引用计数加1，那么只需要简单地对整个引用计数减1，对所有的东西解锁，然后返回。</p>
<h3 id="函数pthread-mutex-timedlock"><a href="#函数pthread-mutex-timedlock" class="headerlink" title="函数pthread_mutex_timedlock"></a>函数pthread_mutex_timedlock</h3><p>当线程试图获取一个已加锁的互斥量时，<code>pthread_mutex_timedlock</code>互斥量原语允许绑定线程阻塞时间。<code>pthread_mutex_timedlock</code>函数与<code>pthread_mutex_lock</code>是基本等价的，但是在达到超时时间值时，<code>pthread_mutex_timedlock</code>不会对互斥量进行加锁。而是返回错误码ETIMEDOUT。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_timedlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> tinespec *<span class="keyword">restrict</span> tsptr)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>超时指定愿意等待的绝对时间(与相对时间对比而言，指定在时间X之前可以阻塞等待，而不是说愿意阻塞Y秒)。这个超时时间是用<code>timespec</code>结构来表示的，它用秒和纳秒来描述时间。</p>
<p>程序给出了如何用<code>pthread_mutex_timedlock</code>避免永久阻塞。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tout</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tmp</span>;</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">        <span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mutex is locked\n&quot;</span>);</span><br><span class="line">        clock_gettime(CLOCK_REALTIME, &amp;tout);</span><br><span class="line">        tmp = localtime(&amp;tout.tv_sec);</span><br><span class="line">        strftime(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;%r&quot;</span>, tmp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;current time is %s\n&quot;</span>, buf);</span><br><span class="line">        tout.tv_sec += <span class="number">10</span>;      <span class="comment">/* 10 seconds from now */</span></span><br><span class="line">        <span class="comment">/* caution: this could lead to deadlock */</span></span><br><span class="line">        err = pthread_mutex_timedlock(&amp;lock, &amp;tout);</span><br><span class="line">        clock_gettime(CLOCK_REALTIME, &amp;tout);</span><br><span class="line">        tmp = localtime(&amp;tout.tv_sec);</span><br><span class="line">        strftime(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;%r&quot;</span>, tmp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the time is now %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;mutex locked again!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t lock mutex again: %s\n&quot;</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>运行结果输出如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">mutex is locked</span><br><span class="line">current <span class="keyword">time</span> <span class="keyword">in</span> 12:41:58 MI</span><br><span class="line">the <span class="keyword">time</span> is now 11:42:08 AM</span><br><span class="line">can<span class="string">&#x27;t lock mutex again: Connection timed out</span></span><br></pre></td></tr></table></figure></p>
<p>这个程序故意对它已有的互斥量进行加锁，目的是演示<code>pthread_mutex_timedlock</code>是如何工作的。不推荐在实际中使用这种策略，因为它会导致死锁。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁(reader-writerlock)与互斥量类似，不过读写锁允许更高的并行性。互斥量要么是锁住状态，要么就是不加锁状态，而且一次只有一个线程可以对其加锁。读写锁可以有3种状态：</p>
<ul>
<li>读模式下加锁状态，</li>
<li>写模式下加锁状态，</li>
<li>不加锁状态。</li>
</ul>
<p>一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。当读写锁是写加锁状态时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞。当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是任何希望以写模式对此锁进行加锁的线程都会阻塞，直到所有的线程释放它们的读锁为止。</p>
<p>虽然各操作系统对读写锁的实现各不相同，但当读写锁处于读模式锁住的状态，而这时有一个线程试图以写模式获取锁时，读写锁通常会阻塞随后的读模式锁请求。这样可以避免读模式锁长期占用，而等待的写模式锁请求一直得不到满足。</p>
<p>读写锁非常适合于对数据结构读的次数远大于写的情况。当读写锁在写模式下时，它所保护的数据结构就可以被安全地修改，因为一次只有一个线程可以在写模式下拥有这个锁。当读写锁在读模式下时，只要线程先获取了读模式下的读写镇，该锁所保护的数据结构就可以被多个获得读模式锁的线程读取。</p>
<p>读写锁也叫做<strong>共享互斥锁</strong>(shared-exclusive lock)。 当读写锁是读模式锁住时，就可以说成是以共享模式锁住的。当它是写模式锁住的时候，就可以说成是以互斥模式锁住的。与互斥量相比，读写锁在使用之前必须初始化，在释放它们底层的内存之前必须销毁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>读写锁通过调用<code>pthread_rwlock_init</code>进行初始化。如果希望读写锁有默认的属性，可以传一个null指针给attr。Single UNIX Specification在XSI扩展中定义了<code>PTHREAD_RWLOCK_INITIALIZER</code>常量。如果默认属性就足够的话，可以用它对静态分配的读写锁进行初始化。</p>
<p>在释放读写锁占用的内存之前，需要调用<code>pthread_rwlock_destroy</code>做清理工作。如果<code>pthread_rwlock_init</code>为读写锁分配了资源，<code>pthread_nwlock_destroy</code>将释放这些资源。如果在调用<code>pthread_rwlock_destroy</code>之前就释放了读写锁占用的内存空间，那么分配给这<br>个锁的资源就会丢失。要在读模式下锁定读写锁，需要调用<code>pthread_rwlock_rdlock</code>。要在写模式下锁定读写锁，需要调用<code>pthread_rwlock_wrlock</code>。不管以何种方式锁住读写锁，都可以调用<code>pthread_rwlock_unlock</code>进行解锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="comment">// 所有函数的返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>各种实现可能会对共享模式下可获取的读写锁的次数进行限制，所以需要检查<code>pthread_rwlock_rdlock</code>的返回值。即使<code>pthread_rwlock_wrlock</code>和<code>pthread_rwlock_unlock</code>有错误返回，而且从技术上来讲，在调用函数时应该总是检查错误返回，但是如果锁设计合理的话，就不需要检查它们。错误返回值的定义只是针对不正确使用读写锁的情况(如未经初始化的锁)，或者试图获取已拥有的锁从而可能产生死锁的情况。但是需要注意，有些特定的实现可能会定义另外的错误返回。</p>
<p>Single UNIX Specification还定义了读写锁原语的条件版本。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthreed_rwlock_tryrdlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span>*rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span>*rwlock)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返阀错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>可以获取锁时，这两个函数返回0；否则，它们返回错误EBUSY。这两个函数可以用于我们前面讨论的遵守某种锁层次但还不能完全避免死锁的情况。</p>
<p>程序解释了读写锁的使用。作业请求队列由单个读写锁保护。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">job</span> *<span class="title">j_next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">job</span> *<span class="title">j_prev</span>;</span></span><br><span class="line">	<span class="type">pthread_t</span>   j_id;   <span class="comment">/* tells which thread handles this job */</span></span><br><span class="line">	<span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">job</span>      *<span class="title">q_head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">job</span>      *<span class="title">q_tail</span>;</span></span><br><span class="line">	<span class="type">pthread_rwlock_t</span> q_lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initialize a queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">queue_init</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">queue</span> *qp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	qp-&gt;q_head = <span class="literal">NULL</span>;</span><br><span class="line">	qp-&gt;q_tail = <span class="literal">NULL</span>;</span><br><span class="line">	err = pthread_rwlock_init(&amp;qp-&gt;q_lock, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(err);</span><br><span class="line">	<span class="comment">/* ... continue initialization ... */</span></span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Insert a job at the head of the queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">job_insert</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">queue</span> *qp, <span class="keyword">struct</span> job *jp)</span></span><br><span class="line">&#123;</span><br><span class="line">	pthread_rwlock_wrlock(&amp;qp-&gt;q_lock);</span><br><span class="line">	jp-&gt;j_next = qp-&gt;q_head;</span><br><span class="line">	jp-&gt;j_prev = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (qp-&gt;q_head != <span class="literal">NULL</span>)</span><br><span class="line">		qp-&gt;q_head-&gt;j_prev = jp;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		qp-&gt;q_tail = jp;	<span class="comment">/* list was empty */</span></span><br><span class="line">	qp-&gt;q_head = jp;</span><br><span class="line">	pthread_rwlock_unlock(&amp;qp-&gt;q_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Append a job on the tail of the queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">job_append</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">queue</span> *qp, <span class="keyword">struct</span> job *jp)</span></span><br><span class="line">&#123;</span><br><span class="line">	pthread_rwlock_wrlock(&amp;qp-&gt;q_lock);</span><br><span class="line">	jp-&gt;j_next = <span class="literal">NULL</span>;</span><br><span class="line">	jp-&gt;j_prev = qp-&gt;q_tail;</span><br><span class="line">	<span class="keyword">if</span> (qp-&gt;q_tail != <span class="literal">NULL</span>)</span><br><span class="line">		qp-&gt;q_tail-&gt;j_next = jp;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		qp-&gt;q_head = jp;	<span class="comment">/* list was empty */</span></span><br><span class="line">	qp-&gt;q_tail = jp;</span><br><span class="line">	pthread_rwlock_unlock(&amp;qp-&gt;q_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Remove the given job from a queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">job_remove</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">queue</span> *qp, <span class="keyword">struct</span> job *jp)</span></span><br><span class="line">&#123;</span><br><span class="line">	pthread_rwlock_wrlock(&amp;qp-&gt;q_lock);</span><br><span class="line">	<span class="keyword">if</span> (jp == qp-&gt;q_head) &#123;</span><br><span class="line">		qp-&gt;q_head = jp-&gt;j_next;</span><br><span class="line">		<span class="keyword">if</span> (qp-&gt;q_tail == jp)</span><br><span class="line">			qp-&gt;q_tail = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			jp-&gt;j_next-&gt;j_prev = jp-&gt;j_prev;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (jp == qp-&gt;q_tail) &#123;</span><br><span class="line">		qp-&gt;q_tail = jp-&gt;j_prev;</span><br><span class="line">		jp-&gt;j_prev-&gt;j_next = jp-&gt;j_next;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		jp-&gt;j_prev-&gt;j_next = jp-&gt;j_next;</span><br><span class="line">		jp-&gt;j_next-&gt;j_prev = jp-&gt;j_prev;</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_rwlock_unlock(&amp;qp-&gt;q_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Find a job for the given thread ID.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> job *</span><br><span class="line"><span class="title function_">job_find</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">queue</span> *qp, <span class="type">pthread_t</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">job</span> *<span class="title">jp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pthread_rwlock_rdlock(&amp;qp-&gt;q_lock) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (jp = qp-&gt;q_head; jp != <span class="literal">NULL</span>; jp = jp-&gt;j_next)</span><br><span class="line">		<span class="keyword">if</span> (pthread_equal(jp-&gt;j_id, id))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	pthread_rwlock_unlock(&amp;qp-&gt;q_lock);</span><br><span class="line">	<span class="keyword">return</span>(jp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，凡是需要向队列中增加作业或者从队列中删除作业的时候，都采用了写模式来锁住队列的读写锁。不管何时搜索队列，都需要获取读模式下的锁，允许所有的工作线程并发地搜索队列。在这种情况下，只有在线程搜索作业的频率远远高于增加或剩除作业时，使用读写锁才可能改善性能。工作线程只能从队列中读取与它们的线程ID匹配的作业。由于作业结构同一时间只能由一个线程使用，所以不需要额外的加锁。</p>
<h3 id="带有超时的读写锁"><a href="#带有超时的读写锁" class="headerlink" title="带有超时的读写锁"></a>带有超时的读写锁</h3><p>与互斥量一样，Single UNIX Specification提供了带有超时的读写锁加锁函数，使应用程序在获取读写锁时避免陷入永久阻塞状态。这两个函数是<code>pthread_rwlock_timedrdlock</code>和<code>pthread_rwlock_timedwrlock</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlook_timedrdlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_timedwrlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>这两个函数的行为与它们“不计时的”版本类似。<code>tsptr</code>参数指向<code>timespec</code>结构，指定线程应该停止阻塞的时间。如果它们不能获取锁，那么超时到期时，这两个函数将返回ETIMEDOUT错误。与<code>pthread_mutex_timedlock</code>函数类似，超时指定的是绝对时间，而不是相对时间。</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量是线程可用的另一种同步机制。条件变量给多个线程提供了一个会合的场所。条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生。条件本身是由互斥量保护的。线程在改变条件状态之前必须首先锁住互斥量。其他线程在获得互斥量之前不会察觉到这种改变，因为互斥量必须在锁定以后才能计算条件。</p>
<p>在使用条件变量之前，必须先对它进行初始化。由<code>pthread_cond_t</code>数据类型表示的条件变量可以用两种方式进行初始化，可以把常量<code>PTHREAD_COND_INITIALIZER</code>赋给静态分配的条件变量，但是如果条件变量是动态分配的，则需要使用<code>pthread_cond_init</code>函数对它进行初始化。</p>
<p>在释放条件变量底层的内存空间之前，可以使用<code>pthread_cond_destroy</code>函数对条件变量进行反初始化(deinitialize)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span> <span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span> <span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>除非需要创建一个具有非默认属性的条件变量，否则<code>pthread_cond_init</code>函数的attr参数可以设置为NULL。我们使用<code>pthread_cond_wait</code>等待条件变量变为真。如果在给定的时间内条件不能满足，那么会生成一个返回错误码的变量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span> <span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthcead_cond_timedwast</span> <span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>传递给<code>pthread_cond_wait</code>的互斥量对条件进行保护。调用者把锁住的互斥量传给函数，函数然后自动把调用线程放到等待条件的线程列表上，对互斥量解锁。这就关闭了条件检查和线程进入休眠状态等待条件改变这两个操作之间的时间通道，这样线程就不会错过条件的任何变化。<code>pthread_cond_wait</code>返回时，互斥量再次被锁住，<code>pthread_cond_timedwait</code>函数的功能与<code>pthread_cond_wait</code>函数相似，只是多了一<br>个超时(<code>tsptr</code>)。超时值指定了我们愿意等待多长时间，它是通过timespec结构指定的。</p>
<p>如果超时到期时条件还是没有出现，<code>pthread_cond_timewait</code>将重新获取互斥最，然后返回错误ETIMEDOUT。从<code>pthread_cond_wait</code>或者<code>pthread_cond_timedwait</code>调用成功返回时，线程需要重新计算条件，因为另一个线程可能已经在运行并改变了条件。</p>
<p>有两个函数可以用于通知线程条件已经满足。<code>pthread_cond_signal</code>函数至少能唤醒一个等待该条件的线程，而<code>pthread_cond_broadcast</code>函数则能唤醒等待该条件的所有线程。POSIX规范为了简化<code>pthread_cond_signal</code>的实现，允许它在实现的时候唤醒一个以上的线程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> (pthread.h&gt;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span> <span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span> <span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0：否则，返回锗误编号</span></span><br></pre></td></tr></table></figure></p>
<p>在调用<code>pthread_cond_signal</code>或者<code>pthread_cond_broadcast</code>时，我们说这是在给线程或者条件发信号。必须注意，一定要在改变条件状态以后再给线程发信号。</p>
<p>给出了如何结合使用条件变量和互斥量对线程进行同步。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">m_next</span>;</span></span><br><span class="line">	<span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">workq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_cond_t</span> qready = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> qlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">process_msg</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		pthread_mutex_lock(&amp;qlock);</span><br><span class="line">		<span class="keyword">while</span> (workq == <span class="literal">NULL</span>)</span><br><span class="line">			pthread_cond_wait(&amp;qready, &amp;qlock);</span><br><span class="line">		mp = workq;</span><br><span class="line">		workq = mp-&gt;m_next;</span><br><span class="line">		pthread_mutex_unlock(&amp;qlock);</span><br><span class="line">		<span class="comment">/* now process the message mp */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">enqueue_msg</span><span class="params">(<span class="keyword">struct</span> msg *mp)</span></span><br><span class="line">&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;qlock);</span><br><span class="line">	mp-&gt;m_next = workq;</span><br><span class="line">	workq = mp;</span><br><span class="line">	pthread_mutex_unlock(&amp;qlock);</span><br><span class="line">	pthread_cond_signal(&amp;qready);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>条件是工作队列的状态。我们用互斥量保护条件，在while循环中判断条件。把消息放到工作队列时，需要占有互斥量，但在给等待线程发信号时，不需要占有互斥量。只要线程在调用<code>pthread_cond_signal</code>之前把消息从队列中拖出了，就可以在释放互斥量以后完成这部分工作。因为我们是在while循环中检查条件，所以不存在这样的问题：线程醒来，发现队列仍为空，然后返回继续等待。如果代码不能容忍这种竞争，就需要在给线程发信号的时候占有互斥量。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁与互斥量类似，但它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等(自旋)阻塞状态。自旋锁可用于以下情况：锁被持有的时间短，而且线程并不希望在重新调度上花费太多的成本。</p>
<p>自旋锁通常作为底层原语用于实现其他类型的锁。根据它们所基于的系统体系结构，可以通过使用测试并设置指令有效地实现。当自旋锁用在非抢占式内核中时是非常有用的：除了提供互斥机制以外，它们会阻塞中断，这样中断处理程序就不会让系统陷入死锁状态，因为它需要获取已被加锁的自旋锁。在这种类型的内核中，中断处理程序不能休眠，因此它们能用的同步原语只能是自旋锁。</p>
<p>很多互斥量的实现非常高效。以至于应用程序采用互斥锁的性能与曾经采用过自旋锁的性能基本是相同的。事实上，有些互斥量的实现在试图获取互斥量的时候会自旋一小段时间，只有在自旋计数到达某一阙值的时候才会休眠。</p>
<p>自旋锁的接口与互斥量的接口类似，这使得它可以比较容易地从一个替换为另一个。可以用<code>pthread_spin_init</code>函数对自旋锁进行初始化。用<code>pthread_spin_destroy</code>函数进行自旋锁的反初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_init</span> <span class="params">(<span class="type">pthread_spinlock_t</span> *lock, <span class="type">int</span> pshared)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthzead_spin_destroy</span> <span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>只有一个属性是自旋锁特有的，这个属性只在支持线程进程共享同步(Thread Process SharedSynchronization)选项的平台上才用得到。<code>pshared</code>参数表示进程共享属性，表明自旋锁是如何获取的。如果它设为<code>PTHREAD_PROCESS_SHARED</code>，则自旋锁能被可以访问锁底层内存的线程所获取，即便那些线程属于不同的进程，情况也是如此。否则<code>pshared</code>参数设为<code>PTHREAD_PROCESS_PRIVATE</code>，自旋锁就只能被初始化该锁的进程内部的线程所访问。</p>
<p>可以用<code>pthread_spin_lock</code>或<code>pthread_spin_trylock</code>对自旋锁进行加锁，前者在获取锁之前一直自旋，后者如果不能获取锁，就立即返回EBUSY错误。注意，<code>pthread_spin_trylock</code>不能自旋。不管以何种方式加锁，自旋锁都可以调用<code>pthread_spin_unlock</code>函数解锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_lock</span> <span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_trylock</span> <span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_unlock</span> <span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br><span class="line"><span class="comment">// 所有函数的返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>注意，如果自旋锁当前在解锁状态的话，<code>pthread_spin_lock</code>函数不要自旋就可以对它加锁。如果线程已经对它加锁了，结果就是未定义的。调用<code>pthread_spin_lock</code>会返回EDEADLK错误(或其他错误)，或者调用可能会永久自旋。具体行为依赖于实际的实现。试图对没有加锁的自旋锁进行解锁，结果也是未定义的。</p>
<p>不管是<code>pthread_spin_lock</code>还是<code>pthread_spin_trylock</code>，返回值为0的话就表示自旋锁被加锁。需要注意，不要调用在持有自旋锁情况下可能会进入休眠状态的函数。如果调用了这些函数，会浪费CPU资源，因为其他线程需要获取自旋锁需要等待的时间就延长了。</p>
<h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p>屏障(barrier)是用户协调多个线程并行工作的同步机制。屏障允许每个线程等待，直到所有的合作线程都到达某一点，然后从该点继续执行。我们已经看到一种屏障，<code>pthread_join</code>函数就是一种屏障，允许一个线程等待，直到另一个线程退出。</p>
<p>但是屏障对象的概念更广，它们允许任意数量的线程等待，直到所有的线程完成处理工作，而线程不需要退出。所有线程达到屏障后可以接着工作，可以使用<code>pthread_barrier_init</code>函数对屏障进行初始化，用<code>thread_barrier_destroy</code>函数反初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_barrier_init</span> <span class="params">(<span class="type">pthreed_barrier_t</span> *<span class="keyword">restrict</span> barrier,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="type">pthread_barrierattr_t</span> *<span class="keyword">restrict</span> attr,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_barrier_destroy</span> <span class="params">(<span class="type">pthread_barrier_t</span> *barrier)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>初始化屏障时，可以使用<code>count</code>参数指定，在允许所有线程继续运行之前，必须到达屏障的线程数目。使用<code>attr</code>参数指定屏障对象的属性。现在设置<code>attr</code>为NULL，用默认属性初始化屏障。如果使用<code>pthread_barrier_init</code>函数为屏障分配资源，那么在反初始化屏障时可以调用<code>pthread_barrier_destroy</code>函数释放相应的资源。</p>
<p>可以使用<code>pthread_barrier_wait</code>函数来表明，线程已完成工作，准备等所有其他线程赶上来。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_barrier_wait</span> <span class="params">(<span class="type">pthread_barrier_t</span> *barrier)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0或者PTHREAD_BARRIER_SERIAL_THREAD；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>调用<code>pthread_barrier_wait</code>的线程在屏障计数(调用<code>pthread_barrier_init</code>时设定)未满足条件时，会进入休眠状态。如果该线程是最后一个调用<code>pthread_barrier_wait</code>的线程，就满足了屏障计数，所有的线程都被唤醒。</p>
<p>对于一个任意线程，<code>pthread_barrier_wait</code>函数返回了<code>PTHREAD_BARRIER_SERIAL_THREAD</code>。剩下的线程看到的返回值是0。这使得一个线程可以作为主线程，它可以工作在其他所有线程已完成的工作结果上。</p>
<p>一旦达到屏障计数值，而且线程处于非阻塞状态，屏障就可以被重用。但是除非在调用了<code>pthread_barrier_destroy</code>函数之后，又调用了<code>pthread_barrier_init</code>函数对计数用另外的数进行初始化，否则屏障计数不会改变。</p>
<p>给出了在一个任务上合作的多个线程之间如何用屏障进行同步。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NTHR   8				<span class="comment">/* number of threads */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMNUM 8000000L			<span class="comment">/* number of numbers to sort */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TNUM   (NUMNUM/NTHR)	<span class="comment">/* number to sort per thread */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> nums[NUMNUM];</span><br><span class="line"><span class="type">long</span> snums[NUMNUM];</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_barrier_t</span> b;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SOLARIS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heapsort qsort</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">heapsort</span><span class="params">(<span class="type">void</span> *, <span class="type">size_t</span>, <span class="type">size_t</span>,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> (*)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Compare two long integers (helper function for heapsort)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">complong</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *arg1, <span class="type">const</span> <span class="type">void</span> *arg2)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> l1 = *(<span class="type">long</span> *)arg1;</span><br><span class="line">	<span class="type">long</span> l2 = *(<span class="type">long</span> *)arg2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (l1 == l2)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (l1 &lt; l2)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Worker thread to sort a portion of the set of numbers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">thr_fn</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span>	idx = (<span class="type">long</span>)arg;</span><br><span class="line"></span><br><span class="line">	heapsort(&amp;nums[idx], TNUM, <span class="keyword">sizeof</span>(<span class="type">long</span>), complong);</span><br><span class="line">	pthread_barrier_wait(&amp;b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Go off and perform more work ...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span>((<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Merge the results of the individual sorted ranges.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">merge</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span>	idx[NTHR];</span><br><span class="line">	<span class="type">long</span>	i, minidx, sidx, num;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NTHR; i++)</span><br><span class="line">		idx[i] = i * TNUM;</span><br><span class="line">	<span class="keyword">for</span> (sidx = <span class="number">0</span>; sidx &lt; NUMNUM; sidx++) &#123;</span><br><span class="line">		num = LONG_MAX;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NTHR; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((idx[i] &lt; (i+<span class="number">1</span>)*TNUM) &amp;&amp; (nums[idx[i]] &lt; num)) &#123;</span><br><span class="line">				num = nums[idx[i]];</span><br><span class="line">				minidx = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		snums[sidx] = nums[idx[minidx]];</span><br><span class="line">		idx[minidx]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>	<span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span>		startusec, endusec;</span><br><span class="line">	<span class="type">double</span>			elapsed;</span><br><span class="line">	<span class="type">int</span>				err;</span><br><span class="line">	<span class="type">pthread_t</span>		tid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Create the initial set of numbers to sort.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	srandom(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUMNUM; i++)</span><br><span class="line">		nums[i] = random();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Create 8 threads to sort the numbers.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_barrier_init(&amp;b, <span class="literal">NULL</span>, NTHR+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NTHR; i++) &#123;</span><br><span class="line">		err = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_fn, (<span class="type">void</span> *)(i * TNUM));</span><br><span class="line">		<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">			err_exit(err, <span class="string">&quot;can&#x27;t create thread&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_barrier_wait(&amp;b);</span><br><span class="line">	merge();</span><br><span class="line">	gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Print the sorted list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	startusec = start.tv_sec * <span class="number">1000000</span> + start.tv_usec;</span><br><span class="line">	endusec = end.tv_sec * <span class="number">1000000</span> + end.tv_usec;</span><br><span class="line">	elapsed = (<span class="type">double</span>)(endusec - startusec) / <span class="number">1000000.0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sort took %.4f seconds\n&quot;</span>, elapsed);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUMNUM; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, snums[i]);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子给出了多个线程只执行一个任务时，使用屏障的简单情况。在更加实际的情况下，工作线程在调用<code>pthread_barrier_wait</code>函数返回后会接着执行其他的活动。</p>
<p>在这个实例中，使用8个线程分解了800万个数的排序工作。每个线程用堆排序算法对100万个数进行排序。然后主线程调用一个函数对这些结果进行合并。并不需要使用<code>pthread_barrier_wait</code>函数中的返回值<code>PTHREAD_BARRIER_SERIAL_THREAD</code>来决定哪个线程执行结果合并操作，因为我们使用了主线程来完成这个任务。这也是把屏障计数值设为工作线程数加1的原因，主线程也作为其中的一个候选线程。</p>
<h1 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h1><h2 id="线程限制"><a href="#线程限制" class="headerlink" title="线程限制"></a>线程限制</h2><p>Single UNIX Speeification定义了与线程操作有关的一些限制，与其他的系统限制一样，这些限制也可以通过sysconf函数进行查询。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>限制名称</th>
<th>描述</th>
<th>name参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>PTHREAD_DESTRUCTOR_ITERATIONS</td>
<td>线程退出时操作系统实现试图销毁线程特定数据的最大次数</td>
<td><code>_SC_THREAD_DESTRUCTOR_ITERATIONS</code></td>
</tr>
<tr>
<td>PTHREAD_KEYS_MAX</td>
<td>进程可以创建的健的最大数目</td>
<td><code>_SC_THREAD_KEYS_MAX</code></td>
</tr>
<tr>
<td>PTHREAD_STACK_HIN</td>
<td>一个线程的栈可用的最小字节数</td>
<td><code>_SC_THREAD_STACK_MIN</code></td>
</tr>
<tr>
<td>PTHREAD_THREADS_MAX</td>
<td>进程可以创建的最大线程数</td>
<td><code>SC_THREAD_THREADS_MAX</code></td>
</tr>
</tbody>
</table>
</div>
<p>这些限制的使用是为了增强应用程序在不同的操作系统实现之间的可移植性。</p>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>pthread接口允许我们通过设置每个对象关联的不同属性来细调线程和同步对象的行为。通常，管理这些属性的函数都遵循相同的模式。</p>
<ol>
<li>每个对象与它自己类型的属性对象进行关联(线程与线程属性关联，互斥量与互斥量属性关联，等等)。一个属性对象可以代表多个属性。属性对象对应用程序来说是不透明的。这意味着应用程序并不需要了解有关属性对象内部结构的详细细节，这样可以增强应用程序的可移植性。取而代之的是，需要提供相应的函数来管理这些属性对象。</li>
<li>有一个初始化函数，把属性设置为默认值。</li>
<li>还有一个销毁属性对象的函数。如果初始化函数分配了与属性对象关联的资源，销毁函数负责释放这些资源。</li>
<li>每个属性都有一个从属性对象中获取属性值的函数。由于函数成功时会返回0；失败时会返回错误编号，所以可以通过把属性值存储在函数的某一个参数指定的内存单元中，把属性值返回给调用者。</li>
<li>每个属性都有一个设置属性值的函数。在这种情况下，属性值作为参数按值传递。</li>
</ol>
<p>所有调用<code>pthread_create</code>函数的实例中，传入的参数都是空指针，而不是指向<code>pthread_attr_t</code>结构的指针。可以使用<code>pthread_attr_t</code>结构修改线程默认属性，并把这些属性与创建的线程联系起来。可以使用<code>pthread_attr_init</code>函数初始化<code>pthread_attr_t</code>结构。在调用<code>pthread_attr_init</code>以后，<code>pthread_attr_t</code>结构所包含的就是操作系统实现支持的所有线程属性的默认值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span> <span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span> <span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>如果要反初始化    <code>pthread_attr_t</code>结构， 可以调用<code>pthread_attr_destroy</code>函数。如果<code>pthread_attr_init</code>的实现对属性对象的内存空间是动态分配的，<code>pthread_attr_destroy</code>就会释放该内存空间。除此之外，<code>pthread_attr_ destroy</code>还会用无效的值初始化属性对象，因此，如果该属性对象被误用，将会导致<code>pthread_create</code>函数返回错误码。</p>
<p>下表总结了POSIX.1定义的线程属性。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>detachstate</td>
<td>线程的分离状态属性</td>
</tr>
<tr>
<td>guardsize</td>
<td>线程栈未尾的警戒缓冲区大小(字节数)</td>
</tr>
<tr>
<td>stackaddr</td>
<td>线程栈的最低地址</td>
</tr>
<tr>
<td>stackstze</td>
<td>线程栈的最小长度(字节数)</td>
</tr>
</tbody>
</table>
</div>
<p>如果在创建线程时就知道不需要了解线程的终止状态，就可以修改<code>pthread_attr_t</code>结构中的<code>detachstate</code>线程属性，让线程一开始就处于分离状态。可以使用<code>pthread_attr_setdetachstate</code>函数把线程属性<code>detachstate</code>设置成以下两个合法值之一：<code>PTHREAD_CREATE_DETACHED</code>，以分离状态启动线程；或者<code>PTHREAD_CREATE_JOINABLE</code>，正常启动线程，应用程序可以获取线程的终止状态。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthreed_attr_getdetachatate</span> <span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="type">int</span> *detackstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span> <span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *detachstate)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>可以调用<code>pthread_attr_getdetachstate</code>函数获取当前的<code>detachstate</code>线程属性。第二个参数所指向的整数要么设置成<code>PTHREAD_CREATE_DETACHED</code>，要么设置成<code>PTHREAD_CREATE_JOINABLE</code>，具体要取决于给定<code>pthread_attr_t</code>结构中的属性值。</p>
<p>给出了一个以分离状态创建线程的函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">makethread</span><span class="params">(<span class="type">void</span> *(*fn)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>				err;</span><br><span class="line">	<span class="type">pthread_t</span>		tid;</span><br><span class="line">	<span class="type">pthread_attr_t</span>	attr;</span><br><span class="line"></span><br><span class="line">	err = pthread_attr_init(&amp;attr);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(err);</span><br><span class="line">	err = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">	<span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">		err = pthread_create(&amp;tid, &amp;attr, fn, arg);</span><br><span class="line">	pthread_attr_destroy(&amp;attr);</span><br><span class="line">	<span class="keyword">return</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，此例忽略了<code>pthread_attr_destroy</code>函数调用的返回值。在这个实例中，我们对线程属性进行了合理的初始化，因此<code>pthread_attr_destroy</code>应该不会失败。但是，如果<code>pthread_attr_destroy</code>确实出现了失败的情况，将难以清理：必须销毁刚刚创建的线程，也许这个线程可能已经运行，并且与<code>pthread_attr_destroy</code>函数可能是异步执行的。忽略<code>pthread_attr_destroy</code>的错误返回可能出现的最坏情况是，如果<code>pthread_attr_init</code>已经分配了内存空间，就会有少量的内存泄漏。另一方面，如果<code>pthread_attr_init</code>成功地对线程属性进行了初始化，但之后<code>pthread_attr_ destroy</code>的清理工作失败，那么将没有任何补救策略，因为线程属性结构对应用程序来说是不透明的，可以对线程属性结构进行清理的唯一接口是<code>pthread_attr_destroy</code>，但它失败了。</p>
<p>可以在编译阶段使用<code>_POSIX_THREAD_ATTR_STACKADDR</code>和<code>_POSIX_THREAD_ATTR_STACKSIZE</code>符号来检查系统是否支持每一个线程栈属性。如果系统定义了这些符号中的一个，就说明它支持相应的线程栈属性。或者，也可以在运行阶段把<code>_SC_THREAD_ATTR_STACKADDR</code>和<code>_SC_THREAD_ATTR_STACKSIZE</code>参数传给<code>sysconf</code>函数，检查运行时系统对线程视属性的支持情况。</p>
<p>可以使用函数<code>pthread_attr_getstack</code>和<code>pthread_attr_setstack</code>对线程栈属性进行管理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstack</span> <span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span><br><span class="line"><span class="params">	<span class="type">void</span> **<span class="keyword">restrict</span> stackaddr,</span></span><br><span class="line"><span class="params">	<span class="type">size_t</span> *<span class="keyword">restrict</span> stacksize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstack</span> <span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *stackaddr, <span class="type">size_t</span> stacksize)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>对于进程来说，虚地址空间的大小是固定的。因为进程中只有一个栈，所以它的大小通常不是问题。但对于线程来说，同样大小的虚地址空间必须被所有的线程栈共享。如果应用程序使用了许多线程，以致这些线程栈的累计大小超过了可用的虚地址空间，就需要减少默认的线程栈大小。另一方面，如果线程调用的函数分配了：大量的自动变量，或者调用的函数涉及许多很深的栈帧(stack frame)，那么需要的栈大小可能要比默认的大。</p>
<p>如果线程栈的虚地址空间都用完了，那可以使用<code>malloc</code>或者<code>mmap</code>来为可替代的栈分配空间，并用<code>pthread_attr_setstack</code>函数来改变新建线程的栈位置。由<code>stackaddr</code>参数指定的地址可以用作线程栈的内存范围中的最低可寻址地址，该地址与处理器结构相应的边界应对齐。当然，这要假设<code>malloc</code>和<code>mmap</code>所用的虚地址范围与线程栈当前使用的虚地址范围不同。</p>
<p><code>stackaddr</code>线程属性被定义为栈的最低内存地址，但这并不一定是栈的开始位置。对于一个给定的处理器结构来说，如果栈是从高地址向低地址方向增长的，那么<code>stackaddr</code>线程属性将是栈的结尾位置，而不是开始位置。</p>
<p>应用程序也可以通过<code>pthread_attr_getstacksize</code>和<code>pthread_attr_setstacksize</code>函数读取或设置线程属性<code>stacksize</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstacksize</span> <span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span><br><span class="line"><span class="params">					<span class="type">size_t</span> *<span class="keyword">restrict</span> stacksize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstacksize</span> <span class="params">(<span class="type">pthread_attr_t</span> *addr, <span class="type">size_t</span> stacksize)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>如果希望改变默认的栈大小，但又不想自己处理线程栈的分配问题，这时使用<code>pthread_attr_setstacksize</code>函数就非常有用。设置<code>stacksize</code>属性时，选择的<code>stacksize</code>不能小于<code>PTHREAD_STACK_MIN</code>。</p>
<p>线程属性<code>guardsize</code>控制着线程栈未尾之后用以避免栈溢出的扩展内存的大小。可以把<code>guardsize</code>线程属性设置为0，不允许属性的这种特征行为发生，在这种情况下，不会提供警戒缓冲区。同样，如果修改了线程属性<code>stackaddr</code>，系统就认为我们将自己管理栈，使栈警戒缓冲区机制无效，这等同于把<code>guardsize</code>线程属性设置为0。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getquardsize</span> <span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="type">size_t</span> *<span class="keyword">restrict</span> guardsie)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setguardsize</span> <span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> guandsite)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回锖谟编号</span></span><br></pre></td></tr></table></figure></p>
<p>如果<code>guardsize</code>线程属性被修改了，操作系统可能会把它取为页大小的整数倍。如果线程的栈指针溢出到警戒区域，应用程序就可能通过信号接收到出错信息。</p>
<h2 id="同步属性"><a href="#同步属性" class="headerlink" title="同步属性"></a>同步属性</h2><h2 id="互斥量属性"><a href="#互斥量属性" class="headerlink" title="互斥量属性"></a>互斥量属性</h2><p>互斥量属性是用<code>pthread_mutexattr_t</code>结构表示的。对互斥量进行初始化时，可以通过使用<code>PTHREAD_MUTEX_INITIALIZER</code>常量或者用指向互斥量属性结构的空指针作为参数调用<code>pthread_mutex_init</code>函数，得到互斥量的默认属性。</p>
<p>对于非默认属性，可以用<code>pthread_mutexattr_init</code>初始化<code>pthread_mutexattr_t</code>结构，用<code>pthread_mutexattr_destroy</code>来反初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_init</span> <span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_destroy</span> <span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p><code>pthread_mutexattr_init</code>函数将用默认的互斥量属性初始化<code>pthread_mutexattr_t</code>结构。值得注意的3个属性是：进程共享属性、健壮属性以及类型属性。POSIX.1中，进程共享属性是可选的。可以通过检查系统中是否定义了<code>_POSIX_THREAD_PROCESS_SHARED</code>符号来判断这个平台是否支持进程共享这个属性，也可以在运行时把<code>_SC_THREAD_PROCESS_SHARED</code>参数传给<code>sysconf</code>函数进行检查。</p>
<p>在进程中，多个线程可以访问同一个同步对象，进程共享互斥量属性需设置为<code>PTHREAD_PROCESS_PRIVATE</code>。如果进程共享互斥量属性设置为<code>PTHREAD_PROCESS_SHARED</code>，从多个进程彼此之间共享的内存数据块中分配的互斥量就可以用于这些进程的同步。</p>
<p>可以使用<code>pthread_mutexattr_getpshared</code>函数查询<code>pthread_mutexattr_t</code>结构，得到它的进程共享属性，使用<code>pthread_mutexattr_ setpshared</code>函数修改进程共享属性。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_getpahared</span> <span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr, <span class="type">int</span> *<span class="keyword">restrict</span> prhared)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_setpshared</span> <span class="params">(<span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> pthared)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>进程共享互斥量属性设置为<code>PTHREAD_PROCESS_PRIVATE</code>时，允许pthread线程库提供更有效的互斥量实现，这在多线程应用程序中是默认的情况。在多个进程共享多个互斥量的情况下，pthread线程库可以限制开销较大的互斥量实现。</p>
<p>互斥量健壮属性与在多个进程间共享的互斥量有关。这意味着，当持有互斥量的进程终止时，需要解决互斥量状态恢复的问题。这种情况发生时，互斥量处于锁定状态，恢复起来很困难。其他阻塞在这个锁的进程将会一直阻塞下去，可以使用<code>pthread_mutexattr_getrobust</code>函数获取健壮的互斥量属性的值。可以调用<code>pthread_mutexattr_setrobust</code>函数设置健壮的互斥最属性的值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_getrobust</span> <span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr, <span class="type">int</span> *<span class="keyword">restrict</span> robust)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_setrobust</span> <span class="params">(<span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> robust)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>健壮属性取值有两种可能的情况。默认值是<code>PTHREAD_MUTEX_STALLED</code>，这意味着持有互斥量的进程终止时不需要采取特别的动作。这种情况下，使用互斥量后的行为是未定义的，等待该互斥量解锁的应用程序会被有效地“拖住”。另一个取值是<code>PTHREAD_MUTEX_ROBUST</code>。这个值将导致线程调用<code>pthread_mutex_lock</code>获取锁，而该锁被另一个进程持有，但它终止时并没有对该镇进行解锁，此时线程会阻塞，从<code>pthread_mutex_lock</code>返回的值为<code>EOWNERDEAD</code>而不是0。</p>
<p>使用健壮的互斥量改变了我们使用<code>pthread_mutex_lock</code>的方式，因为现在必须检查3个返回值而不是之前的两个：不需要恢复的成功、需要恢复的成功以及失败。但是，即使不用健壮的互斥量，也可以只检查成功或者失败。</p>
<p>如果应用状态无法恢复，在线程对互斥量解锁以后，该互斥量将处于永久不可用状态。为了避免这样的问题，线程可以调用<code>pthread_mutex_consistent</code>函数，指明与该互斥量相关的状态在互斥量解锁之前是一致的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_consistent</span> <span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>如果线程没有先调用<code>pthread_mutex_consistent</code>就对互斥最进行了解锁，那么其他试图获取该互斥最的阻塞线程就会得到错误码<code>ENOTRECOVERABLE</code>。如果发生这种情况，互斥量将不再可用。线程通过提前调用<code>pthread_mutex_consistent</code>，能让互斥量正常工作，这样它就<br>可以持续被使用。</p>
<p><strong>类型互斥量</strong>属性控制着互斥量的锁定特性。POSIX.1定义了4种类型：</p>
<ul>
<li><code>PTHREAD_MUTEX_NORMAL</code>：标准互斥量类型，不做任何特殊的错误检查或死锁检测。</li>
<li><code>PTHREAD_MUTEX_ERRORCHECK</code>：此互斥量类型提供错误检查。</li>
<li><code>PTHREAD_MUTEX_RECURSIVE</code>：此互斥量类型允许同一线程在互斥量解锁之前对该互斥量进行多次加锁。递归互斥量维护锁的计数，在解锁次数和加锁次数不相同的情况下，不会释放锁。所以，如果对一个递归互斥量加锁两次，然后解锁一次，那么这个互斥量将依然处于加锁状态，对它再次解锁以前不能释放该锁。</li>
<li><code>PTHREAD_MUTEX_DEFAULT</code>：此互斥量类型可以提供默认特性和行为。操作系统在实现它的时候可以把这种类型自由地映射到其他互斥量类型中的一种。</li>
</ul>
<p>这4种类型的行为如表所示。”不占用时解锁”这一栏指的是，一个线程对被另一个线程加锁的互斥量进行解锁的情况。“在已解锁时解锁”这一栏指的是， 当一个线程对已经解锁的互斥量进行解锁时将会发生什么，这通常是编码错误引起的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>互斥量类型</th>
<th>没有解锁时重新加镇?</th>
<th>不占用时解锁?</th>
<th>在已解锁时解锁?</th>
</tr>
</thead>
<tbody>
<tr>
<td>PTHREAD_MUTEX_NORMAL</td>
<td>死锁</td>
<td>未定义</td>
<td>未定义</td>
</tr>
<tr>
<td>PTHREAD_MUTEX_ERRORCHECK</td>
<td>返回错误</td>
<td>返回错误</td>
<td>返回错误</td>
</tr>
<tr>
<td>PTHREAD_MUTEX RECURSIVE</td>
<td>允许</td>
<td>返回错误</td>
<td>返回错误</td>
</tr>
<tr>
<td>PTHREAD_MUTEX_DEFAULT</td>
<td>未定义</td>
<td>未定义</td>
<td>未定义</td>
</tr>
</tbody>
</table>
</div>
<p>可以用<code>pthread_mutexattr_gettype</code>函数得到互斥量类型属性，用<code>pthread_mutexattr_settype</code>函数修改互斥量类型属性。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_gettype</span> <span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr, <span class="type">int</span> *<span class="keyword">restrict</span> type)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_settype</span> <span class="params">(<span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> type)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>如果递归互斥量被多次加锁，然后用在调用<code>pthread_cond_wait</code>函数中，那么条件永远都不会得到满足，因为<code>pthread_cond_wait</code>所做的解锁操作并不能释放互斥量。如果需要把现有的单线程接口放到多线程环境中，递归互斥量是非常有用的，但由于现有程序兼容性的限制，不能对函数接口进行修改。然而，使用递归锁可能很难处理，因此应该只在没有其他可行方案的时候才使用它们。</p>
<p>程序解释了有必要使用递归互斥量的另一 种情况。这里，有一个“超时”(timeout)函数，它允许安排另一个函数在未来的某个时间运行。假设线程并不是很昂贵的资源，就可以为每个挂起的超时函数创建一个线程。线程在时间来到时将一 直等待，时间到了以后再调用请求的函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">makethread</span><span class="params">(<span class="type">void</span> *(*)(<span class="type">void</span> *), <span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">to_info</span> &#123;</span></span><br><span class="line">	<span class="type">void</span>	      (*to_fn)(<span class="type">void</span> *);	<span class="comment">/* function */</span></span><br><span class="line">	<span class="type">void</span>           *to_arg;			<span class="comment">/* argument */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">to_wait</span>;</span>		<span class="comment">/* time to wait */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECTONSEC  1000000000	<span class="comment">/* seconds to nanoseconds */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CLOCK_REALTIME) || defined(BSD)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clock_nanosleep(ID, FL, REQ, REM)	nanosleep((REQ), (REM))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CLOCK_REALTIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOCK_REALTIME 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USECTONSEC 1000		<span class="comment">/* microseconds to nanoseconds */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">clock_gettime</span><span class="params">(<span class="type">int</span> id, <span class="keyword">struct</span> timespec *tsp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line">	gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">	tsp-&gt;tv_sec = tv.tv_sec;</span><br><span class="line">	tsp-&gt;tv_nsec = tv.tv_usec * USECTONSEC;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">timeout_helper</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">to_info</span>	*<span class="title">tip</span>;</span></span><br><span class="line"></span><br><span class="line">	tip = (<span class="keyword">struct</span> to_info *)arg;</span><br><span class="line">	clock_nanosleep(CLOCK_REALTIME, <span class="number">0</span>, &amp;tip-&gt;to_wait, <span class="literal">NULL</span>);</span><br><span class="line">	(*tip-&gt;to_fn)(tip-&gt;to_arg);</span><br><span class="line">	<span class="built_in">free</span>(arg);</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">timeout</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> timespec *when, <span class="type">void</span> (*func)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>	<span class="title">now</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">to_info</span>	*<span class="title">tip</span>;</span></span><br><span class="line">	<span class="type">int</span>				err;</span><br><span class="line"></span><br><span class="line">	clock_gettime(CLOCK_REALTIME, &amp;now);</span><br><span class="line">	<span class="keyword">if</span> ((when-&gt;tv_sec &gt; now.tv_sec) ||</span><br><span class="line">	  (when-&gt;tv_sec == now.tv_sec &amp;&amp; when-&gt;tv_nsec &gt; now.tv_nsec)) &#123;</span><br><span class="line">		tip = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> to_info));</span><br><span class="line">		<span class="keyword">if</span> (tip != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			tip-&gt;to_fn = func;</span><br><span class="line">			tip-&gt;to_arg = arg;</span><br><span class="line">			tip-&gt;to_wait.tv_sec = when-&gt;tv_sec - now.tv_sec;</span><br><span class="line">			<span class="keyword">if</span> (when-&gt;tv_nsec &gt;= now.tv_nsec) &#123;</span><br><span class="line">				tip-&gt;to_wait.tv_nsec = when-&gt;tv_nsec - now.tv_nsec;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				tip-&gt;to_wait.tv_sec--;</span><br><span class="line">				tip-&gt;to_wait.tv_nsec = SECTONSEC - now.tv_nsec +</span><br><span class="line">				  when-&gt;tv_nsec;</span><br><span class="line">			&#125;</span><br><span class="line">			err = makethread(timeout_helper, (<span class="type">void</span> *)tip);</span><br><span class="line">			<span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">free</span>(tip);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We get here if (a) when &lt;= now, or (b) malloc fails, or</span></span><br><span class="line"><span class="comment">	 * (c) we can&#x27;t make a thread, so we just call the function now.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	(*func)(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutexattr_t</span> attr;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">retry</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* perform retry steps ... */</span></span><br><span class="line"></span><br><span class="line">	pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>				err, condition, arg;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>	<span class="title">when</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((err = pthread_mutexattr_init(&amp;attr)) != <span class="number">0</span>)</span><br><span class="line">		err_exit(err, <span class="string">&quot;pthread_mutexattr_init failed&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((err = pthread_mutexattr_settype(&amp;attr,</span><br><span class="line">	  PTHREAD_MUTEX_RECURSIVE)) != <span class="number">0</span>)</span><br><span class="line">		err_exit(err, <span class="string">&quot;can&#x27;t set recursive type&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((err = pthread_mutex_init(&amp;mutex, &amp;attr)) != <span class="number">0</span>)</span><br><span class="line">		err_exit(err, <span class="string">&quot;can&#x27;t create recursive mutex&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* continue processing ... */</span></span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Check the condition under the protection of a lock to</span></span><br><span class="line"><span class="comment">	 * make the check and the call to timeout atomic.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (condition) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Calculate the absolute time when we want to retry.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		clock_gettime(CLOCK_REALTIME, &amp;when);</span><br><span class="line">		when.tv_sec += <span class="number">10</span>;	<span class="comment">/* 10 seconds from now */</span></span><br><span class="line">		timeout(&amp;when, retry, (<span class="type">void</span> *)((<span class="type">unsigned</span> <span class="type">long</span>)arg));</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* continue processing ... */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们不能创建线程，或者安排函数运行的时间已过，这时问题就出现了。在这些情况下，我们只需在当前上下文中调用之前请求运行的函数。因为函数要获取的愤和我们现在占有的锁是同一个，所以除非该锁是递归的，否则就会出现死锁。</p>
<p>我们使用<code>makethread</code>函数以分离状态创建线程，因为传递给<code>timeout</code>函数的<code>func</code>函数参数将在未来运行，所以我们不希望一直空等线程结束。可以调用<code>sleep</code>等待超时到期，但它提供的时间粒度是秒级的。如果希望等待的时间不是整数秒，就需要用<code>nanosleep</code>或者<code>clock_nanosleep</code>函数，它们两个提供了更高精度的休眠时间。</p>
<h3 id="读写锁属性"><a href="#读写锁属性" class="headerlink" title="读写锁属性"></a>读写锁属性</h3><p>读写锁与互斥量类似，也是有属性的。可以用<code>pthread_rwlockattr_init</code>初始化<code>pthread_rwlockattr_t</code>结构，用<code>pthread_rwlockattr_destroy</code>反初始化该结构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlockattr_init</span> <span class="params">(<span class="type">pthread_rwlockattr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlockattr_deatroy</span> <span class="params">(<span class="type">pthread_rwlockattr_t</span> *attr)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>读写锁支持的唯一属性是进程共享属性。它与互斥量的进程共享属性是相同的。就像互斥量的进程共享属性一样，有一对函数用于读取和设置读写锁的进程共享属性。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlockattr_getpshared</span> <span class="params">(<span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr, <span class="type">int</span> *<span class="keyword">restrict</span> pshared)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlockattr_setpshared</span> <span class="params">(<span class="type">pthread_rwlockattr_t</span> *attr, <span class="type">int</span> pshared)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<h3 id="条件变量属性"><a href="#条件变量属性" class="headerlink" title="条件变量属性"></a>条件变量属性</h3><p>目前定义了条件变量的两个属性：进程共享属性和时钟属性。与其他的属性对象一样，有一对函数用于初始化和反初始化条件变量属性。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_condattr_init</span> <span class="params">(<span class="type">pthread_condattr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_condattr_destroy</span> <span class="params">(<span class="type">pthread_condattr_t</span> *attr)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>与其他的同步属性一样，条件变量支持进程共享属性。它控制着条件变量是可以被单进程的多个线程使用，还是可以被多进程的线程使用。要获取进程共享属性的当前值，可以用<code>pthread_condattr_getpshared</code>函数。设置该值可以用<code>pthread_condattr_setpshared</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_condattr_getpshared</span> <span class="params">(<span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr, <span class="type">int</span> *<span class="keyword">restrict</span> pshared)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_condattr_setpshared</span> <span class="params">(<span class="type">pthread_condattr_t</span> *attr, <span class="type">int</span> pshared)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>时钟属性控制计算<code>pthread_cond_timedwait</code>函数的超时参数(<code>tspr</code>)时采用的是哪个时钟。可以使用<code>pthread_condattr_getclock</code>函数获取可被用于<code>pthread_cond_timedwait</code>函数的时钟ID，在使用<code>pthread_cond_timedwait</code>函数前需要用<code>pthread_condattr_t</code>对象对条件变量进行初始化。可以用<code>pthread_condattr_setclock</code>函数对时钟ID进行修改。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> epthread.h&gt;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_condattr_getclock</span> <span class="params">(<span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr, <span class="type">clockid_t</span> *<span class="keyword">restrict</span> clock_id)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_condattr_setclock</span> <span class="params">(<span class="type">pthread_condattr_t</span> *attr, <span class="type">clockid_t</span> clock_d)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值；若成功，返回0；否则，返回镨误编号</span></span><br></pre></td></tr></table></figure></p>
<h3 id="屏障属性"><a href="#屏障属性" class="headerlink" title="屏障属性"></a>屏障属性</h3><p>屏障也有属性。可以使用<code>pthread_barrierattr_init</code>函数对屏障属性对象进行初始化，用<code>pthread_barrierattr_destroy</code>函数对屏障属性对象进行反初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_barrierattr_init</span> <span class="params">(pthread_barrier *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_barrierattr_destroy</span> <span class="params">(<span class="type">pthread_barrierattr_t</span> *attr)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>目前定义的屏障属性只有进程共享属性，它控制着屏障是可以被多进程的线程使用，还是只能被初始化屏障的进程内的多线程使用。与其他属性对象一样，有一个获取属性值的函数(<code>pthread_barrierattr_getpshared</code>)和一个设置属性值的函数(<code>pthread_barrierattr_setpshared</code>)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_barrierattr_getpshared</span> <span class="params">(<span class="type">const</span> pthread_barrier *<span class="keyword">restrict</span> attr, <span class="type">int</span> *<span class="keyword">restrict</span> pthared)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_barrierattr_setpshared</span> <span class="params">(<span class="type">pthread_barrierattr_t</span> *attr, <span class="type">int</span> pshared)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>进程共享属性的值可以是<code>PTHREAD_PROCESS_SHARED</code>(多进程中的多个线程可用)，也可以是<code>PTHREAD_PROCESS_PRIVATE</code>(只有初始化屏障的那个进程内的多个线程可用)。</p>
<h2 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h2><p>如果一个函数在相同的时间点可以被多个线程安全地调用，就称该函数是<strong>线程安全</strong>的。除了图中列出的函数，其他函数都保证是线程安全的。<br><img src="/img/1622445555.jpg" alt=""></p>
<p>另外，<code>ctermid</code>和<code>tmpnam</code>函数在参数传入空指针时并不能保证是线程安全的。类似地。如果参数<code>mbstate_t</code>传入的是空指针，也不能保证<code>wertomb</code>和<code>wcsrtombs</code>函数是线程安全的。</p>
<p>支持线程安全函数的操作系统实现会在<code>&lt;unistd.h&gt;</code>中定义符号<code>_POSIX_THREAD_SAFE_FUNCTIONS</code>。应用程序也可以在<code>sysconf</code>函数中传入<code>_SC_THREAD_SAFE_FUNCTIONS</code>参数在运行时检查是否支持线程安全函数。</p>
<p>操作系统实现支持线程安全函数这个特性时，对POSIX.1中的一些非线程安全函数，它会提供可替代的线程安全版本，图中列出了这些函数的线程安全版本。这些函数的命名方式与它们的非线程安全版本的名字相似，只不过在名字最后加了<code>_r</code>，表明这些版本是可重入的。很多函数并不是线程安全的，因为它们返回的数据存放在静态的内存缓冲区中。通过修改接口，要求调用者自己提供缓冲区可以使函数变为线程安全。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>线程安全函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>getgrgid_r</td>
</tr>
<tr>
<td>localtime_r</td>
</tr>
<tr>
<td>getgrnam_r</td>
</tr>
<tr>
<td>readdir_r</td>
</tr>
<tr>
<td>getlogin_r</td>
</tr>
<tr>
<td>strerror_r</td>
</tr>
<tr>
<td>getpwnam_r</td>
</tr>
<tr>
<td>strtok_z</td>
</tr>
<tr>
<td>getpwuid_r</td>
</tr>
<tr>
<td>ttynane_r</td>
</tr>
<tr>
<td>gmtime_r</td>
</tr>
</tbody>
</table>
</div>
<p>如果函数对异步信号处理程序的重入是安全的，那么就可以说函数是异步信号安全的。</p>
<p>POSIX.1还提供了以线程安全的方式管理<code>FILE</code>对象的方法。可以使用<code>flockfile</code>和<code>ftrylockfile</code>获取给定<code>FILE</code>对象关联的锁。这个锁是递归的：当你占有这把锁的时候，还是可以再次获取该锁，而且不会导致死锁。虽然这种锁的具体实现并无规定，但要求所有操作<code>FILE</code>对象的标准例程的动作行为必须看起来就像它们内部调用了<code>flockfile</code>和<code>funlockfile</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ftrylockfile</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若不能获取，返回非0数值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">flocktile</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">funlockfile</span> <span class="params">(FTLE *fp)</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果标准例程都获取它们各自的锁，那么在做一次一个字符的I/O时就会出现严重的性能下降。在这种情况下，需要对每一个字符的读写操作进行获取锁和释放锁的动作。为了避免这种开销，出现了不加锁版本的基于字符的标准I/O例程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getchar_unlocked</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getc_unlocked</span> <span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回下一个字符，若遇到文件尾或者出错，返回EOF</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putchar_unlocked</span><span class="params">(<span class="type">int</span> e)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putc_unlocked</span><span class="params">(<span class="type">int</span> e, FILE *fp)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回c；若出错，返回BOF</span></span><br></pre></td></tr></table></figure></p>
<p>除非被<code>flockfile</code>(或<code>ftrylockfile</code>)和<code>funlockfile</code>的调用包围，否则尽量不要调用这4个函数，因为它们会导致不可预期的结果(比如，由于多个控制线程非同步访问数据引起的种种问题)。一旦对FILE对象进行加锁，就可以在释放锁之前对这些函数进行多次调用。这样就可以在多次的数据读写上分摊总的加解锁的开销。</p>
<p>给出了<code>getenv</code>的可重入的版本。这个版本叫做<code>getenv_r</code>。它使用<code>pthread_once</code>函数来确保不管多少线程同时竞争调用<code>getenv_r</code>，每个进程只调用<code>thread_init</code>函数一次。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> env_mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_once_t</span> init_done = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">thread_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pthread_mutexattr_t</span> attr;</span><br><span class="line"></span><br><span class="line">	pthread_mutexattr_init(&amp;attr);</span><br><span class="line">	pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">	pthread_mutex_init(&amp;env_mutex, &amp;attr);</span><br><span class="line">	pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">getenv_r</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">char</span> *buf, <span class="type">int</span> buflen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, len, olen;</span><br><span class="line"></span><br><span class="line">	pthread_once(&amp;init_done, thread_init);</span><br><span class="line">	len = <span class="built_in">strlen</span>(name);</span><br><span class="line">	pthread_mutex_lock(&amp;env_mutex);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; environ[i] != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="built_in">strncmp</span>(name, environ[i], len) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">		  (environ[i][len] == <span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">			olen = <span class="built_in">strlen</span>(&amp;environ[i][len+<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">if</span> (olen &gt;= buflen) &#123;</span><br><span class="line">				pthread_mutex_unlock(&amp;env_mutex);</span><br><span class="line">				<span class="keyword">return</span>(ENOSPC);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">strcpy</span>(buf, &amp;environ[i][len+<span class="number">1</span>]);</span><br><span class="line">			pthread_mutex_unlock(&amp;env_mutex);</span><br><span class="line">			<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(&amp;env_mutex);</span><br><span class="line">	<span class="keyword">return</span>(ENOENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要使<code>getenv_r</code>可重入，需要改变接口，调用者必须提供它自己的缓冲区，这样每个线程可以使用各自不同的缓冲区避免其他线程的干扰。但是，注意，要想使<code>getenv_r</code>成为线程安全的，这样做还不够，需要在搜索请求的字符时保护环境不被修改。可以使用互斥量，通过<code>getenv_r</code>和<code>putenv</code>函数对环境列表的访问进行串行化。</p>
<p>可以使用读写锁，从而允许对<code>getenv_r</code>进行多次并发访问，但增加的并发性可能并不会在很大程度上改善程序的性能，这里面有两个原因第一，环境列表通常并不会很长，所以扫描列表时并不需要长时间地占有互斥量；第二，对<code>getenv</code>和<code>putenv</code>的调用也不是频繁发生的，所以改善它们的性能并不会对程序的整体性能产生很大的影响。</p>
<p>即使可以把<code>getenv_r</code>变成线程安全的，这也不意味着它对信号处理程序是可重入的。如果使用的是非递归的互斥量，线程从信号处理程序中调用<code>getenv_r</code>就有可能出现死锁。如果信号处理程序在线程执行<code>getenv_r</code>时中断了该线程，这时我们已经占有加锁的<code>env_mutex</code>，这样其他线程试图对这个互斥量的加锁就会被阻塞，最终导致线程进入死锁状态。所以，必须使用递归互斥量阻止其他线程改变我们正需要的数据结构，还要阻止来自信号处理程序的死锁。</p>
<h2 id="线程特定数据"><a href="#线程特定数据" class="headerlink" title="线程特定数据"></a>线程特定数据</h2><p><strong>线程特定数据</strong>(thread-specific data), 也称为线程私有数据(thread-private data)，是存储和查询某个特定线程相关数据的一种机制。我们希望每个线程可以访问它自己单独的数据副本，而不需要担心与其他线程的同步访问问题。</p>
<p>线程模型促进了进程中数据和属性的共享，许多人在设计线程模型时会遇到各种麻烦。那么为什么有人想在这样的模型中促进阻止共享的接口呢?这其中有两个原因。</p>
<ul>
<li>有时候需要维护基于每线程(per-bread)的数据。因为线程ID并不能保证是小而连续的整数，所以就不能简单地分配一个每线程数据数组，用线程ID作为数组的索引。</li>
<li>它提供了让基于进程的接口适应多线程环境的机制。系统调用和库例程在调用或执行失败时设置<code>errno</code>，为了让线程也能够使用那些原本基于进程的系统调用和库例程，<code>errno</code>被重新定义为线程私有数据。这样，一个线程做了重置<code>errno</code>的操作也不会影响进程中其他线程的<code>errno</code>值。</li>
</ul>
<p>在分配线程特定数据之前，需要创建与该数据关联的键。这个键将用于获取对线程特定数据的访问。使用<code>pthread_key_create</code>创建一个键<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_create</span> <span class="params">(<span class="type">pthread_key_t</span> *keyp, <span class="type">void</span> (*destructor) (<span class="type">void</span> *))</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>创建的键存储在<code>keyp</code>指向的内存单元中，这个键可以被进程中的所有线程使用，但每个线程把这个键与不同的线程特定数据地址进行关联。创建新键时，每个线程的数据地址设为空值。除了创建键以外，<code>pthread_key_create</code>可以为该键关联一个可选择的析构函数。当这个线程退出时，如果数据地址已经被置为非空值，那么析构函数就会被调用，它唯一的参数就是该数据地址。如果传入的析构函数为空，就表明没有析构函数与这个键关联。当线程调用<code>pthread_exit</code>或者线程执行返回，正常退出时，析构函数就会被调用。同样，线程取消时，只有在最后的清理处理程序返回之后，析构函数才会被调用。如果线程调用了<code>exit</code>、<code>_exit</code>、<code>_Exit</code>或<code>abort</code>，或者出现其他非正常的退出时，就不会调用析构函数。</p>
<p>线程通常使用<code>malloc</code>为线程特定数据分配内存，析构函数通常释放已分配的内存。如果线程在没有释放内存之前就退出了，那么这块内存就会丢失，即线程所属进程就出现了内存泄漏。</p>
<p>线程退出时，线程特定数据的析构函数将按照操作系统实现中定义的顺序被调用。析构函数可能会调用另一个函数，该函数可能会创建新的线程特定数据，并且把这个数据与当前的键关联起来。当所有的析构函数都调用完成以后，系统会检查是否还有非空的线程特定数据值与键关联，如果有的话，再次调用析构函数。这个过程将会一直重复直到线程所有的键都为空线程特定数据值，或者已经做了<code>PTHREAD_DESTRUCTOR_LITERATIONS</code>中定义的最大次数的尝试。</p>
<p>对所有的线程，我们都可以通过调用<code>pthread_key_delete</code>来取消键与线程特定数据值之间的关联关系。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_delete</span> <span class="params">(<span class="type">pthreed_key_t</span> key)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>注意，调用<code>pthread_key_delete</code>并不会激活与键关联的析构函数。要释放任何与键关联的线程特定数据值的内存，需要在应用程序中采取额外的步骤。</p>
<p>需要确保分配的键并不会由于在初始化阶段的竞争而发生变动。下面的代码会导致两个线程都调用<code>pthread_key_create</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">destructor</span> <span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_key_t</span> key;</span><br><span class="line"><span class="type">int</span> init_done = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadfunc</span> <span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (!init_done) &#123;</span><br><span class="line">		init_done = <span class="number">1</span>;</span><br><span class="line">		err = pthread_key_create (&amp;key, destructor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有些线程可能看到一个键值，而其他的线程看到的可能是另一个不同的键值，这取决于系统是如何调度线程的，解决这种竞争的办法是使用<code>pthread_once</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_once_t</span> iniflag = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_once</span> <span class="params">(<span class="type">pthread_once_t</span> *initflag, <span class="type">void</span> (*inifn(<span class="type">void</span>));</span></span><br><span class="line"><span class="params"><span class="comment">// 返回值：若成功，返回0；否则，返回错误编号</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>initflag</code>必须是一个非本地变量(如全局变量或静态变量)，而且必须初始化为<code>PTHREAD_ONCE_INIT</code>。</p>
<p>如果每个线程都调用<code>pthread_once</code>，系统就能保证初始化例程<code>initfn</code>只被调用一次，即系统首次调用<code>pthread_once</code>时。创建键时避免出现冲突的一个正确方法如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">destructor</span> <span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_key_t</span> key;</span><br><span class="line"><span class="type">pthreed_once_t</span> init_done = PTHREAD_ONCE_INTT;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="built_in">exit</span> = pthread_key_create(&amp;key, destructor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">threadfunc</span> <span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	pthread_once(&amp;init_done, thread_init);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>键一旦创建以后，就可以通过调用<code>pthread_setspecific</code>函数把键和线程特定数据关联起来。可以通过<code>pthread_getspecific</code>函数获得线程特定数据的地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">pthread_getspecitic</span> <span class="params">(<span class="type">pthread_key_t</span> key)</span>;</span><br><span class="line"><span class="comment">// 返回值，线程特定数据值，若没有值与该键关联，返回NULL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setspecific</span> <span class="params">(<span class="type">pthread_key_t</span> key, <span class="type">const</span> <span class="type">void</span> *value)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>如果没有线程特定数据值与键关联，<code>pthread_getspecific</code>将返回一个空指针，我们可以用这个返回值来确定是否需要调用<code>pthread_setspecific</code>。</p>
<p>可以使用线程特定数据来维护每个线程的数据缓冲区副本，用于存放各自的返回字符串。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTRINGSZ	4096</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_key_t</span> key;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_once_t</span> init_done = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="type">pthread_mutex_t</span> env_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">thread_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	pthread_key_create(&amp;key, <span class="built_in">free</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *</span><br><span class="line"><span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		i, len;</span><br><span class="line">	<span class="type">char</span>	*envbuf;</span><br><span class="line"></span><br><span class="line">	pthread_once(&amp;init_done, thread_init);</span><br><span class="line">	pthread_mutex_lock(&amp;env_mutex);</span><br><span class="line">	envbuf = (<span class="type">char</span> *)pthread_getspecific(key);</span><br><span class="line">	<span class="keyword">if</span> (envbuf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		envbuf = <span class="built_in">malloc</span>(MAXSTRINGSZ);</span><br><span class="line">		<span class="keyword">if</span> (envbuf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			pthread_mutex_unlock(&amp;env_mutex);</span><br><span class="line">			<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		pthread_setspecific(key, envbuf);</span><br><span class="line">	&#125;</span><br><span class="line">	len = <span class="built_in">strlen</span>(name);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; environ[i] != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="built_in">strncmp</span>(name, environ[i], len) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">		  (environ[i][len] == <span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">			<span class="built_in">strncpy</span>(envbuf, &amp;environ[i][len+<span class="number">1</span>], MAXSTRINGSZ<span class="number">-1</span>);</span><br><span class="line">			pthread_mutex_unlock(&amp;env_mutex);</span><br><span class="line">			<span class="keyword">return</span>(envbuf);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(&amp;env_mutex);</span><br><span class="line">	<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们使用<code>pthread_once</code>来确保只为我们将使用的线程特定数据创建一个键。如果<code>pthread_getspecific</code>返回的是空指针，就需要先分配内存缓冲区，然后再把键与该内存缓冲区关联。否则，如果返回的不是空指针，就使用<code>pthread_getspecific</code>返回的内存缓冲区。</p>
<p>对析构函数，使用<code>free</code>来释放之前由<code>malloc</code>分配的内存。只有当线程特定数据值为非空时，析构函数才会被调用。</p>
<h2 id="取消选项"><a href="#取消选项" class="headerlink" title="取消选项"></a>取消选项</h2><p>有两个线程属性并没有包含在<code>pthread_attr_t</code>结构中，它们是可取消状态和可取消类型。这两个属性影响着线程在响应<code>pthread_cancel</code>函数调用时所呈现的行为。</p>
<p>可取消状态属性可以是<code>PTHREAD_CANCEL_ENABLE</code>，也可以是<code>PTHREAD_CANCEL_DISABLE</code>。线程可以通过调用<code>pthread_setcancelstate</code>修改它的可取消状态。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcancelstate</span> <span class="params">(<span class="type">int</span> state, <span class="type">int</span> *oldstate)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p><code>pthread_setcancelstate</code>把当前的可取消状态设置为state，把原来的可取消状态存储在由oldstare指向的内存单元，这两步是一个原子操作。</p>
<p>线程启动时默认的可取消状态是<code>PTHREAD_CANCEL_ENABLE</code>。当状态设为<code>PTHREAD_CANCEL_DISABLE</code>时，对<code>pthread_cancel</code>的调用并不会杀死线程。相反，取消请求对这个线程来说还处于挂起状态，当取消状态再次变为<code>PTHREAD_CANCEL_ENABLE</code>时，线程将在下一个取消点上对所有挂起的取消请求进行处理。</p>
<p>可以调用<code>pthread_testcancel</code>函数在程序中添加自己的取消点。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_testcancel</span> <span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>调用<code>pthread_testcancel</code>时，如果有某个取消请求正处于挂起状态，而且取消并没有置为无效，那么线程就会被取消。但是，如果取消被置为无效，<code>pthread_testcancel</code>调用就没有任何效果了。</p>
<p>我们所描述的默认的取消类型也称为推迟取消。调用<code>pthread_cancel</code>以后，在线程到达取消点之前，并不会出现真正的取消。可以通过调用<code>pthread_setcanceltype</code>来修改取消类型。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.b&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> tyye, <span class="type">int</span> *oldtype)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p><code>pthread_setcanceltype</code>函数把取消类型设置为<code>type</code>(类型参数可以是<code>PTHREADCANCEL_DEFERRED</code>，也可以是<code>PTHREAD_CANCEL_ASYNCKRONOUS</code>)，把原来的取消类型返回到<code>oldype</code>指向的整型单元。</p>
<p>异步取消与推迟取消不同，因为使用异步取消时，线程可以在任意时间撒消，不是非得遇到取消点才能被取消。</p>
<h2 id="线程和信号"><a href="#线程和信号" class="headerlink" title="线程和信号"></a>线程和信号</h2><p>每个线程都有自己的信号屏蔽字，但是信号的处理是进程中所有线程共享的。这意味着单个线程可以阻止某些信号，但当某个线程修改了与某个给定信号相关的处理行为以后，所有的线程都必须共享这个处理行为的改变。这样，如果一个线程选择忽略某个给定信号，那么另一个线程就可以通过以下两种方式撤消上述线程的信号选择：恢复信号的默认处理行为，或者为信号设置个新的信号处理程序。</p>
<p>进程中的信号是递送到单个线程的。如果一个信号与硬件故障相关，那么该信号一般会被发送到引起该事件的线程中去，而其他的信号则被发送到任意一个线程。</p>
<p>10.12节讨论了进程如何使用<code>sigprocmask</code>函数来阻止信号发送。然而，<code>sigprocmask</code>的行为在多线程的进程中并没有定义，线程必须使用<code>pthread_sigmask</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_sigmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="type">sigset_t</span> *<span class="keyword">restrict</span> oset)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0：否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p><code>pthread_sigmask</code>函数与<code>sigprocmask</code>函数基本相同，不过<code>pthread_sigmask</code>工作在线程中，而且失败时返回错误码，不再像<code>sigprocmask</code>中那样设置<code>errno</code>并返回-1，<code>set</code>参数包含线程用于修改信号屏蔽字的信号集。<code>how</code>参数可以取下列3个值之一：</p>
<ul>
<li><code>SIG_BLOCK</code>，把信号集添加到线程信号屏蔽字中，</li>
<li><code>SIG_SETMASK</code>，用信号集替换线程的信号屏蔽字，</li>
<li><code>SIG_UNBLOCK</code>，从线程信号屏蔽字中移除信号集。</li>
</ul>
<p>如果<code>oset</code>参数不为空，线程之前的信号屏蔽字就存储在它指向的<code>sigset_t</code>结构中。线程可以通过把<code>set</code>参数设置为NULL，并把<code>oset</code>参数设置为<code>sigset_t</code>结构的地址，来获取当前的信号屏蔽字。这种情况中的<code>how</code>参数会被忽略。</p>
<p>线程可以通过调用<code>sigwait</code>等待一个或多个信号的出现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigwait</span> <span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="type">int</span> *<span class="keyword">restrict</span> signop)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p><code>set</code>参数指定了线程等待的信号集。返回时，<code>signop</code>指向的整数将包含发送信号的数量。如果信号集中的某个信号在<code>sigwait</code>调用的时候处于挂起状态，那么<code>sigwait</code>将无阻塞地返回。在返回之前，<code>sigwait</code>将从进程中移除那些处于挂起等待状态的信号。如果具体实现支持捧队信号，并且信号的多个实例被挂起，那么<code>sigwait</code>将会移除该信号的一个实例，其他的实例还要继续捧队。</p>
<p>为了避免错误行为发生，线程在调用<code>sigwait</code>之前，必须阻塞那些它正在等待的信号。<code>sigwait</code>函数会原子地取消信号集的阻塞状态，直到有新的信号被递送。在返回之前，<code>sigwait</code>将恢复线程的信号屏蔽字。如果信号在<code>sigwait</code>被调用的时候没有被阻塞，那么在线程完成对<code>sigwait</code>的调用之前会出现一个时间窗，在这个时间窗中，信号就可以被发送给线程。使用<code>sigwait</code>的好处在于它可以简化信号处理，允许把异步产生的信号用同步的方式处理。</p>
<p>为了防止信号中断线程，可以把信号加到每个线程的信号屏蔽字中。然后可以安排专用线程处理信号。这些专用线程可以进行函数调用，不需要担心在信号处理程序中调用哪些函数是安全的，因为这些函数调用来自正常的线程上下文，而非会中断线程正常执行的传统信号处理程序。如果多个线程在<code>sigwait</code>的调用中因等待同一个信号而阻塞，那么在信号递送的时候，就只有一个线程可以从<code>sigwait</code>中返回。如果一个信号被捕获，而且一个线程正在<code>sigwait</code>调用中等待同一信号，那么这时将由操作系统实现来决定以何种方式递送信号。操作系统实现可以让<code>sigwait</code>返回，也可以激活信号处理程序，但这两种情况不会同时发生。</p>
<p>要把信号发送给进程，可以调用<code>kill</code>。要把信号发送给线程，可以调用<code>pthread_kill</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_kill</span> <span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> signo)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>可以传一个0值的<code>signo</code>来检查线程是否存在。如果信号的默认处理动作是终止该进程，那么把信号传递给某个线程仍然会杀死整个进程。</p>
<p>注意，闹钟定时器是进程资源，并且所有的线程共享相同的闹钟。所以，进程中的多个线程不可能互不干扰(或互不合作)地使用闹钟定时器。</p>
<h2 id="线程和fork"><a href="#线程和fork" class="headerlink" title="线程和fork"></a>线程和fork</h2><p>当线程调用<code>fork</code>时，就为子进程创建了整个进程地址空间的副本。子进程通过继承整个地址空间的副本，还从父进程那儿继承了每个互斥量、读写锁和条件变量的状态。如果父进程包含一个以上的线程，子进程在<code>fork</code>返回以后，如果紧接着不是马上调用<code>exec</code>的话，就需要清理锁状态。</p>
<p>在子进程内部，只存在一个线程，它是由父进程中调用<code>fork</code>的线程的副本构成的。如果父进程中的线程占有锁，子进程将同样占有这些锁。问题是子进程并不包含占有锁的线程的副本，所以子进程没有办法知道它占有了哪些锁、需要释放哪些锁。如果子进程从<code>fork</code>返回以后马上调用其中一个<code>exec</code>函数，就可以避免这样的问题。这种情况下，旧的地址空间就被丢弃，所以锁的状态无关紧要。但如果子进程需要继续做处理工作的话，这种策略就行不通，还需要使用其他的策略。</p>
<p>在多线程的进程中，为了避免不一致状态的问题，POSIX.1声明，在<code>fork</code>返回和子进程调用其中一个<code>exec</code>函数之间，子进程只能调用异步信号安全的函数。这就限制了在调用<code>exec</code>之前子进程能做什么，但不涉及子进程中锁状态的问题，要清除锁状态，可以通过调用<code>pthread_atfork</code>函数建立<code>fork</code>处理程序。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_atfork</span> <span class="params">(<span class="type">void</span> (*prepare) (<span class="type">void</span>), <span class="type">void</span> (*parent) (<span class="type">void</span>), <span class="type">void</span> (*child)(<span class="type">void</span>))</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0：否则，返回借误编号</span></span><br></pre></td></tr></table></figure></p>
<p>用<code>pthread_atfork</code>函数最多可以安装3个帮助清理锁的函数。<code>prepare</code> fork处理程序由父进程在<code>fork</code>创建子进程前调用。这个<code>fork</code>处理程序的任务是获取父进程定义的所有锁。<code>parent</code> fork处理程序是在<code>fork</code>创建子进程以后、返回之前在父进程上下文中调用的。这个<code>fork</code>处理程序的任务是对<code>prepare</code> fork处理程序获取的所有锁进行解锁。<code>child</code> fork处理程序在<code>fork</code>返回之前在子进程上下文中调用。与<code>parent</code> fork处理程序一样，<code>child</code> fork处理程序也必须释放<code>prepare</code> fork处理程序获取的所有锁。</p>
<p>注意，不会出现加锁一次解锁两次的情况，虽然看起来也许会出现。子进程地址空间在创建时就得到了父进程定义的所有锁的副本。因为<code>prepare</code> fork处理程序获取了所有的镜，父进程中的内存和子进程中的内存内容在开始的时候是相同的。当父进程和子进程对它们锁的副本进程解锁的时候，新的内存是分配给子进程的，父进程的内存内容是复制到子进程的内存中(写时复制)，所以看起来父进程对它所有的锁的副本进行了加锁，子进程对它所有的锁的副本进行了加锁。父进程和子进程对在不同内存单元的重复的锁都进行了解锁操作，就好像出现了下列事件序列。</p>
<ol>
<li>父进程获取所有的锁</li>
<li>子进程获取所有的锁</li>
<li>父进程释放它的锁</li>
<li>子进程释放它的锁</li>
</ol>
<p>可以多次调用<code>pthread_atfork</code>函数从而设置多套<code>fork</code>处理程序。如果不需要使用其中某个处理程序，可以给特定的处理程序参数传入空指针，它就不会起任何作用了。使用多个<code>fork</code>处理程序时，处理程序的调用顺序并不相同。<code>parent</code>和<code>child</code> fork处理程序是以它们注册时的顺序进行调用的，而<code>prepare</code> fork处理程序的调用顺序与它们注册时的顺序相反。这样可以允许多个模块注册它们自己的<code>fork</code>处理程序，而且可以保持锁的层次。</p>
<p>例如，假设模块A调用模块B中的函数，而且每个模块有自己的一套锁。如果锁的层次是A在B之前，模块B必须在模块A之前设置它的<code>fork</code>处理程序。当父进程调用<code>fork</code>时，就会执行以下的步骤，假设子进程在父进程之前运行：</p>
<ol>
<li>调用模块A的<code>prepare fork</code>处理程序获取模块A的所有锁。</li>
<li>调用模块B的<code>prepare fork</code>处理程序获取模块B的所有锁。</li>
<li>创建子进程</li>
<li>调用模块B中的<code>child fork</code>处理程序释放子进程中模块B的所有镜。</li>
<li>调用模块A中的<code>child fork</code>处理程序释放子进程中模块A的所有锁。</li>
<li>fork函数返回到子进程</li>
<li>调用模块B中的<code>parent fork</code>处理程序释放父进程中模块B的所有锁。</li>
<li>调用模块A中的<code>parent fork</code>处理程序来释放父进程中模块才的所有锁。</li>
<li><code>fork</code>函数返同到父进程</li>
</ol>
<figure class="highlight plaintext"><figcaption><span>"apue.h"</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">pthread_mutex_t lock1 = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">pthread_mutex_t lock2 = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">prepare(void)</span><br><span class="line">&#123;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	printf(&quot;preparing locks...\n&quot;);</span><br><span class="line">	if ((err = pthread_mutex_lock(&amp;lock1)) != 0)</span><br><span class="line">		err_cont(err, &quot;can&#x27;t lock lock1 in prepare handler&quot;);</span><br><span class="line">	if ((err = pthread_mutex_lock(&amp;lock2)) != 0)</span><br><span class="line">		err_cont(err, &quot;can&#x27;t lock lock2 in prepare handler&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">parent(void)</span><br><span class="line">&#123;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	printf(&quot;parent unlocking locks...\n&quot;);</span><br><span class="line">	if ((err = pthread_mutex_unlock(&amp;lock1)) != 0)</span><br><span class="line">		err_cont(err, &quot;can&#x27;t unlock lock1 in parent handler&quot;);</span><br><span class="line">	if ((err = pthread_mutex_unlock(&amp;lock2)) != 0)</span><br><span class="line">		err_cont(err, &quot;can&#x27;t unlock lock2 in parent handler&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">child(void)</span><br><span class="line">&#123;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	printf(&quot;child unlocking locks...\n&quot;);</span><br><span class="line">	if ((err = pthread_mutex_unlock(&amp;lock1)) != 0)</span><br><span class="line">		err_cont(err, &quot;can&#x27;t unlock lock1 in child handler&quot;);</span><br><span class="line">	if ((err = pthread_mutex_unlock(&amp;lock2)) != 0)</span><br><span class="line">		err_cont(err, &quot;can&#x27;t unlock lock2 in child handler&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *</span><br><span class="line">thr_fn(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;thread started...\n&quot;);</span><br><span class="line">	pause();</span><br><span class="line">	return(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int			err;</span><br><span class="line">	pid_t		pid;</span><br><span class="line">	pthread_t	tid;</span><br><span class="line"></span><br><span class="line">	if ((err = pthread_atfork(prepare, parent, child)) != 0)</span><br><span class="line">		err_exit(err, &quot;can&#x27;t install fork handlers&quot;);</span><br><span class="line">	if ((err = pthread_create(&amp;tid, NULL, thr_fn, 0)) != 0)</span><br><span class="line">		err_exit(err, &quot;can&#x27;t create thread&quot;);</span><br><span class="line"></span><br><span class="line">	sleep(2);</span><br><span class="line">	printf(&quot;parent about to fork...\n&quot;);</span><br><span class="line"></span><br><span class="line">	if ((pid = fork()) &lt; 0)</span><br><span class="line">		err_quit(&quot;fork failed&quot;);</span><br><span class="line">	else if (pid == 0)	/* child */</span><br><span class="line">		printf(&quot;child returned from fork\n&quot;);</span><br><span class="line">	else		/* parent */</span><br><span class="line">		printf(&quot;parent returned from fork\n&quot;);</span><br><span class="line">	exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了两个互斥量，<code>lock1</code>和<code>lock2</code>，<code>prepare fork</code>处理程序获取这两把锁，<code>child fork</code>处理程序在子进程上下文中释放它们，<code>parent fork</code>处理程序在父进程上下文中释放它们。运行该程序，得到如下输出：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">thread started.</span><br><span class="line">parent about to tork...</span><br><span class="line">preparing locks.</span><br><span class="line">child unlocking locks.</span><br><span class="line">child returned from fork</span><br><span class="line">parent unlocking locks.</span><br><span class="line">parent returned from fork</span><br></pre></td></tr></table></figure></p>
<p>可以看到，<code>prepare fork</code>处理程序在调用<code>fork</code>以后运行，<code>child fork</code>处理程序在<code>fork</code>调用返回到子进程之前运行，<code>parent fork</code>处理程序在<code>fork</code>调用返回给父进程之前运行。虽然<code>pthread_atfork</code>机制的意图是使<code>fork</code>之后的锁状态保持一致，但它还是存在一些不足之处，只能在有限情况下可用。</p>
<ul>
<li>没有很好的办法对较复杂的同步对象(如条件变量或者屏障)进行状态的重新初始化。</li>
<li>某些错误检查的互斥量实现在<code>child fork</code>处理程序试图对被父进程加锁的互斥量进行解锁时会产生错误。</li>
<li>递归互斥量不能在<code>child fork</code>处理程序中清理，因为没有办法确定该互斥量被加锁的次数。</li>
<li>如果子进程只允许调用异步信号安全的函数，<code>child fork</code>处理程序就不可能清理同步对象，因为用于操作清理的所有函数都不是异步信号安全的。实际的问题是同步对象在某个线程调用<code>fork</code>时可能处于中间状态，除非同步对象处于一致状态，否则无法被清理。</li>
<li>如果应用程序在信号处理程序中调用了fork(这是合法的，因为fork本身是异步信号安全的)，<code>pthread_atfork</code>注册的<code>fork</code>处理程序只能调用异步信号安全的函数，否则结果将是未定义的。</li>
</ul>
<h1 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h1><h2 id="守护进程的特征"><a href="#守护进程的特征" class="headerlink" title="守护进程的特征"></a>守护进程的特征</h2><p>父进程ID为0的各进程通常是内核进程，它们作为系统引导装入过程的一部分而启动。(init是个例外，它是一个由内核在引导装入时启动的用户层次的命令)，内核进程是特殊的，通常存在于系统的整个生命期中。它们以超级用户特权运行，无控制终端，无命令行。</p>
<p>对于需要在进程上下文执行工作但却不被用户层进程上下文调用的每一个内核组件，通常有它自己的内核守护进程。例如，在Linux中，</p>
<ul>
<li><code>kswapd</code>守护进程也称为内存换页守护进程。它支持虚拟内存子系统在经过一段时间后将脏页面慢慢地写回磁盘来回收这些页面；</li>
<li><code>flush</code>守护进程在可用内存达到设置的最小阈值时将脏页面冲洗至磁盘，它也定期地将脏页面冲洗回磁盘来减少在系统出现故障时发生的数据丢失，多个冲洗守护进程可以同时存在，每个写回的设备都有一个冲洗守护进程；</li>
<li><code>sync_supers</code>守护进程定期将文件系统元数据冲洗至磁盘。</li>
<li><code>job</code>守护进程帮助实现了ext4文件系统中的日志功能。</li>
</ul>
<p><code>init</code>是一个系统守护进程，除了其他工作外，主要负责启动各运行层次特定的系统服务。这些服务通常是在它们自己拥有的守护进程的帮助下实现的。</p>
<p><code>rpcbind</code>守护进程提供将远程过程调用(Remote Procedure Call, RPC)程序号映射为网络端口号的服务。<code>rsyslogd</code>守护进程可以被由管理员启用的将系统消息记入日志的任何程序使用。可以在一台实际的控制台上打印这些消息，也可将它们写到一个文件中。</p>
<p><code>cron</code>守护进程在定期安排的日期和时间执行命令。许多系统管理任务是通过<code>cron</code>每隔一段固定的时间就运行相关程序而得以实现的。<code>atd</code>守护进程与<code>cron</code>类似，它允许用户在指定的时间执行任务，但是每个任务它只执行一次，而非在定期安排的时间反复执行。<code>cupsd</code>守护进程是个打印假脱机进程，它处理对系统提出的各个打印请求。<code>sshd</code>守护进程提供了安全的远程登录和执行设施。</p>
<p>注意，大多数守护进程都以超级用户(root)特权运行。所有的守护进程都没有控制终端，其终端名设置为问号。内核守护进程以无控制终端方式启动。用户层守护进程缺少控制终端可能是守护进程调用了<code>setsid</code>的结果。大多数用户层守护进程都是进程组的组长进程以及会话的首进程，而且是这些进程组和会话中的唯一进程(<code>rsyslogd</code>是一个例外)。最后，应当引起注意的是用户层守护进程的父进程是<code>init</code>进程。</p>
<h2 id="编程规则"><a href="#编程规则" class="headerlink" title="编程规则"></a>编程规则</h2><p>在编写守护进程程序时需遵循一些基本规则，以防止产生不必要的交互作用。</p>
<ul>
<li>首先要做的是调用<code>umask</code>将文件模式创建屏蔽字设置为一个已知值(通常是0)。由继承得来的文件模式创建屏蔽字可能会被设置为拒绝某些权限。如果守护进程要创建文件，那么它可能要设置特定的权限。例如，若守护进程要创建组可读、组可写的文件，继承的文件模式创建屏蔽字可能会屏蔽上述两种权限中的一 种，而使其无法发挥作用。另一方面，如果守护进程调用的库函数创建了文件，那么将文件模式创建屏蔽字设置为一个限制性更强的值(如007)可能会更明智，因为库函数可能不允许调用者通过一个显式的函数参数来设置权限。</li>
<li>调用<code>fork</code>，然后使父进程<code>exit</code>。这样做实现了下面几点。第一，如果该守护进程是作为一条简单的shell命令启动的，那么父进程终止会让shell认为这条命令已经执行完毕。第二，虽然子进程继承了父进程的进程组ID，但获得了一个新的进程ID，这就保证了子进程不是一个进程组的组长进程。这是下面将要进行的<code>setsid</code>调用的先决条件。</li>
<li>调用<code>setsid</code>创建一个新会话。然后执行3个步骤，使调用进程：<ul>
<li>成为新会话的首进程，</li>
<li>成为一个新进程组的组长进程，</li>
<li>没有控制终端。</li>
</ul>
</li>
<li>将当前工作目录更改为根目录。从父进程处继承过来的当前工作目录可能在一个挂载的文件系统中。因为守护进程通常在系统再引导之前是一直存在的，所以如果守护进程的当前工作目录在一个挂载文件系统中，那么该文件系统就不能被卸载。或者。某些守护进程还可能会把当前工作目录更改到某个指定位置，并在此位置进行它们的全部工作。</li>
<li>关闭不再需要的文件描述符。这使守护进程不再持有从其父进程继承来的任何文件描述符。可以使用<code>open_max</code>函数或<code>getrlimit</code>函数来判定最高文件描述符值，并关闭直到该值的所有描述符。</li>
<li>某些守护进程打开/dev/null使其具有文件描述符0、1和2，这样，任何一个试图读标准输入、写标准输出或标准错误的库例程都不会产生任何效果。因为守护进程并不与终端设备相关联。即使守护进程是从交互式会话启动的，但是守护进程是在后台运行的，所以登录会话的终止并不影响守护进程。</li>
</ul>
<p>函数可由一个想要初始化为守护进程的程序调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">daemonize</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>					i, fd0, fd1, fd2;</span><br><span class="line">	<span class="type">pid_t</span>				pid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span>		<span class="title">rl</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>	<span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Clear file creation mask.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Get maximum number of file descriptors.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (getrlimit(RLIMIT_NOFILE, &amp;rl) &lt; <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;%s: can&#x27;t get file limit&quot;</span>, cmd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Become a session leader to lose controlling TTY.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;%s: can&#x27;t fork&quot;</span>, cmd);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>) <span class="comment">/* parent */</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	setsid();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ensure future opens won&#x27;t allocate controlling TTYs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sa.sa_handler = SIG_IGN;</span><br><span class="line">	sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">	sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (sigaction(SIGHUP, &amp;sa, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;%s: can&#x27;t ignore SIGHUP&quot;</span>, cmd);</span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;%s: can&#x27;t fork&quot;</span>, cmd);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>) <span class="comment">/* parent */</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Change the current working directory to the root so</span></span><br><span class="line"><span class="comment">	 * we won&#x27;t prevent file systems from being unmounted.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (chdir(<span class="string">&quot;/&quot;</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;%s: can&#x27;t change directory to /&quot;</span>, cmd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Close all open file descriptors.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (rl.rlim_max == RLIM_INFINITY)</span><br><span class="line">		rl.rlim_max = <span class="number">1024</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rl.rlim_max; i++)</span><br><span class="line">		close(i);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Attach file descriptors 0, 1, and 2 to /dev/null.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	fd0 = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">	fd1 = dup(<span class="number">0</span>);</span><br><span class="line">	fd2 = dup(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initialize the log file.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	openlog(cmd, LOG_CONS, LOG_DAEMON);</span><br><span class="line">	<span class="keyword">if</span> (fd0 != <span class="number">0</span> || fd1 != <span class="number">1</span> || fd2 != <span class="number">2</span>) &#123;</span><br><span class="line">		syslog(LOG_ERR, <span class="string">&quot;unexpected file descriptors %d %d %d&quot;</span>,</span><br><span class="line">		  fd0, fd1, fd2);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>若daemonize函数由main程序调用，然后main程序进入休眠状态，那么可以用ps命令检查该守护进程的状态：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">$ ps -efj </span><br><span class="line">UID   PID PPID  PGID   SID TTY CMD</span><br><span class="line">sar 13800    1 13799 13799  ?  ./a.out</span><br><span class="line">$ ps -efj | grep 13799</span><br><span class="line">sar 13800    1 13799 13799  ?  ./a.out</span><br></pre></td></tr></table></figure></p>
<p>我们也可用ps命令验证，没有活动进程存在的ID是13799，这意味着，守护进程在一个孤儿进程组中，它不是会话首进程，因此没有机会被分配到一个控制终端。这一结果是在<code>daemonize</code>函数中执行第二个<code>fork</code>造成的。可以看出，守护进程已经被正确地初始化了。</p>
<h2 id="出错记录"><a href="#出错记录" class="headerlink" title="出错记录"></a>出错记录</h2><p>守护进程存在的一个问题是如何处理出错消息。因为它本就不应该有控制终端，所以不能只是简单地写到标准错误上，需要有一个集中的守护进程出错记录设施。</p>
<p>有以下3种产生日志信息的方法，</p>
<ol>
<li>内核例程可以调用<code>log</code>函数。任何一个用户进程都可以通过打开(<code>open</code>)并读取(<code>read</code>)/dev/klog设备来读取这些消息。</li>
<li>大多数用户进程(守护进程)调用<code>syslog</code>(3)函数来产生日志消息。这使消息被发送至UNIX域数据报套接字<code>/dev/log</code>。</li>
<li>无论一个用户进程是在此主机上，还是在通过TCPIP网络连接到此主机的其他主机上，都可将日志消息发向UDP端口514。注意，<code>syslog</code>函数从不产生这些UDP数据报，它们要求产生此日志消息的进程进行显式的网络编程。</li>
</ol>
<p>通常，<code>syslogd</code>守护进程读取所有3种格式的日志消息。此守护进程在启动时读一个配置文件，其文件名一般为<code>/etc/syslog.cont</code>。该文件决定了不同种类的消息应送向何处。例如，紧急消息可发送至系统管理员(着已登录)，并在控制台上打印，而警告消息则可记录到一个文件中。该设施的接口是<code>syslog</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">openlog</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ident, <span class="type">int</span> option, <span class="type">int</span> facility)</span> :</span><br><span class="line"><span class="type">void</span> <span class="title function_">syslog</span><span class="params">(<span class="type">int</span> prionity, <span class="type">const</span> <span class="type">char</span> *formar, ...)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">closelog</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setlogmask</span><span class="params">(<span class="type">int</span> markpri)</span>;</span><br><span class="line"><span class="comment">// 返回值，前日志记录优先级屏蔽字值</span></span><br></pre></td></tr></table></figure></p>
<p>调用<code>openlog</code>是可选择的。如果不调用<code>openlog</code>，则在第一次调用<code>syslog</code>时，自动调用<code>openlog</code>。调用<code>closelog</code>也是可选择的，因为它只是关闭曾被用于与<code>synlogd</code>守护进程进行通信的描述符。</p>
<p>调用<code>openlog</code>使我们可以指定一个<code>ident</code>，以后，此<code>ident</code>将被加至每则日志消息中。<code>ident</code>一般是程序的名称，<code>option</code>参数是指定各种选项的位屏蔽。表中介绍了可用的option(选项)。</p>
<p>|<code>option</code>|说明|<br>|<code>LOG_CONS</code>|若日志消息不能通过UNIX域数据报送至<code>syslogd</code>，则将该消息写至控制台|<br>|<code>LOG_NDELAY</code>|立即打开至<code>syslogd</code>守护进程的UNIX域数据报套接字，不要等到第一条消息已经被记录时再打开。通常，在记录第一条消息之前，不打开该套接字|<br>|<code>LOG_NOWATT</code>|不要等待在将消息记入日志过程中可能已创建的子进程。因为在<code>syslog</code>调用<code>wait</code>时，应用程序可能已获得了子进程的状态。这种处理限止了与捕提SIGCKLD信号的应用程序之间产生的冲突|<br>|<code>LOG_OOELAY</code>|在第一条消息被记录之前越迟打开至<code>syslogd</code>守护进程的连接|<br>|<code>LOG_PERROR</code>|除将日志消息发送给<code>syslogd</code>以外，还将它写至标准出错|<br>|<code>LOG_PID</code>|记录每条消息都要包含进程ID。此选项可供对每个不同的请求都<code>fork</code>一个子进程的守护进程使用|</p>
<p><code>openlog</code>的<code>facility</code>参数值选取自下图。设置<code>facility</code>参数的目的是可以让配置文件说明，来自不同设施的消息将以不同的方式进行处理。如果不调用<code>openlog</code>，或者以<code>facility</code>为0来调用它，那么在调用<code>syslog</code>时，可将<code>facility</code>作为<code>priority</code>参数的一个部分进行说明。</p>
<p>调用<code>syslog</code>产生一个日志消息。其<code>priority</code>参数是<code>facility</code>和<code>level</code>的组合，它们可选取的值分别列于<code>facility</code>和<code>level</code>中。<code>level</code>值按优先级从最高到最低依次排列。<br><img src="/img/1622621887.jpg" alt=""></p>
<p>将<code>format</code>参数以及其他所有参数传至<code>vsprintf</code>函数以便进行格式化。在<code>format</code>中，每个出现的<code>%m</code>字符都先被代换成与errno值对应的出错消息字符串(strerror)。<code>setlogmask</code>函数用于设置进程的记录优先级屏蔽字。它返回调用它之前的屏蔽字。当设置了记录优先级屏蔽字时，各条消息除非已在记录优先级屏蔽字中进行了设置，否则将不被记录。</p>
<p>在一个守护进程中，可能包含有下面的调用序列：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openlog(<span class="string">&quot;lpd&quot;</span>, LOG_PID, LOG_LPR);</span><br><span class="line">syslog (LOG_ERR, <span class="string">&quot;open error for %s: %m”, filename);</span></span><br></pre></td></tr></table></figure></p>
<p>第一个调用将<code>ident</code>字符串设置为程序名，指定该进程ID要始终被打印。对<code>syslog</code>的调用指定一个出错条件和一个消息字符串。如若不调用<code>openlog</code>，则第二个调用的形式可能是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syslog (LOG_ERR | LOG_LPR, <span class="string">&quot;open error for %s: %m&quot;</span>, filename);</span><br></pre></td></tr></table></figure></p>
<p>其中，将<code>priority</code>参数指定为<code>level</code>和<code>facility</code>的组合。</p>
<p>除了<code>syslog</code>，很多平台还提供它的一种变体来处理可变参数列表。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vsyslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span> *format, va_list arg)</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="单实例守护进程"><a href="#单实例守护进程" class="headerlink" title="单实例守护进程"></a>单实例守护进程</h2><p>为了正常运作，某些守护进程会实现为，在任一时刻只运行该守护进程的一个副本。文件和记录锁机制为一种方法提供了基础，该方法保证一个守护进程只有一个副本在运行，文件和记录锁提供了一种方便的互斥机制。如果守护进程在一个文件的整体上得到一把写锁，那么在该守护进程终止时，这把锁将被自动删除。这就简化了复原所需的处理，去除了对以前的守护进程实例需要进行清理的有关操作。</p>
<p>所示的函数说明了如何使用文件和记录镜来保证只运行一个守护进程的一个副本。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCKFILE <span class="string">&quot;/var/run/daemon.pid&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCKMODE (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">lockfile</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">already_running</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		fd;</span><br><span class="line">	<span class="type">char</span>	buf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">	fd = open(LOCKFILE, O_RDWR|O_CREAT, LOCKMODE);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		syslog(LOG_ERR, <span class="string">&quot;can&#x27;t open %s: %s&quot;</span>, LOCKFILE, strerror(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (lockfile(fd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (errno == EACCES || errno == EAGAIN) &#123;</span><br><span class="line">			close(fd);</span><br><span class="line">			<span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		syslog(LOG_ERR, <span class="string">&quot;can&#x27;t lock %s: %s&quot;</span>, LOCKFILE, strerror(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ftruncate(fd, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">sprintf</span>(buf, <span class="string">&quot;%ld&quot;</span>, (<span class="type">long</span>)getpid());</span><br><span class="line">	write(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>守护进程的每个副本都将试图创建一个文件，并将其进程ID写到该文件中。这使管理人员易于标识该进程。如果该文件已经加了锁，那么<code>lockfile</code>函数将失败，errno设置为EACCES或EAGAIN，函数返回1，表明该守护进程已在运行。否则将文件长度截断为0，将进程ID写入该文件，函数返回0。</p>
<p>需要将文件长度截断为0，其原因是之前的守护进程实例的进程ID字符串可能长于调用此函数的当前进程的进程ID字符串。例如，若以前的守护进程的进程ID是12345，而新实例的进程ID是9999，那么将此进程ID写入文件后，在文件中留下的是99995。将文件长度截断为0就解决了此问题。</p>
<h2 id="守护进程的惯例"><a href="#守护进程的惯例" class="headerlink" title="守护进程的惯例"></a>守护进程的惯例</h2><ul>
<li>若守护进程使用锁文件，那么该文件通常存储在/var/run目录中。然而需要注意的是，守护进程可能需要具有超级用户权限才能在此目录下创建文件，锁文件的名字通常是<code>name.pid</code>，其中，<code>name</code>是该守护进程或服务的名字，</li>
<li>若守护进程支持配置选项，那么配置文件通常存放在/etc目录中。配置文件的名字通常是<code>name.conf</code>。其中，<code>name</code>是该守护进程或服务的名字。例如，<code>syslogd</code>守护进程的配置文件通常是<code>/etc/syslog.conf</code>。</li>
<li>守护进程可用命令行启动，但通常它们是由系统初始化脚本之一(<code>/etc/rc*</code>或<code>/etc/init.d/*</code>)启动的。如果在守护进程终止时，应当自动地重新启动它，则我们可在<code>/etc/inittab</code>中为该守护进程包括<code>respawn</code>记录项，这样，init就将重新启动该守护进程。</li>
<li>若一个守护进程有一个配置文件，那么当该守护进程启动时会读该文件，但在此之后一般就不会再查看它。若某个管理员更改了配置文件， 那么该守护进程可能需要被停止，然后再启动，以使配置文件的更改生效。为避免此种麻烦，某些守护进程将捕捉<code>SIGHUP</code>信号，当它们接收到该信号时，重新读配置文件。</li>
</ul>
<p>程序说明了守护进程可以重读其配置文件的一种方法。该程序使用<code>sigwait</code>以及多线程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sigset_t</span>	mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">already_running</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">reread</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">thr_fn</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err, signo;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		err = sigwait(&amp;mask, &amp;signo);</span><br><span class="line">		<span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">			syslog(LOG_ERR, <span class="string">&quot;sigwait failed&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (signo) &#123;</span><br><span class="line">		<span class="keyword">case</span> SIGHUP:</span><br><span class="line">			syslog(LOG_INFO, <span class="string">&quot;Re-reading configuration file&quot;</span>);</span><br><span class="line">			reread();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> SIGTERM:</span><br><span class="line">			syslog(LOG_INFO, <span class="string">&quot;got SIGTERM; exiting&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			syslog(LOG_INFO, <span class="string">&quot;unexpected signal %d\n&quot;</span>, signo);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>					err;</span><br><span class="line">	<span class="type">pthread_t</span>			tid;</span><br><span class="line">	<span class="type">char</span>				*cmd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>	<span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((cmd = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">&#x27;/&#x27;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">		cmd = argv[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cmd++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Become a daemon.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	daemonize(cmd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure only one copy of the daemon is running.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (already_running()) &#123;</span><br><span class="line">		syslog(LOG_ERR, <span class="string">&quot;daemon already running&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Restore SIGHUP default and block all signals.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sa.sa_handler = SIG_DFL;</span><br><span class="line">	sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">	sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (sigaction(SIGHUP, &amp;sa, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;%s: can&#x27;t restore SIGHUP default&quot;</span>);</span><br><span class="line">	sigfillset(&amp;mask);</span><br><span class="line">	<span class="keyword">if</span> ((err = pthread_sigmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">		err_exit(err, <span class="string">&quot;SIG_BLOCK error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Create a thread to handle SIGHUP and SIGTERM.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	err = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_fn, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">		err_exit(err, <span class="string">&quot;can&#x27;t create thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Proceed with the rest of the daemon.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该程序调用了<code>daemonize</code>来初始化守护进程。从该函数返回后，调用<code>already_running</code>函数以确保该守护进程只有一个副本在运行。到达这一点时，<code>SIGHUP</code>信号仍被忽略，所以需恢复对该信号的系统默认处理方式；否则调用<code>sigwait</code>的线程决不会见到该信号。如同对多线程程序所推荐的那样，阻塞所有信号，然后创建一个线程处理信号。该线程的唯一工作是等待<code>SIGHUP</code>和<code>SIGTERM</code>。当接收到<code>SIGHUP</code>信号时，该线程调用<code>reread</code>函数重读它的配置文件。当它接收到<code>SIGTERM</code>信号时，会记录消息并退出。</p>
<h1 id="高级I-O"><a href="#高级I-O" class="headerlink" title="高级I/O"></a>高级I/O</h1><h2 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h2><p>对于一个给定的描述符，有两种为其指定非阻塞I/O的方法。</p>
<ol>
<li>如果调用<code>open</code>获得描述符，则可指定<code>O_NONBLOCK</code>标志。</li>
<li>对于已经打开的一个描述符，则可调用<code>fcntl</code>，由该函数打开<code>O_NONBLOCK</code>文件状态标志。</li>
</ol>
<p>程序是一个非阻塞I/O的实例，它从标准输入读500000字节，并试图将它们写到标准输出上。该程序先将标准输出设置为非阻塞的，然后用for循环进行输出，每次write调用的结果都在标准错误上打印。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>	buf[<span class="number">500000</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		ntowrite, nwrite;</span><br><span class="line">	<span class="type">char</span>	*ptr;</span><br><span class="line"></span><br><span class="line">	ntowrite = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;read %d bytes\n&quot;</span>, ntowrite);</span><br><span class="line"></span><br><span class="line">	set_fl(STDOUT_FILENO, O_NONBLOCK);	<span class="comment">/* set nonblocking */</span></span><br><span class="line"></span><br><span class="line">	ptr = buf;</span><br><span class="line">	<span class="keyword">while</span> (ntowrite &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		errno = <span class="number">0</span>;</span><br><span class="line">		nwrite = write(STDOUT_FILENO, ptr, ntowrite);</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;nwrite = %d, errno = %d\n&quot;</span>, nwrite, errno);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nwrite &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			ptr += nwrite;</span><br><span class="line">			ntowrite -= nwrite;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	clr_fl(STDOUT_FILENO, O_NONBLOCK);	<span class="comment">/* clear nonblocking */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>若标准输出是普通文件，则可以期望<code>write</code>只执行一次。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l /etc/services    打印文件长度</span><br><span class="line">-rw-r--r-- 1 root 677959 Jun 23 2009 /etc/services</span><br><span class="line">s ./a.out &lt; /ete/services &gt; temp.file  先试一个普通文件</span><br><span class="line"><span class="built_in">read</span> 500000 bytes</span><br><span class="line">nwrite = 500000, errno = 0   一次写</span><br><span class="line">$ <span class="built_in">ls</span> -l temp.tile    检验输出文件长度</span><br><span class="line">-rw-rw-t-- 1 sar 500000 Apr 1 13:03 temp.file</span><br></pre></td></tr></table></figure></p>
<p>但是，若标准输出是终端，则期望write有时返回小于500000的一个数字，有时返回错误。</p>
<h2 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h2><p>记录锁(record locking)的功能是：当第一个进程正在读或修改文件的某个部分时，使用记录锁可以阻止其他进程修改同一文件区。对于UNIX系统而言，”记录”这个词是一种误用，因为UNIX系统内核根本没有使用文件记录这种概念。一个更适合的术语可能是字节范围锁(byte-range locking)，因为它锁定的只是文件中的一个区域(也可能是整个文件)。</p>
<h3 id="fcntl记录锁"><a href="#fcntl记录锁" class="headerlink" title="fcntl记录锁"></a>fcntl记录锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...<span class="comment">/* struct flock *flockptr */</span>)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，依赖于cmd(见下)。否则，返回-1</span></span><br></pre></td></tr></table></figure>
<p>对于记录锁，<code>cmd</code>是<code>F_GETLK</code>、<code>F_SETLX</code>或<code>F_SETLKW</code>。第三个参数是一个指向<code>flock</code>结构的指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span> &#123;</span></span><br><span class="line">	<span class="type">short</span> l_type;   <span class="comment">/* F_RDLCK, E_WRLCK, or F_UNLCK */</span></span><br><span class="line">	<span class="type">short</span> l_whence; <span class="comment">/* SEEK_SET, SEEK_CUR, OF SEEK_END */</span></span><br><span class="line">	<span class="type">off_t</span> l_start;  <span class="comment">/* offset in bytes, relative to l_whence */</span></span><br><span class="line">	<span class="type">off_t</span> l_len;    <span class="comment">/* length, in bytes; 0 means lock to EOF */</span></span><br><span class="line">	<span class="type">pid_t</span> l_pid;    <span class="comment">/* returned with F_GETLK */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对<code>flock</code>结构说明如下。</p>
<ul>
<li>所希望的锁类型：<code>F_RDLCK</code>(共享读锁)、<code>F_WRLCK</code>(独占性写锁)或<code>F_ONLCK</code>(解锁个区域)</li>
<li>要加锁或解锁区域的起始字节偏移量(<code>l_start</code>和<code>l_whence</code>)</li>
<li>区域的字节长度(<code>l_len</code>)</li>
<li>进程的ID(<code>l_pid</code>)持有的锁能阻塞当前进程(仅由<code>F_GETLK</code>返回)</li>
</ul>
<p>关于加锁或解锁区域的说明还要注意下列几项规则。</p>
<ul>
<li>指定区域起始偏移量的两个元素与<code>lseek</code>函数中最后两个参数类似。<code>l_whence</code>可选用的值是<code>SEEK_SET</code>、<code>SEEK_CUR</code>或<code>SEEK_END</code></li>
<li>锁可以在当前文件尾端处开始或者越过尾端处开始。但是不能在文件起始位置之前开始。</li>
<li>如若<code>l_len</code>为0。则表示锁的范围可以扩展到最大可能偏移量。这意味着不管向该文件中追加写了多少数据，它们都可以处于锁的范围内(不必猜测会有多少字节被追加写到了文件之后)，而且起始位置可以是文件中的任意一个位置</li>
<li>为了对整个文件加锁，我们设置<code>l_start</code>和<code>l_whence</code>指向文件的起始位置，并且指定长度(<code>l_len</code>)为0</li>
</ul>
<p>上面提到了两种类型的锁，共享读锁(<code>l_type</code>为<code>L_RDLCK</code>)和独占性写锁(<code>L_WRLCK</code>)。基本规则是：任意多个进程在一个给定的字节上可以有一把共享的读锁，但是在一个给定字节上只能有一个进程有一把独占写锁。进一步而言，如果在一个给定字节上已经有一把或多把读锁，则不能在该字节上再加写锁；如果在一个字节上已经有一把独占性写锁，则不能再对它加任何读锁<br><img src="/img/1622627160.jpg" alt=""></p>
<p>上面说明的兼容性规则适用于不同进程提出的锁请求，并不适用于单个进程提出的多个锁请求。如果一个进程对一个文件区间已经有了一把锁，后来该进程又企图在同一文件区间再加一把锁，那么新锁将替换已有镜。加读锁时，该描述符必须是读打开。加写锁时，该描述符必须是写打开。下面说明一下<code>fcntl</code>函数的3种命令。</p>
<ul>
<li><code>F_GETLK</code>判断由<code>flockptr</code>所描述的锁是否会被另外一把锁所排斥(阻塞)。如果存在一把锁，它阻止创建由<code>flockptr</code>所描述的锁，则该现有锁的信息将重写<code>flockptr</code>指向的信息。如果不存在这种情况，则除了将<code>l_type</code>设置为<code>E_UNLCK</code>之外，<code>flockptr</code>所指向结构中的其他信息保持不变</li>
<li><code>F_SETLK</code>设置由<code>flockptr</code>所描述的锁。如果我们试图获得一把读锁(<code>l_type</code>为<code>F_RDLCK</code>)或写锁(<code>l_type</code>为<code>F_WRLCK</code>)，而兼容性规则阻止系统给我们这把锁，那么<code>fcntl</code>会立即出错返回，此时errno设置为EACCES或EAGAIN。此命令也用来清除由<code>flockptr</code>指定的锁(<code>l_type</code>为<code>F_UNLCK</code>)</li>
<li><code>F_SETLKW</code>这个命令是<code>F_SETLK</code>的阻塞版本。如果所请求的读愤或写锁因另一个进程当前已经对所请求区域的某部分进行了加锁而不能被授予，那么调用进程会被置为休眠。如果请求创建的锁已经可用，或者休眠由信号中断，则该进程被唤醒</li>
</ul>
<p>应当了解，用<code>E_GETLK</code>测试能否建立一把锁，然后用<code>F_SETLK</code>或<code>E_SETLKW</code>企图建立那把锁，这两者不是一个原子操作。因此不能保证在这两次<code>fcntl</code>调用之间不会有另一个进程插入并建立一把相同的锁。如果不希望在等待锁变为可用时产生阻塞，就必须处理由<code>F_SETLK</code>返回的可能的出错。</p>
<p>在设置或释放文件上的一把锁时，系统按要求组合或分裂相邻区。例如，若第100~199字节是加锁的区，需解锁第150字节， 则内核将维持两把锁，一把用于第100~149字节，另一把用于第151~199字节。假定我们又对第150字节加锁，那么系统将会再把3个相邻的加锁区合并成一个区(第100~199字节)。</p>
<p>为了避免每次分配<code>flock</code>结构，然后又填入各项信息，可以用函数<code>lock_reg</code>来处理所有这些细节。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">lock_reg</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="type">int</span> type, <span class="type">off_t</span> offset, <span class="type">int</span> whence, <span class="type">off_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">flock</span>	<span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">	lock.l_type = type;		<span class="comment">/* F_RDLCK, F_WRLCK, F_UNLCK */</span></span><br><span class="line">	lock.l_start = offset;	<span class="comment">/* byte offset, relative to l_whence */</span></span><br><span class="line">	lock.l_whence = whence;	<span class="comment">/* SEEK_SET, SEEK_CUR, SEEK_END */</span></span><br><span class="line">	lock.l_len = len;		<span class="comment">/* #bytes (0 means to EOF) */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(fcntl(fd, cmd, &amp;lock));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为大多数锁调用是加锁或解锁一个文件区域(命令<code>E_GETLK</code>很少使用)，故通常使用下列5个宏中的一个。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> read_lock(fd, offset, whence, len)\</span></span><br><span class="line"><span class="meta">	lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> readw_lock (fd, offset, whence, len) \</span></span><br><span class="line"><span class="meta">	lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> write_lock(fd, offset, whence, len) \</span></span><br><span class="line"><span class="meta">	lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> writew_lock (fd, offset, whence, len) \</span></span><br><span class="line"><span class="meta">	lock_reg((fd)，F_SETLKW, F_WRLCK, (offset),(whence), (len))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> un_lock (fd, offset, whence, len) \</span></span><br><span class="line"><span class="meta">	lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))</span></span><br></pre></td></tr></table></figure></p>
<p>下边定义了一个函数<code>lock_test</code>，我们将用它测试一把锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span></span><br><span class="line"><span class="title function_">lock_test</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> type, <span class="type">off_t</span> offset, <span class="type">int</span> whence, <span class="type">off_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">flock</span>	<span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">	lock.l_type = type;		<span class="comment">/* F_RDLCK or F_WRLCK */</span></span><br><span class="line">	lock.l_start = offset;	<span class="comment">/* byte offset, relative to l_whence */</span></span><br><span class="line">	lock.l_whence = whence;	<span class="comment">/* SEEK_SET, SEEK_CUR, SEEK_END */</span></span><br><span class="line">	lock.l_len = len;		<span class="comment">/* #bytes (0 means to EOF) */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fcntl(fd, F_GETLK, &amp;lock) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lock.l_type == F_UNLCK)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">0</span>);		<span class="comment">/* false, region isn&#x27;t locked by another proc */</span></span><br><span class="line">	<span class="keyword">return</span>(lock.l_pid);	<span class="comment">/* true, return pid of lock owner */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果存在一把锁，它阻塞由参数指定的锁请求，则此函数返回持有这把现有锁的进程的进程ID，否则此函数返回0。通常用下面两个宏来调用此函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	is_read_lockable(fd, offset, whence, len) \</span></span><br><span class="line"><span class="meta">			(lock_test((fd), F_RDLCK, (offset), (whence), (len)) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	is_write_lockable(fd, offset, whence, len) \</span></span><br><span class="line"><span class="meta">			(lock_test((fd), F_WRLCK, (offset), (whence), (len)) == 0)</span></span><br></pre></td></tr></table></figure></p>
<p>注意，进程不能使用<code>lock_test</code>函数测试它自己是否在文件的某一部分持有一把锁。<code>F_GETLK</code>命令的定义说明，返回信息指示是否有现有的锁阻止调用进程设置它自己的锁。因为<code>F_SETLK</code>和<code>F_SETLKW</code>命令总是替换调用进程现有的锁，所以调用进程决不会阻塞在自己持有的锁上，于是，<code>F_GETLK</code>命令决不会报告调用进程自己持有的锁。</p>
<p>如果一个进程已经控制了文件中的一个加锁区域。然后它又试图对另一个进程控制的区域加锁，那么它就会休眠，在这种情况下，有发生死锁的可能性。子进程对第0字节加锁，父进程对第1字节加锁。然后，它们中的每一个又试图对对方已经加锁的字节加锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">lockabyte</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (writew_lock(fd, offset, SEEK_SET, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;%s: writew_lock error&quot;</span>, name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s: got the lock, byte %lld\n&quot;</span>, name, (<span class="type">long</span> <span class="type">long</span>)offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		fd;</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Create a file and write two bytes to it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((fd = creat(<span class="string">&quot;templock&quot;</span>, FILE_MODE)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;creat error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (write(fd, <span class="string">&quot;ab&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	TELL_WAIT();</span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;			<span class="comment">/* child */</span></span><br><span class="line">		lockabyte(<span class="string">&quot;child&quot;</span>, fd, <span class="number">0</span>);</span><br><span class="line">		TELL_PARENT(getppid());</span><br><span class="line">		WAIT_PARENT();</span><br><span class="line">		lockabyte(<span class="string">&quot;child&quot;</span>, fd, <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;						<span class="comment">/* parent */</span></span><br><span class="line">		lockabyte(<span class="string">&quot;parent&quot;</span>, fd, <span class="number">1</span>);</span><br><span class="line">		TELL_CHILD(pid);</span><br><span class="line">		WAIT_CHILD();</span><br><span class="line">		lockabyte(<span class="string">&quot;parent&quot;</span>, fd, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行图14-7中的程序得到：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">parent: got the lock, byte 1</span><br><span class="line">child: got the lock, byte 0</span><br><span class="line">parent: writem_lock error: Resource deadlock avoided</span><br><span class="line">child: got the lock, byte 1</span><br></pre></td></tr></table></figure></p>
<p>检测到死锁时，内核必须选择一个进程接收出错返回。在本实例中，选择了父进程，但这是一个实现细节。在某些系统上，子进程总是接到出错信息，在另一些系统上，父进程总是接到出错信息。在某些系统上，当试图使用多把锁时，有时是子进程接到出错信息，有时则是父进程接到出错信息。</p>
<h3 id="锁的隐含继承和释放"><a href="#锁的隐含继承和释放" class="headerlink" title="锁的隐含继承和释放"></a>锁的隐含继承和释放</h3><p>关于记录锁的自动继承和释放有3条规则。</p>
<ul>
<li>锁与进程和文件两者相关联。这有两重含义。第一重很明显，当一个进程终止时，它所建立的锁全部释放；第二重则不太明显，无论一个描述符何时关闭，该进程通过这一描述符引用的文件上的任何一把锁都会释放(这些锁都是该进程设置的)。<ul>
<li>这就意味着，如果执行下列4步：<ul>
<li><code>fd1 = open (pathname, ...);</code></li>
<li><code>read_lock(fd1, ...);</code></li>
<li><code>fd2 = dup(fdi);</code></li>
<li><code>close (fd2);</code></li>
</ul>
</li>
<li>则在<code>close(fd2)</code>后，在<code>fd1</code>上设置的锁被释放。如果将<code>dup</code>替换为<code>open</code>，其效果也一样：<ul>
<li><code>fd1 = open (pathname, ...);</code></li>
<li><code>read_lock(fd1, ...);</code></li>
<li><code>fd2 = open(pathname, ...);</code></li>
<li><code>close (fd2);</code></li>
</ul>
</li>
</ul>
</li>
<li>由<code>fork</code>产生的子进程不继承父进程所设置的锁。这意味着，若一个进程得到一把锁，然后调用<code>fork</code>，那么对于父进程获得的锁而言，子进程被视为另一个进程。对于通过<code>fork</code>从父进程处继承过来的描述符，子进程需要调用<code>fcntl</code>才能获得它自己的锁。<ul>
<li>这个约束是有道理的，因为锁的作用是阻止多个进程同时写同一个文件。如果子进程通过<code>fork</code>继承父进程的锁，则父进程和子进程就可以同时写同一个文件。</li>
</ul>
</li>
<li>在执行exec后，新程序可以继承原执行程序的锁。但是注意，如果对一个文件描述符设置了执行时关闭标志，那么当作为<code>exec</code>的一部分关闭该文件描述符时，将释放相应文件的所有锁。</li>
</ul>
<h3 id="FreeBSD实现"><a href="#FreeBSD实现" class="headerlink" title="FreeBSD实现"></a>FreeBSD实现</h3><p>先简要地观察FreeBSD实现中使用的数据结构。这会帮助我们进一步理解记录锁的自动继承和释放的第一条规则：锁与进程和文件两者相关联。考虑一个进程，它执行下列语句(忽略出错返回)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fd1 = open (pathname, ...);</span><br><span class="line">write_lock(fd1, <span class="number">0</span>, SEEK_SET, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* parent write locks byte 0 */</span></span><br><span class="line"><span class="keyword">if</span> ((pid = fork()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">/* parent */</span></span><br><span class="line">	fd2 = dup(fd1);</span><br><span class="line">	fd3 = open (pathname, ...];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">	read_lock(fd1, <span class="number">1</span>, SEEK_SET, <span class="number">1</span>); <span class="comment">/* child read locks byte 1 */</span></span><br><span class="line">&#125;</span><br><span class="line">pause();</span><br></pre></td></tr></table></figure></p>
<p>图显示了父进程和子进程暂停(执行<code>pause()</code>)后的数据结构情况。<br><img src="/img/1622640114.jpg" alt=""></p>
<p>前面已经给出了<code>open</code>、<code>fork</code>以及<code>dup</code>调用后的数据结构。有了记录锁后，在原来的这些图上新加了<code>lockf</code>结构，它们由i节点结构开始相互链接起来。每个<code>lockf</code>结构描述了一个给定进程的一个加锁区域(由偏移量和长度定义的)。图中显示了两个<code>lockf</code>结构，一个是由父进程调用<code>write_lock</code>形成的，另一个则是由子进程调用<code>read_lock</code>形成的。每一个结构都包含了相应的进程ID。</p>
<p>在父进程中，关闭<code>fd1</code>、<code>fd2</code>或<code>fd3</code>中的任意一个都将释放由父进程设置的写锁。在关闭这3个描述符中的任意一个时，内核会从该描述符所关联的i节点开始，逐个检查<code>lockf</code>链接表中的各项，并释放由调用进程持有的各把锁。</p>
<p>程序展示了<code>lockfile</code>函数的实现，守护进程可用该函数在文件上加写锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">lockfile</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">fl</span>;</span></span><br><span class="line"></span><br><span class="line">	fl.l_type = F_WRLCK;</span><br><span class="line">	fl.l_start = <span class="number">0</span>;</span><br><span class="line">	fl.l_whence = SEEK_SET;</span><br><span class="line">	fl.l_len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span>(fcntl(fd, F_SETLK, &amp;fl));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一种方法是用<code>write_lock</code>函数定义<code>lockfile</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lockfile(fd) write_lock((fd)，0, SEEK_SET, 0)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="在文件尾端加锁"><a href="#在文件尾端加锁" class="headerlink" title="在文件尾端加锁"></a>在文件尾端加锁</h3><p>在对相对于文件尾端的字节范围加锁或解锁时需要特别小心。大多数实现按照<code>l_whence</code>的<code>SEEK_CUR</code>或<code>SEEK_END</code>值，用<code>l_start</code>以及文件当前位置或当前长度得到绝对文件偏移量。但是，常常需要相对于文件的当前长度指定一把锁，但又不能调用<code>fstat</code>来得到当前文件长度，因为我们在该文件上没有锁。考虑以下代码序列：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">writew_lock(fd, <span class="number">0</span>, SEEK_END, <span class="number">0</span>);</span><br><span class="line">write(fd, buf, <span class="number">1</span>):</span><br><span class="line">un_lock(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">write(fd, buf, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>该代码序列所做的可能并不是你所期望的，它得到一把写锁，该写锁从当前文件尾端起，包括以后可能追加写到该文件的任何数据。假定，该文件偏移量处于文件尾端时，执行第一个write，这个操作将文件延伸了1个字节，而该字节将被加锁。跟随其后的是解锁操作，其作用是对以后追加写到文件上的数据不再加锁。但在其之前刚追加写的一个字节则保留加锁状态。当执行第二个写时，文件尾端又廷伸了1个字节，但该字节并未加锁。</p>
<p>当对文件的一部分加锁时，内核将指定的偏移量变换成绝对文件偏移量。另外，除了指定一个绝对偏移量(<code>SEEK_SET</code>)之外，<code>fcntl</code>还允许我们相对于文件中的某个点指定该偏移量，这个点是指当前偏移量(<code>SEEK_CUR</code>)或文件尾端(<code>SEEK_END</code>)。当前偏移量和文件尾端可能会不断变化，而这种变化又不应影响现有锁的状态，所以内核必须独立于当前文件偏移量或文件尾端而记住锁。如果想解除的锁中包括第一次<code>write</code>所写的1个字节，那么应指定长度为-1。负的长度值表示在指定偏移量之前的字节数。</p>
<h3 id="建议性锁和强制性锁"><a href="#建议性锁和强制性锁" class="headerlink" title="建议性锁和强制性锁"></a>建议性锁和强制性锁</h3><p>强制性锁会让内核检查每一个<code>open</code>、<code>read</code>和<code>write</code>，验证调用进程是否违背了正在访问的文件上的某一把锁。强制性锁有时也称为强迫方式锁(enforcement-mode locking)。</p>
<p>对一个特定文件打开其设置组ID位、关闭其组执行位便开启了对该文件的强制性锁机制。因为当组执行位关闭时，设置组ID位不再有意义。如果一个进程试图读(read)或写(write)一个强制性锁起作用的文件，而欲读、写的部分又由其他进程加上了锁，取决于3方面的因素：操作类型(read或write)、其他进程持有的锁的类型(读锁或写锁)以及read或write的描述符是阻塞还是非阻塞的，下边列出了8种可能性。<br><img src="/img/1622641438.jpg" alt=""></p>
<p>通常，即使正在打开的文件具有强制性记录锁，该<code>open</code>也会成功。如果欲打开的文件具有强制性记录锁(读锁或写锁)，而且<code>open</code>调用中的标志指定为<code>O_TRUNC</code>或<code>O_CREAT</code>，则不论是否指定<code>O_NONBLOCK</code>，<code>open</code>都立即出错返回，errno设置为EAGAIN。</p>
<h2 id="I-O多路转接"><a href="#I-O多路转接" class="headerlink" title="I/O多路转接"></a>I/O多路转接</h2><p>当从一个描述符读，然后又写到另一个描述符时，可以在下列形式的循环中使用阻塞I/O:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((n=read(STDIN_FILENO, buf, BUFSIZ)) &gt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> (write(STDOUT_FILENO, buf, n) != n)</span><br><span class="line">		err_sys (<span class="string">&quot;write error&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>这种形式的阻塞I/O到处可见。但是如果必须从两个描述符读，我们不能在任一个描述符上进行阻塞读(read)，否则可能会因为被阻塞在一个描述符的读操作上而导致另一个描述符即使有数据也无法处理。所以为了处理这种情况需要另一种不同的技术。将一个进程变成两个进程(用fork)，每个进程处理一条数据通路。图中显示了这种安排。<br><img src="/img/1622642397.jpg" alt=""></p>
<p>如果使用两个进程，则可使每个进程都执行阻塞<code>read</code>。如果子进程接收到文件结束符，那么该子进程终止。然后父进程接收到<code>SIGCHLD</code>信号。但是，如果父进程终止，那么父进程应通知子进程停止。为此可以使用一个信号(如<code>SIGUSR1</code>)，但这使程序变得更加复杂。</p>
<p>另一个方法是仍旧使用一个进程执行该程序，但使用非阻塞I/O读取数据。其基本思想是：将两个输入描述符都设置为非阻塞的，对第一个描述符发一个<code>read</code>。如果该输入上有数据，则读数据并处理它。如果无数据可读，则该调用立即返回。然后对第二个描述符作同样的处理。在此之后，等待一定的时间(可能是若干秒)，然后再尝试从第一个描述符读。这种形式的循环称为<strong>轮询</strong>。这种方法的不足之处是浪费CPU时间。</p>
<p>还有一种技术称为异步I/O(asynchronous I/O)。进程告诉内核：当描述符准备好可以进行I/O时，用一个信号通知它。这种技术有两个问题。首先，尽管一些系统提供了各自的受限形式的异步I/O，但POSIX采纳了另外一套标准化接口。</p>
<p>这种技术的第二个问题是，这种信号对每个进程而言只有1个(<code>SIGPOLL</code>或<code>SIGIO</code>)。如果使该信号对两个描述符都起作用，那么进程在接到此信号时将无法判别是哪一个描述符准备好了，需将这两个描述符都设置为非阻塞的，并顺序尝试执行I/O。</p>
<p>一种比较好的技术是使用I/O多路转接(I/O multiplexing)。为了使用这种技术，先构造一张我们感兴趣的描述符(通常都不止一个)的列表，然后调用一个函数，直到这些描述符中的一个已准备好进行I/O时，该函数才返回。<code>poll</code>、<code>pselect</code>和<code>select</code>这3个函数使我们能够执行I/O多路转接。在从这些函数返回时，进程会被告知哪些描述符已准备好可以进行I/O。POSIX指定，为了在程序中使用<code>select</code>，必须包括<code>&lt;sys/select.h&gt;</code>。</p>
<h3 id="函数select和pselect"><a href="#函数select和pselect" class="headerlink" title="函数select和pselect"></a>函数select和pselect</h3><p><code>select</code>函数使我们可以执行I/O多路转接。传给<code>select</code>的参数告诉内核：</p>
<ul>
<li>我们所关心的描述符</li>
<li>对于每个描述符我们所关心的条件</li>
<li>愿意等待多长时间</li>
</ul>
<p>从<code>select</code>返回时，内核告诉我们</p>
<ul>
<li>已准备好的描述符的总数量：</li>
<li>对于读、写或异常这3个条件中的每一个，哪些描述符已准备好。</li>
</ul>
<p>使用这种返回信息，就可调用相应的I/O函数(一般是<code>read</code>或<code>write</code>)，并且确知该函数不会阻塞。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> maxfdp1, fd_set *<span class="keyword">restrict</span> readfds, fd_set *<span class="keyword">restrict</span> writefds, fd_set *restriet exceptfds, <span class="keyword">struct</span> timeval *<span class="keyword">restrict</span> tvptr)</span>;</span><br><span class="line"><span class="comment">// 返回值，准备就绪的描述符数目，若超时，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>最后一个参数指定愿意等待的时间长度，单位为秒和微秒。有以下3种情况。</p>
<ul>
<li><code>tvptr == NULL</code><ul>
<li>永远等待。如果捕捉到一个信号则中断此无限期等待。当所指定的描述符中的一个已准备好或捕捉到一个信号则返回。如果捕捉到一个信号，则<code>select</code>返回-1，errno设置为EINTR。</li>
</ul>
</li>
<li><code>tvptr-&gt;tv_sec == 0 &amp;&amp; tvptr-&gt;tv_usec == 0</code><ul>
<li>根本不等待。测试所有指定的描述符并立即返回。这是轮询系统找到多个描述符状态而不阻塞<code>select</code>函数的方法。</li>
</ul>
</li>
<li><code>tvptr-&gt;tv_sec != 0 || tvptr-&gt;n_usec != 0</code><ul>
<li>等待指定的秒数和微秒数。当指定的描述符之一已准备好，或当指定的时间值已经超过时立即返回。如果在超时到期时还没有一个描述符准备好，则返回值是0。与第一种情况一样，这种等待可被捕捉到的信号中断。</li>
</ul>
</li>
</ul>
<p>中间3个参数<code>readfds</code>，<code>writefds</code>和<code>exceptfds</code>是指向描述符集的指针。这3个描述符集说明了可读、可写或处于异常条件的描述符集合。每个描述符集存储在一个<code>fd_set</code>数据类型中。这个数据类型是由实现选择的，它可以为每一个可能的描述符保持一位。我们可以认为它只是一个很大的字节数组。<br><img src="/img/1622643609.jpg" alt=""></p>
<p>对于<code>fd_set</code>数据类型，唯一可以进行的处理是：分配一个这种类型的变量，将这种类型的一个变量值赋给同类型的另一个变量，或对这种类型的变量使用下列4个函数中的一个。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;</span><br><span class="line"><span class="comment">// 返回值：若fd在描述符集中，返回非0值；否则，返回0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *fdset)</span>;</span><br></pre></td></tr></table></figure></p>
<p>这些接口可实现为宏或函数。调用<code>FD_ZERO</code>将一个<code>fd_set</code>变量的所有位设置为0。要开启描述符集中的一位，可以调用<code>FD_SET</code>。调用<code>FD_CLR</code>可以清除一位。最后，可以调用<code>FD_ISSET</code>测试描述符集中的一个指定位是否已打开。</p>
<p>在声明了一个描述符集之后，必须用<code>FD_ZERO</code>将这个描述符集置为0，然后在其中设置我们关心的各个描述符的位。具体操作如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fd_set rset;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line">FD_ZERO(&amp;rset);</span><br><span class="line">FD_SET(fd, &amp;rset);</span><br><span class="line">FD_SET(STDIN_FILENO, &amp;rset);</span><br></pre></td></tr></table></figure></p>
<p>从<code>select</code>返回时，可以用<code>FD_ISSET</code>测试该集中的一个给定位是否仍处于打开状态：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (FD_ISSET(fd, &amp;rset));</span><br></pre></td></tr></table></figure></p>
<p><code>select</code>的中间3个参数(指向描述符集的指针)中的任意一个(或全部)可以是空指针，这表示对相应条件并不关心。如果所有3个指针都是NULL，则<code>select</code>提供了比<code>sleep</code>更精确的定时器。</p>
<p><code>select</code>第一个参数<code>maxfdp1</code>的意思是“最大文件描述符编号值加1”。也可将第一个参数设置为<code>FD_SETSIZE</code>，它指定最大描述符数(经常是1024)。通过指定我们所关注的最大描述符，内核就只需在此范围内寻找打开的位，而不必在了个描述符集中的数百个没有使用的位内搜索。例如，图14-16所示的两个描述符集的情况就好像是执行了下述操作：<br><img src="/img/20210602112207.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fd_set readset, writeset;</span><br><span class="line">PO_ZERO(&amp;readset);</span><br><span class="line">PD_ZERO(&amp;writeset);</span><br><span class="line">FD_SET(<span class="number">0</span>, &amp;readset);</span><br><span class="line">FD_SET(<span class="number">3</span>, &amp;readset);</span><br><span class="line">FD_SET(<span class="number">1</span>, &amp;writeset);</span><br><span class="line">FD_SET(<span class="number">2</span>, &amp;writeset);</span><br><span class="line">select(<span class="number">4</span>, &amp;readset, &amp;writeset, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>因为描述符编号从0开始，所以要在最大描述符编号值上加1。第一个参数实际上是要检查的描述符数(从描述符0开始)。</p>
<p><code>select</code>有3个可能的返回值。</p>
<ol>
<li>返回值-1表示出错。这是可能发生的，例如，在所指定的描述符一个都没准备好时捕捉到一个信号。在此种情况下，一个描述符集都不修改</li>
<li>返回值0表示没有描述符准备好。若指定的描述符一个都没准备好，指定的时间就过了，那么就会发生这种情况。此时，所有描述符集都会置0</li>
<li>一个正返回值说明了已经准备好的描述符数。该值是3个描述符集中已准备好的描述符数之和，所以如果同一描述符已准备好读和写，那么在返回值中会对其计两次数。在这种情况下，3个描述符集中仍旧打开的位对应于已准备好的描述符。</li>
</ol>
<p>对于“准备好”的含义要作一些更具体的说明。</p>
<ul>
<li>若对读集(readfds)中的一个描述符进行的read操作不会阻塞，则认为此描述符是准备好的。</li>
<li>若对写集(writefds)中的一个描述符进行的wrile操作不会阻塞，则认为此描述符是准备好的。</li>
<li>若对异常条件集(exceptfds)中的一个描述符有一个未决异常条件，则认为此播述符是准备好的。</li>
<li>对于读、写和异常条件，普通文件的文件描述符总是返回准备好。</li>
</ul>
<p>一个描述符阻塞与否并不影响<code>select</code>是否阻塞，也就是说，如果希望读一个非阻塞描述符，并且以超时值为5秒调用<code>select</code>，则<code>select</code>最多阻塞5s。相类似，如果指定一个无限的超时值，则在该描述符数据准备好，或捕捉到一个信号之前，<code>select</code>会一直阻塞。</p>
<p>如果在一个描述符上碰到了文件尾端，则<code>select</code>会认为该描述符是可读的。然后调用<code>read</code>，它返回0；这是UNIX系统指示到达文件尾端的方法。POSIX.1也定义了一个<code>select</code>的变体，称为<code>pselect</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ays/seiect.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pselect</span> <span class="params">(<span class="type">int</span> maxfdpl, fd_set *<span class="keyword">restrict</span> readfds,</span></span><br><span class="line"><span class="params">	fd_set *<span class="keyword">restrict</span> writefds, fd_set *<span class="keyword">restrict</span> exceptfds,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="type">sigset_t</span> *<span class="keyword">restrict</span> sigmask)</span>;</span><br><span class="line"><span class="comment">// 返回值：准备就绪的描述符数目，若超时，返回0。若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>除下列几点外，<code>pselect</code>与<code>select</code>相同。</p>
<ul>
<li><code>select</code>的超时值用<code>timeval</code>结构指定，但<code>pselect</code>使用<code>timespec</code>结构。<code>timespec</code>结构以秒和纳秒表示超时值，而非秒和微秒。</li>
<li><code>pselect</code>的超时值被声明为<code>const</code>，这保证了调用<code>pselect</code>不会改变此值。</li>
<li><code>pselect</code>可使用可选信号屏蔽字。若<code>sigmask</code>为NULL，那么在与信号有关的方面，<code>pselect</code>的运行状况和<code>select</code>相同。否则，<code>sigmask</code>指向一信号屏蔽字，在调用<code>pselect</code>时，以原子操作的方式安装该信号屏蔽字。在返回时，恢复以前的信号屏蔽字。</li>
</ul>
<h3 id="函数poll"><a href="#函数poll" class="headerlink" title="函数poll"></a>函数poll</h3><p><code>poll</code>函数类似于<code>select</code>，但是程序员接口有所不同。<code>poll</code>函数可用于任何类型的文件描述符。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span> <span class="params">(<span class="keyword">struct</span> pollfd fdarray[], <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="comment">// 返回值：准备就绪的描述行数目，若超时，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>与<code>select</code>不同，<code>poll</code>不是为每个条件(可读性、可写性和异常条件)构造一个描述符集，而是构造一个<code>pollfd</code>结构的数组，每个数组元素指定一个描述符编号以及我们对该描述符感兴趣的条件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> fd;       <span class="comment">/* file deacriptor to check, or &lt;0 to sgnore */</span></span><br><span class="line">	<span class="type">short</span> events; <span class="comment">/* events of interest on fd */</span></span><br><span class="line">	<span class="type">short</span> revents; <span class="comment">/* events that occurred on fd */</span></span><br></pre></td></tr></table></figure></p>
<p><code>fdarray</code>数组中的元素数由<code>nfds</code>指定。</p>
<p>应将每个数组元素的<code>events</code>成员设置为表中所示值的一个或几个，通过这些值告诉内核我们关心的是每个描述符的哪些事件。返回时，<code>revents</code>成员由内核设置，用于说明每个描述符发生了哪些事件。(注意，<code>poll</code>没有更改<code>events</code>成员。这与<code>select</code>不同，<code>select</code>修改其参数以指示哪一个描述符已准备好了。)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>POLLIN</td>
<td>可以不阻塞读高优先级数据以外的数据(等效于<code>POLLRDNORM</code></td>
<td><code>POLLRDBAND</code>)</td>
</tr>
<tr>
<td>POLLRDNORM</td>
<td>可以不阻塞地读普通数据</td>
</tr>
<tr>
<td>POLLRDBAND</td>
<td>可以不阻塞地读优先级数据</td>
</tr>
<tr>
<td>POLLPRI</td>
<td>可以不阻塞地读高优先级数据</td>
</tr>
<tr>
<td>POLLOUT</td>
<td>可以不阻塞地写普通数据</td>
</tr>
<tr>
<td>POLLMRNORM</td>
<td>与POLLOUT相同</td>
</tr>
<tr>
<td>POLLWRBAND</td>
<td>可以不阻塞地写优先级数据</td>
</tr>
<tr>
<td>POLLERR</td>
<td>已出错</td>
</tr>
<tr>
<td>POLLHUP</td>
<td>已挂断</td>
</tr>
<tr>
<td>POLLNVAL</td>
<td>描述符没有引用一个打开文件</td>
</tr>
</tbody>
</table>
</div>
<p>当一个描述符被挂断(<code>POLLHUP</code>)后，就不能再写该描述符，但是有可能仍然可以从该描述符读取到数据。</p>
<p><code>poll</code>的最后一个参数指定的是我们愿意等待多长时间。如同<code>select</code>一样，有3种不同的情形。</p>
<ul>
<li><code>timeout == -1</code><ul>
<li>永远等待。(某些系统在<code>&lt;stropts.h&gt;</code>中定义了常量INFTIM，其值通常是-1。)当所指定的描述符中的一个已准备好，或捕捉到一个信号时返回。如果捕捉到一个信号，则<code>poll</code>返回-1，errno设置为EINTR。</li>
</ul>
</li>
<li><code>timeout == 0</code><ul>
<li>不等待。测试所有描述符并立即返回。这是一种轮询系统的方法，可以找到多个描述符的状态而不阻塞<code>poll</code>函数。</li>
</ul>
</li>
<li><code>timeout &gt; 0</code><ul>
<li>等待timeout毫秒，当指定的描述符之一已准备好，或<code>timeout</code>到期时立即返回。如果<code>timeout</code>到期时还没有一个描述符准备好，则返回值是0。</li>
</ul>
</li>
</ul>
<p>与<code>select</code>一样，一个描述符是否阻塞不会影响<code>poll</code>是否阻塞。</p>
<h2 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h2><p>使用POSIX异步I/O接口，会带来下列麻烦：</p>
<ul>
<li>每个异步操作有了处可能产生错误的地方：一处在操作提交的部分，一处在操作本身的结果，还有一处在用于决定异步操作状态的函数中。</li>
<li>与POSIX异步IO接口的传统方法相比，它们本身涉及大量的额外设置和处理规则。<ul>
<li>事实上，并不能把非异步I/O函数称作“同步”的，因为尽管它们相对于程序流来说是同步的，但相对于I/O来说并非如此。当从<code>write</code>函数的调用返回时，写的数据是持久的，我们称这个写操作为“同步”的。也不能依靠把传统的调用归类为“标准”的I/O调用来区到传统的I/O函数和异步I/O函数，因为这样会使它们和标准I/O库中的函数调用相混淆。</li>
</ul>
</li>
<li>从错误中恢复可能会比较困难。</li>
</ul>
<h3 id="System-V异步I-O"><a href="#System-V异步I-O" class="headerlink" title="System V异步I/O"></a>System V异步I/O</h3><p>在System V中，异步I/O是STREAMS系统的一部分，它只对STREAMS设备和STREAMS管道起作用。SystemV的异步I/O信号是<code>SIGPOLL</code>。</p>
<p>除了调用<code>ioctl</code>指定产生<code>SIGPOLL</code>信号的条件以外，还应为该信号建立信号处理程序。应当在调用<code>ioctl</code>之前建立信号处理程序。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>S_INPUT</td>
<td>可以不阻塞地读取数据(非高优先级数据)</td>
</tr>
<tr>
<td>S_RDNORM</td>
<td>可以不阻塞地读取普通数据</td>
</tr>
<tr>
<td>S_RDBAND</td>
<td>可以不阻塞地读取优先级数据</td>
</tr>
<tr>
<td>S_BANDURG</td>
<td>若此常量和<code>S_RDBAND</code>一起指定，当我们可以不阻塞地读取优先数据时，产生<code>SIGURG</code>信号而非<code>SIGPOLL</code></td>
</tr>
<tr>
<td>S_HIPRI</td>
<td>可以不阻塞地读取高优先级数据</td>
</tr>
<tr>
<td>S_OUTPUT</td>
<td>可以不阻塞地写普通数据</td>
</tr>
<tr>
<td>S_WRNGRM</td>
<td>与<code>S_OUTPUT</code>相同</td>
</tr>
<tr>
<td>S_WRBAND</td>
<td>可以不阻塞地写优先级数据</td>
</tr>
<tr>
<td>S_MSG</td>
<td>包含<code>SIGPOLL</code>信号的消息已经到达流头部</td>
</tr>
<tr>
<td>S_ERROR</td>
<td>流有错误</td>
</tr>
<tr>
<td>S_HANGUP</td>
<td>流已挂起</td>
</tr>
</tbody>
</table>
</div>
<h3 id="BSD异步I-O"><a href="#BSD异步I-O" class="headerlink" title="BSD异步I/O"></a>BSD异步I/O</h3><p>在BSD派生的系统中，异步I/O是信号<code>SIGIO</code>和<code>SIGURG</code>的组合。<code>SIGIO</code>是通用异步I/O信号，<code>SIGURG</code>则只用来通知进程网络连接上的带外数据已经到达。为了接收SIGIO信号，需执行以下3步。</p>
<ol>
<li>调用<code>signal</code>或<code>sigaction</code>为<code>SIGIO</code>信号建立信号处理程序。</li>
<li>以命令<code>F_SETOWN</code>调用tentl来设置进程ID或进程组ID，用于接收时对于该描述符的信号。</li>
<li>以命令<code>F_SETPL</code>调用<code>fcnt1</code>设置<code>O_ASYNC</code>文件状态标志，使在该描述符上可以进行异步I/O。</li>
</ol>
<h3 id="POSIX异步I-O"><a href="#POSIX异步I-O" class="headerlink" title="POSIX异步I/O"></a>POSIX异步I/O</h3><p>POSIX异步I/O接口为对不同类型的文件进行异步I/O提供了一套一致的方法。这些异步I/O接口使用AIO控制块来描述I/O操作。<code>aiocb</code>结构定义了AIO控制块。该结构至少包括下面这些字段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alocb</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> aio_fildes;                <span class="comment">/* file descriptor */</span></span><br><span class="line">	<span class="type">off_t</span> aio_offset;              <span class="comment">/* file offset for I/O */</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">void</span> *aio_buf;        <span class="comment">/* buffer for I/O */</span></span><br><span class="line">	<span class="type">size_t</span> aio_nbytes;             <span class="comment">/* number of bytes to transfer */</span></span><br><span class="line">	<span class="type">int</span> aio_reqprior               <span class="comment">/* priority */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">aio_sigevent</span>;</span>  <span class="comment">/* signal information */</span></span><br><span class="line">	<span class="type">int</span> aio_lio_opcode;            <span class="comment">/* operation for list I/O */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>aio_fields</code>字段表示被打开用来读或写的文件损述符。读或写操作从<code>aio_offset</code>指定的偏移量开始。对于读操作，数据会复制到缓冲区中，该缓冲区从<code>aio_buf</code>指定的地址开始。对于写操作，数据会从这个缓冲区中复制出来。<code>aio_ nbytes</code>字段包含了要读或写的字节数。注意，异步I/O操作必须显式地指定偏移量。异步I/O接口并不影响由操作系统维护的文件偏移量。如果使用异步I/O接口向一个以追加模式(使用<code>O_APPEND</code>)打开的文件中写入数据，AIO控制块中的<code>aio_offset</code>字段会被系统忽略。</p>
<p>其他字段和传统I/O函数中的不一致。应用程序使用<code>aio_reqprio</code>字段为异步I/O请求提示顺序。然而，系统对于该顺序只有有限的控制能力，因此不一定能遵循该提示。<code>aio_lio_opcode</code>字段只能用于基于列表的异步I/O，<code>aio_sigevent</code>字段控制，在I/O事件完成后，如何通知应用程序。这个字段通过<code>sigevent</code>结构来描述。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">migevent</span> &#123;</span></span><br><span class="line"><span class="type">int</span>   sigev_notitys                           <span class="comment">/* notity type */</span></span><br><span class="line"><span class="type">int</span>   sigev_signos                            <span class="comment">/* aignai number */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">sigval</span> <span class="title">sigev_value</span>;</span>                     <span class="comment">/* notify arqument */</span></span><br><span class="line"><span class="type">void</span> (*sigev_notify_funetion) (<span class="keyword">union</span> sigval); <span class="comment">/* notify function */</span></span><br><span class="line"><span class="type">pthread_attr_t</span> *sigev_notify_attributes;      <span class="comment">/* notity attrs */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>sigev_notify</code>字段控制通知的类型。取值可能是以下3个中的一个。</p>
<ul>
<li><code>SIGEV_NONE</code>：异步I/O请求完成后，不通知进程。</li>
<li><code>SIGEV_SIGNAL</code>：异步IO请求完成后，产生由<code>sigev_signo</code>字段指定的信号。如果应用程序已选择捕捉信号，且在建立信号处理程序的时候指定了<code>SA_SIGINFO</code>标志，那么该信号将被入队(如果实现支持捶队信号)。信号处理程序会传送给一个<code>siginfo</code>结构，该结构的<code>si_value</code>字段被设置为<code>sigev_value</code>(如果使用了<code>SA_SIGINFO</code>标志)。</li>
<li><code>SIGEV_THREAD</code>：当异步I/O请求完成时，由<code>sigev_notify_function</code>字段指定的函数被调用。<code>sigev_value</code>字段被传入作为它的唯一参数。除非<code>sigev_notify_attributes</code>字段被设定为<code>pthread</code>属性结构的地址，且该结构指定了一个另外的线程属性，否则该函数将在分离状态下的一个单独的线程中执行。</li>
</ul>
<p>在进行异步I/O之前需要先初始化AIO控制块，调用<code>aio_read</code>函数来进行异步读操作，或调用<code>aio_write</code>函数来进行异步写操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> caio.h&gt;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">aio_read</span> <span class="params">(<span class="keyword">struct</span> aiocb *aiocb)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">aio_write</span> <span class="params">(<span class="keyword">struct</span> aiocb *aiocb)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>当这些函数返回成功时，异步I/O请求便已经被操作系统放入等待处理的队列中了。这些返回值与实际I/O操作的结果没有任何关系。I/O操作在等待时，必须注意确保AIO控制块和数据库缓冲区保持稳定；它们下面对应的内存必须始终是合法的，除非I/O操作完成，否则不能被复用。要想强制所有等待中的异步操作不等待而写入持久化的存储中，可以设立一个AIO控制块并调用<code>aio_fsync</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">aio_async</span><span class="params">(<span class="type">int</span> op, <span class="keyword">struct</span> aiocb *aiocb)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>AIO控制块中的<code>aio_fildes</code>字段指定了其异步写操作被同步的文件。如果<code>op</code>参数设定为<code>O_DSYNC</code>，那么操作执行起来就会像调用了<code>fdatasync</code>一样。否则，如果<code>op</code>参数设定为<code>O_SYNC</code>，那么操作执行起来就会像调用了<code>fsync</code>一样。</p>
<p>像<code>aio_read</code>和<code>aio_write</code>函数一样，在安排了同步时，<code>aio_fsync</code>操作返回。在异步同步操作完成之前，数据不会被持久化。AIO控制块控制我们如何被通知，就像<code>aio_read</code>和<code>aio_write</code>函数一样，为了获知一个异步读、写或者同步操作的完成状态，需要调用<code>aio_error</code>函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">aio_error</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> aiocb *aiocb)</span>;</span><br></pre></td></tr></table></figure></p>
<p>返回值为下面4种情况中的一种</p>
<ul>
<li>0：异步操作成功完成。需要调用<code>aio_return</code>函数获取操作返回值。</li>
<li>-1：对<code>aio_error</code>的调用失败。这种情况下，errno会告诉我们为什么。</li>
<li><code>EINPROGRESS</code>：异步读、写或同步操作仍在等待。</li>
<li>其他情况：其他任何返回值是相关的异步操作失败返回的错误码。</li>
</ul>
<p>如果异步操作成功，可以调用<code>aio_return</code>函数来获取异步操作的返回值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">aio_return</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> aiocb *aiocb)</span>;</span><br></pre></td></tr></table></figure></p>
<p>直到异步操作完成之前，都需要小心不要调用<code>aio_return</code>函数。操作完成之前的结果是来定义的。还需要小心对每个异步操作只调用一次<code>aio_return</code>。一旦调用了该函数，操作系统就可以释放掉包含了I/O操作返回值的记录。如果<code>aio_return</code>函数本身失败，会返回-1，并设置errno。其他情况下，它将返回异步操作的结果，即会返回<code>read</code>、<code>write</code>或者<code>fsync</code>在被成功调用时可能返回的结果。</p>
<p>执行I/O操作时，如果还有其他事务要处理而不想被I/O操作阻塞，就可以使用异步I/O。然如果在完成了所有事务时，还有异步操作未完成时，可以调用<code>aio_suspend</code>函数来阻塞进直到操作完成。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">aio_suspend</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> aiocb *<span class="type">const</span> <span class="built_in">list</span>[], <span class="type">int</span> nent, <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>aio_suspend</code>可能会返回三种情况中的一种。</p>
<ul>
<li>如果我们被一个信号中断，它将会返回-1，并将errno设置为EINTR。</li>
<li>如果在没有任何I/O操作完成的情况下，阻塞的时间超过了函数中可选的<code>timeout</code>参数所指定的时间限制，那么<code>aio_suspend</code>将返回-1，并将errno设置为EAGAIN。</li>
<li>如果有任何I/O操作完成，<code>aio_suspend</code>将返回0。</li>
<li>如果在我们调用<code>aio_suspend</code>操作时，所有的异步I/O操作都已完成，那么<code>aio_suspend</code>将在不阻塞的情况下直接返回。</li>
</ul>
<p><code>list</code>参数是一个指向AIO控制块数组的指针，<code>nent</code>参数表明了数组中的条目数。数组中的空指针会被跳过，其他条目都必须指向已用于初始化异步I/O操作的AIO控制块。</p>
<p>当还有我们不想再完成的等待中的异步I/O操作时，可以尝试使用<code>aio_cancel</code>函数来取消它们。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">aio_cancel</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> aiocb *aiocb)</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>fd</code>参数指定了那个未完成的异步I/O操作的文件描述符。如果<code>aiocb</code>参数为NULL，系统将会尝试取消所有该文件上未完成的异步I/O操作。其他情况下，系统将尝试取消由AIO控制块描述的单个异步I/O操作。我们之所以说系统“尝试”取消操作，是因为无法保证系统能够取消正在进程中的任何操作。</p>
<p><code>aio_cancel</code>函数可能会返回以下4个值中的一个。</p>
<ul>
<li><code>AIO_ALLDONE</code>：所有操作在尝试取消它们之前已经完成。</li>
<li><code>AIO_CANCELED</code>：所有要求的操作已被取消</li>
<li><code>AIO_NOTCANCELED</code>：至少有一个要求的操作没有被取消.</li>
<li>-1：对<code>aio_cancel</code>的调用失败，错误码将被存储在errno中。</li>
</ul>
<p>如果异步I/O操作被成功取消，对相应的AIO控制块调用<code>aio_error</code>函数将会返回错误ECANCELED。如果操作不能被取消，那么相应的AIO控制块不会因为对<code>aio_cancel</code>的调用而被修改。</p>
<p>还有一个函数也被包含在异步I/O接口当中，尽管它既能以同步的方式来使用，又能以异步的方式来使用，这个函数就是<code>lio_listio</code>。该函数提交一系列由一个AIO控制块列表描述的IO请求。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lio_lintio</span><span class="params">(<span class="type">int</span> mode, <span class="keyword">struct</span> aiocb *<span class="keyword">restrict</span> <span class="type">const</span> <span class="built_in">list</span>[<span class="keyword">restrict</span>],</span></span><br><span class="line"><span class="params">	<span class="type">int</span> nent, <span class="keyword">struct</span> sigevent *<span class="keyword">restrict</span> sigev)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>mode</code>参数决定了I/O是否真的是异步的。如果该参数被设定为<code>LIO_WAIT</code>，<code>lio_listio</code>函数将在所有由列表指定的I/O操作完成后返回。在这种情况下，<code>sigev</code>参数将被忽略。如果<code>mode</code>参数被设定为<code>LIO_NOWAIT</code>，<code>lio_listio</code>函数将在I/O请求入队后立即返回。进程将在所有I/O操作完成后，按照<code>sigev</code>参数指定的，被异步地通知。如果不想被通知，可以把<code>sigev</code>设定为NULL。注意，每个AIO控制块本身也可能肩用了在各自操作完成时的异步通知。被<code>sigev</code>参数指定的异步通知是在此之外另加的，并且只会在所有的I/O操作完成后发送。</p>
<p><code>list</code>参数指向AIO控制块列表，该列表指定了要运行的I/O操作的。<code>nent</code>参数指定了数组中的元素个数。AIO控制块列表可以包含NULL指针，这些条目将被忽略。</p>
<p>在每一个AIO控制块中，<code>alo_lio_opcode</code>字段指定了该操作是一个读操作(<code>LIO_READ</code>)、写操作(<code>LIO_WRITE</code>)，还是将被忽略的空操作(<code>LIO_NOP</code>)。 读操作会按照对应的AIO控制块被传给了<code>aio_read</code>函数来处理。类似地，写操作会按照对应的AIO控制块被传给了<code>aio_write</code>函数来处理。</p>
<p>实现会限制我们不想完成的异步I/O操作的数量。这些限制都是运行时不变量。</p>
<p>可以通过调用<code>sysconf</code>函数并把<code>name</code>参数设置为<code>_SC_IO_LISTIO_MAX</code>来设定<code>AIO_LISTIO_MAX</code>的值。类似地，可以通过调用<code>sysconf</code>并把<code>name</code>参数设置为<code>_SC_AIO_MAX</code>来设定<code>AIO_MAX</code>的值，通过调用<code>sysconf</code>并把其参数设置为<code>_SC_AIO_PRIO_DELTA_MAX</code>来设定<code>AIO_PRIO_DELTA_MAX</code>的值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>可接受的最小值</th>
</tr>
</thead>
<tbody>
<tr>
<td>AIO_LISTIO_MAX</td>
<td>单个列表I/O调用中的最大I/O操作数</td>
<td><code>_POSIX_AIO_LISTIO_MAX(2)</code></td>
</tr>
<tr>
<td>AIO_MAX</td>
<td>未完成的异步I/O操作的最大数目</td>
<td><code>_POSIX_AIO_MAX(1)</code></td>
</tr>
<tr>
<td>AIO_PRIO_DELTA_MAX</td>
<td>进程可以减少的其异步I/O优先级的最大值</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>引入POSIX异步操作IO接口的初衷是为实时应用提供一种方法，避免在执行I/O操作时阻塞进程。</p>
<p>从输入文件中读取一个块，翻译之，然后再把这个块写到输出文件中。重复该步骤直到遇到文件尾端，read返回0。程序展示了如何使用异步I/O函数完成。<br><figure class="highlight plaintext"><figcaption><span>"apue.h"</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;aio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">#define BSZ 4096</span><br><span class="line">#define NBUF 8</span><br><span class="line"></span><br><span class="line">enum rwop &#123;</span><br><span class="line">	UNUSED = 0,</span><br><span class="line">	READ_PENDING = 1,</span><br><span class="line">	WRITE_PENDING = 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct buf &#123;</span><br><span class="line">	enum rwop     op;</span><br><span class="line">	int           last;</span><br><span class="line">	struct aiocb  aiocb;</span><br><span class="line">	unsigned char data[BSZ];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct buf bufs[NBUF];</span><br><span class="line"></span><br><span class="line">unsigned char</span><br><span class="line">translate(unsigned char c)</span><br><span class="line">&#123;</span><br><span class="line">	/* same as before */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int					ifd, ofd, i, j, n, err, numop;</span><br><span class="line">	struct stat			sbuf;</span><br><span class="line">	const struct aiocb	*aiolist[NBUF];</span><br><span class="line">	off_t				off = 0;</span><br><span class="line"></span><br><span class="line">	if (argc != 3)</span><br><span class="line">		err_quit(&quot;usage: rot13 infile outfile&quot;);</span><br><span class="line">	if ((ifd = open(argv[1], O_RDONLY)) &lt; 0)</span><br><span class="line">		err_sys(&quot;can&#x27;t open %s&quot;, argv[1]);</span><br><span class="line">	if ((ofd = open(argv[2], O_RDWR|O_CREAT|O_TRUNC, FILE_MODE)) &lt; 0)</span><br><span class="line">		err_sys(&quot;can&#x27;t create %s&quot;, argv[2]);</span><br><span class="line">	if (fstat(ifd, &amp;sbuf) &lt; 0)</span><br><span class="line">		err_sys(&quot;fstat failed&quot;);</span><br><span class="line"></span><br><span class="line">	/* initialize the buffers */</span><br><span class="line">	for (i = 0; i &lt; NBUF; i++) &#123;</span><br><span class="line">		bufs[i].op = UNUSED;</span><br><span class="line">		bufs[i].aiocb.aio_buf = bufs[i].data;</span><br><span class="line">		bufs[i].aiocb.aio_sigevent.sigev_notify = SIGEV_NONE;</span><br><span class="line">		aiolist[i] = NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	numop = 0;</span><br><span class="line">	for (;;) &#123;</span><br><span class="line">		for (i = 0; i &lt; NBUF; i++) &#123;</span><br><span class="line">			switch (bufs[i].op) &#123;</span><br><span class="line">			case UNUSED:</span><br><span class="line">				/*</span><br><span class="line">				 * Read from the input file if more data</span><br><span class="line">				 * remains unread.</span><br><span class="line">				 */</span><br><span class="line">				if (off &lt; sbuf.st_size) &#123;</span><br><span class="line">					bufs[i].op = READ_PENDING;</span><br><span class="line">					bufs[i].aiocb.aio_fildes = ifd;</span><br><span class="line">					bufs[i].aiocb.aio_offset = off;</span><br><span class="line">					off += BSZ;</span><br><span class="line">					if (off &gt;= sbuf.st_size)</span><br><span class="line">						bufs[i].last = 1;</span><br><span class="line">					bufs[i].aiocb.aio_nbytes = BSZ;</span><br><span class="line">					if (aio_read(&amp;bufs[i].aiocb) &lt; 0)</span><br><span class="line">						err_sys(&quot;aio_read failed&quot;);</span><br><span class="line">					aiolist[i] = &amp;bufs[i].aiocb;</span><br><span class="line">					numop++;</span><br><span class="line">				&#125;</span><br><span class="line">				break;</span><br><span class="line"></span><br><span class="line">			case READ_PENDING:</span><br><span class="line">				if ((err = aio_error(&amp;bufs[i].aiocb)) == EINPROGRESS)</span><br><span class="line">					continue;</span><br><span class="line">				if (err != 0) &#123;</span><br><span class="line">					if (err == -1)</span><br><span class="line">						err_sys(&quot;aio_error failed&quot;);</span><br><span class="line">					else</span><br><span class="line">						err_exit(err, &quot;read failed&quot;);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				/*</span><br><span class="line">				 * A read is complete; translate the buffer</span><br><span class="line">				 * and write it.</span><br><span class="line">				 */</span><br><span class="line">				if ((n = aio_return(&amp;bufs[i].aiocb)) &lt; 0)</span><br><span class="line">					err_sys(&quot;aio_return failed&quot;);</span><br><span class="line">				if (n != BSZ &amp;&amp; !bufs[i].last)</span><br><span class="line">					err_quit(&quot;short read (%d/%d)&quot;, n, BSZ);</span><br><span class="line">				for (j = 0; j &lt; n; j++)</span><br><span class="line">					bufs[i].data[j] = translate(bufs[i].data[j]);</span><br><span class="line">				bufs[i].op = WRITE_PENDING;</span><br><span class="line">				bufs[i].aiocb.aio_fildes = ofd;</span><br><span class="line">				bufs[i].aiocb.aio_nbytes = n;</span><br><span class="line">				if (aio_write(&amp;bufs[i].aiocb) &lt; 0)</span><br><span class="line">					err_sys(&quot;aio_write failed&quot;);</span><br><span class="line">				/* retain our spot in aiolist */</span><br><span class="line">				break;</span><br><span class="line"></span><br><span class="line">			case WRITE_PENDING:</span><br><span class="line">				if ((err = aio_error(&amp;bufs[i].aiocb)) == EINPROGRESS)</span><br><span class="line">					continue;</span><br><span class="line">				if (err != 0) &#123;</span><br><span class="line">					if (err == -1)</span><br><span class="line">						err_sys(&quot;aio_error failed&quot;);</span><br><span class="line">					else</span><br><span class="line">						err_exit(err, &quot;write failed&quot;);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				/*</span><br><span class="line">				 * A write is complete; mark the buffer as unused.</span><br><span class="line">				 */</span><br><span class="line">				if ((n = aio_return(&amp;bufs[i].aiocb)) &lt; 0)</span><br><span class="line">					err_sys(&quot;aio_return failed&quot;);</span><br><span class="line">				if (n != bufs[i].aiocb.aio_nbytes)</span><br><span class="line">					err_quit(&quot;short write (%d/%d)&quot;, n, BSZ);</span><br><span class="line">				aiolist[i] = NULL;</span><br><span class="line">				bufs[i].op = UNUSED;</span><br><span class="line">				numop--;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (numop == 0) &#123;</span><br><span class="line">			if (off &gt;= sbuf.st_size)</span><br><span class="line">				break;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			if (aio_suspend(aiolist, NBUF, NULL) &lt; 0)</span><br><span class="line">				err_sys(&quot;aio_suspend failed&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bufs[0].aiocb.aio_fildes = ofd;</span><br><span class="line">	if (aio_fsync(O_SYNC, &amp;bufs[0].aiocb) &lt; 0)</span><br><span class="line">		err_sys(&quot;aio_fsync failed&quot;);</span><br><span class="line">	exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，我们使用了8个缓冲区，因此可以有最多8个异步I/O请求处于等待状态。在检查操作的返回值之前，必须确认操作已经完成。当<code>aio_error</code>返回的值既非EINPROGRESS亦非-1时，表明操作完成。除了这些值之外，如果返回值是0以外的任何值，说明操作失败了。一旦检查过这些情况，便可以安全地调用<code>aio_return</code>来获取I/O操作的返回值了。</p>
<p>只要还有事情要做，就可以提交异步I/O操作。当存在未使用的AIO控制块时，可以提交一个异步读操作。读操作完成后，翻译缓冲区中的内容并将它提交给一个异步写请求。当所有AIO控制块都在使用中时，通过调用<code>aio_suspend</code>等待操作完成。</p>
<h2 id="函数readv和writev"><a href="#函数readv和writev" class="headerlink" title="函数readv和writev"></a>函数readv和writev</h2><p><code>readv</code>和<code>writev</code>函数用于在一次函数调用中读、写多个非连续缓冲区。有时也将这两个函数称为散布读(scatter read)和聚集写(gather write)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ays/uio.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovent)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovent)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，已读或已写的字节数；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>这两个函数的第二个参数是指向<code>iovec</code>结构数组的一个指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> *iov_bases <span class="comment">/* starting address of buffer */</span></span><br><span class="line">	<span class="type">size_t</span> iov_len; <span class="comment">/* size of buffer */</span></span><br></pre></td></tr></table></figure></p>
<p><code>iov</code>数组中的元素数由<code>iovent</code>指定，其最大值受限于<code>IOV_MAX</code>。图中显示了这两个函数的参数和<code>iovec</code>结构之间的关系。<br><img src="/img/20210604122019.png" alt=""></p>
<p><code>writev</code>函数从缓冲区中来集输出数据的顺序是：<code>iov[0]</code>、<code>iov[1]</code>直至<code>iov[iovent-1]</code>。<code>writev</code>返回输出的字节总数，通常应等于所有缓冲区长度之和。</p>
<p><code>readv</code>函数则将读入的数据按上述同样顺序散布到缓冲区中。<code>readv</code>总是先填满一个缓冲区，然后再填写下一个。<code>readv</code>返回读到的字节总数。如果遇到文件尾端，己无数据可读，则返回0。</p>
<h2 id="函数readn和writen"><a href="#函数readn和writen" class="headerlink" title="函数readn和writen"></a>函数readn和writen</h2><p>管道、FIFO以及某些设备(特别是终端和网络)有下列两种性质。</p>
<ol>
<li>一次<code>read</code>操作所返回的数据可能少于所要求的数据，即使还没达到文件尾端也可能是这样。这不是一个错误，应当继续读该设备。</li>
<li>一次<code>write</code>操作的返回值也可能少于指定输出的字节数。这可能是由某个因素造成的。</li>
</ol>
<p>在读、写磁盘文件时从未见到过这种情况，除非文件系统用完了空间，或者接近了配额限制，不能将要求写的数据全部写出。</p>
<p>通常，在读、写一个管道、网络设备或终端时，需要考虑这些特性。下面两个函数<code>readn</code>和<code>writen</code>的功能分别是读、写指定的N字节数据，并处理返回值可能小于要求值的情况。这两个函数只是按需多次调用<code>read</code>和<code>write</code>直至读、写了N字节数据。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> nbyees)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：读、写的字节数，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>在要将数据写到上面提到的文件类型上时，就可调用<code>writen</code>，但是仅当事先就知道要接收数据的数量时，才调用<code>readn</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span>             <span class="comment">/* Read &quot;n&quot; bytes from a descriptor  */</span></span><br><span class="line">readn(<span class="type">int</span> fd, <span class="type">void</span> *ptr, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span>		nleft;</span><br><span class="line">	<span class="type">ssize_t</span>		nread;</span><br><span class="line"></span><br><span class="line">	nleft = n;</span><br><span class="line">	<span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((nread = read(fd, ptr, nleft)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nleft == n)</span><br><span class="line">				<span class="keyword">return</span>(<span class="number">-1</span>); <span class="comment">/* error, return -1 */</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;      <span class="comment">/* error, return amount read so far */</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;          <span class="comment">/* EOF */</span></span><br><span class="line">		&#125;</span><br><span class="line">		nleft -= nread;</span><br><span class="line">		ptr   += nread;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(n - nleft);      <span class="comment">/* return &gt;= 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，若在已经读、写了一些数据之后出错，则这两个函数返回的是已传输的数据量，而非错误。与此类似，在读时，如达到文件尾端，而且在此之前已成功地读了一些数据，但尚未满足所要求的量，则<code>readn</code>返回已复制到调用者缓冲区中的字节数。</p>
<h2 id="存储映射I-O"><a href="#存储映射I-O" class="headerlink" title="存储映射I/O"></a>存储映射I/O</h2><p>存储映射I/O(memory-mapped I/O)能将一个磁盘文件映射到存储空间中的一个缓冲区上，于是。当从缓冲区中取数据时，就相当于读文件中的相应字节。与此类似，将数据存入缓冲区时，相应字节就自动写入文件。这样，就可以在不使用<code>read</code>和<code>write</code>的情况下执行I/O。</p>
<p>为了使用这种功能，应首先告诉内核将一个给定的文件映射到一个存储区域中。这是由<code>map</code>函数实现的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot, <span class="type">int</span> flag, <span class="type">int</span> fd, <span class="type">off_t</span> off)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回映射区的起始地址；若出错，返回MAP.PAILED</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>addr</code>参数用于指定映射存储区的起始地址。通常将其设置为0。这表示由系统选择该映射区的起始地址。此函数的返回值是该映射区的起始地址。</li>
<li><code>fd</code>参数是指定要被映射文件的描述符。在文件映射到地址空间之前，必须先打开该文件。<code>len</code>参数是映射的字节数，<code>off</code>是要映射字节在文件中的起始偏移量。</li>
<li><code>prot</code>参数指定了映射存储区的保护要求，如下所示。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>prot</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>PROT_READ</td>
<td>映射区可读</td>
</tr>
<tr>
<td>PROT_WRITE</td>
<td>映射区可写</td>
</tr>
<tr>
<td>PROT_EXEC</td>
<td>映射区可执行</td>
</tr>
<tr>
<td>PROT_NONE</td>
<td>映射区不可访问</td>
</tr>
</tbody>
</table>
</div>
<p>可将<code>prot</code>参数指定任意组合的按位或。对指定映射存储区的保护要求不能超过文件<code>open</code>模式访问权限。</p>
<p>图中显示了一个存储映射文件。在此图中，“起始地址”是<code>mmap</code>的返回值。映射存储区位于堆和栈之间。<br><img src="/img/20210604124542.png" alt=""></p>
<p>下面是<code>flag</code>参数影响映射存储区的多种属性</p>
<ul>
<li><code>MAP_FIXED</code>：返回值必须等于<code>addr</code>，因为这不利于可移植性，所以不鼓励使用此标志。如果未指定此标志，而且<code>addr</code>非0，则内核只把<code>addr</code>视为在何处设置映射区的一种建议，但是不保证会使用所要求的地址。将<code>addr</code>指定为0可获得最大可移植性。</li>
<li><code>MAR_SHARED</code>：这一标志描述了本进程对映射区所进行的存储操作的配置。此标志指定存储操作修改映射文件。</li>
<li><code>MAP_PRIVATE</code>：本标志说明，对映射区的存储操作导致创建该映射文件的一个私有副本。所有后来对该映射区的引用都是引用该副本。</li>
</ul>
<p><code>off</code>的值和<code>addr</code>的值(如果指定了<code>MAP_FIXED</code>)通常被要求是系统虚拟存储页长度的倍数。虚拟存储页长可用带参数<code>_SC_PAGESIZE</code>或<code>SC_PAGE_SIZE</code>的<code>sysconf</code>函数得到。因为<code>off</code>和<code>addr</code>常常指定为0，所以这种要求一般并不重要。</p>
<p>既然映射文件的起始偏移量受系统虚拟存储页长度的限制，那么如果映射区的长度不是页长的整数倍时，文件长为12字节， 系统页长为512字节，则系统通常提供512字节的映射区，其中后500字节被设置为0。可以修改后面的这500字节，但任何变动都不会在文件中反映出来。于是，不能用<code>mmap</code>将数据添加到文件中。</p>
<p>与映射区相关的信号有<code>SIGSEGV</code>和<code>SIGBUS</code>。信号<code>SIGSEGV</code>通常用于指示进程试图访问对它不可用的存储区。如果映射存储区被<code>mmap</code>指定成了只读的，那么进程试图将数据存入这个映射存储区的时候，也会产生此信号。如果映射区的某个部分在访问时已不存在，则产生<code>SIGBUS</code>信号。例如，假设用文件长度映射了一个文件，但在引用该映射区之前，另一个进程已将该文件截断。此时，如果进程试图访问对应于该文件已截去部分的映射区，将会接收到<code>SIGBUS</code>信号。</p>
<p>子进程能通过<code>fork</code>继承存储映射区(因为子进程复制父进程地址空间，而存储映射区是该地址空间中的一部分)，但是由于同样的原因，新程序则不能通过<code>exec</code>继承存储映射区。</p>
<p>调用<code>mprotect</code>可以更改一个现有映射的权限。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mprotect</span> <span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>prot</code>的合法值与<code>mmap</code>中<code>prot</code>参数的一样。请注意，地址参数<code>addr</code>的值必须是系统页长的整数倍。</p>
<p>如果修改的页是通过<code>MAP_SHARED</code>标志映射到地址空间的，那么修改并不会立即写回到文件中。相反，何时写回脏页由内核的守护进程决定，决定的依据是系统负载和用来限制在系统失败事件中的数据损失的配置参数。因此，如果只修改了一页中的一个字节，当修改被写回到文件中时，整个页都会被写回。</p>
<p>如果共享映射中的页已修改，那么可以调用<code>msync</code>将该页冲洗到被映射的文件中。<code>msync</code>函数类似于<code>fsync</code>，但作用于存储映射区。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/man.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msync</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>如果映射是私有的，那么不修改被映射的文件。与其他存储映射函数一样，地址必须与页边界对齐。</p>
<p><code>flags</code>参数使我们对如何冲洗存储区有某种程度的控制。可以指定<code>MS_ASYNC</code>标志来简单地调试要写的页。如果希望在返回之前等待写操作完成，则可指定<code>MS_SYNC</code>标志。一定要指定<code>MS_ASYNC</code>和<code>MS_SYNC</code>中的一个。</p>
<p><code>MS_INVALIDATE</code>是一个可选标志， 允许我们通知操作系统丢弃那些与底层存储器没有同步的页。若使用了此标志，某些实现将丢弃指定范围中的所有页，但这种行为并不是必需的。</p>
<p>当进程终止时，会自动解除存储映射区的映射，或者直接调用<code>munmap</code>函数也可以解除映射。关闭映射存储区时使用的文件描述符并不解除映射区。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>munmap</code>并不影响被映射的对象，也就是说，调用<code>munmap</code>并不会使映射区的内容写到磁盘文件上。对于<code>MAR_SHARED</code>区磁盘文件的更新， 会在我们将数据写到存储映射区后的某个时刻，按内核虚拟存储算法自动进行。在存储区解除映射后，对<code>MAP_PRIVATE</code>存储区的修改会被丢弃。</p>
<p>程序用存储映射I/O复制文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COPYINCR (1024*1024*1024)	<span class="comment">/* 1 GB */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>			fdin, fdout;</span><br><span class="line">	<span class="type">void</span>		*src, *dst;</span><br><span class="line">	<span class="type">size_t</span>		copysz;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span>	<span class="title">sbuf</span>;</span></span><br><span class="line">	<span class="type">off_t</span>		fsz = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;usage: %s &lt;fromfile&gt; &lt;tofile&gt;&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fdin = open(argv[<span class="number">1</span>], O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;can&#x27;t open %s for reading&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fdout = open(argv[<span class="number">2</span>], O_RDWR | O_CREAT | O_TRUNC,</span><br><span class="line">	  FILE_MODE)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;can&#x27;t creat %s for writing&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fstat(fdin, &amp;sbuf) &lt; <span class="number">0</span>)			<span class="comment">/* need size of input file */</span></span><br><span class="line">		err_sys(<span class="string">&quot;fstat error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ftruncate(fdout, sbuf.st_size) &lt; <span class="number">0</span>)	<span class="comment">/* set output file size */</span></span><br><span class="line">		err_sys(<span class="string">&quot;ftruncate error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fsz &lt; sbuf.st_size) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((sbuf.st_size - fsz) &gt; COPYINCR)</span><br><span class="line">			copysz = COPYINCR;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			copysz = sbuf.st_size - fsz;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((src = mmap(<span class="number">0</span>, copysz, PROT_READ, MAP_SHARED,</span><br><span class="line">		  fdin, fsz)) == MAP_FAILED)</span><br><span class="line">			err_sys(<span class="string">&quot;mmap error for input&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> ((dst = mmap(<span class="number">0</span>, copysz, PROT_READ | PROT_WRITE,</span><br><span class="line">		  MAP_SHARED, fdout, fsz)) == MAP_FAILED)</span><br><span class="line">			err_sys(<span class="string">&quot;mmap error for output&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memcpy</span>(dst, src, copysz);	<span class="comment">/* does the file copy */</span></span><br><span class="line">		munmap(src, copysz);</span><br><span class="line">		munmap(dst, copysz);</span><br><span class="line">		fsz += copysz;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该程序首先打开两个文件，然后调用<code>fstat</code>得到输入文件的长度。在为输入文件调用<code>map</code>和设置输出文件长度时都需使用输入文件长度。可以调用<code>ftruncate</code>设置输出文件的长度。如果不设置输出文件的长度，则对输出文件调用<code>mmap</code>也可以，但是对相关存储区的第一次引用会产生SIGBUS信号。</p>
<p>然后对每个文件调用<code>mmap</code>，将文件映射到内存，最后调用<code>memcpy</code>将输入缓冲区的内容复制到输出缓冲区。为了限制使用内存的量，我们每次最多复制1GB的数据(如果系统没有足够的内存，可能无法把一个很大的文件中的所有内容都映射到内存中)。在映射文件中的后一部分数据之前，我们需要解除前一部分数据的映射。</p>
<p>在从输入缓冲区(src)取数据字节时，内核自动读输入文件：在将数据存入输出缓冲区(dst)时，内核自动将数据写到输出文件中。</p>
<p>数据被写到文件的确切时间依赖于系统的页管理算法。某些系统设置了守护进程，在系统运行期间，它慢条斯理地将改写过的页写到磁盘上。如果想要确保数据安全地写到文件中，则需在进程终止前以<code>MS_SYNC</code>标志调用<code>msync</code>。</p>
<p>使用<code>mmap</code>和<code>memcpy</code>复制，与使用<code>read</code>和<code>write</code>相比，花费了更多的用户时间，但却减少了系统时间。在Linux中，用<code>read</code>和<code>write</code>消耗的系统时间要比使用<code>mmap</code>和<code>memcpy</code>略好一些。这两种版本的方法是殊途同归的。</p>
<p>二者的主要区别在于，与<code>mmap</code>和<code>memcpy</code>相比，<code>read</code>和<code>write</code>执行了更多的系统调用，并做了更多的复制。<code>read</code>和<code>write</code>将数据从内核缓冲区中复制到应用缓冲区(read)，然后再把数据从应用缓冲区复制到内核缓冲区(write)。而<code>mmap</code>和<code>memcpy</code>则直接把数据从映射到地址空间的一个内核缓冲区复制到另一个内核缓冲区。当引用尚不存在的内存页时，这样的复制过程就会作为处理页错误的结果面出现(每次错页读发生一次错误， 每次错页写发生一次错误)。如果系统调用和额外的复制操作的开销和页错误的开销不同，那么这两种方法中就会有一种比另一种表现更好。</p>
<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="引言-3"><a href="#引言-3" class="headerlink" title="引言"></a>引言</h2><p>进程间通信(InterProcess Communication, IPC)是各种进程通信方式的统称。</p>
<ul>
<li>半双工管道</li>
<li>FIFO</li>
<li>全双工管道</li>
<li>命名全双工管道</li>
<li>XSI消息队列</li>
<li>XSI信号量</li>
<li>XSI共享存储</li>
<li>消息队列(实时)</li>
<li>信号量</li>
<li>共享存储(实时)</li>
<li>套接字</li>
<li>STREAMS</li>
</ul>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道是UNIX系统IPC的最古老形式，所有UNIX系统都提供此种通信机制。管道有以下两种局限性：</p>
<ol>
<li>历史上，它们是半双工的(即数据只能在一个方向上流动)。现在，某些系统提供全双工管道。</li>
<li>管道只能在具有公共祖先的两个进程之间使用。通常，一个管道由一个进程创建，在进程调用<code>fork</code>之后，这个管道就能在父进程和子进程之间使用了。</li>
</ol>
<p>半双工管道仍是最常用的IPC形式。每当在管道中键入一个命令序列，让shell执行时，shell都会为每一条命令单独创建一个进程，然后用管道将前一条命令进程的标<br>准输出与后一条命令的标准输入相连接。</p>
<p>管道是通过调用<code>pipe</code>函数创建的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>经由参数<code>fd</code>返回两个文件描述符：<code>fd[0]</code>为读而打开，<code>f[1]</code>为写而打开。<code>fd[1]</code>的输出是<code>fd[0]</code>的输入。</p>
<p><code>fstat</code>函数对管道的每一端都返回一个FIFO类型的文件描述符。可以用<code>S_ISFIFO</code>宏来测试管道。POSIX.1规定<code>stat</code>结构的<code>st_size</code>成员对于管道是未定义的。但是当<code>fstat</code>函数应用于管道读端的文件描述符时，很多系统在<code>st_size</code>中存储管道中可用于读的字节数。但是，这是不可移植的。</p>
<p>单个进程中的管道几乎没有任何用处。通常，进程会先调用<code>pipe</code>，接着调用<code>fork</code>，从而创建从父进程到子进程的IPC通道，反之亦然。</p>
<p><code>fork</code>之后做什么取决于我们想要的数据流的方向。对于从父进程到子进程的管道，父进程关闭管道的读端(<code>fd[0]</code>)，子进程关闭写端(<code>fd[1]</code>)。</p>
<p>对于一个从子进程到父进程的管道，父进程关闭<code>fd[1]</code>，子进程关闭<code>fd[0]</code>。</p>
<p>当管道的一端被关闭后，下列两条规则起作用。</p>
<ol>
<li>当读(read)一个写已被关闭的管道时，在所有数据都被读取后，read返回0；表示文件结束。</li>
<li>如果写(write)一个读端已被关闭的管道，则产生信号<code>SIGPIPE</code>。如果忽略该信号或者捕捉该信号并从其处理程序返回，则<code>write</code>返回-1，errno设置为EPIPE.</li>
</ol>
<p>在写管道(或FIFO)时，常量<code>PIPE_BUF</code>规定了内核的管道缓冲区大小。如果对管道调用<code>write</code>，而且要求写的字节数小于等于<code>PIPE_BUF</code>，则此操作不会与其他进程对同一管道(或FIFO)的<code>write</code>操作交叉进行。但是，若有多个进程同时写一个管道(或FIFO)，而且我们要求写的字节数超过<code>PIPE_BUF</code>，那么我们所写的数据可能会与其他进程所写的数据相互交叉。用<code>pathconf</code>或<code>fpathconf</code>函数可以确定<code>PIPE_BUF</code>的值。</p>
<p>程序创建了一个从父进程到子进程的管道，并且父进程经由该管道向子进程传送数据。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		n;</span><br><span class="line">	<span class="type">int</span>		fd[<span class="number">2</span>];</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line">	<span class="type">char</span>	line[MAXLINE];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pipe(fd) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;		<span class="comment">/* parent */</span></span><br><span class="line">		close(fd[<span class="number">0</span>]);</span><br><span class="line">		write(fd[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;					<span class="comment">/* child */</span></span><br><span class="line">		close(fd[<span class="number">1</span>]);</span><br><span class="line">		n = read(fd[<span class="number">0</span>], line, MAXLINE);</span><br><span class="line">		write(STDOUT_FILENO, line, n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中，直接对管道描述符调用了<code>read</code>和<code>write</code>。更有趣的是将管道描述符复制到了标准输入或标准输出上。通常，子进程会在此之后执行另一个程序，该程序或者从标准输入(已创建的管道)读数据，或者将数据写至其标准输出(该管道)。</p>
<p>我们希望通过管道将输出直接送到分页程序。为此，先创建一个管道，<code>fork</code>一个子进程，使子进程的标准输入成为管道的读端，然后调用<code>exec</code>，执行用的分页程序。程序显示了如何实现这些操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	DEF_PAGER	<span class="string">&quot;/bin/more&quot;</span>		<span class="comment">/* default pager program */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		n;</span><br><span class="line">	<span class="type">int</span>		fd[<span class="number">2</span>];</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line">	<span class="type">char</span>	*pager, *argv0;</span><br><span class="line">	<span class="type">char</span>	line[MAXLINE];</span><br><span class="line">	FILE	*fp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;usage: a.out &lt;pathname&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fp = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;can&#x27;t open %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span> (pipe(fd) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;								<span class="comment">/* parent */</span></span><br><span class="line">		close(fd[<span class="number">0</span>]);		<span class="comment">/* close read end */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* parent copies argv[1] to pipe */</span></span><br><span class="line">		<span class="keyword">while</span> (fgets(line, MAXLINE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			n = <span class="built_in">strlen</span>(line);</span><br><span class="line">			<span class="keyword">if</span> (write(fd[<span class="number">1</span>], line, n) != n)</span><br><span class="line">				err_sys(<span class="string">&quot;write error to pipe&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ferror(fp))</span><br><span class="line">			err_sys(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line"></span><br><span class="line">		close(fd[<span class="number">1</span>]);	<span class="comment">/* close write end of pipe for reader */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;										<span class="comment">/* child */</span></span><br><span class="line">		close(fd[<span class="number">1</span>]);	<span class="comment">/* close write end */</span></span><br><span class="line">		<span class="keyword">if</span> (fd[<span class="number">0</span>] != STDIN_FILENO) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dup2(fd[<span class="number">0</span>], STDIN_FILENO) != STDIN_FILENO)</span><br><span class="line">				err_sys(<span class="string">&quot;dup2 error to stdin&quot;</span>);</span><br><span class="line">			close(fd[<span class="number">0</span>]);	<span class="comment">/* don&#x27;t need this after dup2 */</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* get arguments for execl() */</span></span><br><span class="line">		<span class="keyword">if</span> ((pager = getenv(<span class="string">&quot;PAGER&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">			pager = DEF_PAGER;</span><br><span class="line">		<span class="keyword">if</span> ((argv0 = <span class="built_in">strrchr</span>(pager, <span class="string">&#x27;/&#x27;</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">			argv0++;		<span class="comment">/* step past rightmost slash */</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			argv0 = pager;	<span class="comment">/* no slash in pager */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (execl(pager, argv0, (<span class="type">char</span> *)<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">&quot;execl error for %s&quot;</span>, pager);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在调用<code>fork</code>之前，先创建一个管道。调用<code>fork</code>之后，父进程关闭其读端，子进程关闭其写端。然后子进程调用<code>dup2</code>，使其标准输。入成为管道的读端。当执行分页程序时，其标准输入将是管道的读端。</p>
<p>将一个描述符复制到另一个上(在子进程中，<code>fd[0]</code>复制到标准输入)，在复制之前应当比较该描述符的值是否已经具有所希望的值。如果该描述符已经具有所希望的值，并且调用了<code>dup2</code>和<code>close</code>，那么该描述符的副本将关闭。</p>
<p>在本程序中，如果shell没有打开标准输入，那么程序开始处的<code>fopen</code>应已使用描述符0。也就是最小未使用的描述符，所以<code>fd[0]</code>决不会等于标准输入。尽管如此，无论何时调用<code>dup2</code>和<code>close</code>将一个描述符复制到另一个上，作为一种保护性的编程措施，都要先将两个描述符进行比较。</p>
<h2 id="函数popen和pclose"><a href="#函数popen和pclose" class="headerlink" title="函数popen和pclose"></a>函数popen和pclose</h2><p>常见的操作是创建一个连接到另一个进程的管道，然后读其输出或向其输入端发送数据，为此，标准I/O库提供了两个函数<code>popen</code>和<code>pclose</code>。这两个函数实现的操作是：创建一个管道，<code>fork</code>一个子进程，关闭未使用的管道端，执行一个shell运行命令，然后等待命令终止。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">popen</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *cmdstring, <span class="type">const</span> <span class="type">char</span> *type)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回文件指针；若出错，返回NULL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回cmdetring的终止状态；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>函数<code>popen</code>先执行<code>fork</code>，然后调用<code>exec</code>执行<code>cmdstring</code>，并且返回一个标准I/O文件指针。如果type是”r”，则文件指针连接到cmdstring的标准输出。如果ype是”w”，则文件指针连接到cmdstring的标准输入。</p>
<p>有一种方法可以帮助我们记住<code>popen</code>的最后一个参数及其作用，这就是与<code>fopen</code>进行类比。如果type是”r”，则返回的文件指针是可读的，如果type是”w”，则是可写的。</p>
<p><code>pclose</code>函数关闭标准I/O流，等待命令终止，然后返回shell的终止状态。如果shell不能被执行，则<code>pclose</code>返回的终止状态与shell已执行exit(127)一样，<code>cmdstring</code>由Bourne shell以下列方式执行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c cmdstring</span><br></pre></td></tr></table></figure></p>
<p>这表示shell将扩展<code>cmdstring</code>中的任何特殊字符。例如，可以使用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fp = popen(<span class="string">&quot;ls *.c&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fp = popen(<span class="string">&quot;cmd 2&gt;&amp;1&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>程序是我们编写的<code>popen</code>和<code>pclose</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pointer to array allocated at run-time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">pid_t</span>	*childpid = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * From our open_max(), &#123;Prog openmax&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span>		maxfd;</span><br><span class="line"></span><br><span class="line">FILE *</span><br><span class="line"><span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmdstring, <span class="type">const</span> <span class="type">char</span> *type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		i;</span><br><span class="line">	<span class="type">int</span>		pfd[<span class="number">2</span>];</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line">	FILE	*fp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* only allow &quot;r&quot; or &quot;w&quot; */</span></span><br><span class="line">	<span class="keyword">if</span> ((type[<span class="number">0</span>] != <span class="string">&#x27;r&#x27;</span> &amp;&amp; type[<span class="number">0</span>] != <span class="string">&#x27;w&#x27;</span>) || type[<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">		errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (childpid == <span class="literal">NULL</span>) &#123;		<span class="comment">/* first time through */</span></span><br><span class="line">		<span class="comment">/* allocate zeroed out array for child pids */</span></span><br><span class="line">		maxfd = open_max();</span><br><span class="line">		<span class="keyword">if</span> ((childpid = <span class="built_in">calloc</span>(maxfd, <span class="keyword">sizeof</span>(<span class="type">pid_t</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pipe(pfd) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);	<span class="comment">/* errno set by pipe() */</span></span><br><span class="line">	<span class="keyword">if</span> (pfd[<span class="number">0</span>] &gt;= maxfd || pfd[<span class="number">1</span>] &gt;= maxfd) &#123;</span><br><span class="line">		close(pfd[<span class="number">0</span>]);</span><br><span class="line">		close(pfd[<span class="number">1</span>]);</span><br><span class="line">		errno = EMFILE;</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);	<span class="comment">/* errno set by fork() */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;							<span class="comment">/* child */</span></span><br><span class="line">		<span class="keyword">if</span> (*type == <span class="string">&#x27;r&#x27;</span>) &#123;</span><br><span class="line">			close(pfd[<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">if</span> (pfd[<span class="number">1</span>] != STDOUT_FILENO) &#123;</span><br><span class="line">				dup2(pfd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">				close(pfd[<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			close(pfd[<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">if</span> (pfd[<span class="number">0</span>] != STDIN_FILENO) &#123;</span><br><span class="line">				dup2(pfd[<span class="number">0</span>], STDIN_FILENO);</span><br><span class="line">				close(pfd[<span class="number">0</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* close all descriptors in childpid[] */</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; maxfd; i++)</span><br><span class="line">			<span class="keyword">if</span> (childpid[i] &gt; <span class="number">0</span>)</span><br><span class="line">				close(i);</span><br><span class="line"></span><br><span class="line">		execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmdstring, (<span class="type">char</span> *)<span class="number">0</span>);</span><br><span class="line">		_exit(<span class="number">127</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* parent continues... */</span></span><br><span class="line">	<span class="keyword">if</span> (*type == <span class="string">&#x27;r&#x27;</span>) &#123;</span><br><span class="line">		close(pfd[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span> ((fp = fdopen(pfd[<span class="number">0</span>], type)) == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		close(pfd[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> ((fp = fdopen(pfd[<span class="number">1</span>], type)) == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	childpid[fileno(fp)] = pid;	<span class="comment">/* remember child pid for this fd */</span></span><br><span class="line">	<span class="keyword">return</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pclose</span><span class="params">(FILE *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		fd, stat;</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (childpid == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);		<span class="comment">/* popen() has never been called */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fd = fileno(fp);</span><br><span class="line">	<span class="keyword">if</span> (fd &gt;= maxfd) &#123;</span><br><span class="line">		errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);		<span class="comment">/* invalid file descriptor */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((pid = childpid[fd]) == <span class="number">0</span>) &#123;</span><br><span class="line">		errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);		<span class="comment">/* fp wasn&#x27;t opened by popen() */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	childpid[fd] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (fclose(fp) == EOF)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (waitpid(pid, &amp;stat, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">			<span class="keyword">return</span>(<span class="number">-1</span>);	<span class="comment">/* error other than EINTR from waitpid() */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(stat);	<span class="comment">/* return child&#x27;s termination status */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，每次调用<code>popen</code>时，应当记住所创建的子进程的进程ID, 以及其文件描述符或<code>FILE</code>指针。我们选择在数组<code>childpid</code>中保存子进程ID，并用文件描述符作为其下标。于是，当以<code>FILE</code>指针作为参数调用<code>pclose</code>时，调用标准I/O函数<code>fileno</code>得到文件描述符，然后取得子进程ID，并用其作为参数调用<code>waitpid</code>。因为一个进程可能调用<code>popen</code>多次，所以在动态分配<code>childpid</code>数组时(第一次调用<code>popen</code>时)，其数组长度应当是最大文件描述符数，于是该数组中可以存放与最大文件描述符数相同的子进程ID数。</p>
<p>POSIX.1要求<code>popen</code>关闭那些以前调用<code>popen</code>打开的、现在仍然在子进程中打开着的I/O流。为此，在子进程中从头逐个检查childpid数组的各个元素，关闭仍旧打开着的描述符。若<code>pclose</code>的调用者已经为信号SIGCHLD设置了一个信号处理程序，则<code>pclose</code>中的<code>waitpid</code>调用将返回一个错误EINTR。因为允许调用者捕捉此信号，所以当<code>waitpid</code>被一个捕捉到的信号中断时，我们只是再次调用<code>waitpid</code>。</p>
<p>注意，如果应用程序调用<code>waitpid</code>，并且获得了<code>popen</code>创建的子进程的退出状态，那么我们会在应用程序调用<code>pclose</code>时调用<code>waitpid</code>，如果发现子进程已不再存在，将返回-1，将errno设置为ECHILD。</p>
<p>注意，<code>popen</code>决不应由设置用户ID或设置组ID程序调用。当它执行命令时，<code>popen</code>等同于：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span> command, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p>
<p>它在从调用者继承的环境中执行shell，并由shell解释执行command。一个恶意用户可以操控这种环境，使得shell能以设置ID文件模式所授予的提升了的权限以及非预期的方式执行命令。</p>
<p><code>popen</code>特别适用于执行简单的过滤器程序，它变换运行命令的输入成输出。当命令希望构造它自己的管道时，就是这种情形。</p>
<h2 id="协同进程"><a href="#协同进程" class="headerlink" title="协同进程"></a>协同进程</h2><p>UNIX系统过滤程序从标准输入读取数据，向标准输出写数据。几个过滤程序通常在shell管道中线性连接。当一个过滤程序既产生某个过滤程序的输入，又读取该过滤程序的输出时，它就变成了<strong>协同进程</strong>(coprocess)。</p>
<p>协同进程通常在shell的后台运行，其标准输入和标准输出通过管道连接到另一个程序。<code>popen</code>只提供连接到另一个进程的标准输入或标准输出的一个单向管道，而协同进程则有连接到另一个进程的两个单向管道：一个接到其标准输入，另一个则来自其标准输出。我们想将数据写到其标准输入，经其处理后，再从其标准输出读取数据。</p>
<h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>FIFO有时被称为命名管道。未命名的管道只能在两个相关的进程之间使用，而且这两个相关的进程还要有一个共同的创建了它们的祖先进程。但是，通过FIFO，不相关的进程也能交换数据。</p>
<p>通过<code>stat</code>结构的<code>st_mode</code>成员的编码可以知道文件是否是FIFO类型。可以用<code>S_ISFIFO</code>宏对此进行测试。创建FIFO类似于创建文件。确实，FIFO的路径名存在于文件系统中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifoat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>mkfifo</code>函数中<code>mode</code>参数的规格说明与<code>open</code>函数中<code>mode</code>的相同。</p>
<p><code>mkfitoat</code>函数和<code>mkfifo</code>函数相似，但是<code>mkfifoat</code>函数可以被用来在<code>fd</code>文件描述符表示的目录相关的位置创建一个FIFO。像其他at函数一样，这里有3种情形：</p>
<ol>
<li>如果path参数指定的是绝对路径名，则后参数会被忽略掉，并且<code>mkfifoat</code>函数的行为和`mkfifo类似</li>
<li>如果path参数指定的是相对路径名，则细参数是一个打开目录的有效文件描述符，路径名和目录有关</li>
<li>如果path参数指定的是相对路径名，并且<code>fd</code>参数有一个特殊值<code>AT_FDCWD</code>，则路径名以当前目录开始，<code>mkfifoat</code>和<code>mkfifo</code>类似。</li>
</ol>
<p>当我们用<code>mkfifo</code>或者<code>mkfifoat</code>创建FIFO时，要用<code>open</code>来打开它。确实，正常的文件I/O函数(如<code>close</code>、<code>read</code>、<code>write</code>和<code>unlink</code>)都需要FIFO。</p>
<p>当open一个FIFO时，非阻塞标志(<code>O_NONBLOCK</code>)会产生下列影响。在一般情况下(没有指定<code>O_NONBLOCK</code>)，只读<code>open</code>要阻塞到某个其他进程为写而打开这个FIFO为止。类似地，只写open要阻塞到某个其他进程为读而打开它为止。如果指定了<code>O_NONBLOCK</code>，则只读open立即返回。但是，如果没有进程为读而打开一个FIFO，那么只写open将返回-1，并将errno设置成ENXIO。</p>
<p>类似于管道，若<code>write</code>一个尚无进程为读而打开的FIFO，则产生信号<code>SIGPIPE</code>。若某个FIFO的最后一个写进程关闭了该FIFO，则将为该FIPO的读进程产生一个文件结束标志。</p>
<p>一个给定的FIFO有多个写进程是常见的。这就意味着，如果不希望多个进程所写的数据交叉，则必须考虑原子写操作。和管道一样，常量PIPB. BUF说明了可被原子地写到FIFO的最大数据量。</p>
<p>FIFO有以下两种用途。</p>
<ol>
<li>shell命令使用FIFO将数据从一条管道传送到另一条时，无需创建中间临时文件。</li>
<li>客户进程-服务器进程应用程序中，FIFO用作汇聚点，在客户进程和服务器进程二者之间传递数据</li>
</ol>
<p>实例：用FIFO复制输出流<br>FIFO可用于复制一系列shell命令中的输出流。这就防止了将数据写向中间磁盘文件(类似于使用管道来避免中间磁盘文件)。但是不同的是管道只能用于两个进程之间的线性连接，而FIFO是有名字的，因此它可用于非线性连接。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkfifo</span> fifo1</span><br><span class="line">prog3 &lt; fifo1 &amp;</span><br><span class="line">prog1 &lt; infile | <span class="built_in">tee</span> fifo1 | prog2</span><br></pre></td></tr></table></figure></p>
<p>创建FIFO，然后在后台启动prog3，从FIFO读数据。然后启动prog1，用tee将其输出发送到FIFO和prog2。</p>
<p>FIFO的另一个用途是在客户进程和服务器进程之间传送数据。如果有一个服务器进程，它与很多客户进程有关，每个客户进程都可将其请求写到一个该服务器进程创建的众所周知的FIFO中。因为该FIFO有多个写进程，所以客户进程发送给服务器进程的请求的长度要小于<code>PIPE_BUF</code>字节。这样就能避免客户进程的多次写之间的交叉。</p>
<p>每个客户进程都在其请求中包含它的进程ID。然后服务器进程为每个客户进程创建一个FIFO，所使用的路径名是以客户进程的进程ID为基础的。虽然这种安排可以工作，但服务器进程不能判断一个客户进程是否崩溃终止，这就使得客户进程专用FIFO会遗留在文件系统中。另外，服务器进程还必须得捕捉SIGPIPE信号，因为客户进程在发送一个请求后有可能没有读取响应就终止了，于是留下一个只有写进程(服务器进程)而无读进程的客户进程专用FIFO。</p>
<p>如果服务器进程以只读方式打开众所周知的FIFO (因为它只需读该FIFO)，则每当客户进程个数从1变成0时，服务器进程就将在FIFO中读到(read)一个文件结束标志为使服务器进程免于处理这种情况，一种常用的技巧是使服务器进程以读-写方式打开该众所周知的FIFO</p>
<h2 id="XSI-IPC"><a href="#XSI-IPC" class="headerlink" title="XSI IPC"></a>XSI IPC</h2><p>有3种称作XSI IPC的IPC：消息队列、信号量以及共享存储器。它们之间有很多相似之处。</p>
<h3 id="标识符和键"><a href="#标识符和键" class="headerlink" title="标识符和键"></a>标识符和键</h3><p>每个内核中的IPC结构(消息队列、信号量或共享存储段)都用一个非负整数的标识符(idemtifier)加以引用。当一个IPC结构被创建，然后又被删除时，与这种结构相关的标识符连续加1，直至达到一个整型数的最大正值，然后又回转到0。</p>
<p>标识符是IPC对象的内部名。为使多个合作进程能够在同一IPC对象上汇聚，需要提供一个外部命名方案。为此，每个IPC对象都与一个键(key)相关联。将这个键作为该对象的外部名。无论何时创建IPC结构(通过调用<code>msgget</code>、<code>semget</code>或<code>shmget</code>创建)，都应指定一个键。这个键的数据类型是基本系统数据类型<code>key_t</code>，通常在头文件<code>&lt;sys/types.h&gt;</code>中被定义为长整型。这个键由内核变换成标识符。</p>
<p>有多种方法使客户进程和服务器进程在同一IPC结构上汇聚</p>
<ol>
<li>服务器进程可以指定键<code>IPC_PRIVATE</code>创建一个新IPC结构，将返回的标识符存放在某处(如一个文件)以便客户进程取用。键<code>IPC_PRIVATE</code>保证服务器进程创建一个新IPC结构。缺点是需要读写文件。<code>IPC_PRIVATE</code>键也可用于父进程子关系。父进程指定<code>IPC_PRIVATE</code>创建一个新IPC结构，所返回的标识符可供fork后的子进程使用。接着，子进程又可将此标识符作为<code>exec</code>函数的一个参数传给一个新程序。</li>
<li>可以在一个公用头文件中定义一个客户进程和服务器进程都认可的键。然后服务器进程指定此键创建一个新的IPC结构。这种方法的问题是该键可能已与一个IPC结构相结合，在此情况下，<code>get</code>函数(<code>msgget</code>、<code>semget</code>或<code>shmget</code>)出错返回。服务器进程必须处理这一错误，删除已存在的IPC结构，然后试着再创建它。</li>
<li>客户进程和服务器进程认同一个路径名和项目ID，接着，调用函数<code>ftok</code>将这两个值变换为一个键。然后在方法(2)中使用此键。<code>ftok</code>提供的唯一服务就是由一个路径名和项目ID产生一个键。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> id)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回键，若出错，返回(key_t)-1</span></span><br></pre></td></tr></table></figure>
<p><code>path</code>参数必须引用一个现有的文件。当产生键时，只使用过参数的低8位。<code>ftok</code>创建的键通常是用下列方式构成的：按给定的路径名取得其<code>stat</code>结构中的部分<code>st_dev</code>和<code>st_ino</code>字段， 然后再将它们与项目ID组合起来。如果两个路径名引用的是两个不同的文件，那么<code>ftok</code>通常会为这两个路径名返回不同的键。但是，因为i节点编号和键通常都存放在长整型中，所以创建健时可能会丢失信息。这意味着，对于不同文件的两个路径名。如果使用同一项目ID，那么可能产生相同的键。</p>
<p>3个get函数(<code>msgget</code>、<code>semget</code>和<code>shmget</code>)都有两个类似的参数：一个<code>key</code>和一个整型<code>flag</code>。在创建新的IPC结构(通常由服务器进程创建)时，如果<code>key</code>是<code>IPC_PRIVATE</code>或者和当前某种类型的IPC结构无关，则需要指明<code>flag</code>的<code>IPC_CREAT</code>标志位。为了引用一个现有队列(通常由客户进程创建)，<code>key</code>必须等于队列创建时指明的<code>key</code>的值，并且<code>IPC_CREAT</code>必须不被指明。注意，决不能指定<code>IPC_PRIVATE</code>作为键来引用一个现有队列，因为这个特殊的健值总是用于创建一个新队列。为了引用一个用<code>IPC_PRIVATE</code>键创建的现有队列，一定要知道这个相关的标识符，然后在其他IPC调用中(如<code>msgsnd</code>、<code>msgrev</code>)使用该标识符，这样可以绕过<code>get</code>函数。</p>
<p>如果希望创建一个新的IPC结构，而且要确保没有引用具有同一标识符的一个现有IPC结构，那么必须在<code>flag</code>中同时指定<code>IPC_CREAT</code>和<code>IPC_EXCL</code>位。这样做了以后，如果IPC结构已经存在就会造成出错，返回EEXIST(这与指定了<code>O_CREAT</code>和<code>O_EXCL</code>标志的<code>open</code>相类似)。</p>
<h3 id="权限结构"><a href="#权限结构" class="headerlink" title="权限结构"></a>权限结构</h3><p>XSI IPC为每一个IPC结构关联了一个<code>ipc_perm</code>结构。该结构规定了权限和所有者，它至少包括下列成员：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">	<span class="type">uid_t</span> uid; <span class="comment">/* owner&#x27;s effective user id */</span></span><br><span class="line">	<span class="type">gid_t</span> gid; <span class="comment">/* owner&#x27;s effective group id */</span></span><br><span class="line">	<span class="type">uid_t</span> cuid; <span class="comment">/* creator&#x27;s effective user id */</span></span><br><span class="line">	<span class="type">gid_t</span> cgid; <span class="comment">/* creator&#x27;s effective group id */</span></span><br><span class="line">	<span class="type">mode_t</span> mode; <span class="comment">/* access modes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>mode</code>字段对于任何IPC结构都不存在执行权限。另外，消息队列和共享存储使用术语“读”和“写”，而信号量则用术语“读”和“更改”(alter)。</p>
<h3 id="结构限制"><a href="#结构限制" class="headerlink" title="结构限制"></a>结构限制</h3><p>所有3种形式的XSIIPC都有内置限制。大多数限制可以通过重新配置内核来改变。在对这3种形式的IPC中的每一种进行描述时，我们都会指出它的限制。</p>
<h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><p>XSI IPC的一个基本问题是：IPC结构是在系统范围内起作用的，没有引用计数。例如，如果进程创建了一个消息队列，并且在该队列中放入了几则消息，然后终止，那么该消息队列及其内容不会被删除。它们会一直留在系统中直至发生下列动作为止：由某个进程调用<code>msgrcv</code>或<code>msgctl</code>读消息或删除消息队列：成某个进程执行<code>ipcrm(1)</code>命令删除消息队列：或正在自举的系统删除消息队列。将此与管道相比，当最后一个引用管道的进程终止时，管道就被完全地删除了。对于FIFO面言，在最后一个引用FIFO的进程终止时，虽然FIFO的名字仍保留在系统中，直至被显式地删除，但是留在PIPO中的数据已被删除了。</p>
<p>XSI IPC的另一个问题是：这些IPC结构在文件系统中没有名字。不能用<code>ls</code>命令查看IPC对象，不能用<code>rm</code>命令删除它们，也不能用<code>chmod</code>命令修改它们的访问权限。于是，又增加了两个新命令<code>ipcs(1)</code>和<code>ipcrm(1)</code>。</p>
<p>表中对这些不同形式IPC的某些特征进行了比较。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>IPC类型</th>
<th>无连接?</th>
<th>可靠的?</th>
<th>流控制?</th>
<th>记录?</th>
<th>消息类型或优先级?</th>
</tr>
</thead>
<tbody>
<tr>
<td>消息队列</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>STREAMS</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>UNIX域流套接字</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>UNIX域数据报套接字</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>FIFO(非STREAMS)</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
</tbody>
</table>
</div>
<p>“无连接”指的是无需先调用某种形式的打开函数就能发送消息的能力。如前所述，因为需要有某种技术来获得队列标识符，所以我们并不认为消息队列是无连接的。因为所有这些形式的IPC被限制在一台主机上，所以它们都是可靠的。当消息通过网络传送时，就要考虑丢失消息的可能性。“流控制”的意思是如果系统资源(缓冲区)短缺，或者如果接收进程不能再接收更多消息，则发送进程就要休眠。当流控制条件消失时，发送进程应自动唤醒。</p>
<p>图中没有显示的一个特征是：IPC设施能否自动地为每个客户进程创建一个到服务器进程的唯一连接。</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是消息的链接表，存储在内核中，由消息队列标识符标识。在本节中，我们把消息队列简称为队列，其标识符简称为队列ID。</p>
<p><code>msgget</code>用于创建一个新队列或打开一个现有队列。<code>msgsnd</code>将新消息添加到队列尾缩。每个消息包含一个正的长整型类型的字段、一个非负的长度以及实际数据字节数(对应于长度)，所有这些都在将消息添加到队列时，传送给<code>msgsnd</code>、<code>msgrev</code>用于从队列中取消息。我们并不一定要以先进先出次序取消息。也可以按消息的类型字段取消息。</p>
<p>每个队列都有一个<code>msqid_ds</code>结构与其相关联：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span>  <span class="title">msg_perm</span>;</span>  </span><br><span class="line">	<span class="type">msgqnum_t</span>        msg_qnum;    <span class="comment">/* # of nessages on queue */</span></span><br><span class="line">	<span class="type">msglen_t</span>         msg_qbytes;  <span class="comment">/* max # of bytes on queue */</span></span><br><span class="line">	<span class="type">pid_t</span>            msg_lspid;   <span class="comment">/* pid of last msgsnd() */</span></span><br><span class="line">	<span class="type">pid_t</span>            msg_lrpid;   <span class="comment">/* pid of last magrev() */</span></span><br><span class="line">	<span class="type">time_t</span>           msg_stime;   <span class="comment">/* last-msgsnd() time */</span></span><br><span class="line">	<span class="type">time_t</span>           msg_rtime;   <span class="comment">/* last-msgrev() time */</span></span><br><span class="line">	<span class="type">time_t</span>           msg_ctime;   <span class="comment">/* last-change time */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用的第一个函数通常是<code>msgget</code>，其功能是打开一个现有队列或创建一个新队列。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> flag)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回消息队列ID，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>在创建新队列时，要初始化<code>msqid-ds</code>结构的下列成员。</p>
<ul>
<li><code>ipc-perm</code>结构中的<code>mode</code>成员按<code>flag</code>中的相应权限位设置。</li>
<li><code>msg_qnum</code>、<code>msg_lspid</code>、<code>msg_lrpid</code>、<code>msg_stime</code>和<code>msg_rtime</code>都设置为0。</li>
<li><code>msg_ctime</code>设置为当前时间。</li>
<li><code>msg_qbytes</code>设置为系统限制值。</li>
</ul>
<p>若执行成功，<code>msgget</code>返回非负队列ID。此后，该值就可被用于其他3个消息队列函数。<code>msgctl</code>函数对队列执行多种操作。它和另外两个与信号量及共享存储有关的函数(<code>semctl</code>和<code>shmctl</code>)都是XSI IPC的类似于<code>ioctl</code>的函数(亦即垃圾桶函数)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">magctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>cmd</code>参数指定对<code>msqid</code>指定的队列要执行的命令。</p>
<ul>
<li><code>IPC_STAT</code>取此队列的<code>msqid_ds</code>结构，并将它存放在buf指向的结构中。</li>
<li><code>IPC_SET</code>将字段<code>msg_perm.uid</code>、<code>msg_perm.gid</code>、<code>msg_perm.mode</code>和<code>msg_qbytes</code>从<code>buf</code>指向的结构复制到与这个队列相关的<code>msqid_ds</code>结构中。此命令只能由下列两种进程执行：<ul>
<li>一种是其有效用户ID等于<code>msg_perm.cuid</code>或<code>msg_perm.uid</code>，</li>
<li>另一种是具有超级用户特权的进程。只有超级用户才能增加<code>msg_qbytes</code>的值。</li>
</ul>
</li>
<li><code>IPC_RMID</code>从系统中删除该消息队列以及仍在该队列中的所有数据。这种删除立即生效。仍在使用这一消息队列的其他进程在它们下一次试图对此队列进行操作时，将得到EIDRM错误。此命令只能由下列两种进程执行：<ul>
<li>一种是其有效用户ID等于<code>msg_perm.cuid</code>或<code>msg_perm.uid</code>；</li>
<li>另一种是具有超级用户特权的进程。</li>
</ul>
</li>
</ul>
<p>调用<code>msgsnd</code>将数据放到消息队列中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes, <span class="type">int</span> flag)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>正如前面提及的，每个消息都由3部分组成：</p>
<ul>
<li>一个正的长整型类型的字段；</li>
<li>一个非负的长度(nbytes)</li>
<li>实际数据字节数(对应于长度)。</li>
</ul>
<p>消息总是放在队列尾端。<code>ptr</code>参数指向一个长整型数，它包含了正的整型消息类型，其后紧接着的是消息数据(若<code>mbytes</code>是0，则无消息数据)。若发送的最长消息是512字节的，则可定义下列结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mymesg</span> &#123;</span></span><br><span class="line">	<span class="type">long</span> mtype;      <span class="comment">/* positive nessage type */</span></span><br><span class="line">	<span class="type">char</span> mtext[<span class="number">512</span>]; <span class="comment">/* nessage data, of length mbytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>ptr</code>就是一个指向<code>mymesg</code>结构的指针。接收者可以使用消息类型以非先进先出的次序取消息。</p>
<blockquote>
<p>某些平台既支持32位环境，又支持64位环境。这影响到长整型和指针的大小。64位应用程序的<code>mtype</code>字段的一部分可能会被32位应用程序视为<code>mtext</code>字段的组成部分，而32位应用程序的<code>mtext</code>字段的前4个字节会被64位应用程序解释为<code>mtype</code>字段的组成部分。</p>
</blockquote>
<p>参数<code>flag</code>的值可以指定为<code>IPC_NOWAIT</code>。这类似于文件I/O的非阻塞I/O标志。若消息队列已满(或者是队列中的消息总数等于系统限制值，或队列中的字节总数等于系统限制值)，则指定<code>IPC_NOWAIT</code>使得<code>msgsnd</code>立即出错返回EAGAIN。如果没有指定<code>IPC_NOWAIT</code>，则进程会一直阻塞到；有空间可以容纳要发送的消息；或者从系统中删除了此队列，或者捕捉到一个信号，并从信号处理程序返回。</p>
<p>注意，对删除消息队列的处理不是很完善。因为每个消息队列没有维护引用计数器，所以在队列被删除以后，仍在使用这一队列的进程在下次对队列进行操作时会出错返回。信号量机构也以同样方式处理其删除。相反，删除一个文件时，要等到使用该文件的最后一个进程关闭了它的文件描述符以后，才能删除文件中的内容。</p>
<p>当<code>msgsnd</code>返回成功时，消息队列相关的<code>msqid_ds</code>结构会随之更新，表明调用的进程ID(<code>msg_lspid</code>)、调用的时间(<code>msg_stime</code>)以及队列中新增的消息(<code>msg_qnum</code>)。</p>
<p><code>msgrcv</code>从队列中取用消息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="type">saize_t</span> <span class="title function_">msgrev</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes, <span class="type">long</span> type, <span class="type">int</span> flag)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回消息数据部分的长度，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>和<code>msgsnd</code>一样，<code>ptr</code>参数指向一个长整型数(其中存储的是返回的消息类型)，其后跟随的是存储实际消息数据的缓冲区。<code>nbyes</code>指定数据缓冲区的长度。若返回的清息长度大于<code>nbytes</code>，而且在<code>flag</code>中设置了<code>MSG_NOERROR</code>位，则该消息会被截断。如果没有设置这一标志，而消息又太长，则出错返回E2BIG。</p>
<p>参数<code>type</code>可以指定想要哪一种消息。</p>
<ul>
<li><code>type == 0</code>返回队列中的第一个消息，</li>
<li><code>type &gt; 0</code>返回队列中消息类型为<code>type</code>的第一个消息。</li>
<li><code>type &lt; 0</code>返回队列中消息类型值小于等于<code>type</code>绝对值的消息，如果这种消息有若干个，则取类型值最小的消息。</li>
</ul>
<p><code>type</code>值非0用于以非先进先出次序读消息。例如，若应用程序对消息赋予优先权，那么<code>type</code>就可以是优先权值。如果一个消息队列由多个客户进程和一个服务器进程使用，那么<code>type</code>字段可以用来包含客户进程的进程ID(只要进程ID可以存放在长整型中)。</p>
<p>可以将<code>flag</code>值指定为<code>IPC_NOWAIT</code>，使操作不阻塞，这样，如果没有所指定类型的消息可用，则<code>msgrcv</code>返回-1，error设置为ENOMSG。如果没有指定<code>IPC_NOWAIT</code>，则进程会一直阻塞到有了指定类型的消息可用，或者从系统中删除了此队列(返回-1，error设置为EIDRN)，或者捕捉到一个信号并从信号处理程序返回。</p>
<p><code>msgrev</code>成功执行时，内核会更新与该消息队列相关联的<code>msqid_ds</code>结构，以指示调用者的进程ID(<code>msg_lrpid</code>)和调用时间(<code>msg_rtime</code>), 并指示队列中的消息数减少了1个(<code>msg_qnum</code>)。</p>
<p>如若需要客户进程和服务器进程之间的双向数据流，可以使用消息队列或全双工管道。消息队列原来的实施目的是提供高于一般速度的IPC，但现在与其他形式的IPC相比，在速度方面已经没有什么差别了。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量是一个计数器，用于为多个进程提供对共享数据对象的访问。</p>
<p>为了获得共享资源，进程需要执行下列操作。</p>
<ol>
<li>测试控制该资源的信号量。</li>
<li>若此信号量的值为正，则进程可以使用该资源。在这种情况下，进程会将信号量值减1，表示它使用了一个资源单位</li>
<li>否则，若此信号量的值为0。则进程进入休眼状态，直至信号量值大于0。进程被唤醒后，它返回至步骤(1)</li>
</ol>
<p>当进程不再使用由一个信号量控制的共享资源时，该信号量值增1。如果有进程正在休眠等待此信号量，则唤醒它们。为了正确地实现信号量，信号量值的测试及减1操作应当是原子操作。为此，信号最通常是在内核中实现的。</p>
<p>常用的信号量形式被称为二元信号量(binary semuphore)。它控制单个资源，其初始值为1。但是，一般而言，信号量的初值可以是任意一个正值，该值表明有多少个共享资源单位可供共享应用。遭憾的是，XSI信号量与此相比要复杂得多。以下3种特性造成了这种不必要的复杂性。</p>
<ol>
<li>信号量并非是单个非负值，而必需定义为含有一个或多个信号量值的集合。当创建信号量时，要指定集合中信号量值的数量</li>
<li>信号量的创建(semget)是独立于它的初始化(semct1)的。这是一个致命的缺点，因为不能原子地创建一个信号量集合，并且对该集合中的各个信号量值赋初值。</li>
<li>即使没有进程正在使用各种形式的XSIPC。它们仍然是存在的。有的程序在终止时并没有释放已经分配给它的信号量，所以我们不得不为这种程序担心。后面将要说明的undo功能就是处理这种情况的。</li>
</ol>
<p>内核为每个信号量集合维护着一个<code>semid_ds</code>结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> sem_nsems; <span class="comment">/* # of semaphores in set */</span></span><br><span class="line">	<span class="type">time_t</span> sem_otimes <span class="comment">/* last-semop() time */</span></span><br><span class="line">	<span class="type">time_t</span> sem_ctime; <span class="comment">/* last-change time */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>每个信号量由一个无名结构表示，它至少包含下列成员：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> semval;    <span class="comment">/* semaphore value, always &gt;= 0 */</span></span><br><span class="line">	<span class="type">pid_t</span> sempid;             <span class="comment">/* pid for last operation */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> semncnt;   <span class="comment">/* # processes awaiting senval&gt;curval */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> senzcnts   <span class="comment">/* # processes awaiting senval==0 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当我们想使用XSI信号量时，首先需要通过调用函数<code>semget</code>来获得一个信号量ID。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">semget</span> <span class="params">(<span class="type">key_t</span> kay, <span class="type">int</span> nsems, <span class="type">int</span> flag)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回信号量ID，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>创建一个新集合时，要对<code>semid_ds</code>结构的下列成员赋初值。</p>
<ul>
<li>初始化<code>ipc_perm</code>结构。该结构中的<code>mode</code>成员被设置为<code>flag</code>中的相应权限位。</li>
<li><code>sem_otime</code>设置为0。</li>
<li><code>sem_ctime</code>设置为当前时间。</li>
<li><code>sem_nsems</code>设置为<code>nsems</code>。</li>
</ul>
<p><code>nsems</code>是该集合中的信号量数。如果是创建新集合，则必须指定<code>nsems</code>。如果是引用现有集合(一个客户进程)，则将<code>nsems</code>指定为0。</p>
<p><code>semctl</code>函数包含了多种信号量操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> semnum, <span class="type">int</span> cmd, ... <span class="comment">/* union semun arg */</span>)</span>;</span><br></pre></td></tr></table></figure><br>第4个参数是可选的，是否使用取决于所请求的命令，如果使用该参数，则其类型是<code>semun</code>，它是多个命令特定参数的联合(union):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> val;              <span class="comment">/* for SETVAL */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span> <span class="comment">/* for IPC_STAT and IPC_SET */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> *<span class="built_in">array</span>;<span class="comment">/* for GETALL and SETALL */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这个选项参数是一个联合，而非指向联合的指针。</p>
<p><code>cmd</code>参数指定下列10种命令中的一种，这些命令是运行在<code>semid</code>指定的信号量集合上的。其中有5种命令是针对一个特定的信号量值的，它们用<code>semnum</code>指定该信号量集合中的一个成员。<code>semnum</code>值在0和nsems-1之间，包括0和nsems-1。</p>
<ul>
<li><code>IPC_STAT</code>对此集合取<code>semid_ds</code>结构，并存储在由<code>arg.buf</code>指向的结构中。</li>
<li><code>IPC_SET</code>按<code>arg.buf</code>指向的结构中的值，设置与此集合相关的结构中的<code>sem_perm.uid</code>、<code>sem_perm.gid</code>和<code>sem_perm.mode</code>字段。此命令只能由两种进程执行：<ul>
<li>一种是其有效用户ID等于<code>sem_perm.cuid</code>或<code>sem_perm.uid</code>的进程，</li>
<li>另一种是具有超级用户特权的进程</li>
</ul>
</li>
<li><code>IPC_RMID</code>从系统中删除该信号量集合。这种删除是立即发生的。删除时仍在使用此信号量集合的其他进程，在它们下次试图对此信号量集合进行操作时，将出错返回EIDRM。此命令只能由两种进程执行：<ul>
<li>一种是其有效用户ID等于<code>sem_perm.cuid</code>或<code>sem_perm.uid</code>的进程；</li>
<li>另一种是具有超级用户特权的进程。</li>
</ul>
</li>
<li><code>GETVAL</code>：返回成员<code>semnum</code>的<code>semval</code>值。</li>
<li><code>SETVAL</code>：设置成员<code>semnum</code>的<code>semval</code>值。该值由<code>arg.val</code>指定。</li>
<li><code>GETPID</code>：返回成员<code>semnum</code>的<code>sempid</code>值。</li>
<li><code>GETNCNT</code>：返回成员<code>semnum</code>的<code>semncnt</code>值。</li>
<li><code>GETZCNT</code>：返回成员<code>semnum</code>的<code>semzcnt</code>值。</li>
<li><code>GETALL</code>：取该集合中所有的信号量值。这些值存储在<code>arg.array</code>指向的数组中。</li>
<li><code>SETALL</code>：将该集合中所有的信号量值设置成<code>arg.array</code>指向的数组中的值。</li>
</ul>
<p>对于除<code>GETALL</code>以外的所有<code>GET</code>命令，<code>semctl</code>函数都返回相应值。对于其他命令，若成功则返回值为0，若出错，则设置errno井返回-1。</p>
<p>函数<code>semop</code>自动执行信号量集合上的操作数组。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf semoparray[], <span class="type">size_t</span> nops)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>参数<code>semoparray</code>是一个指针，它指向一个由<code>sembuf</code>结构表示的信号量操作数组：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>  sem_num;  <span class="comment">/* menber # in set (0, 1, ..., nsems-1 */</span></span><br><span class="line">	<span class="type">short</span> sem_op;  <span class="comment">/* operation(negative, 0, or positive */</span>)</span><br><span class="line">	<span class="type">short</span> sem_flg; <span class="comment">/* IPC_NOWAIT, SEM_UNDO */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>参数<code>nops</code>规定该数组中操作的数量(元素数)。对集合中每个成员的操作由相应的<code>sem_op</code>值规定。此值可以是负值、0或正值。</p>
<ol>
<li>最易于处理的情况是<code>sem_op</code>为正值。这对应于进程释放的占用的资源数。<code>sem_op</code>值会加到信号量的值上。如果指定了<code>undo</code>标志，则也从该进程的此信号量调整值中减去<code>sem_op</code>。</li>
<li>若<code>sem_op</code>为负值，则表示要获取由该信号量控制的资源。</li>
</ol>
<p>如若该信号量的值大于等于<code>sem_op</code>的绝对值(具有所需的资源)，则从信号量值中减去<code>sem_op</code>的绝对值。这能保证信号量的结果值大于等于0。如果指定了<code>undo</code>标志，则<code>sem_op</code>的绝对值也加到该进程的此信号量调整值上。</p>
<p>如果信号量值小于<code>sem_op</code>的绝对值(资源不能满足要求)，则适用下列条件。</p>
<ol>
<li>若指定了<code>IPC_NOWAIT</code>，则<code>semop</code>出错返回EAGAIN。</li>
<li>若未指定<code>IPC_NOWAIT</code>，则该信号量的<code>semncnt</code>值加1(因为调用进程将进入休眠状态)，然后调用进程被挂起直至下列事件之一发生：<ol>
<li>此信号量值变成大于等于<code>sem_op</code>的绝对值(即某个进程已释放了某些资源)。此信号量的<code>semncnt</code>值减1(因为已结束等待)，并且从信号量值中减去<code>sem_op</code>的绝对值。如果指定了<code>undo</code>标志，则<code>sem_op</code>的绝对值也加到该进程的此信号量调整值上。</li>
<li>从系统中删除了此信号量。在这种情况下，函数出错返回EIDRM。</li>
<li>进程捕捉到一个信号，并从信号处理程序返同，在这种情况下，此信号量的<code>semncnt</code>值减1(因为调用进程不再等待)，并且函数出错返回EINTR。</li>
</ol>
</li>
<li>若<code>sem_op</code>为0，这表示调用进程希望等待到该信号量值变成0。<ol>
<li>如果信号量值当前是0，则此函数立即返回，</li>
<li>如果信号量值非0，则适用下列条件。<ol>
<li>若指定了<code>IPC_NOWAIT</code>，则出错返回EAGAIN。</li>
<li>若未指定<code>IPC_NOWAIT</code>，则该信号量的<code>semzcnt</code>值加1(因为调用进程将进入休眠状态)，然后调用进程被挂起，直至下列的一个事件发生。<ol>
<li>此信号量值变成0。此信号量的semzcnt值减1 (因为调用进程已结束等待)。</li>
<li>从系统中删除了此信号量。在这种情况下，函数出错返回BIDRM.</li>
<li>进程捕提到一个信号，并从信号处理程序返回，在这种情况下，此信号量的<code>semzcnt</code>值减1(因为调用进程不再等待)，并且函数出错返回BINTR。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><code>semop</code>函数具有原子性，它或者执行数组中的所有操作，或者一个也不做。</p>
<h3 id="exit时的信号量调整"><a href="#exit时的信号量调整" class="headerlink" title="exit时的信号量调整"></a>exit时的信号量调整</h3><p>如果在进程终止时，它占用了经由信号量分配的资源，那么就会成为一个问题。无论何时只要为信号量操作指定了<code>SEM_UNDO</code>标志，然后分配资源(sem_op值小于0)，那么内核就会记住对于该特定信号量，分配给调用进程多少资源(<code>sem_op</code>的绝对值)。当该进程终止时，不论自愿或者不自愿，内核都将检验该进程是否还有尚来处理的信号最调整值，如果有，则按调整值对相应信号量值进行处理。</p>
<p>如果用带<code>SETVAL</code>或<code>SETALL</code>命令的<code>semctl</code>设置一个信号量的值，则在所有进程中，该信号量的调整值都将设置为0。</p>
<p>若使用信号量，则先创建一个包含一个成员的信号量集合，然后将该信号量值初始化为1。为了分配资源，以<code>sem_op</code>为-1调用<code>semop</code>。为了释放资源，以<code>sem_op</code>为-1调用<code>semop</code>。对每个操作都指定<code>SEM_UNDO</code>，以处理在未释放资源条件下进程终止的情况。</p>
<p>若使用记录锁，则先创建一个空文件，并且用该文件的第一个字节(无需存在)作为锁字节。为了分配资源，先对该字节获得一个写锁。释放该资源时，则对该字节解锁。记录锁的性质确保了当一个锁的持有者进程终止时，内核会自动释放该锁。</p>
<p>若使用互斥量，需要所有的进程将相同的文件映射到它们的地址空间里，并且使用<code>PTHREAD_PROCESS_SHARED</code>互斥量属性在文件的相同偏移处初始化互斥量。为了分配资源，我们对互斥量加锁。为了释放锁，我们解锁互斥量。如果一个进程没有释放互斥量而终止，恢复将是非常困难的，除<br>非我们使用鲁棒互斥量。</p>
<h2 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h2><p>共享存储允许两个或多个进程共享一个给定的存储区。因为数据不需要在客户进程和服务器进程之间复制，所以这是最快的一种IPC。使用共享存储时要掌握的唯一窍门是，在多个进程之间同步访问一个给定的存储区。若服务器进程正在将数据放入共享存储区，则在它做完这一操作之前，客户进程不应当去取这些数据。通常，信号量用于同步共享存储访问。</p>
<p>我们已经看到了共享存储的一种形式，就是在多个进程将同一个文件映射到它们的地址空间的时候。XSI共享存储和内存映射的文件的不同之处在于，前者没有相关的文件。XSI共享存储段是内存的匿名段。</p>
<p>内核为每个共享存储段维护着一个结构，该结构至少要为每个共享存储段包含以下成员：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span></span><br><span class="line">	<span class="type">size_t</span> shm_segsz;   <span class="comment">/* size of segment in bytes */</span></span><br><span class="line">	<span class="type">pid_t</span> shm_lpid; <span class="comment">/* pid of last shoop() */</span></span><br><span class="line">	<span class="type">pid_t</span> shm_cpid; <span class="comment">/* pid of creator */</span></span><br><span class="line">	<span class="type">shmatt_t</span> shm_nattch; <span class="comment">/* number of current attaches */</span></span><br><span class="line">	<span class="type">time_t</span> shm_atime; <span class="comment">/* last-attach time */</span></span><br><span class="line">	<span class="type">time_t</span> shm_dtime; <span class="comment">/* last-detach time */</span></span><br><span class="line">	<span class="type">time_t</span> shm_ctime; <span class="comment">/* last-change time */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>shmatt_t</code>类型定义为无符号整型。</p>
<p>调用的第一个函数通常是<code>shmget</code>，它获得一个共享存储标识符：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> flag)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回共享存储ID，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>当创建一个新段时，初始化<code>shmid_ds</code>结构的下列成员。</p>
<ul>
<li><code>ipc_perm</code>结构中的<code>mode</code>按<code>flag</code>中的相应权限位设置</li>
<li><code>shm_lpid</code>、<code>shm_nattach</code>、<code>shm_atime</code>和<code>shm_dtime</code>都设置为0</li>
<li><code>shm_ctime</code>设置为当前时间</li>
<li><code>shm_segsz</code>设置为请求的size</li>
</ul>
<p>参数<code>size</code>是该共享存储段的长度，以字节为单位。实现通常将其向上取为系统页长的整倍数。但是，若应用指定的<code>size</code>值并非系统页长的整倍数，那么最后一页的余下部分是不可使用的。如果正在创建一个新段(通常在服务器进程中)，则必须指定其<code>size</code>。如果正在引用一个现存的段(一个客户进程)，则将<code>size</code>指定为0。当创建一个新段时，段内的内容初始化为0。</p>
<p><code>shmctl</code>函数对共享存储段执行多种操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>cmd</code>参数指定下列5种命令中的一种，使其在<code>shmid</code>指定的段上执行。</p>
<ul>
<li><code>IPC_STAT</code>取此段的<code>shmid_ds</code>结构，并将它存储在由<code>buf</code>指向的结构中。</li>
<li><code>IPC_SET</code>按<code>buf</code>指向的结构中的值设置与此共享存储段相关的<code>shmid_ds</code>结构中的下列3个字段：<code>shm_perm.uid</code>、<code>shm_perm.gid</code>和<code>shm_perm.mode</code>。此命令只能由下列两种进程执行，<ul>
<li>一种是其有效用户ID等于<code>shm_perm.cuid</code>或<code>shm_perm.uid</code>的进程；</li>
<li>另一种是具有超级用户特权的进程。</li>
</ul>
</li>
<li><code>IPC_RMID</code>从系统中剥除该共享存储段。因为每个共享存储段维护着一个连接计数(<code>shmid_ds</code>结构中的<code>shm_nattch</code>字段)，所以除非使用该段的最后一个进程终止或与该段分离，否则不会实际上删除该存储段。不管此段是否仍在使用，该段标识符都会被立即删除，所以不能再用<code>shmat</code>与该段连接。此命令只能由下列两种进程执行，<ul>
<li>一种是其有效用户ID等于<code>shm_perm.cuid</code>或<code>shm_perm.uid</code>的进程；</li>
<li>另一种是具有超级用户特权的进程。</li>
</ul>
</li>
</ul>
<p>Linux提供了另外两种命令。</p>
<ul>
<li><code>SHM_LOCK</code>在内存中对共享存储段加锁。此命令，只能由超级用户执行。</li>
<li><code>SHM_UNLOCK</code>解锁共享存储段。此命令只能由超级用户执行。</li>
</ul>
<p>一旦创建了一个共享存储段，进程就可调用<code>shmat</code>将其连接到它的地址空间中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *addr, <span class="type">int</span> flag)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回指向共享存储段的指针，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>共享存储段连接到调用进程的哪个地址上与<code>addr</code>参数以及<code>flag</code>中是否指定<code>SRM_RND</code>位有关。</p>
<ul>
<li>如果<code>addr</code>为0，则此段连接到由内核选择的第一个可用地址上。这是推荐的使用方式。</li>
<li>如果<code>addr</code>非0，并且没有指定<code>SHM_RND</code>，则此段连接到<code>addr</code>所指定的地址上。</li>
<li>如果<code>addr</code>非0，并且指定了<code>SHM_RND</code>，则此段连接到(<code>addr - (addr mod SHMLBA)</code>)所表示的地址上。<code>SHM_RND</code>命令的意思是“取整”。<code>SHMLBA</code>的意思是“低边界地址倍数”，它总是2的乘方。该算式是将地址向下取最近1个<code>SHMLBA</code>的倍数。</li>
</ul>
<p>当对共享存储段的操作已经结束时，则调用<code>shmdt</code>与该段分离。注意，这并不从系统中删除其标识符以及其相关的数据结构。该标识符仍然存在，直至某个进程(一般是服务器进程)带<code>IPC_RMID</code>命令的调用<code>shmctl</code>特地删除它为止。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>addr</code>参数是以前调用<code>shmat</code>时的返回值。如果成功，<code>shmdt</code>将使相关<code>shmid_ds</code>结构中的<code>shm_nattch</code>计数器值减1。</p>
<p>内核将以地址0连接的共享存储段放在什么位置上与系统密切相关。程序打印一些特定系统存放各种类型的数据的位置信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ARRAY_SIZE	40000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MALLOC_SIZE	100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SHM_SIZE	100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SHM_MODE	0600	<span class="comment">/* user read/write */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>	<span class="built_in">array</span>[ARRAY_SIZE];	<span class="comment">/* uninitialized data = bss */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		shmid;</span><br><span class="line">	<span class="type">char</span>	*ptr, *shmptr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;array[] from %p to %p\n&quot;</span>, (<span class="type">void</span> *)&amp;<span class="built_in">array</span>[<span class="number">0</span>],</span><br><span class="line">	  (<span class="type">void</span> *)&amp;<span class="built_in">array</span>[ARRAY_SIZE]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;stack around %p\n&quot;</span>, (<span class="type">void</span> *)&amp;shmid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((ptr = <span class="built_in">malloc</span>(MALLOC_SIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;malloc error&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloced from %p to %p\n&quot;</span>, (<span class="type">void</span> *)ptr,</span><br><span class="line">	  (<span class="type">void</span> *)ptr+MALLOC_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((shmid = shmget(IPC_PRIVATE, SHM_SIZE, SHM_MODE)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;shmget error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((shmptr = shmat(shmid, <span class="number">0</span>, <span class="number">0</span>)) == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;shmat error&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;shared memory attached from %p to %p\n&quot;</span>, (<span class="type">void</span> *)shmptr,</span><br><span class="line">	  (<span class="type">void</span> *)shmptr+SHM_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;shmctl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在一个基于Intel的64位Linux系统上运行此程序，其输出如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">array[] from 0x6020c0 to Ox60bd00</span><br><span class="line">stack around Ox7ffr957b146c</span><br><span class="line">malloced fron 0x9e3010 to 0x9fb6b0</span><br><span class="line">shared nemory attached from 0x7fba578ab000 to 0x7fba578c36a0</span><br></pre></td></tr></table></figure></p>
<p>图显示了这种情况，注意，共享存储段紧靠在栈之下。<br><img src="/img/1622869817.jpg" alt=""></p>
<p>回忆一下mmap函数，它可将一个文件的若干部分映射至进程地址空间。这在概念上类似于用<code>shmat</code>连接一个共享存储段。两者之间的主要区别是，用<code>mmap</code>映射的存储段是与文件相关联的，而XSI共享存储段则并无这种关联。</p>
<p>在读设备<code>/dev/zero</code>时，该设备是0字节的无限资源。它也接收写向它的任何数据，但又忽略这些数据。我们对此设备作为IPC的兴趣在于，当对其进行存储映射时，它具有一些特殊性质。</p>
<ul>
<li>创建一个未命名的存储区，其长度是<code>mmap</code>的第二个参数，将其向上取整为系统的最近页长。</li>
<li>存储区都初始化为0。</li>
<li>如果多个进程的共同祖先进程对<code>mmap</code>指定了<code>MAP_SHARED</code>标志，则这些进程可共享此存储区。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	NLOOPS		1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SIZE		sizeof(long)	<span class="comment">/* size of shared memory area */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">update</span><span class="params">(<span class="type">long</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>((*ptr)++);	<span class="comment">/* return value before increment */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		fd, i, counter;</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line">	<span class="type">void</span>	*area;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fd = open(<span class="string">&quot;/dev/zero&quot;</span>, O_RDWR)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((area = mmap(<span class="number">0</span>, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED,</span><br><span class="line">	  fd, <span class="number">0</span>)) == MAP_FAILED)</span><br><span class="line">		err_sys(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">	close(fd);		<span class="comment">/* can close /dev/zero now that it&#x27;s mapped */</span></span><br><span class="line"></span><br><span class="line">	TELL_WAIT();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;			<span class="comment">/* parent */</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NLOOPS; i += <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((counter = update((<span class="type">long</span> *)area)) != i)</span><br><span class="line">				err_quit(<span class="string">&quot;parent: expected %d, got %d&quot;</span>, i, counter);</span><br><span class="line"></span><br><span class="line">			TELL_CHILD(pid);</span><br><span class="line">			WAIT_CHILD();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;						<span class="comment">/* child */</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NLOOPS + <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">			WAIT_PARENT();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ((counter = update((<span class="type">long</span> *)area)) != i)</span><br><span class="line">				err_quit(<span class="string">&quot;child: expected %d, got %d&quot;</span>, i, counter);</span><br><span class="line"></span><br><span class="line">			TELL_PARENT(getppid());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="POSIX信号量"><a href="#POSIX信号量" class="headerlink" title="POSIX信号量"></a>POSIX信号量</h2><p>POSIX信号量接口意在解决XSI信号量接口的儿个缺陷，</p>
<ul>
<li>相比于XSI接口。POSIX信号量接口考虑到了更高性能的实现</li>
<li>POSIX信号量接口使用更简单，没有信号量集，在熟悉的文件系统操作后一些接口被模式化了。尽管没有要求一定要在文件系统中实现，但是一些系统的确是这么实现的。</li>
<li>POSIX信号量在删除时表现更完美。使用POSIX信号量时，操作能继续正常工作直到该信号量的最后一次引用被释放。</li>
</ul>
<p>POSIX信号量有两种形式；命名的和未命名的。它们的差异在于创建和销毁的形式上，但其他工作一样。未命名信号量只存在于内存中，并要求能使用信号量的进程必须可以访问内存。这意味着它们只能应用在同一进程中的线程，或者不同进程中已经映射相同内存内容到它们的地址空间中的线程。相反，命名信号量可以通过名字访问，因此可以被任何已知它们名字的进程中的线程使用。</p>
<p>我们可以调用<code>sem_open</code>函数来创建一个新的命名信号量或者使用一个现有信号量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">sem_t</span> *<span class="title function_">sem_open</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, ...<span class="comment">/* mode_t mode, unsigned int value */</span> )</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回指向信号量的指针，若出错，返回SEM_FAILED</span></span><br></pre></td></tr></table></figure></p>
<p>当使用一个现有的命名信号量时，我们仅仅指定两个参数：信号量的名字和<code>oflag</code>参数的0值。当这个<code>oflag</code>参数有<code>O_CREAT</code>标志集时，如果命名信号量不存在，则创建一个新的。如果它已经存在，则会被使用，但是不会有额外的初始化发生。</p>
<p>当我们指定<code>O_CREAT</code>标志时，需要提供两个额外的参数。<code>mode</code>参数指定谁可以访问信号量。<code>mode</code>的取值和打开文件的权限位相同：用户读、用户写、用户执行、组读、组写、组执行、其他读、其他写和其他执行。赋值给信号量的权限可以被调用者的文件创建屏蔽字修改。注意，只有读和写访问要紧，但是当我们打开一个现有信号量时接口不允许指定模式。</p>
<p>在创建信号量时，<code>value</code>参数用来指定信号量的初始值。它的取值是0~<code>SEM_VALUE_MAX</code>。如果我们想确保创建的是信号量，可以设置<code>oflag</code>参数为<code>O_CREATIO_EXCL</code>。如果信号量已经存在，会导致<code>sem_open</code>失败。</p>
<p>为了增加可移植性，在选择信号量命名时必须遵循一定的规则。</p>
<ul>
<li>名字的第一个字符应该为斜杠(<code>/</code>)。</li>
<li>名字不应包含其他斜杠以此避免实现定义的行为。例如，如果文件系统被使用了，那么名字<code>/mysem</code>和<code>//mysem</code>会被认定为是同一个文件名，但是如果实现没有使用文件系统，那么这两种命名可以被认为是不同的</li>
<li>信号量名字的最大长度是实现定义的。名字不应该长于<code>_POSIX_NAME_MAX</code>个字符长度。因为这是使用文件系统的实现能允许的最大名字长度的限制。</li>
</ul>
<p>如果想在信号量上进行操作，<code>sem_open</code>函数会为我们返回一个信号量指针，用于传递到其他信号量函数上。当完成信号最操作时，可以调用<code>sem_close</code>函数来释放任何信号量相关的资源。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_close</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>如果进程没有首先调用<code>sem_close</code>而退出，那么内核将自动关闭任何打开的信号量。注意，这不会影响信号量值的状态，如果已经对它进行了增1操作，这并不会仅因为退出而改变。类似地。如果调用<code>sem_close</code>，信号量值也不会受到影响。在XSI信号量中没有类似<code>SEM_UNDO</code>标志的机制。可以使用<code>sem_unlink</code>函数来销毁一个命名信号量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>sem_unlink函数删除信号量的名字。如果没有打开的信号量引用，则该信号量会被销毁。否则，销毁将延迟到最后一个打开的引用关闭。</p>
<p>不像XSI信号量，我们只能通过一个函数调用来调节POSIX信号量的值。计数减1和对一个二进制信号量加锁或者获取计数信号量的相关资源是相类似的。</p>
<p>注意，信号量和POSIX信号量之间是没有差别的。是采用二进制信号量还是用计数信号量取决于如何初始化和使用信号量。如果一个信号量只是有值0或者1，那么它就是二进制信号量。当二进制信号量是1时，它就是“解锁的”，如果它的值是0，那就是“加锁的”。</p>
<p>可以使用<code>sem_wait</code>或者<code>sem_trywait</code>函数来实现信号量的减1操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span> <span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span> <span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；若出错则返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>sem_wait</code>函数时，如果信号量计数是0就会发生阻塞。直到成功使信号量减1或者被信号中断时才返回。可以使用<code>sem_trywait</code>函数来避免阻塞。调用<code>sem_trywait</code>时，如果信号量是0，则不会阻塞，而是会返回-1并且将errno置为EAGAIN。</p>
<p>第三个选择是阻塞一段确定的时间。为此，可以使用<code>sem_timewait</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sen_timedwait</span> <span class="params">(<span class="type">sem_t</span> *<span class="keyword">restrict</span> sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>想要放弃等待信号量的时候，可以用<code>tsptr</code>参数指定绝对时间。超时是基于<code>CLOCK_REALTIME</code>时钟的。如果信号量可以立即减1，那么超时值就不重要了，尽管指定的可能是过去的某个时间，信号量的减1操作依然会成功。如果超时到期并且信号量计数没能减1，<code>sem_timedwait</code>将返回-1且将errno设置为ETIMEDOUT。</p>
<p>可以调用<code>sem_post</code>函数使信号量值增1。这和解锁一个二进制信号量或者释放一个计数信号量相关的资源的过程是类似的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span> <span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>调用<code>sem_post</code>时，如果在调用<code>sem_wait</code>(或者<code>sem_timedwait</code>)中发生进程阻塞，那么进程会被唤醒并且被<code>sem_post</code>增1的信号量计数会再次被<code>sem_wait</code>(或者<code>sem_timedwait</code>)减1。</p>
<p>当我们想在单个进程中使用POSIX信号量时，使用未命名信号量更容易。这仅仅改变创建和销毁信号量的方式。可以调用<code>sem_init</code>函数来创建一个未命名的信号量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;senaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span> <span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>pshared</code>参数表明是否在多个进程中使用信号量。如果是，将其设置成一个非0值。<code>value</code>参数指定了信号量的初始值。</p>
<p>需要声明一个<code>sem_t</code>类型的变量并把它的地址传递给<code>sem_init</code>来实现初始化，而不是像<code>sem_open</code>函数那样返回一个指向信号量的指针。如果要在两个进程之间使用信号量，需要确保<code>sem</code>参数指向两个进程之间共享的内存范围。</p>
<p>对未命名信号量的使用已经完成时，可以调用<code>sem_destroy</code>函数丢弃它。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>调用<code>sem_destroy</code>后，不能再使用任何带有<code>sem</code>的信号量函数，除非通过调用<code>sem_init</code>重新初始化它。</p>
<p><code>sem_getvalue</code>函数可以用来检索信号量值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span> <span class="params">(<span class="type">sem_t</span> *<span class="keyword">restrict</span> sem, <span class="type">int</span> *<span class="keyword">restrict</span> valp)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>成功后，<code>valp</code>指向的整数值将包含信号量值，试图要使用刚读出来的值时，信号量的值可能已经变了。除非使用额外的同步机制来避免这种竞争，否则<code>sem_getvalue</code>函数只能用于调试。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;slock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> slock *</span><br><span class="line"><span class="title function_">s_alloc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slock</span> *<span class="title">sp</span>;</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((sp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> slock))) == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="built_in">snprintf</span>(sp-&gt;name, <span class="keyword">sizeof</span>(sp-&gt;name), <span class="string">&quot;/%ld.%d&quot;</span>, (<span class="type">long</span>)getpid(),</span><br><span class="line">		  cnt++);</span><br><span class="line">		sp-&gt;semp = sem_open(sp-&gt;name, O_CREAT|O_EXCL, S_IRWXU, <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span> ((sp-&gt;semp == SEM_FAILED) &amp;&amp; (errno == EEXIST));</span><br><span class="line">	<span class="keyword">if</span> (sp-&gt;semp == SEM_FAILED) &#123;</span><br><span class="line">		<span class="built_in">free</span>(sp);</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	sem_unlink(sp-&gt;name);</span><br><span class="line">	<span class="keyword">return</span>(sp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">s_free</span><span class="params">(<span class="keyword">struct</span> slock *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">	sem_close(sp-&gt;semp);</span><br><span class="line">	<span class="built_in">free</span>(sp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">s_lock</span><span class="params">(<span class="keyword">struct</span> slock *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(sem_wait(sp-&gt;semp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">s_trylock</span><span class="params">(<span class="keyword">struct</span> slock *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(sem_trywait(sp-&gt;semp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">s_unlock</span><span class="params">(<span class="keyword">struct</span> slock *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(sem_post(sp-&gt;semp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="网络IPC：套接字"><a href="#网络IPC：套接字" class="headerlink" title="网络IPC：套接字"></a>网络IPC：套接字</h1><h2 id="引言-4"><a href="#引言-4" class="headerlink" title="引言"></a>引言</h2><p>将描述套接字网络进程间通信接口，进程用该接口能够和其他进程通信，无论它们是在同一台计算机上还是在不同的计算机上。实际上，这正是套接字接口的设计目标之一：同样的接口既可以用于计算机间通信，也可以用于计算机内通信。</p>
<h2 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h2><p>套接字是通信端点的抽象。正如使用文件描述符访问文件，应用程序用套接字描述符访问套接字。套接字描述符在UNIX系统中被当作是一种文件描述符。事实上，许多处理文件描述符的函数(如read和write)可以用于处理套接字描述符。为创建一个套接字，调用<code>socket</code>函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span> <span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回文件(套接字)描述符。若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>参数<code>domain</code>(域)确定通信的特性，包括地址格式。图中总结了由POSIX.1指定的各个域。各个域都有自己表示地址的格式，而表示各个域的常数都以<code>AF_</code>开头，意指地址族(address family)。</p>
<p>大多数系统还定义了<code>AF_LOCAL</code>域，这是<code>AF_UNIX</code>的别名。<code>AF_UNSPEC</code>域可以代表“任何”域。</p>
<p>|域|描述|<br>|AF_INET|IPv4因特网域|<br>|AF_INET6|IPv6因特网域|<br>|AF_UNIX|UNIX域|<br>|AF_UPSPEC|未指定|</p>
<p>参数<code>type</code>确定套接字的类型，进一步确定通信特征。图中总结了由POSIX.1定义的套接字类型，但在实现中可以自由增加其他类型的支持</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SOCK_DGRAM</td>
<td>固定长度的、无连接的、不可靠的报文传递</td>
</tr>
<tr>
<td>SOCK_RAW</td>
<td>IP协议的数据报接口</td>
</tr>
<tr>
<td>SOCK_SEQPACKET</td>
<td>固定长度的、有序的、可靠的、面向连接的报文传递</td>
</tr>
<tr>
<td>SOCK_STREAM</td>
<td>有序的、可靠的、双向的、面向连接的字节流</td>
</tr>
</tbody>
</table>
</div>
<p>参数<code>protocol</code>通常是0，表示为给定的域和套接字类型选择默认协议。当对同一域和套接字类型支持多个协议时，可以使用<code>protocol</code>选择一个特定协议。在<code>AF_INET</code>通信域中，套接字类型<code>SOCK_STREAM</code>的默认协议是传输控制协议(Transmission Control Protocol, TCP)。在<code>AF_INET</code>通信域中，套接字类型<code>SOCK_DGRAM</code>的默认协议是UDP。图列出了为因特网域套接字定义的协议。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>协议</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>IPPROTO_IP</td>
<td>IPv4网际协议</td>
</tr>
<tr>
<td>IPPROTO_IPV6</td>
<td>IPv6网际协议</td>
</tr>
<tr>
<td>IPPROTO_ICMP</td>
<td>因特网控制报文协议(Internet Cantrol Message Protacel)</td>
</tr>
<tr>
<td>IPPROTO_RAW</td>
<td>原始护数据包协议</td>
</tr>
<tr>
<td>IPPROTO_TCP</td>
<td>传输控制协议</td>
</tr>
<tr>
<td>IPPROTO_UDP</td>
<td>用户数据报协议(User Datagram Protocol)</td>
</tr>
</tbody>
</table>
</div>
<p>对于数据报(<code>SOCK_DGRAM</code>)接口，两个对等进程之间通信时不需要逻辑连接。只需要向对等进程所使用的套接字送出一个报文。</p>
<p>因此数据报提供了一个无连接的服务。另一方面，字节流(<code>SOCK_STREAM</code>)要求在交换数据之前，在本地套接字和通信的对等进程的套接字之间建立一个逻辑连接。数据报是自包含报文。发送数据报近似于给某人邮寄信件。你能邮寄很多信，但你不能保证传递的次序，并且可能有些信件会丢失在路上。每封信件包含接收者地址， 使这封信件独立于所有其他信件。每封信件可能送达不同的接收者。</p>
<p>相反，使用面向连接的协议通信就像与对方打电话。首先，需要通过电话建立一个连接，连接建立好之后，彼此能双向地通信。每个连接是端到端的通信链路。对话中不包含地址信息，就像呼叫两端存在一个点对点虚拟连接，并且连接本身暗示特定的源和目的地。</p>
<p><code>SOCK_STREAM</code>套接字提供字节流服务，所以应用程序分辨不出报文的界限。这意味着从<code>SOCK_STREAM</code>套接字读数据时，它也许不会返回所有由发送进程所写的字节数。最终可以获得发送过来的所有数据，但也许要通过若干次函数调用才能得到。</p>
<p><code>SOCK_SEQPACKET</code>套接字和<code>SOCK_STREAM</code>套接字很类似，只是从该套接字得到的是基于报文的服务而不是字节流服务。这意味着从<code>SOCK_SEQPACKET</code>套接字接收的数据量与对方所发送的一致。流控制传输协议(Stream Control Transmission Protocol, SCTP)提供了因特网域上的顺序数据包服务。</p>
<p><code>SOCK_RAM</code>套接字提供一个数据报接口，用于直接访问下面的网络层(即因特网域中的IP层)。使用这个接口时，应用程序负责构造自己的协议头部，这是因为传输协议(如TCP和UDP)被绕过了。当创建一个原始套接字时，需要有超级用户特权，这样可以防止恶意应用程序绕过内建安全机制来创建报文。</p>
<p>调用<code>socket</code>与调用<code>open</code>相类似。在两种情况下，均可获得用于I/O的文件描述符。当不再需要该文件描述符时，调用<code>close</code>来关闭对文件或套接字的访问，并且释放该描述符以便重新使用。虽然套接字描述符本质上是一个文件描述符，但不是所有参数为文件描述符的函数都可以接受套接字描述符。</p>
<p><img src="/img/1622943429.jpg" alt=""><br>未指定和由实现定义的行为通常意味着该函数对套接字描述符无效。例如，<code>lseek</code>不能以套接字横述符为参数，因为套接字不支持文件偏移量的概念。</p>
<p>套接字通信是双向的。可以采用<code>shutdown</code>函数来禁止一个套接字的I/O。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span> <span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>如果<code>how</code>是<code>SHUT_RD</code>(关闭读端)，那么无法从套接字读取数据。如果<code>how</code>是<code>SHUT_WR</code>(关闭写端)，那么无法使用套接字发送数据。如果<code>how</code>是<code>SHUT_RDWR</code>，则既无法读取数据，又无法发送数据。</p>
<p>为何使用shutdown呢?首先，只有最后一个活动引用关闭时，<code>close</code>才释放网络端点。这意味着如果复制一个套接字(如采用<code>dup</code>)，要直到关闭了最后一个引用它的文件描述符才会释放这个套接字。而<code>shutdown</code>允许使一个套接字处于不活动状态，和引用它的文件描述符数目无关。其次，有时可以很方便地关闭套接字双向传输中的一个方向。例如，如果想让所通信的进程能够确定数据传输何时结束，可以关闭该套接<br>字的写端，然而通过该套接字读端仍可以继续接收数据。</p>
<h2 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h2><h3 id="宇节序"><a href="#宇节序" class="headerlink" title="宇节序"></a>宇节序</h3><p>字节序是一个处理器架构特性，用于指示像整数这样的大数据类型内部的字节如何排序。网络协议指定了字节序，因此异构计算机系统能够交换协议信息而不会被字节序所混淆。TCP/IP协议栈使用大端字节序。应用程序交换格式化数据时，字节序问题就会出现。</p>
<p>对于TCP/IP应用程序，有4个用来在处理器字节序和网络字节序之间实施转换的函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span> <span class="params">(<span class="type">uint32_t</span> hostint32)</span>;</span><br><span class="line"><span class="comment">// 返回值；以网络字节序表示的32位整数</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostintl6)</span>;</span><br><span class="line"><span class="comment">// 返回值：以网络字节序表示的16位整数</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span> <span class="params">(<span class="type">uint32_t</span> netint32)</span>;</span><br><span class="line"><span class="comment">// 返回值；以主机字节序表示的32位整数</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netint16)</span>;</span><br><span class="line"><span class="comment">// 返回值。以主机字节序表示的16位整数</span></span><br></pre></td></tr></table></figure></p>
<p><code>h</code>表示“主机”字节序，<code>n</code>表示“网络”字节序。<code>l</code>表示“长”(即4字节)整数，<code>s</code>表示“短”(即4字节)整数。虽然在使用这些函数时包含的是<code>&lt;arpa/inet.h&gt;</code>头文件，但系统实现经常是在其他头文件中声明这些函数的，只是这些头文件都包含在<code>&lt;arpa/inet.h&gt;</code>中。对于系统来说，把这些函数实现为宏也是很常见的。</p>
<h3 id="地址格式"><a href="#地址格式" class="headerlink" title="地址格式"></a>地址格式</h3><p>一个地址标识一个特定通信域的套接字端点，地址格式与这个特定的通信域相关。为使不同格式地址能够传入到套接字函数，地址会被强制转换成一个通用的地址结构<code>sockaddr</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;  <span class="comment">/*address family */</span></span><br><span class="line">    <span class="type">char</span> sa_data[];   <span class="comment">/*variabie-length address */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>套接字实现可以自由地添加额外的成员并且定义<code>sa_data</code>成员的大小。</p>
<p>因特网地址定义在<code>&lt;netinet/in.h&gt;</code>头文件中。在IPv4因特网域(<code>AF_INET</code>)中，套接字地址用结构<code>sockaddr_in</code>表示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_adds</span> &#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">    <span class="comment">/* IPv4 address */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family; <span class="comment">/* address family */</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;     <span class="comment">/* port number */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">/* IPv4 address */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>数据类型<code>in_port_t</code>定义成<code>uint16_t</code>。数据类型<code>in_addr_t</code>定义成<code>uint32_t</code>。这些整数类型在<code>&lt;stdint.h&gt;</code>中定义并指定了相应的位数。</p>
<p>与<code>AF_INET</code>域相比较，IPv6因特网域(<code>AF_INET6</code>)套接字地址用结构<code>sockaddr_in6</code>表示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct_in6_addr &#123;</span><br><span class="line">    <span class="type">uint8_t</span> s6_addr[<span class="number">16</span>]; <span class="comment">/* IPv6 address */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin6_family;  <span class="comment">/* address family */</span></span><br><span class="line">    <span class="type">in_port_t</span> sin6_port;      <span class="comment">/* port number */</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_flowinfo;   <span class="comment">/* trattic class and flow info */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span><span class="comment">/* IPv6 addreas*/</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_scope_id;   <span class="comment">/* set of interfaces for scope */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在Linux中，<code>sockaddr_in</code>定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;   <span class="comment">/* address family */</span></span><br><span class="line">    <span class="type">in_port_t</span>   sin_port;     <span class="comment">/* port number */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_add</span>;</span> <span class="comment">/* IPV4 address */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>];<span class="comment">/* filler */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中成员<code>sin_zero</code>为填充字段，应该全部被置为0。</p>
<p>注意，尽管<code>sockaddr_in</code>与<code>sockaddr_in6</code>结构相差比较大，但它们均被强制转换成<code>sockaddr</code>结构输入到套接字例程中。将会看到UNIX域套接字地址的结构与上述两个因特网域套接字地址格式的不同。</p>
<p>有时，需要打印出能被人理解而不是计算机所理解的地址格式。有两个新函数<code>inet_ntop</code>和<code>inet_pton</code>具有相似的功能，而且同时支持IPv4地址和IPv6地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> domain, <span class="type">const</span> <span class="type">void</span> *<span class="keyword">restrict</span> addit, <span class="type">char</span> *<span class="keyword">restrict</span> str, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回地址字符串指针：若出错，返回NULL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> domain, conat <span class="type">char</span> * <span class="keyword">restrict</span> str, <span class="type">void</span> *<span class="keyword">restrict</span> addr)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回1；若格式无效，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>函数<code>inet_ntop</code>将网络字节序的二进制地址转换成文本字符串格式。<code>inet_pton</code>将文本字符串格式转换成网络字节序的二进制地址。参数<code>domain</code>仅支持两个值：<code>AF_INET</code>和<code>AF_INET6</code>。</p>
<p>对于<code>inet_ntop</code>，参数<code>size</code>指定了保存文本字符串的缓冲区(str)的大小。 两个常数用于简化工作：<code>INET_ADDRSTRLEN</code>定义了足够大的空间来存放一个表示IPv4地址的文本字符串；<code>INET6_ADDRSTRLEN</code>定义了足够大的空间来存放一个表示IPv6地址的文本字符串。对于<code>inet_pton</code>，如果<code>domain</code>是<code>AF_INET</code>，则缓冲区<code>addr</code>需要足够大的空间来存放一个32位地址；如果<code>domain</code>是<code>AF_INET6</code>，则需要足够大的空间来存放一个128位地址。</p>
<h3 id="地址查询"><a href="#地址查询" class="headerlink" title="地址查询"></a>地址查询</h3><p>理想情况下，应用程序不需要了解一个套接字地址的内部结构。如果一个程序简单地传递一个类似于<code>sockaddr</code>结构的套接字地址，并且不依赖于任何协议相关的特性，那么可以与提供相同类型服务的许多不同协议协作。</p>
<p>网络配置信息被存放在许多地方。这个信息可以存放在静态文件(如<code>/etc/hosts</code>和<code>/etc/services</code>)中，也可以由名字服务管理，如域名系统(Domain Name System，DNS)或者网络信息服务(Network Information Service，NIS)。无论这个信息放在何处，都可以用同样的函数访问它。</p>
<p>通过调用<code>gethostent</code>，可以找到给定计算机系统的主机信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostent</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回指针，若出错，返回NULL</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sethostent</span><span class="params">(<span class="type">int</span> stayopen)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">endhostent</span> <span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果主机数据库文件没有打开，<code>gethostent</code>会打开它。函数<code>gethostent</code>返回文件中的下一个条目。函数<code>sethostent</code>会打开文件，如果文件已经被打开，那么将其回绕。当<code>stayopen</code>参数设置成非0值时，调用<code>gethostent</code>之后，文件将依然是打开的。函数<code>endhostent</code>可以关闭文件。</p>
<p>当<code>gethostent</code>返回时，会得到一个指向<code>hostent</code>结构的指针，该结构可能包含一个静态的数据缓冲区，每次调用<code>gethostent</code>，缓冲区都会被覆盖。<code>hostent</code>结构至少包含以下成员：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *h_name;      <span class="comment">/* name of host */</span></span><br><span class="line">    <span class="type">char</span> **h_aliases;  <span class="comment">/* pointer to alternate host name array +/</span></span><br><span class="line"><span class="comment">    int h_addrtype;    /*address type */</span></span><br><span class="line">    <span class="type">int</span> h_length;      <span class="comment">/* length in bytes of address */</span></span><br><span class="line">    <span class="type">char</span> **h_addr_list;<span class="comment">/* pointer to array of network addresses */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>返回的地址采用网络字节序。</p>
<p>另外两个函数<code>gethostbyname</code>和<code>gethostbyaddr</code>，原来包含在<code>hostent</code>函数中，现在则被认为是过时的。</p>
<p>能够采用一套相似的接口来获得网络名字和网络编号，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> netent *<span class="title function_">getnetbyaddr</span> <span class="params">(<span class="type">uint32_t</span> net, <span class="type">int</span> type)</span>;</span><br><span class="line"><span class="keyword">struct</span> netent *<span class="title function_">getnetbyname</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="keyword">struct</span> netent *<span class="title function_">getnetent</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 3个函数的返回值，若成功，返回指针；若出错，返回NULL</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setnetent</span> <span class="params">(<span class="type">int</span> stayopen)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">endnetent</span> <span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>netent</code>结构至少包含以下字段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netent</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>   *n_name;   <span class="comment">/*network nane */</span></span><br><span class="line">    <span class="type">char</span> **n_aliases; <span class="comment">/* alternate network name array pointer */</span></span><br><span class="line">    <span class="type">int</span> n_addrtype;   <span class="comment">/*address type */</span></span><br><span class="line">    <span class="type">uint32_t</span> n_net,   <span class="comment">/*network nunber */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>网络编号按照网络字节序返回。地址类型是地址族常量之一(如<code>AF_INET</code>)。我们可以用以下函数在协议名字和协议编号之间进行映射。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdib.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> protoent *<span class="title function_">getprotobyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="keyword">struct</span> protoent *<span class="title function_">getprotobynumber</span> <span class="params">(<span class="type">int</span> proto)</span>;</span><br><span class="line"><span class="keyword">struct</span> protoent *<span class="title function_">getprotoent</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 3个函数的返回值：若成功，返回指针，若出错，返回NULL</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setprotoent</span> <span class="params">(<span class="type">int</span> stayopen)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">endprotoent</span> <span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>POSIX.1定义的<code>protoent</code>结构至少包含以下成员：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">protoent</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *p_name;       <span class="comment">/* protocol name */</span></span><br><span class="line">    <span class="type">char</span> **p_aliases;   <span class="comment">/* pointer to alternane protocol name array */</span></span><br><span class="line">    <span class="type">int</span> p_proto;        <span class="comment">/* protocol number */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>服务是由地址的端口号部分表示的。每个服务由一个唯一的众所周知的端口号来支持。可以使用函数<code>getservbyname</code>将一个服务名映射到一个端口号，使用函数<code>getservbyport</code>将一个端口号映射到一个服务名，使用函数<code>getservent</code>顺序扫描服务数据库。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> servent *<span class="title function_">getservbyname</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *proto)</span>;</span><br><span class="line"><span class="keyword">struct</span> servent *<span class="title function_">getserbyport</span> <span class="params">(<span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> *proto)</span>;</span><br><span class="line"><span class="keyword">struct</span> servent *<span class="title function_">getservent</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 3个函数的返回值，若成功，返回指针，若出错，返图NULL</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setservent</span> <span class="params">(<span class="type">int</span> stayopen)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">endservent</span> <span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>servent</code>结构至少包含以下成员：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *s_name;      <span class="comment">/* service name */</span></span><br><span class="line">    <span class="type">char</span> **s_aliases;  <span class="comment">/* pointer to alternate service name array */</span></span><br><span class="line">    <span class="type">int</span> s_port;        <span class="comment">/* port nunber */</span></span><br><span class="line">    <span class="type">char</span> *s_proto;     <span class="comment">/* nane of protocol */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>POSIX.1定义了若干新的函数，允许一个应用程序将一个主机名和一个服务名映射到一个地址，或者反之。这些函数代替了较老的函数<code>gethostbyname</code>和<code>gethostbyaddr</code>。</p>
<p><code>getaddrinfo</code>函数允许将一个主机名和一个服务名映射到一个地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> host, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> service, </span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> addrinfo *<span class="keyword">restrict</span> hint, <span class="keyword">struct</span> addrinfo **<span class="keyword">restrict</span> res)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回非0错误码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo *ai)</span>;</span><br></pre></td></tr></table></figure></p>
<p>需要提供主机名、服务名，或者两者都提供。如果仅仅提供一个名字，另外一个必须是一个空指针。主机名可以是一个节点名或点分格式的主机地址。<code>getaddrinfo</code>函数返回一个链表结构<code>addrinfo</code>。可以用<code>freeaddrinfo</code>来释放一个或多个这种结构，这取决于用<code>ai_next</code>字段链接起来的结构有多少。</p>
<p><code>addrinfo</code>结构的定义至少包含以下成员：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinto</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>              ai_flags;    <span class="comment">/* custonize behavior */</span></span><br><span class="line">    <span class="type">int</span>              ai_family;   <span class="comment">/* address fanily */</span></span><br><span class="line">    <span class="type">int</span>              ai_socktype; <span class="comment">/* socket type */</span></span><br><span class="line">    <span class="type">int</span>              ai_protocol; <span class="comment">/* protocol */</span></span><br><span class="line">    <span class="type">socklen_t</span>        ai_addrlen;  <span class="comment">/* length in bytes of address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span>     <span class="comment">/* address */</span></span><br><span class="line">    <span class="type">char</span>            *ai_canonname;<span class="comment">/* canonical name of host */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span>     <span class="comment">/* next in list */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以提供一个可选的<code>hint</code>来选择符合特定条件的地址。<code>hint</code>是一个用于过滤地址的模板，包括<code>ai_family</code>、<code>ai_flags</code>、<code>ai_protocol</code>和<code>ai_socktype</code>字段。剩余的整数字段必须设置为0，指针字段必须为空。图总结了<code>ai_flags</code>字段中的标志，可以用这些标志来自定义如何处理地址和名字。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>AI_ADDRCONFIG</td>
<td>查询配置的地址类型(Pv4或IPv6)</td>
</tr>
<tr>
<td>AI_ALL</td>
<td>查找IPv4和IPv6地址(仅用于AI_V4MAPPED)</td>
</tr>
<tr>
<td>AI_CANONNAME</td>
<td>需要一个规范的名字(与别名相对)</td>
</tr>
<tr>
<td>AI_NUMERICHOST</td>
<td>以数字格式指定主机地址，不翻译</td>
</tr>
<tr>
<td>AL_NUMERICSERV</td>
<td>将服务指定为数字编口号，不翻译</td>
</tr>
<tr>
<td>AI_PASSIVE</td>
<td>套接字地址用于监听绑定</td>
</tr>
<tr>
<td>AI_V4NAPPED</td>
<td>如没有找到IPv6地址，返回映射到IPV6格式的IPv4地址</td>
</tr>
</tbody>
</table>
</div>
<p>如果<code>getaddrinfo</code>失败，不能使用<code>perror</code>或<code>strerror</code>来生成错误消息，而是要调用<code>gai_strerror</code>将返回的错误码转换成错误消息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">gai_strerror</span> <span class="params">(<span class="type">int</span> emor)</span>;</span><br><span class="line"><span class="comment">// 返回值：指向描述错误的字符串的指针</span></span><br></pre></td></tr></table></figure></p>
<p><code>getnameinfo</code>函数将一个地址转换成一个主机名和一个服务名。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getnameinfo</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="type">socklen_t</span> alen,</span></span><br><span class="line"><span class="params">    <span class="type">char</span> *<span class="keyword">restrict</span> host, <span class="type">socklen_t</span> hostlen,</span></span><br><span class="line"><span class="params">    <span class="type">char</span> *reatrict service, <span class="type">socklen_t</span> servlen, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回非0值</span></span><br></pre></td></tr></table></figure></p>
<p>套接字地址(<code>addr</code>)被翻译成一个主机名和一个服务名。如果<code>host</code>非空，则指向一个长度为<code>hostlen</code>字节的缓冲区用于存放返回的主机名。同样，如果<code>service</code>非空，则指向一个长度为<code>servlen</code>字节的缓冲区用于存放返回的主机名。</p>
<p><code>flags</code>参数提供了一些控制翻译的方式。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NI_DGRAM</td>
<td>服务基于数据报而非基于流</td>
</tr>
<tr>
<td>NI_NAMEREQD</td>
<td>如果找不到主机名，将其作为一个错误</td>
</tr>
<tr>
<td>NI_NOFQDN</td>
<td>对于本地主机，仅返回全限定域名的节点名部分</td>
</tr>
<tr>
<td>NI_NUMERICHOST</td>
<td>返回主机地址的数字形式，非主机名</td>
</tr>
<tr>
<td>NI_NUMERICSCOPE</td>
<td>对于IPv6，返回范围ID的数字形式，而非名字</td>
</tr>
<tr>
<td>NI_NUMERICSERV</td>
<td>返回服务地址的数字形式(即端口号)，而非名字</td>
</tr>
</tbody>
</table>
</div>
<p><code>getaddrinfo</code>函数的使用方法。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(SOLARIS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(BSD)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_family</span><span class="params">(<span class="keyword">struct</span> addrinfo *aip)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; family &quot;</span>);</span><br><span class="line">	<span class="keyword">switch</span> (aip-&gt;ai_family) &#123;</span><br><span class="line">	<span class="keyword">case</span> AF_INET:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;inet&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> AF_INET6:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;inet6&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> AF_UNIX:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;unix&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> AF_UNSPEC:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;unspecified&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;unknown&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_type</span><span class="params">(<span class="keyword">struct</span> addrinfo *aip)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; type &quot;</span>);</span><br><span class="line">	<span class="keyword">switch</span> (aip-&gt;ai_socktype) &#123;</span><br><span class="line">	<span class="keyword">case</span> SOCK_STREAM:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;stream&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SOCK_DGRAM:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;datagram&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SOCK_SEQPACKET:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;seqpacket&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SOCK_RAW:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;raw&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;unknown (%d)&quot;</span>, aip-&gt;ai_socktype);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_protocol</span><span class="params">(<span class="keyword">struct</span> addrinfo *aip)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; protocol &quot;</span>);</span><br><span class="line">	<span class="keyword">switch</span> (aip-&gt;ai_protocol) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IPPROTO_TCP:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;TCP&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IPPROTO_UDP:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;UDP&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IPPROTO_RAW:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;raw&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;unknown (%d)&quot;</span>, aip-&gt;ai_protocol);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_flags</span><span class="params">(<span class="keyword">struct</span> addrinfo *aip)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;flags&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (aip-&gt;ai_flags == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; 0&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (aip-&gt;ai_flags &amp; AI_PASSIVE)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; passive&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (aip-&gt;ai_flags &amp; AI_CANONNAME)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; canon&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (aip-&gt;ai_flags &amp; AI_NUMERICHOST)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; numhost&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (aip-&gt;ai_flags &amp; AI_NUMERICSERV)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; numserv&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (aip-&gt;ai_flags &amp; AI_V4MAPPED)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; v4mapped&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (aip-&gt;ai_flags &amp; AI_ALL)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; all&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>		*<span class="title">ailist</span>, *<span class="title">aip</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>		<span class="title">hint</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>	*<span class="title">sinp</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> 			*addr;</span><br><span class="line">	<span class="type">int</span> 				err;</span><br><span class="line">	<span class="type">char</span> 				abuf[INET_ADDRSTRLEN];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;usage: %s nodename service&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">	hint.ai_flags = AI_CANONNAME;</span><br><span class="line">	hint.ai_family = <span class="number">0</span>;</span><br><span class="line">	hint.ai_socktype = <span class="number">0</span>;</span><br><span class="line">	hint.ai_protocol = <span class="number">0</span>;</span><br><span class="line">	hint.ai_addrlen = <span class="number">0</span>;</span><br><span class="line">	hint.ai_canonname = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_addr = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> ((err = getaddrinfo(argv[<span class="number">1</span>], argv[<span class="number">2</span>], &amp;hint, &amp;ailist)) != <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;getaddrinfo error: %s&quot;</span>, gai_strerror(err));</span><br><span class="line">	<span class="keyword">for</span> (aip = ailist; aip != <span class="literal">NULL</span>; aip = aip-&gt;ai_next) &#123;</span><br><span class="line">		print_flags(aip);</span><br><span class="line">		print_family(aip);</span><br><span class="line">		print_type(aip);</span><br><span class="line">		print_protocol(aip);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\thost %s&quot;</span>, aip-&gt;ai_canonname?aip-&gt;ai_canonname:<span class="string">&quot;-&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (aip-&gt;ai_family == AF_INET) &#123;</span><br><span class="line">			sinp = (<span class="keyword">struct</span> sockaddr_in *)aip-&gt;ai_addr;</span><br><span class="line">			addr = inet_ntop(AF_INET, &amp;sinp-&gt;sin_addr, abuf,</span><br><span class="line">			    INET_ADDRSTRLEN);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; address %s&quot;</span>, addr?addr:<span class="string">&quot;unknown&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; port %d&quot;</span>, ntohs(sinp-&gt;sin_port));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个程序说明了<code>getaddrinfo</code>函数的使用方法。如果有多个协议为指定的主机提供给定的服务，程序会打印出多条信息。如果想将输出限制在<code>AF_INET</code>协议族， 可以在提示中设置<code>ai_family</code>字段。在一个测试系统上运行这个程序时，得到了以下输出：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out harry nfs</span><br><span class="line">flags canon fanily inet <span class="built_in">type</span> stream protocol TCP</span><br><span class="line">hoat harry address 192.168.1.99 port 2049</span><br><span class="line">flags canon fanily inet <span class="built_in">type</span> dataqran protocol UDP</span><br><span class="line">host harry address 192.168.1.99 port 2049</span><br></pre></td></tr></table></figure></p>
<h3 id="将套接字与地址关联"><a href="#将套接字与地址关联" class="headerlink" title="将套接字与地址关联"></a>将套接字与地址关联</h3><p>将一个客户端的套接字关联。上一个地址没有多少新意，可以让系统选一个默认的地址。然而，对于服务器，需要给一个接收客户端请求的服务器套接字关联上一个众所周知的地址。客户端应有一种方法来发现连接服务器所需要的地址，最简单的方法就是服务器保留一个地址并且注册在<code>/etc/services</code>或者某个名字服务中。</p>
<p>使用<code>bind</code>函数来关联地址和套接字。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> len)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>对于使用的地址有以下一些限制。</p>
<ul>
<li>在进程正在运行的计算机上，指定的地址必须有效；不能指定一个其他机器的地址。</li>
<li>地址必须和创建套接字时的地址族所支持的格式相匹配。</li>
<li>地址中的端口号必须不小于1024，除非该进程具有相应的特权(即超级用户)。</li>
<li>一般只能将一个套接字端点绑定到一个给定地址上，尽管有些协议允许多重绑定。</li>
</ul>
<p>对于因特网域，如果指定IP地址为<code>INADDR_ANY</code>(<code>&lt;netinet/in.h&gt;</code>中定义的)，套接字端点可以被绑定到所有的系统网络接口上。这意味着可以接收这个系统所安装的任何一个网卡的数据包。</p>
<p>可以调用<code>getsockname</code>函数来发现绑定到套接字上的地址：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockname</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr,</span></span><br><span class="line"><span class="params">    <span class="type">socklen_t</span> *<span class="keyword">restrict</span> alenp)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>调用<code>getsockname</code>之前，将<code>alenp</code>设置为一个指向整数的指针，该整数指定缓冲区<code>sockaddr</code>的长度。返回时，整数会被设置成返同地址的大小。如果地址和提供的缓冲区长度不匹配，地址会被自动截断而不报错。如果当前没有地址绑定到该套接字，则其结果是未定义的。</p>
<p>如果套接字已经和对等方连接，可以调用<code>getpeername</code>函数来找到对方的地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getpeername</span> <span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr,</span></span><br><span class="line"><span class="params">   <span class="type">socklen_t</span> *<span class="keyword">restrict</span> alenp)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>除了返回对等方的地址，函数<code>getpeername</code>和<code>getsockname</code>一样。</p>
<h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>如果要处理一个面向连接的网络服务(<code>SOCK_STREAM</code>或<code>SOCK_SEQPACKET</code>)，那么在开始交换数据以前，需要在请求服务的进程套接字(客户端)和提供服务的进程套接字(服务器)之间建立一个连接。使用<code>connect</code>函数来建立连接。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span> <span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> len)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>在<code>connect</code>中指定的地址是我们想与之通信的服务器地址。如果<code>sockfd</code>没有绑定到一个地址，<code>connect</code>会给调用者绑定一个默认地址。</p>
<p>如果一个服务器运行在一个负载很重的系统上，就很有可能发生错误。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSLEEP 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">connect_retry</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> alen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> numsec;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Try to connect with exponential backoff.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (numsec = <span class="number">1</span>; numsec &lt;= MAXSLEEP; numsec &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (connect(sockfd, addr, alen) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Connection accepted.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Delay before trying again.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (numsec &lt;= MAXSLEEP/<span class="number">2</span>)</span><br><span class="line">			sleep(numsec);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数展示了指数补偿(exponential backoff) 算法。如果调用<code>connect</code>失败，进程会休眠一小段时间，然后进入下次循环再次尝试，每次循环休眠时间会以指数级增加，直到最大延迟为2分钟左右。</p>
<p>如果<code>connect</code>失败，套接字的状态会变成未定义的。因此，如果<code>connect</code>失败，可迁移的应用程序需要关闭套接字。如果想重试，必须打开一个新的套接字。这种更易于迁移的技术如下所示。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSLEEP 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">connect_retry</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol,</span></span><br><span class="line"><span class="params">              <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> alen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> numsec, fd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Try to connect with exponential backoff.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (numsec = <span class="number">1</span>; numsec &lt;= MAXSLEEP; numsec &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((fd = socket(domain, type, protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> (connect(fd, addr, alen) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Connection accepted.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">return</span>(fd);</span><br><span class="line">		&#125;</span><br><span class="line">		close(fd);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Delay before trying again.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (numsec &lt;= MAXSLEEP/<span class="number">2</span>)</span><br><span class="line">			sleep(numsec);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，因为可能要建立一个新的套接字，给<code>connect_retry</code>函数传递一个套接字描述符参数是没有意义。我们现在返回一个已连接的套接字描述符给调用者，而并非返回一个表示调用成功的值</p>
<p>如果套接字描述符处于非阻塞模式，那么在连接不能马上建立时，<code>connect</code>将会返回-1并且将errno设置为特殊的错误码<code>EINPROGRESS</code>。应用程序可以使用<code>poll</code>或者<code>select</code>来判断文件描述符何时可写。如果可写，连接完成。<code>connect</code>函数还可以用于无违接的网络服务(<code>SOCK_DGRAM</code>)。这看起来有点矛盾，实际上却是一个不错的选择。如果用<code>SOCK_DGRAM</code>套接字调用<code>connect</code>，传送的报文的目标地址会设置成<code>connect</code>调用中所指定的地址，这样每次传送报文时就不需要再提供地址。另外，仅能接收来自指定地址的报文。</p>
<p>服务器调用<code>listen</code>函数来宣告它愿意接受连接请求。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回一</span></span><br></pre></td></tr></table></figure></p>
<p>参数<code>backlog</code>提供了一个提示，提示系统该进程所要入队的未完成连接请求数量。其实际值由系统决定，但上限由<code>&lt;sys/socket.h&gt;</code>中的<code>SOMAXCONN</code>指定。一旦队列满，系统就会拒绝多余的连接请求，所以<code>backlog</code>的值应该基于服务器期望负载和处理量来选择，其中处理量是指接受连接请求与启动服务的数量。一旦服务器调用了<code>listen</code>，所用的套接字就能接收连接请求。使用<code>accept</code>函数获得连接请求并建立连接。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span> <span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr,</span></span><br><span class="line"><span class="params">    <span class="type">socklen_t</span> *<span class="keyword">restrict</span> len)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回文件(套接字)描述符；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>函数<code>accept</code>所返回的文件描述符是套接字描述符，该描述符连接到调用<code>connect</code>的客户端。这个新的套接字描述符和原始套接字(<code>sockfd</code>)具有相同的套接字类型和地址族。传给<code>accept</code>的原始套接字没有关联到这个连接，而是继续保持可用状态并接收其他连接请求。</p>
<p>如果不关心客户端标识，可以将参数<code>addr</code>和<code>len</code>设为NULL。否则，在调用<code>accept</code>之前，将<code>addr</code>参数设为足够大的缓冲区来存放地址，并且将<code>len</code>指向的整数设为这个缓冲区的字节大小。返回时，<code>accept</code>会在缓冲区填充客户端的地址，并且更新指向<code>len</code>的整数来反映该地址的大小。</p>
<p>如果没有连接请求在等待，<code>accept</code>会阻塞直到一个请求到来。如果<code>sockfd</code>处于非阻塞模式，<code>accept</code>会返回-1，并将errno设置为EAGAIN或EWOULDBLOCK。</p>
<p>如果服务器调用<code>accept</code>，并且当前没有连接请求，服务器会阻塞直到一个请求到来。另外，服务器可以使用<code>poll</code>或<code>select</code>来等待一个请求的到来。在这种情况下，一个带有等待连接请求的套接字会以可读的方式出现。</p>
<p>函数可以用来分配和初始化套接字供服务器进程使用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">initserver</span><span class="params">(<span class="type">int</span> type, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> alen,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> qlen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fd = socket(addr-&gt;sa_family, type, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (bind(fd, addr, alen) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	<span class="keyword">if</span> (type == SOCK_STREAM || type == SOCK_SEQPACKET) &#123;</span><br><span class="line">		<span class="keyword">if</span> (listen(fd, qlen) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(fd);</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">	err = errno;</span><br><span class="line">	close(fd);</span><br><span class="line">	errno = err;</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>既然一个套接字端点表示为一个文件描述符，那么只要建立连接，就可以使用<code>read</code>和<code>write</code>来通过套接字通信。通过在<code>connect</code>函数里面设置默认对等地址，数据报套接字也可以被“连接”。在套接字描述符上使用<code>read</code>和<code>write</code>是非常有意义的，因为这意味着可以将套接字描述符传递给那些原先为处理本地文件而设计的函数。而且还可以安排将套接字描述符传递给予进程，而该子进程执行的程序并不了解套接字。</p>
<p>如果想指定选项，从多个客户端接收数据包，或者发送带外数据，就需要使用6个为数据传递而设计的套接字函数中的一个。3个函数用来发送数据，3个用于接收数据。首先，考查用于发送数据的函数。最简单的是<code>send</code>，它和<code>write</code>很像，但是可以指定标志来改变处理传输数据的方式。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回发送的字节数：若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>类似<code>write</code>，使用<code>send</code>时套接字必须已经连接。参数<code>buf</code>和<code>nbytes</code>的含义与<code>write</code>中的一致。</p>
<p>然而，与<code>write</code>不同的是，<code>send</code>支持第4个参数<code>flags</code>。图总结了这些标志。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>MSG_CONFIRM</td>
<td>提供链路层反馈以保持地址映射有效</td>
</tr>
<tr>
<td>MSG_DONTROUTE</td>
<td>勿将数据包路由出本地网络</td>
</tr>
<tr>
<td>MSG_DONTWAIT</td>
<td>允许非阻塞操作</td>
</tr>
<tr>
<td>MSG_EOF</td>
<td>发送数据后关闭套接字的发送端</td>
</tr>
<tr>
<td>MSG_EOR</td>
<td>如果协议支持，标记记录结束</td>
</tr>
<tr>
<td>MSG_MORE</td>
<td>延迟发送数据包允许写更多数据</td>
</tr>
<tr>
<td>MSG_NOSIGNAL</td>
<td>在写无连接的套接字时不产生SIGPIPE信号</td>
</tr>
<tr>
<td>MSG_OOB</td>
<td>如果协议支持，发送带外数据</td>
</tr>
</tbody>
</table>
</div>
<p>即使<code>send</code>成功返回，也并不表示连接的另一端的进程就一定接收了数据。我们所能保证的只是当<code>send</code>成功返回时，数据已经被无错误地发送到网络驱动程序上。对于支持报文边界的协议，如果尝试发送的单个报文的长度超过协议所支持的最大长度，那么<code>send</code>会失败，并将errno设为EMSGSIZE。对于字节流协议，<code>send</code>会阻塞直到整个数据传输完成。函数<code>sendto</code>和<code>send</code>很类似。区别在于<code>sendto</code>可以在无连锁的套接字上指定一个目标地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> sockaddr *destaddr, <span class="type">socklen_t</span> destlen)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回发送的字节数；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>对于面向连接的套接字，目标地址是被忽略的，因为连接中隐含了目标地址。对于无连接的套接字，除非先调用<code>connect</code>设置了目标地址，否则不能使用<code>send</code>。<code>sendto</code>提供了发送报文的另一种方式。</p>
<p>通过套接字发送数据时，还有一个选择。可以调用带有<code>msghdr</code>结构的<code>sendmsg</code>来指定多重缓冲区传输数据，这和<code>writev</code>函数很相似<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> msghdr *mig, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回发送的字节数；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>POSIX.1定义了<code>msghdr</code>结构，它至少有以下成员：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>         *msg_name;      <span class="comment">/* optional address */</span></span><br><span class="line">    <span class="type">socklen_t</span>     msg_namelen;   <span class="comment">/* address oize in bytes */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>       <span class="comment">/* array of I/O butters */</span></span><br><span class="line">    <span class="type">int</span>           msg_iovlen;    <span class="comment">/* number of elements in array */</span></span><br><span class="line">    <span class="type">void</span>         *msg_control;   <span class="comment">/* ancillary data */</span></span><br><span class="line">    <span class="type">socklen_t</span>     msg_eontrollen;<span class="comment">/* number of ancillary bytes */</span></span><br><span class="line">    <span class="type">int</span>           msg_flags;     <span class="comment">/* flags for received nessage */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>函数<code>recv</code>和<code>read</code>相似，但是<code>recv</code>可以指定标志来控制如何接收数据。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">// 返回值，返回数据的字节长度；着无可用数据或对等方已经按序结束，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>MSG_CMSG_CLOEXEC</td>
<td>为UNIX域套接字上接收的文件描述符设置执行时关闭标志</td>
</tr>
<tr>
<td>MSG_DONTWAIT启用非阻塞操作</td>
</tr>
<tr>
<td>MSG_ERRQUEUE</td>
<td>接收错误信息作为辅助数据</td>
</tr>
<tr>
<td>MSG_OOB</td>
<td>如果协议支持，获取带外数据</td>
</tr>
<tr>
<td>MSG_PEEK</td>
<td>返回数据包内容而不真正取走数据包</td>
</tr>
<tr>
<td>MSG_TRUNC</td>
<td>即使数据包被截断，也返回数据包的实际长度</td>
</tr>
<tr>
<td>MSG_WAITALL</td>
<td>等待直到所有的数据可用</td>
</tr>
</tbody>
</table>
</div>
<p>当指定<code>MSG_PEEK</code>标志时，可以查看下一个要读取的数据但不真正取走它。当再次调用<code>read</code>或其中一个<code>recv</code>函数时，会返回刚才查看的数据。对于<code>SOCK_STREAM</code>套接字， 接收的数据可以比预期的少。<code>MSG_WAITALL</code>标志会阻止这种行为，直到所请求的数据全部返回，<code>recv</code>函数才会返回。对于<code>SOCK_DGRAM</code>和<code>SOCK_SEQPACKET</code>套接字，<code>MSG_WAITALL</code>标志没有改变什么行为，因为这些基于报文的套接字类型一次读取就返回整个报文。</p>
<p>如果发送者已经调用<code>shutdown</code>来结束传输，或者网络协议支持按默认的顺序关闭并且发送端已经关闭，那么当所有的数据接收完毕后，<code>recv</code>会返回0。</p>
<p>如果有兴趣定位发送者，可以使用<code>recvfrom</code>来得到数据发送者的源地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *<span class="keyword">restrict</span> buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr,</span></span><br><span class="line"><span class="params">    <span class="type">socklen_t</span> *<span class="keyword">restrict</span> addrlen)</span>;</span><br><span class="line"><span class="comment">// 返回值：返回数据的字节长度，若无可用数据或对等方已经按序结束，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>如果<code>addr</code>非空，它将包含数据发送者的套接字端点地址。当调用<code>recvfrom</code>时，需要设置<code>addrlen</code>参数指向一个整数，该整数包含<code>addr</code>所指向的套接字缓冲区的字节长度。返回时，该整数设为该地址的实际字节长度。因为可以获得发送者的地址，<code>recvfrom</code>通常用于无连接的套接字。否则，<code>recvfrom</code>等同于<code>recv</code>。</p>
<p>为了将接收到的数据送入多个缓冲区，类似于<code>readv</code>，或者想接收辅助数据，可以使用<code>recvmsg</code>，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">// 返回值，返回数据的字节长度。若无可用数据或对等方已经按序结束，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>recvmsg</code>用<code>msghdr</code>结构指定接收数据的输入缓冲区。可以设置参数<code>flags</code>来改变<code>recvmsg</code>的默认行为。返回时，<code>msghdr</code>结构中的<code>msg_flags</code>字段被设为所接收数据的各种特征。<code>recvmsg</code>中返回的各种可能值总结在图中。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>MSG_CTRUNC</td>
<td>控制数据被阶段</td>
</tr>
<tr>
<td>MSG_EOR</td>
<td>接收记录结束符</td>
</tr>
<tr>
<td>MSG_ERRQUEUE</td>
<td>接收错误信息作为辅助数据</td>
</tr>
<tr>
<td>MSG_OOB</td>
<td>接收带外数据</td>
</tr>
<tr>
<td>MSG_TRUNC</td>
<td>一般数据被截断</td>
</tr>
</tbody>
</table>
</div>
<p>程序显示了一个与服务器通信的客户端从系统的<code>uptime</code>命令获得输出。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFLEN		128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">connect_retry</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *,</span></span><br><span class="line"><span class="params">	<span class="type">socklen_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_uptime</span><span class="params">(<span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		n;</span><br><span class="line">	<span class="type">char</span>	buf[BUFLEN];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((n = recv(sockfd, buf, BUFLEN, <span class="number">0</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">		write(STDOUT_FILENO, buf, n);</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;recv error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>	*<span class="title">ailist</span>, *<span class="title">aip</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>	<span class="title">hint</span>;</span></span><br><span class="line">	<span class="type">int</span>				sockfd, err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;usage: ruptime hostname&quot;</span>);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;hint, <span class="number">0</span>, <span class="keyword">sizeof</span>(hint));</span><br><span class="line">	hint.ai_socktype = SOCK_STREAM;</span><br><span class="line">	hint.ai_canonname = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_addr = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> ((err = getaddrinfo(argv[<span class="number">1</span>], <span class="string">&quot;ruptime&quot;</span>, &amp;hint, &amp;ailist)) != <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;getaddrinfo error: %s&quot;</span>, gai_strerror(err));</span><br><span class="line">	<span class="keyword">for</span> (aip = ailist; aip != <span class="literal">NULL</span>; aip = aip-&gt;ai_next) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((sockfd = connect_retry(aip-&gt;ai_family, SOCK_STREAM, <span class="number">0</span>,</span><br><span class="line">		  aip-&gt;ai_addr, aip-&gt;ai_addrlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			err = errno;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			print_uptime(sockfd);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	err_exit(err, <span class="string">&quot;can&#x27;t connect to %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个程序连接服务器，读取服务器发送过来的字符串并将其打印到标准输出。因为使用的是<code>SOCK_STREAM</code>套接字，所以不能保证调用一次<code>recv</code>就会读取整个字符串，因此需要重复调用直到它返回0。</p>
<p>如果服务器支持多重网络接口或多重网络协议，函数<code>getaddrinfo</code>可能会返回多个候选地址供使用。轮流尝试每个地址，当找到一个允许连接到服务的地址时便可停止。使用<code>connect_retry</code>函数来与服务器建立一个连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFLEN	128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QLEN 10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HOST_NAME_MAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_NAME_MAX 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">initserver</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *, <span class="type">socklen_t</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">serve</span><span class="params">(<span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		clfd;</span><br><span class="line">	FILE	*fp;</span><br><span class="line">	<span class="type">char</span>	buf[BUFLEN];</span><br><span class="line"></span><br><span class="line">	set_cloexec(sockfd);</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((clfd = accept(sockfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			syslog(LOG_ERR, <span class="string">&quot;ruptimed: accept error: %s&quot;</span>,</span><br><span class="line">			  strerror(errno));</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		set_cloexec(clfd);</span><br><span class="line">		<span class="keyword">if</span> ((fp = popen(<span class="string">&quot;/usr/bin/uptime&quot;</span>, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">sprintf</span>(buf, <span class="string">&quot;error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">			send(clfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (fgets(buf, BUFLEN, fp) != <span class="literal">NULL</span>)</span><br><span class="line">				send(clfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">			pclose(fp);</span><br><span class="line">		&#125;</span><br><span class="line">		close(clfd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>	*<span class="title">ailist</span>, *<span class="title">aip</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>	<span class="title">hint</span>;</span></span><br><span class="line">	<span class="type">int</span>				sockfd, err, n;</span><br><span class="line">	<span class="type">char</span>			*host;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">1</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;usage: ruptimed&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((n = sysconf(_SC_HOST_NAME_MAX)) &lt; <span class="number">0</span>)</span><br><span class="line">		n = HOST_NAME_MAX;	<span class="comment">/* best guess */</span></span><br><span class="line">	<span class="keyword">if</span> ((host = <span class="built_in">malloc</span>(n)) == <span class="literal">NULL</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;malloc error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (gethostname(host, n) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;gethostname error&quot;</span>);</span><br><span class="line">	daemonize(<span class="string">&quot;ruptimed&quot;</span>);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;hint, <span class="number">0</span>, <span class="keyword">sizeof</span>(hint));</span><br><span class="line">	hint.ai_flags = AI_CANONNAME;</span><br><span class="line">	hint.ai_socktype = SOCK_STREAM;</span><br><span class="line">	hint.ai_canonname = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_addr = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> ((err = getaddrinfo(host, <span class="string">&quot;ruptime&quot;</span>, &amp;hint, &amp;ailist)) != <span class="number">0</span>) &#123;</span><br><span class="line">		syslog(LOG_ERR, <span class="string">&quot;ruptimed: getaddrinfo error: %s&quot;</span>,</span><br><span class="line">		  gai_strerror(err));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (aip = ailist; aip != <span class="literal">NULL</span>; aip = aip-&gt;ai_next) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((sockfd = initserver(SOCK_STREAM, aip-&gt;ai_addr,</span><br><span class="line">		  aip-&gt;ai_addrlen, QLEN)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			serve(sockfd);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了找到它的地址，服务器需要获得其运行时的主机名。如果主机名的最大长度不确定，可以使用<code>HOST_NAME_MAX</code>代替。如果系统没定义<code>HOST_NAME_MAX</code>，可以自己定义。POSIX.1要求主机名的最大长度至少为255字节，不包括终止null字符，因此定义<code>HOST_NAME_MAX</code>为256来包括终止null字符。</p>
<p>对于无连接的套接字，数据包到达时可能已经没有次序，因此如果不能将所有的数据放在一个数据包里，则在应用程序中就必须关心数据包的次序。数据包的最大尺寸是通信协议的特征，另外，对于无连接的套接字，数据包可能会丢失。如果应用程序不能容忍这种丢失，必须使用面向连接的套接字。</p>
<p>容忍数据包丢失意味着两种选择。一种选择是，如果想和对等方可靠通信，就必须对数据包编号，并且在发现数据包丢失时，请求对等应用程序重传，还必须标识重复数据包并丢弃它们，因为数据包可能会延迟或疑似丢失，可能请求重传之后，它们又出现了。</p>
<p>另一种选择是，通过让用户再次尝试那个命令来处理错误。对于简单的应用程序，这可能就足够了，但对于复杂的应用程序，这种选择通常不可行。因此，一般在这种情况下使用面向连接的套接字比较好。</p>
<p>面向连接的套接字的缺陷在于需要更多的时间和工作来建立一个连接，并且每个连接都需要消耗较多的操作系统资源。</p>
<p>程序是采用数据报套接字接口的<code>uptime</code>客户端命令版本。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFLEN		128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMEOUT		20</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sigalrm</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_uptime</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> addrinfo *aip)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		n;</span><br><span class="line">	<span class="type">char</span>	buf[BUFLEN];</span><br><span class="line"></span><br><span class="line">	buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (sendto(sockfd, buf, <span class="number">1</span>, <span class="number">0</span>, aip-&gt;ai_addr, aip-&gt;ai_addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;sendto error&quot;</span>);</span><br><span class="line">	alarm(TIMEOUT);</span><br><span class="line">	<span class="keyword">if</span> ((n = recvfrom(sockfd, buf, BUFLEN, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">			alarm(<span class="number">0</span>);</span><br><span class="line">		err_sys(<span class="string">&quot;recv error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	alarm(<span class="number">0</span>);</span><br><span class="line">	write(STDOUT_FILENO, buf, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>		*<span class="title">ailist</span>, *<span class="title">aip</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>		<span class="title">hint</span>;</span></span><br><span class="line">	<span class="type">int</span>					sockfd, err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>	<span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;usage: ruptime hostname&quot;</span>);</span><br><span class="line">	sa.sa_handler = sigalrm;</span><br><span class="line">	sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">	sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">	<span class="keyword">if</span> (sigaction(SIGALRM, &amp;sa, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;hint, <span class="number">0</span>, <span class="keyword">sizeof</span>(hint));</span><br><span class="line">	hint.ai_socktype = SOCK_DGRAM;</span><br><span class="line">	hint.ai_canonname = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_addr = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> ((err = getaddrinfo(argv[<span class="number">1</span>], <span class="string">&quot;ruptime&quot;</span>, &amp;hint, &amp;ailist)) != <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;getaddrinfo error: %s&quot;</span>, gai_strerror(err));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (aip = ailist; aip != <span class="literal">NULL</span>; aip = aip-&gt;ai_next) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((sockfd = socket(aip-&gt;ai_family, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			err = errno;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			print_uptime(sockfd, aip);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;can&#x27;t contact %s: %s\n&quot;</span>, argv[<span class="number">1</span>], strerror(err));</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了增加安装一个SIGALRM的信号处理程序以外，基于数据报的客户端中的main函数和面向连接的客户端中的类似。使用<code>alarm</code>函数来避免调用<code>recvfrom</code>时的无限期阻塞。</p>
<p>对于面向连接的协议，需要在交换数据之前连接到服务器。对于服务器来说，到来的连接请求已经足够判断出所需提供给客户端的服务。但是对于基于数据报的协议，需要有一种方法通知服务器来执行服务。本例中，只是简单地向服务器发送了1字节的数据。服务器将接收它，从数据包中得到地址，并使用这个地址来传送它的响应。如果服务器提供多个服务，可以使用这个请求数据来表示需要的服务，但由于服务器只做一件事情，1字节数据的内容是无关紧要的。</p>
<p>如果服务器不在运行状态，客户端调用<code>recvfrom</code>便会无限期阻塞。对于这个面向连接的实例，如果服务器不运行，<code>connect</code>调用会失败。为了避免无限期阻塞，可以在调用<code>recvfrom</code>之前设置警告时钟。</p>
<h2 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h2><p>套接字机制提供了两个套接字选项接口来控制套接字行为。一个接口用来设置选项，另一个接口可以查询选项的状态。可以获取或设置以下3种选项。</p>
<ol>
<li>通用选项，工作在所有套接字类型上。</li>
<li>在套接字层次管理的选项，但是依赖于下层协议的支持。</li>
<li>特定于某协议的选项，每个协议独有的。</li>
</ol>
<p>可以使用<code>setsockopt</code>函数来设置套接字选项。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option, <span class="type">const</span> <span class="type">void</span> *val,</span></span><br><span class="line"><span class="params">    <span class="type">socklen_t</span> len)</span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>参数<code>level</code>标识了选项应用的协议。如果选项是通用的套接字层次选项，则<code>level</code>设置成<code>SOL_SOCKET</code>。否则，<code>level</code>设置成控制这个选项的协议编号。对于TCP选项，<code>level</code>是<code>IPPROTO_TCP</code>，对于IP，<code>level</code>是<code>IPPROTO_IP</code>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>参数val的类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SO_ACCEPTCONN</td>
<td>int</td>
<td>返回信息指示该套接字是否能被监听</td>
</tr>
<tr>
<td>SO_BROADCAST</td>
<td>int</td>
<td>如果<code>*val</code>非0，广播数据报</td>
</tr>
<tr>
<td>SO_DEBUG</td>
<td>int</td>
<td>如果<code>*val</code>非0，启用网络驱动调试功能</td>
</tr>
<tr>
<td>SO_DONTROUTE</td>
<td>int</td>
<td>如果<code>*val</code>非0。绕过通常路由</td>
</tr>
<tr>
<td>SO_ERROR</td>
<td>int</td>
<td>返回挂起的套接字错误并清除</td>
</tr>
<tr>
<td>SO_KEEPALIVE</td>
<td>int</td>
<td>如果<code>*val</code>非0。启用周期性keep-alive报文</td>
</tr>
<tr>
<td>SO_LINGER</td>
<td>struct linger</td>
<td>当还有未发报文雨套接字已关闭时，延迟时间</td>
</tr>
<tr>
<td>SO_OOBINLINE</td>
<td>int</td>
<td>如果<code>*val</code>非0，将带外数据放在普通数据中</td>
</tr>
<tr>
<td>SO_RCVBUF</td>
<td>int</td>
<td>接收缓冲区的字节长度</td>
</tr>
<tr>
<td>SO_RCVLOWAT</td>
<td>int</td>
<td>接收调用中返回的最小数据字节数</td>
</tr>
<tr>
<td>SO_RCVTIMEO</td>
<td>struct timeval</td>
<td>套接字接收调用的超时值</td>
</tr>
<tr>
<td>SO_REUSEADDR</td>
<td>int</td>
<td>如果<code>*val</code>非0，重用bind中的地址</td>
</tr>
<tr>
<td>SO_SNDBUF</td>
<td>int</td>
<td>发送缓冲区的字节长度</td>
</tr>
<tr>
<td>SO_SNDLOWAT</td>
<td>int</td>
<td>发送调用中传送的最小数据字节数</td>
</tr>
<tr>
<td>SO_SNDTIMEO</td>
<td>struct timeval</td>
<td>套接字发送调用的超时值</td>
</tr>
<tr>
<td>SO_TYPE</td>
<td>int</td>
<td>标识套接字类型</td>
</tr>
</tbody>
</table>
</div>
<p>参数<code>val</code>根据选项的不同指向一个数据结构或者一个整数。一些选项是on/off开关。如果整数非0，则启用选项。如果整数为0，则禁止选项。参数len指定了val指向的对象的大小。可以使用<code>getsockopt</code>函数来查看选项的当前值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span> <span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option, <span class="type">void</span> *<span class="keyword">restrict</span> val,</span></span><br><span class="line"><span class="params">    <span class="type">socklen_t</span> *rentrict lenp)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>多数<code>lenp</code>是一个指向整数的指针。在调用<code>getsockopt</code>之前，设置该整数为复制选项缓冲区的长度。如果选项的实际长度大于此值，则选项会被截断。如果实际长度正好小于此值，那么返回时将此值更新为实际长度。</p>
<h2 id="带外数据"><a href="#带外数据" class="headerlink" title="带外数据"></a>带外数据</h2><p>带外数据(out-of-band data)是一些通信协议所支持的可选功能，与普通数据相比，它允许更高优先级的数据传输。带外数据先行传输，即使传输队列已经有数据。TCP支持带外数据，但是UDP不支持。套接字接口对带外数据的支持很大程度上受TCP带外数据具体实现的影响。</p>
<p>TCP将带外数据称为紧急数据(urgent data)。TCP仅支持一个字节的紧急数据，但是允许紧急数据在普通数据传递机制数据流之外传输。为了产生紧急数据，可以在3个send函数中的任何一个里指定<code>MSG_OOB</code>标志。如果带<code>MSG_OOB</code>标志发送的字节数超过一个时，最后一个字节将被视为紧急数据字节。</p>
<p>如果通过套接字安排了信号的产生，那么紧急数据被接收时，会发送SIGURG信号。可以通过调用以下函数安排进程接收套接字的信号：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fcntl(sockfd, F_SETOWN, pid);</span><br></pre></td></tr></table></figure></p>
<p><code>F_GETOWN</code>命令可以用来获得当前套接字所有权，对于<code>F_SETOWN</code>命令，负值代表进程组ID，正值代表进程ID。因此，调用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">owner = fcntl (socked, F_GETOWN, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>将返回<code>owner</code>，如果<code>owner</code>为正值， 则等于配置为接收套接字信号的进程的ID。如果<code>owner</code>为负值，其绝对值为接收套接字信号的进程组的ID。</p>
<p>TCP支持紧急标记(urgentmark)的概念， 即在普通数据流中紧急数据所在的位置。如果采用套接字选项<code>SO_OOBINLINE</code>，那么可以在普通数据中接收紧急数据。为帮助判断是否已经到达紧急标记，可以使用函数<code>sockatmark</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sockatmark</span><span class="params">(<span class="type">int</span> sockfd)</span>;</span><br><span class="line"><span class="comment">// 返回值：若在标记处，返回1；若没在标记处，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>当下一个要读取的字节在紧急标志处时，<code>sockatmark</code>返回1。当带外数据出现在套接字读取队列时，<code>select</code>函数会返回一个文件描述符并且有一个待处理的异常条件。可以在普通数据流上接收紧急数据，也可以在其中一个<code>recv</code>函数中采用<code>MSG_OOB</code>标志在其他队列数据之前接收紧急数据。TCP队列仅用一个字节的紧急数据。如果在接收当前的紧急数据字节之前又有新的紧急数据到来，那么已有的字节会被丢弃。</p>
<h2 id="非阻塞和异步I-O"><a href="#非阻塞和异步I-O" class="headerlink" title="非阻塞和异步I/O"></a>非阻塞和异步I/O</h2><p>通常，<code>recv</code>函数没有数据可用时会阻塞等待。同样地，当套接字输出队列没有足够空间来发送消息时，<code>send</code>函数会阻塞。在套接字非阻塞模式下，行为会改变。在这种情况下，这些函数不会阻塞而是会失败，将errno设置为EWOULDBLOCK成者EAGAIN。当这种情况发生时，可以使用<code>poll</code>或<code>select</code>来判断能否接收或者传输数据。</p>
<p>在基于套接字的异步I/O中，当从套接字中读取数据时， 或者当套接字写队列中空间变得可用时，可以安排要发送的信号SIGIO。启用异步I/O是一个两步骤的过程。</p>
<ol>
<li>建立套接字所有权，这样信号可以被传递到合适的进程。</li>
<li>通知套接字当I/O操作不会阻塞时发信号。</li>
</ol>
<p>可以使用3种方式来完成第一个步骤。</p>
<ul>
<li>在<code>fcntl</code>中使用<code>F_SETOWN</code>命令。</li>
<li>在<code>fcctl</code>中使用<code>FIOSETOWN</code>命令。</li>
<li>在<code>fcctl</code>中使用<code>SIOCSPGRP</code>命令。</li>
</ul>
<p>要完成第二个步骤，有两个选择</p>
<ol>
<li>在<code>fcntl</code>中使用<code>F_SETFL</code>命令并且启用文件标志<code>O_ASYNC</code>。</li>
<li>在<code>ioctl</code>中使用<code>FIOASYNC</code>命令。</li>
</ol>
<h1 id="高级进程间通信"><a href="#高级进程间通信" class="headerlink" title="高级进程间通信"></a>高级进程间通信</h1><h2 id="UNIX域套接字"><a href="#UNIX域套接字" class="headerlink" title="UNIX域套接字"></a>UNIX域套接字</h2><p>UNIX域套接字用于在同一台计算机上运行的进程之间的通信。虽然因特网域套接字可用于同一目的，但UNIX域套接字的效率更高。UNIX域套接字仅仅复制数据，它们并不执行协议处理，不需要添加或删除网络报头，无需计算校验和，不要产生顺序号，无需发送确认报文。UNIX域套接字提供流和数据报两种接口，UNIX域数据报服务是可靠的，既不会丢失报文也不会传递出错。UNIX域套接字就像是套接字和管道的混合。可以使用它们面向网络的域套接字接口或者使用<code>socketpair</code>函数来创建一对无命名的、相互连接的UNIX域套接字。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socketpair</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol, <span class="type">int</span> sockfd[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>虽然接口足够通用，允许<code>socketpair</code>用于其他域，但一般来说操作系统仅对UNIX域提供支持，一对相互连接的UNIX域套接字可以起到全双工管道的作用：两端对读和写开放。我们将其称为fd管道(fd-pipe)，以便与普通的半双工管道区分开来。</p>
<p><code>fd_pipe</code>函数使用<code>socketpair</code>函数来创建一对相互连接的UNIX域流套接字。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fd_pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (socketpair (AF_UNIX, SOCK_STREAM, <span class="number">0</span>, fd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>套接字是和文件描述符相关联的，消息到达时，可以用套接字来通知。对每个消息队列使用一个线程。每个线程都会在<code>msgrcv</code>调用中阻塞。当消息到达时，线程会把它写入一个UNIX域套接字的一端。当poll指示套接字可以读取数据时，应用程序会使用这个套接字的另外一端来接收这个消息。</p>
<p><code>main</code>函数中创建了一些消息队列和UNIX域套接字，并为每个消息队列开启了一个新线程。然后它在一个无限循环中用poll来轮询选择一个套接字端点。当某个套接字可读时，程序可以从套接字中读取数据并把消息打印到标准输出上。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NQ		3		<span class="comment">/* number of queues */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXMSZ	512		<span class="comment">/* maximum message size */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY		0x123	<span class="comment">/* key for first message queue */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">threadinfo</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> qid;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mymesg</span> &#123;</span></span><br><span class="line">	<span class="type">long</span> mtype;</span><br><span class="line">	<span class="type">char</span> mtext[MAXMSZ];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">helper</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>					n;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mymesg</span>		<span class="title">m</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">threadinfo</span>	*<span class="title">tip</span> =</span> arg;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(;;) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(&amp;m, <span class="number">0</span>, <span class="keyword">sizeof</span>(m));</span><br><span class="line">		<span class="keyword">if</span> ((n = msgrcv(tip-&gt;qid, &amp;m, MAXMSZ, <span class="number">0</span>, MSG_NOERROR)) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">&quot;msgrcv error&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (write(tip-&gt;fd, m.mtext, n) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>					i, n, err;</span><br><span class="line">	<span class="type">int</span>					fd[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span>					qid[NQ];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>		<span class="title">pfd</span>[<span class="title">NQ</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">threadinfo</span>	<span class="title">ti</span>[<span class="title">NQ</span>];</span></span><br><span class="line">	<span class="type">pthread_t</span>			tid[NQ];</span><br><span class="line">	<span class="type">char</span>				buf[MAXMSZ];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NQ; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((qid[i] = msgget((KEY+i), IPC_CREAT|<span class="number">0666</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">&quot;msgget error&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;queue ID %d is %d\n&quot;</span>, i, qid[i]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, fd) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">&quot;socketpair error&quot;</span>);</span><br><span class="line">		pfd[i].fd = fd[<span class="number">0</span>];</span><br><span class="line">		pfd[i].events = POLLIN;</span><br><span class="line">		ti[i].qid = qid[i];</span><br><span class="line">		ti[i].fd = fd[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> ((err = pthread_create(&amp;tid[i], <span class="literal">NULL</span>, helper, &amp;ti[i])) != <span class="number">0</span>)</span><br><span class="line">			err_exit(err, <span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (poll(pfd, NQ, <span class="number">-1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">&quot;poll error&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NQ; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pfd[i].revents &amp; POLLIN) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((n = read(pfd[i].fd, buf, <span class="keyword">sizeof</span>(buf))) &lt; <span class="number">0</span>)</span><br><span class="line">					err_sys(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">				buf[n] = <span class="number">0</span>;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;queue id %d, message %s\n&quot;</span>, qid[i], buf);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，我们使用的是数据报(<code>SOCK_DGRAM</code>)套接字而不是流套接字。这样做可以保持消息边界，以保证从套接字里一次只读取一条消息。</p>
<p>这种技术可以(非直接地)在消息队列中运用<code>poll</code>或者<code>select</code>。只要为每个队列分配一个线程的开销以及每个消息额外复制两次(一次写入套接字，另一次从套接字里读取出来)的开销是可接受的，这种技术就会使XSI消息队列的使用更加容易。</p>
<p>使用上述的程序发送消息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXMSZ 512</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mymesg</span> &#123;</span></span><br><span class="line">	<span class="type">long</span> mtype;</span><br><span class="line">	<span class="type">char</span> mtext[MAXMSZ];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">key_t</span> key;</span><br><span class="line">	<span class="type">long</span> qid;</span><br><span class="line">	<span class="type">size_t</span> nbytes;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mymesg</span> <span class="title">m</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: sendmsg KEY message\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	key = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> ((qid = msgget(key, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;can&#x27;t open queue key %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;m, <span class="number">0</span>, <span class="keyword">sizeof</span>(m));</span><br><span class="line">	<span class="built_in">strncpy</span>(m.mtext, argv[<span class="number">2</span>], MAXMSZ<span class="number">-1</span>);</span><br><span class="line">	nbytes = <span class="built_in">strlen</span>(m.mtext);</span><br><span class="line">	m.mtype = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (msgsnd(qid, &amp;m, nbytes, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;can&#x27;t send message&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个程序需要两个参数：消息队列关联的键值以及一个包含消息主体的字符串。发送消息到服务器端时，它会打印如下信息：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ./pollmag &amp;      在后台运行服务器</span><br><span class="line">[1]12814</span><br><span class="line">$ queue ID 0 is 196608</span><br><span class="line">queue ID 1 18 196609</span><br><span class="line">queue ID 2 18 196610</span><br><span class="line"></span><br><span class="line">$ ./sendmsg 0x123 <span class="string">&quot;hello, world&quot;</span>     给第一个队列发送一条消息</span><br><span class="line">queue <span class="built_in">id</span> 196608, message hello, world</span><br><span class="line">$ ./sendmsg 0x124 <span class="string">&quot;just a test&quot;</span>      给第二个队列发送一条消息</span><br><span class="line">queue <span class="built_in">id</span> 196609, nessage just a <span class="built_in">test</span> </span><br><span class="line">$ ./ sendmsg 0x125 <span class="string">&quot;bye&quot;</span>             给第三个队列发送一条消息</span><br><span class="line">queue <span class="built_in">id</span> 196610, nessage <span class="built_in">bye</span></span><br></pre></td></tr></table></figure></p>
<h3 id="命名UNIX域套接字"><a href="#命名UNIX域套接字" class="headerlink" title="命名UNIX域套接字"></a>命名UNIX域套接字</h3><p>虽然<code>socketpair</code>函数能创建一对相互连接的套接字，但是每一个套接字都没有名字。这意味着无关进程不能使用它们。</p>
<p>可以命名UNIX域套接字，并可将其用于告示服务。但是要注意，UNIX域套接字使用的地址格式不同于因特网域套接字。套接字地址格式会随实现而变。UNIX域套接字的地址由<code>sockaddr_un</code>结构表示。<code>sockaddr_un</code>结构在头文件<code>&lt;sys/un.h&gt;</code>中的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sun_tamily;   <span class="comment">/* AF_UNIX */</span></span><br><span class="line">	<span class="type">char</span> sun_path[<span class="number">108</span>];       <span class="comment">/* pathnome */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>sockaddr_un</code>结构的<code>sun_path</code>成员包含一个路径名。当我们将一个地址绑定到一个UNIX域套接字时，系统会用该路径名创建一个<code>S_IFSOCK</code>类型的文件。该文件仅用于向客户进程告示套接字名字。该文件无法打开，也不能由应用程序用于通信。如果我们试图绑定同一地址时，该文件已经存在，那么bind请求会失败。当关闭套接字时，并不自动删除该文件，所以必须确保在应用程序退出前，对该文件执行解除链接操作。</p>
<p>所示的程序是一个将地址绑定到UNIX域套接字的例子。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd, size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">un</span>;</span></span><br><span class="line"></span><br><span class="line">	un.sun_family = AF_UNIX;</span><br><span class="line">	<span class="built_in">strcpy</span>(un.sun_path, <span class="string">&quot;foo.socket&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((fd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;socket failed&quot;</span>);</span><br><span class="line">	size = offsetof(<span class="keyword">struct</span> sockaddr_un, sun_path) + <span class="built_in">strlen</span>(un.sun_path);</span><br><span class="line">	<span class="keyword">if</span> (bind(fd, (<span class="keyword">struct</span> sockaddr *)&amp;un, size) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;UNIX domain socket bound\n&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>确定绑定地址长度的方法是，先计算<code>sun_path</code>成员在<code>sockaddr_un</code>结构中的偏移量，然后将结果与路径名长度(不包括终止null字符)相加。因为<code>sockaddr_un</code>结构中<code>sun_path</code>之前的成员与实现相关，所以我们使用<code>&lt;stddef.h&gt;</code>头文件(包括在<code>apue.h</code>中)中的<code>offsetof</code>宏计算<code>sun_path</code>成员从结构开始处的偏移量。如果查看<code>&lt;stddef.h&gt;</code>，则可见到类似于下列形式的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof (TYPE, MEMBER) ((int)&amp;((TYPE *)0)-&gt;MEMBER)</span></span><br></pre></td></tr></table></figure></p>
<p>假定该结构从地址0开始，此表达式求得成员起始地址的整型值。</p>
<h2 id="唯一连接"><a href="#唯一连接" class="headerlink" title="唯一连接"></a>唯一连接</h2><p>服务器进程可以使用标准<code>bind</code>、<code>listen</code>和<code>accept</code>函数，为客户进程安排一个唯一UNIX域连接。客户进程使用<code>connect</code>与服务器进程联系。在服务器进程接受了<code>connect</code>请求后，在服务器进程和客户进程之间就存在了唯一连接。</p>
<p>图17-6展示了客户进程和服务器进程存在连接之前二者的情形。服务器端把它的套接字绑定到<code>sockaddr_un</code>的地址并监听新的连接请求。图17-7展示了在服务器端接受客户端连接请求后，客户端和服务器端之间建立的唯一的连接。<br><img src="/img/1623034862.jpg" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">serv_listen</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回要监听的文件描述符；若出错，返回负值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">serv_accept</span> <span class="params">(<span class="type">int</span> listenfd, <span class="type">uid_t</span> *uidptr)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回新文件描述符；若出错，返回负值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cli_conn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回文件描述符；若出错，返回负值</span></span><br></pre></td></tr></table></figure>
<p>服务器进程可以调用<code>serv_listen</code>函数声明它要在一个众所周知的名字上监听客户进程的连接请求。当客户进程想要连接至服务器进程时，它们将使用该名字。<code>serv_listen</code>函数的返回值是用于接收客户进程连接请求的服务器UNIX域套接字。服务器进程可以使用<code>serv_accept</code>函数等待客户进程连接请求的到达。当一个请求到达时，系统自动创建一个新的UNIX域套接字，并将它与客户端套接字连接，最后将这个新套接字返回给服务器。此外，客户进程的有效用户ID存放在<code>uidptr</code>指向的存储区中。客户进程调用<code>cli_conn</code>函数连接至服务器进程。客户进程指定的<code>name</code>参数必须与服务器进程调用<code>serv_listen</code>函数时所用的名字相同。函数返回时，客户进程得到接连至服务器进程的文件描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QLEN    10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a server endpoint of a connection.</span></span><br><span class="line"><span class="comment"> * Returns fd if all OK, &lt;0 on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">serv_listen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>                 fd, len, err, rval;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span>  <span class="title">un</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(name) &gt;= <span class="keyword">sizeof</span>(un.sun_path)) &#123;</span><br><span class="line">        errno = ENAMETOOLONG;</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create a UNIX domain stream socket */</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">    unlink(name);   <span class="comment">/* in case it already exists */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fill in socket address structure */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;un, <span class="number">0</span>, <span class="keyword">sizeof</span>(un));</span><br><span class="line">    un.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(un.sun_path, name);</span><br><span class="line">    len = offsetof(<span class="keyword">struct</span> sockaddr_un, sun_path) + <span class="built_in">strlen</span>(name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* bind the name to the descriptor */</span></span><br><span class="line">    <span class="keyword">if</span> (bind(fd, (<span class="keyword">struct</span> sockaddr *)&amp;un, len) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        rval = <span class="number">-3</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(fd, QLEN) &lt; <span class="number">0</span>) &#123; <span class="comment">/* tell kernel we&#x27;re a server */</span></span><br><span class="line">        rval = <span class="number">-4</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(fd);</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">    err = errno;</span><br><span class="line">    close(fd);</span><br><span class="line">    errno = err;</span><br><span class="line">    <span class="keyword">return</span>(rval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，调用<code>socket</code>创建一个UNIX域套接字。然后将欲赋给套接字的众所周知的路径名填入<code>sockaddr_un</code>结构。该结构是调用<code>bind</code>的参数。注意，不需要设置某些平台提供的<code>sun_len</code>字段，因为操作系统会用传送给bind函数的地址长度设置该字段。最后，调用<code>listen</code>函数来通知内核该进程将作为服务器进程等待客户进程的连接请求。当收到一个客户进程的连接请求后，服务器进程调用<code>serv_accept</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	STALE	30	<span class="comment">/* client&#x27;s name can&#x27;t be older than this (sec) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wait for a client connection to arrive, and accept it.</span></span><br><span class="line"><span class="comment"> * We also obtain the client&#x27;s user ID from the pathname</span></span><br><span class="line"><span class="comment"> * that it must bind before calling us.</span></span><br><span class="line"><span class="comment"> * Returns new fd if all OK, &lt;0 on error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">serv_accept</span><span class="params">(<span class="type">int</span> listenfd, <span class="type">uid_t</span> *uidptr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>					clifd, err, rval;</span><br><span class="line">	<span class="type">socklen_t</span>			len;</span><br><span class="line">	<span class="type">time_t</span>				staletime;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span>	<span class="title">un</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span>			<span class="title">statbuf</span>;</span></span><br><span class="line">	<span class="type">char</span>				*name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allocate enough space for longest name plus terminating null */</span></span><br><span class="line">	<span class="keyword">if</span> ((name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(un.sun_path + <span class="number">1</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	len = <span class="keyword">sizeof</span>(un);</span><br><span class="line">	<span class="keyword">if</span> ((clifd = accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;un, &amp;len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(name);</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-2</span>);		<span class="comment">/* often errno=EINTR, if signal caught */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* obtain the client&#x27;s uid from its calling address */</span></span><br><span class="line">	len -= offsetof(<span class="keyword">struct</span> sockaddr_un, sun_path); <span class="comment">/* len of pathname */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(name, un.sun_path, len);</span><br><span class="line">	name[len] = <span class="number">0</span>;			<span class="comment">/* null terminate */</span></span><br><span class="line">	<span class="keyword">if</span> (stat(name, &amp;statbuf) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rval = <span class="number">-3</span>;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	S_ISSOCK	<span class="comment">/* not defined for SVR4 */</span></span></span><br><span class="line">	<span class="keyword">if</span> (S_ISSOCK(statbuf.st_mode) == <span class="number">0</span>) &#123;</span><br><span class="line">		rval = <span class="number">-4</span>;		<span class="comment">/* not a socket */</span></span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((statbuf.st_mode &amp; (S_IRWXG | S_IRWXO)) ||</span><br><span class="line">		(statbuf.st_mode &amp; S_IRWXU) != S_IRWXU) &#123;</span><br><span class="line">		  rval = <span class="number">-5</span>;	<span class="comment">/* is not rwx------ */</span></span><br><span class="line">		  <span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	staletime = time(<span class="literal">NULL</span>) - STALE;</span><br><span class="line">	<span class="keyword">if</span> (statbuf.st_atime &lt; staletime ||</span><br><span class="line">		statbuf.st_ctime &lt; staletime ||</span><br><span class="line">		statbuf.st_mtime &lt; staletime) &#123;</span><br><span class="line">		  rval = <span class="number">-6</span>;	<span class="comment">/* i-node is too old */</span></span><br><span class="line">		  <span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (uidptr != <span class="literal">NULL</span>)</span><br><span class="line">		*uidptr = statbuf.st_uid;	<span class="comment">/* return uid of caller */</span></span><br><span class="line">	unlink(name);		<span class="comment">/* we&#x27;re done with pathname now */</span></span><br><span class="line">	<span class="built_in">free</span>(name);</span><br><span class="line">	<span class="keyword">return</span>(clifd);</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">	err = errno;</span><br><span class="line">	close(clifd);</span><br><span class="line">	<span class="built_in">free</span>(name);</span><br><span class="line">	errno = err;</span><br><span class="line">	<span class="keyword">return</span>(rval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务器进程在调用<code>serv_accept</code>中阻塞，等待一个客户进程调用<code>cli_conn</code>。从<code>accept</code>返回时，返回值是连接到客户进程的崭新的描述符。另外，<code>accept</code>函数也经由其第二个参数(指向<code>sockaddr_un</code>结构的指针)返回客户进程赋给其套接字的路径名(包含客户进程ID的名字)。接着，程序复制这个路径名，并确保它是以null终止的(如果路径名占用了<code>sockaddr_un</code>结构里的<code>sun_path</code>成员所有的可用空间，那就没有空间存放终止null字符)。然后，调用<code>stat</code>函数验证：该路径名确实是一个套接字；其权限仅允许用户读、用户写以及用户执行。还要验证与套接字相关联的3个时间参数不比当前时间早30秒。</p>
<p>如若通过了所有这些检验，则可认为客户进程的身份(其有效用户ID)是该套接字的所有者。虽然这种检验并不完善，但这是对当前系统所能做到的最佳方案。</p>
<p>客户进程调用<code>cli_conn</code>函数对连到服务器进程的连接进行初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	CLI_PATH	<span class="string">&quot;/var/tmp/&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	CLI_PERM	S_IRWXU			<span class="comment">/* rwx for user only */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a client endpoint and connect to a server.</span></span><br><span class="line"><span class="comment"> * Returns fd if all OK, &lt;0 on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">cli_conn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>					fd, len, err, rval;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span>	<span class="title">un</span>, <span class="title">sun</span>;</span></span><br><span class="line">	<span class="type">int</span>					do_unlink = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(name) &gt;= <span class="keyword">sizeof</span>(un.sun_path)) &#123;</span><br><span class="line">		errno = ENAMETOOLONG;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create a UNIX domain stream socket */</span></span><br><span class="line">	<span class="keyword">if</span> ((fd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fill socket address structure with our address */</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;un, <span class="number">0</span>, <span class="keyword">sizeof</span>(un));</span><br><span class="line">	un.sun_family = AF_UNIX;</span><br><span class="line">	<span class="built_in">sprintf</span>(un.sun_path, <span class="string">&quot;%s%05ld&quot;</span>, CLI_PATH, (<span class="type">long</span>)getpid());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;file is %s\n&quot;</span>, un.sun_path);</span><br><span class="line">	len = offsetof(<span class="keyword">struct</span> sockaddr_un, sun_path) + <span class="built_in">strlen</span>(un.sun_path);</span><br><span class="line"></span><br><span class="line">	unlink(un.sun_path);		<span class="comment">/* in case it already exists */</span></span><br><span class="line">	<span class="keyword">if</span> (bind(fd, (<span class="keyword">struct</span> sockaddr *)&amp;un, len) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rval = <span class="number">-2</span>;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (chmod(un.sun_path, CLI_PERM) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rval = <span class="number">-3</span>;</span><br><span class="line">		do_unlink = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fill socket address structure with server&#x27;s address */</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;sun, <span class="number">0</span>, <span class="keyword">sizeof</span>(sun));</span><br><span class="line">	sun.sun_family = AF_UNIX;</span><br><span class="line">	<span class="built_in">strcpy</span>(sun.sun_path, name);</span><br><span class="line">	len = offsetof(<span class="keyword">struct</span> sockaddr_un, sun_path) + <span class="built_in">strlen</span>(name);</span><br><span class="line">	<span class="keyword">if</span> (connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;sun, len) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rval = <span class="number">-4</span>;</span><br><span class="line">		do_unlink = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(fd);</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">	err = errno;</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">if</span> (do_unlink)</span><br><span class="line">		unlink(un.sun_path);</span><br><span class="line">	errno = err;</span><br><span class="line">	<span class="keyword">return</span>(rval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用<code>socket</code>函数创建UNIX域套接字的客户进程端，然后用客户进程专有的名字填入<code>sockaddr_un</code>结构。</p>
<p>绑定的路径名的最后5个字符来自客户进程ID。仅在该路径名已存在时调用<code>unlink</code>。然后，调用<code>bind</code>将名字赋给客户进程套接字。这在文件系统中创建了一个套接字文件，所用的名字与被绑定的路径名一样。接着，调用<code>chmod</code>关闭除用户读、用户写以及用户执行以外的其他权限。</p>
<p>在<code>serv_accept</code>中，服务器进程检验这些权限以及套接字用户ID以验证客户进程的身份。然后，必须填充另一个<code>sockaddr_un</code>结构，这次用的是服务进程众所周知的路径名。最后，调用<code>connect</code>函数初始化与服务进程的连接。</p>
<h2 id="传送文件描述符"><a href="#传送文件描述符" class="headerlink" title="传送文件描述符"></a>传送文件描述符</h2><p>在两个进程之间传送打开文件描述符的技术是非常有用的。它使一个进程(通常是服务器进程)能够处理打开一个文件所要做的一切操作(包括将网络名翻译为网络地址、拨号调制解调器、协商文件锁等)以及向调用进程送回一个描述符，该描述符可被用于以后的所有I/O函数。涉及打开文件或设备的所有细节对客户进程而言都是透明的。</p>
<p>当一个进程向另一个进程传送一个打开文件描述符时，我们想让发送进程和接收进程共享同一文件表项。图中显示了所期望的安排。<br><img src="/img/1623067638.jpg" alt=""></p>
<p>在技术上，我们是将指向一个打开文件表项的指针从一个进程发送到另外一个进程。该指针被分配存放在接收进程的第一个可用描述符项中。两个进程共享同一个打开文件表，这与fork之后的父进程和子进程共享打开文件表的情况完全相同)。</p>
<p>当发送进程将描述符传送给接收进程后，通常会关闭该描述符。发送进程关闭该描述符并不会真的关闭该文件或设备，其原因是该描述符仍被视为由接收进程打开(即使接收进程尚未接收到该描述符)。下面定义本章用以发送和接收文件报述符的3个函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">send_fd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> fd_no_send)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">send_err</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> status, <span class="type">const</span> <span class="type">char</span> *errmsg)</span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0；若出错，返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recv_fd</span><span class="params">(<span class="type">int</span> fd, <span class="type">ssize_t</span> (*userfunc) (<span class="type">int</span>, <span class="type">const</span> <span class="type">void</span> *, <span class="type">size_t</span>))</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回文件描述符：若出错，返回负值</span></span><br></pre></td></tr></table></figure></p>
<p>当一个进程(通常是服务器进程)想将一个描述符传送给另一个进程时，可以调用<code>send_fd</code>或<code>send_err</code>。等待接收描述符的进程(客户进程)调用<code>recv_fd</code>。<code>send_fd</code>使用<code>fd</code>代表的UNIX域套接字发送描述符<code>fd_to_send</code>。<code>send_err</code>使用<code>fd</code>发送<code>errmsg</code>以及后随的<code>stahus</code>字节。<code>status</code>的值应在-1~—255。</p>
<p>客户进程调用<code>recv_fd</code>接收描述符。如果一切正常(发送者调用了<code>send_fd</code>)，则函数返回值为非负描述符。否则，返回值是由<code>send_err</code>发送的<code>status</code>(-1~—255的一个负值)。另外，如果服务器进程发送了一条出错消息，则客户进程调用它自己的<code>userfunc</code>函数处理该消息。<code>userfunc</code>的第一个参数是常量<code>STDERR_FILENO</code>，然后是指向出错消息的指针及其长度。<code>userfunc</code>函数的返回值是已写的字节数或负的出错编号值。客户进程常将普通的<code>write</code>函数指定为<code>userfunc</code>。</p>
<p>为发送一个描述符，<code>send_fd</code>先发送2字节0，然后是实际描述符。为了发送一条出错消息，<code>send_err</code>发送<code>errmsg</code>，然后是1字节0，最后是<code>status</code>字节的绝对值(1~255)。<code>recv_fd</code>函数读取套接字中所有字节直至遇到null字符。null字符之前的所有字符都传送给调用者的<code>userfunc</code>。<code>recv_fd</code>读取的下一个字节是状态(<code>status</code>)字节。若状态字节为0，则表示一个描述符已传送过来，否则表示没有描述符可接收。<code>send_err</code>函数在将出错消息写到套接字后，即调用<code>send_fd</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Used when we had planned to send an fd using send_fd(),</span></span><br><span class="line"><span class="comment"> * but encountered an error instead.  We send the error back</span></span><br><span class="line"><span class="comment"> * using the send_fd()/recv_fd() protocol.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">send_err</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> errcode, <span class="type">const</span> <span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((n = <span class="built_in">strlen</span>(msg)) &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (writen(fd, msg, n) != n)	<span class="comment">/* send the error message */</span></span><br><span class="line">			<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (errcode &gt;= <span class="number">0</span>)</span><br><span class="line">		errcode = <span class="number">-1</span>;	<span class="comment">/* must be negative */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (send_fd(fd, errcode) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了用UNIX域套接字交换文件描述符，调用<code>sendmsg(2)</code>和<code>recvmsg(2)</code>函数。这两个函数的参数中都有一个指向<code>msghdr</code>结构的指针，该结构包含了所有关于要发送或要接收的消息的信息。该结构的定义大致如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> *msg_name;        <span class="comment">/* optional address */</span></span><br><span class="line">	<span class="type">socklen_t</span> msg_namelen; <span class="comment">/* address size in bytes */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span> <span class="comment">/* array of I/O butters */</span></span><br><span class="line">	<span class="type">int</span> msg_iovlens        <span class="comment">/* number of elements in array */</span></span><br><span class="line">	<span class="type">void</span> *msg_control;     <span class="comment">/* ancillary data */</span></span><br><span class="line">	<span class="type">socklen_t</span> msg_controllen; <span class="comment">/* number of ancillery bytes */</span></span><br><span class="line">	<span class="type">int</span> msg_flags;            <span class="comment">/* flags for received message */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>前两个元素通常用于在网络连接上发送数据报，其中目的地址可以由每个数据报指定。接下来的两个元素使我们可以指定一个由多个缓冲区构成的数组(散布读和聚集写)，这与对<code>readv</code>和<code>writev</code>函数的说明一样。<code>msg_flags</code>字段包含了描述接收到的消息的标志，总结了这些标志。</p>
<p>两个元素处理控制信息的传送和接收。<code>msg_control</code>字段指向<code>cmsghdr</code>(整制信息头)结构，<code>msg_controllen</code>字段包含控制信息的字节数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> &#123;</span></span><br><span class="line">	<span class="type">socklen_t</span> cmsg_len;  <span class="comment">/* data byte count, including header */</span></span><br><span class="line">	<span class="type">int</span> cmsg_level;      <span class="comment">/* originating protocol */</span></span><br><span class="line">	<span class="type">int</span> cmsg_type;       <span class="comment">/* protocol-specirie type */</span></span><br><span class="line">	<span class="comment">/* followed by the actual control message data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在此定义3个宏，用于访问控制数据，一个宏用于帮助计算cmsg_len所使用的值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">CMSG_DATA</span><span class="params">(<span class="keyword">struct</span> cmsghdr* cp)</span>;</span><br><span class="line"><span class="comment">// 返回值：返回一个指针，指向与cmsghdr结构相关联的数据</span></span><br><span class="line"><span class="keyword">struct</span> cmsghdr *<span class="title function_">CMSG_FIRSTHDR</span><span class="params">(<span class="keyword">struct</span> msghdr* mp)</span>;</span><br><span class="line"><span class="comment">// 返回值，返回一个指针，指向与msghdr结构相关联的第一个cmsghdr结构，若无这样的结构，返回null</span></span><br><span class="line"><span class="keyword">struct</span> cmsghdr *<span class="title function_">CMSG_NXTHDR</span><span class="params">(<span class="keyword">struct</span> maghdr *mp, <span class="keyword">struct</span> cmsghdr *cp)</span>;</span><br><span class="line"><span class="comment">// 返回值：返回一个指针，指向与msghdr结构相关联的下一个cmsghdr结构，该msghdr结构给出了当前的cmsghdr结构；若当前cmsghdr结构已是最后一个，返回NULL</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">CMSG_LEN</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nbytes)</span>;</span><br><span class="line"><span class="comment">// 返回值。返回为nbytes长的数据对象分配的长度</span></span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84_%E9%87%8F%E5%8C%96%E7%A0%94%E7%A9%B6%E6%96%B9%E6%B3%95%20%E7%AC%94%E8%AE%B03/" rel="prev" title="计算机体系结构 量化研究方法 笔记3">
      <i class="fa fa-chevron-left"></i> 计算机体系结构 量化研究方法 笔记3
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/06/19/%E5%8C%97%E4%BA%AC%E5%9C%B0%E9%93%81%E8%A7%84%E5%88%92/" rel="next" title="北京地铁2025年规划">
      北京地铁2025年规划 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#UNIX%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">UNIX基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#UNIX%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">UNIX体系结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="nav-number">1.2.</span> <span class="nav-text">文件和目录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.2.1.</span> <span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%90%8D"><span class="nav-number">1.2.2.</span> <span class="nav-text">文件名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E5%90%8D"><span class="nav-number">1.2.3.</span> <span class="nav-text">路径名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="nav-number">1.2.4.</span> <span class="nav-text">工作目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%B7%E5%A7%8B%E7%9B%AE%E5%BD%95"><span class="nav-number">1.2.5.</span> <span class="nav-text">起始目录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="nav-number">1.3.</span> <span class="nav-text">输入和输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">1.3.1.</span> <span class="nav-text">文件描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E3%80%81%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E5%92%8C%E6%A0%87%E5%87%86%E9%94%99%E8%AF%AF"><span class="nav-number">1.3.2.</span> <span class="nav-text">标准输入、标准输出和标准错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%B8%A6%E7%BC%93%E5%86%B2%E7%9A%84I-O"><span class="nav-number">1.3.3.</span> <span class="nav-text">不带缓冲的I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86I-O"><span class="nav-number">1.3.4.</span> <span class="nav-text">标准I&#x2F;O</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.4.</span> <span class="nav-text">程序和进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.4.1.</span> <span class="nav-text">程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8BID"><span class="nav-number">1.4.2.</span> <span class="nav-text">进程和进程ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">1.4.3.</span> <span class="nav-text">进程控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8BID"><span class="nav-number">1.4.4.</span> <span class="nav-text">线程和线程ID</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BA%E9%94%99%E5%A4%84%E7%90%86"><span class="nav-number">1.5.</span> <span class="nav-text">出错处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%A0%87%E8%AF%86"><span class="nav-number">1.6.</span> <span class="nav-text">用户标识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7ID"><span class="nav-number">1.6.1.</span> <span class="nav-text">用户ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%84%E5%B1%9E%E7%BB%84ID"><span class="nav-number">1.6.2.</span> <span class="nav-text">附属组ID</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7"><span class="nav-number">1.7.</span> <span class="nav-text">信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%80%BC"><span class="nav-number">1.8.</span> <span class="nav-text">时间值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">1.9.</span> <span class="nav-text">系统调用和库函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%87%E4%BB%B6I-O"><span class="nav-number">2.</span> <span class="nav-text">文件I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">2.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-1"><span class="nav-number">2.2.</span> <span class="nav-text">文件描述符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0open%E5%92%8Copenat"><span class="nav-number">2.3.</span> <span class="nav-text">函数open和openat</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%90%8D%E5%92%8C%E8%B7%AF%E5%BE%84%E5%90%8D%E6%88%AA%E6%96%AD"><span class="nav-number">2.3.1.</span> <span class="nav-text">文件名和路径名截断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0creat"><span class="nav-number">2.4.</span> <span class="nav-text">函数creat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0close"><span class="nav-number">2.5.</span> <span class="nav-text">函数close</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0lseek"><span class="nav-number">2.6.</span> <span class="nav-text">函数lseek</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0read"><span class="nav-number">2.7.</span> <span class="nav-text">函数read</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0write"><span class="nav-number">2.8.</span> <span class="nav-text">函数write</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O%E7%9A%84%E6%95%88%E7%8E%87"><span class="nav-number">2.9.</span> <span class="nav-text">I&#x2F;O的效率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="nav-number">2.10.</span> <span class="nav-text">文件共享</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">2.11.</span> <span class="nav-text">原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%BD%E5%8A%A0%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="nav-number">2.11.1.</span> <span class="nav-text">追加到一个文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0pread%E5%92%8Cpwrite"><span class="nav-number">2.11.2.</span> <span class="nav-text">函数pread和pwrite</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="nav-number">2.11.3.</span> <span class="nav-text">创建一个文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0dup%E5%92%8Cdup2"><span class="nav-number">2.12.</span> <span class="nav-text">函数dup和dup2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0sync%E3%80%81fsync%E5%92%8Cfdatasync"><span class="nav-number">2.13.</span> <span class="nav-text">函数sync、fsync和fdatasync</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0fcntl"><span class="nav-number">2.14.</span> <span class="nav-text">函数fcntl</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0ioctl"><span class="nav-number">2.15.</span> <span class="nav-text">函数ioctl</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dev-fd"><span class="nav-number">2.16.</span> <span class="nav-text">&#x2F;dev&#x2F;fd</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95-1"><span class="nav-number">3.</span> <span class="nav-text">文件和目录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0stat%E3%80%81fstat%E3%80%81fstatat%E5%92%8Clstat"><span class="nav-number">3.1.</span> <span class="nav-text">函数stat、fstat、fstatat和lstat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.</span> <span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7ID%E5%92%8C%E8%AE%BE%E7%BD%AE%E7%BB%84ID"><span class="nav-number">3.3.</span> <span class="nav-text">设置用户ID和设置组ID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="nav-number">3.4.</span> <span class="nav-text">文件访问权限</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-number">3.5.</span> <span class="nav-text">新文件和目录的所有权</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0access%E5%92%8Cfaccessat"><span class="nav-number">3.6.</span> <span class="nav-text">函数access和faccessat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0umask"><span class="nav-number">3.7.</span> <span class="nav-text">函数umask</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0chmod%E3%80%81fchmod%E5%92%8Cfchmodat"><span class="nav-number">3.8.</span> <span class="nav-text">函数chmod、fchmod和fchmodat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B2%98%E7%9D%80%E4%BD%8D"><span class="nav-number">3.9.</span> <span class="nav-text">粘着位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0chown%E3%80%81fchown%E3%80%81fchownat%E5%92%8C1chown"><span class="nav-number">3.10.</span> <span class="nav-text">函数chown、fchown、fchownat和1chown</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E9%95%BF%E5%BA%A6"><span class="nav-number">3.11.</span> <span class="nav-text">文件长度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%B4%9E"><span class="nav-number">3.11.1.</span> <span class="nav-text">文件中的空洞</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%88%AA%E6%96%AD"><span class="nav-number">3.12.</span> <span class="nav-text">文件截断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-1"><span class="nav-number">3.13.</span> <span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B01ink%E3%80%81linkat%E3%80%81unlink%E3%80%81unlinkat%E5%92%8Cremove"><span class="nav-number">3.14.</span> <span class="nav-text">函数1ink、linkat、unlink、unlinkat和remove</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0rename%E5%92%8Crenameat"><span class="nav-number">3.15.</span> <span class="nav-text">函数rename和renameat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5"><span class="nav-number">3.16.</span> <span class="nav-text">符号链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AF%BB%E5%8F%96%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5"><span class="nav-number">3.17.</span> <span class="nav-text">创建和读取符号链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%97%B6%E9%97%B4"><span class="nav-number">3.18.</span> <span class="nav-text">文件的时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0futimens%E3%80%81utimensat%E5%92%8Cutimes"><span class="nav-number">3.19.</span> <span class="nav-text">函数futimens、utimensat和utimes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0mkdir-mkdirat%E5%92%8Crmdir"><span class="nav-number">3.20.</span> <span class="nav-text">函数mkdir, mkdirat和rmdir</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E7%9B%AE%E5%BD%95"><span class="nav-number">3.21.</span> <span class="nav-text">读目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0chdir%E3%80%81fchdir%E5%92%8Cgetcwd"><span class="nav-number">3.22.</span> <span class="nav-text">函数chdir、fchdir和getcwd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6"><span class="nav-number">3.23.</span> <span class="nav-text">设备特殊文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BD%8D%E5%B0%8F%E7%BB%93"><span class="nav-number">3.24.</span> <span class="nav-text">文件访问权限位小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%87%E5%87%86I-O%E5%BA%93"><span class="nav-number">4.</span> <span class="nav-text">标准I&#x2F;O库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E5%92%8CFILE%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.1.</span> <span class="nav-text">流和FILE对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E3%80%81%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E5%92%8C%E6%A0%87%E5%87%86%E9%94%99%E8%AF%AF-1"><span class="nav-number">4.2.</span> <span class="nav-text">标准输入、标准输出和标准错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%86%B2"><span class="nav-number">4.3.</span> <span class="nav-text">缓冲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E6%B5%81"><span class="nav-number">4.4.</span> <span class="nav-text">打开流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%92%8C%E5%86%99%E6%B5%81"><span class="nav-number">4.5.</span> <span class="nav-text">读和写流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0"><span class="nav-number">4.5.1.</span> <span class="nav-text">输入函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="nav-number">4.5.2.</span> <span class="nav-text">输出函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%8F%E6%AC%A1%E4%B8%80%E8%A1%8CI-O"><span class="nav-number">4.6.</span> <span class="nav-text">每次一行I&#x2F;O</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E5%87%86I-O%E7%9A%84%E6%95%88%E7%8E%87"><span class="nav-number">4.7.</span> <span class="nav-text">标准I&#x2F;O的效率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6I-O"><span class="nav-number">4.8.</span> <span class="nav-text">二进制I&#x2F;O</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%BD%8D%E6%B5%81"><span class="nav-number">4.9.</span> <span class="nav-text">定位流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96I-O"><span class="nav-number">4.10.</span> <span class="nav-text">格式化I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="nav-number">4.10.1.</span> <span class="nav-text">格式化输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5"><span class="nav-number">4.10.2.</span> <span class="nav-text">格式化输入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-number">4.11.</span> <span class="nav-text">实现细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6"><span class="nav-number">4.12.</span> <span class="nav-text">临时文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B5%81"><span class="nav-number">4.13.</span> <span class="nav-text">内存流</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E4%BF%A1%E6%81%AF"><span class="nav-number">5.</span> <span class="nav-text">系统数据文件和信息</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E8%A8%80-1"><span class="nav-number">5.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%A3%E4%BB%A4%E6%96%87%E4%BB%B6"><span class="nav-number">5.2.</span> <span class="nav-text">口令文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%B4%E5%BD%B1%E5%8F%A3%E4%BB%A4"><span class="nav-number">5.3.</span> <span class="nav-text">阴影口令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E6%96%87%E4%BB%B6"><span class="nav-number">5.4.</span> <span class="nav-text">组文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84%E5%B1%9E%E7%BB%84ID-1"><span class="nav-number">5.5.</span> <span class="nav-text">附属组ID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6"><span class="nav-number">5.6.</span> <span class="nav-text">其他数据文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%99%BB%E5%BD%95%E8%B4%A6%E6%88%B7%E8%AE%B0%E5%BD%95"><span class="nav-number">5.7.</span> <span class="nav-text">登录账户记录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%A0%87%E8%AF%86"><span class="nav-number">5.8.</span> <span class="nav-text">系统标识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F%E4%BE%8B%E7%A8%8B"><span class="nav-number">5.9.</span> <span class="nav-text">时间和日期例程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%B8%E7%A8%8B%E7%8E%AF%E5%A2%83"><span class="nav-number">6.</span> <span class="nav-text">迸程环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#main%E5%87%BD%E6%95%B0"><span class="nav-number">6.1.</span> <span class="nav-text">main函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="nav-number">6.2.</span> <span class="nav-text">进程终止</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%80%E5%87%BA%E5%87%BD%E6%95%B0"><span class="nav-number">6.2.1.</span> <span class="nav-text">退出函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0atexit"><span class="nav-number">6.2.2.</span> <span class="nav-text">函数atexit</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-number">6.3.</span> <span class="nav-text">命令行参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E8%A1%A8"><span class="nav-number">6.4.</span> <span class="nav-text">环境表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80"><span class="nav-number">6.5.</span> <span class="nav-text">C程序的存储空间布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="nav-number">6.6.</span> <span class="nav-text">共享库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D"><span class="nav-number">6.7.</span> <span class="nav-text">存储空间分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%BF%E4%BB%A3%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E7%A8%8B%E5%BA%8F"><span class="nav-number">6.7.1.</span> <span class="nav-text">替代的存储空间分配程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#libmalloc"><span class="nav-number">6.7.1.1.</span> <span class="nav-text">libmalloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vmalloc"><span class="nav-number">6.7.1.2.</span> <span class="nav-text">vmalloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#quick-fit"><span class="nav-number">6.7.1.3.</span> <span class="nav-text">quick-fit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jemalloc"><span class="nav-number">6.7.1.4.</span> <span class="nav-text">jemalloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCMalloc"><span class="nav-number">6.7.1.5.</span> <span class="nav-text">TCMalloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0alloca"><span class="nav-number">6.7.1.6.</span> <span class="nav-text">函数alloca</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">6.8.</span> <span class="nav-text">环境变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0setjmp%E5%92%8C1ongjmp"><span class="nav-number">6.9.</span> <span class="nav-text">函数setjmp和1ongjmp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0getrlimit%E5%92%8Csetrlimit"><span class="nav-number">6.10.</span> <span class="nav-text">函数getrlimit和setrlimit</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6-1"><span class="nav-number">7.</span> <span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86"><span class="nav-number">7.1.</span> <span class="nav-text">进程标识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0fork"><span class="nav-number">7.2.</span> <span class="nav-text">函数fork</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0vfork"><span class="nav-number">7.3.</span> <span class="nav-text">函数vfork</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0exit"><span class="nav-number">7.4.</span> <span class="nav-text">函数exit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0wait%E5%92%8Cwaitpid"><span class="nav-number">7.5.</span> <span class="nav-text">函数wait和waitpid</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0waitid"><span class="nav-number">7.6.</span> <span class="nav-text">函数waitid</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0wait3%E5%92%8Cwait4"><span class="nav-number">7.7.</span> <span class="nav-text">函数wait3和wait4</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6"><span class="nav-number">7.8.</span> <span class="nav-text">竞争条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0exec"><span class="nav-number">7.9.</span> <span class="nav-text">函数exec</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E7%94%A8%E6%88%B7ID%E5%92%8C%E6%9B%B4%E6%94%B9%E7%BB%84ID"><span class="nav-number">7.10.</span> <span class="nav-text">更改用户ID和更改组ID</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0setreuid%E5%92%8Csotregid"><span class="nav-number">7.10.1.</span> <span class="nav-text">函数setreuid和sotregid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0seteuid%E5%92%8Csotegid"><span class="nav-number">7.10.2.</span> <span class="nav-text">函数seteuid和sotegid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84ID"><span class="nav-number">7.10.3.</span> <span class="nav-text">组ID</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%96%87%E4%BB%B6"><span class="nav-number">7.11.</span> <span class="nav-text">解释器文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0system"><span class="nav-number">7.12.</span> <span class="nav-text">函数system</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%BC%9A%E8%AE%A1"><span class="nav-number">7.13.</span> <span class="nav-text">进程会计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%A0%87%E8%AF%86-1"><span class="nav-number">7.14.</span> <span class="nav-text">用户标识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">7.15.</span> <span class="nav-text">进程调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%97%B6%E9%97%B4"><span class="nav-number">7.16.</span> <span class="nav-text">进程时间</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB"><span class="nav-number">8.</span> <span class="nav-text">进程关系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%88%E7%AB%AF%E7%99%BB%E5%BD%95"><span class="nav-number">8.1.</span> <span class="nav-text">终端登录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="nav-number">8.2.</span> <span class="nav-text">进程组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D"><span class="nav-number">8.3.</span> <span class="nav-text">会话</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%88%E7%AB%AF"><span class="nav-number">8.4.</span> <span class="nav-text">控制终端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0tcgetpgrp%E3%80%81tcsetpgrp%E5%92%8Ctcgetsid"><span class="nav-number">8.5.</span> <span class="nav-text">函数tcgetpgrp、tcsetpgrp和tcgetsid</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6"><span class="nav-number">9.</span> <span class="nav-text">作业控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#shell%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="nav-number">9.1.</span> <span class="nav-text">shell执行程序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7-1"><span class="nav-number">10.</span> <span class="nav-text">信号</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E8%A8%80-2"><span class="nav-number">10.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E6%A6%82%E5%BF%B5"><span class="nav-number">10.2.</span> <span class="nav-text">信号概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0signal"><span class="nav-number">10.3.</span> <span class="nav-text">函数signal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8"><span class="nav-number">10.3.1.</span> <span class="nav-text">程序启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">10.3.2.</span> <span class="nav-text">进程创建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%9D%A0%E7%9A%84%E4%BF%A1%E5%8F%B7"><span class="nav-number">10.4.</span> <span class="nav-text">不可靠的信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">10.5.</span> <span class="nav-text">中断的系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0"><span class="nav-number">10.6.</span> <span class="nav-text">可重入函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SIGCLD%E8%AF%AD%E4%B9%89"><span class="nav-number">10.7.</span> <span class="nav-text">SIGCLD语义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7%E6%9C%AF%E8%AF%AD%E5%92%8C%E8%AF%AD%E4%B9%89"><span class="nav-number">10.8.</span> <span class="nav-text">可靠信号术语和语义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0kill%E5%92%8Craise"><span class="nav-number">10.9.</span> <span class="nav-text">函数kill和raise</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0alarm%E5%92%8Cpause"><span class="nav-number">10.10.</span> <span class="nav-text">函数alarm和pause</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="nav-number">10.11.</span> <span class="nav-text">信号集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0sigprocmask"><span class="nav-number">10.12.</span> <span class="nav-text">函数sigprocmask</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0sigpending"><span class="nav-number">10.13.</span> <span class="nav-text">函数sigpending</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0sigaction"><span class="nav-number">10.14.</span> <span class="nav-text">函数sigaction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0sigsetjmp%E5%92%8Csig1ongjmp"><span class="nav-number">10.15.</span> <span class="nav-text">函数sigsetjmp和sig1ongjmp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0sigsuspend"><span class="nav-number">10.16.</span> <span class="nav-text">函数sigsuspend</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0abort"><span class="nav-number">10.17.</span> <span class="nav-text">函数abort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0system-1"><span class="nav-number">10.18.</span> <span class="nav-text">函数system</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#system%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">10.18.1.</span> <span class="nav-text">system的返回值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0sleep%E3%80%81nanosleep%E5%92%8Cclock-nanosleep"><span class="nav-number">10.19.</span> <span class="nav-text">函数sleep、nanosleep和clock_nanosleep</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0sigqueue"><span class="nav-number">10.20.</span> <span class="nav-text">函数sigqueue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7"><span class="nav-number">10.21.</span> <span class="nav-text">作业控制信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E5%90%8D%E5%92%8C%E7%BC%96%E5%8F%B7"><span class="nav-number">10.22.</span> <span class="nav-text">信号名和编号</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">11.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="nav-number">11.1.</span> <span class="nav-text">线程概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A0%87%E8%AF%86"><span class="nav-number">11.2.</span> <span class="nav-text">线程标识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">11.3.</span> <span class="nav-text">线程创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="nav-number">11.4.</span> <span class="nav-text">线程终止</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">11.5.</span> <span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-number">11.5.1.</span> <span class="nav-text">互斥量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">11.5.2.</span> <span class="nav-text">避免死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0pthread-mutex-timedlock"><span class="nav-number">11.5.3.</span> <span class="nav-text">函数pthread_mutex_timedlock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">11.5.4.</span> <span class="nav-text">读写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E6%9C%89%E8%B6%85%E6%97%B6%E7%9A%84%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">11.5.5.</span> <span class="nav-text">带有超时的读写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">11.5.6.</span> <span class="nav-text">条件变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">11.5.7.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%8F%E9%9A%9C"><span class="nav-number">11.5.8.</span> <span class="nav-text">屏障</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">12.</span> <span class="nav-text">线程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%99%90%E5%88%B6"><span class="nav-number">12.1.</span> <span class="nav-text">线程限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">12.2.</span> <span class="nav-text">线程属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%B1%9E%E6%80%A7"><span class="nav-number">12.3.</span> <span class="nav-text">同步属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="nav-number">12.4.</span> <span class="nav-text">互斥量属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E5%B1%9E%E6%80%A7"><span class="nav-number">12.4.1.</span> <span class="nav-text">读写锁属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="nav-number">12.4.2.</span> <span class="nav-text">条件变量属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%8F%E9%9A%9C%E5%B1%9E%E6%80%A7"><span class="nav-number">12.4.3.</span> <span class="nav-text">屏障属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%85%A5"><span class="nav-number">12.5.</span> <span class="nav-text">重入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%89%B9%E5%AE%9A%E6%95%B0%E6%8D%AE"><span class="nav-number">12.6.</span> <span class="nav-text">线程特定数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%96%E6%B6%88%E9%80%89%E9%A1%B9"><span class="nav-number">12.7.</span> <span class="nav-text">取消选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BF%A1%E5%8F%B7"><span class="nav-number">12.8.</span> <span class="nav-text">线程和信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8Cfork"><span class="nav-number">12.9.</span> <span class="nav-text">线程和fork</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-number">13.</span> <span class="nav-text">守护进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-number">13.1.</span> <span class="nav-text">守护进程的特征</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E8%A7%84%E5%88%99"><span class="nav-number">13.2.</span> <span class="nav-text">编程规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BA%E9%94%99%E8%AE%B0%E5%BD%95"><span class="nav-number">13.3.</span> <span class="nav-text">出错记录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%AE%9E%E4%BE%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-number">13.4.</span> <span class="nav-text">单实例守护进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%83%AF%E4%BE%8B"><span class="nav-number">13.5.</span> <span class="nav-text">守护进程的惯例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7I-O"><span class="nav-number">14.</span> <span class="nav-text">高级I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EI-O"><span class="nav-number">14.1.</span> <span class="nav-text">非阻塞I&#x2F;O</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81"><span class="nav-number">14.2.</span> <span class="nav-text">记录锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fcntl%E8%AE%B0%E5%BD%95%E9%94%81"><span class="nav-number">14.2.1.</span> <span class="nav-text">fcntl记录锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E9%9A%90%E5%90%AB%E7%BB%A7%E6%89%BF%E5%92%8C%E9%87%8A%E6%94%BE"><span class="nav-number">14.2.2.</span> <span class="nav-text">锁的隐含继承和释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeBSD%E5%AE%9E%E7%8E%B0"><span class="nav-number">14.2.3.</span> <span class="nav-text">FreeBSD实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%96%87%E4%BB%B6%E5%B0%BE%E7%AB%AF%E5%8A%A0%E9%94%81"><span class="nav-number">14.2.4.</span> <span class="nav-text">在文件尾端加锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E8%AE%AE%E6%80%A7%E9%94%81%E5%92%8C%E5%BC%BA%E5%88%B6%E6%80%A7%E9%94%81"><span class="nav-number">14.2.5.</span> <span class="nav-text">建议性锁和强制性锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5"><span class="nav-number">14.3.</span> <span class="nav-text">I&#x2F;O多路转接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0select%E5%92%8Cpselect"><span class="nav-number">14.3.1.</span> <span class="nav-text">函数select和pselect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0poll"><span class="nav-number">14.3.2.</span> <span class="nav-text">函数poll</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5I-O"><span class="nav-number">14.4.</span> <span class="nav-text">异步I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#System-V%E5%BC%82%E6%AD%A5I-O"><span class="nav-number">14.4.1.</span> <span class="nav-text">System V异步I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BSD%E5%BC%82%E6%AD%A5I-O"><span class="nav-number">14.4.2.</span> <span class="nav-text">BSD异步I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POSIX%E5%BC%82%E6%AD%A5I-O"><span class="nav-number">14.4.3.</span> <span class="nav-text">POSIX异步I&#x2F;O</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0readv%E5%92%8Cwritev"><span class="nav-number">14.5.</span> <span class="nav-text">函数readv和writev</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0readn%E5%92%8Cwriten"><span class="nav-number">14.6.</span> <span class="nav-text">函数readn和writen</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84I-O"><span class="nav-number">14.7.</span> <span class="nav-text">存储映射I&#x2F;O</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">15.</span> <span class="nav-text">进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E8%A8%80-3"><span class="nav-number">15.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E9%81%93"><span class="nav-number">15.2.</span> <span class="nav-text">管道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0popen%E5%92%8Cpclose"><span class="nav-number">15.3.</span> <span class="nav-text">函数popen和pclose</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E5%90%8C%E8%BF%9B%E7%A8%8B"><span class="nav-number">15.4.</span> <span class="nav-text">协同进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FIFO"><span class="nav-number">15.5.</span> <span class="nav-text">FIFO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XSI-IPC"><span class="nav-number">15.6.</span> <span class="nav-text">XSI IPC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E9%94%AE"><span class="nav-number">15.6.1.</span> <span class="nav-text">标识符和键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E7%BB%93%E6%9E%84"><span class="nav-number">15.6.2.</span> <span class="nav-text">权限结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E9%99%90%E5%88%B6"><span class="nav-number">15.6.3.</span> <span class="nav-text">结构限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="nav-number">15.6.4.</span> <span class="nav-text">优点和缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">15.7.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">15.8.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exit%E6%97%B6%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%B0%83%E6%95%B4"><span class="nav-number">15.8.1.</span> <span class="nav-text">exit时的信号量调整</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="nav-number">15.9.</span> <span class="nav-text">共享存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#POSIX%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">15.10.</span> <span class="nav-text">POSIX信号量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9CIPC%EF%BC%9A%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">16.</span> <span class="nav-text">网络IPC：套接字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E8%A8%80-4"><span class="nav-number">16.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">16.2.</span> <span class="nav-text">套接字描述符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BB%E5%9D%80"><span class="nav-number">16.3.</span> <span class="nav-text">寻址</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%87%E8%8A%82%E5%BA%8F"><span class="nav-number">16.3.1.</span> <span class="nav-text">宇节序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F"><span class="nav-number">16.3.2.</span> <span class="nav-text">地址格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E6%9F%A5%E8%AF%A2"><span class="nav-number">16.3.3.</span> <span class="nav-text">地址查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E5%9C%B0%E5%9D%80%E5%85%B3%E8%81%94"><span class="nav-number">16.3.4.</span> <span class="nav-text">将套接字与地址关联</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="nav-number">16.4.</span> <span class="nav-text">建立连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="nav-number">16.5.</span> <span class="nav-text">数据传输</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9"><span class="nav-number">16.6.</span> <span class="nav-text">套接字选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%A6%E5%A4%96%E6%95%B0%E6%8D%AE"><span class="nav-number">16.7.</span> <span class="nav-text">带外数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%92%8C%E5%BC%82%E6%AD%A5I-O"><span class="nav-number">16.8.</span> <span class="nav-text">非阻塞和异步I&#x2F;O</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">17.</span> <span class="nav-text">高级进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#UNIX%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">17.1.</span> <span class="nav-text">UNIX域套接字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8DUNIX%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">17.1.1.</span> <span class="nav-text">命名UNIX域套接字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E8%BF%9E%E6%8E%A5"><span class="nav-number">17.2.</span> <span class="nav-text">唯一连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E9%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">17.3.</span> <span class="nav-text">传送文件描述符</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuhao0102" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuhao0102" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuhhpc0203@gmail.com" title="E-Mail → mailto:yuhhpc0203@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
