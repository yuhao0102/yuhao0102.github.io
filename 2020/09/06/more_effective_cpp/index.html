<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zn-ch">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="积累," />










<meta name="description" content="条款1：指针与引用的区别指针与引用看上去完全不同（指针用操作符’*’和’-&gt;’，引用使用操作符’.’），但是它们似乎有相同的功能。指针与引用都是让你间接引用其他对象。你如何决定在什么时候使用指针，在什么时候使用引用呢？ 首先，要认识到在任何情况下都不能用指向空值的引用。一个引用必须总是指向某些对象。因此如果你使用一个变量并让它指向一个对象，但是该变量在某些时候也可能不指向任何对象，这时你应该">
<meta property="og:type" content="article">
<meta property="og:title" content="More Effective C++笔记">
<meta property="og:url" content="http://yoursite.com/2020/09/06/more_effective_cpp/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="条款1：指针与引用的区别指针与引用看上去完全不同（指针用操作符’*’和’-&gt;’，引用使用操作符’.’），但是它们似乎有相同的功能。指针与引用都是让你间接引用其他对象。你如何决定在什么时候使用指针，在什么时候使用引用呢？ 首先，要认识到在任何情况下都不能用指向空值的引用。一个引用必须总是指向某些对象。因此如果你使用一个变量并让它指向一个对象，但是该变量在某些时候也可能不指向任何对象，这时你应该">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/20200908003400.png">
<meta property="og:image" content="http://yoursite.com/img/20200908003401.png">
<meta property="og:image" content="http://yoursite.com/img/20200908003402.png">
<meta property="article:published_time" content="2020-09-06T02:11:00.000Z">
<meta property="article:modified_time" content="2020-09-09T01:25:16.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="积累">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/20200908003400.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/09/06/more_effective_cpp/"/>





  <title>More Effective C++笔记 | Hao Yu's blog</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/06/more_effective_cpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">More Effective C++笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-06T10:11:00+08:00">
                2020-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="条款1：指针与引用的区别"><a href="#条款1：指针与引用的区别" class="headerlink" title="条款1：指针与引用的区别"></a>条款1：指针与引用的区别</h1><p>指针与引用看上去完全不同（指针用操作符’*’和’-&gt;’，引用使用操作符’.’），但是它们似乎有相同的功能。指针与引用都是让你间接引用其他对象。你如何决定在什么时候使用指针，在什么时候使用引用呢？</p>
<p>首先，要认识到在任何情况下都不能用指向空值的引用。一个引用必须总是指向某些对象。因此<strong>如果你使用一个变量并让它指向一个对象，但是该变量在某些时候也可能不指向任何对象，这时你应该把变量声明为指针，因为这样你可以赋空值给该变量</strong>。相反，如果变量肯定指向一个对象，例如你的设计不允许变量为空，这时你就可以把变量声明为引用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *pc = <span class="number">0</span>;          <span class="comment">// 设置指针为空值</span></span><br><span class="line"><span class="type">char</span>&amp; rc = *pc;        <span class="comment">// 让引用指向空值</span></span><br></pre></td></tr></table></figure><br>这是非常有害的，毫无疑问。结果将是不确定的（编译器能产生一些输出，导致任何事情都有可能发生）。<strong>因为引用肯定会指向一个对象，在C里，引用应被初始化。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>&amp; rs;             <span class="comment">// 错误，引用必须被初始化</span></span><br><span class="line"><span class="built_in">string</span> <span class="title function_">s</span><span class="params">(<span class="string">&quot;xyzzy&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>&amp; rs = s;         <span class="comment">// 正确，rs指向s</span></span><br></pre></td></tr></table></figure></p>
<p>指针没有这样的限制。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps;             <span class="comment">// 未初始化的指针</span></span><br><span class="line">                        <span class="comment">// 合法但危险</span></span><br></pre></td></tr></table></figure><br>不存在指向空值的引用这个事实意味着使用引用的代码效率比使用指针的要高。因为在使用引用之前不需要测试它的合法性。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printDouble</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; rd)</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; rd;         <span class="comment">// 不需要测试rd,它</span></span><br><span class="line">&#125;                       <span class="comment">// 肯定指向一个double值</span></span><br></pre></td></tr></table></figure></p>
<p>相反，指针则应该总是被测试，防止其为空：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printDouble</span><span class="params">(<span class="type">const</span> <span class="type">double</span> *pd)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (pd) &#123;             <span class="comment">// 检查是否为NULL</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pd;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>指针与引用的另一个重要的不同是指针可以被重新赋值以指向另一个不同的对象。但是引用则总是指向在初始化时被指定的对象，以后不能改变。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="title function_">s1</span><span class="params">(<span class="string">&quot;Nancy&quot;</span>)</span>;</span><br><span class="line"><span class="built_in">string</span> <span class="title function_">s2</span><span class="params">(<span class="string">&quot;Clancy&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>&amp; rs = s1;         <span class="comment">// rs 引用 s1</span></span><br><span class="line"><span class="built_in">string</span> *ps = &amp;s1;        <span class="comment">// ps 指向 s1</span></span><br><span class="line"></span><br><span class="line">rs = s2;                 <span class="comment">// rs 仍旧引用s1,</span></span><br><span class="line">                         <span class="comment">// 但是 s1的值现在是</span></span><br><span class="line">                         <span class="comment">// &quot;Clancy&quot;</span></span><br><span class="line">ps = &amp;s2;                <span class="comment">// ps 现在指向 s2;</span></span><br><span class="line">                         <span class="comment">// s1 没有改变</span></span><br></pre></td></tr></table></figure></p>
<p>总的来说，在以下情况下你应该使用指针：</p>
<ul>
<li>一是你考虑到存在不指向任何对象的可能（在这种情况下，你能够设置指针为空）；</li>
<li>二是你需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向）。</li>
<li>如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么你应该使用引用。</li>
</ul>
<p>还有一种情况，就是当你重载某个操作符时，你应该使用引用。最普通的例子是操作符[]。这个操作符典型的用法是返回一个目标对象，其能被赋值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">v</span><span class="params">(<span class="number">10</span>)</span>;       <span class="comment">// 建立整形向量（vector），大小为10;</span></span><br><span class="line">                         <span class="comment">// 向量是一个在标准C库中的一个模板(见条款35)</span></span><br><span class="line">v[<span class="number">5</span>] = <span class="number">10</span>;               <span class="comment">// 这个被赋值的目标对象就是操作符[]返回的值</span></span><br></pre></td></tr></table></figure></p>
<p>如果操作符[]返回一个指针，那么后一个语句就得这样写：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*v[5] = 10;</span><br></pre></td></tr></table></figure></p>
<p>但是这样会使得v看上去象是一个向量指针。因此你会选择让操作符返回一个引用。（这有一个有趣的例外，参见条款30）</p>
<p>当你知道你必须指向一个对象并且不想改变其指向时，或者在重载操作符并为防止不必要的语义误解时，你不应该使用指针。而在除此之外的其他情况下，则应使用指针。</p>
<h1 id="条款2：尽量使用C-风格的类型转换"><a href="#条款2：尽量使用C-风格的类型转换" class="headerlink" title="条款2：尽量使用C++风格的类型转换"></a>条款2：尽量使用C++风格的类型转换</h1><p>C++通过引进四个新的类型转换操作符克服了C风格类型转换的缺点，这四个操作符是，<code>static_cast</code>,<code>const_cast</code>,<code>dynamic_cast</code>, 和<code>reinterpret_cast</code>。在大多数情况下，对于这些操作符你只需要知道原来你习惯于这样写，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(type) expression</span><br></pre></td></tr></table></figure><br>而现在你总应该这样写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;type&gt;(expression)</span><br></pre></td></tr></table></figure></p>
<p>例如，假设你想把一个int转换成double，以便让包含int类型变量的表达式产生出浮点数值的结果。如果用C风格的类型转换，你能这样写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> firstNumber, secondNumber;</span><br><span class="line"><span class="type">double</span> result = ((<span class="type">double</span>)firstNumber)/secondNumber；</span><br></pre></td></tr></table></figure><br>如果用上述新的类型转换方法，你应该这样写：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double result = static_cast&lt;double&gt;(firstNumber)/secondNumber;</span><br></pre></td></tr></table></figure></p>
<p><code>static_cast</code>也有功能上限制。例如，你不能用static_cast象用C风格的类型转换一样把struct转换成int类型或者把double类型转换成指针类型，另外，static_cast不能从表达式中去除const属性，因为另一个新的类型转换操作符const_cast有这样的功能。</p>
<p><code>const_cast</code>用于类型转换掉表达式的<code>const</code>或<code>volatileness</code>属性。通过使用<code>const_cast</code>，你向人们和编译器强调你通过类型转换想做的只是改变一些东西的constness 或者 volatileness属性。这个含义被编译器所约束。如果你试图使用<code>const_cast</code>来完成修改constness 或者 volatileness属性之外的事情，你的类型转换将被拒绝。下面是一些例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWidget</span>: <span class="keyword">public</span> Widget &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(SpecialWidget *psw)</span></span>;</span><br><span class="line"></span><br><span class="line">SpecialWidget sw;                <span class="comment">// sw 是一个非const 对象。</span></span><br><span class="line"><span class="type">const</span> SpecialWidget&amp; csw = sw;   <span class="comment">// csw 是sw的一个引用</span></span><br><span class="line">                                <span class="comment">// 它是一个const 对象</span></span><br><span class="line">                              </span><br><span class="line"><span class="built_in">update</span>(&amp;csw);  <span class="comment">// 错误!不能传递一个const SpecialWidget* 变量</span></span><br><span class="line">               <span class="comment">// 给一个处理SpecialWidget*类型变量的函数</span></span><br><span class="line">                              </span><br><span class="line"><span class="built_in">update</span>(<span class="built_in">const_cast</span>&lt;SpecialWidget*&gt;(&amp;csw));</span><br><span class="line">                       <span class="comment">// 正确，csw的const被显示地转换掉（</span></span><br><span class="line">                      <span class="comment">// csw和sw两个变量值在update函数中能被更新）</span></span><br><span class="line">                             </span><br><span class="line"><span class="built_in">update</span>((SpecialWidget*)&amp;csw);</span><br><span class="line">                         <span class="comment">// 同上，但用了一个更难识别的C风格的类型转换</span></span><br><span class="line">                              </span><br><span class="line">Widget *pw = <span class="keyword">new</span> SpecialWidget;</span><br><span class="line"><span class="built_in">update</span>(pw);         <span class="comment">// 错误！pw的类型是Widget*，但是</span></span><br><span class="line">                    <span class="comment">// update函数处理的是SpecialWidget*类型</span></span><br><span class="line"><span class="built_in">update</span>(<span class="built_in">const_cast</span>&lt;SpecialWidget*&gt;(pw));</span><br><span class="line">                    <span class="comment">// 错误！const_cast仅能被用在影响</span></span><br><span class="line">                    <span class="comment">// constness or volatileness的地方上。,</span></span><br><span class="line">                    <span class="comment">// 不能用在向继承子类进行类型转换。</span></span><br></pre></td></tr></table></figure><br>到目前为止，const_cast最普通的用途就是转换掉对象的const属性。</p>
<p>第二种特殊的类型转换符是<code>dynamic_cast</code>，它被用于安全地沿着类的继承关系向下进行类型转换。这就是说，你能<strong>用dynamic_cast把指向基类的指针或引用转换成指向其派生类或其兄弟类的指针或引用</strong>，而且你能知道转换是否成功。失败的转换将返回空指针（当对指针进行类型转换时）或者抛出异常（当对引用进行类型转换时）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Widget *pw;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">update</span>(<span class="built_in">dynamic_cast</span>&lt;SpecialWidget*&gt;(pw));</span><br><span class="line">        <span class="comment">// 正确，传递给update函数一个指针</span></span><br><span class="line">        <span class="comment">// 是指向变量类型为SpecialWidget的pw的指针</span></span><br><span class="line">        <span class="comment">// 如果pw确实指向一个对象，否则传递过去的将使空指针。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateViaRef</span><span class="params">(SpecialWidget&amp; rsw)</span></span>;</span><br><span class="line"><span class="built_in">updateViaRef</span>(<span class="built_in">dynamic_cast</span>&lt;SpecialWidget&amp;&gt;(*pw));</span><br><span class="line">                         <span class="comment">//正确。 传递给updateViaRef函数</span></span><br><span class="line">                         <span class="comment">// SpecialWidget pw 指针，如果pw</span></span><br><span class="line">                         <span class="comment">// 确实指向了某个对象</span></span><br><span class="line">                         <span class="comment">// 否则将抛出异常</span></span><br></pre></td></tr></table></figure><br>dynamic_casts在帮助你浏览继承层次上是有限制的。它不能被用于缺乏虚函数的类型上（参见条款24），也不能用它来转换掉constness:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> firstNumber, secondNumber;</span><br><span class="line">...</span><br><span class="line"><span class="type">double</span> result = <span class="built_in">dynamic_cast</span>&lt;<span class="type">double</span>&gt;(firstNumber)/secondNumber;</span><br><span class="line">                         <span class="comment">// 错误！没有继承关系</span></span><br><span class="line"><span class="type">const</span> SpecialWidget sw;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">update</span>(<span class="built_in">dynamic_cast</span>&lt;SpecialWidget*&gt;(&amp;sw));</span><br><span class="line">                         <span class="comment">// 错误! dynamic_cast不能转换</span></span><br><span class="line">                         <span class="comment">// 掉const。</span></span><br></pre></td></tr></table></figure><br>如你想在没有继承关系的类型中进行转换，你可能想到<code>static_cast</code>。如果是为了去除const，你总得用<code>const_cast</code>。</p>
<p><code>reinterpret_cast</code>被用于的类型转换的转换结果几乎都是实现时定义（implementation-defined）。因此，使用<code>reinterpret_casts</code>的代码很难移植。<code>reinterpret_casts</code>的最普通的用途就是<strong>在函数指针类型之间进行转换</strong>。例如，假设你有一个函数指针数组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FuncPtr)</span><span class="params">()</span></span>;      <span class="comment">// FuncPtr is 一个指向函数</span></span><br><span class="line">                                <span class="comment">// 的指针，该函数没有参数</span></span><br><span class="line">                                 <span class="comment">// 也返回值类型为void</span></span><br><span class="line">FuncPtr funcPtrArray[<span class="number">10</span>];       <span class="comment">// funcPtrArray 是一个能容纳</span></span><br><span class="line">                                <span class="comment">// 10个FuncPtrs指针的数组</span></span><br></pre></td></tr></table></figure><br>让我们假设你希望（因为某些莫名其妙的原因）把一个指向下面函数的指针存入funcPtrArray数组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>你不能不经过类型转换而直接去做，因为doSomething函数对于funcPtrArray数组来说有一个错误的类型。在FuncPtrArray数组里的函数返回值是void类型，而doSomething函数返回值是int类型。<code>reinterpret_cast</code>可以让你迫使编译器以你的方法去看待它们：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">funcPtrArray[<span class="number">0</span>] =                   <span class="comment">// this compiles</span></span><br><span class="line">  <span class="built_in">reinterpret_cast</span>&lt;FuncPtr&gt;(&amp;doSomething);</span><br></pre></td></tr></table></figure></p>
<p>转换函数指针的代码是不可移植的（C++不保证所有的函数指针都被用一样的方法表示），在一些情况下这样的转换会产生不正确的结果（参见条款31），所以你应该避免转换函数指针类型。</p>
<h1 id="条款3：不要使用多态性数组"><a href="#条款3：不要使用多态性数组" class="headerlink" title="条款3：不要使用多态性数组"></a>条款3：不要使用多态性数组</h1><p>类继承的最重要的特性是你可以通过基类指针或引用来操作派生类。这样的指针或引用具有行为的多态性，就好像它们同时具有多种形态。C++允许你通过基类指针和引用来操作派生类数组。不过这根本就不是一个特性，因为这样的代码根本无法如你所愿地那样运行。</p>
<p>假设你有一个类BST（比如是搜索树对象）和继承自BST类的派生类BalancedBST：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BalancedBST</span>: <span class="keyword">public</span> BST &#123; ... &#125;;</span><br></pre></td></tr></table></figure></p>
<p>有这样一个函数，它能打印出BST类数组中每一个BST对象的内容：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBSTArray</span><span class="params">(ostream&amp; s,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> BST array[],</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">int</span> numElements)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numElements; ) &#123;</span><br><span class="line">    s &lt;&lt; array[i];          <span class="comment">//假设BST类</span></span><br><span class="line">  &#125;                         <span class="comment">//重载了操作符&lt;&lt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当你传递给该函数一个含有BST对象的数组变量时，它能够正常运行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BST BSTArray[<span class="number">10</span>];</span><br><span class="line">...</span><br><span class="line"><span class="built_in">printBSTArray</span>(cout, BSTArray, <span class="number">10</span>);          <span class="comment">// 运行正常</span></span><br></pre></td></tr></table></figure></p>
<p>然而，请考虑一下，当你把含有BalancedBST对象的数组变量传递给printBSTArray函数时，会产生什么样的后果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BalancedBST bBSTArray[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">printBSTArray</span>(cout, bBSTArray, <span class="number">10</span>);         <span class="comment">// 还会运行正常么？</span></span><br></pre></td></tr></table></figure></p>
<p>你的编译器将会毫无警告地编译这个函数，但是再看一下这个函数的循环代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numElements; ) &#123;</span><br><span class="line">  s &lt;&lt; array[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>array数组中每一个元素都是BST类型，因此每个元素与数组起始地址的间隔是<code>i*sizeof(BST)</code>。BalancedBST对象长度的比BST长，printBSTArray函数生成的指针算法将是错误的。<strong>多态和指针算法不能混合在一起来用，所以数组与多态也不能用在一起</strong>。</p>
<h1 id="条款4：避免无用的缺省构造函数"><a href="#条款4：避免无用的缺省构造函数" class="headerlink" title="条款4：避免无用的缺省构造函数"></a>条款4：避免无用的缺省构造函数</h1><p>缺省构造函数（指没有参数的构造函数）在C++语言中是一种让你无中生有的方法。缺省构造函数则可以不利用任何在建立对象时的外部数据就能初始化对象。如果一个类没有缺省构造函数，就会存在一些使用上的限制。 </p>
<p>请考虑一下有这样一个类，它表示公司的设备，这个类包含一个公司的ID代码，这个ID代码被强制做为构造函数的参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EquipmentPiece</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">EquipmentPiece</span>(<span class="type">int</span> IDNumber);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>因为EquipmentPiece类没有一个缺省构造函数，所以在三种情况下使用它，就会遇到问题。第一种情况是建立数组时。一般来说，没有一种办法能在建立对象数组时给构造函数传递参数。所以在通常情况下，不可能建立EquipmentPiece对象数组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EquipmentPiece bestPieces[<span class="number">10</span>];           <span class="comment">// 错误！没有正确调用</span></span><br><span class="line">                                         <span class="comment">// EquipmentPiece 构造函数</span></span><br><span class="line">EquipmentPiece *bestPieces = <span class="keyword">new</span> EquipmentPiece[<span class="number">10</span>];</span><br><span class="line">                                        <span class="comment">// 错误！与上面的问题一样</span></span><br></pre></td></tr></table></figure><br>不过还是有三种方法能回避开这个限制。对于使用非堆数组（non-heap arrays）（即不在堆中给数组分配内存。译者注）的一种解决方法是在数组定义时提供必要的参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ID1, ID2, ID3, ..., ID10;            <span class="comment">// 存储设备ID号的变量</span></span><br><span class="line">EquipmentPiece bestPieces[] = &#123;          <span class="comment">// 正确, 提供了构造</span></span><br><span class="line">  <span class="built_in">EquipmentPiece</span>(ID1),                   <span class="comment">// 函数的参数</span></span><br><span class="line">  <span class="built_in">EquipmentPiece</span>(ID2),</span><br><span class="line">  <span class="built_in">EquipmentPiece</span>(ID3),</span><br><span class="line">  ...,</span><br><span class="line">  <span class="built_in">EquipmentPiece</span>(ID10)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>不过很遗憾，这种方法不能用在堆数组(heap arrays)的定义上。更通用的解决方法是利用指针数组来代替一个对象数组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> EquipmentPiece* PEP;             <span class="comment">//  PEP 指针指向</span></span><br><span class="line">                                         <span class="comment">//一个EquipmentPiece对象</span></span><br><span class="line"></span><br><span class="line">PEP bestPieces[<span class="number">10</span>];                      <span class="comment">// 正确, 没有调用构造函数</span></span><br><span class="line">PEP *bestPieces = <span class="keyword">new</span> PEP[<span class="number">10</span>];           <span class="comment">// 也正确</span></span><br></pre></td></tr></table></figure><br>在指针数组里的每一个指针被重新赋值，以指向一个不同的EquipmentPiece对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">  bestPieces[i] = <span class="keyword">new</span> <span class="built_in">EquipmentPiece</span>( ID Number );</span><br></pre></td></tr></table></figure></p>
<p>不过这种方法有两个缺点，第一你必须删除数组里每个指针所指向的对象。如果你忘了，就会发生内存泄漏。第二增加了内存分配量，因为正如你需要空间来容纳EquipmentPiece对象一样，你也需要空间来容纳指针。如果你为数组分配raw memory，你就可以避免浪费内存。使用placement new方法（参见条款8）在内存中构造EquipmentPiece对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为大小为10的数组 分配足够的内存</span></span><br><span class="line"><span class="comment">// EquipmentPiece 对象; 详细情况请参见条款8</span></span><br><span class="line"><span class="comment">// operator new[] 函数</span></span><br><span class="line"><span class="type">void</span> *rawMemory =</span><br><span class="line">  <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="number">10</span>*<span class="built_in">sizeof</span>(EquipmentPiece));</span><br><span class="line"><span class="comment">// make bestPieces point to it so it can be treated as an</span></span><br><span class="line"><span class="comment">// EquipmentPiece array</span></span><br><span class="line">EquipmentPiece *bestPieces =</span><br><span class="line">  <span class="built_in">static_cast</span>&lt;EquipmentPiece*&gt;(rawMemory);</span><br><span class="line"><span class="comment">// construct the EquipmentPiece objects in the memory</span></span><br><span class="line"><span class="comment">// 使用&quot;placement new&quot; (参见条款8)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">  <span class="keyword">new</span> (&amp;bestPieces[i]) <span class="built_in">EquipmentPiece</span>( ID Number );</span><br></pre></td></tr></table></figure></p>
<p>使用placement new的缺点除了是大多数程序员对它不熟悉外（能使用它就更难了），还有就是当你不想让它继续存在使用时，必须手动调用数组对象的析构函数，调用操作符delete[]来释放 raw memory（请再参见条款8）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以与构造bestPieces对象相反的顺序解构它。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">  bestPieces[i].~<span class="built_in">EquipmentPiece</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// deallocate the raw memory</span></span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">delete</span>[](rawMemory);</span><br></pre></td></tr></table></figure></p>
<p>对于类里没有定义缺省构造函数所造成的第二个问题是它们<strong>无法在许多基于模板（template-based）容器类里使用</strong>。因为实例化一个模板时，模板的类型参数应该提供一个缺省构造函数，这是一个常见的要求。这个要求总是来自于模板内部，被建立的模板参数类型数组里。例如一个数组模板类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Array</span>(<span class="type">int</span> size);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T *data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Array&lt;T&gt;::<span class="built_in">Array</span>(<span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  data = <span class="keyword">new</span> T[size];                    <span class="comment">// 为每个数组元素</span></span><br><span class="line">  ...                                    <span class="comment">//依次调用 T::T()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在多数情况下，通过仔细设计模板可以杜绝对缺省构造函数的需求。例如标准的vector模板（生成一个类似于可扩展数组的类）对它的类型参数没有必须有缺省构造函数的要求。</p>
<p>一些人认为所有的类都应该有缺省构造函数，即使缺省构造函数没有足够的数据来初始化一个对象。比如这个原则的拥护者会这样修改EquipmentPiece类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EquipmentPiece</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">EquipmentPiece</span>(  <span class="type">int</span> IDNumber = UNSPECIFIED);</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span>   UNSPECIFIED;        <span class="comment">// ID值不确定。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这允许这样建立EquipmentPiece对象<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EquipmentPiece e;                         <span class="comment">//这样合法</span></span><br></pre></td></tr></table></figure></p>
<p>这样的修改使得其他成员函数变得复杂，因为不再能确保EquipmentPiece对象进行有意义的初始化。</p>
<h1 id="条款5：谨慎定义类型转换函数"><a href="#条款5：谨慎定义类型转换函数" class="headerlink" title="条款5：谨慎定义类型转换函数"></a>条款5：谨慎定义类型转换函数</h1><p>C++编译器能够在两种数据类型之间进行隐式转换（implicit conversions），例如允许把char隐式转换为int，C中许多这种可怕的转换可能会导致数据的丢失。有两种函数允许编译器进行这些的转换：单参数构造函数（single-argument constructors）和隐式类型转换运算符。单参数构造函数是指只用一个参数即可以调用的构造函数。该函数可以是只定义了一个参数，也可以是虽定义了多个参数但第一个参数以后的所有参数都有缺省值。以下有两个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> &#123;                                 <span class="comment">// for names of things</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Name</span>(<span class="type">const</span> string&amp; s);                     <span class="comment">// 转换 string 到 Name</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;                             <span class="comment">// 有理数类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>,                <span class="comment">// 转换int到</span></span><br><span class="line">           <span class="type">int</span> denominator = <span class="number">1</span>);             <span class="comment">// 有理数类</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>隐式类型转换运算符只是一个样子奇怪的成员函数：operator 关键字，其后跟一个类型符号。你不用定义函数的返回类型，因为返回类型就是这个函数的名字。例如为了允许Rational(有理数)类隐式地转换为double类型（在用有理数进行混合类型运算时，可能有用），你可以如此声明Rational类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>;                   <span class="comment">// 转换Rational类成</span></span><br><span class="line">&#125;;                                           <span class="comment">// double类型</span></span><br></pre></td></tr></table></figure></p>
<p>在下面这种情况下，这个函数会被自动调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;                            <span class="comment">// r 的值是1/2</span></span><br><span class="line"><span class="type">double</span> d = <span class="number">0.5</span> * r;                          <span class="comment">// 转换 r 到double,</span></span><br><span class="line">                                             <span class="comment">// 然后做乘法</span></span><br></pre></td></tr></table></figure></p>
<p>当你在不需要使用转换函数时，这些的函数缺却能被调用运行。结果这些不正确的程序会做出一些令人恼火的事情，而你又很难判断出原因。让我们首先分析一下隐式类型转换运算符，它们是最容易处理的。假设你有一个如上所述的Rational类，你想让该类拥有打印有理数对象的功能，就好像它是一个内置类型。因此，你可能会这么写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; r;                                    <span class="comment">// 应该打印出&quot;1/2&quot;</span></span><br></pre></td></tr></table></figure><br>再假设你忘了为Rational对象定义<code>operator&lt;&lt;</code>。你可能想打印操作将失败，因为没有合适的<code>operator&lt;&lt;</code>被调用。但是你错了。当编译器调用<code>operator&lt;&lt;</code>时，会发现没有这样的函数存在，但是它会试图找到一个合适的隐式类型转换顺序以使得函数调用正常运行。类型转换顺序的规则定义是复杂的，但是在这种情况下编译器会发现它们能调用<code>Rational::operator double</code>函数，来把r转换为double类型。所以上述代码打印的结果是一个浮点数，而不是一个有理数。这简直是一个灾难，但是它表明了隐式类型转换的缺点：<strong>它们的存在将导致错误的发生</strong>。</p>
<p>解决方法是用等同的函数来替代转换运算符，而不用语法关键字。例如为了把Rational对象转换为double，用asDouble函数代替operator double函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">asDouble</span><span class="params">()</span> <span class="type">const</span></span>;                   <span class="comment">//转变 Rational</span></span><br><span class="line">&#125;;                                           <span class="comment">// 成double</span></span><br></pre></td></tr></table></figure></p>
<p>这个成员函数能被显式调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; r;                             <span class="comment">// 错误! Rationa对象没有</span></span><br><span class="line">                                       <span class="comment">// operator&lt;&lt;</span></span><br><span class="line">cout &lt;&lt; r.<span class="built_in">asDouble</span>();                  <span class="comment">// 正确, 用double类型                                //打印r</span></span><br></pre></td></tr></table></figure></p>
<p>在多数情况下，这种显式转换函数的使用虽然不方便，但是函数被悄悄调用的情况不再会发生，这点损失是值得的。</p>
<p>通过单参数构造函数进行隐式类型转换更难消除。而且在很多情况下这些函数所导致的问题要甚于隐式类型转换运算符。举一个例子，一个array类模板，这些数组需要调用者确定边界的上限与下限：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Array</span>(<span class="type">int</span> lowBound, <span class="type">int</span> highBound);</span><br><span class="line">  <span class="built_in">Array</span>(<span class="type">int</span> size);</span><br><span class="line">  T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>第一个构造函数允许调用者确定数组索引的范围，例如从10到20。它是一个两参数构造函数，所以不能做为类型转换函数。第二个构造函数让调用者仅仅定义数组元素的个数（使用方法与内置数组的使用相似），不过不同的是它能做为类型转换函数使用，能导致无穷的痛苦。例如比较<code>Array&lt;int&gt;</code>对象，部分代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==( <span class="type">const</span> Array&lt;<span class="type">int</span>&gt;&amp; lhs,</span><br><span class="line">                 <span class="type">const</span> Array&lt;<span class="type">int</span>&gt;&amp; rhs);</span><br><span class="line"><span class="function">Array&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Array&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">  <span class="keyword">if</span> (a == b[i]) &#123;               <span class="comment">// 哎呦! &quot;a&quot; 应该是 &quot;a[i]&quot;</span></span><br><span class="line">    <span class="keyword">do</span> something <span class="keyword">for</span> when</span><br><span class="line">    a[i] <span class="keyword">and</span> b[i] are equal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> something <span class="keyword">for</span> when <span class="keyword">not</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们想用a的每个元素与b的每个元素相比较，但是当录入a时，我们偶然忘记了数组下标。当然我们希望编译器能报出各种各样的警告信息，但是它根本没有。因为它把这个调用看成用<code>Array&lt;int&gt;</code>参数(对于a)和int (对于b[i])参数调用<code>operator==</code>函数 ，然而没有<code>operator==</code>函数是这些的参数类型，我们的编译器注意到它能通过调用<code>Array&lt;int&gt;</code>构造函数能转换int类型到<code>Array&lt;int&gt;</code>类型，这个构造函数只有一个int 类型的参数。然后编译器如此去编译，生成的代码就象这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="keyword">static_cast</span>&lt; Array&lt;<span class="type">int</span>&gt; &gt;(b[i]))   ...</span><br></pre></td></tr></table></figure><br>每一次循环都把a的内容与一个大小为b[i]的临时数组（内容是未定义的）比较 。这不仅不可能以正确的方法运行，而且还是效率低下的。因为每一次循环我们都必须建立和释放<code>Array&lt;int&gt;</code>对象。</p>
<p>通过不声明运算符（operator）的方法,可以克服隐式类型转换运算符的缺点，但是单参数构造函数没有那么简单。毕竟，你确实想给调用者提供一个单参数构造函数。同时你也希望防止编译器不加鉴别地调用这个构造函数。幸运的是，有一个方法可以让你鱼肉与熊掌兼得。事实上是两个方法：一是容易的方法，二是当你的编译器不支持容易的方法时所必须使用的方法。</p>
<p>容易的方法是利用一个最新编译器的特性，explicit关键字。为了解决隐式类型转换而特别引入的这个特性，它的使用方法很好理解。构造函数用explicit声明，如果这样做，编译器会拒绝为了隐式类型转换而调用构造函数。显式类型转换依然合法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Array</span><span class="params">(<span class="type">int</span> size)</span></span>;           <span class="comment">// 注意使用&quot;explicit&quot;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Array&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;                    <span class="comment">// 正确, explicit 构造函数</span></span><br><span class="line">                                     <span class="comment">// 在建立对象时能正常使用</span></span><br><span class="line">                                           </span><br><span class="line"><span class="function">Array&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;                    <span class="comment">// 也正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == b[i]) ...                   <span class="comment">// 错误! 没有办法</span></span><br><span class="line">                                     <span class="comment">// 隐式转换</span></span><br><span class="line">                                     <span class="comment">// int 到 Array&lt;int&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (a == <span class="built_in">Array</span>&lt;<span class="type">int</span>&gt;(b[i])) ...        <span class="comment">// 正确,显式从int到</span></span><br><span class="line">                                      <span class="comment">// Array&lt;int&gt;转换</span></span><br><span class="line">                                      <span class="comment">// （但是代码的逻辑</span></span><br><span class="line">                                      <span class="comment">// 不合理）</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (a == <span class="keyword">static_cast</span>&lt; Array&lt;<span class="type">int</span>&gt; &gt;(b[i])) ...</span><br><span class="line">                                      <span class="comment">// 同样正确，同样</span></span><br><span class="line">                                      <span class="comment">// 不合理</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (a == (Array&lt;<span class="type">int</span>&gt;)b[i]) ...         <span class="comment">//C风格的转换也正确，</span></span><br><span class="line">                                      <span class="comment">// 但是逻辑</span></span><br><span class="line">                                      <span class="comment">// 依旧不合理</span></span><br></pre></td></tr></table></figure></p>
<p>在例子里使用了static_cast（参见条款2），两个“&gt;”字符间的空格不能漏掉，如果这样写语句：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (a == static_cast&lt;Array&lt;int&gt;&gt;(b[i])) ...</span><br></pre></td></tr></table></figure></p>
<p>这是一个不同的含义的语句。因为C++编译器把”&gt;&gt;”做为一个符号来解释。在两个”&gt;”间没有空格，语句会产生语法错误。如果你的编译器不支持explicit，你不得不回到不使用成为隐式类型转换函数的单参数构造函数。</p>
<p>我前面说过复杂的规则决定哪一个隐式类型转换是合法的，哪一个是不合法的。这些规则中没有一个转换能够包含用户自定义类型（调用单参数构造函数或隐式类型转换运算符）。你能利用这个规则来正确构造你的类，使得对象能够正常构造，同时去掉你不想要的隐式类型转换。</p>
<p>再来想一下数组模板，你需要用整形变量做为构造函数参数来确定数组大小，但是同时又必须防止从整数类型到临时数组对象的隐式类型转换。你要达到这个目的，先要建立一个新类ArraySize。这个对象只有一个目的就是表示将要建立数组的大小。你必须修改Array的单参数构造函数，用一个ArraySize对象来代替int。代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ArraySize</span> &#123;                    <span class="comment">// 这个类是新的</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ArraySize</span>(<span class="type">int</span> numElements): <span class="built_in">theSize</span>(numElements) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> theSize; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> theSize;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>(<span class="type">int</span> lowBound, <span class="type">int</span> highBound);</span><br><span class="line">  <span class="built_in">Array</span>(ArraySize size);                  <span class="comment">// 注意新的声明</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里把ArraySize嵌套入Array中，为了强调它总是与Array一起使用。你也必须声明ArraySize为公有，为了让任何人都能使用它。想一下，当通过单参数构造函数定义Array对象，会发生什么样的事情：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Array&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure><br>你的编译器要求用int参数调用<code>Array&lt;int&gt;</code>里的构造函数，但是没有这样的构造函数。编译器意识到它能从int参数转换成一个临时ArraySize对象，ArraySize对象只是<code>Array&lt;int&gt;</code>构造函数所需要的，这样编译器进行了转换。函数调用（及其后的对象建立）也就成功了。</p>
<p>事实上你仍旧能够安心地构造Array对象，不过这样做能够使你避免类型转换。考虑一下以下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==( <span class="type">const</span> Array&lt;<span class="type">int</span>&gt;&amp; lhs,</span><br><span class="line">                 <span class="type">const</span> Array&lt;<span class="type">int</span>&gt;&amp; rhs);</span><br><span class="line"><span class="function">Array&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Array&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">  <span class="keyword">if</span> (a == b[i]) ...                 <span class="comment">// 哎呦! &quot;a&quot; 应该是 &quot;a[i]&quot;;</span></span><br><span class="line">                                    <span class="comment">// 现在是一个错误。</span></span><br></pre></td></tr></table></figure><br>为了调用<code>operator==</code>函数，编译器要求<code>Array&lt;int&gt;</code>对象在”==”右侧,但是不存在一个参数为int的单参数构造函数。而且编译器无法把int转换成一个临时ArraySize对象然后通过这个临时对象建立必须的<code>Array&lt;int&gt;</code>对象，因为这将调用两个用户定义（user-defined）的类型转换，一个从int到ArraySize，一个从ArraySize到<code>Array&lt;int&gt;</code>。这种转换顺序被禁止的，所以当试图进行比较时编译器肯定会产生错误。</p>
<p>在你跳到条款33之前，再仔细考虑一下本条款的内容。让编译器进行隐式类型转换所造成的弊端要大于它所带来的好处，所以除非你确实需要，不要定义类型转换函数。</p>
<h1 id="条款6：自增-increment-、自减-decrement-操作符前缀形式与后缀形式的区别"><a href="#条款6：自增-increment-、自减-decrement-操作符前缀形式与后缀形式的区别" class="headerlink" title="条款6：自增(increment)、自减(decrement)操作符前缀形式与后缀形式的区别"></a>条款6：自增(increment)、自减(decrement)操作符前缀形式与后缀形式的区别</h1><p>C++允许重载increment 和 decrement操作符的两种形式。C++规定后缀形式有一个int类型参数，当函数被调用时，编译器传递一个0做为int参数的值给该函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UPInt</span> &#123;                            <span class="comment">// &quot;unlimited precision int&quot;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  UPInt&amp; <span class="keyword">operator</span>++();                   <span class="comment">// ++ 前缀</span></span><br><span class="line">  <span class="type">const</span> UPInt <span class="keyword">operator</span>++(<span class="type">int</span>);           <span class="comment">// ++ 后缀</span></span><br><span class="line"> </span><br><span class="line">  UPInt&amp; <span class="keyword">operator</span>--();                   <span class="comment">// -- 前缀</span></span><br><span class="line">  <span class="type">const</span> UPInt <span class="keyword">operator</span>--(<span class="type">int</span>);           <span class="comment">// -- 后缀</span></span><br><span class="line"> </span><br><span class="line">  UPInt&amp; <span class="keyword">operator</span>+=(<span class="type">int</span>);                <span class="comment">// += 操作符，UPInts</span></span><br><span class="line">                                         <span class="comment">// 与ints 相运算</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">UPInt i;</span><br><span class="line">++i;                                     <span class="comment">// 调用 i.operator++();</span></span><br><span class="line">i++;                                     <span class="comment">// 调用 i.operator++(0);</span></span><br><span class="line">--i;                                     <span class="comment">// 调用 i.operator--();</span></span><br><span class="line">i--;                                     <span class="comment">// 调用 i.operator--(0);</span></span><br></pre></td></tr></table></figure><br>这些操作符前缀与后缀形式返回值类型是不同的。前缀形式返回一个引用，后缀形式返回一个const类型。下面我们将讨论++操作符的前缀与后缀形式，这些说明也同样使用与—操作符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀形式：增加然后取回值</span></span><br><span class="line">UPInt&amp; UPInt::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">  *<span class="keyword">this</span> += <span class="number">1</span>;                             <span class="comment">// 增加</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;                           <span class="comment">// 取回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// postfix form: fetch and increment</span></span><br><span class="line"><span class="type">const</span> UPInt UPInt::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">  UPInt oldValue = *<span class="keyword">this</span>;                 <span class="comment">// 取回值</span></span><br><span class="line">  ++(*<span class="keyword">this</span>);        <span class="comment">// 增加</span></span><br><span class="line">  <span class="keyword">return</span> oldValue;                          <span class="comment">// 返回被取回的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后缀操作符函数没有使用它的参数。它的参数只是用来区分前缀与后缀函数调用。很明显一个后缀increment必须返回一个对象（它返回的是增加前的值），但是为什么是const对象呢？假设不是const对象，下面的代码就是正确的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPInt i;</span><br><span class="line">i++++;                                     <span class="comment">// 两次increment后缀运算</span></span><br></pre></td></tr></table></figure></p>
<p>这组代码与下面的代码相同：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i.<span class="keyword">operator</span>++(<span class="number">0</span>).<span class="keyword">operator</span>++(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>很明显，第一个调用的operator++函数返回的对象调用了第二个operator++函数。</p>
<h1 id="条款7：不要重载overload-amp-amp-or"><a href="#条款7：不要重载overload-amp-amp-or" class="headerlink" title="条款7：不要重载overload &amp;&amp;, ||, or ,."></a>条款7：不要重载overload &amp;&amp;, ||, or ,.</h1><p>C++使用布尔表达式简化求值法(short-circuit evaluation)。这表示一旦确定了布尔表达式的真假值，即使还有部分表达式没有被测试，布尔表达式也停止运算。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> ((p != <span class="number">0</span>) &amp;&amp; (<span class="built_in">strlen</span>(p) &gt; <span class="number">10</span>)) ...</span><br></pre></td></tr></table></figure><br>这里不用担心当p为空时strlen无法正确运行，因为如果p不等于0的测试失败，strlen不会被调用。同样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((index &lt; lowerBound) || (index &gt; upperBound)) ...</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果index小于lowerBound，它不会与upperBound进行比较。</p>
<p>C++允许根据用户定义的类型，来定制&amp;&amp;和||操作符。方法是重载函数operator&amp;&amp; 和operator||。如果你重载了操作符&amp;&amp;，对于编译器来说，等同于下面代码之一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression1.<span class="keyword">operator</span>&amp;&amp;(expression2)) ...</span><br><span class="line">                              <span class="comment">// when operator&amp;&amp; is a</span></span><br><span class="line">                              <span class="comment">// member function</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">operator</span>&amp;&amp;(expression1, expression2)) ...</span><br><span class="line">                              <span class="comment">// when operator&amp;&amp; is a</span></span><br><span class="line">                              <span class="comment">// global function</span></span><br></pre></td></tr></table></figure><br>这好像没有什么不同，但是函数调用法与简短求值法是绝对不同的。首先当函数被调用时，需要运算其所有参数，所以调用函数functions operator&amp;&amp; 和 operator||时，两个参数都需要计算，换言之，没有采用简短计算法。第二是C++语言规范没有定义函数参数的计算顺序，所以没有办法知道表达式1与表达式2哪一个先计算。完全与具有从左参数到右参数计算顺序的简短计算法相反。</p>
<p><strong>因此如果你重载&amp;&amp;或||，就没有办法提供给程序员他们所期望和使用的行为特性，所以不要重载&amp;&amp;和||</strong>。存在一些限制，你不能重载下面的操作符：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.              .*              ::             ?:</span><br><span class="line"></span><br><span class="line">new          delete        sizeof      typeid</span><br><span class="line"></span><br><span class="line">static_cast  dynamic_cast  const_cast  reinterpret_cast</span><br></pre></td></tr></table></figure><br>你能重载：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">operator new        operator delete</span><br><span class="line"></span><br><span class="line">operator   new[]    operator delete[]</span><br><span class="line"></span><br><span class="line">+    -   *   /   %   ^     &amp;   |     ~</span><br><span class="line"></span><br><span class="line">!    =   &lt;   &gt;  +=   -=   *=   /=   %=</span><br><span class="line"></span><br><span class="line">^=  &amp;=  |=  &lt;&lt;  &gt;&gt;   &gt;&gt;=  &lt;&lt;=  ==   !=</span><br><span class="line"></span><br><span class="line">&lt;=  &gt;=  &amp;&amp;  ||  ++   --    ,   -&gt;*  -&gt;</span><br><span class="line"></span><br><span class="line">()  []</span><br></pre></td></tr></table></figure></p>
<h1 id="条款8：理解各种不同含义的new和delete"><a href="#条款8：理解各种不同含义的new和delete" class="headerlink" title="条款8：理解各种不同含义的new和delete"></a>条款8：理解各种不同含义的new和delete</h1><p>当你写这样的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Memory Management&quot;</span>);</span><br></pre></td></tr></table></figure><br>你使用的new是new操作符。它要完成的功能分成两部分。第一部分是<strong>分配足够的内存以便容纳所需类型的对象</strong>。第二部分是<strong>它调用构造函数初始化内存中的对象</strong>。<strong>new操作符为分配内存所调用函数的名字是operator new</strong>。</p>
<p>函数operator new 通常这样声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><br><strong>返回值类型是<code>void*</code></strong>，因为这个函数返回一个未经处理（raw）的指针，未初始化的内存。你一般不会直接调用operator new，但是一旦这么做，你可以象调用其它函数一样调用它：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *rawMemory = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(string));</span><br></pre></td></tr></table></figure><br>操作符operator new将返回一个指针，指向一块足够容纳一个string类型对象的内存。</p>
<p>就象malloc一样，<strong><code>operator new</code>的职责只是分配内存</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Memory Management&quot;</span>);</span><br></pre></td></tr></table></figure><br>它生成的代码或多或少与下面的代码相似：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *memory = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(string));   <span class="comment">// 得到未经处理的内存为String对象</span></span><br><span class="line"></span><br><span class="line"><span class="function">call <span class="title">string::string</span><span class="params">(<span class="string">&quot;Memory Management&quot;</span>)</span>    <span class="comment">//初始化</span></span></span><br><span class="line"><span class="function">on *memory</span>;                                 <span class="comment">// 内存中</span></span><br><span class="line">                                            <span class="comment">// 的对象</span></span><br><span class="line">string *ps =                                <span class="comment">// 是ps指针指向</span></span><br><span class="line">  <span class="built_in">static_cast</span>&lt;string*&gt;(memory);             <span class="comment">// 新的对象</span></span><br></pre></td></tr></table></figure><br>注意第二步包含了构造函数的调用，</p>
<p>有时你确实想直接调用构造函数。有时你有一些已经被分配但是尚未处理的的(raw)内存，你需要在这些内存中构造一个对象。你可以使用一个特殊的<code>operator new</code>，它被称为<code>placement new</code>。</p>
<p>下面的例子是placement new如何使用，考虑一下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> widgetSize);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget * <span class="title">constructWidgetInBuffer</span><span class="params">(<span class="type">void</span> *buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">int</span> widgetSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">new</span> (buffer) <span class="built_in">Widget</span>(widgetSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个函数返回一个指针，指向一个Widget 对象，对象在转递给函数的buffer里分配。当程序使用共享内存或memory-mapped I/O时这个函数可能有用，因为在这样程序里对象必须被放置在一个确定地址上或一块被例程分配的内存里。</p>
<p>在constructWidgetInBuffer里面，返回的表达式是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (buffer) <span class="built_in">Widget</span>(widgetSize)</span><br></pre></td></tr></table></figure><br>这是new操作符的一个用法，需要<strong>使用一个额外的变量（buffer）</strong>，当new操作符隐含调用operator new函数时，把这个变量传递给它。被调用的<code>operator new</code>函数除了待有强制的参数<code>size_t</code>外，还必须接受<code>void*</code>指针参数，指向构造对象占用的内存空间。这个<code>operator new</code>就是<code>placement new</code>，它看上去象这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">void</span> *location)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> location;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>operator new</code>的目的是<strong>为对象分配内存然后返回指向该内存的指针</strong>。placement new必须做的就是返回转递给它的指针。为了使用<code>placement new</code>，你必须使用语句<code>#include &lt;new&gt;</code>。</p>
<ul>
<li>你想在堆上建立一个对象，应该用new操作符。它既分配内存又为对象调用构造函数。</li>
<li>如果你仅仅想分配内存，就应该调用operator new函数；它不会调用构造函数。</li>
<li>如果你想定制自己的在堆对象被建立时的内存分配过程，你应该写你自己的operator new函数，然后使用new操作符，new操作符会调用你定制的operator new。</li>
<li>如果你想在一块已经获得指针的内存里建立一个对象，应该用placement new。</li>
</ul>
<p>为了避免内存泄漏，每个动态内存分配必须与一个等同相反的deallocation对应。函数operator delete与delete操作符的关系与operator new与new操作符的关系一样。当你看到这些代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string *ps;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ps;                          <span class="comment">// 使用delete 操作符</span></span><br></pre></td></tr></table></figure><br>你的编译器会生成代码来析构对象并释放对象占有的内存。<code>operator delete</code>用来释放内存，它被这样声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *memoryToBeDeallocated)</span></span>;</span><br></pre></td></tr></table></figure><br>因此，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete ps;</span><br></pre></td></tr></table></figure><br>导致编译器生成类似于这样的代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps-&gt;~string();                      // call the object&#x27;s dtor</span><br><span class="line">operator delete(ps);                // deallocate the memory</span><br><span class="line">                                    // the object occupied</span><br></pre></td></tr></table></figure><br>这有一个隐含的意思是如果你只想处理未被初始化的内存，你应该绕过new和delete操作符，而调用operator new 获得内存和operator delete释放内存给系统：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *buffer =                      <span class="comment">// 分配足够的</span></span><br><span class="line">  <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="number">50</span>*<span class="built_in">sizeof</span>(<span class="type">char</span>));    <span class="comment">// 内存以容纳50个char</span></span><br><span class="line">                                    <span class="comment">//没有调用构造函数</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>;            <span class="comment">// 释放内存</span></span><br><span class="line">                                    <span class="comment">// 没有调用析构函数</span></span><br></pre></td></tr></table></figure><br>这与在C中调用malloc和free等同。</p>
<p>如果你用placement new在内存中建立对象，你应该避免在该内存中用delete操作符。因为delete操作符调用operator delete来释放内存，但是包含对象的内存最初不是被operator new分配的，placement new只是返回转递给它的指针。谁知道这个指针来自何方？而你应该<strong>显式调用对象的析构函数来解除构造函数的影响</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在共享内存中分配和释放内存的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="title">mallocShared</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">freeShared</span><span class="params">(<span class="type">void</span> *memory)</span></span>;</span><br><span class="line"><span class="type">void</span> *sharedMemory = <span class="built_in">mallocShared</span>(<span class="built_in">sizeof</span>(Widget));</span><br><span class="line">Widget *pw =                                   <span class="comment">// 如上所示,</span></span><br><span class="line">  <span class="built_in">constructWidgetInBuffer</span>(sharedMemory, <span class="number">10</span>);   <span class="comment">// 使用</span></span><br><span class="line">                                               <span class="comment">// placement new</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> pw;            <span class="comment">// 结果不确定! 共享内存来自</span></span><br><span class="line">                      <span class="comment">// mallocShared, 而不是operator new</span></span><br><span class="line">pw-&gt;~<span class="built_in">Widget</span>();        <span class="comment">// 正确。 析构 pw指向的Widget，</span></span><br><span class="line">                      <span class="comment">// 但是没有释放</span></span><br><span class="line">                      <span class="comment">//包含Widget的内存</span></span><br><span class="line"><span class="built_in">freeShared</span>(pw);       <span class="comment">// 正确。 释放pw指向的共享内存</span></span><br><span class="line">                      <span class="comment">// 但是没有调用析构函数</span></span><br></pre></td></tr></table></figure></p>
<p>如上例所示，如果传递给placement new的raw内存是自己动态分配的（通过一些不常用的方法），如果你希望避免内存泄漏，你必须释放它。（参见我的文章Counting objects里面关于placement delete的注释。）</p>
<p>到目前为止一切顺利，但是还得接着走。到目前为止我们所测试的都是一次建立一个对象。怎样分配数组？会发生什么？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string *ps = <span class="keyword">new</span> string[<span class="number">10</span>];          <span class="comment">// allocate an array of objects</span></span><br></pre></td></tr></table></figure><br>被使用的new仍然是new操作符，但是建立数组时new操作符的行为与单个对象建立有少许不同。第一是内存不再用operator new分配，代替以等同的数组分配函数，叫做<code>operator new[]</code>（经常被称为array new）。它与operator new一样能被重载。这就允许你控制数组的内存分配，就象你能控制单个对象内存分配一样。</p>
<p>第二个不同是new操作符调用构造函数的数量。对于数组，在数组里的每一个对象的构造函数都必须被调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string *ps =               <span class="comment">// 调用operator new[]为10个</span></span><br><span class="line">  <span class="keyword">new</span> string[<span class="number">10</span>];          <span class="comment">// string对象分配内存,</span></span><br><span class="line">                           <span class="comment">// 然后对每个数组元素调用</span></span><br><span class="line">                           <span class="comment">// string对象的缺省构造函数。</span></span><br></pre></td></tr></table></figure><br>同样当delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用operator delete来释放内存。就象你能替换或重载operator delete一样，你也替换或重载operator delete[]。在它们重载的方法上有一些限制。</p>
<p>new和delete操作符是内置的，其行为不受你的控制，凡是它们调用的内存分配和释放函数则可以控制。当你想定制new和delete操作符的行为时，请记住你不能真的做到这一点。你只能改变它们为完成它们的功能所采取的方法，而它们所完成的功能则被语言固定下来，不能改变。</p>
<h1 id="条款9：使用析构函数防止资源泄漏"><a href="#条款9：使用析构函数防止资源泄漏" class="headerlink" title="条款9：使用析构函数防止资源泄漏"></a>条款9：使用析构函数防止资源泄漏</h1><p>我们可以把总被执行的清除代码放入局部对象的析构函数里，这样可以避免重复书写清除代码。因为当函数返回时局部对象总是被释放，无论函数是如何退出的。标准C++库函数包含一个类模板，叫做auto_ptr，每一个auto_ptr类的构造函数里，让一个指针指向一个堆对象（heap object），并且在它的析构函数里删除这个对象。下面所示的是auto_ptr类的一些重要的部分：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">auto_ptr</span>(T *p = <span class="number">0</span>): <span class="built_in">ptr</span>(p) &#123;&#125;        <span class="comment">// 保存ptr，指向对象</span></span><br><span class="line">  ~<span class="built_in">auto_ptr</span>() &#123; <span class="keyword">delete</span> ptr; &#125;          <span class="comment">// 删除ptr指向的对象</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T *ptr;                              <span class="comment">// raw ptr to object</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>auto_ptr类的完整代码是非常有趣的，上述简化的代码实现不能在实际中应用。用auto_ptr对象代替raw指针，你将不再为堆对象不能被删除而担心，即使在抛出异常时，对象也能被及时删除。(因为auto_ptr的析构函数使用的是单对象形式的delete，所以auto_ptr不能用于指向对象数组的指针。如果想让auto_ptr类似于一个数组模板，你必须自己写一个。在这种情况下，用vector代替array可能更好)</p>
<p>隐藏在auto_ptr后的思想是：用一个对象存储需要被自动释放的资源，然后依靠对象的析构函数来释放资源，这种思想不只是可以运用在指针上，还能用在其它资源的分配和释放上。</p>
<h1 id="条款10：在构造函数中防止资源泄漏"><a href="#条款10：在构造函数中防止资源泄漏" class="headerlink" title="条款10：在构造函数中防止资源泄漏"></a>条款10：在构造函数中防止资源泄漏</h1><ul>
<li>C++保证删除null指针是安全的.</li>
<li>面对尚未完全构造好的对象, C++拒绝调用其对应的析构函数.</li>
<li>C++不自动清理那些构造期间抛出异常(exceptions)的对象, 需要在构造函数中捕获可能存在的异常.</li>
<li>最好把共享代码抽出放进一个private的辅助函数内, 然后让析构或构造函数都调用它.</li>
<li>智能指针shared_ptr可以帮助构造函数处理构造过程中出现的异常.</li>
</ul>
<h1 id="条款11：禁止异常信息（exceptions）传递到析构函数外"><a href="#条款11：禁止异常信息（exceptions）传递到析构函数外" class="headerlink" title="条款11：禁止异常信息（exceptions）传递到析构函数外"></a>条款11：禁止异常信息（exceptions）传递到析构函数外</h1><p>在有两种情况下会调用析构函数。第一种是在正常情况下删除一个对象，例如对象超出了作用域或被显式地delete。第二种是异常传递的堆栈辗转开解（stack-unwinding）过程中,由异常处理系统删除一个对象。</p>
<p>在上述两种情况下，调用析构函数时异常可能处于激活状态也可能没有处于激活状态。遗憾的是没有办法在析构函数内部区分出这两种情况。因此在写析构函数时你必须保守地假设有异常被激活，因为如果在一个异常被激活的同时，析构函数也抛出异常，并导致程序控制权转移到析构函数外，C++将调用terminate函数。这个函数的作用正如其名字所表示的：它终止你程序的运行，而且是立即终止，甚至连局部对象都没有被释放。</p>
<p>我们知道禁止异常传递到析构函数外有两个原因，第一能够在异常转递的堆栈辗转开解（stack-unwinding）的过程中，防止terminate被调用。第二它能帮助确保析构函数总能完成我们希望它做的所有事情。</p>
<h1 id="条款12：理解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”间的差异"><a href="#条款12：理解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”间的差异" class="headerlink" title="条款12：理解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”间的差异"></a>条款12：理解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”间的差异</h1><p>从语法上看，在函数里声明参数与在catch子句中声明参数几乎没有什么差别：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;                 <span class="comment">//一个类，具体是什么类</span></span><br><span class="line">                                      <span class="comment">// 在这里并不重要</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(Widget w)</span></span>;                    <span class="comment">// 一些函数，其参数分别为</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(Widget&amp; w)</span></span>;                   <span class="comment">// Widget, Widget&amp;,或</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;             <span class="comment">// Widget* 类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">(Widget *pw)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f5</span><span class="params">(<span class="type">const</span> Widget *pw)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">catch</span> (Widget w) ...                  <span class="comment">//一些catch 子句，用来</span></span><br><span class="line"><span class="built_in">catch</span> (Widget&amp; w)   ...               <span class="comment">//捕获异常，异常的类型为</span></span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> Widget&amp; w) ...           <span class="comment">// Widget, Widget&amp;, 或</span></span><br><span class="line"><span class="built_in">catch</span> (Widget *pw) ...                <span class="comment">// Widget*</span></span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> Widget *pw) ...</span><br></pre></td></tr></table></figure><br>传递函数参数与异常的途径可以是传值、传递引用或传递指针，这是相同的。但是当你传递参数和异常时，系统所要完成的操作过程则是完全不同的。产生这个差异的原因是：你调用函数时，程序的控制权最终还会返回到函数的调用处，但是当你抛出一个异常时，控制权永远不会回到抛出异常的地方。</p>
<p>有这样一个函数，参数类型是Widget，并抛出一个Widget类型的异常：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个函数，从流中读值到Widget中</span></span><br><span class="line">istream <span class="keyword">operator</span>&gt;&gt;(istream&amp; s, Widget&amp; w);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">passAndThrowWidget</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Widget localWidget;</span><br><span class="line">  cin &gt;&gt; localWidget;          <span class="comment">//传递localWidget到 operator&gt;&gt;</span></span><br><span class="line">  <span class="keyword">throw</span> localWidget;           <span class="comment">// 抛出localWidget异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当传递localWidget到函数operator&gt;&gt;里，不用进行拷贝操作，而是把operator&gt;&gt;内的引用类型变量w指向localWidget，任何对w的操作实际上都施加到localWidget上。这与抛出localWidget异常有很大不同。不论通过传值捕获异常还是通过引用捕获（不能通过指针捕获这个异常，因为类型不匹配）都将进行lcalWidget的拷贝操作，也就说传递到catch子句中的是localWidget的拷贝。必须这么做，因为当localWidget离开了生存空间后，其析构函数将被调用。如果把localWidget本身（而不是它的拷贝）传递给catch子句，这个子句接收到的只是一个被析构了的Widget，一个Widget的“尸体”。这是无法使用的。因此C++规范要求被做为异常抛出的对象必须被复制。</p>
<p>即使被抛出的对象不会被释放，也会进行拷贝操作。例如如果passAndThrowWidget函数声明localWidget为静态变量（static），<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">passAndThrowWidget</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> Widget localWidget;        <span class="comment">// 现在是静态变量（static）;</span></span><br><span class="line">                                    <span class="comment">//一直存在至程序结束</span></span><br><span class="line">  cin &gt;&gt; localWidget;               <span class="comment">// 象以前那样运行</span></span><br><span class="line">  <span class="keyword">throw</span> localWidget;                <span class="comment">// 仍将对localWidget</span></span><br><span class="line">&#125;                                   <span class="comment">//进行拷贝操作</span></span><br></pre></td></tr></table></figure><br>当抛出异常时仍将复制出localWidget的一个拷贝。这表示即使通过引用来捕获异常，也不能在catch块中修改localWidget；仅仅能修改localWidget的拷贝。对异常对象进行强制复制拷贝，这个限制有助于我们理解参数传递与抛出异常的第二个差异：抛出异常运行速度比参数传递要慢。</p>
<p>当异常对象被拷贝时，拷贝操作是由对象的拷贝构造函数完成的。该拷贝构造函数是对象的静态类型（static type）所对应类的拷贝构造函数，而不是对象的动态类型（dynamic type）对应类的拷贝构造函数。比如以下这经过少许修改的passAndThrowWidget：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWidget</span>: <span class="keyword">public</span> Widget &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">passAndThrowWidget</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  SpecialWidget localSpecialWidget;</span><br><span class="line">  ...</span><br><span class="line">  Widget&amp; rw = localSpecialWidget;      <span class="comment">// rw 引用SpecialWidget</span></span><br><span class="line">  <span class="keyword">throw</span> rw;                             <span class="comment">//它抛出一个类型为Widget</span></span><br><span class="line">                                        <span class="comment">// 的异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里抛出的异常对象是Widget，即使rw引用的是一个SpecialWidget。因为rw的静态类型（static type）是Widget，而不是SpecialWidget。你的编译器根本没有主要到rw引用的是一个SpecialWidget。编译器所注意的是rw的静态类型（static type）。这种行为可能与你所期待的不一样，但是这与在其他情况下C++中拷贝构造函数的行为是一致的。</p>
<p>异常是其它对象的拷贝，这个事实影响到你如何在catch块中再抛出一个异常。比如下面这两个catch块，乍一看好像一样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span> (Widget&amp; w)                 <span class="comment">// 捕获Widget异常</span></span><br><span class="line">&#123;</span><br><span class="line">  ...                             <span class="comment">// 处理异常</span></span><br><span class="line">  <span class="keyword">throw</span>;                          <span class="comment">// 重新抛出异常，让它</span></span><br><span class="line">&#125;                                 <span class="comment">// 继续传递</span></span><br><span class="line"><span class="built_in">catch</span> (Widget&amp; w)                 <span class="comment">// 捕获Widget异常</span></span><br><span class="line">&#123;</span><br><span class="line">  ...                             <span class="comment">// 处理异常</span></span><br><span class="line">  <span class="keyword">throw</span> w;                        <span class="comment">// 传递被捕获异常的</span></span><br><span class="line">&#125;                                 <span class="comment">// 拷贝</span></span><br></pre></td></tr></table></figure><br>这两个catch块的差别在于第一个catch块中重新抛出的是当前捕获的异常，而第二个catch块中重新抛出的是当前捕获异常的一个新的拷贝。如果忽略生成额外拷贝的系统开销，这两种方法还有差异么？</p>
<p>当然有。第一个块中重新抛出的是当前异常（current exception）,无论它是什么类型。特别是如果这个异常开始就是做为SpecialWidget类型抛出的，那么第一个块中传递出去的还是SpecialWidget异常，即使w的静态类型（static type）是Widget。这是因为重新抛出异常时没有进行拷贝操作。第二个catch块重新抛出的是新异常，类型总是Widget，因为w的静态类型（static type）是Widget。一般来说，你应该用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span></span><br></pre></td></tr></table></figure><br>来重新抛出当前的异常，因为这样不会改变被传递出去的异常类型，而且更有效率，因为不用生成一个新拷贝。</p>
<p>让我们测试一下下面这三种用来捕获Widget异常的catch子句，异常是做为passAndThrowWidgetp抛出的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span> (Widget w) ...                <span class="comment">// 通过传值捕获异常</span></span><br><span class="line"><span class="built_in">catch</span> (Widget&amp; w) ...               <span class="comment">// 通过传递引用捕获</span></span><br><span class="line">                                    <span class="comment">// 异常</span></span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> Widget&amp; w) ...         <span class="comment">//通过传递指向const的引用</span></span><br><span class="line">                                    <span class="comment">//捕获异常</span></span><br></pre></td></tr></table></figure><br>我们立刻注意到了传递参数与传递异常的另一个差异。一个被异常抛出的对象（刚才解释过，总是一个临时对象）可以通过普通的引用捕获；它不需要通过指向const对象的引用（reference-to-const）捕获。在函数调用中不允许转递一个临时对象到一个非const引用类型的参数里，但是在异常中却被允许。</p>
<p>让我们先不管这个差异，回到异常对象拷贝的测试上来。我们知道当用传值的方式传递函数的参数，我们制造了被传递对象的一个拷贝，并把这个拷贝存储到函数的参数里。同样我们通过传值的方式传递一个异常时，也是这么做的。当我们这样声明一个catch子句时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span> (Widget w) ...                <span class="comment">// 通过传值捕获</span></span><br></pre></td></tr></table></figure><br>会建立两个被抛出对象的拷贝，一个是所有异常都必须建立的临时对象，第二个是把临时对象拷贝进w中。同样，当我们通过引用捕获异常时，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span> (Widget&amp; w) ...               <span class="comment">// 通过引用捕获</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> Widget&amp; w) ...         <span class="comment">//也通过引用捕获</span></span><br></pre></td></tr></table></figure><br>这仍旧会建立一个被抛出对象的拷贝：拷贝是一个临时对象。相反当我们通过引用传递函数参数时，没有进行对象拷贝。当抛出一个异常时，系统构造的（以后会析构掉）被抛出对象的拷贝数比以相同对象做为参数传递给函数时构造的拷贝数要多一个。</p>
<p>我们还没有讨论通过指针抛出异常的情况，不过通过指针抛出异常与通过指针传递参数是相同的。不论哪种方法都是一个指针的拷贝被传递。你不能认为抛出的指针是一个指向局部对象的指针，因为当异常离开局部变量的生存空间时，该局部变量已经被释放。Catch子句将获得一个指向已经不存在的对象的指针。这种行为在设计时应该予以避免。</p>
<p>对象从函数的调用处传递到函数参数里与从异常抛出点传递到catch子句里所采用的方法不同，这只是参数传递与异常传递的区别的一个方面，第二个差异是在函数调用者或抛出异常者与被调用者或异常捕获者之间的类型匹配的过程不同。比如在标准数学库（the standard math library）中sqrt函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">sqrt</span><span class="params">(<span class="type">double</span>)</span></span>;                 <span class="comment">// from &lt;cmath&gt; or &lt;math.h&gt;</span></span><br></pre></td></tr></table></figure><br>我们能这样计算一个整数的平方根，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line"><span class="type">double</span> sqrtOfi = <span class="built_in">sqrt</span>(i);</span><br></pre></td></tr></table></figure><br>毫无疑问，C++允许进行从int到double的隐式类型转换，所以在sqrt的调用中，i 被悄悄地转变为double类型，并且其返回值也是double。一般来说，catch子句匹配异常类型时不会进行这样的转换。见下面的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">someFunction</span>()) &#123;      <span class="comment">// 如果 someFunction()返回</span></span><br><span class="line">      <span class="keyword">throw</span> value;             <span class="comment">//真，抛出一个整形值</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> (<span class="type">double</span> d) &#123;           <span class="comment">// 只处理double类型的异常</span></span><br><span class="line">    ...  </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在try块中抛出的int异常不会被处理double异常的catch子句捕获。该子句只能捕获真真正正为double类型的异常；不进行类型转换。因此如果要想捕获int异常，必须使用带有int或int&amp;参数的catch子句。</p>
<p>不过在catch子句中进行异常匹配时可以进行两种类型转换。第一种是继承类与基类间的转换。一个用来捕获基类的catch子句也可以处理派生类类型的异常。</p>
<p>捕获runtime_errors异常的Catch子句可以捕获range_error类型和overflow_error类型的异常，可以接收根类exception异常的catch子句能捕获其任意派生类异常。这种派生类与基类（inheritance_based）间的异常类型转换可以作用于数值、引用以及指针上：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span> (runtime_error) ...               <span class="comment">// can catch errors of type</span></span><br><span class="line"><span class="built_in">catch</span> (runtime_error&amp;) ...              <span class="comment">// runtime_error,</span></span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> runtime_error&amp;) ...        <span class="comment">// range_error, or</span></span><br><span class="line">                                        <span class="comment">// overflow_error</span></span><br><span class="line"><span class="built_in">catch</span> (runtime_error*) ...              <span class="comment">// can catch errors of type</span></span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> runtime_error*) ...        <span class="comment">// runtime_error*,</span></span><br><span class="line">                                        <span class="comment">// range_error*, or</span></span><br><span class="line">                                        <span class="comment">// overflow_error*</span></span><br></pre></td></tr></table></figure><br>第二种是允许从一个类型化指针（typed pointer）转变成无类型指针（untyped pointer），所以带有<code>const void*</code>指针的catch子句能捕获任何类型的指针类型异常：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> <span class="type">void</span>*) ...                 <span class="comment">//捕获任何指针类型异常</span></span><br></pre></td></tr></table></figure></p>
<p>传递参数和传递异常间最后一点差别是catch子句匹配顺序总是取决于它们在程序中出现的顺序。因此一个派生类异常可能被处理其基类异常的catch子句捕获，即使同时存在有能处理该派生类异常的catch子句，与相同的try块相对应。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (logic_error&amp; ex) &#123;              <span class="comment">// 这个catch块 将捕获</span></span><br><span class="line">  ...                                  <span class="comment">// 所有的logic_error</span></span><br><span class="line">&#125;                                      <span class="comment">// 异常, 包括它的派生类</span></span><br><span class="line"><span class="built_in">catch</span> (invalid_argument&amp; ex) &#123;         <span class="comment">// 这个块永远不会被执行</span></span><br><span class="line">  ...                                  <span class="comment">//因为所有的</span></span><br><span class="line">&#125;                                      <span class="comment">// invalid_argument</span></span><br><span class="line">                                       <span class="comment">// 异常 都被上面的</span></span><br><span class="line">                                       <span class="comment">// catch子句捕获。</span></span><br></pre></td></tr></table></figure><br>与上面这种行为相反，当你调用一个虚拟函数时，被调用的函数位于与发出函数调用的对象的动态类型（dynamic type）最相近的类里。你可以这样说虚拟函数采用最优适合法，而异常处理采用的是最先适合法。如果一个处理派生类异常的catch子句位于处理基类异常的catch子句前面，编译器会发出警告。（因为这样的代码在C++里通常是不合法的。）不过你最好做好预先防范：不要把处理基类异常的catch子句放在处理派生类异常的catch子句的前面。象上面那个例子，应该这样去写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (invalid_argument&amp; ex) &#123;          <span class="comment">// 处理 invalid_argument</span></span><br><span class="line">  ...                                   <span class="comment">//异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (logic_error&amp; ex) &#123;               <span class="comment">// 处理所有其它的</span></span><br><span class="line">  ...                                   <span class="comment">// logic_errors异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>综上所述，把一个对象传递给函数或一个对象调用虚拟函数与把一个对象做为异常抛出，这之间有三个主要区别。</p>
<ul>
<li>异常对象在传递时总被进行拷贝；当通过传值方式捕获时，异常对象被拷贝了两次。对象做为参数传递给函数时不需要被拷贝。</li>
<li>对象做为异常被抛出与做为参数传递给函数相比，前者类型转换比后者要少（前者只有两种转换形式）。</li>
<li>catch子句进行异常类型匹配的顺序是它们在源代码中出现的顺序，第一个类型匹配成功的catch将被用来执行。当一个对象调用一个虚拟函数时，被选择的函数位于与对象类型匹配最佳的类里，即使该类不是在源代码的最前头。</li>
</ul>
<h1 id="条款13：通过引用（reference）捕获异常"><a href="#条款13：通过引用（reference）捕获异常" class="headerlink" title="条款13：通过引用（reference）捕获异常"></a>条款13：通过引用（reference）捕获异常</h1><p>当你写一个catch子句时，必须确定让异常通过何种方式传递到catch子句里。你可以有三个选择：与你给函数传递参数一样，通过指针（by pointer），通过传值（by value）或通过引用（by reference）。</p>
<p>从throw处传递一个异常到catch子句是一个缓慢的过程，在理论上通过指针方式捕获异常的实现对于这个过程来说是效率最高的。因为在传递异常信息时，只有采用通过指针抛出异常的方法才能够做到不拷贝对象，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">exception</span> &#123; ... &#125;;          <span class="comment">// 来自标准C++库（STL）</span></span><br><span class="line">                                  <span class="comment">// 中的异常类层次</span></span><br><span class="line">                                  <span class="comment">// （参见条款12）</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> exception ex;            <span class="comment">// 异常对象</span></span><br><span class="line">  <span class="keyword">throw</span> &amp;ex;                      <span class="comment">// 抛出一个指针，指向ex</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">someFunction</span>();               <span class="comment">// 抛出一个 exception*</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> (exception *ex) &#123;         <span class="comment">// 捕获 exception*;</span></span><br><span class="line">    ...                           <span class="comment">// 没有对象被拷贝</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这看上去很不错，但是实际情况却不是这样。为了能让程序正常运行，程序员定义异常对象时必须确保当程序控制权离开抛出指针的函数后，对象还能够继续生存。全局与静态对象都能够做到这一点，但是程序员很容易忘记这个约束。如果真是如此的话，他们会这样写代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  exception ex;                   <span class="comment">// 局部异常对象;</span></span><br><span class="line">                                  <span class="comment">// 当退出函数的生存空间时</span></span><br><span class="line">                                  <span class="comment">// 这个对象将被释放。</span></span><br><span class="line">  ...    </span><br><span class="line">  <span class="keyword">throw</span> &amp;ex;                      <span class="comment">// 抛出一个指针，指向</span></span><br><span class="line">  ...                             <span class="comment">// 已被释放的对象</span></span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure><br>这简直糟糕透了，因为处理这个异常的catch子句接受到的指针，其指向的对象已经不再存在。</p>
<p>另一种抛出指针的方法是在建立一个堆对象（new heap object）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> exception;            <span class="comment">// 抛出一个指针，指向一个在堆中</span></span><br><span class="line">  ...                             <span class="comment">// 建立的对象(希望</span></span><br><span class="line">&#125;                                 <span class="comment">// 操作符new — 参见条款8—</span></span><br><span class="line">                                  <span class="comment">// 自己不要再抛出一个</span></span><br><span class="line">                                  <span class="comment">// 异常!)</span></span><br></pre></td></tr></table></figure><br>通过指针捕获异常也不符合C+ +语言本身的规范。四个标准的异常――bad_alloc(当operator new不能分配足够的内存时，被抛出)，bad_cast（当dynamic_cast针对一个引用（reference）操作失败时，被抛出）,bad_typeid（当dynamic_cast对空指针进行操作时，被抛出）和bad_exception（用于unexpected异常；参见条款14）――都不是指向对象的指针，所以你必须通过值或引用来捕获它们。</p>
<p>通过值捕获异常（catch -by-value）可以解决上述的问题，例如异常对象删除的问题和使用标准异常类型的问题。但是当它们被抛出时系统将对异常对象拷贝两次（参见条款 12）。而且它会产生slicing problem，即派生类的异常对象被做为基类异常对象捕获时，那它的派生类行为就被切掉了（sliced off）。这样的sliced对象实际上是一个基类对象：它们没有派生类的数据成员，而且当调用它们的虚拟函数时，系统解析后调用的是基类对象的函数。</p>
<p>最后剩下方法就是通过引用捕获异常（catch-by-reference）。通过引用捕获异常能使你避开上述所有问题。不象通过指针捕获异常，这种方法不会有对象删除的问题而且也能捕获标准异常类型。也不象通过值捕获异常，这种方法没有slicing problem，而且异常对象只被拷贝一次。</p>
<p>如果你通过引用捕获异常（catch by reference），你就能避开上述所有问题，不会为是否删除异常对象而烦恼；能够避开slicing异常对象；能够捕获标准异常类型；减少异常对象需要被拷贝的数目。</p>
<h1 id="条款14：审慎使用异常规格-exception-specifications"><a href="#条款14：审慎使用异常规格-exception-specifications" class="headerlink" title="条款14：审慎使用异常规格(exception specifications)"></a>条款14：审慎使用异常规格(exception specifications)</h1><p>异常规格使得代码更容易理解，因为它明确地描述了一个函数可以抛出什么样的异常。但是它不只是一个有趣的注释。编译器在编译时有时能够检测到异常规格的不一致。而且如果一个函数抛出一个不在异常规格范围里的异常，系统在运行时能够检测出这个错误，然后一个特殊函数unexpected将被自动地调用。函数unexpected 缺省的行为是调用函数terminate，而terminate缺省的行为是调用函数abort，所以一个违反异常规格的程序其缺省的行为就是halt。</p>
<p>一个函数调用了另一个函数，并且后者可能抛出一个违反前者异常规格的异常，例如函数f1没有声明异常规格，这样的函数就可以抛出任意种类的异常：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>;                  <span class="comment">// 可以抛出任意的异常</span></span><br></pre></td></tr></table></figure><br>假设有一个函数f2通过它的异常规格来声明其只能抛出int类型的异常：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><br>f2调用f1是非常合法的，即使f1可能抛出一个违反f2异常规格的异常：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">f1</span>();                  <span class="comment">// 即使f1可能抛出不是int类型的</span></span><br><span class="line">                         <span class="comment">//异常，这也是合法的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当带有异常规格的新代码与没有异常规格的老代码整合在一起工作时，这种灵活性就显得很重要。一种好方法是避免在带有类型参数的模板内使用异常规格。例如下面这种模板，它好像不能抛出任何异常：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a poorly designed template wrt exception specifications</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> T&amp; lhs, <span class="type">const</span> T&amp; rhs) <span class="built_in">throw</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;lhs == &amp;rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个模板为所有类型定义了一个操作符函数operator==。对于任意一对类型相同的对象，如果对象有一样的地址，该函数返回true，否则返回false。</p>
<p>这个模板包含的异常规格表示模板生成的函数不能抛出异常。但是事实可能不会这样，因为opertor&amp;能被一些类型对象重载。如果被重载的话，当调用从operator==函数内部调用opertor&amp;时，opertor&amp;可能会抛出一个异常，这样就违反了我们的异常规格，使得程序控制跳转到unexpected。</p>
<p>能够避免调用unexpected函数的第二个方法是如果<strong>在一个函数内调用其它没有异常规格的函数时应该去除这个函数的异常规格</strong>。这很容易理解，但是实际中容易被忽略。比如允许用户注册一个回调函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个window系统回调函数指针</span></span><br><span class="line"><span class="comment">//当一个window系统事件发生时</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*CallBackPtr)</span><span class="params">(<span class="type">int</span> eventXLocation,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">int</span> eventYLocation,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">void</span> *dataToPassBack)</span></span>;</span><br><span class="line"><span class="comment">//window系统类，含有回调函数指针，</span></span><br><span class="line"><span class="comment">//该回调函数能被window系统客户注册</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallBack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CallBack</span>(CallBackPtr fPtr, <span class="type">void</span> *dataToPassBack)</span><br><span class="line">  : <span class="built_in">func</span>(fPtr), <span class="built_in">data</span>(dataToPassBack) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">makeCallBack</span><span class="params">(<span class="type">int</span> eventXLocation,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">int</span> eventYLocation)</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  CallBackPtr func;               <span class="comment">// function to call when</span></span><br><span class="line">                                  <span class="comment">// callback is made</span></span><br><span class="line">   <span class="type">void</span> *data;                       <span class="comment">// data to pass to callback</span></span><br><span class="line">&#125;;                                <span class="comment">// function</span></span><br><span class="line"><span class="comment">// 为了实现回调函数，我们调用注册函数，</span></span><br><span class="line"><span class="comment">//事件的作标与注册数据做为函数参数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CallBack::makeCallBack</span><span class="params">(<span class="type">int</span> eventXLocation,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">int</span> eventYLocation)</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">func</span>(eventXLocation, eventYLocation, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里在makeCallBack内调用func，要冒违反异常规格的风险，因为无法知道func会抛出什么类型的异常。</p>
<p>通过在程序在CallBackPtr typedef中采用更严格的异常规格来解决问题：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*CallBackPtr)</span><span class="params">(<span class="type">int</span> eventXLocation,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">int</span> eventYLocation,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">void</span> *dataToPassBack)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br>这样定义typedef后，如果注册一个可能会抛出异常的callback函数将是非法的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个没有异常给各的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callBackFcn1</span><span class="params">(<span class="type">int</span> eventXLocation, <span class="type">int</span> eventYLocation,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">void</span> *dataToPassBack)</span></span>;</span><br><span class="line"><span class="type">void</span> *callBackData;</span><br><span class="line">...</span><br><span class="line"><span class="function">CallBack <span class="title">c1</span><span class="params">(callBackFcn1, callBackData)</span></span>;</span><br><span class="line">                               <span class="comment">//错误！callBackFcn1可能</span></span><br><span class="line">                               <span class="comment">// 抛出异常</span></span><br><span class="line"><span class="comment">//带有异常规格的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callBackFcn2</span><span class="params">(<span class="type">int</span> eventXLocation,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> eventYLocation,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">void</span> *dataToPassBack)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">CallBack <span class="title">c2</span><span class="params">(callBackFcn2, callBackData)</span></span>;</span><br><span class="line">                               <span class="comment">// 正确，callBackFcn2</span></span><br><span class="line">                               <span class="comment">// 没有异常规格</span></span><br></pre></td></tr></table></figure><br>传递函数指针时进行这种异常规格的检查，是语言的较新的特性，所以有可能你的编译器不支持这个特性。如果它们不支持，那就依靠你自己来确保不能犯这种错误。</p>
<p>避免调用unexpected的第三个方法是处理系统本身抛出的异常。这些异常中最常见的是bad_alloc，当内存分配失败时它被operator new 和operator new[]抛出。</p>
<p>虽然防止抛出unexpected异常是不现实的，但是C++允许你用其它不同的异常类型替换unexpected异常，你能够利用这个特性。例如你希望所有的unexpected异常都被替换为UnexpectedException对象。你能这样编写代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnexpectedException</span> &#123;&#125;;          <span class="comment">// 所有的unexpected异常对象被</span></span><br><span class="line">                                       <span class="comment">//替换为这种类型对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">convertUnexpected</span><span class="params">()</span>               <span class="comment">// 如果一个unexpected异常被</span></span></span><br><span class="line"><span class="function"></span>&#123;                                      <span class="comment">// 抛出，这个函数被调用</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">UnexpectedException</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过用convertUnexpected函数替换缺省的unexpected函数，来使上述代码开始运行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set_unexpected</span>(convertUnexpected);</span><br></pre></td></tr></table></figure><br>当你这么做了以后，一个unexpected异常将触发调用convertUnexpected函数。Unexpected异常被一种UnexpectedException新异常类型替换。如果被违反的异常规格包含UnexpectedException异常，那么异常传递将继续下去，好像异常规格总是得到满足。</p>
<p>另一种把unexpected异常转变成知名类型的方法是替换unexpected函数，让其重新抛出当前异常，这样异常将被替换为bad_exception。你可以这样编写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">convertUnexpected</span><span class="params">()</span>          <span class="comment">// 如果一个unexpected异常被</span></span></span><br><span class="line"><span class="function"></span>&#123;                                 <span class="comment">//抛出，这个函数被调用</span></span><br><span class="line">  <span class="keyword">throw</span>;                          <span class="comment">// 它只是重新抛出当前</span></span><br><span class="line">&#125;                                 <span class="comment">// 异常</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set_unexpected</span>(convertUnexpected);</span><br><span class="line">                                  <span class="comment">// 安装 convertUnexpected</span></span><br><span class="line">                                  <span class="comment">// 做为unexpected</span></span><br><span class="line">                                  <span class="comment">// 的替代品</span></span><br></pre></td></tr></table></figure><br>如果这么做，你应该在所有的异常规格里包含bad_exception（或它的基类，标准类exception）。你将不必再担心如果遇到unexpected异常会导致程序运行终止。任何不听话的异常都将被替换为bad_exception，这个异常代替原来的异常继续传递。</p>
<p>到现在你应该理解异常规格能导致大量的麻烦。编译器仅仅能部分地检测它们的使用是否一致，在模板中使用它们会有问题，一不注意它们就很容易被违反，并且在缺省的情况下它们被违反时会导致程序终止运行。异常规格还有一个缺点就是它们能导致unexpected被触发即使一个high-level调用者准备处理被抛出的异常，比如下面这个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span> &#123;                  <span class="comment">// for modeling online</span></span><br><span class="line"><span class="keyword">public</span>:                          <span class="comment">// sessions</span></span><br><span class="line">  ~<span class="built_in">Session</span>();</span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">logDestruction</span><span class="params">(Session *objAddr)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Session::~<span class="built_in">Session</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">logDestruction</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> (...) &#123;  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>session的析构函数调用logDestruction记录有关session对象被释放的信息，它明确地要捕获从logDestruction抛出的所有异常。但是logDestruction的异常规格表示其不抛出任何异常。现在假设被logDestruction调用的函数抛出了一个异常，而logDestruction没有捕获。我们不会期望发生这样的事情，凡是正如我们所见，很容易就会写出违反异常规格的代码。当这个异常通过logDestruction传递出来，unexpected将被调用，缺省情况下将导致程序终止执行。这是一个正确的行为，这是session析构函数的作者所希望的行为么？作者想处理所有可能的异常，所以好像不应该不给session析构函数里的catch块执行的机会就终止程序。如果logDestruction没有异常规格，这种事情就不会发生。</p>
<h1 id="条款15：了解异常处理的系统开销"><a href="#条款15：了解异常处理的系统开销" class="headerlink" title="条款15：了解异常处理的系统开销"></a>条款15：了解异常处理的系统开销</h1><p>C++编译器必须支持异常，也就是说，当你不用异常处理时你不能让编译器生产商消除这方面的开销，因为程序一般由多个独立生成的目标文件（object files）组成，只有一个目标文件不进行异常处理并不能代表其他目标文件不进行异常处理。</p>
<p>使用异常处理的第二个开销来自于try 块，无论何时使用它，也就是无论何时你想能够捕获异常，那你都得为此付出代价。不同的编译器实现try块的方法不同，所以编译器与编译器间的开销也不一样。粗略地估计，如果你使用try块，代码的尺寸将增加5%-10%并且运行速度也同比例减慢。</p>
<p>现在我们来到了问题的核心部分，看看抛出异常的开销。事实上我们不用太关心这个问题，因为异常是很少见的，这种事件的发生往往被描述为exceptional （异常的，罕见的）。与一个正常的函数返回相比，通过抛出异常从函数里返回可能会慢三个数量级。</p>
<h1 id="条款16：牢记80－20准则（80－20-rule）"><a href="#条款16：牢记80－20准则（80－20-rule）" class="headerlink" title="条款16：牢记80－20准则（80－20 rule）"></a>条款16：牢记80－20准则（80－20 rule）</h1><p>软件整体的性能取决于代码组成中的一小部分。用profiler程序识别出令人讨厌的程序的20％部分。不是所有的工作都让profiler去做。你想让它去直接地测量你感兴趣的资源。</p>
<p>profiler 告诉你每条语句执行了多少次或各函数被调用了多少次，知道语句执行或函数调用的频繁程度，有时能帮助你洞察软件内部的行为。</p>
<h1 id="条款17：考虑使用lazy-evaluation（懒惰计算法）"><a href="#条款17：考虑使用lazy-evaluation（懒惰计算法）" class="headerlink" title="条款17：考虑使用lazy evaluation（懒惰计算法）"></a>条款17：考虑使用lazy evaluation（懒惰计算法）</h1><p>当你使用了lazy evaluation（<strong>懒惰计算法</strong>）后，采用此种方法的类将<strong>推迟计算工作直到系统需要这些计算的结果</strong>。如果不需要结果，将不用进行计算。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123; ... &#125;;            <span class="comment">// 一个string 类 (the standard</span></span><br><span class="line">                                <span class="comment">// string type may be implemented</span></span><br><span class="line">                                <span class="comment">// as described below, but it</span></span><br><span class="line">                                <span class="comment">// doesn&#x27;t have to be)</span></span><br><span class="line"> </span><br><span class="line">String s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"> </span><br><span class="line">String s2 = s1;                 / 调用string拷贝构造函数</span><br></pre></td></tr></table></figure>
<p>通常string拷贝构造函数让s2被s1初始化后，s1和s2都有自己的”Hello”拷贝。这种拷贝构造函数会引起较大的开销：只因为到string拷贝构造函数，就要制作s1值的拷贝并把它赋给s2。然而这时的s2并不需要这个值的拷贝，因为s2没有被使用。</p>
<p>懒惰能就是少工作。不应该赋给s2一个s1的拷贝，而是让s2与s1共享一个值。我们只须做一些记录以便知道谁在共享什么，就能够省掉调用new和拷贝字符的开销。事实上s1和s2共享一个数据结构，这对于client来说是透明的，对于下面的例子来说，这没有什么差别，因为它们只是读数据：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; s1;                              <span class="comment">// 读s1的值</span></span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; s1 + s2;                         <span class="comment">// 读s1和s2的值</span></span><br></pre></td></tr></table></figure><br>仅仅当这个或那个string的值被修改时，共享同一个值的方法才会造成差异。仅仅修改一个string的值，而不是两个都被修改，这一点是极为重要的。例如这条语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s2.<span class="built_in">convertToUpperCase</span>();</span><br></pre></td></tr></table></figure><br>这是至关紧要的，仅仅修改s2的值，而不是连s1的值一块修改。</p>
<p>为了这样执行语句，string的convertToUpperCase函数应该制作s2值的一个拷贝，在修改前把这个私有的值赋给s2。在convertToUpperCase内部，我们不能再懒惰了：必须为s2（共享的）值制作拷贝以让s2自己使用。另一方面，如果不修改s2，我们就不用制作它自己值的拷贝。</p>
<p>除非确实需要，不去为任何东西制作拷贝。我们应该是懒惰的，只要可能就共享使用其它值。在一些应用领域，你经常可以这么做。</p>
<h2 id="区别对待读取和写入"><a href="#区别对待读取和写入" class="headerlink" title="区别对待读取和写入"></a>区别对待读取和写入</h2><p>来看看使用lazy evaluation的第二种方法。考虑这样的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;Homer&#x27;s Iliad&quot;</span>;            <span class="comment">// 假设是一个</span></span><br><span class="line">                                      <span class="comment">// reference-counted string</span></span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; s[<span class="number">3</span>];                         <span class="comment">// 调用 operator[] 读取s[3]</span></span><br><span class="line">s[<span class="number">3</span>] = <span class="string">&#x27;x&#x27;</span>;                           <span class="comment">// 调用 operator[] 写入 s[3]</span></span><br></pre></td></tr></table></figure><br>读取reference-counted string是很容易的，而写入这个string则需要在写入前对该string值制作一个新拷贝。我们可以推迟做出是读操作还是写操作的决定，直到我们能判断出正确的答案。</p>
<h2 id="Lazy-Fetching（懒惰提取）"><a href="#Lazy-Fetching（懒惰提取）" class="headerlink" title="Lazy Fetching（懒惰提取）"></a>Lazy Fetching（懒惰提取）</h2><p>第三个lazy evaluation的例子，假设你的程序使用了一些包含许多字段的大型对象。这些对象的生存期超越了程序运行期，所以它们必须被存储在数据库里。每一个对都有一个唯一的对象标识符，用来从数据库中重新获得对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LargeObject</span> &#123;                        <span class="comment">// 大型持久对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LargeObject</span>(ObjectID id);                <span class="comment">// 从磁盘中恢复对象</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="type">const</span> string&amp; <span class="title">field1</span><span class="params">()</span> <span class="type">const</span></span>;            <span class="comment">// field 1的值</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">field2</span><span class="params">()</span> <span class="type">const</span></span>;                      <span class="comment">// field 2的值</span></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">field3</span><span class="params">()</span> <span class="type">const</span></span>;                   <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="type">const</span> string&amp; <span class="title">field4</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> string&amp; <span class="title">field5</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>现在考虑一下从磁盘中恢复LargeObject的开销：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">restoreAndProcessObject</span><span class="params">(ObjectID id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">LargeObject <span class="title">object</span><span class="params">(id)</span></span>;                  <span class="comment">// 恢复对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">因为LargeObject对象实例很大，为这样的对象获取所有的数据，数据库的操作的开销将非常大，特别是如果从远程数据库中获取数据和通过网络发送数据时。而在这种情况下，不需要读去所有数据。例如，考虑这样一个程序：</span><br><span class="line">```C++</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">restoreAndProcessObject</span><span class="params">(ObjectID id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">LargeObject <span class="title">object</span><span class="params">(id)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (object.<span class="built_in">field2</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;: null field2./n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里仅仅需要filed2的值，所以为获取其它字段而付出的努力都是浪费。</p>
<p>当LargeObject对象被建立时，不从磁盘上读取所有的数据，这样懒惰法解决了这个问题。不过这时建立的仅是一个对象“壳“，当需要某个数据时，这个数据才被从数据库中取回。这种“demand-paged”对象初始化的实现方法是:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LargeObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LargeObject</span>(ObjectID id);</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="type">const</span> string&amp; <span class="title">field1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">field2</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">field3</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> string&amp; <span class="title">field4</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ObjectID oid;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">mutable</span> string *field1Value;               <span class="comment">//参见下面有关</span></span><br><span class="line">  <span class="keyword">mutable</span> <span class="type">int</span> *field2Value;                  <span class="comment">// &quot;mutable&quot;的讨论</span></span><br><span class="line">  <span class="keyword">mutable</span> <span class="type">double</span> *field3Value;</span><br><span class="line">  <span class="keyword">mutable</span> string *field4Value;</span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LargeObject::<span class="built_in">LargeObject</span>(ObjectID id)</span><br><span class="line">: <span class="built_in">oid</span>(id), <span class="built_in">field1Value</span>(<span class="number">0</span>), <span class="built_in">field2Value</span>(<span class="number">0</span>), <span class="built_in">field3Value</span>(<span class="number">0</span>), ...</span><br><span class="line">&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">const</span> string&amp; <span class="title">LargeObject::field1</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (field1Value == <span class="number">0</span>) &#123;</span><br><span class="line">    从数据库中为filed <span class="number">1</span>读取数据，使</span><br><span class="line">    field1Value 指向这个值;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> *field1Value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对象中每个字段都用一个指向数据的指针来表示，LargeObject构造函数把每个指针初始化为空。这些空指针表示字段还没有从数据库中读取数值。每个LargeObject成员函数在访问字段指针所指向的数据之前必须字段指针检查的状态。如果指针为空，在对数据进行操作之前必须从数据库中读取对应的数据。</p>
<h2 id="Lazy-Expression-Evaluation-懒惰表达式计算"><a href="#Lazy-Expression-Evaluation-懒惰表达式计算" class="headerlink" title="Lazy Expression Evaluation(懒惰表达式计算)"></a>Lazy Expression Evaluation(懒惰表达式计算)</h2><p>有关lazy evaluation的最后一个例子来自于数字程序。考虑这样的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span> &#123; ... &#125;;                         <span class="comment">// for homogeneous matrices</span></span><br><span class="line"> </span><br><span class="line"><span class="function">Matrix&lt;<span class="type">int</span>&gt; <span class="title">m1</span><span class="params">(<span class="number">1000</span>, <span class="number">1000</span>)</span></span>;                   <span class="comment">// 一个 1000 ＊ 1000 的矩阵</span></span><br><span class="line"><span class="function">Matrix&lt;<span class="type">int</span>&gt; <span class="title">m2</span><span class="params">(<span class="number">1000</span>, <span class="number">1000</span>)</span></span>;                   <span class="comment">// 同上</span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">Matrix&lt;<span class="type">int</span>&gt; m3 = m1 + m2;                     <span class="comment">// m1＋m2</span></span><br></pre></td></tr></table></figure><br>通常operator的实现使用eagar evaluation：在这种情况下，它会计算和返回m1与m2的和。这个计算量相当大（1000000次加法运算），当然系统也会分配内存来存储这些值。</p>
<p>lazy evaluation方法说这样做工作太多，所以还是不要去做。而是应该建立一个数据结构来表示m3的值是m1与m2的和，在用一个enum表示它们间是加法操作。很明显，建立这个数据结构比m1与m2相加要快许多，也能够节省大量的内存。</p>
<p>考虑程序后面这部分内容，在使用m3之前，代码执行如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Matrix&lt;<span class="type">int</span>&gt; <span class="title">m4</span><span class="params">(<span class="number">1000</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">...                                           <span class="comment">// 赋给m4一些值</span></span><br><span class="line"> </span><br><span class="line">m3 = m4 * m1;</span><br></pre></td></tr></table></figure><br>现在我们可以忘掉m3是m1与m2的和（因此节省了计算的开销），在这里我们应该记住m3是m4与m1运算的结果。不必说，我们不用进行乘法运算。因为我们是懒惰的。</p>
<p>实际上lazy evaluation就存在于APL语言中。APL是在1960年代发展起来语言，能够进行基于矩阵的交互式的运算。APL使用lazy evaluation 来拖延它们的计算直到确切地知道需要矩阵哪一部分的结果，然后仅仅计算这一部分。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上这四个例子展示了lazy evaluation在各个领域都是有用的：<strong>能避免不需要的对象拷贝通过使用operator[]区分出读操作，避免不需要的数据库读取操作，避免不需要的数字操作</strong>。</p>
<h1 id="条款18：分期摊还期望的计算"><a href="#条款18：分期摊还期望的计算" class="headerlink" title="条款18：分期摊还期望的计算"></a>条款18：分期摊还期望的计算</h1><p>这个条款的核心就是over-eager evaluation（过度热情计算法）：在要求你做某些事情以前就完成它们。例如下面这个模板类，用来表示放有大量数字型数据的一个集合：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NumericalType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataCollection</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">NumericalType <span class="title">min</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">NumericalType <span class="title">max</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">NumericalType <span class="title">avg</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>假设min, max和avg函数分别返回现在这个集合的最小值，最大值和平均值，有三种方法实现这三种函数。使用eager evaluation(热情计算法)，当min,max和avg函数被调用时，我们检测集合内所有的数值，然后返回一个合适的值。使用lazy evaluation（懒惰计算法）,只有确实需要函数的返回值时我们才要求函数返回能用来确定准确数值的数据结构。使用 over-eager evaluation（过度热情计算法），我们随时跟踪目前集合的最小值，最大值和平均值，这样当min,max或avg被调用时，我们可以不用计算就立刻返回正确的数值。如果频繁调用min,max和avg，我们把跟踪集合最小值、最大值和平均值的开销分摊到所有这些函数的调用上，每次函数调用所分摊的开销比eager evaluation或lazy evaluation要小。</p>
<p>隐藏在over-eager evaluation后面的思想是如果你认为一个计算需要频繁进行。你就可以设计一个数据结构高效地处理这些计算需求，这样可以降低每次计算需求的开销。</p>
<p>采用over-eager最简单的方法就是<strong>caching(缓存)那些已经被计算出来而以后还有可能需要的值</strong>。</p>
<p>以下是实现findCubicleNumber的一种方法：它使用了标准模板库（STL）里的map对象。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findCubicleNumber</span><span class="params">(<span class="type">const</span> string&amp; employeeName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 定义静态map，存储 (employee name, cubicle number)</span></span><br><span class="line">  <span class="comment">// pairs. 这个 map 是local cache。</span></span><br><span class="line">  <span class="keyword">typedef</span> map&lt;string, <span class="type">int</span>&gt; CubicleMap;</span><br><span class="line">  <span class="type">static</span> CubicleMap cubes;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// try to find an entry for employeeName in the cache;</span></span><br><span class="line">  <span class="comment">// the STL iterator &quot;it&quot; will then point to the found</span></span><br><span class="line">  <span class="comment">// entry, if there is one (see Item 35 for details)</span></span><br><span class="line">  CubicleMap::iterator it = cubes.<span class="built_in">find</span>(employeeName);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// &quot;it&quot;&#x27;s value will be cubes.end() if no entry was</span></span><br><span class="line">  <span class="comment">// found (this is standard STL behavior). If this is</span></span><br><span class="line">  <span class="comment">// the case, consult the database for the cubicle</span></span><br><span class="line">  <span class="comment">// number, then add it to the cache</span></span><br><span class="line">  <span class="keyword">if</span> (it == cubes.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> cubicle =</span><br><span class="line">      the result of looking up employeeName<span class="number">&#x27;</span>s cubicle</span><br><span class="line">      number in the database;</span><br><span class="line"> </span><br><span class="line">    cubes[employeeName] = cubicle;           <span class="comment">// add the pair</span></span><br><span class="line">                                             <span class="comment">// (employeeName, cubicle)</span></span><br><span class="line">                                             <span class="comment">// to the cache</span></span><br><span class="line">    <span class="keyword">return</span> cubicle;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// &quot;it&quot; points to the correct cache entry, which is a</span></span><br><span class="line">    <span class="comment">// (employee name, cubicle number) pair. We want only</span></span><br><span class="line">    <span class="comment">// the second component of this pair, and the member</span></span><br><span class="line">    <span class="comment">// &quot;second&quot; will give it to us</span></span><br><span class="line">    <span class="built_in">return</span> (*it).second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个方法是使用local cache，用开销相对不大的内存中查询来替代开销较大的数据库查询。假如隔间号被不止一次地频繁需要，在findCubicleNumber内使用cache会减少返回隔间号的平均开销。</p>
<ul>
<li>贯穿本条款的是一个常见的主题，更快的速度经常会消耗更多的内存。跟踪运行时的最小值、最大值和平均值，这需要额外的空间，但是能节省时间。</li>
<li>Cache运算结果需要更多的内存，但是一旦需要被cache的结果时就能减少需要重新生成的时间。</li>
<li>Prefetch需要空间放置被prefetch的东西，但是它减少了访问它们所需的时间。</li>
</ul>
<p>自从有了计算机就有这样的描述：你能以空间换时间。</p>
<p>在本条款中我提出的建议，即通过over-eager方法分摊预期计算的开销，例如caching和prefething，这并不与在条款17中提出的有关lazy evaluation的建议相矛盾。<strong>当你必须支持某些操作而不总需要其结果时</strong>，可以使用lazy evaluation用以提高程序运行效率。当你必须支持某些操作而其结果几乎总是被需要或被不止一次地需要时，可以使用over-eager用以提高程序运行效率。它们对性能的巨大提高证明在这方面花些精力是值得的。</p>
<h1 id="条款19：理解临时对象的来源"><a href="#条款19：理解临时对象的来源" class="headerlink" title="条款19：理解临时对象的来源"></a>条款19：理解临时对象的来源</h1><p>在C++中真正的临时对象是看不见的，它们不出现在你的源代码中。建立一个没有命名的非堆（non-heap）对象会产生临时对象。这种未命名的对象通常在两种条件下产生：<strong>为了使函数成功调用而进行隐式类型转换</strong>和<strong>函数返回对象</strong>时。</p>
<p>首先考虑为使函数成功调用而建立临时对象这种情况。当传送给函数的对象类型与参数类型不匹配时会产生这种情况。例如一个函数，它用来计算一个字符在字符串中出现的次数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回ch在str中出现的次数</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">countChar</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">char</span> ch)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> buffer[MAX_STRING_LEN];</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 读入到一个字符和字符串中，用setw</span></span><br><span class="line"><span class="comment">// 避免缓存溢出，当读取一个字符串时</span></span><br><span class="line">cin &gt;&gt; c &gt;&gt; <span class="built_in">setw</span>(MAX_STRING_LEN) &gt;&gt; buffer;</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;There are &quot;</span> &lt;&lt; <span class="built_in">countChar</span>(buffer, c)</span><br><span class="line">     &lt;&lt; <span class="string">&quot; occurrences of the character &quot;</span> &lt;&lt; c</span><br><span class="line">     &lt;&lt; <span class="string">&quot; in &quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br></pre></td></tr></table></figure><br>看一下countChar的调用。第一个被传送的参数是字符数组，但是对应函数的正被绑定的参数的类型是const string&amp;。仅当消除类型不匹配后，才能成功进行这个调用，你的编译器很乐意替你消除它，方法是建立一个string类型的临时对象。通过以buffer做为参数调用string的构造函数来初始化这个临时对象。countChar的参数str被绑定在这个临时的string对象上。当countChar返回时，临时对象自动释放。</p>
<p>这样的类型转换很方便，但是从效率的观点来看，临时string对象的构造和释放是不必要的开销。通常有两个方法可以消除它。一种是重新设计你的代码，不让发生这种类型转换。另一种方法是通过修改软件而不再需要类型转换。</p>
<p>仅当通过传值（by value）方式传递对象或传递常量引用（reference-to-const）参数时，才会发生这些类型转换。当传递一个非常量引用（reference-to-non-const）参数对象，就不会发生。考虑一下这个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">uppercasify</span><span class="params">(string&amp; str)</span></span>;               <span class="comment">// 把str中所有的字符改变成大写</span></span><br></pre></td></tr></table></figure><br>在字符计数的例子里，能够成功传递char数组到countChar中，但是在这里试图用char数组调用upeercasify函数，则不会成功：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char subtleBookPlug[] = &quot;Effective C++&quot;;</span><br><span class="line"> </span><br><span class="line">uppercasify(subtleBookPlug);                // 错误!</span><br></pre></td></tr></table></figure><br>没有为使调用成功而建立临时对象，为什么呢？</p>
<p>假设建立一个临时对象，那么临时对象将被传递到upeercasify中，其会修改这个临时对象，把它的字符改成大写。但是对subtleBookPlug函数调用的真正参数没有任何影响；仅仅改变了临时从subtleBookPlug生成的string对象。无疑这不是程序员所希望的。程序员传递subtleBookPlug参数到uppercasify函数中，期望修改subtleBookPlug的值。当程序员期望修改非临时对象时，对非常量引用（references-to-non-const）进行的隐式类型转换却修改临时对象。这就是为什么C++语言禁止为非常量引用（reference-to-non-const）产生临时对象。这样非常量引用（reference-to-non-const）参数就不会遇到这种问题。</p>
<p>建立临时对象的第二种环境是函数返回对象时。例如operator+必须返回一个对象，以表示它的两个操作数的和。例如给定一个类型Number，这种类型的operator+被这样声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Number <span class="keyword">operator</span>+(<span class="type">const</span> Number&amp; lhs,</span><br><span class="line">                       <span class="type">const</span> Number&amp; rhs);</span><br></pre></td></tr></table></figure><br>这个函数的返回值是临时的，因为它没有被命名；它只是函数的返回值。你必须为每次调用operator+构造和释放这个对象而付出代价。</p>
<p>综上所述，临时对象是有开销的，所以你应该尽可能地去除它们，然而更重要的是训练自己寻找可能建立临时对象的地方。在任何时候只要见到常量引用（reference-to-const）参数，就存在建立临时对象而绑定在参数上的可能性。在任何时候只要见到函数返回对象，就会有一个临时对象被建立（以后被释放）。</p>
<h1 id="条款20：协助完成返回值优化"><a href="#条款20：协助完成返回值优化" class="headerlink" title="条款20：协助完成返回值优化"></a>条款20：协助完成返回值优化</h1><p>一个返回对象的函数很难有较高的效率，因为传值返回会导致调用对象内的构造和析构函数，这种调用是不能避免的。考虑rational(有理数)类的成员函数operator<em>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>, <span class="type">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">numerator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 有关为什么返回值是const的解释，参见条款6,</span></span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs,</span><br><span class="line">                         <span class="type">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure><br>甚至不用看`operator</em><code>的代码，我们就知道它肯定要返回一个对象，因为它返回的是两个任意数字的计算结果。这些结果是任意的数字。</code>operator*`如何能避免建立新对象来容纳它们的计算结果呢？这是不可能的，所以它必须得建立新对象并返回它。</p>
<p>以某种方法返回对象，能让编译器消除临时对象的开销，这样编写函数通常是很普遍的。这种技巧是返回constructor argument而不是直接返回对象，你可以这样做：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一种高效和正确的方法，用来实现</span></span><br><span class="line"><span class="comment">// 返回对象的函数</span></span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs,</span><br><span class="line">                         <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                  lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>仔细观察被返回的表达式。它看上去好象正在调用Rational的构造函数，实际上确是这样。你通过这个表达式建立一个临时的Rational对象，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">         lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br></pre></td></tr></table></figure><br>并且这是一个临时对象，函数把它拷贝给函数的返回值，这种方法还会给你带来很多开销，因为你仍旧必须为在函数内临时对象的构造和释放而付出代价，你仍旧必须为函数返回对象的构造和释放而付出代价。</p>
<p>C++规则允许编译器优化不出现的临时对象（temporary objects out of existence）。因此如果你在如下的环境里调用<code>operator*</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rational a = <span class="number">10</span>;</span><br><span class="line"><span class="function">Rational <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">Rational c = a * b;                          <span class="comment">// 在这里调用operator*</span></span><br></pre></td></tr></table></figure><br>编译器就会被允许消除在<code>operator*</code>内的临时变量和<code>operator*</code>返回的临时变量。它们能在为目标c分配的内存里构造return 表达式定义的对象。如果你的编译器这样去做，调用<code>operator*</code>的临时对象的开销就是零：没有建立临时对象。</p>
<p>通过使用函数的return location（或者用一个在函数调用位置的对象来替代），来消除局部临时对象――是众所周知的和被普遍实现的。它甚至还有一个名字：<strong>返回值优化</strong>（return value optimization）。</p>
<h1 id="条款21：通过重载避免隐式类型转换"><a href="#条款21：通过重载避免隐式类型转换" class="headerlink" title="条款21：通过重载避免隐式类型转换"></a>条款21：通过重载避免隐式类型转换</h1><p>以下是一段代码，如果没有什么不寻常的原因，实在看不出什么东西：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UPInt</span> &#123;                                 <span class="comment">// unlimited precision</span></span><br><span class="line"><span class="keyword">public</span>:                                       <span class="comment">// integers 类</span></span><br><span class="line">  <span class="built_in">UPInt</span>();</span><br><span class="line">  <span class="built_in">UPInt</span>(<span class="type">int</span> value);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//有关为什么返回值是const的解释，参见Effective C++ 条款21</span></span><br><span class="line"><span class="type">const</span> UPInt <span class="keyword">operator</span>+(<span class="type">const</span> UPInt&amp; lhs, <span class="type">const</span> UPInt&amp; rhs);</span><br><span class="line"></span><br><span class="line">UPInt upi1, upi2;</span><br><span class="line"></span><br><span class="line">UPInt upi3 = upi1 + upi2;</span><br></pre></td></tr></table></figure><br>这里还看不出什么令人惊讶的东西。upi1 和upi2都是UPInt对象，所以它们之间相加就会调用UPInts的operator函数。</p>
<p>现在考虑下面这些语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">upi3 = upi1 + <span class="number">10</span>;</span><br><span class="line">upi3 = <span class="number">10</span> + upi2;</span><br></pre></td></tr></table></figure><br>这些语句也能够成功运行。方法是通过建立临时对象把整形数10转换为UPInts。</p>
<p>如果我们想要把UPInt和int对象相加，通过声明如下几个函数达到这个目的，每一个函数有不同的参数类型集。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> UPInt <span class="keyword">operator</span>+(<span class="type">const</span> UPInt&amp; lhs,      <span class="comment">// add UPInt</span></span><br><span class="line">                      <span class="type">const</span> UPInt&amp; rhs);     <span class="comment">// and UPInt</span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> UPInt <span class="keyword">operator</span>+(<span class="type">const</span> UPInt&amp; lhs,      <span class="comment">// add UPInt</span></span><br><span class="line">                      <span class="type">int</span> rhs);              <span class="comment">// and int</span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> UPInt <span class="keyword">operator</span>+(<span class="type">int</span> lhs,               <span class="comment">// add int and</span></span><br><span class="line">                      <span class="type">const</span> UPInt&amp; rhs);     <span class="comment">// UPInt</span></span><br><span class="line"> </span><br><span class="line">UPInt upi1, upi2;</span><br><span class="line">UPInt upi3 = upi1 + upi2;                  <span class="comment">// 正确,没有由upi1 或 upi2</span></span><br><span class="line">                                           <span class="comment">// 生成的临时对象</span></span><br><span class="line">upi3 = upi1 + <span class="number">10</span>;                          <span class="comment">// 正确, 没有由upi1 or 10</span></span><br><span class="line">                                           <span class="comment">// 生成的临时对象</span></span><br><span class="line">upi3 = <span class="number">10</span> + upi2;                          <span class="comment">//正确, 没有由10 or upi2</span></span><br><span class="line">                                           <span class="comment">//生成的临时对象。</span></span><br></pre></td></tr></table></figure><br>一旦你开始用函数重载来消除类型转换，你就有可能这样声明函数，把自己陷入危险之中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> UPInt <span class="keyword">operator</span>+(<span class="type">int</span> lhs, <span class="type">int</span> rhs);           <span class="comment">// 错误!</span></span><br></pre></td></tr></table></figure><br><strong>在C+ +中有一条规则是每一个重载的operator必须带有一个用户定义类型（user-defined type）的参数</strong>。int不是用户定义类型，所以我们不能重载operator成为仅带有此类型参数的函数。</p>
<h1 id="条款22：考虑用运算符的赋值形式（op-）取代其单独形式（op）"><a href="#条款22：考虑用运算符的赋值形式（op-）取代其单独形式（op）" class="headerlink" title="条款22：考虑用运算符的赋值形式（op=）取代其单独形式（op）"></a>条款22：考虑用运算符的赋值形式（op=）取代其单独形式（op）</h1><p>大多数程序员认为如果他们能这样写代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x + y;                    x = x - y;</span><br></pre></td></tr></table></figure><br>那他们也能这样写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x += y;                       x -= y;</span><br></pre></td></tr></table></figure><br>如果x和y是用户定义的类型（user-defined type），就不能确保这样。就C++来说，operator+、operator=和operator+=之间没有任何关系。</p>
<p>确保operator的赋值形式（assignment version）（例如operator+=）与一个operator的单独形式（stand-alone）(例如 operator+ )之间存在正常的关系，一种好方法是后者（指operator+）根据前者（指operator+=）来实现。这很容易：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  Rational&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Rational&amp; rhs);</span><br><span class="line">  Rational&amp; <span class="keyword">operator</span>-=(<span class="type">const</span> Rational&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// operator+ 根据operator+=实现;</span></span><br><span class="line"><span class="comment">//有关为什么返回值是const的解释，</span></span><br><span class="line"><span class="comment">//参见Effective C++条款21 和 109页 的有关实现的警告</span></span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>+(<span class="type">const</span> Rational&amp; lhs,</span><br><span class="line">                         <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs) += rhs;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// operator- 根据 operator -= 来实现</span></span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>-(<span class="type">const</span> Rational&amp; lhs,</span><br><span class="line">                         <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs) -= rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这个例子里，从零开始实现operator+=和-=，而operator+ 和operator- 则是通过调用前述的函数来提供自己的功能。使用这种设计方法，只用维护operator的赋值形式就行了。而且如果假设operator赋值形式在类的public接口里，这就不用让operator的单独形式成为类的友元。</p>
<p>如果你不介意把所有的operator的单独形式放在全局域里，那就可以使用模板来替代单独形式的函数的编写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">const</span> T <span class="keyword">operator</span>+(<span class="type">const</span> T&amp; lhs, <span class="type">const</span> T&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">T</span>(lhs) += rhs;                     <span class="comment">// 参见下面的讨论</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">const</span> T <span class="keyword">operator</span>-(<span class="type">const</span> T&amp; lhs, <span class="type">const</span> T&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">T</span>(lhs) -= rhs;                      <span class="comment">// 参见下面的讨论</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用这些模板，只要为operator赋值形式定义某种类型，一旦需要，其对应的operator单独形式就会被自动生成。</p>
<p>第一、总的来说operator 的赋值形式（例如operator+=）比其单独形式效率更高，因为单独形式要返回一个新对象，从而在临时对象的构造和释放上有一些开销、第二、提供operator的赋值形式（例如operator+=）的同时也要提供其标准形式，允许类的客户端在便利与效率上做出折衷选择。</p>
<p>最后一点，涉及到operator单独形式的实现。再看看operator+ 的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">const</span> T <span class="keyword">operator</span>+(<span class="type">const</span> T&amp; lhs, <span class="type">const</span> T&amp; rhs)</span><br><span class="line">&#123; <span class="keyword">return</span> <span class="built_in">T</span>(lhs) += rhs; &#125;</span><br></pre></td></tr></table></figure><br>表达式T(lhs)调用了T的拷贝构造函数。它建立一个临时对象，其值与lhs一样。这个临时对象用来与rhs一起调用operator+= ，操作的结果被从operator+.返回。实现方法总可以使用返回值优化，所以编译器为其生成优化代码的可能就会更大。</p>
<h1 id="条款23：考虑变更程序库"><a href="#条款23：考虑变更程序库" class="headerlink" title="条款23：考虑变更程序库"></a>条款23：考虑变更程序库</h1><p>理想的程序库应该是短小的、快速的、强大的、灵活的、可扩展的、直观的、普遍适用的、具有良好的支持、没有使用约束、没有错误的。考虑iostream 和stdio程序库，iostream程序库与C中的stdio相比有几个优点，在效率方面，iostream程序库总是不如stdio，因为stdio产生的执行文件与iostream产生的执行文件相比尺寸小而且执行速度快。</p>
<p>让我们测试一个简单的benchmark 程序，只测试最基本的I/O功能。这个程序从标准输入读取30000个浮点数，然后把它们以固定的格式写到标准输出里。编译时预处理符号STDIO决定是使用stdio还是iostream。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> STDIO</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> VALUES = <span class="number">30000</span>;                 <span class="comment">// # of values to read/write</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> d;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">1</span>; n &lt;= VALUES; ++n) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> STDIO</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%10.5f&quot;</span>, d);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    cin &gt;&gt; d;</span><br><span class="line">    cout  &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>)                     <span class="comment">// 设定field宽度</span></span><br><span class="line">          &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>)              <span class="comment">// 设置小数位置</span></span><br><span class="line">          &lt;&lt; <span class="built_in">setiosflags</span>(ios::showpoint)  <span class="comment">// keep trailing 0s</span></span><br><span class="line">          &lt;&lt; <span class="built_in">setiosflags</span>(ios::fixed)      <span class="comment">// 使用这些设置</span></span><br><span class="line">          &lt;&lt; d;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> STDIO</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;/n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      cout &lt;&lt; <span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>cout远不如printf输入方便，但是操作符&lt;&lt;既是类型安全（type-safe）又可以扩展，而printf则不具有这两种优点。</p>
<p>应该注意到<strong>stdio的高效性主要是由其代码实现决定的</strong>，所以我已经测试过的系统其将来的实现或者我没有测试过的系统的当前实现都可能表现出iostream和stdio并没有显著的差异。一旦你找到软件的瓶颈应该知道是否可能通过替换程序库来消除瓶颈。</p>
<h1 id="条款24：理解虚拟函数、多继承、虚基类和RTTI所需的代价"><a href="#条款24：理解虚拟函数、多继承、虚基类和RTTI所需的代价" class="headerlink" title="条款24：理解虚拟函数、多继承、虚基类和RTTI所需的代价"></a>条款24：理解虚拟函数、多继承、虚基类和RTTI所需的代价</h1><p>当调用一个虚拟函数时，被执行的代码必须与调用函数的对象的动态类型相一致；指向对象的指针或引用的类型是不重要的。大多数编译器是使用<strong>virtual table</strong>和<strong>virtual table pointers</strong>。virtual table和virtual table pointers通常被分别地称为vtbl和vptr。</p>
<p>一个vtbl通常是一个<strong>函数指针数组</strong>。在程序中的每个类只要声明了虚函数或继承了虚函数，它就有自己的vtbl，并且类中vtbl的项目是指向虚函数实现体的指针。例如，如下这个类定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">C1</span>();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">C1</span>();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">f2</span><span class="params">(<span class="type">char</span> c)</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>C1的virtual table数组看起来如下图所示：<br><img src="/img/20200908003400.png" alt=""><br>注意<strong>非虚函数f4不在表中</strong>，而且<strong>C1的构造函数也不在</strong>。非虚函数就象普通的C函数那样被实现，所以有关它们的使用在性能上没有特殊的考虑。如果有一个C2类继承自C1，重新定义了它继承的一些虚函数，并加入了它自己的一些虚函数，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span>: <span class="keyword">public</span> C1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">C2</span>();                                      <span class="comment">// 非虚函数</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">C2</span>();                             <span class="comment">// 重定义函数</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>;                         <span class="comment">// 重定义函数</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f5</span><span class="params">(<span class="type">char</span> *str)</span></span>;                <span class="comment">// 新的虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>它的virtual table项目指向与对象相适合的函数。这些项目包括指向没有被C2重定义的C1虚函数的指针：<br><img src="/img/20200908003401.png" alt=""></p>
<p>这个论述引出了虚函数所需的第一个代价：<strong>你必须为每个包含虚函数的类的virtual talbe留出空间</strong>。类的vtbl的大小与类中声明的虚函数的数量成正比（包括从基类继承的虚函数）。每个类应该只有一个virtual table，所以virtual table所需的空间可能很大。</p>
<p>virtual table放在哪里呢？</p>
<ul>
<li>为每一个可能需要vtbl的object文件生成一个vtbl拷贝。<ul>
<li>连接程序然后去除重复的拷贝，在最后的可执行文件或程序库里就为每个vtbl保留一个实例。</li>
</ul>
</li>
<li>采用启发式算法来决定哪一个object文件应该包含类的vtbl。<ul>
<li>要在一个object文件中生成一个类的vtbl，要求该object文件包含该类的第一个非内联、非纯虚拟函数（non-inline non-pure virual function）定义（也就是类的实现体）。因此上述C1类的vtbl将被放置到包含C1::~C1定义的object文件里（不是内联的函数），C2类的vtbl被放置到包含C1::~C2定义的object文件里（不是内联函数）。</li>
</ul>
</li>
</ul>
<p>Virtual table只实现了虚拟函数的一半机制，virtual table pointer来建立联系。每个声明了虚函数的对象都带有它，它是一个看不见的数据成员，<strong>指向对应类的virtual table</strong>。这个看不见的数据成员也称为vptr，被编译器加在对象里，位置只有才编译器知道。从理论上讲，我们可以认为包含有虚函数的对象的布局是这样的：<br><img src="/img/20200908003402.png" alt=""></p>
<p>虚函数所需的第二个代价是：<strong>在每个包含虚函数的类的对象里，你必须为额外的指针付出代价</strong>。</p>
<p>假如我们有一个程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeACall</span><span class="params">(C1 *pC1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pC1-&gt;<span class="built_in">f1</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过指针pC1调用虚拟函数f1。仅仅看这段代码，你不会知道它调用的是那一个f1函数――C1::f1或C2::f1，因为pC1可以指向C1对象也可以指向C2对象。尽管如此编译器仍然得为在makeACall的f1函数的调用生成代码，它必须确保无论pC1指向什么对象，函数的调用必须正确。编译器生成的代码会做如下这些事情：</p>
<ol>
<li>通过对象的vptr找到类的vtbl。</li>
<li>找到对应vtbl内的指向被调用函数的指针（在上例中是f1）。</li>
<li>调用第二步找到的的指针所指向的函数。</li>
</ol>
<p>如果我们假设每个对象有一个隐藏的数据叫做vptr，而且f1在vtbl中的索引为i，此语句<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pC1-&gt;<span class="built_in">f1</span>();</span><br></pre></td></tr></table></figure><br>生成的代码就是这样的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(*pC1-&gt;vptr[i])(pC1);            <span class="comment">//调用被vtbl中第i个单元指</span></span><br><span class="line">                                 <span class="comment">// 向的函数，而pC1-&gt;vptr</span></span><br><span class="line">                                 <span class="comment">//指向的是vtbl；pC1被做为</span></span><br><span class="line">                                 <span class="comment">// this指针传递给函数。</span></span><br></pre></td></tr></table></figure><br>这几乎与调用非虚函数效率一样。在大多数计算机上它多执行了很少的一些指令。调用虚函数所需的代价基本上与通过函数指针调用函数一样。虚函数本身通常不是性能的瓶颈。</p>
<p>在实际运行中，<strong>虚函数所需的代价与内联函数有关</strong>。实际上虚函数不能是内联的。这是因为“内联”是指“<strong>在编译期间用被调用的函数体本身来代替函数调用的指令</strong>”，但是虚函数的“虚”是指“<strong>直到运行时才能知道要调用的是哪一个函数</strong>”。这是虚函数所需的第三个代价：<strong>你实际上放弃了使用内联函数</strong>。</p>
<p>如果一个派生类有一个以上从基类的继承路径，基类的数据成员被复制到每一个继承类对象里，把基类定义为虚基类则可以消除这种复制。然而虚基类本身会引起它们自己的代价，因为<strong>虚基类的实现经常使用指向虚基类的指针做为避免复制的手段</strong>，一个或者更多的指针被存储在对象里。<strong>虚函数能使对象变得更大，而且不能使用内联</strong>。</p>
<p><strong>运行时类型识别</strong>（RTTI）能让我们在运行时找到对象和类的有关信息，你能<strong>通过使用typeid操作符访问一个类的type_info对象</strong>。我们保证可以获得一个对象动态类型信息，如果该类型有至少一个虚函数。RTTI被设计为在类的vtbl基础上实现。</p>
<p>使用这种实现方法，<strong>RTTI耗费的空间是在每个类的vtbl中的占用的额外单元再加上存储type_info对象的空间</strong>。下面这个表各是对虚函数、多继承、虚基类以及RTTI所需主要代价的总结：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Feature</th>
<th>Increases Size of Objects</th>
<th>Increases Per-Class Data</th>
<th>Reduces Inlining</th>
</tr>
</thead>
<tbody>
<tr>
<td>Virtual Functions</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Multiple Inheritance</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Virtual Base Classes</td>
<td>Often</td>
<td>Sometimes</td>
<td>No</td>
</tr>
<tr>
<td>RTTI</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody>
</table>
</div>
<h1 id="条款25：将构造函数和非成员函数虚拟化"><a href="#条款25：将构造函数和非成员函数虚拟化" class="headerlink" title="条款25：将构造函数和非成员函数虚拟化"></a>条款25：将构造函数和非成员函数虚拟化</h1><p>当你有一个指针或引用，但是不知道其指向对象的真实类型是什么时，你可以调用虚拟函数来完成特定类型（type-specific）对象的行为。<strong>虚拟构造函数是指能够根据输入给它的数据的不同而建立不同类型的对象</strong>。还有一种特殊种类的虚拟构造函数――虚拟拷贝构造函数――也有着广泛的用途。虚拟拷贝构造函数能返回一个指针，指向调用该函数的对象的新拷贝。因为这种行为特性，虚拟拷贝构造函数的名字一般都是copySelf，cloneSelf或者是象下面这样就叫做clone。很少会有函数能以这么直接的方式实现它：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NLComponent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// declaration of virtual copy constructor</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> NLComponent * <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span>: <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> TextBlock * <span class="title">clone</span><span class="params">()</span> <span class="type">const</span>         <span class="comment">// virtual copy</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TextBlock</span>(*<span class="keyword">this</span>); &#125;          <span class="comment">// constructor</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graphic</span>: <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Graphic * <span class="title">clone</span><span class="params">()</span> <span class="type">const</span>            <span class="comment">// virtual copy</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Graphic</span>(*<span class="keyword">this</span>); &#125;             <span class="comment">// constructor</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>正如我们看到的，<strong>类的虚拟拷贝构造函数只是调用它们真正的拷贝构造函数</strong>。因此“拷贝”的含义与真正的拷贝构造函数相同。如果真正的拷贝构造函数只做了简单的拷贝，那么虚拟拷贝构造函数也做简单的拷贝。如果真正的拷贝构造函数做了全面的拷贝，那么虚拟拷贝构造函数也做全面的拷贝。如果真正的拷贝构造函数做一些奇特的事情，象引用计数或copy-on-write，那么虚拟构造函数也这么做。</p>
<p>被派生类重定义的虚拟函数不用必须与基类的虚拟函数具有一样的返回类型。如果函数的返回类型是一个指向基类的指针（或一个引用），那么派生类的函数可以返回一个指向基类的派生类的指针（或引用）。这不是C++的类型检查上的漏洞，它使得又可能声明象虚拟构造函数这样的函数。</p>
<p>在NLComponent中的虚拟拷贝构造函数能让实现NewLetter的(正常的)拷贝构造函数变得很容易：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewsLetter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">NewsLetter</span>(<span class="type">const</span> NewsLetter&amp; rhs);</span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  list&lt;NLComponent*&gt; components;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NewsLetter::<span class="built_in">NewsLetter</span>(<span class="type">const</span> NewsLetter&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 遍历整个rhs链表，使用每个元素的虚拟拷贝构造函数</span></span><br><span class="line">  <span class="comment">// 把元素拷贝进这个对象的component链表。</span></span><br><span class="line">  <span class="comment">// 有关下面代码如何运行的详细情况，请参见条款35.</span></span><br><span class="line">  <span class="keyword">for</span> (list&lt;NLComponent*&gt;::const_iterator it =</span><br><span class="line">          rhs.components.<span class="built_in">begin</span>();</span><br><span class="line">      it != rhs.components.<span class="built_in">end</span>();</span><br><span class="line">      ++it) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;it&quot; 指向rhs.components的当前元素，调用元素的clone函数，</span></span><br><span class="line">    <span class="comment">// 得到该元素的一个拷贝，并把该拷贝放到</span></span><br><span class="line">    <span class="comment">//这个对象的component链表的尾端。</span></span><br><span class="line">    components.<span class="built_in">push_back</span>((*it)-&gt;<span class="built_in">clone</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>遍历被拷贝的NewsLetter对象中的整个component链表，调用链表内每个元素对象的虚拟构造函数。我们在这里需要一个虚拟构造函数，因为链表中包含指向NLComponent对象的指针，但是我们知道其实每一个指针不是指向TextBlock对象就是指向Graphic对象。无论它指向谁，我们都想进行正确的拷贝操作，虚拟构造函数能够为我们做到这点。</p>
<h2 id="虚拟化非成员函数"><a href="#虚拟化非成员函数" class="headerlink" title="虚拟化非成员函数"></a>虚拟化非成员函数</h2><p>非成员函数也不能成为真正的虚拟函数。然而，既然一个函数能够构造出不同类型的新对象是可以理解的，那么同样也存在这样的非成员函数，可以根据参数的不同动态类型而其行为特性也不同。例如，假设你想为TextBlock和Graphic对象实现一个输出操作符。显而易见的方法是虚拟化这个输出操作符。但是输出操作符是<code>operator&lt;&lt;</code>，函数把<code>ostream&amp;</code>做为它的左参数（left-hand argument）（即把它放在函数参数列表的左边  译者注），这就不可能使该函数成为TextBlock 或 Graphic成员函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NLComponent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 对输出操作符的不寻常的声明</span></span><br><span class="line">  <span class="keyword">virtual</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; str) <span class="type">const</span> = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span>: <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 虚拟输出操作符(同样不寻常)</span></span><br><span class="line">  <span class="keyword">virtual</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; str) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graphic</span>: <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 虚拟输出操作符 (让就不寻常)</span></span><br><span class="line">  <span class="keyword">virtual</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; str) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">TextBlock t;</span><br><span class="line">Graphic g;</span><br><span class="line"> </span><br><span class="line">t &lt;&lt; cout;                                  <span class="comment">// 通过virtual operator&lt;&lt;</span></span><br><span class="line">                                            <span class="comment">//把t打印到cout中。</span></span><br><span class="line">                                            <span class="comment">// 不寻常的语法</span></span><br><span class="line">g &lt;&lt; cout;                                  <span class="comment">//通过virtual operator&lt;&lt;</span></span><br><span class="line">                                            <span class="comment">//把g打印到cout中。</span></span><br></pre></td></tr></table></figure><br>类的使用者得把stream对象放到&lt;&lt;符号的右边，这与输出操作符一般的用法相反。为了能够回到正常的语法上来，我们必须把operator&lt;&lt;移出TextBlock 和 Graphic类，但是如果我们这样做，就不能再把它声明为虚拟了。）</p>
<p>另一种方法是为打印操作声明一个虚拟函数（例如print）把它定义在TextBlock 和 Graphic类里。但是如果这样，打印TextBlock 和 Graphic对象的语法就与使用operator&lt;&lt;做为输出操作符的其它类型的对象不一致了，定义operator&lt;&lt; 和print函数，让前者调用后者！<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NLComponent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; s)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span>: <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; s)</span> <span class="type">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graphic</span>: <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; s)</span> <span class="type">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; s, <span class="type">const</span> NLComponent&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> c.<span class="built_in">print</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="条款26：限制某个类所能产生的对象数量-上）"><a href="#条款26：限制某个类所能产生的对象数量-上）" class="headerlink" title="条款26：限制某个类所能产生的对象数量(上）"></a>条款26：限制某个类所能产生的对象数量(上）</h1><p>每次实例化一个对象时，我们很确切地知道一件事情：“将调用一个构造函数。”事实确实这样，阻止建立某个类的对象，最容易的方法就是把该类的构造函数声明在类的private域：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CantBeInstantiated</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">CantBeInstantiated</span>();</span><br><span class="line">  <span class="built_in">CantBeInstantiated</span>(<span class="type">const</span> CantBeInstantiated&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这样做以后，每个人都没有权力建立对象，我们能够有选择性地放松这个限制。把打印机对象封装在一个函数内，以便让每个人都能访问打印机，但是只有一个打印机对象被建立。：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrintJob</span>;                           <span class="comment">// forward 声明</span></span><br><span class="line">                                          <span class="comment">// 参见Effective C++条款34</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">submitJob</span><span class="params">(<span class="type">const</span> PrintJob&amp; job)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">performSelfTest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">friend</span> Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Printer</span>();</span><br><span class="line">  <span class="built_in">Printer</span>(<span class="type">const</span> Printer&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> Printer p;                          <span class="comment">// 单个打印机对象</span></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个设计由三个部分组成：</p>
<ul>
<li>Printer类的构造函数是private。这样能阻止建立对象。</li>
<li>全局函数thePrinter被声明为类的友元，让thePrinter避免私有构造含函数引起的限制。</li>
<li>thePrinter包含一个静态Printer对象，这意味着只有一个对象被建立。</li>
</ul>
<p>客户端代码无论何时要与系统的打印机进行交互访问，它都要使用thePrinter函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrintJob</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">PrintJob</span>(<span class="type">const</span> string&amp; whatToPrint);</span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line">string buffer;</span><br><span class="line"><span class="built_in">thePrinter</span>().<span class="built_in">reset</span>();</span><br><span class="line"><span class="built_in">thePrinter</span>().<span class="built_in">submitJob</span>(buffer);</span><br></pre></td></tr></table></figure></p>
<p>使用静态函数，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Printer</span>();</span><br><span class="line">  <span class="built_in">Printer</span>(<span class="type">const</span> Printer&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Printer&amp; <span class="title">Printer::thePrinter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> Printer p;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>客户端使用printer时有些繁琐：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Printer::<span class="built_in">thePrinter</span>().<span class="built_in">reset</span>();</span><br><span class="line">Printer::<span class="built_in">thePrinter</span>().<span class="built_in">submitJob</span>(buffer);</span><br></pre></td></tr></table></figure><br>另一种方法是把thePrinter移出全局域，放入namespace（命名空间）。命名空间从句法上来看有些象类，但是它没有public、protected或private域。所有都是public。如下所示，我们把Printer、thePrinter放入叫做PrintingStuff的命名空间里：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> PrintingStuff &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Printer</span> &#123;                          <span class="comment">// 在命名空间</span></span><br><span class="line">  <span class="keyword">public</span>:                                 <span class="comment">// PrintingStuff中的类</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">submitJob</span><span class="params">(<span class="type">const</span> PrintJob&amp; job)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">performSelfTest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Printer</span>();</span><br><span class="line">    <span class="built_in">Printer</span>(<span class="type">const</span> Printer&amp; rhs);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">Printer&amp; <span class="title">thePrinter</span><span class="params">()</span>                   <span class="comment">// 这个函数也在命名空间里</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="type">static</span> Printer p;</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用这个命名空间后，客户端可以通过使用fully-qualified name（完全限制符名）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintingStuff::<span class="built_in">thePrinter</span>().<span class="built_in">reset</span>();</span><br><span class="line">PrintingStuff::<span class="built_in">thePrinter</span>().<span class="built_in">submitJob</span>(buffer);</span><br></pre></td></tr></table></figure><br>但是也可以使用using声明，以简化键盘输入：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> PrintingStuff::thePrinter;    <span class="comment">// 从命名空间&quot;PrintingStuff&quot;</span></span><br><span class="line">                                    <span class="comment">//引入名字&quot;thePrinter&quot;</span></span><br><span class="line"><span class="built_in">thePrinter</span>().<span class="built_in">reset</span>();               <span class="comment">// 现在可以象使用局部命名</span></span><br><span class="line"><span class="built_in">thePrinter</span>().<span class="built_in">submitJob</span>(buffer);    <span class="comment">// 一样，使用thePrinter</span></span><br></pre></td></tr></table></figure></p>
<p>单独的Printer是位于函数里的静态成员而不是在类中的静态成员，只有第一次执行函数时，才会建立函数中的静态对象，所以如果没有调用函数，就不会建立对象。与一个函数的静态成员相比，把Printer声明为类中的静态成员还有一个缺点，它的初始化时间不确定。</p>
<p>第二个细微之处是内联与函数内静态对象的关系。再看一下thePrinter的非成员函数形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> Printer p;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>除了第一次执行这个函数时，其它时候这就是一个一行函数——<code>return p;</code>。记住一件事：<strong>带有内部链接的函数可能在程序内被复制（也就是说程序的目标（object）代码可能包含一个以上的内部链接函数的代码</strong>，这种复制也包括函数内的静态对象。<strong>如果建立一个包含局部静态对象的非成员函数，你可能会使程序的静态对象的拷贝超过一个！所以不要建立包含局部静态数据的非成员函数。</strong></p>
<h2 id="允许对象来去自由"><a href="#允许对象来去自由" class="headerlink" title="允许对象来去自由"></a>允许对象来去自由</h2><p>使用thePrinter函数封装对单个对象的访问，以便把Printer对象的数量限制为一个，这样做的同时也会让我们在每一次运行程序时只能使用一个Printer对象。导致我们不能这样编写代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">建立 Printer 对象 p1;</span><br><span class="line">使用 p1;</span><br><span class="line">释放 p1;</span><br><span class="line">建立Printer对象p2;</span><br><span class="line">使用 p2;</span><br><span class="line">释放 p2;</span><br></pre></td></tr></table></figure><br>这种设计在同一时间里没有实例化多个Printer对象，而是在程序的不同部分使用了不同的Printer对象。不允许这样编写有些不合理。我们必须把先前使用的对象计数的代码与刚才看到的伪构造函数代码合并在一起：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">TooManyObjects</span>&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 伪构造函数</span></span><br><span class="line">  <span class="function"><span class="type">static</span> Printer * <span class="title">makePrinter</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">~<span class="built_in">Printer</span>();</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">submitJob</span><span class="params">(<span class="type">const</span> PrintJob&amp; job)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">performSelfTest</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">size_t</span> numObjects;</span><br><span class="line">  <span class="built_in">Printer</span>();</span><br><span class="line">  <span class="built_in">Printer</span>(<span class="type">const</span> Printer&amp; rhs);        <span class="comment">//我们不定义这个函数</span></span><br><span class="line">&#125;;                                    <span class="comment">//因为不允许</span></span><br><span class="line">                                       <span class="comment">//进行拷贝 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Obligatory definition of class static</span></span><br><span class="line"><span class="type">size_t</span> Printer::numObjects = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Printer::<span class="built_in">Printer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (numObjects &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">TooManyObjects</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  继续运行正常的构造函数;</span><br><span class="line">  ++numObjects;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Printer * <span class="title">Printer::makePrinter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Printer; &#125;</span><br></pre></td></tr></table></figure><br>当需要的对象过多时，会抛出异常，如果你认为这种方式给你的感觉是unreasonably harsh，你可以让伪构造函数返回一个空指针。当然客户端在使用之前应该进行检测。除了客户端必须调用伪构造函数，而不是真正的构造函数之外，它们使用Printer类就象使用其他类一样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Printer p1;                               <span class="comment">// 错误! 缺省构造函数是</span></span><br><span class="line">                                          <span class="comment">// private</span></span><br><span class="line">Printer *p2 =</span><br><span class="line">  Printer::<span class="built_in">makePrinter</span>();                 <span class="comment">// 正确, 间接调用</span></span><br><span class="line">                                          <span class="comment">// 缺省构造函数</span></span><br><span class="line">Printer p3 = *p2;                         <span class="comment">// 错误! 拷贝构造函数是</span></span><br><span class="line">                                          <span class="comment">// private</span></span><br><span class="line"></span><br><span class="line">p2-&gt;<span class="built_in">performSelfTest</span>();                   <span class="comment">// 所有其它的函数都可以</span></span><br><span class="line">p2-&gt;<span class="built_in">reset</span>();                             <span class="comment">// 正常调用</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p2;                                <span class="comment">// 避免内存泄漏，如果</span></span><br><span class="line">                                          <span class="comment">// p2 是一个 auto_ptr，</span></span><br><span class="line">                                          <span class="comment">// 就不需要这步。</span></span><br></pre></td></tr></table></figure><br>这种技术很容易推广到限制对象为任何数量上。我们只需把hard-wired常量值1改为根据某个类而确定的数量，然后消除拷贝对象的约束。例如，下面这个经过修改的Printer类的代码实现，最多允许10个Printer对象存在：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">TooManyObjects</span>&#123;&#125;;</span><br><span class="line">  <span class="comment">// 伪构造函数</span></span><br><span class="line">  <span class="function"><span class="type">static</span> Printer * <span class="title">makePrinter</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> Printer * <span class="title">makePrinter</span><span class="params">(<span class="type">const</span> Printer&amp; rhs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">size_t</span> numObjects;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> maxObjects = <span class="number">10</span>;       <span class="comment">// 见下面解释</span></span><br><span class="line">  <span class="built_in">Printer</span>();</span><br><span class="line">  <span class="built_in">Printer</span>(<span class="type">const</span> Printer&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Obligatory definitions of class statics</span></span><br><span class="line"><span class="type">size_t</span> Printer::numObjects = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> Printer::maxObjects;</span><br><span class="line"> </span><br><span class="line">Printer::<span class="built_in">Printer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (numObjects &gt;= maxObjects) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">TooManyObjects</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Printer::<span class="built_in">Printer</span>(<span class="type">const</span> Printer&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (numObjects &gt;= maxObjects) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">TooManyObjects</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Printer * <span class="title">Printer::makePrinter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Printer; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Printer * <span class="title">Printer::makePrinter</span><span class="params">(<span class="type">const</span> Printer&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Printer</span>(rhs); &#125;</span><br></pre></td></tr></table></figure><br>或者把maxObjects作为枚举类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">enum</span> &#123; maxObjects = <span class="number">10</span> &#125;;                <span class="comment">// 在类中,</span></span><br><span class="line">  ...                                      <span class="comment">// maxObjects为常量10</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>或者象non-const static成员一样初始化static常量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> maxObjects;            <span class="comment">// 没有赋给初值</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 放在一个代码实现的文件中</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> Printer::maxObjects = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="一个具有对象计数功能的基类"><a href="#一个具有对象计数功能的基类" class="headerlink" title="一个具有对象计数功能的基类"></a>一个具有对象计数功能的基类</h2><p>我们很容易地能够编写一个具有实例计数功能的基类，然后让像Printer这样的类从该基类继承。Printer类的计数器是静态变量numObjects，我们应该把变量放入实例计数类中。然而也需要确保每个进行实例计数的类都有一个相互隔离的计数器。使用计数类模板可以自动生成适当数量的计数器，因为我们能让计数器成为从模板中生成的类的静态成员：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">BeingCounted</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counted</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">TooManyObjects</span>&#123;&#125;;                     <span class="comment">// 用来抛出异常</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">objectCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> numObjects; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="built_in">Counted</span>();</span><br><span class="line">  <span class="built_in">Counted</span>(<span class="type">const</span> Counted&amp; rhs);</span><br><span class="line">  ~<span class="built_in">Counted</span>() &#123; --numObjects; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> numObjects;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> maxObjects;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;                                <span class="comment">// 避免构造函数的</span></span><br><span class="line">&#125;;                                            <span class="comment">// 代码重复</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">BeingCounted</span>&gt;</span><br><span class="line">Counted&lt;BeingCounted&gt;::<span class="built_in">Counted</span>()</span><br><span class="line">&#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">BeingCounted</span>&gt;</span><br><span class="line">Counted&lt;BeingCounted&gt;::<span class="built_in">Counted</span>(<span class="type">const</span> Counted&lt;BeingCounted&gt;&amp;)</span><br><span class="line">&#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">BeingCounted</span>&gt;</span><br><span class="line"><span class="type">void</span> Counted&lt;BeingCounted&gt;::<span class="built_in">init</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (numObjects &gt;= maxObjects) <span class="keyword">throw</span> <span class="built_in">TooManyObjects</span>();</span><br><span class="line">  ++numObjects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从这个模板生成的类仅仅能被做为基类使用，因此构造函数和析构函数被声明为protected。注意private成员函数init用来避免两个Counted构造函数的语句重复。</p>
<p>现在我们能修改Printer类，这样使用Counted模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>: <span class="keyword">private</span> Counted&lt;Printer&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 伪构造函数</span></span><br><span class="line">  <span class="function"><span class="type">static</span> Printer * <span class="title">makePrinter</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> Printer * <span class="title">makePrinter</span><span class="params">(<span class="type">const</span> Printer&amp; rhs)</span></span>;</span><br><span class="line"> </span><br><span class="line">  ~<span class="built_in">Printer</span>();</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">submitJob</span><span class="params">(<span class="type">const</span> PrintJob&amp; job)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">performSelfTest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> Counted&lt;Printer&gt;::objectCount;     <span class="comment">// 参见下面解释</span></span><br><span class="line">  <span class="keyword">using</span> Counted&lt;Printer&gt;::TooManyObjects;  <span class="comment">// 参见下面解释</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Printer</span>();</span><br><span class="line">  <span class="built_in">Printer</span>(<span class="type">const</span> Printer&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>Printer使用了Counter模板来跟踪存在多少Printer对象。另一种方法是在Printer和<code>counted&lt;Printer&gt;</code>之间使用public继承，但是我们必须给Counted类一个虚拟析构函数。</p>
<p>当Printer继承<code>Counted&lt;Printer&gt;</code>时，它可以忘记有关对象计数的事情。编写Printer类时根本不用考虑对象计数，就好像有其他人会为它计数一样。Printer的构造函数可以是这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Printer::<span class="built_in">Printer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  进行正常的构造函数运行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为<code>Counted&lt;Printer&gt;</code>是Printer的基类，<code>Counted&lt;Printer&gt;</code>的构造函数总在Printer的前面被调用。如果建立过多的对象，<code>Counted&lt;Printer&gt;</code>的构造函数就会抛出异常，甚至都没有调用Printer的构造函数。</p>
<p>最后还有一点需要注意，必须定义Counted内的静态成员。对于numObjects来说，这很容易——我们只需要在Counted的实现文件里定义它即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">BeingCounted</span>&gt;                 <span class="comment">// 定义numObjects</span></span><br><span class="line"><span class="type">int</span> Counted&lt;BeingCounted&gt;::numObjects;       <span class="comment">// 自动把它初始化为0</span></span><br></pre></td></tr></table></figure></p>
<p>我们应该如何初始化<code>Counted&lt;Printer&gt;::maxObjects</code>？简单的方法就是什么也不做，让此类的客户端提供合适的初始化。Printer的作者必须把这条语句加入到一个实现文件里：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">size_t</span> Counted&lt;Printer&gt;::maxObjects = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><br>同样FileDescriptor的作者也得加入这条语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">size_t</span> Counted&lt;FileDescriptor&gt;::maxObjects = <span class="number">16</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="条款27：要求或禁止在堆中产生对象（上）"><a href="#条款27：要求或禁止在堆中产生对象（上）" class="headerlink" title="条款27：要求或禁止在堆中产生对象（上）"></a>条款27：要求或禁止在堆中产生对象（上）</h1><h2 id="要求在堆中建立对象"><a href="#要求在堆中建立对象" class="headerlink" title="要求在堆中建立对象"></a>要求在堆中建立对象</h2><p>为了执行这种限制，你必须找到一种方法禁止以调用“new”以外的其它手段建立对象。这很容易做到。<strong>非堆对象（non-heap object）在定义它的地方被自动构造，在生存时间结束时自动被释放，所以只要禁止使用隐式的构造函数和析构函数，就可以实现这种限制</strong>。</p>
<p>把这些调用变得不合法的一种最直接的方法是把构造函数和析构函数声明为private。这样做副作用太大。没有理由让这两个函数都是private。最好让析构函数成为private，让构造函数成为public。处理过程与条款26相似，你可以引进一个专用的伪析构函数，用来访问真正的析构函数。客户端调用伪析构函数释放他们建立的对象。</p>
<p>例如，如果我们想仅仅在堆中建立代表unlimited precision numbers（无限精确度数字）的对象，可以这样做：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UPNumber</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">UPNumber</span>();</span><br><span class="line">  <span class="built_in">UPNumber</span>(<span class="type">int</span> initValue);</span><br><span class="line">  <span class="built_in">UPNumber</span>(<span class="type">double</span> initValue);</span><br><span class="line">  <span class="built_in">UPNumber</span>(<span class="type">const</span> UPNumber&amp; rhs);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 伪析构函数 (一个const 成员函数， 因为</span></span><br><span class="line">  <span class="comment">// 即使是const对象也能被释放。)</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ~<span class="built_in">UPNumber</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>然后客户端这样进行程序设计：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPNumber n;                          <span class="comment">// 错误! (在这里合法，但是当它的析构函数被隐式地调用时，就不合法了)</span></span><br><span class="line">UPNumber *p = <span class="keyword">new</span> UPNumber;          <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">delete</span> p;                            <span class="comment">// 错误! 试图调用</span></span><br><span class="line">                                     <span class="comment">// private 析构函数</span></span><br><span class="line">p-&gt;<span class="built_in">destroy</span>();                        <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><br>另一种方法是把全部的构造函数都声明为private。这种方法的缺点是一个类经常有许多构造函数，类的作者必须记住把它们都声明为private。否则如果这些函数就会由编译器生成，构造函数包括拷贝构造函数，也包括缺省构造函数；编译器生成的函数总是public。因此仅仅声明析构函数为private是很简单的，因为每个类只有一个析构函数。</p>
<p>通过限制访问一个类的析构函数或它的构造函数来阻止建立非堆对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UPNumber</span> &#123; ... &#125;;              <span class="comment">// 声明析构函数或构造函数</span></span><br><span class="line">                                     <span class="comment">// 为private</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonNegativeUPNumber</span>:</span><br><span class="line">  <span class="keyword">public</span> UPNumber &#123; ... &#125;;           <span class="comment">// 错误! 析构函数或</span></span><br><span class="line">                                     <span class="comment">//构造函数不能编译</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Asset</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  UPNumber value;</span><br><span class="line">  ...                                <span class="comment">// 错误! 析构函数或</span></span><br><span class="line">                                     <span class="comment">//构造函数不能编译</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这些困难不是不能克服的。通过把UPNumber的析构函数声明为protected（同时它的构造函数还保持public）就可以解决继承的问题，需要包含UPNumber对象的类可以修改为包含指向UPNumber的指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UPNumber</span> &#123; ... &#125;;              <span class="comment">// 声明析构函数为protected</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonNegativeUPNumber</span>:</span><br><span class="line">  <span class="keyword">public</span> UPNumber &#123; ... &#125;;           <span class="comment">// 现在正确了; 派生类</span></span><br><span class="line">                                     <span class="comment">// 能够访问</span></span><br><span class="line">                                     <span class="comment">// protected 成员</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Asset</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Asset</span>(<span class="type">int</span> initValue);</span><br><span class="line">  ~<span class="built_in">Asset</span>();</span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  UPNumber *value;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Asset::<span class="built_in">Asset</span>(<span class="type">int</span> initValue)</span><br><span class="line">: <span class="built_in">value</span>(<span class="keyword">new</span> <span class="built_in">UPNumber</span>(initValue))      <span class="comment">// 正确</span></span><br><span class="line">&#123; ... &#125;</span><br><span class="line"> </span><br><span class="line">Asset::~<span class="built_in">Asset</span>()</span><br><span class="line">&#123; value-&gt;<span class="built_in">destroy</span>(); &#125;                 <span class="comment">// 也正确</span></span><br></pre></td></tr></table></figure></p>
<h2 id="判断一个对象是否在堆中"><a href="#判断一个对象是否在堆中" class="headerlink" title="判断一个对象是否在堆中"></a>判断一个对象是否在堆中</h2><p>最根本的问题是对象可以被分配在三个地方，而不是两个。是的，<strong>栈</strong>和<strong>堆</strong>能够容纳对象，但是我们忘了<strong>静态对象</strong>。静态对象是那些在程序运行时仅能初始化一次的对象。静态对象不仅仅包括显示地声明为static的对象，也包括在全局和命名空间里的对象。这些对象肯定位于某些地方，而这些地方既不是栈也不是堆。</p>
<p>它们的位置是依据系统而定的，但是在很多栈和堆相向扩展的系统里，它们位于堆的底端。不仅没有一种可移植的方法来判断对象是否在堆上，而且连能在多数时间正常工作的“准可移植”的方法也没有。如果你实在非得必须判断一个地址是否在堆上，你必须使用完全不可移植的方法，其实现依赖于系统调用。</p>
<p>如果你发现自己实在为对象是否在堆中这个问题所困扰，一个可能的原因是你想知道对象是否能在其上安全调用delete。这种删除经常采用<code>delete this</code>这种声明狼籍的形式。不过知道“是否能安全删除一个指针”与“只简单地知道一个指针是否指向堆中的事物”不一样，因为不是所有在堆中的事物都能被安全地delete。再考虑包含UPNumber对象的Asset对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Asset</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  UPNumber value;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Asset *pa = <span class="keyword">new</span> Asset;</span><br></pre></td></tr></table></figure><br>很明显*pa（包括它的成员value）在堆上。同样很明显在指向pa-&gt;value上调用delete是不安全的，因为该指针不是被new返回的。</p>
<p>幸运的是“判断是否能够删除一个指针”比“判断一个指针指向的事物是否在堆上”要容易。因为对于前者我们只需要一个operator new返回的地址集合：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">void</span> *p = <span class="built_in">getMemory</span>(size);         <span class="comment">//调用一些函数来分配内存，</span></span><br><span class="line">                                     <span class="comment">//处理内存不够的情况</span></span><br><span class="line">  把 p加入到一个被分配地址的集合;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">releaseMemory</span>(ptr);                <span class="comment">// return memory to</span></span><br><span class="line">                                     <span class="comment">// free store</span></span><br><span class="line"> </span><br><span class="line">  从被分配地址的集合中移去ptr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSafeToDelete</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  返回address是否在被分配地址的集合中;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这很简单，<code>operator new</code>在地址分配集合里加入一个元素，<code>operator delete</code>从集合中移去项目，<code>isSafeToDelete</code>在集合中查找并确定某个地址是否在集合中。如果<code>operator new</code> 和 <code>operator delete</code>函数在全局作用域中，它就能适用于所有的类型，甚至是内建类型。</p>
<p>在实际当中，有三种因素制约着对这种设计方式的使用。</p>
<ul>
<li>第一是我们极不愿意在全局域定义任何东西，特别是那些已经具有某种含义的函数，象<code>operator new</code>和<code>operator delete</code>。正如我们所知，只有一个全局域，只有一种具有正常特征形式（也就是参数类型）的<code>operator new</code>和<code>operator delete</code>。这样做会使得我们的软件与其它也实现全局版本的<code>operator new</code>和<code>operator delete</code>的软件（例如许多面向对象数据库系统）不兼容。</li>
<li>我们考虑的第二个因素是效率：如果我们不需要这些，为什么还要为跟踪返回的地址而负担额外的开销呢？</li>
<li>最后一点可能有些平常，但是很重要。实现isSafeToDelete让它总能够正常工作是不可能的。难点是多继承下来的类或继承自虚基类的类有多个地址，所以无法保证传给isSafeToDelete的地址与operator new 返回的地址相同，即使对象在堆中建立。</li>
</ul>
<p>C++使用一种抽象基类满足了我们的需要。<strong>抽象基类是不能被实例化的基类，也就是至少具有一个纯虚函数的基类</strong>。mixin(mix in)类提供某一特定的功能，并可以与其继承类提供的其它功能相兼容。这种类几乎都是抽象类。因此我们能够使用抽象混合（mixin）基类给派生类提供判断指针指向的内存是否由operator new分配的能力。该类如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapTracked</span> &#123;                  <span class="comment">// 混合类; 跟踪</span></span><br><span class="line"><span class="keyword">public</span>:                              <span class="comment">// 从operator new返回的ptr</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">MissingAddress</span>&#123;&#125;;            <span class="comment">// 异常类，见下面代码</span></span><br><span class="line"> <span class="keyword">virtual</span> ~<span class="built_in">HeapTracked</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">isOnHeap</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> <span class="type">void</span>* RawAddress;</span><br><span class="line">  <span class="type">static</span> list&lt;RawAddress&gt; addresses;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这个类使用了list（链表）数据结构跟踪从operator new返回的所有指针，list标准C++库的一部分。operator new函数分配内存并把地址加入到list中；operator delete用来释放内存并从list中移去地址元素。isOnHeap判断一个对象的地址是否在list中。</p>
<p>HeapTracked类的实作很简单，调用全局的operator new和operator delete函数来完成内存的分配与释放，list类里的函数进行插入操作和删除操作，并进行单语句的查找操作。以下是HeapTracked的全部实作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mandatory definition of static class member</span></span><br><span class="line">list&lt;RawAddress&gt; HeapTracked::addresses;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HeapTracked的析构函数是纯虚函数，使得该类变为抽象类。然而析构函数必须被定义，</span></span><br><span class="line"><span class="comment">//所以我们做了一个空定义。</span></span><br><span class="line">HeapTracked::~<span class="built_in">HeapTracked</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> * HeapTracked::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">void</span> *memPtr = ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);  <span class="comment">// 获得内存</span></span><br><span class="line">  addresses.<span class="built_in">push_front</span>(memPtr);         <span class="comment">// 把地址放到list的前端</span></span><br><span class="line">  <span class="keyword">return</span> memPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> HeapTracked::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//得到一个 &quot;iterator&quot;，用来识别list元素包含的ptr；</span></span><br><span class="line">  list&lt;RawAddress&gt;::iterator it =</span><br><span class="line">    <span class="built_in">find</span>(addresses.<span class="built_in">begin</span>(), addresses.<span class="built_in">end</span>(), ptr);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (it != addresses.<span class="built_in">end</span>()) &#123;       <span class="comment">// 如果发现一个元素</span></span><br><span class="line">    addresses.<span class="built_in">erase</span>(it);             <span class="comment">//则删除该元素</span></span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>;          <span class="comment">// 释放内存</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;                           <span class="comment">// 否则</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">MissingAddress</span>();          <span class="comment">// ptr就不是用operator new</span></span><br><span class="line">  &#125;                                  <span class="comment">// 分配的，所以抛出一个异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HeapTracked::isOnHeap</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 得到一个指针，指向*this占据的内存空间的起始处，</span></span><br><span class="line">  <span class="comment">// 有关细节参见下面的讨论</span></span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *rawAddress = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(<span class="keyword">this</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 在operator new返回的地址list中查到指针</span></span><br><span class="line">  list&lt;RawAddress&gt;::iterator it =</span><br><span class="line">    <span class="built_in">find</span>(addresses.<span class="built_in">begin</span>(), addresses.<span class="built_in">end</span>(), rawAddress);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> it != addresses.<span class="built_in">end</span>();      <span class="comment">// 返回it是否被找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为isOnHeap仅仅用于HeapTracked对象中，我们能使用dynamic_cast操作符的一种特殊的特性来消除这个问题。只需简单地放入dynamic_cast，把一个指针dynamic_cast成<code>void*</code>类型（或<code>const void*</code>或<code>volatile void*</code>），生成的指针指向“原指针指向对象内存”的开始处。但是dynamic_cast只能用于“指向至少具有一个虚拟函数的对象”的指针上。isOnHeap更具有选择性，所以能把this指针dynamic_cast成<code>const void*</code>，变成一个指向当前对象起始地址的指针。如果HeapTracked::operator new为当前对象分配内存，这个指针就是HeapTracked::operator new返回的指针。如果你的编译器支持dynamic_cast 操作符，这个技巧是完全可移植的。</p>
<p>使用这个类，即使是最初级的程序员也可以在类中加入跟踪堆中指针的功能。他们所需要做的就是让他们的类从HeapTracked继承下来。例如我们想判断Assert对象指针指向的是否是堆对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Asset</span>: <span class="keyword">public</span> HeapTracked &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  UPNumber value;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>我们能够这样查询Assert*指针，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inventoryAsset</span><span class="params">(<span class="type">const</span> Asset *ap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ap-&gt;<span class="built_in">isOnHeap</span>()) &#123;</span><br><span class="line">    ap is a heap-based asset — inventory it as such;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    ap is a non-heap-based asset — record it that way;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>象HeapTracked这样的混合类有一个缺点，它不能用于内建类型，因为象int和char这样的类型不能继承自其它类型。不过使用象HeapTracked的原因一般都是要判断是否可以调用”delete this”，你不可能在内建类型上调用它，因为内建类型没有this指针。</p>
<h2 id="禁止堆对象"><a href="#禁止堆对象" class="headerlink" title="禁止堆对象"></a>禁止堆对象</h2><p>通常对象的建立这样三种情况：<strong>对象被直接实例化</strong>；<strong>对象做为派生类的基类被实例化</strong>；<strong>对象被嵌入到其它对象内</strong>。我们将按顺序地讨论它们。</p>
<p>禁止客户端直接实例化对象很简单，利用new操作符总是调用operator new函数来达到目的。例如，如果你想不想让客户端在堆中建立UPNumber对象，你可以这样编写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UPNumber</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>现在客户端仅仅可以做允许它们做的事情：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPNumber n1;                         <span class="comment">// okay</span></span><br><span class="line"><span class="type">static</span> UPNumber n2;                  <span class="comment">// also okay</span></span><br><span class="line">UPNumber *p = <span class="keyword">new</span> UPNumber;          <span class="comment">// error! attempt to call private operator new</span></span><br></pre></td></tr></table></figure><br>如果你也想禁止UPNumber堆对象数组，可以把operator new[]和operator delete[]也声明为private。有趣的是，把operator new声明为private经常会阻碍UPNumber对象做为一个位于堆中的派生类对象的基类被实例化。因为如果operator new和operator delete没有在派生类中被声明为public，它们就会被继承下来，继承了基类private函数的类，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UPNumber</span> &#123; ... &#125;;             <span class="comment">// 同上</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonNegativeUPNumber</span>:          <span class="comment">//假设这个类</span></span><br><span class="line">  <span class="keyword">public</span> UPNumber &#123;                 <span class="comment">//没有声明operator new</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NonNegativeUPNumber n1;             <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> NonNegativeUPNumber n2;      <span class="comment">// 也正确</span></span><br><span class="line"></span><br><span class="line">NonNegativeUPNumber *p =            <span class="comment">// 错误! 试图调用</span></span><br><span class="line">  <span class="keyword">new</span> NonNegativeUPNumber;          <span class="comment">// private operator new</span></span><br></pre></td></tr></table></figure><br>如果派生类声明它自己的operator new，当在堆中分配派生对象时，就会调用这个函数，必须得找到一种不同的方法防止UPNumber基类部分缠绕在这里。同样，UPNumber的operator new是private这一点，不会对分配包含做为成员的UPNumber对象的对象产生任何影响：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Asset</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Asset</span>(<span class="type">int</span> initValue);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  UPNumber value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Asset *pa = <span class="keyword">new</span> <span class="built_in">Asset</span>(<span class="number">100</span>);          <span class="comment">// 正确, 调用</span></span><br><span class="line">                                     <span class="comment">// Asset::operator new 或</span></span><br><span class="line">                                     <span class="comment">// ::operator new, 不是</span></span><br><span class="line">                                     <span class="comment">// UPNumber::operator new</span></span><br></pre></td></tr></table></figure></p>
<h1 id="条款28：灵巧（smart）指针（上）"><a href="#条款28：灵巧（smart）指针（上）" class="headerlink" title="条款28：灵巧（smart）指针（上）"></a>条款28：灵巧（smart）指针（上）</h1><p>灵巧指针是一种外观和行为都被设计成与内建指针相类似的对象，不过它能提供更多的功能。当你使用灵巧指针替代C++的内建指针（也就是dumb pointer）,你就能控制下面这些方面的指针的行为：</p>
<ul>
<li>构造和析构。你可以决定建立灵巧指针时应该怎么做。通常赋给灵巧指针缺省值0，避免出现令人头疼的未初始化的指针。当指向某一对象的最后一个灵巧指针被释放时，一些灵巧指针负责删除它们指向的对象。</li>
<li>拷贝和赋值。你能对拷贝灵巧指针或设计灵巧指针的赋值操作进行控制。对于一些类型的灵巧指针来说，期望的行为是自动拷贝它们所指向的对象或用对这些对象进行赋值操作，也就是进行deep copy(深层拷贝)。</li>
<li>Dereferencing(取出指针所指东西的内容)。当客户端引用被灵巧指针所指的对象，可以自行决定行为。</li>
</ul>
<p>灵巧指针从模板中生成，因为要与内建指针类似，必须是strongly typed(强类型)的；模板参数确定指向对象的类型。大多数灵巧指针模板看起来都象这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;                    <span class="comment">//灵巧指针对象模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;                    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SmartPtr</span>(T* realPtr = <span class="number">0</span>);          <span class="comment">// 建立一个灵巧指针</span></span><br><span class="line">                                     <span class="comment">// 指向dumb pointer所指的</span></span><br><span class="line">                                     <span class="comment">// 对象。未初始化的指针</span></span><br><span class="line">                                     <span class="comment">// 缺省值为0(null)</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">SmartPtr</span>(<span class="type">const</span> SmartPtr&amp; rhs);     <span class="comment">// 拷贝一个灵巧指针</span></span><br><span class="line"> </span><br><span class="line">  ~<span class="built_in">SmartPtr</span>();                       <span class="comment">// 释放灵巧指针</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// make an assignment to a smart ptr</span></span><br><span class="line">  SmartPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SmartPtr&amp; rhs);</span><br><span class="line"> </span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span>;             <span class="comment">// dereference一个灵巧指针</span></span><br><span class="line">                                     <span class="comment">// 以访问所指对象的成员</span></span><br><span class="line"> </span><br><span class="line">  T&amp; <span class="keyword">operator</span>*() <span class="type">const</span>;              <span class="comment">// dereference 灵巧指针</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T *pointee;                        <span class="comment">// 灵巧指针所指的对象</span></span><br><span class="line">&#125;;                                 </span><br></pre></td></tr></table></figure><br>拷贝构造函数和赋值操作符都被展现在这里。对于灵巧指针类来说，不能允许进行拷贝和赋值操作，它们应该被声明为private 。两个dereference操作符被声明为const，是因为dereference一个指针时不能对指针进行修改。最后，每个指向T对象的灵巧指针包含一个指向T的dumb pointer。这个dumb pointer指向的对象才是灵巧指针指向的真正对象。</p>
<p>采用不同的方法分别处理本地对象与远程对象是一件很烦人的事情。让所有的对象都位于一个地方会更方便。灵巧指针可以让程序库实现这样的梦想。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;                    <span class="comment">// 指向位于分布式 DB（数据库）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBPtr</span> &#123;                        <span class="comment">// 中对象的灵巧指针模板</span></span><br><span class="line"><span class="keyword">public</span>:                              <span class="comment">//</span></span><br><span class="line">  <span class="built_in">DBPtr</span>(T *realPtr = <span class="number">0</span>);             <span class="comment">// 建立灵巧指针，指向</span></span><br><span class="line">                                     <span class="comment">// 由一个本地dumb pointer</span></span><br><span class="line">                                     <span class="comment">// 给出的DB 对象</span></span><br><span class="line">  <span class="built_in">DBPtr</span>(DataBaseID id);              <span class="comment">// 建立灵巧指针，</span></span><br><span class="line">                                     <span class="comment">// 指向一个DB对象，</span></span><br><span class="line">                                     <span class="comment">// 具有惟一的DB识别符</span></span><br><span class="line">&#125;;                                   <span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuple</span> &#123;                        <span class="comment">// 数据库元组类</span></span><br><span class="line"><span class="keyword">public</span>:                            </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">displayEditDialog</span><span class="params">()</span></span>;          <span class="comment">// 显示一个图形对话框，</span></span><br><span class="line">                                     <span class="comment">// 允许用户编辑元组。</span></span><br><span class="line">                                     <span class="comment">// user to edit the tuple</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">()</span> <span class="type">const</span></span>;              <span class="comment">// 返回*this是否通过了</span></span><br><span class="line">&#125;;                                   <span class="comment">// 合法性验证</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个类模板用于在修改T对象时进行日志登记。</span></span><br><span class="line"><span class="comment">// 有关细节参见下面的叙述：</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogEntry</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LogEntry</span>(<span class="type">const</span> T&amp; objectToBeModified);</span><br><span class="line">  ~<span class="built_in">LogEntry</span>();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">editTuple</span><span class="params">(DBPtr&lt;Tuple&gt;&amp; pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">LogEntry&lt;Tuple&gt; <span class="title">entry</span><span class="params">(*pt)</span></span>;        <span class="comment">// 为这个编辑操作登记日志</span></span><br><span class="line">                                     <span class="comment">// 有关细节参见下面的叙述</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 重复显示编辑对话框，直到提供了合法的数值。</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    pt-&gt;<span class="built_in">displayEditDialog</span>();</span><br><span class="line">  &#125; <span class="keyword">while</span> (pt-&gt;<span class="built_in">isValid</span>() == <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>程序员只需关心通过对象进行访问的元组，而不用关心如何声明它们，其行为就像一个内建指针。正如你所看到的，使用灵巧指针与使用dump pointer没有很大的差别。这表明了封装是非常有效的。</p>
<h2 id="灵巧指针的构造、赋值和析构"><a href="#灵巧指针的构造、赋值和析构" class="headerlink" title="灵巧指针的构造、赋值和析构"></a>灵巧指针的构造、赋值和析构</h2><p>灵巧指针的析构通常很简单：<strong>找到指向的对象（一般由灵巧指针构造函数的参数给出），让灵巧指针的内部成员dumb pointer指向它</strong>。如果没有找到对象，把内部指针设为0或发出一个错误信号（可以是抛出一个异常）。</p>
<p>看一下标准C++类库中auto_ptr模板。一个auto_ptr对象是一个指向堆对象的灵巧指针，直到auto_ptr被释放。auto_ptr模板的实作如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">auto_ptr</span>(T *ptr = <span class="number">0</span>): <span class="built_in">pointee</span>(ptr) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">auto_ptr</span>() &#123; <span class="keyword">delete</span> pointee; &#125;</span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T *pointee;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>假如auto_ptr拥有对象时，它可以正常运行。但是当auto_ptr被拷贝或被赋值时，会发生什么情况呢？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;TreeNode&gt; <span class="title">ptn1</span><span class="params">(<span class="keyword">new</span> TreeNode)</span></span>;</span><br><span class="line">auto_ptr&lt;TreeNode&gt; ptn2 = ptn1;      <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">                                     <span class="comment">//会发生什么情况？</span></span><br><span class="line">auto_ptr&lt;TreeNode&gt; ptn3;</span><br><span class="line">ptn3 = ptn2;                         <span class="comment">// 调用 operator=;</span></span><br><span class="line">                                     <span class="comment">// 会发生什么情况?</span></span><br></pre></td></tr></table></figure><br>如果我们只拷贝内部的dumb pointer，会导致两个auto_ptr指向一个相同的对象。这是一个灾难，因为当释放auto_ptr时每个auto_ptr都会删除它们所指的对象。这意味着一个对象会被我们删除两次。</p>
<p>另一种方法是通过调用new，建立一个所指对象的新拷贝。这确保了不会有许多指向同一个对象的auto_ptr，但是建立（以后还得释放）新对象会造成不可接受的性能损耗。并且我们不知道要建立什么类型的对象。如果auto_ptr禁止拷贝和赋值，就可以消除这个问题，但是采用<strong>当auto_ptr被拷贝和赋值时，对象所有权随之被传递</strong>的方法，是一个更具灵活性的解决方案：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">auto_ptr</span>(auto_ptr&lt;T&gt;&amp; rhs);        <span class="comment">// 拷贝构造函数</span></span><br><span class="line"> </span><br><span class="line">  auto_ptr&lt;T&gt;&amp;                       <span class="comment">// 赋值</span></span><br><span class="line">  <span class="keyword">operator</span>=(auto_ptr&lt;T&gt;&amp; rhs);       <span class="comment">// 操作符</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">auto_ptr&lt;T&gt;::<span class="built_in">auto_ptr</span>(auto_ptr&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  pointee = rhs.pointee;             <span class="comment">// 把*pointee的所有权</span></span><br><span class="line">                                     <span class="comment">// 传递到 *this</span></span><br><span class="line">  rhs.pointee = <span class="number">0</span>;                   <span class="comment">// rhs不再拥有</span></span><br><span class="line">&#125;                                    <span class="comment">// 任何东西</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">auto_ptr&lt;T&gt;&amp; auto_ptr&lt;T&gt;::<span class="keyword">operator</span>=(auto_ptr&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)                  <span class="comment">// 如果这个对象自我赋值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                    <span class="comment">// 什么也不要做</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> pointee;                    <span class="comment">// 删除现在拥有的对象</span></span><br><span class="line">  pointee = rhs.pointee;             <span class="comment">// 把*pointee的所有权</span></span><br><span class="line">  rhs.pointee = <span class="number">0</span>;                   <span class="comment">// 从 rhs 传递到 *this</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意赋值操作符在接受新对象的所有权以前必须删除原来拥有的对象。如果不这样做，原来拥有的对象将永远不会被删除。记住，除了auto_ptr对象，没有人拥有auto_ptr指向的对象。</p>
<p>因为当调用auto_ptr的拷贝构造函数时，对象的所有权被传递出去，所以通过传值方式传递auto_ptr对象是一个很糟糕的方法。因为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数通常会导致灾难发生</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTreeNode</span><span class="params">(ostream&amp; s, auto_ptr&lt;TreeNode&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123; s &lt;&lt; *p; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">auto_ptr&lt;TreeNode&gt; <span class="title">ptn</span><span class="params">(<span class="keyword">new</span> TreeNode)</span></span>;</span><br><span class="line">  <span class="built_in">printTreeNode</span>(cout, ptn);          <span class="comment">//通过传值方式传递auto_ptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>当printTreeNode的参数p被初始化时，ptn指向对象的所有权被传递到给了p。当printTreeNode结束执行后，p离开了作用域，<strong>它的析构函数删除它指向的对象</strong>。然而ptr不再指向任何对象，所以调用printTreeNode以后任何试图使用它的操作都将产生不可定义的行为。<strong>只有在你确实想把对象的所有权传递给一个临时的函数参数时，才能通过传值方式传递auto_pt</strong>r。通过const引用传递可以传递，方法是这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数的行为更直观一些</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTreeNode</span><span class="params">(ostream&amp; s,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> auto_ptr&lt;TreeNode&gt;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123; s &lt;&lt; *p; &#125;</span><br></pre></td></tr></table></figure><br>在函数里，p是一个引用，而不是一个对象，所以不会调用拷贝构造函数初始化p。当ptn被传递到上面这个printTreeNode时，它还保留着所指对象的所有权，调用printTreeNode以后还可以安全地使用ptn。</p>
</blockquote>
<p><strong>当拷贝一个对象或这个对象做为赋值的数据源，就会修改该对象</strong>。</p>
<p>灵巧指针的析构函数通常是这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">SmartPtr&lt;T&gt;::~<span class="built_in">SmartPtr</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (*<span class="keyword">this</span> owns *pointee) &#123;</span><br><span class="line">    <span class="keyword">delete</span> pointee;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="实作Dereference-操作符"><a href="#实作Dereference-操作符" class="headerlink" title="实作Dereference 操作符"></a>实作Dereference 操作符</h2><p>让我们把注意力转向灵巧指针的核心部分，<code>the operator*</code>和<code>operator-&gt;</code>函数。理论上，这很简单：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T&amp; SmartPtr&lt;T&gt;::<span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">  perform <span class="string">&quot;smart pointer&quot;</span> processing;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> *pointee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意返回类型是一个引用。必须时刻牢记：<strong>pointee不用必须指向T类型对象；它也可以指向T的派生类对象</strong>。如果在这种情况<code>下operator*</code>函数返回的是T类型对象而不是派生类对象的引用，你的函数实际上返回的是一个错误类型的对象。</p>
<p>operator-&gt;的情况与operator<em>是相同的，但是在分析operator-&gt;之前，让我们先回忆一下这个函数调用的与众不同的含义。再考虑editTuple函数，其使用一个指向Tuple对象的灵巧指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">editTuple</span><span class="params">(DBPtr&lt;Tuple&gt;&amp; pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">LogEntry&lt;Tuple&gt; <span class="title">entry</span><span class="params">(*pt)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    pt-&gt;<span class="built_in">displayEditDialog</span>();</span><br><span class="line">  &#125; <span class="keyword">while</span> (pt-&gt;<span class="built_in">isValid</span>() == <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>语句<code>pt-&gt;displayEditDialog();</code>被编译器解释为：<code>(pt.operator-&gt;())-&gt;displayEditDialog();</code>，这意味着不论<code>operator-&gt;</code>返回什么，它必须使用成员选择操作符（-&gt;）。因此<code>operator-&gt;</code>仅能返回两种东西：<strong>一个指向某对象的dumb pointer</strong>或<em>*另一个灵巧指针</em></em>。多数情况下，你想返回一个普通dumb pointer。在此情况下，你这样实作operator-&gt; ：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T* SmartPtr&lt;T&gt;::<span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">  perform <span class="string">&quot;smart pointer&quot;</span> processing;</span><br><span class="line">  <span class="keyword">return</span> pointee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样做运行良好。因为该函数返回一个指针，通过operator-&gt;调用虚拟函数，其行为也是正确的。</p>
<h2 id="测试灵巧指针是否为NULL"><a href="#测试灵巧指针是否为NULL" class="headerlink" title="测试灵巧指针是否为NULL"></a>测试灵巧指针是否为NULL</h2><p>目前为止我们讨论的函数能让我们建立、释放、拷贝、赋值、dereference灵巧指针。但是有一件我们做不到的事情是“发现灵巧指针为NULL”：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr&lt;TreeNode&gt; ptn;</span><br><span class="line"><span class="keyword">if</span> (ptn == <span class="number">0</span>) ...                    <span class="comment">// error!</span></span><br><span class="line"><span class="keyword">if</span> (ptn) ...                         <span class="comment">// error!</span></span><br><span class="line"><span class="keyword">if</span> (!ptn) ...                        <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><br>这是一个严重的限制。</p>
<p>在灵巧指针类里加入一个isNull成员函数是一件很容易的事，但是仍然没有解决当测试NULL时灵巧指针的行为与dumb pointer不相似的问题。另一种方法是提供隐式类型转换操作符，允许编译上述的测试。一般应用于这种目的的类型转换是void* ：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">operator</span> <span class="type">void</span>*();                  <span class="comment">// 如果灵巧指针为null，返回0，否则返回非0。</span></span><br><span class="line">&#125;</span><br><span class="line">SmartPtr&lt;TreeNode&gt; ptn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptn == <span class="number">0</span>) ...                    <span class="comment">// 现在正确</span></span><br><span class="line"><span class="keyword">if</span> (ptn) ...                         <span class="comment">// 也正确</span></span><br><span class="line"><span class="keyword">if</span> (!ptn) ...                        <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></p>
<p>这与iostream类中提供的类型转换相同，所以可以这样编写代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">inputFile</span><span class="params">(<span class="string">&quot;datafile.dat&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (inputFile) ...                   <span class="comment">// 测试inputFile是否已经被成功地打开。</span></span><br></pre></td></tr></table></figure><br>象所有的类型转换函数一样，它有一个缺点，在一些情况下虽然大多数程序员希望它调用失败，但是函数还能够成功地被调用。特别是它允许灵巧指针与完全不同的类型之间进行比较：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr&lt;Apple&gt; pa;</span><br><span class="line">SmartPtr&lt;Orange&gt; po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pa == po) ...                    <span class="comment">// 这能够被成功编译!</span></span><br></pre></td></tr></table></figure><br>即使在<code>SmartPtr&lt;Apple&gt;</code> 和<code>SmartPtr&lt;Orange&gt;</code>之间没有operator= 函数，也能够编译，因为<strong>灵巧指针被隐式地转换为void*指针</strong>，对于内建指针类型有一个内建的比较函数。这种进行隐式类型转换的行为特性很危险。</p>
<p>有一种两全之策可以提供合理的测试空值的语法形式，这就是<strong>在灵巧指针类中重载<code>operator!</code></strong>，当且仅当灵巧指针是一个空指针时，<code>operator!</code>返回true：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>!() <span class="type">const</span>;            <span class="comment">// 当且仅当灵巧指针是</span></span><br><span class="line">  ...                                <span class="comment">// 空值，返回true。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>客户端程序如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr&lt;TreeNode&gt; ptn;</span><br><span class="line"><span class="keyword">if</span> (!ptn) &#123;                          <span class="comment">// 正确</span></span><br><span class="line">  ...                                <span class="comment">// ptn 是空值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  ...                                <span class="comment">// ptn不是空值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但是这样就不正确了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptn == <span class="number">0</span>) ...                    <span class="comment">// 仍然错误</span></span><br><span class="line"><span class="keyword">if</span> (ptn) ...                         <span class="comment">// 也是错误的</span></span><br></pre></td></tr></table></figure><br>仅在这种情况下会存在不同类型之间进行比较：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr&lt;Apple&gt; pa;</span><br><span class="line">SmartPtr&lt;Orange&gt; po;</span><br><span class="line"><span class="keyword">if</span> (!pa == !po) ...                 <span class="comment">// 能够编译</span></span><br></pre></td></tr></table></figure></p>
<p>通过成员模板来实现灵巧指针的类型转换有两个缺点。第一，<strong>支持成员模板的编译器较少</strong>，所以这种技术不具有可移植性。第二，这种方法的工作原理不很明了，要理解它必须先要深入理解函数调用的参数匹配，隐式类型转换函数，模板函数隐式实例化和成员函数模板。正如Daniel Edelson所说，灵巧指针固然灵巧，但不是指针。最好的方法是<strong>使用成员模板生成类型转换函数，在会产生二义性结果的地方使用casts</strong>。</p>
<h2 id="灵巧指针和const"><a href="#灵巧指针和const" class="headerlink" title="灵巧指针和const"></a>灵巧指针和const</h2><p>对于dumb指针来说，const既可以针对指针所指向的东西，也可以针对于指针本身，或者兼有两者的含义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CD <span class="title">goodCD</span><span class="params">(<span class="string">&quot;Flood&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> CD *p;                         <span class="comment">// p 是一个non-const 指针</span></span><br><span class="line">                                     <span class="comment">//指向 const CD 对象</span></span><br><span class="line">CD * <span class="type">const</span> p = &amp;goodCD;              <span class="comment">// p 是一个const 指针</span></span><br><span class="line">                                     <span class="comment">// 指向non-const CD 对象;</span></span><br><span class="line">                                     <span class="comment">// 因为 p 是const, 它</span></span><br><span class="line">                                     <span class="comment">// 必须被初始化</span></span><br><span class="line"><span class="type">const</span> CD * <span class="type">const</span> p = &amp;goodCD;        <span class="comment">// p 是一个const 指针</span></span><br><span class="line">                                     <span class="comment">// 指向一个 const CD 对象</span></span><br></pre></td></tr></table></figure><br>我们自然想要让灵巧指针具有同样的灵活性。不幸的是只能在一个地方放置const，并只能对指针本身起作用，而不能针对于所指对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> SmartPtr&lt;CD&gt; p =                <span class="comment">// p 是一个const 灵巧指针</span></span><br><span class="line">  &amp;goodCD;                             <span class="comment">// 指向 non-const CD 对象</span></span><br></pre></td></tr></table></figure><br>好像有一个简单的补救方法，就是建立一个指向cosnt CD的灵巧指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr&lt;<span class="type">const</span> CD&gt; p =            <span class="comment">// p 是一个 non-const 灵巧指针</span></span><br><span class="line">  &amp;goodCD;                        <span class="comment">// 指向const CD 对象</span></span><br></pre></td></tr></table></figure><br>现在我们可以建立const和non-const对象和指针的四种不同组合：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr&lt;CD&gt; p;                          <span class="comment">// non-const 对象</span></span><br><span class="line">                                         <span class="comment">// non-const 指针</span></span><br><span class="line"></span><br><span class="line">SmartPtr&lt;<span class="type">const</span> CD&gt; p;                    <span class="comment">// const 对象,</span></span><br><span class="line">                                         <span class="comment">// non-const 指针</span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> SmartPtr&lt;CD&gt; p = &amp;goodCD;          <span class="comment">// non-const 对象</span></span><br><span class="line">                                         <span class="comment">// const指针</span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> SmartPtr&lt;<span class="type">const</span> CD&gt; p = &amp;goodCD;    <span class="comment">// const 对象</span></span><br><span class="line">                                         <span class="comment">// const 指针</span></span><br></pre></td></tr></table></figure><br>但是美中不足的是，使用dumb指针我们能够用non-const指针初始化const指针，我们也能用指向non-cosnt对象的指针初始化指向const对象的指针；就像进行赋值一样。例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CD *pCD = new CD(&quot;Famous Movie Themes&quot;);</span><br><span class="line">const CD * pConstCD = pCD;               // 正确</span><br></pre></td></tr></table></figure><br>但是如果我们试图把这种方法用在灵巧指针上，情况会怎么样呢？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr&lt;CD&gt; pCD = <span class="keyword">new</span> <span class="built_in">CD</span>(<span class="string">&quot;Famous Movie Themes&quot;</span>);</span><br><span class="line">SmartPtr&lt;<span class="type">const</span> CD&gt; pConstCD = pCD;       <span class="comment">// 正确么?</span></span><br></pre></td></tr></table></figure><br><code>SmartPtr&lt;CD&gt;</code>与<code>SmartPtr&lt;const CD&gt;</code>是完全不同的类型。在编译器看来，它们是毫不相关的，所以没有理由相信它们是赋值兼容的。到目前为止这是一个老问题了，把它们变成赋值兼容的惟一方法是你<strong>必须提供函数，用来把SmartPtr<CD>类型的对象转换成SmartPtr<const CD>类型</strong>。如果你使用的编译器支持成员模板，就可以利用前面所说的技巧自动生成你需要的隐式类型转换操作。</p>
<p>包括const的类型转换是单向的：<strong>从non-const到const的转换是安全的，但是从const到non-const则不是安全的</strong>。而且用const指针能的事情，用non-const指针也能做，但是用non-const指针还能做其它一些事情。同样，用指向const的指针能做的任何事情，用指向non-const的指针也能做到，但是用指向non-const的指针能够完成一些使用指向const的指针所不能完成的事情。</p>
<p>这些规则看起来与public继承的规则相类似。你能够把一个派生类对象转换成基类对象，但是反之则不是这样，你对基类所做的任何事情对派生类也能做，但是还能对派生类做另外一些事情。我们能够利用这一点来实作灵巧指针，就是说可以让每个指向T的灵巧指针类public派生自一个对应的指向const-T的灵巧指针类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;                    <span class="comment">// 指向const对象的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtrToConst</span> &#123;              <span class="comment">// 灵巧指针</span></span><br><span class="line">  ...                                <span class="comment">// 灵巧指针通常的</span></span><br><span class="line">                                     <span class="comment">// 成员函数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="type">const</span> T* constPointee;           <span class="comment">// 让 SmartPtrToConst 访问</span></span><br><span class="line">    T* pointee;                      <span class="comment">// 让 SmartPtr 访问</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;                    <span class="comment">// 指向non-const对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span>:                      <span class="comment">// 的灵巧指针</span></span><br><span class="line">  <span class="keyword">public</span> SmartPtrToConst&lt;T&gt; &#123;</span><br><span class="line">  ...                                <span class="comment">// 没有数据成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>使用这种设计方法，<strong>指向non-const-T对象的灵巧指针包含一个指向const-T的dumb指针，指向const-T的灵巧指针需要包含一个指向cosnt-T的dumb指针</strong>。最方便的方法是<strong>把指向const-T的dumb指针放在基类里，把指向non-const-T的dumb指针放在派生类里</strong>，然而这样做有些浪费，因为SmartPtr对象包含两个dumb指针:一个是从SmartPtrToConst继承来的，一个是SmartPtr自己的。</p>
<p>一种在C世界里的老式武器可以解决这个问题，这就是union，它在C++中同样有用。Union在protected中，所以两个类都可以访问它，它包含两个必须的dumb指针类型，<code>SmartPtrToConst&lt;T&gt;</code>对象使用constPointee指针，<code>SmartPtr&lt;T&gt;</code>对象使用pointee指针。因此我们可以在不分配额外空间的情况下，使用两个不同的指针。</p>
<p>利用这种新设计，我们能够获得所要的行为特性：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr&lt;CD&gt; pCD = <span class="keyword">new</span> <span class="built_in">CD</span>(<span class="string">&quot;Famous Movie Themes&quot;</span>);</span><br><span class="line">SmartPtrToConst&lt;CD&gt; pConstCD = pCD;     <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></p>
<h1 id="条款29：引用计数"><a href="#条款29：引用计数" class="headerlink" title="条款29：引用计数"></a>条款29：引用计数</h1><p>引用计数<strong>允许多个有相同值的对象共享这个值的实现</strong>。这个技巧：</p>
<ul>
<li>简化跟踪堆中的对象的过程。引用计数可以免除跟踪对象所有权的担子，对象自己拥有自己。当没人再使用它时，它自己自动销毁自己。因此，引用计数是个简单的垃圾回收体系。</li>
<li>让所有的对象共享这个值的实现。这么做不但节省内存，而且可以使得程序运行更快，因为不需要构造和析构这个值的拷贝。</li>
</ul>
<p>保存当前共享/引用同一个值的对象数目的需求意味着我们必须增加一个计数值（引用计数）。</p>
<p>所以我们将创建一个类来保存引用计数及其跟踪的值。我们叫这个类StringValue，又因为它唯一的用处就是帮助我们实现String类，所以我们将它嵌套在String类的私有区内。另外，为了便于String的所有成员函数读取其数据区，我们将StringValue申明为struct。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">StringValue</span> &#123; ... &#125;;        <span class="comment">// holds a reference count</span></span><br><span class="line">                                     <span class="comment">// and a string value</span></span><br><span class="line">  StringValue *value;                <span class="comment">// value of this String</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这是StringValue的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">StringValue</span> &#123;</span><br><span class="line">      <span class="type">int</span> refCount;</span><br><span class="line">      <span class="type">char</span> *data;</span><br><span class="line">      <span class="built_in">StringValue</span>(<span class="type">const</span> <span class="type">char</span> *initValue);</span><br><span class="line">      ~<span class="built_in">StringValue</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">String::StringValue::<span class="built_in">StringValue</span>(<span class="type">const</span> <span class="type">char</span> *initValue)</span><br><span class="line">: <span class="built_in">refCount</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(initValue) + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(data, initValue);</span><br><span class="line">&#125;</span><br><span class="line">String::StringValue::~<span class="built_in">StringValue</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">delete</span> [] data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>StringValue的主要目的是提供一个空间将一个特别的值和共享此值的对象的数目联系起来。接下来是String的成员函数，首先是构造函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *initValue = <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> String&amp; rhs);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>第一个构造函数被实现得尽可能简单。我们用传入的<code>char *</code>字符串创建了一个新的StringValue对象，并将我们正在构造的string对象指向这个新生成的StringValue：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *initValue)</span><br><span class="line">: <span class="built_in">value</span>(<span class="keyword">new</span> <span class="built_in">StringValue</span>(initValue))</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>String的拷贝构造函数很高效：新生成的String对象与被拷贝的对象共享相同的StringValue对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> String&amp; rhs)</span><br><span class="line">: <span class="built_in">value</span>(rhs.value)</span><br><span class="line">&#123;</span><br><span class="line">  ++value-&gt;refCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这肯定比通常的string类高效，因为不需要为新生成的string值分配内存、释放内存以及将内容拷贝入这块内存。</p>
<p>String类的析构函数同样容易实现，因为大部分情况下它不需要做任何事情。只要引用计数值不是0，也就是至少有一个String对象使用这个值，这个值就不可以被销毁。只有当唯一的使用者被析构了，String的析构函数才摧毁StringValue对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">String</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">String::~<span class="built_in">String</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (--value-&gt;refCount == <span class="number">0</span>) <span class="keyword">delete</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这就是String的构造和析构，我们现在转到赋值操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp; rhs);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>当用户写下这样的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 = s2;                              <span class="comment">// s1 and s2 are both String objects</span></span><br></pre></td></tr></table></figure><br>其结果应该是s1和s2指向相同的StringValue对象。对象的引用计数应该在赋值时被增加。并且，<strong>s1原来指向的StringValue对象的引用计数应该减少</strong>，因为s1不再具有这个值了。如果s1是拥有原来的值的唯一对象，这个值应该被销毁。在C++中，其实现看起来是这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (value == rhs.value) &#123;          <span class="comment">// do nothing if the values</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                    <span class="comment">// are already the same; this</span></span><br><span class="line">  &#125;                                  <span class="comment">// subsumes the usual test of</span></span><br><span class="line">                                     <span class="comment">// this against &amp;rhs</span></span><br><span class="line">  <span class="keyword">if</span> (--value-&gt;refCount == <span class="number">0</span>) &#123;      <span class="comment">// destroy *this&#x27;s value if</span></span><br><span class="line">    <span class="keyword">delete</span> value;                    <span class="comment">// no one else is using it</span></span><br><span class="line">  &#125;</span><br><span class="line">  value = rhs.value;                 <span class="comment">// have *this share rhs&#x27;s</span></span><br><span class="line">  ++value-&gt;refCount;                 <span class="comment">// value</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h2><p>围绕我们的带引用计数的String类，考虑一下数组下标操作（[]），它允许字符串中的单个字符被读或写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span>;       <span class="comment">// for const Strings</span></span><br><span class="line">  <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index);           <span class="comment">// for non-const Strings</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这个函数的const版本的实现很容易，因为它是一个只读操作，String对象的值不受影响：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> value-&gt;data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>非const的operator[]版本就是一个完全不同的故事了。它可能是被调用了来读一个字符，也可能被调用了来写一个字符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s;</span><br><span class="line">...</span><br><span class="line">cout &lt;&lt; s[<span class="number">3</span>];                        <span class="comment">// this is a read</span></span><br><span class="line">s[<span class="number">5</span>] = <span class="string">&#x27;x&#x27;</span>;                          <span class="comment">// this is a write</span></span><br></pre></td></tr></table></figure></p>
<p>我们必须保守地假设“所有”调用非<code>const operator[]</code>的行为都是为了写操作。为了安全地实现非const的<code>operator[]</code>，我们必须确保没有其它String对象在共享这个可能被修改的StringValue对象。简而言之，当我们返回StringValue对象中的一个字符的引用时，必须确保这个StringValue的引用计数是1。这儿是我们的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="type">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// if we&#x27;re sharing a value with other String objects,</span></span><br><span class="line">  <span class="comment">// break off a separate copy of the value for ourselves</span></span><br><span class="line">  <span class="keyword">if</span> (value-&gt;refCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    --value-&gt;refCount;                    <span class="comment">// decrement current value&#x27;s</span></span><br><span class="line">                                          <span class="comment">// refCount, because we won&#x27;t</span></span><br><span class="line">                                          <span class="comment">// be using that value any more</span></span><br><span class="line">    value =                               <span class="comment">// make a copy of the</span></span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">StringValue</span>(value-&gt;data);       <span class="comment">// value for ourselves</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// return a reference to a character inside our</span></span><br><span class="line">  <span class="comment">// unshared StringValue object</span></span><br><span class="line">  <span class="keyword">return</span> value-&gt;data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="指针、引用与写时拷贝"><a href="#指针、引用与写时拷贝" class="headerlink" title="指针、引用与写时拷贝"></a>指针、引用与写时拷贝</h2><p>大部分情况下，写时拷贝可以同时保证效率和正确性。只有一个挥之不去的问题。看一下这样的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p = &amp;s1[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></p>
<p>现在看增加一条语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s2 = s1;</span><br></pre></td></tr></table></figure><br>String的拷贝构造函数使得s2共享s1的StringValue对象，下面这样的语句将有不受欢迎的结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*p = <span class="string">&#x27;x&#x27;</span>;                     <span class="comment">// modifies both s1 and s2!</span></span><br></pre></td></tr></table></figure><br>String的拷贝构造函数没有办法检测这样的问题，因为它不知道指向s1拥有的StringValue对象的指针的存在。并且，这个问题不局限于指针：它同样存在于有人保存了一个String的非<code>const operator[]</code>的返回值的引用的情况下。</p>
<p>解决的方法是这样的：在每个StringValue对象中增加一个标志以指出它是否为可共享的。在最初（对象可共享时）将标志打开，在非const的<code>operator[]</code>被调用时将它关闭。一旦标志被设为false，它将永远保持在这个状态。</p>
<p>这是增加了共享标志的修改版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">StringValue</span> &#123;</span><br><span class="line">    <span class="type">int</span> refCount;</span><br><span class="line">    <span class="type">bool</span> shareable;                <span class="comment">// add this</span></span><br><span class="line">    <span class="type">char</span> *data;</span><br><span class="line">    <span class="built_in">StringValue</span>(<span class="type">const</span> <span class="type">char</span> *initValue);</span><br><span class="line">    ~<span class="built_in">StringValue</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">String::StringValue::<span class="built_in">StringValue</span>(<span class="type">const</span> <span class="type">char</span> *initValue)</span><br><span class="line">:   <span class="built_in">refCount</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="built_in">shareable</span>(<span class="literal">true</span>)                <span class="comment">// add this</span></span><br><span class="line">&#123;</span><br><span class="line">  data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(initValue) + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(data, initValue);</span><br><span class="line">&#125;</span><br><span class="line">String::StringValue::~<span class="built_in">StringValue</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">delete</span> [] data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如上所见，并不需要太多的改变；需要修改的两行都有注释。当然，String的成员函数也必须被修改以处理这个共享标志。这里是拷贝构造函数的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (rhs.value-&gt;shareable) &#123;</span><br><span class="line">    value = rhs.value;</span><br><span class="line">    ++value-&gt;refCount;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    value = <span class="keyword">new</span> <span class="built_in">StringValue</span>(rhs.value-&gt;data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>所有其它的成员函数也都必须以类似的方法检查这个共享标志。非const的operator[]版本是唯一将共享标志设为false的地方：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="type">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (value-&gt;refCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    --value-&gt;refCount;</span><br><span class="line">    value = <span class="keyword">new</span> <span class="built_in">StringValue</span>(value-&gt;data);</span><br><span class="line">  &#125;</span><br><span class="line">  value-&gt;shareable = <span class="literal">false</span>;           <span class="comment">// add this</span></span><br><span class="line">  <span class="keyword">return</span> value-&gt;data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="带引用计数的基类"><a href="#带引用计数的基类" class="headerlink" title="带引用计数的基类"></a>带引用计数的基类</h2><p>将引用计数的代码写成与运行环境无关的，第一步是构建一个基类<strong>RCObject</strong>，任何需要引用计数的类都必须从它继承。RCObject<strong>封装了引用计数功能</strong>，如增加和减少引用计数的函数。它还包含了当这个值不再被需要时摧毁值对象的代码。最后，它包含了一个字段以跟踪这个值对象是否可共享，并提供查询这个值和将它设为false的函数。不需将可共享标志设为true的函数，因为所有的值对象默认都是可共享的。如上面说过的，<strong>一旦一个对象变成了不可共享，将没有办法使它再次成为可共享</strong>。RCObject的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RCObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">RCObject</span>();</span><br><span class="line">  <span class="built_in">RCObject</span>(<span class="type">const</span> RCObject&amp; rhs);</span><br><span class="line">  RCObject&amp; <span class="keyword">operator</span>=(<span class="type">const</span> RCObject&amp; rhs);</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">RCObject</span>() = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">addReference</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">removeReference</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">markUnshareable</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isShareable</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isShared</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> refCount;</span><br><span class="line">  <span class="type">bool</span> shareable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>RCObjcet可以被构造（作为派生类的基类部分）和析构；可以有新的引用加在上面以及移除当前引用；其可共享性可以被查询以及被禁止；它们可以报告当前是否被共享了。这就是它所提供的功能。对于想有引用计数的类，这确实就是我们所期望它们完成的东西。注意虚析构函数，它明确表明这个类是被设计了作基类使用的。同时要注意这个析构函数是纯虚的，它明确表明这个类只能作基类使用。</p>
<p>RCOject的实现代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RCObject::<span class="built_in">RCObject</span>()</span><br><span class="line">: <span class="built_in">refCount</span>(<span class="number">0</span>), <span class="built_in">shareable</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">RCObject::<span class="built_in">RCObject</span>(<span class="type">const</span> RCObject&amp;)</span><br><span class="line">: <span class="built_in">refCount</span>(<span class="number">0</span>), <span class="built_in">shareable</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">RCObject&amp; RCObject::<span class="keyword">operator</span>=(<span class="type">const</span> RCObject&amp;)</span><br><span class="line">&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">RCObject::~<span class="built_in">RCObject</span>() &#123;&#125;               <span class="comment">// virtual dtors must always</span></span><br><span class="line">                                       <span class="comment">// be implemented, even if</span></span><br><span class="line">                                       <span class="comment">// they are pure virtual</span></span><br><span class="line">                                       <span class="comment">// and do nothing</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RCObject::addReference</span><span class="params">()</span> </span>&#123; ++refCount; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RCObject::removeReference</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="keyword">if</span> (--refCount == <span class="number">0</span>) <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RCObject::markUnshareable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; shareable = <span class="literal">false</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RCObject::isShareable</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> shareable; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RCObject::isShared</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> refCount &gt; <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure></p>
<p>为了使用我们新写的引用计数基类，我们将StringValue修改为是从RCObject继承而得到引用计数功能的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">StringValue</span>: <span class="keyword">public</span> RCObject &#123;</span><br><span class="line">    <span class="type">char</span> *data;</span><br><span class="line">    <span class="built_in">StringValue</span>(<span class="type">const</span> <span class="type">char</span> *initValue);</span><br><span class="line">    ~<span class="built_in">StringValue</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">String::StringValue::<span class="built_in">StringValue</span>(<span class="type">const</span> <span class="type">char</span> *initValue)</span><br><span class="line">&#123;</span><br><span class="line">  data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(initValue) + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(data, initValue);</span><br><span class="line">&#125;</span><br><span class="line">String::StringValue::~<span class="built_in">StringValue</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">delete</span> [] data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个版本的StringValue和前面的几乎一样，唯一改变的就是StringValue的成员函数不再处理refCount字段。RCObject现在接管了这个工作。</p>
<p>实现引用计数不是没有代价的。每个被引用的值带一个引用计数，其大部分操作都需要以某种形式检查或操作引用计数。对象的值需要更多的内存，而我们在处理它们时需要执行更多的代码。此外，就内部的源代码而言，带引用计数的类的复杂度比不带的版本高。没有引用计数的String类只依赖于自己，而我们最终的String类如果没有三个辅助类（StringValue、RCObject和RCPtr）就无法使用。</p>
<p>总之，引用计数在下列情况下对提高效率很有用：</p>
<ul>
<li>少量的值被大量的对象共享。这样的共享通常通过调用赋值操作和拷贝构造而发生。对象/值的比例越高，越是适宜使用引用计数。</li>
<li>对象的值的创建和销毁代价很高昂，或它们占用大量的内存。即使这样，如果不是多个对象共享相同的值，引用计数仍然帮不了你任何东西。</li>
</ul>
<h1 id="条款30：代理类-Proxy-classes"><a href="#条款30：代理类-Proxy-classes" class="headerlink" title="条款30：代理类(Proxy classes)"></a>条款30：代理类(Proxy classes)</h1><p>所谓代理类(proxy class),指的是<strong>它的每一个对象都是为了其他对象而存在的,就像是其他对象的代理人一般</strong>。某些情况下用代理类取代某些内置类型可以实现独特的功能,因为可以为代理类定义成员函数而但却无法对内置类型定义操作。</p>
<p>C++没有提供分配动态二维数组的语法,因此常常需要定义一些类(模板实现这些功能),像这样:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array2D</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array2D</span>(<span class="type">int</span> dim1, <span class="type">int</span> dim2);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>既然是二维数组，那么有必要提供使用”[][]”访问元素的操作，然而[][]并不是一个操作符，C++也就不允许重载一个operator[][]，解决办法就是采用代理类,像这样:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array2D</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//代理类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Array1D</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index);</span><br><span class="line">        <span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span>;</span><br><span class="line">    ...</span><br><span class="line">    &#125;;</span><br><span class="line">    Array1D <span class="keyword">operator</span>[](<span class="type">int</span> index);</span><br><span class="line">    <span class="type">const</span> Array1D <span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>那么以下操作:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Array2D&lt;<span class="type">float</span>&gt; <span class="title">data</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line">cout &lt;&lt; data[<span class="number">3</span>][<span class="number">6</span>];</span><br></pre></td></tr></table></figure><br><code>data[3][6]</code>实际上进行了两次函数调用：第一次调用Array2D的<code>operator[]</code>，返回Array1D对象,第二次调用Array1D的<code>operator[]</code>，返回指定元素。</p>
<h2 id="区分operator-的读写动作"><a href="#区分operator-的读写动作" class="headerlink" title="区分operator[]的读写动作"></a>区分operator[]的读写动作</h2><p>条款29用String类的例子讨论了引用计数，由于当时无法判断non-const版本<code>oeprator[]</code>返回的字符将被用于读操作还是写操作，因此保险起见，一旦调用non-const版本<code>operator[]</code>，便开辟一块新内存并复制数据结构到新内存。在这种策略下，因此如果<code>operator[]</code>返回的字符被用于读操作，那么分配新内存并复制数据结构的行为其实是不必要的，由此会带来效率损失，使用proxy class便可以做到区分non-const <code>operator[]</code>用于读还是写操作，在 proxy 类上只能做三件事：</p>
<ul>
<li>创建它，也就是指定它扮演哪个字符。</li>
<li>将它作为赋值操作的目标，在这种情况下可以将赋值真正作用在它扮演的字符上。这样被使用时，proxy 类扮演的是左值。</li>
<li>用其它方式使用它。这时，代理类扮演的是右值。 </li>
</ul>
<p>像这样:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//代理类用于区分operator[]的读写操作</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CharProxy</span> &#123; <span class="comment">// proxies for string chars</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">CharProxy</span>(String&amp; str, <span class="type">int</span> index); <span class="comment">// creation</span></span><br><span class="line">        CharProxy&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CharProxy&amp; rhs); <span class="comment">// lvalue</span></span><br><span class="line">        CharProxy&amp; <span class="keyword">operator</span>=(<span class="type">char</span> c); <span class="comment">// uses</span></span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">char</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        String&amp; theString; <span class="comment">//用于操作String,并在适当时机开辟新内存并复制</span></span><br><span class="line">        <span class="type">int</span> charIndex;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">const</span> CharProxy <span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span>; <span class="comment">// for const Strings</span></span><br><span class="line">    CharProxy <span class="keyword">operator</span>[](<span class="type">int</span> index); <span class="comment">// for non-const Strings</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">CharProxy</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RCPtr&lt;StringValue&gt; value;<span class="comment">//见条款29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>对String调用<code>operator[]</code>将返回CharProxy对象，CharProxy通过重载oeprator char模拟char类型的行为，但它比char类型更有优势——可以为CharProxy定义新的操作，这样当对CharProxy使用operator=时，便可以得知对CharProxy进行写操作，由于CHarProxy保存了父对象String的一个引用，便可以在现在执行开辟内存并复制数据结构的行为，像这样:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String::CharProxy&amp; String::CharProxy::<span class="keyword">operator</span>=(<span class="type">const</span> CharProxy&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (theString.value-&gt;<span class="built_in">isShared</span>()) &#123;</span><br><span class="line">        theString.value = <span class="keyword">new</span> <span class="built_in">StringValue</span>(theString.value-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    theString.value-&gt;data[charIndex] = rhs.theString.value-&gt;data[rhs.charIndex];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">String::CharProxy&amp; String::CharProxy::<span class="keyword">operator</span>=(<span class="type">char</span> c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (theString.value-&gt;<span class="built_in">isShared</span>()) &#123;</span><br><span class="line">        theString.value = <span class="keyword">new</span> <span class="built_in">StringValue</span>(theString.value-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    theString.value-&gt;data[charIndex] = c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上来那个函数的代码部分有重复，可考虑将重复部分提取成一个函数</span></span><br></pre></td></tr></table></figure>
<p>由于内存开辟和数据结构赋值任务交由CharProxy完成，String的operator[]相当简单，像这样:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> String::CharProxy String::<span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CharProxy</span>(<span class="built_in">const_cast</span>&lt;String&amp;&gt;(*<span class="keyword">this</span>), index);</span><br><span class="line">&#125;</span><br><span class="line">String::CharProxy String::<span class="keyword">operator</span>[](<span class="type">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CharProxy</span>(*<span class="keyword">this</span>, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>CharProxy实现的其他部分如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String::CharProxy::<span class="built_in">CharProxy</span>(String&amp; str, <span class="type">int</span> index): <span class="built_in">theString</span>(str), <span class="built_in">charIndex</span>(index) &#123;&#125;</span><br><span class="line">String::<span class="function">CharProxy::<span class="keyword">operator</span> <span class="title">char</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> theString.value-&gt;data[charIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性."></a>局限性.</h2><p>就像智能指针永远无法完全取代内置指针一样，proxy class也永远无法模仿内置类型的所有特点.proxy class可以实现内置类型无法做到功能，但有利有弊——为了模仿内置类型的其他特点，它还要打许多”补丁”.</p>
<ul>
<li>对proxy class取址.<ul>
<li>条款29通过为StringValue类添加可共享标志(flag)来表示对象是否可被共享以防止外部指针的篡改，其中涉及到对operator[]返回值进行取址操作，这就提示CharProxy也需要对operator&amp;进行重载，像这样:</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CharProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">char</span> * <span class="keyword">operator</span>&amp;();</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> * <span class="keyword">operator</span>&amp;() <span class="type">const</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>const版本operator&amp;实现比较容易:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> * String::CharProxy::<span class="keyword">operator</span>&amp;() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(theString.value-&gt;data[charIndex]);</span><br><span class="line">&#125;</span><br><span class="line">    non-<span class="type">const</span>版本的<span class="keyword">operator</span>&amp;要做的事情多一些:</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * String::CharProxy::<span class="keyword">operator</span>&amp;()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果正在使用共享内存，就开辟新内存并复制数据结构</span></span><br><span class="line">    <span class="keyword">if</span> (theString.value-&gt;<span class="built_in">isShared</span>()) &#123;</span><br><span class="line">        theString.value = <span class="keyword">new</span> <span class="built_in">StringValue</span>(theString.value-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由于有外部指针指向它，因此有被篡改风险，禁止使用共享内存</span></span><br><span class="line">    theString.value-&gt;<span class="built_in">markUnshareable</span>();</span><br><span class="line">    <span class="keyword">return</span> &amp;(theString.value-&gt;data[charIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将proxy class传递给接受”references to non-const objects”的函数.</li>
</ul>
<p>假设有一个swap函数用于对象两个char的内容:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">char</span>&amp; a, <span class="type">char</span>&amp; b)</span></span>;</span><br></pre></td></tr></table></figure><br>那么将无法将CharProxy做参数传递给swap，因为swap的参数是char&amp;，尽管CharProxy可以转换到char，但由于抓换后的char是临时对象，仍然无法绑定到char&amp;，解决方法似乎只有对swap进行重载.</p>
<ul>
<li><p>通过proxy cobjects调用真实对象的member function.</p>
<ul>
<li>如果proxy class的作用是用来取代内置类型，那么它必须也应该对内置类型能够进行的操作进行重载，如++，+=等，如果它用来取代类类型，那么它也必须具有相同成员函数，使得对该类类型能够进行的操作同样也能够施行于proxy class.</li>
</ul>
</li>
<li><p>隐式类型转换.</p>
<ul>
<li>proxy class要具有和被代理类型相同的行为，通常的做法是重载隐式转换操作符，正如条款5对proxy class的使用那样，proxy class可以利用”用户定制的隐式类型转换不能连续实行两次”的特点阻止不必要的隐式类型转换，proxy class同样可能因为这个特点而阻止用户需要的隐式类型转换.</li>
</ul>
</li>
</ul>
<p>proxy class的作用很强大，像上面所提到的实现多维数组，区分operator[]的读写操作，压抑隐式类型转换等，但是也有其缺点，如果函数返回proxy class对象，那么它生成一个临时对象，产生和销毁它就有可能带来额外的构造和析构成本，此外正如4所讲，proxy class无法完全代替真正对象的行为，尽管大多数情况下真正对象的操作都可由proxy class完成.</p>
<h1 id="条款31：让函数根据一个以上的对象来决定怎么虚拟"><a href="#条款31：让函数根据一个以上的对象来决定怎么虚拟" class="headerlink" title="条款31：让函数根据一个以上的对象来决定怎么虚拟"></a>条款31：让函数根据一个以上的对象来决定怎么虚拟</h1><p>问题来源：假设正在编写一个小游戏，游戏的背景是发生在太空，有宇宙飞船、太空船和小行星，它们可能会互相碰撞，而且其碰撞的规则不同，如何用C++代码处理物体间的碰撞。代码的框架如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameObject</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpaceShip</span>:<span class="keyword">public</span> GameObject&#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpaceStation</span>:<span class="keyword">public</span> GameObject&#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Asteroid</span>:<span class="keyword">public</span> GameObject&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkForCollision</span><span class="params">(GameObject&amp; obj1,GameObject&amp; obj2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">theyJustCollided</span>(obj1,obj2))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">processCollision</span>(obj1,obj2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>正如上述代码所示，当调用processCollision()时，obj1和obj2的碰撞结果取决于obj1和obj2的真实类型，但我们只知道它们是GameObject对象。相当于我们需要一种<strong>作用在多个对象上的虚函数</strong>。这类型问题，在C++中被称为<strong>二重调度问题</strong>，下面介绍几种方法解决二重调度问题。</p>
<h2 id="虚函数加RTTI"><a href="#虚函数加RTTI" class="headerlink" title="虚函数加RTTI"></a>虚函数加RTTI</h2><p>虚函数实现了一个单一调度，我们只需要实现另一调度。其具体实现方法：<strong>将processCollision()定义为虚函数，解决一重调度，然后只需要检测一个对象类型，利用RTTI来检测对象的类型，再利用if…else语句来调用不同的处理方法</strong>。具体实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameObject</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpaceShip</span>:<span class="keyword">public</span> GameObject&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherObject)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollisionWithUnknownObject</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CollisionWithUnknownObject</span>(GameObject&amp; whatWehit);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpaceShip::collide</span><span class="params">(GameObject&amp; otherObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> type_info&amp; objectType = <span class="built_in">typeid</span>(otherObject);</span><br><span class="line">    <span class="keyword">if</span>(objectType == <span class="built_in">typeid</span>(SpaceShip))</span><br><span class="line">    &#123;</span><br><span class="line">        SpaceShip&amp; ss = <span class="built_in">static_cast</span>&lt;SpaceShip&amp;&gt;(otherObject);</span><br><span class="line">        process a SpaceShip-SpaceShip collision;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(objectType == <span class="built_in">typeid</span>(SpaceStation))</span><br><span class="line">    &#123;</span><br><span class="line">        SpaceStation&amp; ss = <span class="built_in">static_cast</span>&lt;SpaceStation&amp;&gt;(otherObject);</span><br><span class="line">        process a SpaceShip-SpaceStation collision;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(objectType == <span class="built_in">typeid</span>(Asteroid))</span><br><span class="line">    &#123;</span><br><span class="line">        Asteroid&amp; a = <span class="built_in">static_cast</span>&lt;Asteriod&amp;&gt;(otherObject);</span><br><span class="line">        process a SpaceShip-Asteroid collision;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">CollisionWithUnknownObject</span>(otherObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该方法的实现简单，容易理解，其缺点是其扩展性不好。如果增加一个新的类时，我们必须更新每一个基于RTTI的if…else链以处理这个新的类型。</p>
<h2 id="只使用虚函数"><a href="#只使用虚函数" class="headerlink" title="只使用虚函数"></a>只使用虚函数</h2><p>基本原理就是<strong>用两个单一调度实现二重调度，也就是有两个单独的虚函数调用：第一次决定第一个对象的动态类型，第二次决定第二个对象动态类型</strong>。其具体实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpaceShip</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpaceStation</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Asteroid</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameObject</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">collide</span><span class="params">(SpaceShip&amp; otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">collide</span><span class="params">(SpaceStation&amp; otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">collide</span><span class="params">(Asteroid&amp; otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpaceShip</span>:<span class="keyword">public</span> GameObject&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">collide</span><span class="params">(SpaceShip&amp; otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">collide</span><span class="params">(SpaceStation&amp; otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">collide</span><span class="params">(Asteroid&amp; otherObject)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpaceShip::collide</span><span class="params">(GameObject&amp; otherObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    otherObject.<span class="built_in">collide</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpaceShip::collide</span><span class="params">(SpaceShip&amp; otherObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    process a SpaceShip-SpaceShip collision;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpaceShip::collide</span><span class="params">(SpaceStation&amp; otherObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    process a SpaceShip-SpaceStation collision;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpaceShip::collide</span><span class="params">(Asteroid&amp; otherObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    process a SpaceShip-Asteroid collision;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>与前面RTTI方法一样，该方法的缺点扩展性不好。每个类都必须知道它的同胞类，当增加新类时，所有的代码都必须更新。</p>
<h2 id="模拟虚函数表"><a href="#模拟虚函数表" class="headerlink" title="模拟虚函数表"></a>模拟虚函数表</h2><p>编译器通常创建一个函数指针数组(vtbl)来实现虚函数，并在虚函数被调用时在这个数组中进行下标索引。我们可以借鉴编译器虚拟函数表的方法，建立一个对象到碰撞函数指针的映射，然后在这个映射中利用对象进行查询，获取对应的碰撞函数指针，进行函数调用。具体代码实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shipAsteroid</span><span class="params">(GameObject&amp; spaceShip,GameObject&amp; asteroid)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shipStation</span><span class="params">(GameObject&amp; spaceShip,GameObject&amp; spaceStation)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">asteroidStation</span><span class="params">(GameObject&amp; asteroid,GameObject&amp; spaceStation)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//implement symmetry</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">asteroidShip</span><span class="params">(GameObject&amp; asteroid,GameObject&amp; spaceShip)</span></span></span><br><span class="line"><span class="function">    </span>&#123;    <span class="built_in">shipAsteroid</span>(spaceShip,asteroid);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stationShip</span><span class="params">(GameObject&amp; spaceStation,GameObject&amp; spaceShip)</span></span></span><br><span class="line"><span class="function">    </span>&#123;    <span class="built_in">shipStation</span>(spaceShip,spaceStation);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stationAsteroid</span><span class="params">(GameObject&amp; spaceStation,GameObject&amp; asteroid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;    <span class="built_in">asteroidStation</span>(asteroid,spaceStation);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*HitFunctionPtr)</span><span class="params">(GameObject&amp;,GameObject&amp;)</span></span>;</span><br><span class="line">    <span class="keyword">typedef</span>    map&lt;pair&lt;string,string&gt;,HitFunctionPtr&gt; HitMap;</span><br><span class="line">    <span class="function">pair&lt;string,string&gt; <span class="title">makeStringPair</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1,<span class="type">const</span> <span class="type">char</span> *s2)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">HitMap* <span class="title">initializeCollisionMap</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">HitFunctionPtr <span class="title">lookup</span><span class="params">(<span class="type">const</span> string&amp; class1,<span class="type">const</span> string&amp; class2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processCollision</span><span class="params">(GameObject&amp; obj1,GameObject&amp; obj2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HitFunctionPtr phf = <span class="built_in">lookup</span>(<span class="built_in">typeid</span>(obj1).<span class="built_in">name</span>(),<span class="built_in">typeid</span>(obj2).<span class="built_in">name</span>());</span><br><span class="line">    <span class="keyword">if</span>(phf)</span><br><span class="line">        <span class="built_in">phf</span>(obj1,obj2);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">UnknownCollision</span>(obj1,obj2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line">    <span class="function">pair&lt;string,string&gt; <span class="title">makeStringPair</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1,<span class="type">const</span> <span class="type">char</span> *s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pair</span>&lt;string,string&gt;(s1,s2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">HitMap* <span class="title">initializeCollisionMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HitMap *phm = <span class="keyword">new</span> HitMap;</span><br><span class="line">        (*phm)[<span class="built_in">makeStringPair</span>(<span class="string">&quot;SpaceShip&quot;</span>,<span class="string">&quot;Asteroid&quot;</span>)] = &amp;shipAsteroid;</span><br><span class="line">        (*phm)[<span class="built_in">makeStringPair</span>(<span class="string">&quot;SpaceShip&quot;</span>,<span class="string">&quot;SpaceStation&quot;</span>)] = &amp;shipStation;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> phm;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">HitFunctionPtr <span class="title">lookup</span><span class="params">(<span class="type">const</span> string&amp; class1,<span class="type">const</span> string&amp; class2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="type">static</span> auto_ptr&lt;HitMap&gt;    <span class="title">collisionMap</span><span class="params">(initializeCollisionMap())</span></span>;</span><br><span class="line">        HitMap::iterator mapEntry = collisionMap-&gt;<span class="built_in">find</span>(<span class="built_in">make_pair</span>(class1,class2));</span><br><span class="line">        <span class="keyword">if</span>(mapEntry == collisionMap-&gt;<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (*mapEntry).second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如上述代码所示，使用非成员函数来处理碰撞过程，根据obj1和obj2来查询初始化之后映射表，来确定对应的非成员函数指针。利用模拟虚函数表的方法，基本上完成了基于多个对象的虚拟化功能。但是为了更方便的使用代码，更方便的维护代码，我们还需要进一步完善其实现过程。</p>
<h2 id="将映射表和注册映射表过程封装起来"><a href="#将映射表和注册映射表过程封装起来" class="headerlink" title="将映射表和注册映射表过程封装起来"></a>将映射表和注册映射表过程封装起来</h2><p>由于具体应用的过程，映射表的映射关系存在着增加和删除的操作，因而需要把映射表封装类体，提供增加，删除等接口。具体实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CollisionMap</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*HitFunctionPtr)</span><span class="params">(GameObject&amp;,GameObject&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEntry</span><span class="params">(<span class="type">const</span> string&amp; type1,<span class="type">const</span> string&amp; type2,HitFunctionPtr collisionFunction,<span class="type">bool</span> symmetric = <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeEntry</span><span class="params">(<span class="type">const</span> string&amp; type1,<span class="type">const</span> string&amp; type2)</span></span>;</span><br><span class="line">    <span class="function">HitFunctionPtr <span class="title">lookup</span><span class="params">(<span class="type">const</span> string&amp; type1,<span class="type">const</span> string&amp; type2)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> CollisionMap&amp; <span class="title">theCollisinMap</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CollisionMap</span>();</span><br><span class="line">    <span class="built_in">CollisinMap</span>(<span class="type">const</span> CollisionMap&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在应用中，我们必须确保在发生碰撞前将映射关系加入了映射表。一个方法是让GameObject的子类在构造函数中进行确认，这将导致在运行期的性能开销，另外一个方法创建一个RegisterCollisionFunction类，用于完成映射关系的注册工作。RegisterCollisionFunction相应的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RegisterCollisionFunction</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RegisterCollisionFunction</span>(<span class="type">const</span> string&amp; type1,<span class="type">const</span> string&amp; type2,CollisionMap::HitFunctionPtr collisionFunction,<span class="type">bool</span> symmetric = <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        CollisionMap::<span class="built_in">theCollisionMap</span>().<span class="built_in">addEntry</span>(type1,type2,collisionFunction,symmetric);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//利用此类型的全局对象来自动地注册映射关系</span></span><br><span class="line"><span class="function">RegisterCollisionFunction <span class="title">cf1</span><span class="params">(<span class="string">&quot;SpaceShip&quot;</span>,<span class="string">&quot;Asteroid&quot;</span>,&amp;shipAsteroid)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="条款32：在未来时态下开发程序"><a href="#条款32：在未来时态下开发程序" class="headerlink" title="条款32：在未来时态下开发程序"></a>条款32：在未来时态下开发程序</h1><p>要在未来时态下开发程序，就必须接受事物会发生变化，并为此作了准备。这是应该考虑的：</p>
<ul>
<li>新的函数将被加入到函数库中，新的重载将发生，于是要注意那些含糊的函数调用行为的结果；</li>
<li>新的类将会加入继承层次，现在的派生类将会是以后的基类，并已为此作好准备；</li>
<li>将会编制新的应用软件，函数将在新的运行环境下被调用，它们应该被写得在新平台上运行正确；</li>
<li>程序的维护人员通常不是原来编写它们的人，因此应该被设计得易于被别人理解、维护和扩充。</li>
</ul>
<p>因为万物都会变化，要写能承受软件发展过程中的混乱攻击的类。应该判断一个函数的含意，以及它被派生类重定义的话是否有意义。如果是有意义的，申明它为虚，即使没有人立即重定义它。如果不是的话，申明它为非虚，并且不要在以后为了便于某人而更改；确保更改是对整个类的运行环境和类所表示的抽象是有意义的。</p>
<p>处理每个类的赋值和拷贝构造函数，即使“从没人这样做过”。他们现在没有这么做并不意味着他们以后不这么做。如果这些函数是难以实现的，那么申明它们为私有。这样，不会有人误调编译器提供的默认版本而做错事。</p>
<p>基于最小惊讶法则：努力提供这样的类，它们的操作和函数有自然的语法和直观的语义。和内建数据类型的行为保持一致：拿不定主意时，仿照int来做。</p>
<p>努力于可移植的代码。写可移植的代码并不比不可移植的代码难太多，只有在性能极其重要时采用不可移植的结构才是可取的。</p>
<p>将你的代码设计得当需要变化时，影响是局部的。尽可能地封装；将实现细节申明为私有。只要可能，使用无名的命名空间和文件内的静态对象或函数。避免导致虚基类的设计，因为这种类需要每个派生类都直接初始化它－－即使是那些间接派生类。避免需要RTTI的设计，它需要if…then…else型的瀑布结构。</p>
<p>这是著名的老生常谈般的告戒，但大部分程序员仍然违背它。看这条一个著名C++专家提出忠告（很不幸，许多作者也这么说）：</p>
<p><strong>你需要虚析构函数，只要有人delete一个实际值向D的B *</strong>。这里，B是基类，D是其派生类。换句话说，这位作者暗示，如果你的程序看起来是这样时，并不需要B有虚析构函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; ... &#125;;                   <span class="comment">// no virtual dtor needed</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B &#123; ... &#125;;</span><br><span class="line">B *pb = <span class="keyword">new</span> D;</span><br></pre></td></tr></table></figure><br>然而，当你加入这么一句时，情况就变了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pb;                        <span class="comment">// NOW you need the virtual</span></span><br><span class="line">                                  <span class="comment">// destructor in B</span></span><br></pre></td></tr></table></figure><br>这意味着，用户代码中的一个小变化－－增加了一个delete语句－－实际上能导致需要修改B的定义。如果这发生了的话，所有B的用户都必须重编译。采纳了这个作者的建议的话，一条语句的增加将导致大量代码的重编译和重链接。这绝不是一个高效的设计。</p>
<h1 id="条款33：将非尾端类设计为抽象类"><a href="#条款33：将非尾端类设计为抽象类" class="headerlink" title="条款33：将非尾端类设计为抽象类"></a>条款33：将非尾端类设计为抽象类</h1><p>考虑下面的需求，软件处理动物，Cat与Dog需要特殊处理，因此，设计Cat和Dog继承Animal。Animal有copy赋值（不是虚方法），Cat和Dog也有copy赋值。考虑下面的情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cat cat1;</span><br><span class="line">Cat cat2;</span><br><span class="line">Animal *a1 = &amp;cat1;</span><br><span class="line">Animal *a2 = &amp;cat2;</span><br><span class="line">*a1 = *a2;</span><br></pre></td></tr></table></figure><br>思考<em>a1 = </em>a2会有什么问题？ copy赋值不是虚方法，根据表面类型，调用Animal的copy赋值，这就导致所谓的部分赋值，cat2的Animal成分赋值给cat1的Animal成分，二者的Cat成分保持不变。</p>
<p>怎么解决上面的问题？将Animal的copy赋值声明为virtual方法，如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> Animal&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Animal &amp;rhs);</span><br></pre></td></tr></table></figure><br>Cat和Dog重写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> Cat&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Animal &amp;rhs);</span><br><span class="line"><span class="keyword">virtual</span> Dog&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Animal &amp;rhs);</span><br></pre></td></tr></table></figure><br>这里使用了C++语言后期的一个特性，即协变，返回的引用更加具体。但是，对于形参表，重写必须保证保持一致。将copy赋值声明为virtual，解决了部分赋值的问题。但是，引入了一个新的问题。如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cat cat；</span><br><span class="line">Dog dog;</span><br><span class="line">Animal* a1 = &amp;cat;</span><br><span class="line">Animal* a2 = &amp;dog;</span><br><span class="line">*a1 = *a2;</span><br></pre></td></tr></table></figure><br>这是异型赋值，左边是Cat，右边是Dog。C++是强类型语言，一般情况下，异型赋值不合法，不会造成问题。但是，这种情况下导致异型赋值合法。对于指针解引用的情况，我们期望同型赋值是合法的，异型赋值是非法的。容易想到的办法是，<strong>在重写的copy赋值中，使用dynamic_cast进行同型判断</strong>。比如Cat的copy赋值，首先判断rhs是不是Cat，如果是，就赋值，如果不是，抛出异常。</p>
<p>我们知道，使用dynamic_cast效率低，考虑下面的情况，<code>cat1 = cat2;</code> 即使cat1与cat2的表面类型就是Cat，也会调用<code>Cat&amp; operator=(const Animal &amp;rhs)</code>进行一次dynamic_cast的运算，这不是我们所期望的。解决办法是：<strong>增加一个过载方法，编译器编译时，根据表面类型确定方法的调用</strong>。如下：<code>Cat&amp; operator=(const Cat &amp;rhs)</code>。</p>
<p>同时对于重写的方法，可以调用前面的方法，如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cat&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Animal &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">operator</span>=(<span class="built_in">dynamic_cast</span>&lt;Cat&amp;&gt;(rhs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行期的类型检查，dynamic_cast的使用应该尽量避免。因为，首先效率低，其次，有些编译器还不支持dynamic_cast，不具有移植性。有没有更好的办法？导致问题的原因是，<strong>对于指针解引用的赋值，父类的copy赋值不是虚方法，导致部分赋值</strong>。</p>
<p>因此，解决办法是，<strong>提取一个抽象类AbstractAnimal，将copy赋值声明为protected，子类可以调用，表面类型是抽象类的指针解引用赋值，不能调用</strong>。增加一个Animal类，继承AbstractAnimal。</p>
<p>对于抽象类，内部至少要有一个纯虚方法，很自然地将析构方法声明为纯虚方法。对于纯虚方法，需要注意：</p>
<ul>
<li>纯虚方法意味着当前类为抽象类，不能实例化。</li>
<li>纯虚方法要求子类必须重写。</li>
<li>特别注意，纯虚方法一般不提供实现，但是允许提供实现，子类也可以调用。如果析构方法为纯虚方法，必须要提供实现。因为子类调用自身的析构方法后，必定会去调用父类的析构方法。</li>
</ul>
<p>考虑，具体基类没有字段，是不是就不需要上述的抽象类了？这有两个问题，首先现在没有字段，以后可能会有字段，其次如果一个类没有字段，一开始就应该是一个抽象类。</p>
<p>结论，对于继承体系中的非尾端类，应该设计为抽象类，如果使用外界的程序库，需要做一下变通。</p>
<h1 id="条款34：如何在同一程序中混合使用-C-和-C"><a href="#条款34：如何在同一程序中混合使用-C-和-C" class="headerlink" title="条款34：如何在同一程序中混合使用 C++和 C"></a>条款34：如何在同一程序中混合使用 C++和 C</h1><p>确保你的C++编译器和C编译器兼容，之后，还有四个要考虑的问题：<strong>名变换</strong>，<strong>静态初始化</strong>，<strong>内存动态分配</strong>，<strong>数据结构兼容</strong>。</p>
<h2 id="名变换"><a href="#名变换" class="headerlink" title="名变换"></a>名变换</h2><p>名变换，就是<strong>C++编译器给程序的每个函数换一个独一无二的名字</strong>。重载不兼容于绝大部分链接程序，因为链接程序通常无法分辨同名的函数。名变换是对链接程序的妥协；链接程序通常坚持函数名必须独一无二。</p>
<p>如果你有一个函数叫drawline而编译器将它变换为xyzzy，你总使用名字drawLine，不会注意到背后的obj文件引用的是xyzzy的。但如果drawLine是一个C函数，obj文件中包含的编译后的drawLine函数仍然叫drawLine；没有名变换动作。当你试图将obj文件链接为程序时，将得到一个错误，因为链接程序在寻找一个叫xyzzy的函数，而没有这样的函数存在。</p>
<p>要解决这个问题，你需要一种方法来告诉C++编译器不要在这个函数上进行名变换。要禁止名变换，使用C++的<code>extern &#39;C&#39;</code>指示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declare a function called drawLine; don&#x27;t mangle</span></span><br><span class="line"><span class="comment">// its name</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawLine</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>例如，如果不幸到必须要用汇编写一个函数，你也可以申明它为extern ‘C’：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this function is in assembler - don&#x27;t mangle its name</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">twiddleBits</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> bits)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>为每一个函数添加<code>extern &#39;C&#39;</code>是痛苦的。extern ‘C’可以对一组函数生效，只要将它们放入一对大括号中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;                           <span class="comment">// disable name mangling for</span></span><br><span class="line">                                       <span class="comment">// all the following functions</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">drawLine</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">twiddleBits</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> bits)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">simulate</span><span class="params">(<span class="type">int</span> iterations)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样使用extern ‘C’简化了维护那些必须同时供C++和C使用的头文件的工作。当用C++编译时，你应该加extern ‘C’，但用C编译时，不应该这样。通过只在C++编译器下定义的宏<code>__cplusplus</code>，你可以将头文件组织得这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">drawLine</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">twiddleBits</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> bits)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">simulate</span><span class="params">(<span class="type">int</span> iterations)</span></span>;</span><br><span class="line">  ...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h2><p><strong>在main执行前和执行后都有大量代码被执行</strong>，静态的类对象和定义在全局的、命名空间中的或文件体中的类对象的构造函数通常在main被执行前就被调用。这个过程称为<strong>静态初始化</strong>。为了解决main()应该首先被调用，而对象又需要在main()执行前被构造的两难问题，许多编译器在main()的最开始处插入了一个特别的函数，由它来负责静态初始化。同样地，编译器在main()结束处插入了一个函数来析构静态对象。产生的代码通常看起来象这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">performStaticInitialization</span>();         <span class="comment">// generated by the</span></span><br><span class="line">                                         <span class="comment">// implementation</span></span><br><span class="line">  the statements you put in main go here;</span><br><span class="line">  <span class="built_in">performStaticDestruction</span>();            <span class="comment">// generated by the</span></span><br><span class="line">                                         <span class="comment">// implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不要注重于这些名字。函数performStaticInitialization()和performStaticDestruction()通常是更含糊的名字，甚至是内联函数（这时在你的obj文件中将找不到这些函数）。要点是：<strong>如果一个C++编译器采用这种方法来初始化和析构静态对象，除非main()是用C++写的，这些对象将从没被初始化和析构</strong>。因为这种初始化和析构静态对象的方法是如此通用，只要程序的任意部分是C++写的，你就应该用C++写main()函数。</p>
<p>有时看起来用C写main()更有意义－－比如程序的大部分是C的，C++部分只是一个支持库。然而，这个C++库很可能含有静态对象，所以用C++写main()仍然是个好主意。这并不意味着你需要重写你的C代码。只要将C写的main()改名为realMain()，然后用C++版本的main()调用realMain()：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>                                <span class="comment">// implement this</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">realMain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>;     <span class="comment">// function in C</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>          <span class="comment">// write this in C++</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">realMain</span>(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>通行规则很简单：<strong>C++部分使用new和delete</strong>，<strong>C部分使用malloc和free</strong>。唯一要记住的就是：<strong>将你的new和delete与mallco和free进行严格的隔离</strong>。</p>
<p>说比做容易。看一下这个粗糙（但很方便）的strdup函数，它并不在C和C++标准（运行库）中，却很常见：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">strdup</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ps)</span></span>;         <span class="comment">// return a copy of the</span></span><br><span class="line">                                       <span class="comment">// string pointed to by ps</span></span><br></pre></td></tr></table></figure><br>要想没有内存泄漏，strdup的调用着必须释放在strdup()中分配的内存。但这内存这么释放？用delete？用free？如果你调用的strdup来自于C函数库中，那么是后者。如果它是用C++写的，那么恐怕是前者。在调用strdup后所需要做的操作，在不同的操作系统下不同，在不同的编译器下也不同。</p>
<h2 id="数据结构的兼容性"><a href="#数据结构的兼容性" class="headerlink" title="数据结构的兼容性"></a>数据结构的兼容性</h2><p><strong>没有可移植的方法来传递对象或传递指向成员函数的指针给C写的函数</strong>。想让你的C++和C编译器生产兼容的输出，<strong>两种语言间的函数可以安全地交换指向对象的指针和指向非成员的函数或静态成员函数的指针</strong>。自然地，结构和内建类型（如int、char等）的变量也可自由通过。</p>
<p>只有非虚函数的结构（或类）的对象兼容于它们在C中的孪生版本。增加虚函数将结束游戏，因为其对象将使用一个不同的内存结构。从其它结构（或类）进行继承的结构，通常也改变其内存结构，所以有基类的结构也不能与C函数交互。就数据结构而言，结论是：<strong>在C++和C之间这样相互传递数据结构是安全的－－在C++和C下提供同样的定义来进行编译</strong>。在C++版本中增加非虚成员函数或许不影响兼容性，但几乎其它的改变都将影响兼容。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>如果想在同一程序下混合C++与C编程，记住下面的指导原则：</p>
<ul>
<li>确保C++和C编译器产生兼容的obj文件。</li>
<li>将在两种语言下都使用的函数申明为extern ‘C’。</li>
<li>只要可能，用C++写main()。</li>
<li>总用delete释放new分配的内存；总用free释放malloc分配的内存。</li>
<li>将在两种语言间传递的东西限制在用C编译的数据结构的范围内；这些结构的C++版本可以包含非虚成员函数。 </li>
</ul>
<h1 id="条款35：让自己习惯使用标准-C-语言"><a href="#条款35：让自己习惯使用标准-C-语言" class="headerlink" title="条款35：让自己习惯使用标准 C++语言"></a>条款35：让自己习惯使用标准 C++语言</h1><p>C++标准运行库的功能分为下列类别（参见Effective C++ Item 49）:</p>
<ul>
<li>支持标准C运行库。</li>
<li>支持string类型。</li>
<li>支持本地化。</li>
<li>支持I/O操作</li>
<li>支持数学运算。</li>
<li>支持通用容器和运算。</li>
</ul>
<p>在介绍STL前，必须先知道标准C++运行库的两个特性。</p>
<ul>
<li>第一，在运行库中的几乎任何东西都是模板。在本书中，我谈到过运行库中的string类，实际上没有这样的类。其实，有一个模板类叫basic_string来描述字符序列，它接受一个字符类型的参数来构造此序列，这使得它能表示char串、wide char串、Unicode char串等等。</li>
<li>我们通常认为的string类是从<code>basic_string&lt;char&gt;</code>实例化而成的。用于它被用得如此广泛，标准运行库作了一个类型定义：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">char</span>&gt; string;</span><br></pre></td></tr></table></figure>
<p>这其实仍然隐藏了很多细节，因为basic_string模板带三个参数；除了第一个外都有默认参数。要全面理解string类型，必须面对这个未经删节的basic_string：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">charT</span>,</span><br><span class="line">         <span class="keyword">class</span> <span class="title class_">traits</span> = string_char_traits&lt;charT&gt;,</span><br><span class="line">         <span class="keyword">class</span> Allocator = allocator&gt;</span><br><span class="line">  <span class="keyword">class</span> basic_string;</span><br></pre></td></tr></table></figure></p>
<p>另外需要知道的是：标准运行库将几乎所有内容都包含在命名空间std中。要想使用标准运行库里面的东西而无需特别指明运行库的名称，你可以使用using指示或使用（更方便的）using申明。幸运的是，这种重复工作在你#include恰当的头文件时自动进行。</p>
<h2 id="标准模板库"><a href="#标准模板库" class="headerlink" title="标准模板库"></a>标准模板库</h2><p>STL基于三个基本概念：<strong>包容器</strong>（container）、<strong>选择子</strong>（iterator）和<strong>算法</strong>（algorithms）。包容器是被包容对象的封装；选择子是类指针的对象让你能如同使用指针操作内建类型的数组一样操作STL的包容器；算法是对包容器进行处理的函数，并使用选择子来实现的。</p>
<p>一个指向数组的指针可以正确地指出数组的任意元素或刚刚超出数组范围的那个元素。如果指向了那个超范围的元素，它将只能与其它指向此数组的指针进行地址比较；对其进行反引用，其结果为未定义。我们可以利用这条规则来实现在数组中查找一个特定值的函数。对一个整型数组，函数可能是这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> * <span class="title">find</span><span class="params">(<span class="type">int</span> *begin, <span class="type">int</span> *end, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (begin != end &amp;&amp; *begin != value) ++begin;</span><br><span class="line">  <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个函数在begin与end之间查找value，返回第一个值为value的元素；如果没有找到，它返回end。</p>
<p>返回end来表示没找到，看起来有些可笑。find()函数必须返回特别的指针值来表明查找失败，就此目的而言，end指针与NULL指针效果相同。但，如我们将要看到的，end指针在推广到其它包容器类型时比NULL指针好。</p>
<p>你可以这么使用find()函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> values[<span class="number">50</span>];</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> *firstFive = <span class="built_in">find</span>(values,        <span class="comment">// search the range</span></span><br><span class="line">                      values+<span class="number">50</span>,     <span class="comment">// values[0] - values[49]</span></span><br><span class="line">                      <span class="number">5</span>);            <span class="comment">// for the value 5</span></span><br><span class="line"><span class="keyword">if</span> (firstFive != values+<span class="number">50</span>) &#123;        <span class="comment">// did the search succeed?</span></span><br><span class="line">  ...                                <span class="comment">// yes</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  ...                                <span class="comment">// no, the search failed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>你也可以只搜索数组的一部分：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *firstFive = <span class="built_in">find</span>(values,        <span class="comment">// search the range</span></span><br><span class="line">                      values+<span class="number">10</span>,     <span class="comment">// values[0] - values[9]</span></span><br><span class="line">                      <span class="number">5</span>);            <span class="comment">// for the value 5</span></span><br><span class="line"><span class="type">int</span> age = <span class="number">36</span>;</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> *firstValue = <span class="built_in">find</span>(values+<span class="number">10</span>,    <span class="comment">// search the range</span></span><br><span class="line">                       values+<span class="number">20</span>,    <span class="comment">// values[10] - values[19]</span></span><br><span class="line">                       age);         <span class="comment">// for the value in age</span></span><br></pre></td></tr></table></figure><br>find()函数内部并没有限制它只能对int型数组操作，所以它可以实际上是一个模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T * <span class="title">find</span><span class="params">(T *begin, T *end, <span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (begin != end &amp;&amp; *begin != value) ++begin;</span><br><span class="line">  <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在每次调用过程中，每个传值的参数都要有构造函数和析构函数的开销。通过传引用避免了这个开销</p>
<p>选择子就是被设计为操作STL的包容器的类指针对象。有了作为类指针对象的选择子的概念，我们可以用选择子代替find()中的指针。改写后的find()类似于：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">Iterator <span class="title">find</span><span class="params">(Iterator begin, Iterator end, <span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (begin != end &amp;&amp; *begin != value) ++begin;</span><br><span class="line">  <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>STL中包含了很多使用包容器和选择子的算法，find()是其中之一。STL中的包容器有bitset、vector、list、deque、queue、priority-queue、stack、set和map，你可以在其中任一类型上使用find()，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">char</span>&gt; charList;                  <span class="comment">// create STL list object</span></span><br><span class="line">                                      <span class="comment">// for holding chars</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// find the first occurrence of &#x27;x&#x27; in charList</span></span><br><span class="line">list&lt;<span class="type">char</span>&gt;::iterator it = <span class="built_in">find</span>(charList.<span class="built_in">begin</span>(),</span><br><span class="line">                               charList.<span class="built_in">end</span>(),</span><br><span class="line">                               <span class="string">&#x27;x&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<p>要对list对象调用find()，你必须提供一个指向list中的第一个元素的选择子和一个越过list中最后一个元素的选择子。如果list类不提供帮助，这将有些难，因为你无法知道list是怎么实现的。</p>
<p>当find()执行完成时，它返回一个选择子对象指向找到的元素或charList.end()。它提供了一个类型重定义，iterator就是list内部使用的选择子的类型。既然charList是一个包容char的list，它内部的选择子类型就是<code>list&lt;char&gt;::iterator</code>。同样的方法也完全适用于其它STL包容器。此外，C++指针也是STL选择子，所以，最初的数组的例子也能适用STL的find()函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> values[<span class="number">50</span>];</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> *firstFive =   <span class="built_in">find</span>(values, values+<span class="number">50</span>, <span class="number">5</span>);     <span class="comment">// fine, calls</span></span><br><span class="line">                                                   <span class="comment">// STL find</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E7%A7%AF%E7%B4%AF/" rel="tag"># 积累</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/09/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E7%AC%94%E8%AE%B0/" rel="next" title="程序员的自我修养笔记">
                <i class="fa fa-chevron-left"></i> 程序员的自我修养笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/09/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8%20%E7%AC%94%E8%AE%B01/" rel="prev" title="深入理解Linux内核 1-4章">
                深入理解Linux内核 1-4章 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">130</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE1%EF%BC%9A%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">条款1：指针与引用的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE2%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8C-%E9%A3%8E%E6%A0%BC%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.</span> <span class="nav-text">条款2：尽量使用C++风格的类型转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE3%EF%BC%9A%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%80%81%E6%80%A7%E6%95%B0%E7%BB%84"><span class="nav-number">3.</span> <span class="nav-text">条款3：不要使用多态性数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE4%EF%BC%9A%E9%81%BF%E5%85%8D%E6%97%A0%E7%94%A8%E7%9A%84%E7%BC%BA%E7%9C%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">条款4：避免无用的缺省构造函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE5%EF%BC%9A%E8%B0%A8%E6%85%8E%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text">条款5：谨慎定义类型转换函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE6%EF%BC%9A%E8%87%AA%E5%A2%9E-increment-%E3%80%81%E8%87%AA%E5%87%8F-decrement-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%89%8D%E7%BC%80%E5%BD%A2%E5%BC%8F%E4%B8%8E%E5%90%8E%E7%BC%80%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.</span> <span class="nav-text">条款6：自增(increment)、自减(decrement)操作符前缀形式与后缀形式的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE7%EF%BC%9A%E4%B8%8D%E8%A6%81%E9%87%8D%E8%BD%BDoverload-amp-amp-or"><span class="nav-number">7.</span> <span class="nav-text">条款7：不要重载overload &amp;&amp;, ||, or ,.</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE8%EF%BC%9A%E7%90%86%E8%A7%A3%E5%90%84%E7%A7%8D%E4%B8%8D%E5%90%8C%E5%90%AB%E4%B9%89%E7%9A%84new%E5%92%8Cdelete"><span class="nav-number">8.</span> <span class="nav-text">条款8：理解各种不同含义的new和delete</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE9%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E9%98%B2%E6%AD%A2%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F"><span class="nav-number">9.</span> <span class="nav-text">条款9：使用析构函数防止资源泄漏</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE10%EF%BC%9A%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E9%98%B2%E6%AD%A2%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F"><span class="nav-number">10.</span> <span class="nav-text">条款10：在构造函数中防止资源泄漏</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE11%EF%BC%9A%E7%A6%81%E6%AD%A2%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%EF%BC%88exceptions%EF%BC%89%E4%BC%A0%E9%80%92%E5%88%B0%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%A4%96"><span class="nav-number">11.</span> <span class="nav-text">条款11：禁止异常信息（exceptions）传递到析构函数外</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE12%EF%BC%9A%E7%90%86%E8%A7%A3%E2%80%9C%E6%8A%9B%E5%87%BA%E4%B8%80%E4%B8%AA%E5%BC%82%E5%B8%B8%E2%80%9D%E4%B8%8E%E2%80%9C%E4%BC%A0%E9%80%92%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E2%80%9D%E6%88%96%E2%80%9C%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E8%99%9A%E5%87%BD%E6%95%B0%E2%80%9D%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="nav-number">12.</span> <span class="nav-text">条款12：理解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”间的差异</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE13%EF%BC%9A%E9%80%9A%E8%BF%87%E5%BC%95%E7%94%A8%EF%BC%88reference%EF%BC%89%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="nav-number">13.</span> <span class="nav-text">条款13：通过引用（reference）捕获异常</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE14%EF%BC%9A%E5%AE%A1%E6%85%8E%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8%E8%A7%84%E6%A0%BC-exception-specifications"><span class="nav-number">14.</span> <span class="nav-text">条款14：审慎使用异常规格(exception specifications)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE15%EF%BC%9A%E4%BA%86%E8%A7%A3%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%BC%80%E9%94%80"><span class="nav-number">15.</span> <span class="nav-text">条款15：了解异常处理的系统开销</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE16%EF%BC%9A%E7%89%A2%E8%AE%B080%EF%BC%8D20%E5%87%86%E5%88%99%EF%BC%8880%EF%BC%8D20-rule%EF%BC%89"><span class="nav-number">16.</span> <span class="nav-text">条款16：牢记80－20准则（80－20 rule）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE17%EF%BC%9A%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8lazy-evaluation%EF%BC%88%E6%87%92%E6%83%B0%E8%AE%A1%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">17.</span> <span class="nav-text">条款17：考虑使用lazy evaluation（懒惰计算法）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-number">17.1.</span> <span class="nav-text">引用计数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB%E5%AF%B9%E5%BE%85%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5"><span class="nav-number">17.2.</span> <span class="nav-text">区别对待读取和写入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lazy-Fetching%EF%BC%88%E6%87%92%E6%83%B0%E6%8F%90%E5%8F%96%EF%BC%89"><span class="nav-number">17.3.</span> <span class="nav-text">Lazy Fetching（懒惰提取）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lazy-Expression-Evaluation-%E6%87%92%E6%83%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="nav-number">17.4.</span> <span class="nav-text">Lazy Expression Evaluation(懒惰表达式计算)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">17.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE18%EF%BC%9A%E5%88%86%E6%9C%9F%E6%91%8A%E8%BF%98%E6%9C%9F%E6%9C%9B%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-number">18.</span> <span class="nav-text">条款18：分期摊还期望的计算</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE19%EF%BC%9A%E7%90%86%E8%A7%A3%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9D%A5%E6%BA%90"><span class="nav-number">19.</span> <span class="nav-text">条款19：理解临时对象的来源</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE20%EF%BC%9A%E5%8D%8F%E5%8A%A9%E5%AE%8C%E6%88%90%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96"><span class="nav-number">20.</span> <span class="nav-text">条款20：协助完成返回值优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE21%EF%BC%9A%E9%80%9A%E8%BF%87%E9%87%8D%E8%BD%BD%E9%81%BF%E5%85%8D%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">21.</span> <span class="nav-text">条款21：通过重载避免隐式类型转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE22%EF%BC%9A%E8%80%83%E8%99%91%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%B5%8B%E5%80%BC%E5%BD%A2%E5%BC%8F%EF%BC%88op-%EF%BC%89%E5%8F%96%E4%BB%A3%E5%85%B6%E5%8D%95%E7%8B%AC%E5%BD%A2%E5%BC%8F%EF%BC%88op%EF%BC%89"><span class="nav-number">22.</span> <span class="nav-text">条款22：考虑用运算符的赋值形式（op&#x3D;）取代其单独形式（op）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE23%EF%BC%9A%E8%80%83%E8%99%91%E5%8F%98%E6%9B%B4%E7%A8%8B%E5%BA%8F%E5%BA%93"><span class="nav-number">23.</span> <span class="nav-text">条款23：考虑变更程序库</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE24%EF%BC%9A%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E5%87%BD%E6%95%B0%E3%80%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%9F%BA%E7%B1%BB%E5%92%8CRTTI%E6%89%80%E9%9C%80%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="nav-number">24.</span> <span class="nav-text">条款24：理解虚拟函数、多继承、虚基类和RTTI所需的代价</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE25%EF%BC%9A%E5%B0%86%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-number">25.</span> <span class="nav-text">条款25：将构造函数和非成员函数虚拟化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">25.1.</span> <span class="nav-text">虚拟化非成员函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE26%EF%BC%9A%E9%99%90%E5%88%B6%E6%9F%90%E4%B8%AA%E7%B1%BB%E6%89%80%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%95%B0%E9%87%8F-%E4%B8%8A%EF%BC%89"><span class="nav-number">26.</span> <span class="nav-text">条款26：限制某个类所能产生的对象数量(上）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%81%E8%AE%B8%E5%AF%B9%E8%B1%A1%E6%9D%A5%E5%8E%BB%E8%87%AA%E7%94%B1"><span class="nav-number">26.1.</span> <span class="nav-text">允许对象来去自由</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%85%B7%E6%9C%89%E5%AF%B9%E8%B1%A1%E8%AE%A1%E6%95%B0%E5%8A%9F%E8%83%BD%E7%9A%84%E5%9F%BA%E7%B1%BB"><span class="nav-number">26.2.</span> <span class="nav-text">一个具有对象计数功能的基类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE27%EF%BC%9A%E8%A6%81%E6%B1%82%E6%88%96%E7%A6%81%E6%AD%A2%E5%9C%A8%E5%A0%86%E4%B8%AD%E4%BA%A7%E7%94%9F%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="nav-number">27.</span> <span class="nav-text">条款27：要求或禁止在堆中产生对象（上）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%81%E6%B1%82%E5%9C%A8%E5%A0%86%E4%B8%AD%E5%BB%BA%E7%AB%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">27.1.</span> <span class="nav-text">要求在堆中建立对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A0%86%E4%B8%AD"><span class="nav-number">27.2.</span> <span class="nav-text">判断一个对象是否在堆中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E5%A0%86%E5%AF%B9%E8%B1%A1"><span class="nav-number">27.3.</span> <span class="nav-text">禁止堆对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE28%EF%BC%9A%E7%81%B5%E5%B7%A7%EF%BC%88smart%EF%BC%89%E6%8C%87%E9%92%88%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="nav-number">28.</span> <span class="nav-text">条款28：灵巧（smart）指针（上）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%81%B5%E5%B7%A7%E6%8C%87%E9%92%88%E7%9A%84%E6%9E%84%E9%80%A0%E3%80%81%E8%B5%8B%E5%80%BC%E5%92%8C%E6%9E%90%E6%9E%84"><span class="nav-number">28.1.</span> <span class="nav-text">灵巧指针的构造、赋值和析构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E4%BD%9CDereference-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">28.2.</span> <span class="nav-text">实作Dereference 操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%81%B5%E5%B7%A7%E6%8C%87%E9%92%88%E6%98%AF%E5%90%A6%E4%B8%BANULL"><span class="nav-number">28.3.</span> <span class="nav-text">测试灵巧指针是否为NULL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%81%B5%E5%B7%A7%E6%8C%87%E9%92%88%E5%92%8Cconst"><span class="nav-number">28.4.</span> <span class="nav-text">灵巧指针和const</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE29%EF%BC%9A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-number">29.</span> <span class="nav-text">条款29：引用计数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D"><span class="nav-number">29.1.</span> <span class="nav-text">写时拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E3%80%81%E5%BC%95%E7%94%A8%E4%B8%8E%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D"><span class="nav-number">29.2.</span> <span class="nav-text">指针、引用与写时拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%A6%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E5%9F%BA%E7%B1%BB"><span class="nav-number">29.3.</span> <span class="nav-text">带引用计数的基类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE30%EF%BC%9A%E4%BB%A3%E7%90%86%E7%B1%BB-Proxy-classes"><span class="nav-number">30.</span> <span class="nav-text">条款30：代理类(Proxy classes)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E5%88%86operator-%E7%9A%84%E8%AF%BB%E5%86%99%E5%8A%A8%E4%BD%9C"><span class="nav-number">30.1.</span> <span class="nav-text">区分operator[]的读写动作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-number">30.2.</span> <span class="nav-text">局限性.</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE31%EF%BC%9A%E8%AE%A9%E5%87%BD%E6%95%B0%E6%A0%B9%E6%8D%AE%E4%B8%80%E4%B8%AA%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9D%A5%E5%86%B3%E5%AE%9A%E6%80%8E%E4%B9%88%E8%99%9A%E6%8B%9F"><span class="nav-number">31.</span> <span class="nav-text">条款31：让函数根据一个以上的对象来决定怎么虚拟</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%8A%A0RTTI"><span class="nav-number">31.1.</span> <span class="nav-text">虚函数加RTTI</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AA%E4%BD%BF%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">31.2.</span> <span class="nav-text">只使用虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="nav-number">31.3.</span> <span class="nav-text">模拟虚函数表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E6%98%A0%E5%B0%84%E8%A1%A8%E5%92%8C%E6%B3%A8%E5%86%8C%E6%98%A0%E5%B0%84%E8%A1%A8%E8%BF%87%E7%A8%8B%E5%B0%81%E8%A3%85%E8%B5%B7%E6%9D%A5"><span class="nav-number">31.4.</span> <span class="nav-text">将映射表和注册映射表过程封装起来</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE32%EF%BC%9A%E5%9C%A8%E6%9C%AA%E6%9D%A5%E6%97%B6%E6%80%81%E4%B8%8B%E5%BC%80%E5%8F%91%E7%A8%8B%E5%BA%8F"><span class="nav-number">32.</span> <span class="nav-text">条款32：在未来时态下开发程序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE33%EF%BC%9A%E5%B0%86%E9%9D%9E%E5%B0%BE%E7%AB%AF%E7%B1%BB%E8%AE%BE%E8%AE%A1%E4%B8%BA%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">33.</span> <span class="nav-text">条款33：将非尾端类设计为抽象类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE34%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8%E5%90%8C%E4%B8%80%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8-C-%E5%92%8C-C"><span class="nav-number">34.</span> <span class="nav-text">条款34：如何在同一程序中混合使用 C++和 C</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8D%E5%8F%98%E6%8D%A2"><span class="nav-number">34.1.</span> <span class="nav-text">名变换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">34.2.</span> <span class="nav-text">静态初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">34.3.</span> <span class="nav-text">动态内存分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="nav-number">34.4.</span> <span class="nav-text">数据结构的兼容性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">34.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE35%EF%BC%9A%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AF%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86-C-%E8%AF%AD%E8%A8%80"><span class="nav-number">35.</span> <span class="nav-text">条款35：让自己习惯使用标准 C++语言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="nav-number">35.1.</span> <span class="nav-text">标准模板库</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
