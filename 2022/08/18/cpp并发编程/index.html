<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="第1章 你好，C++的并发世界!开始入门一个C++多线程程序是什么样子呢?通常是变量、类以及函数的组合。唯一的区别在于某些函数可以并发运行，所以需要确保共享数据在并发访问时是安全的。当然，为了并发地运行函数，必须使用特定的函数以及对象来管理各个线程。 一个非常简单的在单线程中运行的Hello World程序如下所示，当我们谈到多线程时，它可以作为一个基准。12345#include &lt;ios">
<meta property="og:type" content="article">
<meta property="og:title" content="C++并发编程">
<meta property="og:url" content="http://yoursite.com/2022/08/18/cpp%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="第1章 你好，C++的并发世界!开始入门一个C++多线程程序是什么样子呢?通常是变量、类以及函数的组合。唯一的区别在于某些函数可以并发运行，所以需要确保共享数据在并发访问时是安全的。当然，为了并发地运行函数，必须使用特定的函数以及对象来管理各个线程。 一个非常简单的在单线程中运行的Hello World程序如下所示，当我们谈到多线程时，它可以作为一个基准。12345#include &lt;ios">
<meta property="og:locale" content="zn_CH">
<meta property="article:published_time" content="2022-08-18T13:02:00.000Z">
<meta property="article:modified_time" content="2022-08-19T13:55:20.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2022/08/18/cpp%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>C++并发编程 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/08/18/cpp%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++并发编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-18 21:02:00" itemprop="dateCreated datePublished" datetime="2022-08-18T21:02:00+08:00">2022-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-19 21:55:20" itemprop="dateModified" datetime="2022-08-19T21:55:20+08:00">2022-08-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第1章-你好，C-的并发世界"><a href="#第1章-你好，C-的并发世界" class="headerlink" title="第1章 你好，C++的并发世界!"></a>第1章 你好，C++的并发世界!</h1><h2 id="开始入门"><a href="#开始入门" class="headerlink" title="开始入门"></a>开始入门</h2><p>一个C++多线程程序是什么样子呢?通常是变量、类以及函数的组合。唯一的区别在于某些函数可以并发运行，所以需要确保共享数据在并发访问时是安全的。当然，为了并发地运行函数，必须使用特定的函数以及对象来管理各个线程。</p>
<p>一个非常简单的在单线程中运行的Hello World程序如下所示，当我们谈到多线程时，它可以作为一个基准。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello World\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个程序所做的就是将“Hello World”写进标准输出流。让我们将它与下面清单所示的简单的“Hello, Concurrent World”程序做个比较，它启动了一个独立的线程来显示这个信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  <span class="comment">//①</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span>  <span class="comment">//②</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello Concurrent World\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(hello)</span></span>;  <span class="comment">//③</span></span><br><span class="line">  t.<span class="built_in">join</span>();  <span class="comment">//④</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个区别是增加了<code>#include &lt;thread&gt;①</code>，标准C++库中对多线程支持的声明在新的头文件中：管理线程的函数和类在<code>&lt;thread&gt;</code>中声明，而保护共享数据的函数和类在其他头文件中声明。</p>
<p>其次，打印信息的代码被移动到了一个独立的函数中②。因为每个线程都必须具有一个初始函数(initial function)，新线程的执行从这里开始。对于应用程序来说，初始线程是<code>main()</code>，但是对于其他线程，可以在<code>std::thread</code>对象的构造函数中指定——本例中，被命名为<code>t③</code>的<code>std::thread</code>对象拥有新函数<code>hello()</code>作为其初始函数。</p>
<p>下一个区别：与直接写入标准输出或是从<code>main()</code>调用<code>hello()</code>不同，该程序启动了一个全新的线程来实现，将线程数量一分为二——初始线程始于<code>main()</code>，而新线程始于<code>hello()</code>。</p>
<p>新的线程启动之后③，初始线程继续执行。如果它不等待新线程结束，它就将自顾自地继续运行到<code>main()</code>的结束，从而结束程序——有可能发生在新线程运行之前。这就是为什么在④这里调用<code>join()</code>的原因——详见第2章，这会导致调用线程(在<code>main()</code>中)等待与<code>std::thread</code>对象相关联的线程，即这个例子中的t。</p>
<h1 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h1><p>C++标准库中只需要管理std::thread关联的线程，无需把注意力放在其他方面。不过，标准库太灵活，所以管理起来不会太容易。</p>
<p>本章将从基本开始：启动一个线程，等待这个线程结束，或放在后台运行。再看看怎么给已经启动的线程函数传递参数，以及怎么将一个线程的所有权从当前std::thread对象移交给另一个。最后，再来确定线程数，以及识别特殊线程。</p>
<h2 id="线程管理的基础"><a href="#线程管理的基础" class="headerlink" title="线程管理的基础"></a>线程管理的基础</h2><p>每个程序至少有一个线程：执行<code>main()</code>函数的线程，其余线程有其各自的入口函数。线程与原始线程(以<code>main()</code>为入口函数的线程)同时运行。如同<code>main()</code>函数执行完会退出一样，当线程执行完入口函数后，线程也会退出。在为一个线程创建了一个<code>std::thread</code>对象后，需要等待这个线程结束；不过，线程需要先进行启动。下面就来启动线程。</p>
<h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p>最简单的情况下，任务也会很简单，通常是无参数无返回的函数。这种函数在其所属线程上运行，直到函数执行完毕，线程也就结束了。在一些极端情况下，线程运行时，任务中的函数对象需要通过某种通讯机制进行参数的传递，或者执行一系列独立操作；可以通过通讯机制传递信号，让线程停止。线程要做什么，以及什么时候启动，其实都无关紧要。总之，使用C++线程库启动线程，可以归结为构造<code>std::thread</code>对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_some_work</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">(do_some_work)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>为了让编译器识别<code>std::thread</code>类，这个简单的例子也要包含<code>&lt;thread&gt;</code>头文件。如同大多数C++标准库一样，<code>std::thread</code>可以用可调用类型构造，将带有函数调用符类型的实例传入<code>std::thread</code>类中，替换默认的构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">background_task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">    <span class="built_in">do_something_else</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">background_task f;</span><br><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">(f)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>代码中，提供的函数对象会复制到新线程的存储空间当中，函数对象的执行和调用都在线程的内存空间中进行。函数对象的副本应与原始函数对象保持一致，否则得到的结果会与我们的期望不同。</p>
<p>有件事需要注意，当把函数对象传入到线程构造函数中时，需要避免“最令人头痛的语法解析”。如果你传递了一个临时变量，而不是一个命名的变量；C++编译器会将其解析为函数声明，而不是类型对象的定义。</p>
<p>例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">(background_task())</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这里相当与声明了一个名为<code>my_thread</code>的函数，这个函数带有一个参数(函数指针指向没有参数并返回<code>background_task</code>对象的函数)，返回一个<code>std::thread</code>对象的函数，而非启动了一个线程。</p>
<p>使用在前面命名函数对象的方式，或使用多组括号①，或使用新统一的初始化语法②，可以避免这个问题。</p>
<p>如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">((background_task()))</span></span>;  <span class="comment">// 1</span></span><br><span class="line">std::thread my_thread&#123;<span class="built_in">background_task</span>()&#125;;    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>使用lambda表达式也能避免这个问题。lambda表达式是C++11的一个新特性，它允许使用一个可以捕获局部变量的局部函数。之前的例子可以改写为lambda表达式的类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  do_something();</span></span></span><br><span class="line"><span class="params"><span class="function">  do_something_else();</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>启动了线程，你需要明确是要等待线程结束，还是让其自主运行。如果<code>std::thread</code>对象销毁之前还没有做出决定，程序就会终止(<code>std::thread</code>的析构函数会调用<code>std::terminate()</code>)。因此，即便是有异常存在，也需要确保线程能够正确的加入(joined)或分离(detached)。需要注意的是，必须在<code>std::thread</code>对象销毁之前做出决定，否则你的程序将会终止(<code>std::thread</code>的析构函数会调用<code>std::terminate()</code>，这时再去决定会触发相应异常)。</p>
<p>如果不等待线程，就必须保证线程结束之前，可访问的数据得有效性。这不是一个新问题——单线程代码中，对象销毁之后再去访问，也会产生未定义行为——不过，线程的生命周期增加了这个问题发生的几率。</p>
<p>这种情况很可能发生在线程还没结束，函数已经退出的时候，这时线程函数还持有函数局部变量的指针或引用。下面的清单中就展示了这样的一种情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span>&amp; i;</span><br><span class="line">  <span class="built_in">func</span>(<span class="type">int</span>&amp; i_) : <span class="built_in">i</span>(i_) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> j=<span class="number">0</span> ; j&lt;<span class="number">1000000</span> ; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">do_something</span>(i);           <span class="comment">// 1. 潜在访问隐患：悬空引用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oops</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">  <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">my_thread</span><span class="params">(my_func)</span></span>;</span><br><span class="line">  my_thread.<span class="built_in">detach</span>();          <span class="comment">// 2. 不等待线程结束</span></span><br><span class="line">&#125;                              <span class="comment">// 3. 新线程可能还在运行</span></span><br></pre></td></tr></table></figure>
<p>这个例子中，已经决定不等待线程结束(使用了<code>detach()②</code>)，所以当<code>oops()</code>函数执行完成时③，新线程中的函数可能还在运行。如果线程还在运行，它就会去调用<code>do_something(i)</code>函数①，这时就会访问已经销毁的变量。如同一个单线程程序——允许在函数完成后继续持有局部变量的指针或引用；当然，这从来就不是一个好主意——这种情况发生时，错误并不明显，会使多线程更容易出错。</p>
<p>处理这种情况的常规方法：使线程函数的功能齐全，将数据复制到线程中，而非复制到共享数据中。如果使用一个可调用的对象作为线程函数，这个对象就会复制到线程中，而后原始对象就会立即销毁。但对于对象中包含的指针和引用还需谨慎。使用一个能访问局部变量的函数去创建线程是一个糟糕的主意(除非十分确定线程会在函数完成前结束)。此外，可以通过<code>join()</code>函数来确保线程在函数完成前结束。</p>
<h3 id="等待线程完成"><a href="#等待线程完成" class="headerlink" title="等待线程完成"></a>等待线程完成</h3><p>如果需要等待线程，相关的<code>std::thread</code>实例需要使用<code>join()</code>。清单2.1中，将<code>my_thread.detach()</code>替换为<code>my_thread.join()</code>，就可以确保局部变量在线程完成后，才被销毁。在这种情况下，因为原始线程在其生命周期中并没有做什么事，使得用一个独立的线程去执行函数变得收益甚微，但在实际编程中，原始线程要么有自己的工作要做；要么会启动多个子线程来做一些有用的工作，并等待这些线程结束。</p>
<p><code>join()</code>是简单粗暴的等待线程完成或不等待。当你需要对等待中的线程有更灵活的控制时，比如，看一下某个线程是否结束，或者只等待一段时间(超过时间就判定为超时)。想要做到这些，你需要使用其他机制来完成，比如条件变量和期待(futures)。调用<code>join()</code>的行为，还清理了线程相关的存储部分，这样<code>std::thread</code>对象将不再与已经完成的线程有任何关联。这意味着，只能对一个线程使用一次<code>join()</code>；一旦已经使用过<code>join()</code>，<code>std::thread</code>对象就不能再次加入了，当对其使用<code>joinable()</code>时，将返回false。</p>
<h3 id="特殊情况下的等待"><a href="#特殊情况下的等待" class="headerlink" title="特殊情况下的等待"></a>特殊情况下的等待</h3><p>如前所述，需要对一个还未销毁的<code>std::thread</code>对象使用<code>join()</code>或<code>detach()</code>。如果想要分离一个线程，可以在线程启动后，直接使用<code>detach()</code>进行分离。如果打算等待对应线程，则需要细心挑选调用<code>join()</code>的位置。当在线程运行之后产生异常，在<code>join()</code>调用之前抛出，就意味着这次调用会被跳过。</p>
<p>避免应用被抛出的异常所终止，就需要作出一个决定。通常，当倾向于在无异常的情况下使用<code>join()</code>时，需要在异常处理过程中调用<code>join()</code>，从而避免生命周期的问题。下面的程序清单是一个例子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>; <span class="comment">// 定义在清单2.1中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">  <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">do_something_in_current_thread</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(...)</span><br><span class="line">  &#123;</span><br><span class="line">    t.<span class="built_in">join</span>();  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t.<span class="built_in">join</span>();  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清单2.2中的代码使用了try/catch块确保访问本地状态的线程退出后，函数才结束。当函数正常退出时，会执行到②处；当函数执行过程中抛出异常，程序会执行到①处。try/catch块能轻易的捕获轻量级错误，所以这种情况，并非放之四海而皆准。如需确保线程在函数之前结束——查看是否因为线程函数使用了局部变量的引用，以及其他原因——而后再确定一下程序可能会退出的途径，无论正常与否，可以提供一个简洁的机制，来做解决这个问题。</p>
<p>一种方式是使用“资源获取即初始化方式”(RAII，Resource Acquisition Is Initialization)，并且提供一个类，在析构函数中使用<code>join()</code>，如同下面清单中的代码。看它如何简化<code>f()</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span></span><br><span class="line">&#123;</span><br><span class="line">  std::thread&amp; t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(std::thread&amp; t_)</span>:</span></span><br><span class="line"><span class="function">    t(t_)</span></span><br><span class="line"><span class="function">  &#123;</span>&#125;</span><br><span class="line">  ~<span class="built_in">thread_guard</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(t.<span class="built_in">joinable</span>()) <span class="comment">// 1</span></span><br><span class="line">    &#123;</span><br><span class="line">      t.<span class="built_in">join</span>();      <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">thread_guard</span>(thread_guard <span class="type">const</span>&amp;)=<span class="keyword">delete</span>;   <span class="comment">// 3</span></span><br><span class="line">  thread_guard&amp; <span class="keyword">operator</span>=(thread_guard <span class="type">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>; <span class="comment">// 定义在清单2.1中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">  <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">  <span class="function">thread_guard <span class="title">g</span><span class="params">(t)</span></span>;</span><br><span class="line">  <span class="built_in">do_something_in_current_thread</span>();</span><br><span class="line">&#125;    <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>当线程执行到④处时，局部对象就要被逆序销毁了。因此，<code>thread_guard</code>对象<code>g</code>是第一个被销毁的，这时线程在析构函数中被加入②到原始线程中。即使<code>do_something_in_current_thread</code>抛出一个异常，这个销毁依旧会发生。</p>
<p>在<code>thread_guard</code>的析构函数的测试中，首先判断线程是否已加入①，如果没有会调用<code>join()</code>②进行加入。这很重要，因为<code>join()</code>只能对给定的对象调用一次，所以对给已加入的线程再次进行加入操作时，将会导致错误。</p>
<p>拷贝构造函数和拷贝赋值操作被标记为<code>=delete</code>③，是为了不让编译器自动生成它们。直接对一个对象进行拷贝或赋值是危险的，因为这可能会弄丢已经加入的线程。通过删除声明，任何尝试给<code>thread_guard</code>对象赋值的操作都会引发一个编译错误。</p>
<p>如果不想等待线程结束，可以分离(detaching)线程，从而避免异常安全*(exception-safety)问题。不过，这就打破了线程与<code>std::thread</code>对象的联系，即使线程仍然在后台运行着，分离操作也能确保<code>std::terminate()</code>在<code>std::thread</code>对象销毁才被调用。</p>
<h3 id="后台运行线程"><a href="#后台运行线程" class="headerlink" title="后台运行线程"></a>后台运行线程</h3><p>使用<code>detach()</code>会让线程在后台运行，这就意味着主线程不能与之产生直接交互。也就是说，不会等待这个线程结束；如果线程分离，那么就不可能有<code>std::thread</code>对象能引用它，分离线程的确在后台运行，所以分离线程不能被加入。不过C++运行库保证，当线程退出时，相关资源的能够正确回收，后台线程的归属和控制C++运行库都会处理。</p>
<p>通常称分离线程为守护线程(daemon threads),UNIX中守护线程是指，没有任何显式的用户接口，并在后台运行的线程。这种线程的特点就是长时间运行；线程的生命周期可能会从某一个应用起始到结束，可能会在后台监视文件系统，还有可能对缓存进行清理，亦或对数据结构进行优化。另一方面，分离线程的另一方面只能确定线程什么时候结束，发后即忘(fire and forget)的任务就使用到线程的这种方式。</p>
<p>如2.1.2节所示，调用<code>std::thread</code>成员函数<code>detach()</code>来分离一个线程。之后，相应的<code>std::thread</code>对象就与实际执行的线程无关了，并且这个线程也无法加入：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(do_background_work)</span></span>;</span><br><span class="line">t.<span class="built_in">detach</span>();</span><br><span class="line"><span class="built_in">assert</span>(!t.<span class="built_in">joinable</span>());</span><br></pre></td></tr></table></figure></p>
<p>为了从<code>std::thread</code>对象中分离线程(前提是有可进行分离的线程)，不能对没有执行线程的<code>std::thread</code>对象使用<code>detach()</code>，也是<code>join()</code>的使用条件，并且要用同样的方式进行检查——当<code>std::thread</code>对象使用<code>t.joinable()</code>返回的是true，就可以使用<code>t.detach()</code>。</p>
<h2 id="向线程函数传递参数"><a href="#向线程函数传递参数" class="headerlink" title="向线程函数传递参数"></a>向线程函数传递参数</h2><p>清单2.4中，向<code>std::thread</code>构造函数中的可调用对象，或函数传递一个参数很简单。需要注意的是，默认参数要拷贝到线程独立内存中，即使参数是引用的形式，也可以在新线程中进行访问。再来看一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i, std::string <span class="type">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(f, <span class="number">3</span>, <span class="string">&quot;hello&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>代码创建了一个调用<code>f(3, “hello”)</code>的线程。注意，函数<code>f</code>需要一个<code>std::string</code>对象作为第二个参数，但这里使用的是字符串的字面值，也就是<code>char const *</code>类型。之后，在线程的上下文中完成字面值向<code>std::string</code>对象的转化。需要特别要注意，当指向动态变量的指针作为参数传递给线程的情况，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i,std::string <span class="type">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oops</span><span class="params">(<span class="type">int</span> some_param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">1024</span>]; <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%i&quot;</span>,some_param);</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(f,<span class="number">3</span>,buffer)</span></span>; <span class="comment">// 2</span></span><br><span class="line">  t.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种情况下，buffer②是一个指针变量，指向本地变量，然后本地变量通过buffer传递到新线程中②。并且，函数有很有可能会在字面值转化成<code>std::string</code>对象之前崩溃(oops)，从而导致一些未定义的行为。并且想要依赖隐式转换将字面值转换为函数期待的<code>std::string</code>对象，但因<code>std::thread</code>的构造函数会复制提供的变量，就只复制了没有转换成期望类型的字符串字面值。</p>
<p>解决方案就是在传递到<code>std::thread</code>构造函数之前就将字面值转化为<code>std::string</code>对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i,std::string <span class="type">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">not_oops</span><span class="params">(<span class="type">int</span> some_param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">  <span class="built_in">sprintf</span>(buffer,<span class="string">&quot;%i&quot;</span>,some_param);</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(f,<span class="number">3</span>,std::string(buffer))</span></span>;  <span class="comment">// 使用std::string，避免悬垂指针</span></span><br><span class="line">  t.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还可能遇到相反的情况：期望传递一个引用，但整个对象被复制了。当线程更新一个引用传递的数据结构时，这种情况就可能发生，比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_data_for_widget</span><span class="params">(widget_id w,widget_data&amp; data)</span></span>; <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oops_again</span><span class="params">(widget_id w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  widget_data data;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(update_data_for_widget,w,data)</span></span>; <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">display_status</span>();</span><br><span class="line">  t.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">process_widget_data</span>(data); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然<code>update_data_for_widget</code>①的第二个参数期待传入一个引用，但是<code>std::thread</code>的构造函数②并不知晓；构造函数无视函数期待的参数类型，并盲目的拷贝已提供的变量。当线程调用<code>update_data_for_widget</code>函数时，传递给函数的参数是<code>data</code>变量内部拷贝的引用，而非数据本身的引用。因此，当线程结束时，内部拷贝数据将会在数据更新阶段被销毁，且<code>process_widget_data</code>将会接收到没有修改的data变量③。可以使用<code>std::ref</code>将参数转换成引用的形式，从而可将线程的调用改为以下形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(update_data_for_widget,w,std::ref(data))</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>在这之后，<code>update_data_for_widget</code>就会接收到一个<code>data</code>变量的引用，而非一个<code>data</code>变量拷贝的引用。</p>
<p>如果你熟悉<code>std::bind</code>，就应该不会对以上述传参的形式感到奇怪，因为<code>std::thread</code>构造函数和<code>std::bind</code>的操作都在标准库中定义好了，可以传递一个成员函数指针作为线程函数，并提供一个合适的对象指针作为第一个参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">do_lengthy_work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">X my_x;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(&amp;X::do_lengthy_work,&amp;my_x)</span></span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码中，新线程将<code>my_x.do_lengthy_work()</code>作为线程函数；<code>my_x</code>的地址①作为指针对象提供给函数。也可以为成员函数提供参数：<code>std::thread</code>构造函数的第三个参数就是成员函数的第一个参数，以此类推(代码如下，译者自加)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">do_lengthy_work</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">X my_x;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(&amp;X::do_lengthy_work, &amp;my_x, num)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>有趣的是，提供的参数可以移动，但不能拷贝。”移动”是指:原始对象中的数据转移给另一对象，而转移的这些数据就不再在原始对象中保存了。<code>std::unique_ptr</code>就是这样一种类型，这种类型为动态分配的对象提供内存自动管理机制。同一时间内，只允许一个<code>std::unique_ptr</code>实现指向一个给定对象，并且当这个实现销毁时，指向的对象也将被删除。移动构造函数(move constructor)和移动赋值操作符(move assignment operator)允许一个对象在多个<code>std::unique_ptr</code>实现中传递。使用”移动”转移原对象后，就会留下一个空指针(NULL)。移动操作可以将对象转换成可接受的类型，例如:函数参数或函数返回的类型。当原对象是一个临时变量时，自动进行移动操作，但当原对象是一个命名变量，那么转移的时候就需要使用<code>std::move()</code>进行显示移动。下面的代码展示了<code>std::move</code>的用法，展示了<code>std::move</code>是如何转移一个动态对象到一个线程中去的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_big_object</span><span class="params">(std::unique_ptr&lt;big_object&gt;)</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;big_object&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> big_object)</span></span>;</span><br><span class="line">p-&gt;<span class="built_in">prepare_data</span>(<span class="number">42</span>);</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(process_big_object,std::move(p))</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>在<code>std::thread</code>的构造函数中指定<code>std::move(p)</code>，<code>big_object</code>对象的所有权就被首先转移到新创建线程的的内部存储中，之后传递给<code>process_big_object</code>函数。</p>
<p>标准线程库中和<code>std::unique_ptr</code>在所属权上有相似语义类型的类有好几种，<code>std::thread</code>为其中之一。虽然，<code>std::thread</code>实例不像<code>std::unique_ptr</code>那样能占有一个动态对象的所有权，但是它能占有其他资源：每个实例都负责管理一个执行线程。执行线程的所有权可以在多个<code>std::thread</code>实例中互相转移，这是依赖于<code>std::thread</code>实例的可移动且不可复制性。不可复制保性证了在同一时间点，一个<code>std::thread</code>实例只能关联一个执行线程；可移动性使得程序员可以自己决定，哪个实例拥有实际执行线程的所有权。</p>
<h2 id="转移线程所有权"><a href="#转移线程所有权" class="headerlink" title="转移线程所有权"></a>转移线程所有权</h2><p>假设要写一个在后台启动线程的函数，想通过新线程返回的所有权去调用这个函数，而不是等待线程结束再去调用；或完全与之相反的想法：创建一个线程，并在函数中转移所有权，都必须要等待线程结束。总之，新线程的所有权都需要转移。</p>
<p>这就是移动引入<code>std::thread</code>的原因，C++标准库中有很多资源占有(resource-owning)类型，比如<code>std::ifstream</code>，<code>std::unique_ptr</code>还有<code>std::thread</code>都是可移动，但不可拷贝。这就说明执行线程的所有权可以在<code>std::thread</code>实例中移动，下面将展示一个例子。例子中，创建了两个执行线程，并且在<code>std::thread</code>实例之间(t1,t2和t3)转移所有权：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_other_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(some_function)</span></span>;            <span class="comment">// 1</span></span><br><span class="line">std::thread t2=std::<span class="built_in">move</span>(t1);            <span class="comment">// 2</span></span><br><span class="line">t1=std::<span class="built_in">thread</span>(some_other_function);    <span class="comment">// 3</span></span><br><span class="line">std::thread t3;                            <span class="comment">// 4</span></span><br><span class="line">t3=std::<span class="built_in">move</span>(t2);                        <span class="comment">// 5</span></span><br><span class="line">t1=std::<span class="built_in">move</span>(t3);                        <span class="comment">// 6 赋值操作将使程序崩溃</span></span><br></pre></td></tr></table></figure></p>
<p>当显式使用<code>std::move()</code>创建t2后②，t1的所有权就转移给了t2。之后，t1和执行线程已经没有关联了；执行<code>some_function</code>的函数现在与t2关联。</p>
<p>然后，与一个临时<code>std::thread</code>对象相关的线程启动了③。为什么不显式调用<code>std::move()</code>转移所有权呢？因为，所有者是一个临时对象——移动操作将会隐式的调用。</p>
<p>t3使用默认构造方式创建④，与任何执行线程都没有关联。调用<code>std::move()</code>将与t2关联线程的所有权转移到t3中⑤。因为t2是一个命名对象，需要显式的调用<code>std::move()</code>。移动操作⑤完成后，t1与执行<code>some_other_function</code>的线程相关联，t2与任何线程都无关联，t3与执行<code>some_function</code>的线程相关联。</p>
<p>最后一个移动操作，将<code>some_function</code>线程的所有权转移⑥给t1。不过，t1已经有了一个关联的线程(执行some_other_function的线程)，所以这里系统直接调用<code>std::terminate()</code>终止程序继续运行。这样做（不抛出异常，<code>std::terminate()</code>是noexcept函数)是为了保证与<code>std::thread</code>的析构函数的行为一致。2.1.1节中，需要在线程对象被析构前，显式的等待线程完成，或者分离它；进行赋值时也需要满足这些条件。</p>
<p><code>std::thread</code>支持移动，就意味着线程的所有权可以在函数外进行转移，就如下面程序一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">thread</span>(some_function);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">some_other_function</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(some_other_function,<span class="number">42</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当所有权可以在函数内部传递，就允许<code>std::thread</code>实例可作为参数进行传递，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::thread t)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="built_in">f</span>(std::<span class="built_in">thread</span>(some_function));</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(some_function)</span></span>;</span><br><span class="line">  <span class="built_in">f</span>(std::<span class="built_in">move</span>(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>std::thread</code>支持移动的好处是可以创建<code>thread_guard</code>类的实例，并且拥有其线程的所有权。当<code>thread_guard</code>对象所持有的线程已经被引用，移动操作就可以避免很多不必要的麻烦；这意味着，当某个对象转移了线程的所有权后，它就不能对线程进行加入或分离。为了确保线程程序退出前完成，下面的代码里定义了<code>scoped_thread</code>类。现在，我们来看一下这段代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">scoped_thread</span></span><br><span class="line">&#123;</span><br><span class="line">  std::thread t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_thread</span><span class="params">(std::thread t_)</span>:                 // <span class="number">1</span></span></span><br><span class="line"><span class="function">    t(std::move(t_))</span></span><br><span class="line"><span class="function">  &#123;</span></span><br><span class="line">    <span class="keyword">if</span>(!t.<span class="built_in">joinable</span>())                                     <span class="comment">// 2</span></span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(“No thread”);</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">scoped_thread</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    t.<span class="built_in">join</span>();                                            <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">scoped_thread</span>(scoped_thread <span class="type">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">  scoped_thread&amp; <span class="keyword">operator</span>=(scoped_thread <span class="type">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>; <span class="comment">// 定义在清单2.1中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> some_local_state;</span><br><span class="line">  <span class="function">scoped_thread <span class="title">t</span><span class="params">(std::thread(func(some_local_state)))</span></span>;    <span class="comment">// 4</span></span><br><span class="line">  <span class="built_in">do_something_in_current_thread</span>();</span><br><span class="line">&#125;                                                        <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p>
<p>与清单2.3相似，不过这里新线程是直接传递到scoped_thread中④，而非创建一个独立的命名变量。当主线程到达<code>f()</code>函数的末尾时，scoped_thread对象将会销毁，然后加入③到的构造函数①创建的线程对象中去。而在清单2.3中的thread_guard类，就要在析构的时候检查线程是否”可加入”。这里把检查放在了构造函数中②，并且当线程不可加入时，抛出异常。</p>
<p><code>std::thread</code>对象的容器，如果这个容器是移动敏感的(比如，标准中的<code>std::vector&lt;&gt;</code>)，那么移动操作同样适用于这些容器。了解这些后，就可以写出类似清单2.7中的代码，代码量产了一些线程，并且等待它们结束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_work</span><span class="params">(<span class="type">unsigned</span> id)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::vector&lt;std::thread&gt; threads;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">unsigned</span> i=<span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(do_work,i)); <span class="comment">// 产生线程</span></span><br><span class="line">  &#125; </span><br><span class="line">  std::for_each(threads.<span class="built_in">begin</span>(),threads.<span class="built_in">end</span>(),</span><br><span class="line">                  std::<span class="built_in">mem_fn</span>(&amp;std::thread::join)); <span class="comment">// 对每个线程调用join()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们经常需要线程去分割一个算法的总工作量，所以在算法结束的之前，所有的线程必须结束。清单2.7说明线程所做的工作都是独立的，并且结果仅会受到共享数据的影响。如果f()有返回值，这个返回值就依赖于线程得到的结果。在写入返回值之前，程序会检查使用共享数据的线程是否终止。</p>
<p>将<code>std::thread</code>放入<code>std::vector</code>是向线程自动化管理迈出的第一步：并非为这些线程创建独立的变量，并且将他们直接加入，可以把它们当做一个组。创建一组线程(数量在运行时确定)，可使得这一步迈的更大，而非像清单2.7那样创建固定数量的线程。</p>
<h2 id="运行时决定线程数量"><a href="#运行时决定线程数量" class="headerlink" title="运行时决定线程数量"></a>运行时决定线程数量</h2><p><code>std::thread::hardware_concurrency()</code>在新版C++标准库中是一个很有用的函数。这个函数将返回能同时并发在一个程序中的线程数量。例如，多核系统中，返回值可以是CPU核芯的数量。返回值也仅仅是一个提示，当系统信息无法获取时，函数也会返回0。但是，这也无法掩盖这个函数对启动线程数量的帮助。</p>
<p>清单2.8实现了一个并行版的<code>std::accumulate</code>。代码中将整体工作拆分成小任务交给每个线程去做，其中设置最小任务数，是为了避免产生太多的线程。程序可能会在操作数量为0的时候抛出异常。比如，<code>std::thread</code>构造函数无法启动一个执行线程，就会抛出一个异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">accumulate_block</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator first,Iterator last,T&amp; result)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    result=std::<span class="built_in">accumulate</span>(first,last,result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">parallel_accumulate</span><span class="params">(Iterator first,Iterator last,T init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> length=std::<span class="built_in">distance</span>(first,last);</span><br><span class="line">  <span class="keyword">if</span>(!length) <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> min_per_thread=<span class="number">25</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> max_threads = (length+min_per_thread<span class="number">-1</span>)/min_per_thread; <span class="comment">// 2</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hardware_threads = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> num_threads = std::<span class="built_in">min</span>(hardware_threads != <span class="number">0</span> ? hardware_threads : <span class="number">2</span>, max_threads); <span class="comment">// 3</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> block_size = length/num_threads; <span class="comment">// 4</span></span><br><span class="line">  <span class="function">std::vector&lt;T&gt; <span class="title">results</span><span class="params">(num_threads)</span></span>;</span><br><span class="line">  <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(num_threads<span class="number">-1</span>)</span></span>;  <span class="comment">// 5</span></span><br><span class="line">  Iterator block_start=first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">long</span> i=<span class="number">0</span>; i &lt; (num_threads<span class="number">-1</span>); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    Iterator block_end=block_start;</span><br><span class="line">    std::<span class="built_in">advance</span>(block_end,block_size);  <span class="comment">// 6</span></span><br><span class="line">    threads[i]=std::<span class="built_in">thread</span>(     <span class="comment">// 7</span></span><br><span class="line">        <span class="built_in">accumulate_block</span>&lt;Iterator,T&gt;(),</span><br><span class="line">        block_start,block_end,std::<span class="built_in">ref</span>(results[i]));</span><br><span class="line">    block_start=block_end;  <span class="comment">// 8</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">accumulate_block</span>&lt;Iterator,T&gt;()(</span><br><span class="line">      block_start,last,results[num_threads<span class="number">-1</span>]); <span class="comment">// 9</span></span><br><span class="line">  std::for_each(threads.<span class="built_in">begin</span>(),threads.<span class="built_in">end</span>(),</span><br><span class="line">       std::<span class="built_in">mem_fn</span>(&amp;std::thread::join));  <span class="comment">// 10</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(results.<span class="built_in">begin</span>(),results.<span class="built_in">end</span>(),init); <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数看起来很长，但不复杂。如果输入的范围为空①，就会得到init的值。反之，如果范围内多于一个元素时，都需要用范围内元素的总数量除以线程(块)中最小任务数，从而确定启动线程的最大数量②，这样能避免无谓的计算资源的浪费。比如，一台32芯的机器上，只有5个数需要计算，却启动了32个线程。</p>
<p>计算量的最大值和硬件支持线程数中，较小的值为启动线程的数量③。因为上下文频繁的切换会降低线程的性能，所以你肯定不想启动的线程数多于硬件支持的线程数量。当<code>std::thread::hardware_concurrency()</code>返回0，你可以选择一个合适的数作为你的选择；在本例中，我选择了”2”。你也不想在一台单核机器上启动太多的线程，因为这样反而会降低性能，有可能最终让你放弃使用并发。</p>
<p>每个线程中处理的元素数量，是范围中元素的总量除以线程的个数得出的④。对于分配是否得当，我们会在后面讨论。</p>
<p>现在，确定了线程个数，通过创建一个<code>std::vector&lt;T&gt;</code>容器存放中间结果，并为线程创建一个<code>std::vector&lt;std::thread&gt;</code>容器⑤。这里需要注意的是，启动的线程数必须比<code>num_threads</code>少1个，因为在启动之前已经有了一个线程(主线程)。</p>
<p>使用简单的循环来启动线程：<code>block_end</code>迭代器指向当前块的末尾⑥，并启动一个新线程为当前块累加结果⑦。当迭代器指向当前块的末尾时，启动下一个块⑧。</p>
<p>启动所有线程后，⑨中的线程会处理最终块的结果。对于分配不均，因为知道最终块是哪一个，那么这个块中有多少个元素就无所谓了。</p>
<p>当累加最终块的结果后，可以等待<code>std::for_each</code>⑩创建线程的完成，之后使用<code>std::accumulate</code>将所有结果进行累加⑪。</p>
<p>结束这个例子之前，需要明确：T类型的加法运算不满足结合律(比如，对于float型或double型，在进行加法操作时，系统很可能会做截断操作)，因为对范围中元素的分组，会导致<code>parallel_accumulate</code>得到的结果可能与<code>std::accumulate</code>得到的结果不同。同样的，这里对迭代器的要求更加严格：必须都是向前迭代器，而<code>std::accumulate</code>可以在只传入迭代器的情况下工作。对于创建出<code>results</code>容器，需要保证T有默认构造函数。对于算法并行，通常都要这样的修改；不过，需要根据算法本身的特性，选择不同的并行方式。需要注意的：因为不能直接从一个线程中返回一个值，所以需要传递results容器的引用到线程中去。</p>
<p>当线程运行时，所有必要的信息都需要传入到线程中去，包括存储计算结果的位置。不过，并非总需如此：有时候这是识别线程的可行方案，可以传递一个标识数，例如清单2.7中的i。不过，当需要标识的函数在调用栈的深层，同时其他线程也可调用该函数，那么标识数就会变的捉襟见肘。好消息是在设计C++的线程库时，就有预见了这种情况，在之后的实现中就给每个线程附加了唯一标识符。</p>
<h2 id="识别线程"><a href="#识别线程" class="headerlink" title="识别线程"></a>识别线程</h2><p>线程标识类型是<code>std::thread::id</code>，可以通过两种方式进行检索。第一种，可以通过调用<code>std::thread</code>对象的成员函数<code>get_id()</code>来直接获取。如果<code>std::thread</code>对象没有与任何执行线程相关联，<code>get_id()</code>将返回<code>std::thread::type</code>默认构造值，这个值表示“没有线程”。第二种，当前线程中调用<code>std::this_thread::get_id()</code>(这个函数定义在<code>&lt;thread&gt;</code>头文件中)也可以获得线程标识。</p>
<p><code>std::thread::id</code>对象可以自由的拷贝和对比，因为标识符就可以复用。如果两个对象的<code>std::thread::id</code>相等，那它们就是同一个线程，或者都“没有线程”。如果不等，那么就代表了两个不同线程，或者一个有线程，另一没有。</p>
<p>线程库不会限制你去检查线程标识是否一样，<code>std::thread::id</code>类型对象提供相当丰富的对比操作；比如，提供为不同的值进行排序。这意味着允许程序员将其当做为容器的键值，做排序，或做其他方式的比较。按默认顺序比较不同值的<code>std::thread::id</code>，所以这个行为可预见的：当<code>a&lt;b</code>，<code>b&lt;c</code>时，得<code>a&lt;c</code>，等等。标准库也提供<code>std::hash&lt;std::thread::id&gt;</code>容器，所以<code>std::thread::id</code>也可以作为无序容器的键值。</p>
<p><code>std::thread::id</code>实例常用作检测线程是否需要进行一些操作，比如：当用线程来分割一项工作，主线程可能要做一些与其他线程不同的工作。这种情况下，启动其他线程前，它可以将自己的线程ID通过<code>std::this_thread::get_id()</code>得到，并进行存储。就是算法核心部分(所有线程都一样的),每个线程都要检查一下，其拥有的线程ID是否与初始线程的ID相同。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::thread::id master_thread;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_core_part_of_algorithm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(std::this_thread::<span class="built_in">get_id</span>()==master_thread)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">do_master_thread_work</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">do_common_work</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，当前线程的<code>std::thread::id</code>将存储到一个数据结构中。之后在这个结构体中对当前线程的ID与存储的线程ID做对比，来决定操作是被“允许”，还是“需要”(permitted/required)。</p>
<p>同样，作为线程和本地存储不适配的替代方案，线程ID在容器中可作为键值。例如，容器可以存储其掌控下每个线程的信息，或在多个线程中互传信息。</p>
<p><code>std::thread::id</code>可以作为一个线程的通用标识符，当标识符只与语义相关(比如，数组的索引)时，就需要这个方案了。也可以使用输出流(<code>std::cout</code>)来记录一个<code>std::thread::id</code>对象的值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout&lt;&lt;std::this_thread::<span class="built_in">get_id</span>();</span><br></pre></td></tr></table></figure></p>
<p>具体的输出结果是严格依赖于具体实现的，C++标准的唯一要求就是要保证ID比较结果相等的线程，必须有相同的输出。</p>
<h1 id="线程间共享数据"><a href="#线程间共享数据" class="headerlink" title="线程间共享数据"></a>线程间共享数据</h1><h2 id="共享数据带来的问题"><a href="#共享数据带来的问题" class="headerlink" title="共享数据带来的问题"></a>共享数据带来的问题</h2><p>线程间潜在问题就是修改共享数据，致使不变量遭到破坏。当不做些事来确保在这个过程中不会有其他线程进行访问的话，可能就有线程访问到刚刚删除一边的节点；这样的话，线程就读取到要删除节点的数据(因为只有一边的连接被修改，如图3.1(b))，所以不变量就被破坏。破坏不变量的后果是多样，当其他线程按从左往右的顺序来访问列表时，它将跳过被删除的节点。在一方面，如有第二个线程尝试删除图中右边的节点，那么可能会让数据结构产生永久性的损坏，使程序崩溃。无论结果如何，都是并行代码常见错误：条件竞争。</p>
<h3 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h3><p>并发中竞争条件的形成，取决于一个以上线程的相对执行顺序，每个线程都抢着完成自己的任务。</p>
<p>恶性条件竞争通常发生于完成对多于一个的数据块的修改时。因为操作要访问两个独立的数据块，独立的指令将会对数据块将进行修改，并且其中一个线程可能正在进行时，另一个线程就对数据块进行了访问。当系统负载增加时，随着执行数量的增加，执行序列的问题复现的概率也在增加，这样的问题只可能会出现在负载比较大的情况下。</p>
<h3 id="避免恶性条件竞争"><a href="#避免恶性条件竞争" class="headerlink" title="避免恶性条件竞争"></a>避免恶性条件竞争</h3><p>这里提供一些方法来解决恶性条件竞争，最简单的办法就是对数据结构采用某种保护机制，确保只有进行修改的线程才能看到不变量被破坏时的中间状态。</p>
<p>另一个选择是对数据结构和不变量的设计进行修改，修改完的结构必须能完成一系列不可分割的变化，也就是保证每个不变量保持稳定的状态，这就是所谓的无锁编程。</p>
<p>另一种处理条件竞争的方式是，使用事务的方式去处理数据结构的更新。所需的一些数据和读取都存储在事务日志中，然后将之前的操作合为一步，再进行提交。当数据结构被另一个线程修改后，或处理已经重启的情况下，提交就会无法进行，这称作为“软件事务内存”。</p>
<h2 id="使用互斥量保护共享数据"><a href="#使用互斥量保护共享数据" class="headerlink" title="使用互斥量保护共享数据"></a>使用互斥量保护共享数据</h2><p>当访问共享数据前，使用互斥量将相关数据锁住，再当访问结束后，再将数据解锁。线程库需要保证，当一个线程使用特定互斥量锁住共享数据时，其他的线程想要访问锁住的数据，都必须等到之前那个线程对数据进行解锁后，才能进行访问。这就保证了所有线程能看到共享数据，而不破坏不变量。</p>
<h3 id="C-中使用互斥量"><a href="#C-中使用互斥量" class="headerlink" title="C++中使用互斥量"></a>C++中使用互斥量</h3><p>C++中通过实例化<code>std::mutex</code>创建互斥量，通过调用成员函数<code>lock()</code>进行上锁，<code>unlock()</code>进行解锁。C++标准库为互斥量提供了一个RAII语法的模板类<code>std::lock_guard</code>，其会在构造的时候提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁的互斥量总是会被正确的解锁。<code>std::mutex</code>和<code>std::lock_guard</code>都在<code>&lt;mutex&gt;</code>头文件中声明。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; some_list;    <span class="comment">// 1</span></span><br><span class="line">std::mutex some_mutex;    <span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_list</span><span class="params">(<span class="type">int</span> new_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(some_mutex)</span></span>;    <span class="comment">// 3</span></span><br><span class="line">  some_list.<span class="built_in">push_back</span>(new_value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">list_contains</span><span class="params">(<span class="type">int</span> value_to_find)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(some_mutex)</span></span>;    <span class="comment">// 4</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">find</span>(some_list.<span class="built_in">begin</span>(),some_list.<span class="built_in">end</span>(),value_to_find) != some_list.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>add_to_list()</code>③和<code>list_contains()</code>④函数中使用<code>std::lock_guard&lt;std::mutex&gt;</code>，使得这两个函数中对数据的访问是互斥的：<code>list_contains()</code>不可能看到正在被<code>add_to_list()</code>修改的列表。</p>
<p>互斥量和要保护的数据，在类中都需要定义为private成员，这会让访问数据的代码变的清晰，并且容易看出在什么时候对互斥量上锁。当所有成员函数都会在调用时对数据上锁，结束时对数据解锁，那么就保证了数据访问时不变量不被破坏。</p>
<h3 id="精心组织代码来保护共享数据"><a href="#精心组织代码来保护共享数据" class="headerlink" title="精心组织代码来保护共享数据"></a>精心组织代码来保护共享数据</h3><p>使用互斥量来保护数据，并不是仅仅在每一个成员函数中都加入一个<code>std::lock_guard</code>对象那么简单。在确保成员函数不会传出指针或引用的同时，检查成员函数是否通过指针或引用的方式来调用也是很重要的(尤其是这个操作不在你的控制下时)。函数可能没在互斥量保护的区域内，存储着指针或者引用，这样就很危险。更危险的是：将保护数据作为一个运行时参数，如同下面清单中所示那样。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">some_data</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  std::string b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">data_wrapper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_data data;</span><br><span class="line">  std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">process_data</span><span class="params">(Function func)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">l</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="built_in">func</span>(data);    <span class="comment">// 1 传递“保护”数据给用户函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">some_data* unprotected;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">malicious_function</span><span class="params">(some_data&amp; protected_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  unprotected=&amp;protected_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data_wrapper x;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x.<span class="built_in">process_data</span>(malicious_function);    <span class="comment">// 2 传递一个恶意函数</span></span><br><span class="line">  unprotected-&gt;<span class="built_in">do_something</span>();    <span class="comment">// 3 在无保护的情况下访问保护数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例子中process_data看起来没有任何问题，<code>std::lock_guard</code>对数据做了很好的保护，但调用用户提供的函数<code>func</code>①，就意味着foo能够绕过保护机制将函数<code>malicious_function</code>传递进去②，在没有锁定互斥量的情况下调用<code>do_something()</code>。</p>
<p>这段代码的问题在于根本没有保护，只是将所有可访问的数据结构代码标记为互斥。函数<code>foo()</code>中调用<code>unprotected-&gt;do_something()</code>的代码未能被标记为互斥。这种情况下，C++线程库无法提供任何帮助，只能由程序员来使用正确的互斥锁来保护数据。</p>
<h3 id="发现接口内在的条件竞争"><a href="#发现接口内在的条件竞争" class="headerlink" title="发现接口内在的条件竞争"></a>发现接口内在的条件竞争</h3><p>尽管链表的个别操作是安全的，但不意味着你就能走出困境；即使在一个很简单的接口中，依旧可能遇到条件竞争。例如，构建一个类似于<code>std::stack</code>结构的栈，除了构造函数和<code>swap()</code>以外，需要对<code>std::stack</code>提供五个操作：<code>push()</code>一个新元素进栈，<code>pop()</code>一个元素出栈，<code>top()</code>查看栈顶元素，<code>empty()</code>判断栈是否是空栈，<code>size()</code>了解栈中有多少个元素。即使修改了<code>top()</code>，使其返回一个拷贝而非引用，对内部数据使用一个互斥量进行保护，不过这个接口仍存在条件竞争。这个问题不仅存在于基于互斥量实现的接口中，在无锁实现的接口中，条件竞争依旧会产生。这是接口的问题，与其实现方式无关。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Container=std::deque&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> stack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">explicit</span> <span class="built_in">stack</span>(<span class="type">const</span> Container&amp;);</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">stack</span><span class="params">(Container&amp;&amp; = Container())</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="function"><span class="keyword">explicit</span> <span class="title">stack</span><span class="params">(<span class="type">const</span> Alloc&amp;)</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="built_in">stack</span>(<span class="type">const</span> Container&amp;, <span class="type">const</span> Alloc&amp;);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="built_in">stack</span>(Container&amp;&amp;, <span class="type">const</span> Alloc&amp;);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="built_in">stack</span>(stack&amp;&amp;, <span class="type">const</span> Alloc&amp;);</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">T <span class="type">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(stack&amp;&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>虽然<code>empty()</code>和<code>size()</code>可能在被调用并返回时是正确的，但其的结果是不可靠的；当它们返回后，其他线程就可以自由地访问栈，并且可能<code>push()</code>多个新元素到栈中，也可能<code>pop()</code>一些已在栈中的元素。这样的话，之前从<code>empty()</code>和<code>size()</code>得到的结果就有问题了。</p>
<p>特别地，当栈实例是非共享的，如果栈非空，使用<code>empty()</code>检查再调用<code>top()</code>访问栈顶部的元素是安全的。如下代码所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="keyword">if</span> (! s.<span class="built_in">empty</span>())&#123;    <span class="comment">// 1</span></span><br><span class="line">  <span class="type">int</span> <span class="type">const</span> value = s.<span class="built_in">top</span>();    <span class="comment">// 2</span></span><br><span class="line">  s.<span class="built_in">pop</span>();    <span class="comment">// 3</span></span><br><span class="line">  <span class="built_in">do_something</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于共享的栈对象，这样的调用顺序就不再安全了，因为在调用empty()①和调用top()②之间，可能有来自另一个线程的pop()调用并删除了最后一个元素。这是一个经典的条件竞争，使用互斥量对栈内部数据进行保护，但依旧不能阻止条件竞争的发生，这就是接口固有的问题。</p>
<p>当仔细的观察过之前的代码段，就会发现另一个潜在的条件竞争在调用top()②和pop()③之间。假设两个线程运行着前面的代码，并且都引用同一个栈对象s。这并非罕见的情况，当为性能而使用线程时，多个线程在不同的数据上执行相同的操作是很平常的，并且共享同一个栈可以将工作分摊给它们。假设，一开始栈中只有两个元素，这时任一线程上的empty()和top()都存在竞争，只需要考虑可能的执行顺序即可。</p>
<p>当栈被一个内部互斥量所保护时，只有一个线程可以调用栈的成员函数，所以调用可以很好地交错，并且<code>do_something()</code>是可以并发运行的。</p>
<p>当线程运行时，调用两次top()，栈没被修改，所以每个线程能得到同样的值。不仅是这样，在调用top()函数调用的过程中(两次)，pop()函数都没有被调用。这样，在其中一个值再读取的时候，虽然不会出现“写后读”的情况，但其值已被处理了两次。这种条件竞争，比未定义的empty()/top()竞争更加严重；虽然其结果依赖于do_something()的结果，但因为看起来没有任何错误，就会让这个Bug很难定位。</p>
<p>这就需要接口设计上有较大的改动，提议之一就是使用同一互斥量来保护top()和pop()。</p>
<p>pop()操作分为两部分：先获取顶部元素(top())，然后从栈中移除(pop())。这样，在不能安全的将元素拷贝出去的情况下，栈中的这个数据还依旧存在，没有丢失。这样的分割却制造了本想避免或消除的条件竞争。幸运的是，我们还有的别的选项，但是使用这些选项是要付出代价的。</p>
<p>选项1： 传入一个引用。第一个选项是将变量的引用作为参数，传入pop()函数中获取想要的“弹出值”：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">some_stack.<span class="built_in">pop</span>(result);</span><br></pre></td></tr></table></figure></p>
<p>大多数情况下，这种方式还不错，但有明显的缺点：需要构造出一个栈中类型的实例，用于接收目标值。</p>
<p>选项2：无异常抛出的拷贝构造函数或移动构造函数。对于有返回值的pop()函数来说，只有“异常安全”方面的担忧。很多类型都有拷贝构造函数，它们不会抛出异常，并且随着新标准中对“右值引用”的支持，很多类型都将会有一个移动构造函数，即使他们和拷贝构造函数做着相同的事情，它也不会抛出异常。</p>
<p>选项3：返回指向弹出值的指针。指针的优势是自由拷贝，并且不会产生异常。对于选择这个方案的接口，使用<code>std::shared_ptr</code>是个不错的选择；不仅能避免内存泄露(因为当对象中指针销毁时，对象也会被销毁)，而且标准库能够完全控制内存分配方案，也就不需要new和delete操作。</p>
<p>一个接口没有条件竞争的堆栈类定义，它实现了选项1和选项3：重载了<code>pop()</code>，使用一个局部引用去存储弹出值，并返回一个<code>std::shared_ptr&lt;&gt;</code>对象。它有一个简单的接口，只有两个函数：<code>push()</code>和<code>pop()</code>;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  <span class="comment">// For std::shared_ptr&lt;&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">empty_stack</span>: std::exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">threadsafe_stack</span>();</span><br><span class="line">  <span class="built_in">threadsafe_stack</span>(<span class="type">const</span> threadsafe_stack&amp;);</span><br><span class="line">  threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>; <span class="comment">// 1 赋值操作被删除</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span>;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>削减接口可以获得最大程度的安全,甚至限制对栈的一些操作。栈是不能直接赋值的，因为赋值操作已经删除了①，并且这里没有<code>swap()</code>函数。栈可以拷贝的，假设栈中的元素可以拷贝。当栈为空时，<code>pop()</code>函数会抛出一个empty_stack异常，所以在<code>empty()</code>函数被调用后，其他部件还能正常工作。如选项3描述的那样，使用<code>std::shared_ptr</code>可以避免内存分配管理的问题，并避免多次使用new和delete操作。</p>
<p>下面的代码将展示一个简单的实现——封装std::stack&lt;&gt;的线程安全堆栈。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">empty_stack</span>: std::exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;empty stack!&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::stack&lt;T&gt; data;</span><br><span class="line">  <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">threadsafe_stack</span>()</span><br><span class="line">    : <span class="built_in">data</span>(std::<span class="built_in">stack</span>&lt;T&gt;())&#123;&#125;</span><br><span class="line">  <span class="built_in">threadsafe_stack</span>(<span class="type">const</span> threadsafe_stack&amp; other)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;</span><br><span class="line">    data = other.data; <span class="comment">// 1 在构造函数体中的执行拷贝</span></span><br><span class="line">  &#125;</span><br><span class="line">  threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    data.<span class="built_in">push</span>(new_value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>(); <span class="comment">// 在调用pop前，检查栈是否为空</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="type">const</span> <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data.top()))</span></span>; <span class="comment">// 在修改堆栈前，分配出返回值</span></span><br><span class="line">    data.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">    value=data.<span class="built_in">top</span>();</span><br><span class="line">    data.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用多个互斥量保护所有的数据，细粒度锁也有问题。如前所述，当增大互斥量覆盖数据的粒度时，只需要锁住一个互斥量。但是，这种方案并非放之四海皆准，比如：互斥量正在保护一个独立类的实例；这种情况下，锁的状态的下一个阶段，不是离开锁定区域将锁定区域还给用户，就是有独立的互斥量去保护这个类的全部实例。当然，这两种方式都不理想。</p>
<p>一个给定操作需要两个或两个以上的互斥量时，另一个潜在的问题将出现：死锁。与条件竞争完全相反——不同的两个线程会互相等待，从而什么都没做。</p>
<h3 id="死锁：问题描述及解决方案"><a href="#死锁：问题描述及解决方案" class="headerlink" title="死锁：问题描述及解决方案"></a>死锁：问题描述及解决方案</h3><p>避免死锁的一般建议，就是让两个互斥量总以相同的顺序上锁：总在互斥量B之前锁住互斥量A，就永远不会死锁。不过，选择一个固定的顺序(例如，实例提供的第一互斥量作为第一个参数，提供的第二个互斥量为第二个参数)，可能会适得其反：在参数交换了之后，两个线程试图在相同的两个实例间进行数据交换时，程序又死锁了！</p>
<p>很幸运，C++标准库有办法解决这个问题，<code>std::lock</code>——可以一次性锁住多个(两个以上)的互斥量，并且没有副作用(死锁风险)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的std::lock()需要包含&lt;mutex&gt;头文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">some_big_object</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; lhs,some_big_object&amp; rhs)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_big_object some_detail;</span><br><span class="line">  std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>(some_big_object <span class="type">const</span>&amp; sd):<span class="built_in">some_detail</span>(sd)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;lhs==&amp;rhs)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    std::<span class="built_in">lock</span>(lhs.m,rhs.m); <span class="comment">// 1</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m,std::adopt_lock)</span></span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m,std::adopt_lock)</span></span>; <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">swap</span>(lhs.some_detail,rhs.some_detail);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>首先，检查参数是否是不同的实例，因为操作试图获取<code>std::mutex</code>对象上的锁，所以当其被获取时，结果很难预料。然后，调用<code>std::lock()</code>①锁住两个互斥量，并且两个<code>std:lock_guard</code>实例已经创建好②③。提供<code>std::adopt_lock</code>参数除了表示<code>std::lock_guard</code>对象可获取锁之外，还将锁交由<code>std::lock_guard</code>对象管理，而不需要<code>std::lock_guard</code>对象再去构建新的锁。</p>
<p>这样，就能保证在大多数情况下，函数退出时互斥量能被正确的解锁(保护操作可能会抛出一个异常)，也允许使用一个简单的“return”作为返回。还有，需要注意的是，当使用<code>std::lock</code>去锁<code>lhs.m</code>或<code>rhs.m</code>时，可能会抛出异常；这种情况下，异常会传播到<code>std::lock</code>之外。当<code>std::lock</code>成功的获取一个互斥量上的锁，并且当其尝试从另一个互斥量上再获取锁时，就会有异常抛出，第一个锁也会随着异常的产生而自动释放，所以<code>std::lock</code>要么将两个锁都锁住，要不一个都不锁。</p>
<p>虽然<code>std::lock</code>可以在这情况下(获取两个以上的锁)避免死锁，但它没办法帮助你获取其中一个锁。</p>
<h3 id="避免死锁的进阶指导"><a href="#避免死锁的进阶指导" class="headerlink" title="避免死锁的进阶指导"></a>避免死锁的进阶指导</h3><h4 id="避免嵌套锁"><a href="#避免嵌套锁" class="headerlink" title="避免嵌套锁"></a>避免嵌套锁</h4><p>一个线程已获得一个锁时，再别去获取第二个。即使互斥锁造成死锁的最常见原因，也可能会在其他方面受到死锁的困扰(比如：线程间的互相等待)。当你需要获取多个锁，使用一个<code>std::lock</code>来做这件事(对获取锁的操作上锁)，避免产生死锁。</p>
<h4 id="避免在持有锁时调用用户提供的代码"><a href="#避免在持有锁时调用用户提供的代码" class="headerlink" title="避免在持有锁时调用用户提供的代码"></a>避免在持有锁时调用用户提供的代码</h4><p>你在持有锁的情况下，调用用户提供的代码；如果用户代码要获取一个锁，就会违反第一个指导意见，并造成死锁(有时，这是无法避免的)。</p>
<h4 id="使用固定顺序获取锁"><a href="#使用固定顺序获取锁" class="headerlink" title="使用固定顺序获取锁"></a>使用固定顺序获取锁</h4><p>当硬性条件要求你获取两个以上(包括两个)的锁，并且不能使用<code>std::lock</code>单独操作来获取它们；那么最好在每个线程上，用固定的顺序获取它们获取它们(锁)。</p>
<h4 id="使用锁的层次结构"><a href="#使用锁的层次结构" class="headerlink" title="使用锁的层次结构"></a>使用锁的层次结构</h4><p>虽然，这对于定义锁的顺序，的确是一个特殊的情况，但锁的层次的意义在于提供对运行时约定是否被坚持的检查。这个建议需要对你的应用进行分层，并且识别在给定层上所有可上锁的互斥量。当代码试图对一个互斥量上锁，在该层锁已被低层持有时，上锁是不允许的。你可以在运行时对其进行检查，通过分配层数到每个互斥量上，以及记录被每个线程上锁的互斥量。下面的代码列表中将展示两个线程如何使用分层互斥。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">hierarchical_mutex <span class="title">high_level_mutex</span><span class="params">(<span class="number">10000</span>)</span></span>; <span class="comment">// 1</span></span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">low_level_mutex</span><span class="params">(<span class="number">5000</span>)</span></span>;  <span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">do_low_level_stuff</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">low_level_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(low_level_mutex)</span></span>; <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">do_low_level_stuff</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">high_level_stuff</span><span class="params">(<span class="type">int</span> some_param)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">high_level_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(high_level_mutex)</span></span>; <span class="comment">// 4</span></span><br><span class="line">  <span class="built_in">high_level_stuff</span>(<span class="built_in">low_level_func</span>()); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_a</span><span class="params">()</span>  <span class="comment">// 6</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">high_level_func</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">other_mutex</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">// 7</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_other_stuff</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">other_stuff</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">high_level_func</span>();  <span class="comment">// 8</span></span><br><span class="line">  <span class="built_in">do_other_stuff</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_b</span><span class="params">()</span> <span class="comment">// 9</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(other_mutex)</span></span>; <span class="comment">// 10</span></span><br><span class="line">  <span class="built_in">other_stuff</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>thread_a()</code>⑥遵守规则，所以它运行的没问题。另一方面，<code>thread_b()</code>⑨无视规则，因此在运行的时候肯定会失败。<code>thread_a()</code>调用<code>high_level_func()</code>，让<code>high_level_mutex</code>④上锁(其层级值为10000①)，为了获取<code>high_level_stuff()</code>的参数对互斥量上锁，之后调用<code>low_level_func()</code>⑤。<code>low_level_func()</code>会对<code>low_level_mutex</code>上锁，这就没有问题了，因为这个互斥量有一个低层值5000②。</p>
<p><code>thread_b()</code>运行就不会顺利了。首先，它锁住了<code>other_mutex</code>⑩，这个互斥量的层级值只有100⑦。这就意味着，超低层级的数据已被保护。当<code>other_stuff()</code>调用<code>high_level_func()</code>⑧时，就违反了层级结构：<code>high_level_func()</code>试图获取<code>high_level_mutex</code>，这个互斥量的层级值是10000，要比当前层级值100大很多。因此<code>hierarchical_mutex</code>将会产生一个错误，可能会是抛出一个异常，或直接终止程序。在层级互斥量上产生死锁，是不可能的，因为互斥量本身会严格遵循约定顺序，进行上锁。这也意味，当多个互斥量在是在同一级上时，不能同时持有多个锁，所以“手递手”锁的方案需要每个互斥量在一条链上，并且每个互斥量都比其前一个有更低的层级值，这在某些情况下无法实现。</p>
<p>例子也展示了另一点，<code>std::lock_guard&lt;&gt;</code>模板与用户定义的互斥量类型一起使用。虽然<code>hierarchical_mutex</code>不是C++标准的一部分，但是它写起来很容易。尽管它是一个用户定义类型，它可以用于<code>std::lock_guard&lt;&gt;</code>模板中，因为它的实现有三个成员函数为了满足互斥量操作：<code>lock()</code>, <code>unlock()</code> 和<code>try_lock()</code>。虽然你还没见过<code>try_lock()</code>怎么使用，但是其使用起来很简单：当互斥量上的锁被一个线程持有，它将返回false，而不是等待调用的线程，直到能够获取互斥量上的锁为止。在<code>std::lock()</code>的内部实现中，<code>try_lock()</code>会作为避免死锁算法的一部分。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hierarchical_mutex</span></span><br><span class="line">&#123;</span><br><span class="line">  std::mutex internal_mutex;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hierarchy_value;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> previous_hierarchy_value;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">long</span> this_thread_hierarchy_value;  <span class="comment">// 1</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">check_for_hierarchy_violation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(this_thread_hierarchy_value &lt;= hierarchy_value)  <span class="comment">// 2</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(“mutex hierarchy violated”);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update_hierarchy_value</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    previous_hierarchy_value=this_thread_hierarchy_value;  <span class="comment">// 3</span></span><br><span class="line">    this_thread_hierarchy_value=hierarchy_value;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hierarchical_mutex</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> value)</span>:</span></span><br><span class="line"><span class="function">      hierarchy_value(value),</span></span><br><span class="line"><span class="function">      previous_hierarchy_value(<span class="number">0</span>)</span></span><br><span class="line"><span class="function">  &#123;</span>&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">    internal_mutex.<span class="built_in">lock</span>();  <span class="comment">// 4</span></span><br><span class="line">    <span class="built_in">update_hierarchy_value</span>();  <span class="comment">// 5</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    this_thread_hierarchy_value=previous_hierarchy_value;  <span class="comment">// 6</span></span><br><span class="line">    internal_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">    <span class="keyword">if</span>(!internal_mutex.<span class="built_in">try_lock</span>())  <span class="comment">// 7</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">long</span></span></span><br><span class="line"><span class="function">     <span class="title">hierarchical_mutex::this_thread_hierarchy_value</span><span class="params">(ULONG_MAX)</span></span>;  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure></p>
<p>这里重点是使用了thread_local的值来代表当前线程的层级值：<code>this_thread_hierarchy_value</code>①。它被初始化为最大值⑧，所以最初所有线程都能被锁住。因为其声明中有<code>thread_local</code>，所以每个线程都有其拷贝副本，这样线程中变量状态完全独立，当从另一个线程进行读取时，变量的状态也完全独立。</p>
<p>所以，第一次线程锁住一个<code>hierarchical_mutex</code>时，<code>this_thread_hierarchy_value</code>的值是<code>ULONG_MAX</code>。由于其本身的性质，这个值会大于其他任何值，所以会通过<code>check_for_hierarchy_vilation()</code>②的检查。在这种检查方式下，<code>lock()</code>代表内部互斥锁已被锁住④。一旦成功锁住，你可以更新层级值了⑤。</p>
<p>当你现在锁住另一个<code>hierarchical_mutex</code>时，还持有第一个锁，<code>this_thread_hierarchy_value</code>的值将会显示第一个互斥量的层级值。第二个互斥量的层级值必须小于已经持有互斥量检查函数②才能通过。</p>
<p>现在，最重要的是为当前线程存储之前的层级值，所以你可以调用<code>unlock()</code>⑥对层级值进行保存；否则，就锁不住任何互斥量(第二个互斥量的层级数高于第一个互斥量)，即使线程没有持有任何锁。因为保存了之前的层级值，只有当持有<code>internal_mutex</code>③，且在解锁内部互斥量⑥之前存储它的层级值，才能安全的将<code>hierarchical_mutex</code>自身进行存储。这是因为<code>hierarchical_mutex</code>被内部互斥量的锁所保护着。</p>
<p><code>try_lock()</code>与<code>lock()</code>的功能相似，除了在调用<code>internal_mutex</code>的<code>try_lock()</code>⑦失败时，不能持有对应锁，所以不必更新层级值，并直接返回false。</p>
<h3 id="std-unique-lock——灵活的锁"><a href="#std-unique-lock——灵活的锁" class="headerlink" title="std::unique_lock——灵活的锁"></a>std::unique_lock——灵活的锁</h3><p><code>std::unqiue_lock</code>使用更为自由的不变量，这样<code>std::unique_lock</code>实例不会总与互斥量的数据类型相关，使用起来要比<code>std:lock_guard</code>更加灵活。首先，可将<code>std::adopt_lock</code>作为第二个参数传入构造函数，对互斥量进行管理；也可以将<code>std::defer_lock</code>作为第二个参数传递进去，表明互斥量应保持解锁状态。这样，就可以被<code>std::unique_lock</code>对象(不是互斥量)的<code>lock()</code>函数的所获取，或传递<code>std::unique_lock</code>对象到<code>std::lock()</code>中。保证灵活性要付出代价，这个代价就是允许<code>std::unique_lock</code>实例不带互斥量：信息已被存储，且已被更新。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">some_big_object</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; lhs,some_big_object&amp; rhs)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_big_object some_detail;</span><br><span class="line">  std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>(some_big_object <span class="type">const</span>&amp; sd):<span class="built_in">some_detail</span>(sd)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;lhs==&amp;rhs)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m,std::defer_lock)</span></span>; <span class="comment">// 1 </span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m,std::defer_lock)</span></span>; <span class="comment">// 1 std::def_lock 留下未上锁的互斥量</span></span><br><span class="line">    std::<span class="built_in">lock</span>(lock_a,lock_b); <span class="comment">// 2 互斥量在这里上锁</span></span><br><span class="line">    <span class="built_in">swap</span>(lhs.some_detail,rhs.some_detail);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为<code>std::unique_lock</code>支持<code>lock()</code>, <code>try_lock()</code>和<code>unlock()</code>成员函数，所以能将<code>std::unique_lock</code>对象传递到<code>std::lock()</code>②。这些同名的成员函数在低层做着实际的工作，并且仅更新<code>std::unique_lock</code>实例中的标志，来确定该实例是否拥有特定的互斥量，这个标志是为了确保<code>unlock()</code>在析构函数中被正确调用。如果实例拥有互斥量，那么析构函数必须调用<code>unlock()</code>；但当实例中没有互斥量时，析构函数就不能去调用<code>unlock()</code>。这个标志可以通过<code>owns_lock()</code>成员变量进行查询。</p>
<p>可能如你期望的那样，这个标志被存储在某个地方。因此，<code>std::unique_lock</code>对象的体积通常要比<code>std::lock_guard</code>对象大，当使用<code>std::unique_lock</code>替代<code>std::lock_guard</code>，因为会对标志进行适当的更新或检查，就会做些轻微的性能惩罚。当<code>std::lock_guard</code>已经能够满足你的需求，那么还是建议你继续使用它。当需要更加灵活的锁时，最好选择<code>std::unique_lock</code>，因为它更适合于你的任务。</p>
<h3 id="不同域中互斥量所有权的传递"><a href="#不同域中互斥量所有权的传递" class="headerlink" title="不同域中互斥量所有权的传递"></a>不同域中互斥量所有权的传递</h3><p><code>std::unique_lock</code>实例没有与自身相关的互斥量，一个互斥量的所有权可以通过移动操作，在不同的实例中进行传递。某些情况下，这种转移是自动发生的，例如:当函数返回一个实例；另些情况下，需要显式的调用<code>std::move()</code>来执行移动操作。从本质上来说，需要依赖于源值是否是左值——一个实际的值或是引用——或一个右值——一个临时类型。当源值是一个右值，为了避免转移所有权过程出错，就必须显式移动成左值。<code>std::unique_lock</code>是可移动，但不可赋值的类型。</p>
<p>一种使用可能是允许一个函数去锁住一个互斥量，并且将所有权移到调用者上，所以调用者可以在这个锁保护的范围内执行额外的动作。</p>
<p>下面的程序片段展示了：函数<code>get_lock()</code>锁住了互斥量，然后准备数据，返回锁的调用函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">get_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">extern</span> std::mutex some_mutex;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(some_mutex)</span></span>;</span><br><span class="line">  <span class="built_in">prepare_data</span>();</span><br><span class="line">  <span class="keyword">return</span> lk;  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(get_lock())</span></span>;  <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>lk</code>在函数中被声明为自动变量，它不需要调用<code>std::move()</code>，可以直接返回①(编译器负责调用移动构造函数)。<code>process_data()</code>函数直接转移<code>std::unique_lock</code>实例的所有权②，调用<code>do_something()</code>可使用的正确数据(数据没有受到其他线程的修改)。</p>
<p>通常这种模式会用于已锁的互斥量，其依赖于当前程序的状态，或依赖于传入返回类型为<code>std::unique_lock</code>的函数(或以参数返回)。这样的用法不会直接返回锁，不过网关类的一个数据成员可用来确认已经对保护数据的访问权限进行上锁。这种情况下，所有的访问都必须通过网关类：当你想要访问数据，需要获取网关类的实例(如同前面的例子，通过调用<code>get_lock()</code>之类函数)来获取锁。之后你就可以通过网关类的成员函数对数据进行访问。当完成访问，可以销毁这个网关类对象，将锁进行释放，让别的线程来访问保护数据。这样的一个网关类可能是可移动的(所以他可以从一个函数进行返回)，在这种情况下锁对象的数据必须是可移动的。</p>
<p><code>std::unique_lock</code>的灵活性同样也允许实例在销毁之前放弃其拥有的锁。可以使用<code>unlock()</code>来做这件事，如同一个互斥量：<code>std::unique_lock</code>的成员函数提供类似于锁定和解锁互斥量的功能。<code>std::unique_lock</code>实例在销毁前释放锁的能力，当锁没有必要在持有的时候，可以在特定的代码分支对其进行选择性的释放。这对于应用性能来说很重要，因为持有锁的时间增加会导致性能下降，其他线程会等待这个锁的释放，避免超越操作。</p>
<h3 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h3><p>一个细粒度锁(a fine-grained lock)能够保护较小的数据量，一个粗粒度锁(a coarse-grained lock)能够保护较多的数据量。</p>
<p>如果很多线程正在等待同一个资源，当有线程持有锁的时间过长，这就会增加等待的时间。在可能的情况下，锁住互斥量的同时只能对共享数据进行访问；试图对锁外数据进行处理。</p>
<p><code>std::unique_lock</code>在这种情况下工作正常，在调用<code>unlock()</code>时，代码不需要再访问共享数据；而后当再次需要对共享数据进行访问时，就可以再调用<code>lock()</code>了。下面代码就是这样的一种情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_and_process_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">my_lock</span><span class="params">(the_mutex)</span></span>;</span><br><span class="line">  some_class data_to_process=<span class="built_in">get_next_data_chunk</span>();</span><br><span class="line">  my_lock.<span class="built_in">unlock</span>();  <span class="comment">// 1 不要让锁住的互斥量越过process()函数的调用</span></span><br><span class="line">  result_type result=<span class="built_in">process</span>(data_to_process);</span><br><span class="line">  my_lock.<span class="built_in">lock</span>(); <span class="comment">// 2 为了写入数据，对互斥量再次上锁</span></span><br><span class="line">  <span class="built_in">write_result</span>(data_to_process,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不需要让锁住的互斥量越过对<code>process()</code>函数的调用，所以可以在函数调用①前对互斥量手动解锁，并且在之后对其再次上锁②。</p>
<p>这能表示只有一个互斥量保护整个数据结构时的情况，不仅可能会有更多对锁的竞争，也会增加锁持锁的时间。较多的操作步骤需要获取同一个互斥量上的锁，所以持有锁的时间会更长。成本上的双重打击也算是为向细粒度锁转移提供了双重激励和可能。</p>
<p>如同上面的例子，锁不仅是能锁住合适粒度的数据，还要控制锁的持有时间，以及什么操作在执行的同时能够拥有锁。一般情况下，执行必要的操作时，尽可能将持有锁的时间缩减到最小。这也就意味有一些浪费时间的操作，比如：获取另外一个锁(即使你知道这不会造成死锁)，或等待输入/输出操作完成时没有必要持有一个锁(除非绝对需要)。</p>
<h2 id="保护共享数据的替代设施"><a href="#保护共享数据的替代设施" class="headerlink" title="保护共享数据的替代设施"></a>保护共享数据的替代设施</h2><p>互斥量是最通用的机制，但其并非保护共享数据的唯一方式。这里有很多替代方式可以在特定情况下，提供更加合适的保护。</p>
<p>一个特别极端(但十分常见)的情况就是，共享数据在并发访问和初始化时(都需要保护)，但是之后需要进行隐式同步。这可能是因为数据作为只读方式创建，所以没有同步问题；或者因为必要的保护作为对数据操作的一部分，所以隐式的执行。任何情况下，数据初始化后锁住一个互斥量，纯粹是为了保护其初始化过程(这是没有必要的)，并且这会给性能带来不必要的冲击。出于以上的原因，C++标准提供了一种纯粹保护共享数据初始化过程的机制。</p>
<h3 id="保护共享数据的初始化过程"><a href="#保护共享数据的初始化过程" class="headerlink" title="保护共享数据的初始化过程"></a>保护共享数据的初始化过程</h3><p>假设你与一个共享源，构建代价很昂贵，可能它会打开一个数据库连接或分配出很多的内存。</p>
<p>延迟初始化(Lazy initialization)在单线程代码很常见——每一个操作都需要先对源进行检查，为了了解数据是否被初始化，然后在其使用前决定，数据是否需要初始化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!resource_ptr)</span><br><span class="line">  &#123;</span><br><span class="line">    resource_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resource);  <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">  resource_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当共享数据对于并发访问是安全的，①是转为多线程代码时，需要保护的，但是下面天真的转换会使得线程资源产生不必要的序列化。这是因为每个线程必须等待互斥量，为了确定数据源已经初始化了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr;</span><br><span class="line">std::mutex resource_mutex;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(resource_mutex)</span></span>;  <span class="comment">// 所有线程在此序列化 </span></span><br><span class="line">  <span class="keyword">if</span>(!resource_ptr)</span><br><span class="line">  &#123;</span><br><span class="line">    resource_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resource);  <span class="comment">// 只有初始化过程需要保护 </span></span><br><span class="line">  &#125;</span><br><span class="line">  lk.<span class="built_in">unlock</span>();</span><br><span class="line">  resource_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码相当常见了，也足够表现出没必要的线程化问题，很多人能想出更好的一些的办法来做这件事，包括声名狼藉的双重检查锁模式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">undefined_behaviour_with_double_checked_locking</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!resource_ptr)  <span class="comment">// 1</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(resource_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!resource_ptr)  <span class="comment">// 2</span></span><br><span class="line">    &#123;</span><br><span class="line">      resource_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resource);  <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  resource_ptr-&gt;<span class="built_in">do_something</span>();  <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针第一次读取数据不需要获取锁①，并且只有在指针为NULL时才需要获取锁。然后，当获取锁之后，指针会被再次检查一遍② (这就是双重检查的部分)，避免另一的线程在第一次检查后再做初始化，并且让当前线程获取锁。</p>
<p>这个模式为什么声名狼藉呢？因为这里有潜在的条件竞争，未被锁保护的读取操作①没有与其他线程里被锁保护的写入操作③进行同步。因此就会产生条件竞争，这个条件竞争不仅覆盖指针本身，还会影响到其指向的对象；即使一个线程知道另一个线程完成对指针进行写入，它可能没有看到新创建的some_resource实例，然后调用do_something()④后，得到不正确的结果。这个例子是在一种典型的条件竞争——数据竞争，C++标准中这就会被指定为“未定义行为”。这种竞争肯定是可以避免的。</p>
<p>C++标准委员会也认为条件竞争的处理很重要，所以C++标准库提供了<code>std::once_flag</code>和<code>std::call_once</code>来处理这种情况。比起锁住互斥量，并显式的检查指针，每个线程只需要使用<code>std::call_once</code>，在<code>std::call_once</code>的结束时，就能安全的知道指针已经被其他的线程初始化了。使用<code>std::call_once</code>比显式使用互斥量消耗的资源更少，特别是当初始化完成后。在这种情况下，初始化通过调用函数完成，同样这样操作使用类中的函数操作符来实现同样很简单。如同大多数在标准库中的函数一样，或作为函数被调用，或作为参数被传递，<code>std::call_once</code>可以和任何函数或可调用对象一起使用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr;</span><br><span class="line">std::once_flag resource_flag;  <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_resource</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  resource_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::<span class="built_in">call_once</span>(resource_flag,init_resource);  <span class="comment">// 可以完整的进行一次初始化</span></span><br><span class="line">  resource_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，<code>std::once_flag</code>①和初始化好的数据都是命名空间区域的对象，但是<code>std::call_once()</code>可仅作为延迟初始化的类型成员，如同下面的例子一样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  connection_info connection_details;</span><br><span class="line">  connection_handle connection;</span><br><span class="line">  std::once_flag connection_init_flag;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">open_connection</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    connection=connection_manager.<span class="built_in">open</span>(connection_details);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>(connection_info <span class="type">const</span>&amp; connection_details_):</span><br><span class="line">      <span class="built_in">connection_details</span>(connection_details_)</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">send_data</span><span class="params">(data_packet <span class="type">const</span>&amp; data)</span>  <span class="comment">// 1</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(connection_init_flag,&amp;X::open_connection,<span class="keyword">this</span>);  <span class="comment">// 2</span></span><br><span class="line">    connection.<span class="built_in">send_data</span>(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">data_packet <span class="title">receive_data</span><span class="params">()</span>  <span class="comment">// 3</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(connection_init_flag,&amp;X::open_connection,<span class="keyword">this</span>);  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> connection.<span class="built_in">receive_data</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>例子中第一个调用<code>send_data()</code>①或<code>receive_data()</code>③的线程完成初始化过程。使用成员函数<code>open_connection()</code>去初始化数据，也需要将this指针传进去。和其在在标准库中的函数一样，其接受可调用对象，比如<code>std::thread</code>的构造函数和<code>std::bind()</code>，通过向<code>std::call_once</code>()②传递一个额外的参数来完成这个操作。</p>
<p>值得注意的是，<code>std::mutex</code>和<code>std::once_flag</code>的实例就不能拷贝和移动，所以当你使用它们作为类成员函数，如果你需要用到他们，你就得显示定义这些特殊的成员函数。</p>
<p>还有一种情形的初始化过程中潜存着条件竞争：其中一个局部变量被声明为static类型。这种变量的在声明后就已经完成初始化；对于多线程调用的函数，这就意味着这里有条件竞争——抢着去定义这个变量。在C++11标准中，初始化及定义完全在一个线程中发生，并且没有其他线程可在初始化完成前对其进行处理，条件竞争终止于初始化阶段，这样比在之后再去处理好的多。在只需要一个全局实例情况下，这里提供一个<code>std::call_once</code>的替代方案<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span>;</span><br><span class="line"><span class="function">my_class&amp; <span class="title">get_my_class_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> my_class instance;  <span class="comment">// 线程安全的初始化过程</span></span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>多线程可以安全的调用<code>get_my_class_instance()</code>①函数，不用为数据竞争而担心。</p>
<p>对于很少有更新的数据结构来说，只在初始化时保护数据。在大多数情况下，这种数据结构是只读的，并且多线程对其并发的读取也是很愉快的，不过一旦数据结构需要更新，就会产生竞争。</p>
<h3 id="保护很少更新的数据结构"><a href="#保护很少更新的数据结构" class="headerlink" title="保护很少更新的数据结构"></a>保护很少更新的数据结构</h3><p>比起使用<code>std::mutex</code>实例进行同步，不如使用<code>boost::shared_mutex</code>来做同步。对于更新操作，可以使用<code>std::lock_guard&lt;boost::shared_mutex&gt;</code>和<code>std::unique_lock&lt;boost::shared_mutex&gt;</code>上锁。作为<code>std::mutex</code>的替代方案，这就能保证更新线程的独占访问。因为其他线程不需要去修改数据结构，所以其可以使用<code>boost::shared_lock&lt;boost::shared_mutex&gt;</code>获取访问权。这与使用<code>std::unique_lock</code>一样，除非多线程要在同时获取同一个<code>boost::shared_mutex</code>上有共享锁。唯一的限制：当任一线程拥有一个共享锁时，这个线程就会尝试获取一个独占锁，直到其他线程放弃他们的锁；同样的，当任一线程拥有一个独占锁时，其他线程就无法获得共享锁或独占锁，直到第一个线程放弃其拥有的锁。</p>
<p>如同之前描述的那样，下面的代码清单展示了一个简单的DNS缓存，使用std::map持有缓存数据，使用boost::shared_mutex进行保护。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/thread/shared_mutex.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dns_entry</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dns_cache</span></span><br><span class="line">&#123;</span><br><span class="line">  std::map&lt;std::string,dns_entry&gt; entries;</span><br><span class="line">  <span class="keyword">mutable</span> boost::shared_mutex entry_mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">dns_entry <span class="title">find_entry</span><span class="params">(std::string <span class="type">const</span>&amp; domain)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">boost::shared_lock&lt;boost::shared_mutex&gt; <span class="title">lk</span><span class="params">(entry_mutex)</span></span>;  <span class="comment">// 1</span></span><br><span class="line">    std::map&lt;std::string,dns_entry&gt;::const_iterator <span class="type">const</span> it=</span><br><span class="line">       entries.<span class="built_in">find</span>(domain);</span><br><span class="line">    <span class="keyword">return</span> (it==entries.<span class="built_in">end</span>())?<span class="built_in">dns_entry</span>():it-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update_or_add_entry</span><span class="params">(std::string <span class="type">const</span>&amp; domain,</span></span></span><br><span class="line"><span class="params"><span class="function">                           dns_entry <span class="type">const</span>&amp; dns_details)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;boost::shared_mutex&gt; <span class="title">lk</span><span class="params">(entry_mutex)</span></span>;  <span class="comment">// 2</span></span><br><span class="line">    entries[domain]=dns_details;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>find_entry()</code>使用<code>boost::shared_lock&lt;&gt;</code>来保护共享和只读权限①；这就使得多线程可以同时调用<code>find_entry()</code>，且不会出错。另一方面，<code>update_or_add_entry()</code>使用<code>std::lock_guard&lt;&gt;</code>实例，当表格需要更新时②，为其提供独占访问权限；<code>update_or_add_entry()</code>函数调用时，独占锁会阻止其他线程对数据结构进行修改，并且阻止线程调用<code>find_entry()</code>。</p>
<h3 id="嵌套锁"><a href="#嵌套锁" class="headerlink" title="嵌套锁"></a>嵌套锁</h3><p>当一个线程已经获取一个<code>std::mutex</code>时(已经上锁)，并对其再次上锁，这个操作就是错误的，并且继续尝试这样做的话，就会产生未定义行为。然而，在某些情况下，一个线程尝试获取同一个互斥量多次，而没有对其进行一次释放是可以的。之所以可以，是因为C++标准库提供了<code>std::recursive_mutex</code>类。其功能与<code>std::mutex</code>类似，除了你可以从同一线程的单个实例上获取多个锁。互斥量锁住其他线程前，你必须释放你拥有的所有锁，所以当你调用<code>lock()</code>三次时，你也必须调用<code>unlock()</code>三次。正确使用<code>std::lock_guard&lt;std::recursive_mutex&gt;</code>和<code>std::unique_lock&lt;std::recursice_mutex&gt;</code>可以帮你处理这些问题。</p>
<h1 id="同步并发操作"><a href="#同步并发操作" class="headerlink" title="同步并发操作"></a>同步并发操作</h1><h2 id="等待一个事件或其他条件"><a href="#等待一个事件或其他条件" class="headerlink" title="等待一个事件或其他条件"></a>等待一个事件或其他条件</h2><p>当一个线程等待另一个线程完成任务时，它可以持续的检查共享数据标志(用于做保护工作的互斥量)，直到另一线程完成工作时对这个标志进行重设。不过，就是一种浪费：线程消耗宝贵的执行时间持续的检查对应标志，并且当互斥量被等待线程上锁后，其他线程就没有办法获取锁，这样线程就会持续等待。</p>
<p>第二个选择是在等待线程在检查间隙，使用<code>std::this_thread::sleep_for()</code>进行周期性的间歇：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag;</span><br><span class="line">std::mutex m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait_for_flag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">  <span class="keyword">while</span>(!flag)</span><br><span class="line">  &#123;</span><br><span class="line">    lk.<span class="built_in">unlock</span>();  <span class="comment">// 1 解锁互斥量</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));  <span class="comment">// 2 休眠100ms</span></span><br><span class="line">    lk.<span class="built_in">lock</span>();   <span class="comment">// 3 再锁互斥量</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个循环中，在休眠前②，函数对互斥量进行解锁①，并且在休眠结束后再对互斥量进行上锁，所以另外的线程就有机会获取锁并设置标识。</p>
<p>第三个选择(也是优先的选择)是，使用C++标准库提供的工具去等待事件的发生。通过另一线程触发等待事件的机制是最基本的唤醒方式，这种机制就称为“条件变量”。从概念上来说，一个条件变量会与多个事件或其他条件相关，并且一个或多个线程会等待条件的达成。当某些线程被终止时，为了唤醒等待线程(允许等待线程继续执行)终止的线程将会向等待着的线程广播“条件达成”的信息。</p>
<h3 id="等待条件达成"><a href="#等待条件达成" class="headerlink" title="等待条件达成"></a>等待条件达成</h3><p>C++标准库对条件变量有两套实现：<code>std::condition_variable</code>和<code>std::condition_variable_any</code>。这两个实现都包含在<code>&lt;condition_variable&gt;</code>头文件的声明中。两者都需要与一个互斥量一起才能工作(互斥量是为了同步)；前者仅限于与<code>std::mutex</code>一起工作，而后者可以和任何满足最低标准的互斥量一起工作，从而加上了<code>_any</code>的后缀。因为<code>std::condition_variable_any</code>更加通用，这就可能从体积、性能，以及系统资源的使用方面产生额外的开销，所以<code>std::condition_variable</code>一般作为首选的类型，当对灵活性有硬性要求时，我们才会去考虑<code>std::condition_variable_any</code>。</p>
<p>所以，如何使用<code>std::condition_variable</code>去处理之前提到的情况——当有数据需要处理时，如何唤醒休眠中的线程对其进行处理？以下清单展示了一种使用条件变量做唤醒的方式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mut;</span><br><span class="line">std::queue&lt;data_chunk&gt; data_queue;  <span class="comment">// 1</span></span><br><span class="line">std::condition_variable data_cond;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">more_data_to_prepare</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    data_chunk <span class="type">const</span> data=<span class="built_in">prepare_data</span>();</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_queue.<span class="built_in">push</span>(data);  <span class="comment">// 2</span></span><br><span class="line">    data_cond.<span class="built_in">notify_one</span>();  <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">data_processing_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;  <span class="comment">// 4</span></span><br><span class="line">    data_cond.<span class="built_in">wait</span>(</span><br><span class="line">         lk,[]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);  <span class="comment">// 5</span></span><br><span class="line">    data_chunk data=data_queue.<span class="built_in">front</span>();</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    lk.<span class="built_in">unlock</span>();  <span class="comment">// 6</span></span><br><span class="line">    <span class="built_in">process</span>(data);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_last_chunk</span>(data))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，你拥有一个用来在两个线程之间传递数据的队列①。当数据准备好时，使用<code>std::lock_guard</code>对队列上锁，将准备好的数据压入队列中②，之后线程会对队列中的数据上锁。然后调用<code>std::condition_variable</code>的<code>notify_one()</code>成员函数，对等待的线程(如果有等待线程)进行通知③。</p>
<p>在另外一侧，你有一个正在处理数据的线程，这个线程首先对互斥量上锁，但在这里<code>std::unique_lock</code>要比<code>std::lock_guard</code>④更加合适——且听我细细道来。线程之后会调用<code>std::condition_variable</code>的成员函数<code>wait()</code>，传递一个锁和一个lambda函数表达式(作为等待的条件⑤)。</p>
<p><code>wait()</code>会去检查这些条件，如果条件不满足，<code>wait()</code>函数将解锁互斥量，并且将这个线程置于阻塞或等待状态。当准备数据的线程调用<code>notify_one()</code>通知条件变量时，处理数据的线程从睡眠状态中苏醒，重新获取互斥锁，并且对条件再次检查，在条件满足的情况下，从<code>wait()</code>返回并继续持有锁。当条件不满足时，线程将对互斥量解锁，并且重新开始等待。</p>
<p>在调用<code>wait()</code>的过程中，一个条件变量可能会去检查给定条件若干次；然而，它总是在互斥量被锁定时这样做，当且仅当提供测试条件的函数返回true时，它就会立即返回。当等待线程重新获取互斥量并检查条件时，如果它并非直接响应另一个线程的通知，这就是所谓的伪唤醒(spurious wakeup)。</p>
<h3 id="使用条件变量构建线程安全队列"><a href="#使用条件变量构建线程安全队列" class="headerlink" title="使用条件变量构建线程安全队列"></a>使用条件变量构建线程安全队列</h3><p>当使用队列在多个线程中传递数据时，接收线程通常需要等待数据的压入。这里我们提供pop()函数的两个变种：<code>try_pop()</code>和<code>wait_and_pop()</code>。<code>try_pop()</code>尝试从队列中弹出数据，总会直接返回(当有失败时)，即使没有值可检索；<code>wait_and_pop()</code>，将会等待有值可检索的时候才返回。当你使用之前栈的方式来实现你的队列，你实现的队列接口就可能会是下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// 为了使用std::shared_ptr</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">threadsafe_queue</span>();</span><br><span class="line">  <span class="built_in">threadsafe_queue</span>(<span class="type">const</span> threadsafe_queue&amp;);</span><br><span class="line">  threadsafe_queue&amp; <span class="keyword">operator</span>=(</span><br><span class="line">      <span class="type">const</span> threadsafe_queue&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 不允许简单的赋值</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span>;  <span class="comment">// 1</span></span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span>;  <span class="comment">// 2</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span></span>;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>就像之前对栈做的那样，在这里你将很多构造函数剪掉了，并且禁止了对队列的简单赋值。和之前一样，你也需要提供两个版本的<code>try_pop()</code>和<code>wait_for_pop()</code>。第一个重载的<code>try_pop()</code>①在引用变量中存储着检索值，所以它可以用来返回队列中值的状态；当检索到一个变量时，他将返回true，否则将返回false。第二个重载②就不能做这样了，因为它是用来直接返回检索值的。当没有值可检索时，这个函数可以返回NULL指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::mutex mut;</span><br><span class="line">  std::queue&lt;T&gt; data_queue;</span><br><span class="line">  std::condition_variable data_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_queue.<span class="built_in">push</span>(new_value);</span><br><span class="line">    data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_cond.<span class="built_in">wait</span>(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">    value=data_queue.<span class="built_in">front</span>();</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">threadsafe_queue&lt;data_chunk&gt; data_queue;  <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">more_data_to_prepare</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    data_chunk <span class="type">const</span> data=<span class="built_in">prepare_data</span>();</span><br><span class="line">    data_queue.<span class="built_in">push</span>(data);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">data_processing_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    data_chunk data;</span><br><span class="line">    data_queue.<span class="built_in">wait_and_pop</span>(data);  <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">process</span>(data);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_last_chunk</span>(data))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程队列的实例中包含有互斥量和条件变量，所以独立的变量就不需要了①，并且调用<code>push()</code>也不需要外部同步②。当然，<code>wait_and_pop()</code>还要兼顾条件变量的等待③。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> std::mutex mut;  <span class="comment">// 1 互斥量必须是可变的 </span></span><br><span class="line">  std::queue&lt;T&gt; data_queue;</span><br><span class="line">  std::condition_variable data_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">threadsafe_queue</span>()</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  <span class="built_in">threadsafe_queue</span>(threadsafe_queue <span class="type">const</span>&amp; other)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(other.mut)</span></span>;</span><br><span class="line">    data_queue=other.data_queue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_queue.<span class="built_in">push</span>(new_value);</span><br><span class="line">    data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_cond.<span class="built_in">wait</span>(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">    value=data_queue.<span class="built_in">front</span>();</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_cond.<span class="built_in">wait</span>(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    value=data_queue.<span class="built_in">front</span>();</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>empty()</code>是一个const成员函数，并且传入拷贝构造函数的other形参是一个const引用；因为其他线程可能有这个类型的非const引用对象，并调用变种成员函数，所以这里有必要对互斥量上锁。如果锁住互斥量是一个可变操作，那么这个互斥量对象就会标记为可变的①，之后他就可以在empty()和拷贝构造函数中上锁了。</p>
<p>条件变量在多个线程等待同一个事件时，也是很有用的。当线程用来分解工作负载，并且只有一个线程可以对通知做出反应；运行多个数据实例——处理线程(processing thread)。当新的数据准备完成，调用<code>notify_one()</code>将会触发一个正在执行<code>wait()</code>的线程，去检查条件和<code>wait()</code>函数的返回状态(因为你仅是向data_queue添加一个数据项)。 这里不保证线程一定会被通知到，即使只有一个等待线程被通知时，所有处线程也有可能都在处理数据。</p>
<p>另一种可能是，很多线程等待同一事件，对于通知他们都需要做出回应。这会发生在共享数据正在初始化的时候，当处理线程可以使用同一数据时，就要等待数据被初始化，或等待共享数据的更新，比如，定期重新初始化(periodic reinitialization)。在这些情况下，准备线程准备数据数据时，就会通过条件变量调用<code>notify_all()</code>成员函数，而非直接调用<code>notify_one()</code>函数。</p>
<p>当等待线程只等待一次，当条件为true时，它就不会再等待条件变量了，所以一个条件变量可能并非同步机制的最好选择。尤其是，条件在等待一组可用的数据块时。在这样的情况下，期望(future)就是一个适合的选择。</p>
<h2 id="使用期望等待一次性事件"><a href="#使用期望等待一次性事件" class="headerlink" title="使用期望等待一次性事件"></a>使用期望等待一次性事件</h2><p>当一个线程需要等待一个特定的一次性事件时，在某种程度上来说它就需要知道这个事件在未来的表现形式。之后，这个线程会周期性的检查事件是否触发；在检查期间也会执行其他任务。另外，在等待任务期间它可以先执行另外一些任务，直到对应的任务触发，而后等待期望的状态会变为就绪(ready)。一个“期望”可能是数据相关的。</p>
<p>在C++标准库中，有两种“期望”，使用两种类型模板实现，声明在头文件中: 唯一期望(unique futures)(<code>std::future&lt;&gt;</code>)和共享期望(shared futures)(<code>std::shared_future&lt;&gt;</code>)。这是仿照<code>std::unique_ptr</code>和<code>std::shared_ptr</code>。<code>std::future</code>的实例只能与一个指定事件相关联，而<code>std::shared_future</code>的实例就能关联多个事件。后者的实现中，所有实例会在同时变为就绪状态，并且他们可以访问与事件相关的任何数据。这种数据关联与模板有关，比如<code>std::unique_ptr</code>和<code>std::shared_ptr</code>的模板参数就是相关联的数据类型。在与数据无关的地方，可以使用<code>std::future&lt;void&gt;</code>与<code>std::shared_future&lt;void&gt;</code>的特化模板。虽然，我希望用于线程间的通讯，但是“期望”对象本身并不提供同步访问。当多个线程需要访问一个独立“期望”对象时，他们必须使用互斥量或类似同步机制对访问进行保护。</p>
<h3 id="带返回值的后台任务"><a href="#带返回值的后台任务" class="headerlink" title="带返回值的后台任务"></a>带返回值的后台任务</h3><p>当任务的结果你不着急要时，你可以使用<code>std::async</code>启动一个异步任务。与<code>std::thread</code>对象等待的方式不同，<code>std::async</code>会返回一个<code>std::future</code>对象，这个对象持有最终计算出来的结果。当你需要这个值时，你只需要调用这个对象的<code>get()</code>成员函数；并且会阻塞线程直到“期望”状态为就绪为止；之后，返回计算结果。下面清单中代码就是一个简单的例子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_the_answer_to_ltuae</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_other_stuff</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::future&lt;<span class="type">int</span>&gt; the_answer=std::<span class="built_in">async</span>(find_the_answer_to_ltuae);</span><br><span class="line">  <span class="built_in">do_other_stuff</span>();</span><br><span class="line">  std::cout&lt;&lt;<span class="string">&quot;The answer is &quot;</span>&lt;&lt;the_answer.<span class="built_in">get</span>()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与<code>std::thread</code>做的方式一样，<code>std::async</code>允许你通过添加额外的调用参数，向函数传递额外的参数。当第一个参数是一个指向成员函数的指针，第二个参数提供有这个函数成员类的具体对象，剩余的参数可作为成员函数的参数传入。否则，第二个和随后的参数将作为函数的参数，或作为指定可调用对象的第一个参数。就如<code>std::thread</code>，当参数为右值(rvalues)时，拷贝操作将使用移动的方式转移原始数据。这就允许使用“只移动”类型作为函数对象和参数。来看一下下面的程序清单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>,std::string <span class="type">const</span>&amp;)</span></span>;</span><br><span class="line">  <span class="function">std::string <span class="title">bar</span><span class="params">(std::string <span class="type">const</span>&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">X x;</span><br><span class="line"><span class="keyword">auto</span> f1=std::<span class="built_in">async</span>(&amp;X::foo,&amp;x,<span class="number">42</span>,<span class="string">&quot;hello&quot;</span>);  <span class="comment">// 调用p-&gt;foo(42, &quot;hello&quot;)，p是指向x的指针</span></span><br><span class="line"><span class="keyword">auto</span> f2=std::<span class="built_in">async</span>(&amp;X::bar,x,<span class="string">&quot;goodbye&quot;</span>);  <span class="comment">// 调用tmpx.bar(&quot;goodbye&quot;)， tmpx是x的拷贝副本</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Y y;</span><br><span class="line"><span class="keyword">auto</span> f3=std::<span class="built_in">async</span>(<span class="built_in">Y</span>(),<span class="number">3.141</span>);  <span class="comment">// 调用tmpy(3.141)，tmpy通过Y的移动构造函数得到</span></span><br><span class="line"><span class="keyword">auto</span> f4=std::<span class="built_in">async</span>(std::<span class="built_in">ref</span>(y),<span class="number">2.718</span>);  <span class="comment">// 调用y(2.718)</span></span><br><span class="line"><span class="function">X <span class="title">baz</span><span class="params">(X&amp;)</span></span>;</span><br><span class="line">std::<span class="built_in">async</span>(baz,std::<span class="built_in">ref</span>(x));  <span class="comment">// 调用baz(x)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">move_only</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">move_only</span>();</span><br><span class="line">  <span class="built_in">move_only</span>(move_only&amp;&amp;)</span><br><span class="line">  <span class="built_in">move_only</span>(move_only <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  move_only&amp; <span class="keyword">operator</span>=(move_only&amp;&amp;);</span><br><span class="line">  move_only&amp; <span class="keyword">operator</span>=(move_only <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> f5=std::<span class="built_in">async</span>(<span class="built_in">move_only</span>());  <span class="comment">// 调用tmp()，tmp是通过std::move(move_only())构造得到</span></span><br></pre></td></tr></table></figure>
<p>在默认情况下，“期望”是否进行等待取决于<code>std::async</code>是否启动一个线程，或是否有任务正在进行同步。你也可以在函数调用之前，向<code>std::async</code>传递一个额外参数。这个参数的类型是<code>std::launch</code>，还可以是<code>std::launch::defered</code>，用来表明函数调用被延迟到<code>wait()</code>或<code>get()</code>函数调用时才执行，<code>std::launch::async</code>表明函数必须在其所在的独立线程上执行，<code>std::launch::deferred | std::launch::async</code>表明实现可以选择这两种方式的一种。最后一个选项是默认的。当函数调用被延迟，它可能不会在运行了。如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f6=std::<span class="built_in">async</span>(std::launch::async,<span class="built_in">Y</span>(),<span class="number">1.2</span>);  <span class="comment">// 在新线程上执行</span></span><br><span class="line"><span class="keyword">auto</span> f7=std::<span class="built_in">async</span>(std::launch::deferred,baz,std::<span class="built_in">ref</span>(x));  <span class="comment">// 在wait()或get()调用时执行</span></span><br><span class="line"><span class="keyword">auto</span> f8=std::<span class="built_in">async</span>(</span><br><span class="line">              std::launch::deferred | std::launch::async,</span><br><span class="line">              baz,std::<span class="built_in">ref</span>(x));  <span class="comment">// 实现选择执行方式</span></span><br><span class="line"><span class="keyword">auto</span> f9=std::<span class="built_in">async</span>(baz,std::<span class="built_in">ref</span>(x));</span><br><span class="line">f<span class="number">7.</span><span class="built_in">wait</span>();  <span class="comment">//  调用延迟函数</span></span><br></pre></td></tr></table></figure></p>
<h3 id="任务与期望"><a href="#任务与期望" class="headerlink" title="任务与期望"></a>任务与期望</h3><p><code>std::packaged_task&lt;&gt;</code>对一个函数或可调用对象，绑定一个期望。当<code>std::packaged_task&lt;&gt;</code>对象被调用，它就会调用相关函数或可调用对象，将期望状态置为就绪，返回值也会被存储为相关数据。这可以用在构建线程池的结构单元，或用于其他任务的管理，比如在任务所在线程上运行任务，或将它们顺序的运行在一个特殊的后台线程上。当一个粒度较大的操作可以被分解为独立的子任务时，其中每个子任务就可以包含在一个<code>std::packaged_task&lt;&gt;</code>实例中，之后这个实例将传递到任务调度器或线程池中。对任务的细节进行抽象，调度器仅处理<code>std::packaged_task&lt;&gt;</code>实例，而非处理单独的函数。</p>
<p><code>std::packaged_task&lt;&gt;</code>的模板参数是一个函数签名，比如<code>void()</code>就是一个没有参数也没有返回值的函数，或<code>int(std::string&amp;, double*)</code>就是有一个非const引用的std::string和一个指向double类型的指针，并且返回类型是int。当你构造出一个<code>std::packaged_task&lt;&gt;</code>实例时，你必须传入一个函数或可调用对象，这个函数或可调用的对象需要能接收指定的参数和返回可转换为指定返回类型的值。类型可以不完全匹配；你可以用一个int类型的参数和返回一个float类型的函数，来构建<code>std::packaged_task&lt;double(double)&gt;</code>的实例，因为在这里，类型可以隐式转换。</p>
<p>指定函数签名的返回类型可以用来标识，从<code>get_future()</code>返回的<code>std::future&lt;&gt;</code>的类型，不过函数签名的参数列表，可用来指定“打包任务”的函数调用操作符。例如，模板偏特化<code>std::packaged_task&lt;std::string(std::vector&lt;char&gt;*,int)&gt;</code>将在下面的代码清单中使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">packaged_task</span>&lt;std::<span class="built_in">string</span>(std::vector&lt;<span class="type">char</span>&gt;*,<span class="type">int</span>)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">explicit</span> <span class="title">packaged_task</span><span class="params">(Callable&amp;&amp; f)</span></span>;</span><br><span class="line">  <span class="function">std::future&lt;std::string&gt; <span class="title">get_future</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::vector&lt;<span class="type">char</span>&gt;*,<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的<code>std::packaged_task</code>对象是一个可调用对象，并且它可以包含在一个<code>std::function</code>对象中，传递到<code>std::thread</code>对象中，就可作为线程函数；传递另一个函数中，就作为可调用对象，或可以直接进行调用。当<code>std::packaged_task</code>作为一个函数调用时，可为函数调用操作符提供所需的参数，并且返回值作为异步结果存储在<code>std::future</code>，可通过<code>get_future()</code>获取。你可以把一个任务包含入<code>std::packaged_task</code>，并且在检索期望之前，需要将<code>std::packaged_task</code>对象传入，以便调用时能及时的找到。</p>
<p>当你需要异步任务的返回值时，你可以等待期望的状态变为“就绪”。下面的代码就是这么个情况。</p>
<p>很多图形架构需要特定的线程去更新界面，所以当一个线程需要界面的更新时，它需要发出一条信息给正确的线程，让特定的线程来做界面更新。<code>std::packaged_task</code>提供了完成这种功能的一种方法，且不需要发送一条自定义信息给图形界面相关线程。下面来看看代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line">std::mutex m;</span><br><span class="line">std::deque&lt;std::packaged_task&lt;<span class="type">void</span>()&gt; &gt; tasks;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">gui_shutdown_message_received</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_and_process_gui_message</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gui_thread</span><span class="params">()</span>  <span class="comment">// 1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">gui_shutdown_message_received</span>())  <span class="comment">// 2</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">get_and_process_gui_message</span>();  <span class="comment">// 3</span></span><br><span class="line">    std::packaged_task&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">      <span class="keyword">if</span>(tasks.<span class="built_in">empty</span>())  <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      task=std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());  <span class="comment">// 5</span></span><br><span class="line">      tasks.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">task</span>();  <span class="comment">// 6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">gui_bg_thread</span><span class="params">(gui_thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function">std::future&lt;<span class="type">void</span>&gt; <span class="title">post_task_for_gui_thread</span><span class="params">(Func f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::packaged_task&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(f)</span></span>;  <span class="comment">// 7</span></span><br><span class="line">  std::future&lt;<span class="type">void</span>&gt; res=task.<span class="built_in">get_future</span>();  <span class="comment">// 8</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;  <span class="comment">// 9</span></span><br><span class="line">  tasks.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(task));  <span class="comment">// 10</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码十分简单：图形界面线程①循环直到收到一条关闭图形界面的信息后关闭②，进行轮询界面消息处理③，例如用户点击，和执行在队列中的任务。当队列中没有任务④，它将再次循环；除非，他能在队列中提取出一个任务⑤，然后释放队列上的锁，并且执行任务⑥。这里，“期望”与任务相关，当任务执行完成时，其状态会被置为“就绪”状态。</p>
<p>将一个任务传入队列，也很简单：提供的函数⑦可以提供一个打包好的任务，可以通过这个任务⑧调用<code>get_future()</code>成员函数获取“期望”对象，并且在任务被推入列表⑨之前，“期望”将返回调用函数⑩。当需要知道线程执行完任务时，向图形界面线程发布消息的代码，会等待“期望”改变状态；否则，则会丢弃这个“期望”。</p>
<p>这个例子使用<code>std::packaged_task&lt;void()&gt;</code>创建任务，其包含了一个无参数无返回值的函数或可调用对象(如果当这个调用有返回值时，返回值会被丢弃)。这可能是最简单的任务，如你之前所见，<code>std::packaged_task</code>也可以用于一些复杂的情况——通过指定一个不同的函数签名作为模板参数，你不仅可以改变其返回类型(因此该类型的数据会存在期望相关的状态中)，而且也可以改变函数操作符的参数类型。这个例子可以简单的扩展成允许任务运行在图形界面线程上，且接受传参，还有通过<code>std::future</code>返回值，而不仅仅是完成一个指标。</p>
<p>这些任务能作为一个简单的函数调用来表达吗？还有，这些任务的结果能从很多地方得到吗？这些情况可以使用第三种方法创建“期望”来解决：使用std::promise对值进行显示设置。</p>
<h3 id="使用std-promises"><a href="#使用std-promises" class="headerlink" title="使用std::promises"></a>使用std::promises</h3><p><code>std::promise&lt;T&gt;</code>提供设定值的方式(类型为T)，这个类型会和后面看到的<code>std::future&lt;T&gt;</code>对象相关联。一对<code>std::promise/std::future</code>会为这种方式提供一个可行的机制；在期望上可以阻塞等待线程，同时，提供数据的线程可以使用组合中的“承诺”来对相关值进行设置，以及将“期望”的状态置为“就绪”。</p>
<p>可以通过<code>get_future()</code>成员函数来获取与一个给定的<code>std::promise</code>相关的<code>std::future</code>对象，就像是与<code>std::packaged_task</code>相关。当“承诺”的值已经设置完毕(使用<code>set_value()</code>成员函数)，对应“期望”的状态变为“就绪”，并且可用于检索已存储的值。当你在设置值之前销毁<code>std::promise</code>，将会存储一个异常。</p>
<p>在这个例子中，你可以使用一对<code>std::promise&lt;bool&gt;/std::future&lt;bool&gt;</code>找出一块传出成功的数据块；与“期望”相关值只是一个简单的“成功/失败”标识。对于传入包，与“期望”相关的数据就是数据包的有效负载。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_connections</span><span class="params">(connection_set&amp; connections)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">done</span>(connections))  <span class="comment">// 1</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(connection_iterator connection=connections.<span class="built_in">begin</span>(),end=connections.<span class="built_in">end</span>(); <span class="comment">// 2</span></span><br><span class="line">          connection!=end;</span><br><span class="line">          ++connection)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(connection-&gt;<span class="built_in">has_incoming_data</span>())  <span class="comment">// 3</span></span><br><span class="line">      &#123;</span><br><span class="line">        data_packet data=connection-&gt;<span class="built_in">incoming</span>();</span><br><span class="line">        std::promise&lt;payload_type&gt;&amp; p=</span><br><span class="line">            connection-&gt;<span class="built_in">get_promise</span>(data.id);  <span class="comment">// 4</span></span><br><span class="line">        p.<span class="built_in">set_value</span>(data.payload);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(connection-&gt;<span class="built_in">has_outgoing_data</span>())  <span class="comment">// 5</span></span><br><span class="line">      &#123;</span><br><span class="line">        outgoing_packet data=</span><br><span class="line">            connection-&gt;<span class="built_in">top_of_outgoing_queue</span>();</span><br><span class="line">        connection-&gt;<span class="built_in">send</span>(data.payload);</span><br><span class="line">        data.promise.<span class="built_in">set_value</span>(<span class="literal">true</span>);  <span class="comment">// 6</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数<code>process_connections()</code>中，直到<code>done()</code>返回true①为止。每一次循环，程序都会依次的检查每一个连接②，检索是否有数据③或正在发送已入队的传出数据⑤。这里假设输入数据包是具有ID和有效负载的(有实际的数在其中)。一个ID映射到一个<code>std::promise</code>，并且值是设置在包的有效负载中的。对于传出包，包是从传出队列中进行检索的，实际上从接口直接发送出去。当发送完成，与传出数据相关的“承诺”将置为true，来表明传输成功⑥。这是否能映射到实际网络协议上，取决于网络所用协议；这里的“承诺/期望”组合方式可能会在特殊的情况下无法工作，但是它与一些操作系统支持的异步输入/输出结构类似。</p>
<h3 id="为“期望”存储“异常”"><a href="#为“期望”存储“异常”" class="headerlink" title="为“期望”存储“异常”"></a>为“期望”存储“异常”</h3><p>看完下面短小的代码段，思考一下，当你传递-1到<code>square_root()</code>中时，它将抛出一个异常，并且这个异常将会被调用者看到：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">square_root</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(“x&lt;<span class="number">0</span>”);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设调用<code>square_root()</code>函数不是当前线程，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> y=<span class="built_in">square_root</span>(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure></p>
<p>你将这样的调用改为异步调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="type">double</span>&gt; f=std::<span class="built_in">async</span>(square_root,<span class="number">-1</span>);</span><br><span class="line"><span class="type">double</span> y=f.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure></p>
<p>如果行为是完全相同的时候，其结果是理想的；在任何情况下，y获得函数调用的结果，当线程调用<code>f.get()</code>时，就能再看到异常了，即使在一个单线程例子中。</p>
<p>好吧，事实的确如此：函数作为<code>std::async</code>的一部分时，当在调用时抛出一个异常，那么这个异常就会存储到“期望”的结果数据中，之后“期望”的状态被置为“就绪”，之后调用<code>get()</code>会抛出这个存储的异常。(注意：标准级别没有指定重新抛出的这个异常是原始的异常对象，还是一个拷贝；不同的编译器和库将会在这方面做出不同的选择)。当你将函数打包入<code>std::packaged_task</code>任务包中后，在这个任务被调用时，同样的事情也会发生；当打包函数抛出一个异常，这个异常将被存储在“期望”的结果中，准备在调用<code>get()</code>再次抛出。</p>
<p>当然，通过函数的显式调用，<code>std::promise</code>也能提供同样的功能。当你希望存入的是一个异常而非一个数值时，你就需要调用<code>set_exception()</code>成员函数，而非<code>set_value()</code>。这通常是用在一个catch块中，并作为算法的一部分，为了捕获异常，使用异常填充“承诺”：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> std::promise&lt;<span class="type">double</span>&gt; some_promise;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  some_promise.<span class="built_in">set_value</span>(<span class="built_in">calculate_value</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">  some_promise.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里使用了<code>std::current_exception()</code>来检索抛出的异常；可用<code>std::copy_exception()</code>作为一个替换方案，<code>std::copy_exception()</code>会直接存储一个新的异常而不抛出：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_promise.<span class="built_in">set_exception</span>(std::<span class="built_in">copy_exception</span>(std::<span class="built_in">logic_error</span>(<span class="string">&quot;foo &quot;</span>)));</span><br></pre></td></tr></table></figure></p>
<p>这就比使用try/catch块更加清晰，当异常类型是已知的，它就应该优先被使用；不是因为代码实现简单，而是它给编译器提供了极大的代码优化空间。</p>
<p>另一种向“期望”中存储异常的方式是，在没有调用“承诺”上的任何设置函数前，或正在调用包装好的任务时，销毁与<code>std::promise</code>或<code>std::packaged_task</code>相关的“期望”对象。在这任何情况下，当“期望”的状态还不是“就绪”时，调用<code>std::promise</code>或<code>std::packaged_task</code>的析构函数，将会存储一个与<code>std::future_errc::broken_promise</code>错误状态相关的<code>std::future_error</code>异常；通过创建一个“期望”，你可以构造一个“承诺”为其提供值或异常；你可以通过销毁值和异常源，去违背“承诺”。在这种情况下，编译器没有在“期望”中存储任何东西，等待线程可能会永远的等下去。</p>
<p>直到现在，所有例子都在用<code>std::future</code>。不过，<code>std::future</code>也有局限性，在很多线程在等待的时候，只有一个线程能获取等待结果。当多个线程需要等待相同的事件的结果，你就需要使用<code>std::shared_future</code>来替代<code>std::future</code>了。</p>
<h3 id="多个线程的等待"><a href="#多个线程的等待" class="headerlink" title="多个线程的等待"></a>多个线程的等待</h3><p>虽然<code>std::future</code>可以处理所有在线程间数据转移的必要同步，但是调用某一特殊<code>std::future</code>对象的成员函数，就会让这个线程的数据和其他线程的数据不同步。当多线程在没有额外同步的情况下，访问一个独立的<code>std::future</code>对象时，就会有数据竞争和未定义的行为。这是因为：<code>std::future</code>模型独享同步结果的所有权，并且通过调用<code>get()</code>函数，一次性的获取数据，这就让并发访问变的毫无意义——只有一个线程可以获取结果值，因为在第一次调用<code>get()</code>后，就没有值可以再获取了。</p>
<p>如果你的并行代码没有办法让多个线程等待同一个事件，先别太失落；<code>std::shared_future</code>可以来帮你解决。因为<code>std::future</code>是只移动的，所以其所有权可以在不同的实例中互相传递，但是只有一个实例可以获得特定的同步结果；而<code>std::shared_future</code>实例是可拷贝的，所以多个对象可以引用同一关联“期望”的结果。</p>
<p>在每一个<code>std::shared_future</code>的独立对象上成员函数调用返回的结果还是不同步的，所以为了在多个线程访问一个独立对象时，避免数据竞争，必须使用锁来对访问进行保护。优先使用的办法：为了替代只有一个拷贝对象的情况，可以让每个线程都拥有自己对应的拷贝对象。这样，当每个线程都通过自己拥有的<code>std::shared_future</code>对象获取结果，那么多个线程访问共享同步结果就是安全的。</p>
<p>有可能会使用<code>std::shared_future</code>的地方，例如，实现类似于复杂的电子表格的并行执行；每一个单元格有单一的终值，这个终值可能是有其他单元格中的数据通过公式计算得到的。公式计算得到的结果依赖于其他单元格，然后可以使用一个<code>std::shared_future</code>对象引用第一个单元格的数据。当每个单元格内的所有公式并行执行后，这些任务会以期望的方式完成工作；不过，当其中有计算需要依赖其他单元格的值，那么它就会被阻塞，直到依赖单元格的数据准备就绪。这将让系统在最大程度上使用可用的硬件并发。</p>
<p><code>std::shared_future</code>的实例同步<code>std::future</code>实例的状态。当<code>std::future</code>对象没有与其他对象共享同步状态所有权，那么所有权必须使用<code>std::move</code>将所有权传递到<code>std::shared_future</code>，其默认构造函数如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"><span class="function">std::future&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(p.get_future())</span></span>;</span><br><span class="line"><span class="built_in">assert</span>(f.<span class="built_in">valid</span>());  <span class="comment">// 1 &quot;期望&quot; f 是合法的</span></span><br><span class="line"><span class="function">std::shared_future&lt;<span class="type">int</span>&gt; <span class="title">sf</span><span class="params">(std::move(f))</span></span>;</span><br><span class="line"><span class="built_in">assert</span>(!f.<span class="built_in">valid</span>());  <span class="comment">// 2 &quot;期望&quot; f 现在是不合法的</span></span><br><span class="line"><span class="built_in">assert</span>(sf.<span class="built_in">valid</span>());  <span class="comment">// 3 sf 现在是合法的</span></span><br></pre></td></tr></table></figure></p>
<p>这里，“期望”<code>f</code>开始是合法的①，因为它引用的是“承诺”<code>p</code>的同步状态，但是在转移<code>sf</code>的状态后，<code>f</code>就不合法了②，而<code>sf</code>就是合法的了③。</p>
<p>如其他可移动对象一样，转移所有权是对右值的隐式操作，所以你可以通过<code>std::promise</code>对象的成员函数<code>get_future()</code>的返回值，直接构造一个<code>std::shared_future</code>对象，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;std::string&gt; p;</span><br><span class="line"><span class="function">std::shared_future&lt;std::string&gt; <span class="title">sf</span><span class="params">(p.get_future())</span></span>;  <span class="comment">// 1 隐式转移所有权</span></span><br></pre></td></tr></table></figure></p>
<p>这里转移所有权是隐式的；用一个右值构造<code>std::shared_future&lt;&gt;</code>，得到<code>std::future&lt;std::string&gt;</code>类型的实例①。</p>
<p><code>std::future</code>的这种特性，可促进<code>std::shared_future</code>的使用，容器可以自动的对类型进行推断，从而初始化这个类型的变量。<code>std::future</code>有一个<code>share()</code>成员函数，可用来创建新的<code>std::shared_future</code>，并且可以直接转移“期望”的所有权。这样也就能保存很多类型，并且使得代码易于修改：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt; std::map&lt; SomeIndexType, SomeDataType, SomeComparator,</span><br><span class="line">     SomeAllocator&gt;::iterator&gt; p;</span><br><span class="line"><span class="keyword">auto</span> sf=p.<span class="built_in">get_future</span>().<span class="built_in">share</span>();</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，<code>sf</code>的类型推到为<code>std::shared_future&lt;std::map&lt;SomeIndexType, SomeDataType, SomeComparator, SomeAllocator&gt;::iterator&gt;</code>，一口气还真的很难念完。当比较器或分配器有所改动，你只需要对“承诺”的类型进行修改即可；“期望”的类型会自动更新，与“承诺”的修改进行匹配。</p>
<p>有时候你需要限定等待一个事件的时间，不论是因为你在时间上有硬性规定(一段指定的代码需要在某段时间内完成)，还是因为在事件没有很快的触发时，有其他必要的工作需要特定线程来完成。为了处理这种情况，很多等待函数具有用于指定超时的变量。</p>
<h2 id="限定等待时间"><a href="#限定等待时间" class="headerlink" title="限定等待时间"></a>限定等待时间</h2><p>之前介绍过的所有阻塞调用，将会阻塞一段不确定的时间，将线程挂起直到等待的事件发生。在很多情况下，这样的方式很不错，但是在其他一些情况下，你就需要限制一下线程等待的时间了。</p>
<p>介绍两种可能是你希望指定的超时方式：一种是“时延”的超时方式，另一种是“绝对”超时方式。第一种方式，需要指定一段时间；第二种方式，就是指定一个时间点。多数等待函数提供变量，对两种超时方式进行处理。处理持续时间的变量以“_for”作为后缀，处理绝对时间的变量以”_until”作为后缀。</p>
<p>所以，当<code>std::condition_variable</code>的两个成员函数<code>wait_for()</code>和<code>wait_until()</code>成员函数分别有两个负载，这两个负载都与<code>wait()</code>成员函数的负载相关——其中一个负载只是等待信号触发，或时间超期，亦或是一个虚假的唤醒，并且醒来时，会检查锁提供的谓词，并且只有在检查为true时才会返回(这时条件变量的条件达成)，或直接而超时。</p>
<h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>对于C++标准库来说，时钟就是时间信息源。特别是，时钟是一个类，提供了四种不同的信息：</p>
<ul>
<li>现在时间</li>
<li>时间类型</li>
<li>时钟节拍</li>
<li>通过时钟节拍的分布，判断时钟是否稳定</li>
</ul>
<p>时钟的当前时间可以通过调用静态成员函数<code>now()</code>从时钟类中获取；例如，<code>std::chrono::system_clock::now()</code>是将返回系统时钟的当前时间。特定的时间点类型可以通过<code>time_point</code>的数据typedef成员来指定，所以<code>some_clock::now()</code>的类型就是<code>some_clock::time_point</code>。</p>
<p>时钟节拍被指定为1/x(x在不同硬件上有不同的值)秒，这是由时间周期所决定——一个时钟一秒有25个节拍，因此一个周期为<code>std::ratio&lt;1, 25&gt;</code>，当一个时钟的时钟节拍每2.5秒一次，周期就可以表示为<code>std::ratio&lt;5, 2&gt;</code>。当时钟节拍直到运行时都无法知晓，可以使用一个给定的应用程序运行多次，周期可以用执行的平均时间求出，其中最短的时间可能就是时钟节拍。这就不保证在给定应用中观察到的节拍周期与指定的时钟周期相匹配。</p>
<p>当时钟节拍均匀分布(无论是否与周期匹配)，并且不可调整，这种时钟就称为稳定时钟。当<code>is_steady</code>静态数据成员为true时，表明这个时钟就是稳定的，否则，就是不稳定的。通常情况下，<code>std::chrono::system_clock</code>是不稳定的，因为时钟是可调的，即是这种是完全自动适应本地账户的调节。这种调节可能造成的是，首次调用<code>now()</code>返回的时间要早于上次调用<code>now()</code>所返回的时间，这就违反了节拍频率的均匀分布。稳定闹钟对于超时的计算很重要，所以C++标准库提供一个稳定时钟<code>std::chrono::steady_clock</code>。C++标准库提供的其他时钟可表示为<code>std::chrono::system_clock</code>，它代表了系统时钟的“实际时间”，并且提供了函数可将时间点转化为<code>time_t</code>类型的值；<code>std::chrono::high_resolution_clock</code>可能是标准库中提供的具有最小节拍周期的时钟。它实际上是typedef的另一种时钟，这些时钟和其他与时间相关的工具，都被定义在库头文件中。</p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>时延是时间部分最简单的；<code>std::chrono::duration&lt;&gt;</code>函数模板能够对时延进行处理。第一个模板参数是一个类型表示(比如，int，long或double)，第二个模板参数是制定部分，表示每一个单元所用秒数。例如，当几分钟的时间要存在short类型中时，可以写成<code>std::chrono::duration&lt;short, std::ratio&lt;60, 1&gt;&gt;</code>，因为60秒是才是1分钟，所以第二个参数写成<code>std::ratio&lt;60, 1&gt;</code>。另一方面，当需要将毫秒级计数存在double类型中时，可以写成<code>std::chrono::duration&lt;double, std::ratio&lt;1, 1000&gt;&gt;</code>，因为1秒等于1000毫秒。</p>
<p>标准库在<code>std::chrono</code>命名空间内，为延时变量提供一系列预定义类型：nanoseconds[纳秒] , microseconds[微秒] , milliseconds[毫秒] , seconds[秒] , minutes[分]和hours[时]。比如，你要在一个合适的单元表示一段超过500年的时延，预定义类型可充分利用了大整型，来表示所要表示的时间类型。</p>
<p>显式转换可以由<code>std::chrono::duration_cast&lt;&gt;</code>来完成。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">chrono::milliseconds <span class="title">ms</span><span class="params">(<span class="number">54802</span>)</span></span>;</span><br><span class="line">std::chrono::seconds s=</span><br><span class="line">       std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(ms);</span><br></pre></td></tr></table></figure></p>
<p>这里的结果就是截断的，而不是进行了舍入，所以s最后的值将为54。</p>
<p>基于时延的等待可由<code>std::chrono::duration&lt;&gt;</code>来完成。例如，你等待一个“期望”状态变为就绪已经35毫秒：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; f=std::<span class="built_in">async</span>(some_task);</span><br><span class="line"><span class="keyword">if</span>(f.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">35</span>))==std::future_status::ready)</span><br><span class="line">  <span class="built_in">do_something_with</span>(f.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure></p>
<p>等待函数会返回一个状态值，来表示等待是超时，还是继续等待。在这种情况下，你可以等待一个“期望”，所以当函数等待超时时，会返回<code>std::future_status::timeout</code>；当“期望”状态改变，函数会返回<code>std::future_status::ready</code>；当“期望”的任务延迟了，函数会返回<code>std::future_status::deferred</code>。</p>
<h3 id="时间点"><a href="#时间点" class="headerlink" title="时间点"></a>时间点</h3><p>时钟的时间点可以用<code>std::chrono::time_point&lt;&gt;</code>的类型模板实例来表示，实例的第一个参数用来指定所要使用的时钟，第二个函数参数用来表示时间的计量单位(特化的<code>std::chrono::duration&lt;&gt;</code>)。一个时间点的值就是时间的长度(在指定时间的倍数内)，例如，指定“unix时间戳”(epoch)为一个时间点。时钟可能共享一个时间戳，或具有独立的时间戳。当两个时钟共享一个时间戳时，其中一个<code>time_point</code>类型可以与另一个时钟类型中的<code>time_point</code>相关联。可以通过对指定<code>time_point</code>类型使用<code>time_since_epoch()</code>来获取时间戳。</p>
<p>例如，你可能指定了一个时间点<code>std::chrono::time_point&lt;std::chrono::system_clock, std::chrono::minutes&gt;</code>。</p>
<p>你可以通过<code>std::chrono::time_point&lt;&gt;</code>实例来加/减时延，来获得一个新的时间点，所以<code>std::chrono::hight_resolution_clock::now() + std::chrono::nanoseconds(500)</code>将得到500纳秒后的时间。当你知道一块代码的最大时延时，这对于计算绝对时间的超时是一个好消息，当等待时间内，等待函数进行多次调用；或，非等待函数且占用了等待函数时延中的时间。</p>
<p>你也可以减去一个时间点(二者需要共享同一个时钟)。结果是两个时间点的时间差。这对于代码块的计时是很有用的，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> start=std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="built_in">do_something</span>();</span><br><span class="line"><span class="keyword">auto</span> stop=std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">std::cout&lt;&lt;”<span class="built_in">do_something</span>() took “</span><br><span class="line">  &lt;&lt;std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>,std::chrono::seconds&gt;(stop-start).<span class="built_in">count</span>()</span><br><span class="line">  &lt;&lt;” seconds”&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure></p>
<p><code>std::chrono::time_point&lt;&gt;</code>实例的时钟参数可不仅是能够指定unix时间戳的。当你想一个等待函数(绝对时间超时的方式)传递时间点时，时间点的时钟参数就被用来测量时间。当时钟变更时，会产生严重的后果，因为等待轨迹随着时钟的改变而改变，并且知道调用时钟的<code>now()</code>成员函数时，才能返回一个超过超时时间的值。当时钟向前调整，这就有可能减小等待时间的总长度(与稳定时钟的测量相比)；当时钟向后调整，就有可能增加等待时间的总长度。</p>
<p>如你期望的那样，后缀为<code>_unitl</code>的(等待函数的)变量会使用时间点。通常是使用某些时钟的<code>::now()</code>作为偏移，虽然时间点与系统时钟有关，可以使用<code>std::chrono::system_clock::to_time_point()</code>静态成员函数，在用户可视时间点上进行调度操作。例如，当你有一个对多等待500毫秒的，且与条件变量相关的事件，你可以参考如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> done;</span><br><span class="line">std::mutex m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="type">const</span> timeout= std::chrono::steady_clock::<span class="built_in">now</span>()+</span><br><span class="line">      std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>);</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">  <span class="keyword">while</span>(!done)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(cv.<span class="built_in">wait_until</span>(lk,timeout)==std::cv_status::timeout)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式是我们推荐的，当你没有什么事情可以等待时，可在一定时限中等待条件变量。在这种方式中，循环的整体长度是有限的。当使用条件变量(且无事可待)时，你就需要使用循环，这是为了处理假唤醒。当你在循环中使用<code>wait_for()</code>时，你可能在等待了足够长的时间后结束等待(在假唤醒之前)，且下一次等待又开始了。这可能重复很多次，使得等待时间无边无际。</p>
<p>到此，有关时间点超时的基本知识你已经了解了。现在，让我们来了解一下如何在函数中使用超时。</p>
<h3 id="具有超时功能的函数"><a href="#具有超时功能的函数" class="headerlink" title="具有超时功能的函数"></a>具有超时功能的函数</h3><p>使用超时的最简单方式就是，对一个特定线程添加一个延迟处理；当这个线程无所事事时，就不会占用可供其他线程处理的时间。</p>
<p>两个处理函数分别是<code>std::this_thread::sleep_for()</code>和<code>std::this_thread::sleep_until()</code>。他们的工作就像一个简单的闹钟：当线程因为指定时延而进入睡眠时，可使用<code>sleep_for()</code>唤醒；或因指定时间点睡眠的，可使用<code>sleep_until</code>唤醒。<code>sleep_until()</code>允许在某个特定时间点将调度线程唤醒。</p>
<p>当然，休眠只是超时处理的一种形式；你已经看到了，超时可以配合条件变量和“期望”一起使用。超时甚至可以在尝试获取一个互斥锁时使用。<code>std::mutex</code>和<code>std::recursive_mutex</code>都不支持超时锁，但是<code>std::timed_mutex</code>和<code>std::recursive_timed_mutex</code>支持。这两种类型也有<code>try_lock_for()</code>和<code>try_lock_until()</code>成员函数，可以在一段时期内尝试，或在指定时间点前获取互斥锁。</p>
<h1 id="C-内存模型和原子类型操作"><a href="#C-内存模型和原子类型操作" class="headerlink" title="C++内存模型和原子类型操作"></a>C++内存模型和原子类型操作</h1><h2 id="C-中的原子操作和原子类型"><a href="#C-中的原子操作和原子类型" class="headerlink" title="C++中的原子操作和原子类型"></a>C++中的原子操作和原子类型</h2><p>原子操作是不可分割的操作。在系统的所有线程中，你是不可能观察到原子操作完成了一半这种情况的；它要么就是做了，要么就是没做，只有这两种可能。</p>
<p>另一方面，非原子操作可能会被另一个线程观察到只完成一半。如果这个操作是一个存储操作，那么其他线程看到的值，可能既不是存储前的值，也不是存储的值，而是别的什么值。</p>
<p>在C++中，多数时候你需要一个原子类型来得到原子的操作，我们来看一下这些类型。</p>
<h3 id="标准原子类型"><a href="#标准原子类型" class="headerlink" title="标准原子类型"></a>标准原子类型</h3><p>标准原子类型定义在头文件<code>&lt;atomic&gt;</code>中。这些类型上的所有操作都是原子的，在语言定义中只有这些类型的操作是原子的，不过你可以用互斥锁来模拟原子操作。实际上，标准原子类型自己的实现就可能是这样模拟出来的：它们(几乎)都有一个<code>is_lock_free()</code>成员函数，这个函数让用户可以查询某原子类型的操作是直接用的原子指令(<code>x.is_lock_free()</code>返回true)，还是编译器和库内部用了一个锁(<code>x.is_lock_free()</code>返回false)。</p>
<p>只用<code>std::atomic_flag</code>类型不提供<code>is_lock_free()</code>成员函数。这个类型是一个简单的布尔标志，并且在这种类型上的操作都需要是无锁的；当你有一个简单无锁的布尔标志时，你可以使用其实现一个简单的锁，并且实现其他基础的原子类型。</p>
<p>剩下的原子类型都可以通过特化<code>std::atomic&lt;&gt;</code>类型模板而访问到，并且拥有更多的功能，但可能不都是无锁的。在最流行的平台上，期望原子变量都是无锁的内置类型(例如<code>std::atomic&lt;int&gt;</code>和<code>std::atomic&lt;void*&gt;</code>)，但这没有必要。</p>
<p>除了直接使用<code>std::atomic&lt;&gt;</code>类型模板外，你可以使用在表中所示的原子类型集。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>原子类型</th>
<th>相关特化类</th>
</tr>
</thead>
<tbody>
<tr>
<td>atomic_bool</td>
<td>std::atomic<bool></td>
</tr>
<tr>
<td>atomic_char</td>
<td>std::atomic<char></td>
</tr>
<tr>
<td>atomic_schar</td>
<td>std::atomic<signed char></td>
</tr>
<tr>
<td>atomic_uchar</td>
<td>std::atomic<unsigned char></td>
</tr>
<tr>
<td>atomic_int</td>
<td>std::atomic<int></td>
</tr>
<tr>
<td>atomic_uint</td>
<td>std::atomic<unsigned></td>
</tr>
<tr>
<td>atomic_short</td>
<td>std::atomic<short></td>
</tr>
<tr>
<td>atomic_ushort</td>
<td>std::atomic<unsigned short></td>
</tr>
<tr>
<td>atomic_long</td>
<td>std::atomic<long></td>
</tr>
<tr>
<td>atomic_ulong</td>
<td>std::atomic<unsigned long></td>
</tr>
<tr>
<td>atomic_llong</td>
<td>std::atomic<long long></td>
</tr>
<tr>
<td>atomic_ullong</td>
<td>std::atomic<unsigned long long></td>
</tr>
<tr>
<td>atomic_char16_t</td>
<td>std::atomic<char16_t></td>
</tr>
<tr>
<td>atomic_char32_t</td>
<td>std::atomic<char32_t></td>
</tr>
<tr>
<td>atomic_wchar_t</td>
<td>std::atomic<wchar_t></td>
</tr>
</tbody>
</table>
</div>
<p>C++标准库不仅提供基本原子类型，还定义了与原子类型对应的非原子类型，就如同标准库中的<code>std::size_t</code>。如表所示这些类型:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>原子类型定义</th>
<th>标准库中相关类型定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>atomic_int_least8_t</td>
<td>int_least8_t</td>
</tr>
<tr>
<td>atomic_uint_least8_t</td>
<td>uint_least8_t</td>
</tr>
<tr>
<td>atomic_int_least16_t</td>
<td>int_least16_t</td>
</tr>
<tr>
<td>atomic_uint_least16_t</td>
<td>uint_least16_t</td>
</tr>
<tr>
<td>atomic_int_least32_t</td>
<td>int_least32_t</td>
</tr>
<tr>
<td>atomic_uint_least32_t</td>
<td>uint_least32_t</td>
</tr>
<tr>
<td>atomic_int_least64_t</td>
<td>int_least64_t</td>
</tr>
<tr>
<td>atomic_uint_least64_t</td>
<td>uint_least64_t</td>
</tr>
<tr>
<td>atomic_int_fast8_t</td>
<td>int_fast8_t</td>
</tr>
<tr>
<td>atomic_uint_fast8_t</td>
<td>uint_fast8_t</td>
</tr>
<tr>
<td>atomic_int_fast16_t</td>
<td>int_fast16_t</td>
</tr>
<tr>
<td>atomic_uint_fast16_t</td>
<td>uint_fast16_t</td>
</tr>
<tr>
<td>atomic_int_fast32_t</td>
<td>int_fast32_t</td>
</tr>
<tr>
<td>atomic_uint_fast32_t</td>
<td>uint_fast32_t</td>
</tr>
<tr>
<td>atomic_int_fast64_t</td>
<td>int_fast64_t</td>
</tr>
<tr>
<td>atomic_uint_fast64_t</td>
<td>uint_fast64_t</td>
</tr>
<tr>
<td>atomic_intptr_t</td>
<td>intptr_t</td>
</tr>
<tr>
<td>atomic_uintptr_t</td>
<td>uintptr_t</td>
</tr>
<tr>
<td>atomic_size_t</td>
<td>size_t</td>
</tr>
<tr>
<td>atomic_ptrdiff_t</td>
<td>ptrdiff_t</td>
</tr>
<tr>
<td>atomic_intmax_t</td>
<td>intmax_t</td>
</tr>
<tr>
<td>atomic_uintmax_t</td>
<td>uintmax_t</td>
</tr>
</tbody>
</table>
</div>
<p>对于标准类型进行<code>typedef T</code>，相关的原子类型就在原来的类型名前加上<code>atomic_</code>的前缀：<code>atomic_T</code>。除了<code>signed</code>类型的缩写是<code>s</code>，<code>unsigned</code>的缩写是<code>u</code>，和<code>long long</code>的缩写是<code>llong</code>之外，这种方式也同样适用于内置类型。对于<code>std::atomic&lt;T&gt;</code>模板，使用对应的T类型去特化模板的方式，要好于使用别名的方式。</p>
<p>通常，标准原子类型是不能拷贝和赋值，他们没有拷贝构造函数和拷贝赋值操作。但是，因为可以隐式转化成对应的内置类型，所以这些类型依旧支持赋值，可以使用<code>load()</code>和<code>store()</code>成员函数，<code>exchange()</code>、<code>compare_exchange_weak()</code>和<code>compare_exchange_strong()</code>。它们都支持复合赋值符：+=, -=, *=, |= 等等。并且使用整型和指针的特化类型还支持 ++ 和 —。当然，这些操作也有功能相同的成员函数所对应：<code>fetch_add()</code>,<code>fetch_or()</code>等等。赋值操作和成员函数的返回值要么是被存储的值(赋值操作)，要么是操作前的值(命名函数)。这就能避免赋值操作符返回引用。为了获取存储在引用的的值，代码需要执行单独的读操作，从而允许另一个线程在赋值和读取进行的同时修改这个值，这也就为条件竞争打开了大门。</p>
<p><code>std::atomic&lt;&gt;</code>类模板不仅仅一套特化的类型，其作为一个原发模板也可以使用用户定义类型创建对应的原子变量。因为，它是一个通用类模板，操作被限制为<code>load()</code>，<code>store()</code>(赋值和转换为用户类型)，<code>exchange()</code>，<code>compare_exchange_weak()</code>和<code>compare_exchange_strong()</code>。</p>
<p>每种函数类型的操作都有一个可选内存排序参数，这个参数可以用来指定所需存储的顺序。</p>
<ul>
<li>Store操作，可选如下顺序：memory_order_relaxed, memory_order_release, memory_order_seq_cst。</li>
<li>Load操作，可选如下顺序：memory_order_relaxed, memory_order_consume, memory_order_acquire, memory_order_seq_cst。</li>
<li>Read-modify-write(读-改-写)操作，可选如下顺序：memory_order_relaxed, memory_order_consume, memory_order_acquire, memory_order_release, memory_order_acq_rel, memory_order_seq_cst。</li>
</ul>
<p>所有操作的默认顺序都是memory_order_seq_cst。<br>现在，让我们来看一下每个标准原子类型进行的操作，就从<code>std::atomic_flag</code>开始吧。</p>
<h3 id="std-atomic-flag的相关操作"><a href="#std-atomic-flag的相关操作" class="headerlink" title="std::atomic_flag的相关操作"></a>std::atomic_flag的相关操作</h3><p><code>std::atomic_flag</code>是最简单的标准原子类型，它表示了一个布尔标志。这个类型的对象可以在两个状态间切换：设置和清除。它就是那么的简单，只作为一个构建块存在。我从未期待这个类型被使用，除非在十分特别的情况下。</p>
<p><code>std::atomic_flag</code>类型的对象必须被<code>ATOMIC_FLAG_INIT</code>初始化。初始化标志位是“清除”状态。这里没得选择；这个标志总是初始化为“清除”：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::atomic_flag f = ATOMIC_FLAG_INIT;</span><br></pre></td></tr></table></figure></p>
<p>这适用于任何对象的声明，并且可在任意范围内。它是唯一需要以如此特殊的方式初始化的原子类型，但它也是唯一保证无锁的类型。如果<code>std::atomic_flag</code>是静态存储的，那么就的保证其是静态初始化的，也就意味着没有初始化顺序问题；在首次使用时，其都需要初始化。</p>
<p>当你的标志对象已初始化，那么你只能做三件事情：销毁，清除或设置(查询之前的值)。这些事情对应的函数分别是：<code>clear()</code>成员函数，和<code>test_and_set()</code>成员函数。<code>clear()</code>和<code>test_and_set()</code>成员函数可以指定好内存顺序。<code>clear()</code>是一个存储操作，所以不能有<code>memory_order_acquire</code>或<code>memory_order_acq_rel</code>语义，但是<code>test_and_set()</code>是一个“读-改-写”操作，所有可以应用于任何内存顺序标签。每一个原子操作，默认的内存顺序都是<code>memory_order_seq_cst</code>。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.<span class="built_in">clear</span>(std::memory_order_release);  <span class="comment">// 1</span></span><br><span class="line"><span class="type">bool</span> x=f.<span class="built_in">test_and_set</span>();  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>这里，调用<code>clear()</code>①明确要求，使用释放语义清除标志，当调用<code>test_and_set()</code>②使用默认内存顺序设置表示，并且检索旧值。</p>
<p>你不能拷贝构造另一个<code>std::atomic_flag</code>对象；并且，你不能将一个对象赋予另一个<code>std::atomic_flag</code>对象。这并不是<code>std::atomic_flag</code>特有的，而是所有原子类型共有的。一个原子类型的所有操作都是原子的，因赋值和拷贝调用了两个对象，这就就破坏了操作的原子性。在这样的情况下，拷贝构造和拷贝赋值都会将第一个对象的值进行读取，然后再写入另外一个。对于两个独立的对象，这里就有两个独立的操作了，合并这两个操作必定是不原子的。因此，操作就不被允许。</p>
<p>有限的特性集使得<code>std::atomic_flag</code>非常适合于作自旋互斥锁。初始化标志是“清除”，并且互斥量处于解锁状态。为了锁上互斥量，循环运行<code>test_and_set()</code>直到旧值为false，就意味着这个线程已经被设置为true了。解锁互斥量是一件很简单的事情，将标志清除即可。实现如下面的程序清单所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">spinlock_mutex</span></span><br><span class="line">&#123;</span><br><span class="line">  std::atomic_flag flag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">spinlock_mutex</span>():</span><br><span class="line">    <span class="built_in">flag</span>(ATOMIC_FLAG_INIT)</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(flag.<span class="built_in">test_and_set</span>(std::memory_order_acquire));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    flag.<span class="built_in">clear</span>(std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样的互斥量是最最基本的，但是它已经足够<code>std::lock_guard&lt;&gt;</code>使用了。其本质就是在<code>lock()</code>中等待，所以这里几乎不可能有竞争的存在，并且可以确保互斥。当我们看到内存顺序语义时，你将会看到它们是如何对一个互斥锁保证必要的强制顺序的。</p>
<p>由于<code>std::atomic_flag</code>局限性太强，因为它没有非修改查询操作，它甚至不能像普通的布尔标志那样使用。所以，你最好使用<code>std::atomic&lt;bool&gt;</code>。</p>
<h3 id="std-atomic的相关操作"><a href="#std-atomic的相关操作" class="headerlink" title="std::atomic的相关操作"></a>std::atomic的相关操作</h3><p>最基本的原子整型类型就是<code>std::atomic&lt;bool&gt;</code>。如你所料，它有着比<code>std::atomic_flag</code>更加齐全的布尔标志特性。虽然它依旧不能拷贝构造和拷贝赋值，但是你可以使用一个非原子的bool类型构造它，所以它可以被初始化为true或false，并且你也可以从一个非原子bool变量赋值给<code>std::atomic&lt;bool&gt;</code>的实例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">b</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">b=<span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<p>另一件需要注意的事情时，非原子bool类型的赋值操作不同于通常的操作(转换成对应类型的引用，再赋给对应的对象)：它返回一个bool值来代替指定对象。这是在原子类型中，另一种常见的模式：赋值操作通过返回值(返回相关的非原子类型)完成，而非返回引用。如果一个原子变量的引用被返回了，任何依赖与这个赋值结果的代码都需要显式加载这个值。通过使用返回非原子值进行赋值的方式，你可以避免这些多余的加载过程，并且得到的值就是实际存储的值。</p>
<p>虽然有内存顺序语义指定，但是使用<code>store()</code>去写入(true或false)还是好于<code>std::atomic_flag</code>中限制性很强的<code>clear()</code>。同样的，<code>test_and_set()</code>函数也可以被更加通用的<code>exchange()</code>成员函数所替换，<code>exchange()</code>成员函数允许你使用你新选的值替换已存储的值，并且自动的检索原始值。<code>std::atomic&lt;bool&gt;</code>也支持对值的普通(不可修改)查找，其会将对象隐式的转换为一个普通的bool值，或显示的调用<code>load()</code>来完成。如你预期，<code>store()</code>是一个存储操作，而<code>load()</code>是一个加载操作。<code>exchange()</code>是一个“读-改-写”操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; b;</span><br><span class="line"><span class="type">bool</span> x=b.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">b.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">x=b.<span class="built_in">exchange</span>(<span class="literal">false</span>, std::memory_order_acq_rel);</span><br></pre></td></tr></table></figure></p>
<p><code>std::atomic&lt;bool&gt;</code>提供的<code>exchange()</code>，不仅仅是一个“读-改-写”的操作；它还介绍了一种新的存储方式：当当前值与预期值一致时，存储新值的操作。</p>
<p>这是一种新型操作，叫做“比较/交换”，它的形式表现为<code>compare_exchange_weak()</code>和<code>compare_exchange_strong()</code>成员函数。“比较/交换”操作是原子类型编程的基石；它比较原子变量的当前值和一个期望值，当两值相等时，存储提供值。当两值不等，期望值就会被更新为原子变量中的值。“比较/交换”函数值是一个bool变量，当返回true时执行存储操作，当false则更新期望值。</p>
<p>对于<code>compare_exchange_weak()</code>函数，当原始值与预期值一致时，存储也可能会不成功；在这个例子中变量的值不会发生改变，并且<code>compare_exchange_weak()</code>的返回是false。这可能发生在缺少独立“比较-交换”指令的机器上，当处理器不能保证这个操作能够自动的完成——可能是因为线程的操作将指令队列从中间关闭，并且另一个线程安排的指令将会被操作系统所替换(这里线程数多于处理器数量)。这被称为“伪失败”(spurious failure)，因为造成这种情况的原因是时间，而不是变量值。</p>
<p>因为<code>compare_exchange_weak()</code>可以“伪失败”，所以这里通常使用一个循环：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> expected=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">extern</span> atomic&lt;<span class="type">bool</span>&gt; b; <span class="comment">// 设置些什么</span></span><br><span class="line"><span class="keyword">while</span>(!b.<span class="built_in">compare_exchange_weak</span>(expected,<span class="literal">true</span>) &amp;&amp; !expected);</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，循环中<code>expected</code>的值始终是false，表示<code>compare_exchange_weak()</code>会莫名的失败。</p>
<p>另一方面，如果实际值与期望值不符，<code>compare_exchange_strong()</code>就能保证值返回false。这就能消除对循环的需要，就可以知道是否成功的改变了一个变量，或已让另一个线程完成。</p>
<p>如果你想要改变变量值，且无论初始值是什么(可能是根据当前值更新了的值)，更新后的期望值将会变更有用；经历每次循环的时候，期望值都会重新加载，所以当没有其他线程同时修改期望时，循环中对<code>compare_exchange_weak()</code>或<code>compare_exchange_strong()</code>的调用都会在下一次(第二次)成功。如果值的计算很容易存储，那么使用<code>compare_exchange_weak()</code>能更好的避免一个双重循环的执行，即使<code>compare_exchange_weak()</code>可能会“伪失败”(因此<code>compare_exchange_strong()</code>包含一个循环)。另一方面，如果值计算的存储本身是耗时的，那么当期望值不变时，使用<code>compare_exchange_strong()</code>可以避免对值的重复计算。对于<code>std::atomic&lt;bool&gt;</code>这些都不重要——毕竟只可能有两种值——但是对于其他的原子类型就有较大的影响了。</p>
<p>“比较/交换”函数很少对两个拥有内存顺序的参数进行操作，这就就允许内存顺序语义在成功和失败的例子中有所不同；其可能是对memory_order_acq_rel语义的一次成功调用，而对memory_order_relaxed语义的一次失败的调动。一次失败的“比较/交换”将不会进行存储，所以“比较/交换”操作不能拥有memeory_order_release或memory_order_acq_rel语义。因此，这里不保证提供的这些值能作为失败的顺序。你也不能提供比成功顺序更加严格的失败内存顺序；当你需要memory_order_acquire或memory_order_seq_cst作为失败语序，那必须要如同“指定它们是成功语序”那样去做。</p>
<p>如果你没有指定失败的语序，那就假设和成功的顺序是一样的，除了release部分的顺序：memory_order_release变成memory_order_relaxed，并且memoyr_order_acq_rel变成memory_order_acquire。如果你都不指定，他们默认顺序将为memory_order_seq_cst，这个顺序提供了对成功和失败的全排序。下面对compare_exchange_weak()的两次调用是等价的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; b;</span><br><span class="line"><span class="type">bool</span> expected;</span><br><span class="line">b.<span class="built_in">compare_exchange_weak</span>(expected,<span class="literal">true</span>,memory_order_acq_rel,memory_order_acquire);</span><br><span class="line">b.<span class="built_in">compare_exchange_weak</span>(expected,<span class="literal">true</span>,memory_order_acq_rel);</span><br></pre></td></tr></table></figure></p>
<p><code>std::atomic&lt;bool&gt;</code>和<code>std::atomic_flag</code>的不同之处在于，<code>std::atomic&lt;bool&gt;</code>不是无锁的；为了保证操作的原子性，其实现中需要一个内置的互斥量。当处于特殊情况时，你可以使用<code>is_lock_free()</code>成员函数，去检查<code>std::atomic&lt;bool&gt;</code>上的操作是否无锁。这是另一个，除了<code>std::atomic_flag</code>之外，所有原子类型都拥有的特征。</p>
<p>第二简单的原子类型就是特化原子指针——<code>std::atomic&lt;T*&gt;</code>，接下来就看看它是如何工作的吧。</p>
<h3 id="std-atomic-指针运算"><a href="#std-atomic-指针运算" class="headerlink" title="std::atomic:指针运算"></a>std::atomic:指针运算</h3><p>原子指针类型，可以使用内置类型或自定义类型T，通过特化<code>std::atomic&lt;T*&gt;</code>进行定义，就如同使用bool类型定义<code>std::atomic&lt;bool&gt;</code>类型一样。虽然接口几乎一致，但是它的操作是对于相关的类型的指针，而非bool值本身。就像<code>std::atomic&lt;bool&gt;</code>，虽然它既不能拷贝构造，也不能拷贝赋值，但是他可以通过合适的类型指针进行构造和赋值。如同成员函数<code>is_lock_free()</code>一样，<code>std::atomic&lt;T*&gt;</code>也有<code>load()</code>, <code>store()</code>, <code>exchange()</code>, <code>compare_exchange_weak()</code>和<code>compare_exchage_strong()</code>成员函数，与<code>std::atomic&lt;bool&gt;</code>的语义相同，获取与返回的类型都是<code>T*</code>，而不是bool。</p>
<p><code>std::atomic&lt;T*&gt;</code>为指针运算提供新的操作。基本操作有<code>fetch_add()</code>和<code>fetch_sub()</code>提供，它们在存储地址上做原子加法和减法，为+=, -=, ++和—提供简易的封装。对于内置类型的操作，如你所预期：如果x是<code>std::atomic&lt;Foo*&gt;</code>类型的数组的首地址，然后<code>x+=3</code>让其偏移到第四个元素的地址，并且返回一个普通的<code>Foo*</code>类型值，这个指针值是指向数组中第四个元素。<code>fetch_add()</code>和<code>fetch_sub()</code>的返回值略有不同(所以<code>x.ftech_add(3)</code>让x指向第四个元素，并且函数返回指向第一个元素的地址)。这种操作也被称为“交换-相加”，并且这是一个原子的“读-改-写”操作，如同<code>exchange()</code>和<code>compare_exchange_weak()/compare_exchange_strong()</code>一样。正像其他操作那样，返回值是一个普通的<code>T*</code>值，而非是<code>std::atomic&lt;T*&gt;</code>对象的引用，所以调用代码可以基于之前的值进行操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;&#125;;</span><br><span class="line">Foo some_array[<span class="number">5</span>];</span><br><span class="line"><span class="function">std::atomic&lt;Foo*&gt; <span class="title">p</span><span class="params">(some_array)</span></span>;</span><br><span class="line">Foo* x=p.<span class="built_in">fetch_add</span>(<span class="number">2</span>);  <span class="comment">// p加2，并返回原始值</span></span><br><span class="line"><span class="built_in">assert</span>(x==some_array);</span><br><span class="line"><span class="built_in">assert</span>(p.<span class="built_in">load</span>()==&amp;some_array[<span class="number">2</span>]);</span><br><span class="line">x=(p-=<span class="number">1</span>);  <span class="comment">// p减1，并返回原始值</span></span><br><span class="line"><span class="built_in">assert</span>(x==&amp;some_array[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">assert</span>(p.<span class="built_in">load</span>()==&amp;some_array[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure></p>
<p>函数也允许内存顺序语义作为给定函数的参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="built_in">fetch_add</span>(<span class="number">3</span>,std::memory_order_release);</span><br></pre></td></tr></table></figure></p>
<p>因为<code>fetch_add()</code>和<code>fetch_sub()</code>都是“读-改-写”操作，它们可以拥有任意的内存顺序标签，以及加入到一个释放序列中。指定的语序不可能是操作符的形式，因为没办法提供必要的信息：这些形式都具有memory_order_seq_cst语义。</p>
<h3 id="标准的原子整型的相关操作"><a href="#标准的原子整型的相关操作" class="headerlink" title="标准的原子整型的相关操作"></a>标准的原子整型的相关操作</h3><p>如同普通的操作集合一样(<code>load()</code>, <code>store()</code>，<code>exchange()</code>，<code>compare_exchange_weak()</code>，和<code>compare_exchange_strong()</code>)，在<code>std::atomic&lt;int&gt;</code>和<code>std::atomic&lt;unsigned long long&gt;</code>也是有一套完整的操作可以供使用：<code>fetch_add()</code>，<code>fetch_sub()</code>，<code>fetch_and()</code>，<code>fetch_or()</code>，<code>fetch_xor()</code>，还有复合赋值方式((+=, -=, &amp;=, |=和^=)，以及++和—(++x, x++, —x和x—)。虽然对于普通的整型来说，这些复合赋值方式还不完全，但也十分接近完整了：只有除法、乘法和移位操作不在其中。因为，整型原子值通常用来作计数器，或者是掩码，所以以上操作的缺失显得不是那么重要；如果需要，额外的操作可以将<code>compare_exchange_weak()</code>放入循环中完成。</p>
<p>对于<code>std::atomic&lt;T*&gt;</code>类型紧密相关的两个函数就是<code>fetch_add()</code>和<code>fetch_sub()</code>；函数原子化操作，并且返回旧值，而符合赋值运算会返回新值。前缀加减和后缀加减与普通用法一样：++x对变量进行自加，并且返回新值；而x++对变量自加，返回旧值。正如你预期的那样，在这两个例子中，结果都是相关整型的一个值。</p>
<p>我们已经看过所有基本原子类型；剩下的就是<code>std::atomic&lt;&gt;</code>类型模板，而非其特化类型。那么接下来让我们来了解一下<code>std::atomic&lt;&gt;</code>类型模板。</p>
<h3 id="std-atomic-lt-gt-主要类的模板"><a href="#std-atomic-lt-gt-主要类的模板" class="headerlink" title="std::atomic&lt;&gt;主要类的模板"></a>std::atomic&lt;&gt;主要类的模板</h3><p>主模板的存在，在除了标准原子类型之外，允许用户使用自定义类型创建一个原子变量。不是任何自定义类型都可以使用<code>std::atomic&lt;&gt;</code>的：需要满足一定的标准才行。为了使用<code>std::atomic&lt;UDT&gt;</code>(UDT是用户定义类型)，这个类型必须有拷贝赋值运算符。这就意味着这个类型不能有任何虚函数或虚基类，以及必须使用编译器创建的拷贝赋值操作。不仅仅是这些，自定义类型中所有的基类和非静态数据成员也都需要支持拷贝赋值操作。这(基本上)就允许编译器使用<code>memcpy()</code>，或赋值操作的等价操作，因为它们的实现中没有用户代码。</p>
<p>最后，这个类型必须是“位可比的”(bitwise equality comparable)。这与对赋值的要求差不多；你不仅需要确定，一个UDT类型对象可以使用<code>memcpy()</code>进行拷贝，还要确定其对象可以使用<code>memcmp()</code>对位进行比较。之所以要求这么多，是为了保证“比较/交换”操作能正常的工作。</p>
<p>以上严格的限制都是依据第3章中的一个建议：不要将锁定区域内的数据，以引用或指针的形式，作为参数传递给用户提供的函数。通常情况下，编译器不会为<code>std::atomic&lt;UDT&gt;</code>类型生成无锁代码，所以它将对所有操作使用一个内部锁。如果用户提供的拷贝赋值或比较操作被允许，那么这就需要传递保护数据的引用作为一个参数，这就有悖于指导意见了。当原子操作需要时，运行库也可自由的使用单锁，并且运行库允许用户提供函数持有锁，这样就有可能产生死锁(或因为做一个比较操作，而阻塞了其他的线程)。最终，因为这些限制可以让编译器将用户定义的类型看作为一组原始字节，所以编译器可以对<code>std::atomic&lt;UDT&gt;</code>直接使用原子指令(因此实例化一个特殊无锁结构)。</p>
<p>注意，虽然使用<code>std::atomic&lt;float&gt;</code>或<code>std::atomic&lt;double&gt;</code>（内置浮点类型满足使用memcpy和memcmp的标准），但是它们在<code>compare_exchange_strong</code>函数中的表现可能会令人惊讶。当存储的值与当前值相等时，这个操作也可能失败，可能因为旧值是一个不同的表达式。这就不是对浮点数的原子计算操作了。在使用<code>compare_exchange_strong</code>函数的过程中，你可能会遇到相同的结果，如果你使用<code>std::atomic&lt;&gt;</code>特化一个用户自定义类型，且这个类型定义了比较操作，而这个比较操作与memcmp又有不同——操作可能会失败，因为两个相等的值用有不同的表达式。</p>
<p>如果你的UDT类型的大小如同(或小于)一个int或<code>void*</code>类型时，大多数平台将会对<code>std::atomic&lt;UDT&gt;</code>使用原子指令。有些平台可能会对用户自定义类型(两倍于int或<code>void*</code>的大小)特化的<code>std::atmic&lt;&gt;</code>使用原子指令。这些平台通常支持所谓的“双字节比较和交换”(double-word-compare-and-swap，DWCAS)指令，这个指令与<code>compare_exchange_xxx</code>相关联着。这种指令的支持，对于写无锁代码是有很大的帮助。</p>
<p>以上的限制也意味着有些事情你不能做，比如，创建一个<code>std::atomic&lt;std::vector&lt;int&gt;&gt;</code>类型。这里不能使用包含有计数器，标志指针和简单数组的类型，作为特化类型。虽然这不会导致任何问题，但是，越是复杂的数据结构，就有越多的操作要去做，而非只有赋值和比较。如果这种情况发生了，你最好使用<code>std::mutex</code>保证数据能被必要的操作所保护。</p>
<p>当使用用户定义类型T进行实例化时，<code>std::atomic&lt;T&gt;</code>的可用接口就只有: <code>load()</code>，<code>store()</code>，<code>exchange()</code>，<code>compare_exchange_weak()</code>，<code>compare_exchange_strong()</code>和赋值操作，以及向类型T转换的操作。表5.3列举了每一个原子类型所能使用的操作。</p>
<h3 id="原子操作的释放函数"><a href="#原子操作的释放函数" class="headerlink" title="原子操作的释放函数"></a>原子操作的释放函数</h3><p>直到现在，我都还没有去描述成员函数对原子类型操作的形式。但是，在不同的原子类型中也有等价的非成员函数存在。大多数非成员函数的命名与对应成员函数有关，但是需要<code>atomic_</code>作为前缀(比如，<code>std::atomic_load()</code>)。这些函数都会被不同的原子类型所重载。在指定一个内存序列标签时，他们会分成两种：一种没有标签，另一种将<code>_explicit</code>作为后缀，并且需要一个额外的参数，或将内存顺序作为标签，亦或只有标签(例如，<code>std::atomic_store(&amp;atomic_var,new_value)</code>与<code>std::atomic_store_explicit(&amp;atomic_var,new_value,std::memory_order_release)</code>。不过，原子对象被成员函数隐式引用，所有释放函数都持有一个指向原子对象的指针(作为第一个参数)。</p>
<p>例如，<code>std::atomic_is_lock_free()</code>只有一种类型(虽然会被其他类型所重载)，并且对于同一个对象<code>a</code>，<code>std::atomic_is_lock_free(&amp;a)</code>返回值与<code>a.is_lock_free()</code>相同。同样的，<code>std::atomic_load(&amp;a)</code>和<code>a.load()</code>的作用一样，但需要注意的是，与<code>a.load(std::memory_order_acquire)</code>等价的操作是<code>std::atomic_load_explicit(&amp;a, std::memory_order_acquire)</code>。</p>
<p>释放函数的设计是为了要与C语言兼容，在C中只能使用指针，而不能使用引用。例如，<code>compare_exchange_weak()</code>和<code>compare_exchange_strong()</code>成员函数的第一个参数(期望值)是一个引用，而<code>std::atomic_compare_exchange_weak()</code>(第一个参数是指向对象的指针)的第二个参数是一个指针。<code>std::atomic_compare_exchange_weak_explicit()</code>也需要指定成功和失败的内存序列，而“比较/交换”成员函数都有一个单内存序列形式(默认是<code>std::memory_order_seq_cst</code>)，重载函数可以分别获取成功和失败内存序列。</p>
<p>对<code>std::atomic_flag</code>的操作是“反潮流”的，在那些操作中它们“标志”的名称为：<code>std::atomic_flag_test_and_set()</code>和<code>std::atomic_flag_clear()</code>，但是以<code>_explicit</code>为后缀的额外操作也能够指定内存顺序：<code>std::atomic_flag_test_and_set_explicit()</code>和<code>std::atomic_flag_clear_explicit()</code>。</p>
<p>C++标准库也对在一个原子类型中的<code>std::shared_ptr&lt;&gt;</code>智能指针类型提供释放函数。这打破了“只有原子类型，才能提供原子操作”的原则，这里<code>std::shared_ptr&lt;&gt;</code>肯定不是原子类型。但是，C++标准委员会感觉对此提供额外的函数是很重要的。可使用的原子操作有：load, store, exchange和compare/exchange，这些操作重载了标准原子类型的操作，并且获取一个<code>std::shared_ptr&lt;&gt;*</code>作为第一个参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;my_data&gt; p;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_global_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::shared_ptr&lt;my_data&gt; local=std::<span class="built_in">atomic_load</span>(&amp;p);</span><br><span class="line">  <span class="built_in">process_data</span>(local);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_global_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;my_data&gt; <span class="title">local</span><span class="params">(<span class="keyword">new</span> my_data)</span></span>;</span><br><span class="line">  std::<span class="built_in">atomic_store</span>(&amp;p,local);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>作为和原子操作一同使用的其他类型，也提供“_explicit”变量，允许你指定所需的内存顺序，并且<code>std::atomic_is_lock_free()</code>函数可以用来确定实现是否使用锁，来保证原子性。</p>
<p>如之前的描述，标准原子类型不仅仅是为了避免数据竞争所造成的未定义操作，它们还允许用户对不同线程上的操作进行强制排序。这种强制排序是数据保护和同步操作的基础，例如，std::mutex和std::future&lt;&gt;。所以，让我继续了解本章的真实意义：内存模型在并发方面的细节，如何使用原子操作同步数据和强制排序。</p>
<h2 id="同步操作和强制排序"><a href="#同步操作和强制排序" class="headerlink" title="同步操作和强制排序"></a>同步操作和强制排序</h2><p>假设你有两个线程，一个向数据结构中填充数据，另一个读取数据结构中的数据。为了避免恶性条件竞争，第一个线程设置一个标志，用来表明数据已经准备就绪，并且第二个线程在这个标志设置前不能读取数据。下面的程序清单就是这样的情况。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">data_ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!data_ready.<span class="built_in">load</span>())  <span class="comment">// 1</span></span><br><span class="line">  &#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep</span>(std::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout&lt;&lt;<span class="string">&quot;The answer=&quot;</span>&lt;&lt;data[<span class="number">0</span>]&lt;&lt;<span class="string">&quot;\m&quot;</span>;  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  data.<span class="built_in">push_back</span>(<span class="number">42</span>);  <span class="comment">// 3</span></span><br><span class="line">  data_ready=<span class="literal">true</span>;  <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先把等待数据的低效循环①放在一边。你已经知道，当非原子读②和写③对同一数据结构进行无序访问时，将会导致未定义行为的发生，因此这个循环就是确保访问循序被严格的遵守的。</p>
<p>强制访问顺序是由对<code>std::atomic&lt;bool&gt;</code>类型的<code>data_ready</code>变量进行操作完成的；这些操作通过先行发生(happens-before)和同步发生(synchronizes-with)确定必要的顺序。写入数据③的操作，在写入<code>data_ready</code>标志④的操作前发生，并且读取标志①发生在读取数据②之前。当<code>data_ready</code>①为true，写操作就会与读操作同步，建立一个“先行发生”关系。因为“先行发生”是可传递的，所以写入数据③先行于写入标志④，这两个行为又先行于读取标志的操作①，之前的操作都先行于读取数据②，这样你就拥有了强制顺序：写入数据先行于读取数据，其他没问题了。</p>
<p>所有事情看起来非常直观：对一个值来说，写操作必然先于读操作！在默认它们都是原子操作的时候，这无疑是正确的(这就是原子操作为默认属性的原因)，不过这里需要详细说明：原子操作对于排序要求，也有其他的选项，会在稍后进行详述。</p>
<h3 id="同步发生"><a href="#同步发生" class="headerlink" title="同步发生"></a>同步发生</h3><p>“同步发生”只能在原子类型之间进行操作。例如对一个数据结构进行操作(对互斥量上锁)，如果数据结构包含有原子类型，并且操作内部执行了一定的原子操作，那么这些操作就是同步发生关系。从根本上说，这种关系只能来源于对原子类型的操作。</p>
<p>“同步发生”的基本想法是：在变量x进行适当标记的原子写操作W，同步与对x进行适当标记的原子读操作，读取的是W操作写入的内容；或是在W之后，同一线程上的原子写操作对x写入的值；亦或是任意线程对x的一系列原子读-改-写操作(例如，<code>fetch_add()</code>或<code>compare_exchange_weak()</code>)。这里，第一个线程读取到的值是W操作写入的。</p>
<p>先将“适当的标记”放在一边，因为所有对原子类型的操作，默认都是适当标记的。这实际上就是：如果线程A存储了一个值，并且线程B读取了这个值，线程A的存储操作与线程B的载入操作就是同步发生的关系。</p>
<h3 id="先行发生"><a href="#先行发生" class="headerlink" title="先行发生"></a>先行发生</h3><p>“先行发生”关系是一个程序中，基本构建块的操作顺序；它指定了某个操作去影响另一个操作。对于单线程来说，就简单了：当一个操作排在另一个之后，那么这个操作就是先行执行的。这意味着，如果源码中操作A发生在操作B之前，那么A就先行于B发生。如果操作在同时发生，因为操作间无序执行，通常情况下，它们就没有先行关系了。这就是另一种排序未被指定的情况。</p>
<h3 id="原子操作的内存顺序"><a href="#原子操作的内存顺序" class="headerlink" title="原子操作的内存顺序"></a>原子操作的内存顺序</h3><p>这里有六个内存序列选项可应用于对原子类型的操作：memory_order_relaxed, memory_order_consume, memory_order_acquire, memory_order_release, memory_order_acq_rel, 以及memory_order_seq_cst。除非你为特定的操作指定一个序列选项，要不内存序列选项对于所有原子类型默认都是memory_order_seq_cst。虽然有六个选项，但是它们仅代表三种内存模型：排序一致序列(sequentially consistent)，获取-释放序列(memory_order_consume, memory_order_acquire, memory_order_release和memory_order_acq_rel)，和自由序列(memory_order_relaxed)。</p>
<p>这些不同的内存序列模型，在不同的CPU架构下，功耗是不一样的。例如，基于处理器架构的可视化精细操作的系统，比起其他系统，添加的同步指令可被排序一致序列使用(在获取-释放序列和自由序列之前)，或被获取-释放序列调用(在自由序列之前)。如果这些系统有多个处理器，这些额外添加的同步指令可能会消耗大量的时间，从而降低系统整体的性能。另一方面，CPU使用的是x86或x86-64架构(例如，使用Intel或AMD处理器的台式电脑)，使用这种架构的CPU不需要任何对获取-释放序列添加额外的指令(没有保证原子性的必要了)，并且，即使是排序一致序列，对于加载操作也不需要任何特殊的处理，不过在进行存储时，有点额外的消耗。</p>
<p>不同种类的内存序列模型，允许专家利用其提升与更细粒度排序相关操作的性能。当默认使用排序一致序列(相较于其他序列，它是最简单的)时，对于在那些不大重要的情况下是有利的。</p>
<p>选择使用哪个模型，或为了了解与序列相关的代码，为什么选择不同的内存模型，是需要了解一个重要的前提，那就是不同模型是如何影响程序的行为。让我们来看一下选择每个操作序列和同步相关的结果。</p>
<p>默认序列命名为排序一致，是因为程序中的行为从任意角度去看，序列顺序都保持一致。如果原子类型实例上的所有操作都是序列一致的，那么一个多线程程序的行为，就以某种特殊的排序执行，好像单线程那样。这是目前来看，最容易理解的内存序列，这也就是将其设置为默认的原因：所有线程都必须了解，不同的操作也遵守相同的顺序。因为其简单的行为，可以使用原子变量进行编写。通过不同的线程，你可以写出所有序列上可能的操作，这样就可以消除那些不一致，以及验证你代码的行为是否与预期相符。这也就意味着，所有操作都不能重排序；如果你的代码，在一个线程中，将一个操作放在另一个操作前面，那么这个顺序就必须让其他所有的线程所了解。</p>
<p>从同步的角度看，对于同一变量，排序一致的存储操作同步相关于同步一致的载入操作。这就提供了一种对两个(以上)线程操作的排序约束，但是排序一致的功能要比排序约束大的多。所以，对于使用排序一致原子操作的系统上的任一排序一致的原子操作，都会在对值进行存储以后，再进行加载。这种约束不是线程在自由内存序列中使用原子操作；这些线程依旧可以知道，操作以不同顺序排列，所以你必须使用排序一致操作，去保证在多线的情况下有加速的效果。</p>
<p>不过，简单是要付出代价的。在一个多核若排序的机器上，它会加强对性能的惩罚，因为整个序列中的操作都必须在多个处理器上保持一致，可能需要对处理器间的同步操作进行扩展(代价很昂贵！)。即便如此，一些处理器架构(比如通用x86和x86-64架构)就提供了相对廉价的序列一致，所以你需要考虑使用序列一致对性能的影响，这就需要你去查阅你目标处理器的架构文档，进行更多的了解。</p>
<p>以下清单展示了序列一致的行为，对于x和y的加载和存储都显示标注为memory_order_seq_cst，不过在这段代码中，标签可能会忽略，因为其是默认项。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x,y;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_seq_cst);  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_seq_cst);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!x.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">  <span class="keyword">if</span>(y.<span class="built_in">load</span>(std::memory_order_seq_cst))  <span class="comment">// 3</span></span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">  <span class="keyword">if</span>(x.<span class="built_in">load</span>(std::memory_order_seq_cst))  <span class="comment">// 4</span></span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  c.<span class="built_in">join</span>();</span><br><span class="line">  d.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>()!=<span class="number">0</span>);  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>assert⑤语句是永远不会触发的，因为不是存储x的操作①发生，就是存储y的操作②发生。如果在read_x_then_y中加载y③返回false，那是因为存储x的操作肯定发生在存储y的操作之前，那么在这种情况下在read_y_then_x中加载x④必定会返回true，因为while循环能保证在某一时刻y是true。因为memory_order_seq_cst的语义需要一个单全序将所有操作都标记为memory_order_seq_cst，这就暗示着“加载y并返回false③”与“存储y①”的操作，有一个确定的顺序。只有一个全序时，如果一个线程看到x==true，随后又看到y==false，这就意味着在总序列中存储x的操作发生在存储y的操作之前。</p>
<h3 id="释放队列与同步"><a href="#释放队列与同步" class="headerlink" title="释放队列与同步"></a>释放队列与同步</h3><p>通过其他线程，即使有(有序的)多个“读-改-写”操作(所有操作都已经做了适当的标记)在存储和加载操作之间，你依旧可以获取原子变量存储与加载的同步关系。现在，我已经讨论所有可能使用到的内存序列“标签”，我在这里可以做一个简单的概述。当存储操作被标记为memory_order_release，memory_order_acq_rel或memory_order_seq_cst，加载被标记为memory_order_consum，memory_order_acquire或memory_order_sqy_cst，并且操作链上的每一加载操作都会读取之前操作写入的值，因此链上的操作构成了一个释放序列(release sequence)，并且初始化存储同步(对应memory_order_acquire或memory_order_seq_cst)或是前序依赖(对应memory_order_consume)的最终加载。操作链上的任何原子“读-改-写”操作可以拥有任意个存储序列(甚至是memory_order_relaxed)。</p>
<p>为了了解这些操作意味着什么，以及其重要性，考虑一个atomic用作对一个共享队列的元素进行计数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; queue_data;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">populate_queue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">const</span> number_of_items=<span class="number">20</span>;</span><br><span class="line">  queue_data.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">unsigned</span> i=<span class="number">0</span>;i&lt;number_of_items;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    queue_data.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  count.<span class="built_in">store</span>(number_of_items,std::memory_order_release);  <span class="comment">// 1 初始化存储</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consume_queue_items</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> item_index;</span><br><span class="line">    <span class="keyword">if</span>((item_index=count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>,std::memory_order_acquire))&lt;=<span class="number">0</span>)  <span class="comment">// 2 一个“读-改-写”操作</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">wait_for_more_items</span>();  <span class="comment">// 3 等待更多元素</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">process</span>(queue_data[item_index<span class="number">-1</span>]);  <span class="comment">// 4 安全读取queue_data</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(populate_queue)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(consume_queue_items)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">c</span><span class="params">(consume_queue_items)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  c.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种处理方式是让线程产生数据，并存储到一个共享缓存中，而后调用<code>count.store(number_of_items, memory_order_release)</code>①让其他线程知道数据是可用的。线程群消耗着队列中的元素，之后可能调用<code>count.fetch_sub(1, memory_order_acquire)</code>②向队列索取一个元素，不过在这之前，需要对共享缓存进行完整的读取④。一旦count归零，那么队列中就没有更多的元素了，当元素耗尽时线程必须等待③。</p>
<p>当有一个消费者线程时还好，<code>fetch_sub()</code>是一个带有memory_order_acquire的读取操作，并且存储操作是带有memory_order_release语义，所以这里存储与加载同步，线程是可以从缓存中读取元素的。当有两个读取线程时，第二个<code>fetch_sub()</code>操作将看到被第一个线程修改的值，且没有值通过store写入其中。先不管释放序列的规则，这里第二个线程与第一个线程不存在先行关系，并且其对共享缓存中值的读取也不安全，除非第一个<code>fetch_sub()</code>是带有memory_order_release语义的，这个语义为两个消费者线程间建立了不必要的同步。无论是释放序列的规则，还是带有memory_order_release语义的fetch_sub操作，第二个消费者看到的是一个空的queue_data，无法从其获取任何数据，并且这里还会产生条件竞争。幸运的是，第一个<code>fetch_sub()</code>对释放顺序做了一些事情，所以<code>store()</code>能同步与第二个<code>fetch_sub()</code>操作。这里，两个消费者线程间不需要同步关系。</p>
<p>操作链中可以有任意数量的链接，但是提供的都是“读-改-写”操作，比如fetch_sub()，store()，每一个都会与使用memory_order_acquire语义的操作进行同步。在这里例子中，所有链接都是一样的，并且都是获取操作，但它们可由不同内存序列语义组成的操作混合。(译者：也就是不是单纯的获取操作)</p>
<p>虽然，大多数同步关系，是对原子变量的操作应用了内存序列，但这里依旧有必要额外介绍一个对排序的约束——栅栏(fences)。</p>
<h3 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h3><p>如果原子操作库缺少了栅栏，那么这个库就是不完整的。栅栏操作会对内存序列进行约束，使其无法对任何数据进行修改，典型的做法是与使用memory_order_relaxed约束序的原子操作一起使用。栅栏属于全局操作，执行栅栏操作可以影响到在线程中的其他原子操作。因为这类操作就像画了一条任何代码都无法跨越的线一样，所以栅栏操作通常也被称为内存栅栏(memory barriers)。不过，栅栏操作就会限制这种自由，并且会介绍之前没有介绍到的“先行”和“同步”关系。</p>
<p>我们给在不同线程上的两个原子操作中添加一个栅栏，代码如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x,y;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);  <span class="comment">// 1</span></span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);  <span class="comment">// 2</span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);  <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.<span class="built_in">load</span>(std::memory_order_relaxed));  <span class="comment">// 4</span></span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);  <span class="comment">// 5</span></span><br><span class="line">  <span class="keyword">if</span>(x.<span class="built_in">load</span>(std::memory_order_relaxed))  <span class="comment">// 6</span></span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>()!=<span class="number">0</span>);  <span class="comment">// 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>释放栅栏②与获取栅栏⑤同步，这是因为加载y的操作④读取的是在③处存储的值。所以，在①处存储x先行于⑥处加载x，最后x读取出来必为true，并且断言不会被触发⑦。原先不带栅栏的存储和加载x都是无序的，并且断言是可能会触发的。需要注意的是，这两个栅栏都是必要的：你需要在一个线程中进行释放，然后在另一个线程中进行获取，这样才能构建出同步关系。</p>
<p>在这个例子中，如果存储y的操作③标记为memory_order_release，而非memory_order_relaxed的话，释放栅栏②也会对这个操作产生影响。同样的，当加载y的操作④标记为memory_order_acquire时，获取栅栏⑤也会对之产生影响。使用栅栏的一般想法是：当一个获取操作能看到释放栅栏操作后的存储结果，那么这个栅栏就与获取操作同步；并且，当加载操作在获取栅栏操作前，看到一个释放操作的结果，那么这个释放操作同步于获取栅栏。当然，你也可以使用双边栅栏操作，举一个简单的例子，当一个加载操作在获取栅栏前，看到一个值有存储操作写入，且这个存储操作发生在释放栅栏后，那么释放栅栏与获取栅栏是同步的。</p>
<p>虽然，栅栏同步依赖于读取/写入的操作发生于栅栏之前/后，但是这里有一点很重要：同步点，就是栅栏本身。当你执行write_x_then_y，并且在栅栏操作之后对x进行写入，就像下面的代码一样。这里，触发断言的条件就不保证一定为true了，尽管写入x的操作在写入y的操作之前发生。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);</span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里里的两个操作，就不会被栅栏分开，并且也不再有序。只有当栅栏出现在存储x和存储y操作之间，这个顺序是硬性的。当然，栅栏是否存在不会影响任何拥有先行关系的执行序列，这种情况是因为一些其他原子操作。</p>
<h1 id="基于锁的并发数据结构设计"><a href="#基于锁的并发数据结构设计" class="headerlink" title="基于锁的并发数据结构设计"></a>基于锁的并发数据结构设计</h1><h2 id="基于锁的并发数据结构"><a href="#基于锁的并发数据结构" class="headerlink" title="基于锁的并发数据结构"></a>基于锁的并发数据结构</h2><p>基于锁的并发数据结构设计，需要确保访问线程持有锁的时间最短。对于只有一个互斥量的数据结构来说，这十分困难。需要保证数据不被锁之外的操作所访问到，并且还要保证不会在固有结构上产生条件竞争(如第3章所述)。当你使用多个互斥量来保护数据结构中不同的区域时，问题会暴露的更加明显，当操作需要获取多个互斥锁时，就有可能产生死锁。所以，在设计时，使用多个互斥量时需要格外小心。</p>
<p>栈是一个十分简单的数据结构，它只使用了一个互斥量。但是，这个结构是线程安全的吗？它离真正的并发访问又有多远呢？</p>
<h3 id="线程安全栈——使用锁"><a href="#线程安全栈——使用锁" class="headerlink" title="线程安全栈——使用锁"></a>线程安全栈——使用锁</h3><p>我们先把第3章中线程安全的栈拿过来看看：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">empty_stack</span>: std::exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::stack&lt;T&gt; data;</span><br><span class="line">  <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">threadsafe_stack</span>()&#123;&#125;</span><br><span class="line">  <span class="built_in">threadsafe_stack</span>(<span class="type">const</span> threadsafe_stack&amp; other)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;</span><br><span class="line">    data=other.data;</span><br><span class="line">  &#125;</span><br><span class="line">  threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    data.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));  <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();  <span class="comment">// 2</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="type">const</span> <span class="title">res</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      std::make_shared&lt;T&gt;(std::move(data.top())))</span></span>;  <span class="comment">// 3</span></span><br><span class="line">    data.<span class="built_in">pop</span>();  <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">    value=std::<span class="built_in">move</span>(data.<span class="built_in">top</span>());  <span class="comment">// 5</span></span><br><span class="line">    data.<span class="built_in">pop</span>();  <span class="comment">// 6</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先，互斥量m能保证基本的线程安全，那就是对每个成员函数进行加锁保护。这就保证在同一时间内，只有一个线程可以访问到数据，所以能够保证，数据结构的“不变量”被破坏时，不会被其他线程看到。</p>
<p>其次，在<code>empty()</code>和<code>pop()</code>成员函数之间会存在潜在的竞争，不过代码会在<code>pop()</code>函数上锁时，显式的查询栈是否为空，所以这里的竞争是非恶性的。<code>pop()</code>通过对弹出值的直接返回，就可避免<code>std::stack&lt;&gt;</code>中<code>top()</code>和<code>pop()</code>两成员函数之间的潜在竞争。</p>
<p>再次，这个类中也有一些异常源。对互斥量上锁可能会抛出异常，因为上锁操作是每个成员函数所做的第一个操作，所以这是极其罕见的。因无数据修改，所以其是安全的。因解锁一个互斥量是不会失败的，所以段代码很安全，并且使用<code>std::lock_guard&lt;&gt;</code>也能保证互斥量上锁的状态。</p>
<p>对<code>data.push()</code>①的调用可能会抛出一个异常，不是拷贝/移动数据值时，就是内存不足的时候。不管是哪种，<code>std::stack&lt;&gt;</code>都能保证其实安全的，所以这里也没有问题。</p>
<p>在第一个重载<code>pop()</code>中，代码可能会抛出一个<code>empty_stack</code>的异常②，不过数据没有被修改，所以其是安全的。对于res的创建③，也可能会抛出一个异常，这有两方面的原因：对<code>std::make_shared</code>的调用，可能无法分配出足够的内存去创建新的对象，并且内部数据需要对新对象进行引用；或者，在拷贝或移动构造到新分配的内存中返回时抛出异常。两种情况下，c++运行库和标准库能确保这里不会出现内存泄露，并且新创建的对象(如果有的话)都能被正确销毁。因为没有对栈进行任何修改，所以这里也不会有问题。当调用<code>data.pop()</code>④时，其能确保不抛出异常，并且返回结果，所以这个重载<code>pop()</code>函数“异常-安全”。</p>
<p>第二个重载<code>pop()</code>类似，除了在拷贝赋值或移动赋值的时候会抛出异常⑤，当构造一个新对象和一个std::shared_ptr实例时都不会抛出异常。同样，在调用<code>data.pop()</code>⑥（这个成员函数保证不会抛出异常）之前，依旧没有对数据结构进行修改，所以这个函数也为“异常-安全”。</p>
<p>最后，<code>empty()</code>也不会修改任何数据，所以也是“异常-安全”函数。</p>
<p>当调用持有一个锁的用户代码时，这里有两个地方可能会产生死锁：进行拷贝构造或移动构造(①，③)和在对数据项进行拷贝赋值或移动赋值操作⑤的时候；还有一个潜在死锁的地方在于用户定义的操作符new。当这些函数，无论是以直接调用栈的成员函数的方式，还是在成员函数进行操作时，对已经插入或删除的数据进行操作的方式，对锁进行获取，都可能造成死锁。不过，用户要对栈负责，当栈未对一个数据进行拷贝或分配时，用户就不能想当然的将其添加到栈中。</p>
<p>所有成员函数都使用st::lack_guard&lt;&gt;来保护数据，所以栈的成员函数能有“线程安全”的表现。当然，构造与析构函数不是“线程安全”的，不过这也不成问题，因为对实例的构造与析构只能有一次。调用一个不完全构造对象或是已销毁对象的成员函数，无论在那种编程方式下，都不可取。所以，用户就要保证在栈对象完成构建前，其他线程无法对其进行访问；并且，一定要保证在栈对象销毁后，所有线程都要停止对其进行访问。</p>
<p>即使在多线程情况下，并发的调用成员函数是安全的(因为使用锁)，也要保证在单线程的情况下，数据结构做出正确反应。序列化线程会隐性的限制程序性能，这就是栈争议声最大的地方：当一个线程在等待锁时，它就会无所事事。同样的，对于栈来说，等待添加元素也是没有意义的，所以当一个线程需要等待时，其会定期检查empty()或pop()，以及对empty_stack异常进行关注。这样的现实会限制栈的实现的方式，在线程等待的时候，会浪费宝贵的资源去检查数据，或是要求用户写写外部等待和提示代码(例如，使用条件变量)，这就使内部锁失去存在的意义——这就意味着资源的浪费。</p>
<h1 id="无锁并发数据结构设计"><a href="#无锁并发数据结构设计" class="headerlink" title="无锁并发数据结构设计"></a>无锁并发数据结构设计</h1><h2 id="定义和意义"><a href="#定义和意义" class="headerlink" title="定义和意义"></a>定义和意义</h2><p>使用互斥量、条件变量，以及“期望”来同步阻塞数据的算法和数据结构。应用调用库函数，将会挂起一个执行线程，直到其他线程完成某个特定的动作。库函数将调用阻塞操作来对线程进行阻塞，在阻塞移除前，线程无法继续自己的任务。通常，操作系统会完全挂起一个阻塞线程(并将其时间片交给其他线程)，直到其被其他线程“解阻塞”；“解阻塞”的方式很多，比如解锁一个互斥锁、通知条件变量达成，或让“期望”就绪。</p>
<p>不使用阻塞库的数据结构和算法，被称为无阻塞结构。不过，无阻塞的数据结构并非都是无锁的，那么就让我们见识一下各种各样的无阻塞数据结构吧！</p>
<h3 id="非阻塞数据结构"><a href="#非阻塞数据结构" class="headerlink" title="非阻塞数据结构"></a>非阻塞数据结构</h3><p>在第5章中，我们使用<code>std::atomic_flag</code>实现了一个简单的自旋锁。一起回顾一下这段代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">spinlock_mutex</span></span><br><span class="line">&#123;</span><br><span class="line">  std::atomic_flag flag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">spinlock_mutex</span>():</span><br><span class="line">    <span class="built_in">flag</span>(ATOMIC_FLAG_INIT)</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(flag.<span class="built_in">test_and_set</span>(std::memory_order_acquire));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    flag.<span class="built_in">clear</span>(std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这段代码没有调用任何阻塞函数，<code>lock()</code>只是让循环持续调用<code>test_and_set()</code>，并返回false。这就是为什么取名为“自旋锁”的原因——代码“自旋”于循环当中。所以，这里没有阻塞调用，任意代码使用互斥量来保护共享数据都是非阻塞的。不过，自旋锁并不是无锁结构。这里用了一个锁，并且一次能锁住一个线程。让我们来看一下无锁结构的具体定义，这将有助于你判断哪些类型的数据结构是无锁的。</p>
<h3 id="无锁数据结构"><a href="#无锁数据结构" class="headerlink" title="无锁数据结构"></a>无锁数据结构</h3><p>作为无锁结构，就意味着线程可以并发的访问这个数据结构。线程不能做相同的操作；一个无锁队列可能允许一个线程进行压入数据，另一个线程弹出数据，当有两个线程同时尝试添加元素时，这个数据结构将被破坏。不仅如此，当其中一个访问线程被调度器中途挂起时，其他线程必须能够继续完成自己的工作，而无需等待挂起线程。</p>
<p>具有“比较/交换”操作的数据结构，通常在“比较/交换”实现中都有一个循环。使用“比较/交换”操作的原因：当有其他线程同时对指定数据的修改时，代码将尝试恢复数据。当其他线程被挂起时，“比较/交换”操作执行成功，那么这样的代码就是无锁的。当执行失败时，就需要一个自旋锁了，且这个结构就是“非阻塞-有锁”的结构。</p>
<p>无锁算法中的循环会让一些线程处于“饥饿”状态。如有线程在“错误”时间执行，那么第一个线程将会不停得尝试自己所要完成的操作(其他程序继续执行)。“无锁-无等待”数据结构，就为了避免这种问题存在的。</p>
<h3 id="无等待数据结构"><a href="#无等待数据结构" class="headerlink" title="无等待数据结构"></a>无等待数据结构</h3><p>无等待数据结构就是：首先，是无锁数据结构；并且，每个线程都能在有限的步数内完成操作，暂且不管其他线程是如何工作的。由于会和别的线程产生冲突，所以算法可以进行无数次尝试，因此并不是无等待的。</p>
<p>正确实现一个无锁的结构是十分困难的。因为，要保证每一个线程都能在有限步骤里完成操作，就需要保证每一个操作可以被一次性执行完成；当有线程执行某个操作时，不会让其他线程的操作失败。这就会让算法中所使用到的操作变的相当复杂。</p>
<p>考虑到获取无锁或无等待的数据结构所有权都很困难，那么就有理由来写一个数据结构了；需要保证的是，所要得获益要大于实现成本。那么，就先来找一下实现成本和所得获益的平衡点吧！</p>
<h3 id="无锁数据结构的利与弊"><a href="#无锁数据结构的利与弊" class="headerlink" title="无锁数据结构的利与弊"></a>无锁数据结构的利与弊</h3><p>使用无锁结构的主要原因：将并发最大化。使用基于锁的容器，会让线程阻塞或等待；互斥锁削弱了结构的并发性。在无锁数据结构中，某些线程可以逐步执行。在无等待数据结构中，无论其他线程当时在做什么，每一个线程都可以转发进度。这种理想的方式实现起来很难。结构太简单，反而不容易写，因为其就是一个自旋锁。</p>
<p>使用无锁数据结构的第二个原因就是鲁棒性。当一个线程在获取一个锁时被杀死，那么数据结构将被永久性的破坏。不过，当线程在无锁数据结构上执行操作，在执行到一半死亡时，数据结构上的数据没有丢失(除了线程本身的数据)，其他线程依旧可以正常执行。</p>
<p>另一方面，当不能限制访问数据结构的线程数量时，就需要注意不变量的状态，或选择替代品来保持不变量的状态。同时，还需要注意操作的顺序约束。为了避免未定义行为，及相关的数据竞争，就必须使用原子操作对修改操作进行限制。不过，仅使用原子操作时不够的；需要确定被其他线程看到的修改，是遵循正确的顺序。</p>
<p>因为，没有任何锁(有可能存在活锁)，死锁问题不会困扰无锁数据结构。活锁的产生是，两个线程同时尝试修改数据结构，但每个线程所做的修改操作都会让另一个线程重启，所以两个线程就会陷入循环，多次的尝试完成自己的操作。试想有两个人要过独木桥，当两个人从两头向中间走的时候，他们会在中间碰到，然后不得不再走回出发的地方，再次尝试过独木桥。这里，要打破僵局，除非有人先到独木桥的另一端(或是商量好了，或是走的快，或纯粹是运气)，要不这个循环将一直重复下去。不过活锁的存在时间并不久，因为其依赖于线程调度。所以其只是对性能有所消耗，而不是一个长期的问题；但这个问题仍需要关注。根据定义，无等待的代码不会被活锁所困扰，因其操作执行步骤是有上限的。换个角度，无等待的算法要比等待算法的复杂度高，且即使没有其他线程访问数据结构，也可能需要更多步骤来完成对应操作。</p>
<p>这就是“无锁-无等待”代码的缺点：虽然提高了并发访问的能力，减少了单个线程的等待时间，但是其可能会将整体性能拉低。首先，原子操作的无锁代码要慢于无原子操作的代码，原子操作就相当于无锁数据结构中的锁。不仅如此，硬件必须通过同一个原子变量对线程间的数据进行同步。在第8章，你将看到与“乒乓”缓存相关的原子变量(多个线程访问同时进行访问)，将会成为一个明显的性能瓶颈。在提交代码之前，无论是基于锁的数据结构，还是无锁的数据结构，对性能的检查是很重要的(最坏的等待时间，平均等待时间，整体执行时间，或者其他指标)。</p>
<h2 id="无锁数据结构的例子"><a href="#无锁数据结构的例子" class="headerlink" title="无锁数据结构的例子"></a>无锁数据结构的例子</h2><p>为了演示一些在设计无锁数据结构中所使用到的技术，我们将看到一些无锁实现的简单数据结构。这里不仅要在每个例子中描述一个有用的数据结构实现，还将使用这些例子的某些特别之处来阐述对于无锁数据结构的设计。</p>
<p>如之前所提到的，无锁结构依赖与原子操作和内存序及相关保证，以确保多线程以正确的顺序访问数据结构。最初，所有原子操作默认使用的是memory_order_seq_cst内存序；因为简单，所以使用(所有memory_order_seq_cst都遵循一种顺序)。不过，在后面的例子中，我们将会降低内存序的要求，使用memory_order_acquire, memory_order_release, 甚至memory_order_relaxed。虽然这个例子中没有直接的使用锁，但需要注意的是对std::atomic_flag的使用。一些平台上的无锁结构实现，使用了内部锁。</p>
<h3 id="写一个无锁的线程安全栈"><a href="#写一个无锁的线程安全栈" class="headerlink" title="写一个无锁的线程安全栈"></a>写一个无锁的线程安全栈</h3><p>栈的要求很简单：查询顺序是添加顺序的逆序——先入后出(LIFO)。所以，要确保一个值安全的添加入栈就十分重要，因为很可能在添加后，马上被其他线程索引，同时确保只有一个线程能索引到给定值也是很重要。最简单的栈就是链表，head指针指向第一个节点(可能是下一个被索引到的节点)，并且每个节点依次指向下一个节点。</p>
<p>在这样的情况下，添加一个节点相对来说很简单：</p>
<ul>
<li>创建一个新节点。</li>
<li>将当新节点的next指针指向当前的head节点。</li>
<li>让head节点指向新节点。</li>
</ul>
<p>至关重要的是，当有两个线程同时添加节点的时候，在第2步和第3步的时候会产生条件竞争：一个线程可能在修改head的值时，另一个线程正在执行第2步，并且在第3步中对head进行更新。</p>
<p>OK，那如何应对讨厌的条件竞争呢？答案就是：在第3步的时候使用一个原子“比较/交换”操作，来保证当步骤2对head进行读取时，不会对head进行修改。当有修改时，可以循环“比较/交换”操作。下面的代码就展示了，不用锁来实现线程安全的push()函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lock_free_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">  &#123;</span><br><span class="line">    T data;</span><br><span class="line">    node* next;</span><br><span class="line">    <span class="built_in">node</span>(T <span class="type">const</span>&amp; data_):  <span class="comment">// 1</span></span><br><span class="line">     <span class="built_in">data</span>(data_)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  std::atomic&lt;node*&gt; head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; data)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    node* <span class="type">const</span> new_node=<span class="keyword">new</span> <span class="built_in">node</span>(data); <span class="comment">// 2</span></span><br><span class="line">    new_node-&gt;next=head.<span class="built_in">load</span>();  <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">while</span>(!head.<span class="built_in">compare_exchange_weak</span>(new_node-&gt;next,new_node));  <span class="comment">// 4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码近乎能匹配之前所说的三个步骤：创建一个新节点②，设置新节点的next指针指向当前head③，并设置head指针指向新节点④。node结构用其自身的构造函数来进行数据填充①，必须保证节点在构造完成后随时能被弹出。之后需要使用compare_exchange_weak()来保证在被存储到new_node-&gt;next的head指针和之前的一样③。代码的亮点是使用“比较/交换”操作：当其返回false时，因为比较失败(例如，head被其他线程锁修改)，new_node-&gt;next作为操作的第一个参数，将会更新head。循环中不需要每次都重新加载head指针，因为编译器会帮你完成这件事。同样，因为循环可能直接就失败了，所以这里使用compare_exchange_weak要好于使用compare_exchange_strong。</p>
<p>所以，这里暂时不需要pop()操作，可以先快速检查一下push()的实现是否有违指导意见。这里唯一一个能抛出异常的地方就构造新node的时候①，不过其会自行处理，且链表中的内容没有被修改，所以这里是安全的。因为在构建数据的时候，是将其作为node的一部分作为存储的，并且使用compare_exchange_weak()来更新head指针，所以这里没有恶性的条件竞争。“比较/交换”成功时，节点已经准备就绪，且随时可以提取。因为这里没有锁，所以就不存在死锁的情况，这里的push()函数实现的很成功。</p>
<p>那么，你现在已经有往栈中添加数据的方法了，现在需要删除数据的方法。其步骤如下，也很简单：</p>
<ul>
<li>读取当前head指针的值。</li>
<li>读取head-&gt;next。</li>
<li>设置head到head-&gt;next。</li>
<li>通过索引node，返回data数据。</li>
<li>删除索引节点。</li>
</ul>
<p>但在多线程环境下，就不像看起来那么简单了。当有两个线程要从栈中移除数据，两个线程可能在步骤1中读取到同一个head(值相同)。当其中一个线程处理到步骤5，而另一个线程还在处理步骤2时，这个还在处理步骤2的线程将会解引用一个悬空指针。这只是写无锁代码所遇到的最大问题之一，所以现在只能跳过步骤5，让节点泄露。</p>
<p>另一个问题就是：当两个线程读取到同一个head值，他们将返回同一个节点。这就违反了栈结构的意图，所以你需要避免这样的问题产生。你可以像在push()函数中解决条件竞争那样来解决这个问题：使用“比较/交换”操作更新head。当“比较/交换”操作失败时，不是一个新节点已被推入，就是其他线程已经弹出了想要弹出的节点。无论是那种情况，都得返回步骤1(“比较/交换”操作将会重新读取head)。</p>
<p>当“比较/交换”成功，就可以确定当前线程是弹出给定节点的唯一线程，之后就可以放心的执行步骤4了。这里先看一下pop()的雏形：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lock_free_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; result)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    node* old_head=head.<span class="built_in">load</span>();</span><br><span class="line">    <span class="keyword">while</span>(!head.<span class="built_in">compare_exchange_weak</span>(old_head,old_head-&gt;next));</span><br><span class="line">    result=old_head-&gt;data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>虽然这段代码很优雅，但这里还有两个节点泄露的问题。首先，这段代码在空链表的时候不工作：当head指针式一个空指针时，当要访问next指针时，将引起未定义行为。这很容易通过对nullptr的检查进行修复(在while循环中)，要不对空栈抛出一个异常，要不返回一个bool值来表明成功与否。</p>
<p>第二个问题就是异常安全问题。当在第3章中介绍栈结构时，了解了在返回值的时候会出现异常安全问题：当有异常被抛出时，复制的值将丢失。在这种情况下，传入引用是一种可以接受的解决方案；因为这样就能保证，当有异常抛出时，栈上的数据不会丢失。不幸的是，不能这样做；只能在单一线程对值进行返回的时候，才进行拷贝，以确保拷贝操作的安全性，这就意味着在拷贝结束后这个节点就被删除了。因此，通过引用获取返回值的方式就没有任何优势：直接返回也是可以的。若想要安全的返回值，你必须使用第3章中的其他方法：返回指向数据值的(智能)指针。</p>
<p>当返回的是智能指针时，就能返回nullptr以表明没有值可返回，但是要求在堆上对智能指针进行内存分配。将分配过程做为pop()的一部分时(也没有更好的选择了)，堆分配时可能会抛出一个异常。与此相反，可以在push()操作中对内存进行分配——无论怎样，都得对node进行内存分配。返回一个<code>std::shared_ptr&lt;&gt;</code>不会抛出异常，所以在pop()中进行分配就是安全的。将上面的观点放在一起，就能看到如下的代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lock_free_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">  &#123;</span><br><span class="line">    std::shared_ptr&lt;T&gt; data;  <span class="comment">// 1 指针获取数据</span></span><br><span class="line">    node* next;</span><br><span class="line">    <span class="built_in">node</span>(T <span class="type">const</span>&amp; data_):</span><br><span class="line">      <span class="built_in">data</span>(std::<span class="built_in">make_shared</span>&lt;T&gt;(data_))  <span class="comment">// 2 让std::shared_ptr指向新分配出来的T</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  std::atomic&lt;node*&gt; head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; data)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    node* <span class="type">const</span> new_node=<span class="keyword">new</span> <span class="built_in">node</span>(data);</span><br><span class="line">    new_node-&gt;next=head.<span class="built_in">load</span>();</span><br><span class="line">    <span class="keyword">while</span>(!head.<span class="built_in">compare_exchange_weak</span>(new_node-&gt;next,new_node));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    node* old_head=head.<span class="built_in">load</span>();</span><br><span class="line">    <span class="keyword">while</span>(old_head &amp;&amp; <span class="comment">// 3 在解引用前检查old_head是否为空指针</span></span><br><span class="line">      !head.<span class="built_in">compare_exchange_weak</span>(old_head,old_head-&gt;next));</span><br><span class="line">    <span class="keyword">return</span> old_head ? old_head-&gt;data : std::<span class="built_in">shared_ptr</span>&lt;T&gt;();  <span class="comment">// 4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>智能指针指向当前数据①，这里必须在堆上为数据分配内存(在node结构体中)②。而后，在<code>compare_exchage_weak()</code>循环中③，需要在old_head指针前，检查指针是否为空。最终，如果存在相关节点，那么将会返回相关节点的值；当不存在时，将返回一个空指针④。注意，结构是无锁的，但并不是无等待的，因为在<code>push()</code>和<code>pop()</code>函数中都有while循环，当<code>compare_exchange_weak()</code>总是失败的时候，循环将会无限循环下去。</p>
<h3 id="停止内存泄露：使用无锁数据结构管理内存"><a href="#停止内存泄露：使用无锁数据结构管理内存" class="headerlink" title="停止内存泄露：使用无锁数据结构管理内存"></a>停止内存泄露：使用无锁数据结构管理内存</h3><p>第一次了解<code>pop()</code>时，为了避免条件竞争选择了带有内存泄露的节点。但是，不论什么样的C++程序，存在内存泄露都不可接受。所以，现在来解决这个问题！</p>
<p>基本问题在于，当要释放一个节点时，需要确认其他线程没有持有这个节点。当只有一个线程调用<code>pop()</code>，就可以放心的进行释放。当节点添加入栈后，<code>push()</code>就不会与节点有任何的关系了，所以只有调用<code>pop()</code>函数的线程与已加入节点有关，并且能够安全的将节点删除。</p>
<p>另一方面，当栈同时处理多线程对<code>pop()</code>的调用时，就需要知道节点在什么时候被删除。这实际上就需要你写一个节点专用的垃圾收集器。这听起来有些可怖，同时也相当棘手，不过并不是多么糟糕：这里需要检查节点，并且检查哪些节点被<code>pop()</code>访问。不需要对push()中的节点有所担心，因为这些节点推到栈上以后，才能被访问到，而多线程只能通过<code>pop()</code>访问同一节点。</p>
<p>当没有线程调用<code>pop()</code>时，这时可以删除栈上的任意节点。因此，当添加节点到“可删除”列表中时，就能从中提取数据了。而后，当没有线程通过<code>pop()</code>访问节点时，就可以安全的删除这些节点了。那怎么知道没有线程调用<code>pop()</code>了呢？很简单——计数即可。当计数器数值增加时，就是有节点推入；当减少时，就是有节点被删除。这样从“可删除”列表中删除节点就很安全了，直到计数器的值为0为止。当然，这个计数器必须是原子的，这样它才能在多线程的情况下正确的进行计数。下面的清单中，展示了修改后的<code>pop()</code>函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lock_free_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::atomic&lt;<span class="type">unsigned</span>&gt; threads_in_pop;  <span class="comment">// 1 原子变量</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">try_reclaim</span><span class="params">(node* old_head)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ++threads_in_pop;  <span class="comment">// 2 在做事之前，计数值加1</span></span><br><span class="line">    node* old_head=head.<span class="built_in">load</span>();</span><br><span class="line">    <span class="keyword">while</span>(old_head &amp;&amp;</span><br><span class="line">      !head.<span class="built_in">compare_exchange_weak</span>(old_head,old_head-&gt;next));</span><br><span class="line">    std::shared_ptr&lt;T&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(old_head)</span><br><span class="line">    &#123; </span><br><span class="line">      res.<span class="built_in">swap</span>(old_head-&gt;data);  <span class="comment">// 3 回收删除的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">try_reclaim</span>(old_head);  <span class="comment">// 4 从节点中直接提取数据，而非拷贝指针</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>threads_in_pop</code>①原子变量用来记录有多少线程试图弹出栈中的元素。当<code>pop()</code>②函数调用的时候，计数器加一；当调用<code>try_reclaim()</code>时，计数器减一，当这个函数被节点调用时，说明这个节点已经被删除④。因为暂时不需要将节点删除，可以通过swap()函数来删除节点上的数据③(而非只是拷贝指针)，当不再需要这些数据的时候，这些数据会自动删除，而不是持续存在着。接下来看一下<code>try_reclaim()</code>是如何实现的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lock_free_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::atomic&lt;node*&gt; to_be_deleted;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">delete_nodes</span><span class="params">(node* nodes)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(nodes)</span><br><span class="line">    &#123;</span><br><span class="line">      node* next=nodes-&gt;next;</span><br><span class="line">      <span class="keyword">delete</span> nodes;</span><br><span class="line">      nodes=next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">try_reclaim</span><span class="params">(node* old_head)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(threads_in_pop==<span class="number">1</span>)  <span class="comment">// 1</span></span><br><span class="line">    &#123;</span><br><span class="line">      node* nodes_to_delete=to_be_deleted.<span class="built_in">exchange</span>(<span class="literal">nullptr</span>);  <span class="comment">// 2 声明“可删除”列表</span></span><br><span class="line">      <span class="keyword">if</span>(!--threads_in_pop)  <span class="comment">// 3 是否只有一个线程调用pop()？</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">delete_nodes</span>(nodes_to_delete);  <span class="comment">// 4</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(nodes_to_delete)  <span class="comment">// 5</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">chain_pending_nodes</span>(nodes_to_delete);  <span class="comment">// 6</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span> old_head;  <span class="comment">// 7</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">chain_pending_node</span>(old_head);  <span class="comment">// 8</span></span><br><span class="line">      --threads_in_pop;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">chain_pending_nodes</span><span class="params">(node* nodes)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    node* last=nodes;</span><br><span class="line">    <span class="keyword">while</span>(node* <span class="type">const</span> next=last-&gt;next)  <span class="comment">// 9 让next指针指向链表的末尾</span></span><br><span class="line">    &#123;</span><br><span class="line">      last=next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">chain_pending_nodes</span>(nodes,last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">chain_pending_nodes</span><span class="params">(node* first,node* last)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    last-&gt;next=to_be_deleted;  <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">while</span>(!to_be_deleted.<span class="built_in">compare_exchange_weak</span>(  <span class="comment">// 11 用循环来保证last-&gt;next的正确性</span></span><br><span class="line">      last-&gt;next,first));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">chain_pending_node</span><span class="params">(node* n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">chain_pending_nodes</span>(n,n);  <span class="comment">// 12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>回收节点时①，threads_in_pop的数值是1，也就是当前线程正在对pop()进行访问，这时就可以安全的将节点进行删除了⑦(将等待节点删除也是安全的)。当数值不是1时，删除任何节点都不安全，所以需要向等待列表中继续添加节点⑧。</p>
<p>假设在某一时刻，threads_in_pop的值为1。那就可以尝试回收等待列表，如果不回收，节点就会继续等待，直到整个栈被销毁。要做到回收，首先要通过一个原子exchange操作声明②删除列表，并将计数器减一③。如果之后计数的值为0，就意味着没有其他线程访问等待节点链表。出现新的等待节点时，不必为其烦恼，因为它们将被安全的回收。而后，可以使用delete_nodes对链表进行迭代，并将其删除④。</p>
<p>当计数值在减后不为0，回收节点就不安全；所以如果存在⑤，就需要将其挂在等待删除链表之后⑥，这种情况会发生在多个线程同时访问数据结构的时候。一些线程在第一次测试threads_in_pop①和对“回收”链表的声明②操作间调用pop()，这可能新填入一个已经被线程访问的节点到链表中。在图7.1中，线程C添加节点Y到to_be_deleted链表中，即使线程B仍将其引用作为old_head，之后会尝试访问其next指针。在线程A删除节点的时候，会造成线程B发生未定义的行为。</p>
<p>为了将等待删除的节点添加入等待删除链表，需要复用节点的next指针将等待删除节点链接在一起。在这种情况下，将已存在的链表链接到删除链表后面，通过遍历的方式找到链表的末尾⑨，将最后一个节点的next指针替换为当前to_be_deleted指针⑩，并且将链表中的第一个节点作为新的to_be_deleted指针进行存储⑪。这里需要在循环中使用compare_exchange_weak来保证，通过其他线程添加进来的节点不会发生内存泄露。这样，在链表发生改变时，更新next指针很方便。添加单个节点是一种特殊情况，因为这需要将这个节点作为第一个节点，同时也是最后一个节点进行添加⑫。</p>
<p>在低负荷的情况下，这种方式没有问题，因为在没有线程访问pop()，有一个合适的静态指针。不过，这只是一个瞬时的状态，也就是为什么在回收前，需要检查threads_in_pop计数为0③的原因；同样也是删除节点⑦前进行对计数器检查的原因。删除节点是一项耗时的工作，并且希望其他线程能对链表做的修改越小越好。从第一次发现threads_in_pop是1，到尝试删除节点，会用很长的时间，这样就会让线程有机会调用pop()，会让threads_in_pop不为0，阻止节点的删除操作。</p>
<h3 id="检测使用风险指针-不可回收-的节点"><a href="#检测使用风险指针-不可回收-的节点" class="headerlink" title="检测使用风险指针(不可回收)的节点"></a>检测使用风险指针(不可回收)的节点</h3><p>因为删除一个节点可能会让其他引用其的线程处于危险之中。当其他线程持有这个删除的节点的指针，并且解引用进行操作的时候，将会出现未定义行为。这里的基本观点就是，当有线程去访问要被(其他线程)删除的对象时，会先设置对这个对象设置一个风险指针，而后通知其他线程，删除这个指针是一个危险的行为。一旦这个对象不再被需要，那么就可以清除风险指针了。</p>
<p>当线程想要删除一个对象，那么它就必须检查系统中其他线程是否持有风险指针。当没有风险指针的时候，那么它就可以安全删除对象。否则，它就必须等待风险指针的消失了。这样，线程就得周期性的检查其想要删除的对象是否能安全删除。</p>
<p>首先，需要一个地点能存储指向访问对象的指针，这个地点就是风险指针。这个地点必须能让所有线程看到，需要其中一些线程可以对数据结构进行访问。如何正确和高效的分配这些线程，的确是一个挑战，所以这个问题可以放在后面解决，而后假设你有一个<code>get_hazard_pointer_for_current_thread()</code>的函数，这个函数可以返回风险指针的引用。当你读取一个指针，并且想要解引用它的时候，你就需要这个函数——在这种情况下head数值源于下面的列表：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::atomic&lt;<span class="type">void</span>*&gt;&amp; hp=<span class="built_in">get_hazard_pointer_for_current_thread</span>();</span><br><span class="line">  node* old_head=head.<span class="built_in">load</span>();  <span class="comment">// 1</span></span><br><span class="line">  node* temp;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    temp=old_head;</span><br><span class="line">    hp.<span class="built_in">store</span>(old_head);  <span class="comment">// 2</span></span><br><span class="line">    old_head=head.<span class="built_in">load</span>();</span><br><span class="line">  &#125; <span class="keyword">while</span>(old_head!=temp); <span class="comment">// 3</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在while循环中就能保证node不会在读取旧head指针①时，以及在设置风险指针的时被删除了。这种模式下，其他线程不知道有线程对这个给定的节点进行了访问。幸运的是，当旧head节点要被删除时，head本身是要改变的，所以需要对head进行检查，并持续循环，直到head指针中的值与风险指针中的值相同③。使用风险指针，如同依赖对已删除对象的引用。当使用默认的new和delete操作对风险指针进行操作时，会出现未定义行为，所以需要确定实现是否支持这样的操作，或使用自定义分配器来保证这种用法的正确性。</p>
<p>现在已经设置了风险指针，那就可以对<code>pop()</code>进行处理了，基于现在了解到的安全知识，这里不会有其他线程来删除节点。啊哈！这里每一次重新加载old_head时，解引用刚刚读取到的指针时，就需要更新风险指针。当从链表中提取一个节点时，就可以将风险指针清除了。如果没有其他风险指针引用节点，就可以安全的删除节点了；否则，就需要将其添加到链表中，之后再将其删除。下面的代码就是对该方案的完整实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::atomic&lt;<span class="type">void</span>*&gt;&amp; hp=<span class="built_in">get_hazard_pointer_for_current_thread</span>();</span><br><span class="line">  node* old_head=head.<span class="built_in">load</span>();</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    node* temp;</span><br><span class="line">    <span class="keyword">do</span>  <span class="comment">// 1 直到将风险指针设为head指针</span></span><br><span class="line">    &#123;</span><br><span class="line">      temp=old_head;</span><br><span class="line">      hp.<span class="built_in">store</span>(old_head);</span><br><span class="line">      old_head=head.<span class="built_in">load</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span>(old_head!=temp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(old_head &amp;&amp;</span><br><span class="line">    !head.<span class="built_in">compare_exchange_strong</span>(old_head,old_head-&gt;next));</span><br><span class="line">  hp.<span class="built_in">store</span>(<span class="literal">nullptr</span>);  <span class="comment">// 2 当声明完成，清除风险指针</span></span><br><span class="line">  std::shared_ptr&lt;T&gt; res;</span><br><span class="line">  <span class="keyword">if</span>(old_head)</span><br><span class="line">  &#123;</span><br><span class="line">    res.<span class="built_in">swap</span>(old_head-&gt;data);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">outstanding_hazard_pointers_for</span>(old_head))  <span class="comment">// 3 在删除之前对风险指针引用的节点进行检查</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">reclaim_later</span>(old_head);  <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">delete</span> old_head;  <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">delete_nodes_with_no_hazards</span>();  <span class="comment">// 6</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先，循环内部会对风险指针进行设置，在当“比较/交换”操作失败会重载old_head，再次进行设置①。使用compare_exchange_strong()，是因为需要在循环内部做一些实际的工作：当compare_exchange_weak()伪失败后，风险指针将被重置(没有必要)。这个过程能保证风险指针在解引用(old_head)之前，能被正确的设置。当已声明了一个风险指针，那么就可以将其清除了②。如果想要获取一个节点，就需要检查其他线程上的风险指针，检查是否有其他指针引用该节点③。如果有，就不能删除节点，只能将其放在链表中，之后再进行回收④；如果没有，就能直接将这个节点删除了⑤。最后，如果需要对任意节点进行检查，可以调用reclaim_later()。如果链表上没有任何风险指针引用节点，就可以安全的删除这些节点⑥。当有节点持有风险指针，就只能让下一个调用pop()的线程离开。</p>
<p>当然，这些函数——<code>get_hazard_pointer_for_current_thread()</code>, <code>reclaim_later()</code>, <code>outstanding_hazard_pointers_for()</code>, 和<code>delete_nodes_with_no_hazards()</code>——的实现细节我们还没有看到，先来看看它们是如何工作的。</p>
<p>为线程分配风险指针实例的具体方案：使用<code>get_hazard_pointer_for_current_thread()</code>与程序逻辑的关系并不大(不过会影响效率，接下会看到具体的情况)。可以使用一个简单的结构体：固定长度的“线程ID-指针”数组。<code>get_hazard_pointer_for_curent_thread()</code>就可以通过这个数据来找到第一个释放槽，并将当前线程的ID放入到这个槽中。当线程退出时，槽就再次置空，可以通过默认构造<code>std::thread::id()</code>将线程ID放入槽中。这个实现就如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">const</span> max_hazard_pointers=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hazard_pointer</span></span><br><span class="line">&#123;</span><br><span class="line">  std::atomic&lt;std::thread::id&gt; id;</span><br><span class="line">  std::atomic&lt;<span class="type">void</span>*&gt; pointer;</span><br><span class="line">&#125;;</span><br><span class="line">hazard_pointer hazard_pointers[max_hazard_pointers];</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hp_owner</span></span><br><span class="line">&#123;</span><br><span class="line">  hazard_pointer* hp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">hp_owner</span>(hp_owner <span class="type">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">  hp_owner <span class="keyword">operator</span>=(hp_owner <span class="type">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">hp_owner</span>():</span><br><span class="line">    <span class="built_in">hp</span>(<span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> i=<span class="number">0</span>;i&lt;max_hazard_pointers;++i)</span><br><span class="line">    &#123;</span><br><span class="line">      std::thread::id old_id;</span><br><span class="line">      <span class="keyword">if</span>(hazard_pointers[i].id.<span class="built_in">compare_exchange_strong</span>(  <span class="comment">// 6 尝试声明风险指针的所有权</span></span><br><span class="line">         old_id,std::this_thread::<span class="built_in">get_id</span>()))</span><br><span class="line">      &#123;</span><br><span class="line">        hp=&amp;hazard_pointers[i];</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 7</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!hp)  <span class="comment">// 1</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;No hazard pointers available&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::atomic&lt;<span class="type">void</span>*&gt;&amp; <span class="title">get_pointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hp-&gt;pointer;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">hp_owner</span>()  <span class="comment">// 2</span></span><br><span class="line">  &#123;</span><br><span class="line">    hp-&gt;pointer.<span class="built_in">store</span>(<span class="literal">nullptr</span>);  <span class="comment">// 8</span></span><br><span class="line">    hp-&gt;id.<span class="built_in">store</span>(std::thread::<span class="built_in">id</span>());  <span class="comment">// 9</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">void</span>*&gt;&amp; <span class="title">get_hazard_pointer_for_current_thread</span><span class="params">()</span>  <span class="comment">// 3</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">thread_local</span> <span class="type">static</span> hp_owner hazard;  <span class="comment">// 4 每个线程都有自己的风险指针</span></span><br><span class="line">  <span class="keyword">return</span> hazard.<span class="built_in">get_pointer</span>();  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>get_hazard_pointer_for_current_thread()</code>的实现看起来很简单③：一个<code>hp_owner</code>④类型的thread_local(本线程所有)变量，用来存储当前线程的风险指针，可以返回这个变量所持有的指针⑤。之后的工作：第一次有线程调用这个函数时，新hp_owner实例就被创建。这个实例的构造函数⑥，会通过查询“所有者/指针”表，寻找没有所有者的记录。其用<code>compare_exchange_strong()</code>来检查某个记录是否有所有者，并进行析构②。当<code>compare_exchange_strong()</code>失败，其他线程的拥有这个记录，所以可以继续执行下去。当交换成功，当前线程就拥有了这条记录，而后对其进行存储，并停止搜索⑦。当遍历了列表也没有找到物所有权的记录①，就说明有很多线程在使用风险指针，所以这里将抛出一个异常。</p>
<p>一旦<code>hp_owner</code>实例被一个给定的线程所创建，那么之后的访问将会很快，因为指针在缓存中，所以表不需要再次遍历。</p>
<p>当线程退出时，<code>hp_owner</code>的实例将会被销毁。析构函数会在<code>std::thread::id()</code>设置拥有者ID前，将指针重置为nullptr,这样就允许其他线程对这条记录进行复用⑧⑨。</p>
<p>实现<code>get_hazard_pointer_for_current_thread()</code>后，<code>outstanding_hazard_pointer_for()</code>实现就简单了：只需要对风险指针表进行搜索，就可以找到对应记录。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">outstanding_hazard_pointers_for</span><span class="params">(<span class="type">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">unsigned</span> i=<span class="number">0</span>;i&lt;max_hazard_pointers;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(hazard_pointers[i].pointer.<span class="built_in">load</span>()==p)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现都不需要对记录的所有者进行验证：没有所有者的记录会是一个空指针，所以比较代码将总返回false，通过这种方式将代码简化。</p>
<p><code>reclaim_later()</code>和<code>delete_nodes_with_no_hazards()</code>可以对简单的链表进行操作；<code>reclaim_later()</code>只是将节点添加到列表中，<code>delete_nodes_with_no_hazards()</code>就是搜索整个列表，并将无风险指针的记录进行删除。下面将展示它们的具体实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_delete</span><span class="params">(<span class="type">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">delete</span> <span class="built_in">static_cast</span>&lt;T*&gt;(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">data_to_reclaim</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span>* data;</span><br><span class="line">  std::function&lt;<span class="type">void</span>(<span class="type">void</span>*)&gt; deleter;</span><br><span class="line">  data_to_reclaim* next;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="title">data_to_reclaim</span><span class="params">(T* p)</span>:  // <span class="number">1</span></span></span><br><span class="line"><span class="function">    data(p),</span></span><br><span class="line"><span class="function">    deleter(&amp;do_delete&lt;T&gt;),</span></span><br><span class="line"><span class="function">    next(<span class="number">0</span>)</span></span><br><span class="line"><span class="function">  &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">data_to_reclaim</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">deleter</span>(data);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::atomic&lt;data_to_reclaim*&gt; nodes_to_reclaim;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_reclaim_list</span><span class="params">(data_to_reclaim* node)</span>  <span class="comment">// 3</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  node-&gt;next=nodes_to_reclaim.<span class="built_in">load</span>();</span><br><span class="line">  <span class="keyword">while</span>(!nodes_to_reclaim.<span class="built_in">compare_exchange_weak</span>(node-&gt;next,node));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reclaim_later</span><span class="params">(T* data)</span>  <span class="comment">// 4</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">add_to_reclaim_list</span>(<span class="keyword">new</span> <span class="built_in">data_to_reclaim</span>(data));  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delete_nodes_with_no_hazards</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  data_to_reclaim* current=nodes_to_reclaim.<span class="built_in">exchange</span>(<span class="literal">nullptr</span>);  <span class="comment">// 6</span></span><br><span class="line">  <span class="keyword">while</span>(current)</span><br><span class="line">  &#123;</span><br><span class="line">    data_to_reclaim* <span class="type">const</span> next=current-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">outstanding_hazard_pointers_for</span>(current-&gt;data))  <span class="comment">// 7</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">delete</span> current;  <span class="comment">// 8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">add_to_reclaim_list</span>(current);  <span class="comment">// 9</span></span><br><span class="line">    &#125;</span><br><span class="line">    current=next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，<code>reclaim_later()</code>是一个函数模板④。因为风险指针是一个通用解决方案，所以这里就不能将栈节点的类型写死。使用<code>std::atomic&lt;void*&gt;</code>对风险指针进行存储。需要对任意类型的指针进行处理，不过不能使用<code>void*</code>形式，因为当要删除数据项时，delete操作只能对实际类型指针进行操作。<code>data_to_reclaim</code>的构造函数处理的就很优雅：<code>reclaim_later()</code>只是为指针创建一个<code>data_to_reclaim</code>的实例，并且将实例添加到回收链表中⑤。<code>add_to_reclaim_list()</code>③就是使用<code>compare_exchange_weak()</code>循环来访问链表头(就如你之前看到的那样)。</p>
<p>当将节点添加入链表时，<code>data_to_reclaim</code>的析构函数不会被调用；析构函数会在没有风险指针指向节点的时候调用，这也就是<code>delete_nodes_with_no_hazards()</code>的作用。</p>
<p><code>delete_nodes_with_no_hazards()</code>将已声明的链表节点进行回收，使用的是<code>exchange()</code>函数⑥(这个步骤简单且关键，是为了保证只有一个线程回收这些节点)。这样，其他线程就能自由将节点添加到链表中，或在不影响回收指定节点线程的情况下，对节点进行回收。</p>
<p>只要有节点存在于链表中，就需要检查每个节点，查看节点是否被风险指针所指向⑦。如果没有风险指针，那么就可以安全的将记录删除(并且清除存储的数据)⑧。否则，就只能将这个节点添加到链表的后面，再进行回收⑨。</p>
<p>虽然这个实现很简单，也的确安全的回收了被删除的节点，不过这个过程增加了很多开销。遍历风险指针数组需要检查<code>max_hazard_pointers</code>原子变量，并且每次<code>pop()</code>调用时，都需要再检查一遍。原子操作很耗时——在台式CPU上，100次原子操作要比100次非原子操作慢——所以，这里<code>pop()</code>成为了性能瓶颈。这种方式，不仅需要遍历节点的风险指针链表，还要遍历等待链表上的每一个节点。显然，这种方式很糟糕。当有<code>max_hazard_pointers</code>在链表中，那么就需要检查<code>max_hazard_pointers</code>多个已存储的风险指针。</p>
<p>对风险指针(较好)的回收策略</p>
<p>当然有更好的办法。这里只展示一个风险指针的简单实现，来帮助解释技术问题。首先，要考虑的是内存性能。比起对回收链表上的每个节点进行检查都要调用<code>pop()</code>，除非有超过<code>max_hazard_pointer</code>数量的节点存在于链表之上，要不就不需要尝试回收任何节点。这样就能保证至少有一个节点能够回收，如果只是等待链表中的节点数量达到<code>max_hazard_pointers+1</code>，那比之前的方案也没好到哪里去。当获取了<code>max_hazard_pointers</code>数量的节点时，可以调用<code>pop()</code>对节点进行回收，所以这样也不是很好。不过，当有<code>2max_hazard_pointers</code>个节点在列表中时，就能保证至少有<code>max_hazard_pointers</code>可以被回收，在再次尝试回收任意节点前，至少会对<code>pop()</code>有<code>max_hazard_pointers</code>次调用。这就很不错了。比起检查<code>max_hazard_pointers</code>个节点就调用<code>max_hazard_pointers</code>次<code>pop()</code>(而且还不一定能回收节点)，当检查<code>2max_hazard_pointers</code>个节点时，每<code>max_hazard_pointers</code>次对<code>pop()</code>的调用，就会有<code>max_hazard_pointers</code>个节点能被回收。这就意味着，对两个节点检查调用<code>pop()</code>，其中就有一个节点能被回收。</p>
<p>这个方法有个缺点(有增加内存使用的情况)：就是得对回收链表上的节点进行计数，这就意味着要使用原子变量，并且还有很多线程争相对回收链表进行访问。如果还有多余的内存，可以增加内存的使用来实现更好的回收策略：每个线程中的都拥有其自己的回收链表，作为线程的本地变量。这样就不需要原子变量进行计数了。这样的话，就需要分配<code>max_hazard_pointers x max_hazard_pointers</code>个节点。所有节点被回收完毕前时，有线程退出，那么其本地链表可以像之前一样保存在全局中，并且添加到下一个线程的回收链表中，让下一个线程对这些节点进行回收。</p>
<h3 id="应用于无锁栈上的内存模型"><a href="#应用于无锁栈上的内存模型" class="headerlink" title="应用于无锁栈上的内存模型"></a>应用于无锁栈上的内存模型</h3><p>在修改内存序之前，需要检查一下操作之间的依赖关系。而后，再去确定适合这种需求关系的最小内存序。为了保证这种方式能够工作，需要在从线程的视角进行观察。其中最简单的视角就是，向栈中推入一个数据项，之后让其他线程从栈中弹出这个数据。</p>
<p>即使在简单的例子中，都需要三个重要的数据参与。1、counted_node_ptr转移的数据head。2、head引用的node。3、节点所指向的数据项。</p>
<p>做<code>push()</code>的线程，会先构造数据项和节点，再设置head。做<code>pop()</code>的线程，会先加载head的值，再做在循环中对head做“比较/交换”操作，并增加引用计数，再读取对应的node节点，获取next的指向的值，现在就可以看到一组需求关系。next的值是普通的非原子对象，所以为了保证读取安全，这里必须确定存储(推送线程)和加载(弹出线程)的先行关系。因为唯一的原子操作就是<code>push()</code>函数中的<code>compare_exchange_weak()</code>，这里需要释放操作来获取两个线程间的先行关系，这里<code>compare_exchange_weak()</code>必须是<code>std::memory_order_release</code>或更严格的内存序。当<code>compare_exchange_weak()</code>调用失败，什么都不会改变，并且可以持续循环下去，所以使用<code>std::memory_order_relaxed</code>就足够了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  counted_node_ptr new_node;</span><br><span class="line">  new_node.ptr=<span class="keyword">new</span> <span class="built_in">node</span>(data);</span><br><span class="line">  new_node.external_count=<span class="number">1</span>;</span><br><span class="line">  new_node.ptr-&gt;next=head.<span class="built_in">load</span>(std::memory_order_relaxed)</span><br><span class="line">  <span class="keyword">while</span>(!head.<span class="built_in">compare_exchange_weak</span>(new_node.ptr-&gt;next,new_node,</span><br><span class="line">    std::memory_order_release,std::memory_order_relaxed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那<code>pop()</code>的实现呢？为了确定先行关系，必须在访问next值之前使用<code>std::memory_order_acquire</code>或更严格内存序的操作。因为，在<code>increase_head_count()</code>中使用<code>compare_exchange_strong()</code>就获取next指针指向的旧值，所以想要其获取成功就需要确定内存序。如同调用<code>push()</code>那样，当交换失败，循环会继续，所以在失败的时候使用松散的内存序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase_head_count</span><span class="params">(counted_node_ptr&amp; old_counter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  counted_node_ptr new_counter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    new_counter=old_counter;</span><br><span class="line">    ++new_counter.external_count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!head.<span class="built_in">compare_exchange_strong</span>(old_counter,new_counter,</span><br><span class="line">        std::memory_order_acquire,std::memory_order_relaxed));</span><br><span class="line"></span><br><span class="line">  old_counter.external_count=new_counter.external_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当<code>compare_exchange_strong()</code>调用成功，那么ptr中的值就被存到old_counter中。存储操作是<code>push()</code>中的一个释放操作，并且<code>compare_exchange_strong()</code>操作是一个获取操作，现在存储同步于加载，并且能够获取先行关系。因此，在<code>push()</code>中存储ptr的值，要先行于在<code>pop()</code>中对ptr-&gt;next的访问。现在的操作就安全了。</p>
<p>要注意的是，内存序对<code>head.load()</code>的初始化并不妨碍分析，所以现在就可以使用<code>std::memory_order_relaxed</code>。</p>
<p>接下来，<code>compare_exchange_strong()</code>将<code>old_head.ptr-&gt;next</code>设置为head。是否需要做什么来保证操作线程中的数据完整性呢？当交换成功，你就能访问<code>ptr-&gt;data</code>，所以这里需要保证在<code>push()</code>线程中已经对ptr-&gt;data进行了存储(在加载之前)。在<code>increase_head_count()</code>中的获取操作，能保证与<code>push()</code>线程中的存储和“比较/交换”同步。这里的先行关系是：在push()线程中存储数据，先行于存储head指针；调用<code>increase_head_count()</code>先行于对ptr-&gt;data的加载。即使，<code>pop()</code>中的“比较/交换”操作使用<code>std::memory_order_relaxed</code>，这些操作还是能正常运行。唯一不同的地方就是，调用<code>swap()</code>让<code>ptr-&gt;data</code>有所变化，且没有其他线程可以对同一节点进行操作(这就是“比较/交换”操作的作用)。</p>
<p>当<code>compare_exchange_strong()</code>失败，那么新值就不会去更新old_head，继续循环。这里，已确定在<code>increase_head_count()</code>中使用<code>std::memory_order_acquire</code>内存序的可行性，所以这里使用<code>std::memory_order_relaxed</code>也可以。</p>
<p>其他线程呢？是否需要设置一些更为严格的内存序来保证其他线程的安全呢？回答是“不用”。因为，head只会因“比较/交换”操作有所改变；对于“读-改-写”操作来说，<code>push()</code>中的“比较/交换”操作是构成释放序列的一部分。因此，即使有很多线程在同一时间对head进行修改，<code>push()</code>中的<code>compare_exchange_weak()</code>与<code>increase_head_count()</code>(读取已存储的值)中的<code>compare_exchange_strong()</code>也是同步的。</p>
<p>剩余操作就可以用来处理<code>fetch_add()</code>操作(用来改变引用计数的操作)，因为已知其他线程不可能对该节点的数据进行修改，所以从节点中返回数据的线程可以继续执行。不过，当线程获取其他线程修改后的值时，就代表操作失败(<code>swap()</code>是用来提取数据项的引用)。那么，为了避免数据竞争，需要保证<code>swap()</code>先行于delete操作。一种简单的解决办法，在“成功返回”分支中对<code>fetch_add()</code>使用<code>std::memory_order_release</code>内存序，在“再次循环”分支中对<code>fetch_add()</code>使用<code>std::memory_order_qcquire</code>内存序。不过，这就有点矫枉过正：只有一个线程做delete操作(将引用计数设置为0的线程)，所以只有这个线程需要获取操作。幸运的是，因为<code>fetch_add()</code>是一个“读-改-写”操作，是释放序列的一部分，所以可以使用一个额外的<code>load()</code>做获取。当“再次循环”分支将引用计数减为0时，<code>fetch_add()</code>可以重载引用计数，这里使用<code>std::memory_order_acquire</code>为了保持需求的同步关系；并且，<code>fetch_add()</code>本身可以使用<code>std::memory_order_relaxed</code>。使用新<code>pop()</code>的栈实现如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lock_free_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">node</span>;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">counted_node_ptr</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> external_count;</span><br><span class="line">    node* ptr;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">  &#123;</span><br><span class="line">    std::shared_ptr&lt;T&gt; data;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; internal_count;</span><br><span class="line">    counted_node_ptr next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">node</span>(T <span class="type">const</span>&amp; data_):</span><br><span class="line">      <span class="built_in">data</span>(std::<span class="built_in">make_shared</span>&lt;T&gt;(data_)),</span><br><span class="line">      <span class="built_in">internal_count</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::atomic&lt;counted_node_ptr&gt; head;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">increase_head_count</span><span class="params">(counted_node_ptr&amp; old_counter)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    counted_node_ptr new_counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      new_counter=old_counter;</span><br><span class="line">      ++new_counter.external_count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!head.<span class="built_in">compare_exchange_strong</span>(old_counter,new_counter,</span><br><span class="line">                                        std::memory_order_acquire,</span><br><span class="line">                                        std::memory_order_relaxed));</span><br><span class="line">    old_counter.external_count=new_counter.external_count;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">lock_free_stack</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">pop</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; data)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    counted_node_ptr new_node;</span><br><span class="line">    new_node.ptr=<span class="keyword">new</span> <span class="built_in">node</span>(data);</span><br><span class="line">    new_node.external_count=<span class="number">1</span>;</span><br><span class="line">    new_node.ptr-&gt;next=head.<span class="built_in">load</span>(std::memory_order_relaxed)</span><br><span class="line">    <span class="keyword">while</span>(!head.<span class="built_in">compare_exchange_weak</span>(new_node.ptr-&gt;next,new_node,</span><br><span class="line">                                      std::memory_order_release,</span><br><span class="line">                                      std::memory_order_relaxed));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    counted_node_ptr old_head=</span><br><span class="line">       head.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">increase_head_count</span>(old_head);</span><br><span class="line">      node* <span class="type">const</span> ptr=old_head.ptr;</span><br><span class="line">      <span class="keyword">if</span>(!ptr)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(head.<span class="built_in">compare_exchange_strong</span>(old_head,ptr-&gt;next,</span><br><span class="line">                                      std::memory_order_relaxed))</span><br><span class="line">      &#123;</span><br><span class="line">        std::shared_ptr&lt;T&gt; res;</span><br><span class="line">        res.<span class="built_in">swap</span>(ptr-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="type">const</span> count_increase=old_head.external_count<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;internal_count.<span class="built_in">fetch_add</span>(count_increase,</span><br><span class="line">              std::memory_order_release)==-count_increase)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">delete</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(ptr-&gt;internal_count.<span class="built_in">fetch_add</span>(<span class="number">-1</span>,</span><br><span class="line">                   std::memory_order_relaxed)==<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        ptr-&gt;internal_count.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="并发代码设计"><a href="#并发代码设计" class="headerlink" title="并发代码设计"></a>并发代码设计</h1><h2 id="线程间划分工作的技术"><a href="#线程间划分工作的技术" class="headerlink" title="线程间划分工作的技术"></a>线程间划分工作的技术</h2><h3 id="递归划分"><a href="#递归划分" class="headerlink" title="递归划分"></a>递归划分</h3><p>快速排序有两个最基本的步骤：将数据划分到中枢元素之前或之后，然后对中枢元素之前和之后的两半数组再次进行快速排序。这里不能通过对数据的简单划分达到并行，因为，只有在一次排序结束后，才能知道哪些项在中枢元素之前和之后。当要对这种算法进行并行化，很自然的会想到使用递归。每一级的递归都会多次调用quick_sort函数，因为需要知道哪些元素在中枢元素之前和之后。递归调用是完全独立的，因为其访问的是不同的数据集，并且每次迭代都能并发执行。比起对大于和小于的数据块递归调用函数，使用<code>std::async()</code>可以为每一级生成小于数据块的异步任务。使用<code>std::async()</code>时，C++线程库就能决定何时让一个新线程执行任务，以及同步执行任务。</p>
<p>重要的是：对一个很大的数据集进行排序时，当每层递归都产生一个新线程，最后就会产生大量的线程。你会看到其对性能的影响，如果有太多的线程存在，那么你的应用将会运行的很慢。如果数据集过于庞大，会将线程耗尽。那么在递归的基础上进行任务的划分，就是一个不错的主意；你只需要将一定数量的数据打包后，交给线程即可。<code>std::async()</code>可以出里这种简单的情况，不过这不是唯一的选择。</p>
<p>另一种选择是使用<code>std::thread::hardware_concurrency()</code>函数来确定线程的数量。然后，你可以将已排序的数据推到线程安全的栈上。当线程无所事事，不是已经完成对自己数据块的梳理，就是在等待一组排序数据的产生；线程可以从栈上获取这组数据，并且对其排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sorter</span>  <span class="comment">// 1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">chunk_to_sort</span></span><br><span class="line">  &#123;</span><br><span class="line">    std::list&lt;T&gt; data;</span><br><span class="line">    std::promise&lt;std::list&lt;T&gt; &gt; promise;</span><br><span class="line">  &#125;;</span><br><span class="line">  thread_safe_stack&lt;chunk_to_sort&gt; chunks;  <span class="comment">// 2</span></span><br><span class="line">  std::vector&lt;std::thread&gt; threads;  <span class="comment">// 3</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">const</span> max_thread_count;</span><br><span class="line">  std::atomic&lt;<span class="type">bool</span>&gt; end_of_data;</span><br><span class="line">  <span class="built_in">sorter</span>():</span><br><span class="line">    <span class="built_in">max_thread_count</span>(std::thread::<span class="built_in">hardware_concurrency</span>()<span class="number">-1</span>),</span><br><span class="line">    <span class="built_in">end_of_data</span>(<span class="literal">false</span>)</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  ~<span class="built_in">sorter</span>()  <span class="comment">// 4</span></span><br><span class="line">  &#123;</span><br><span class="line">    end_of_data=<span class="literal">true</span>;  <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> i=<span class="number">0</span>;i&lt;threads.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">      threads[i].<span class="built_in">join</span>();  <span class="comment">// 6</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">try_sort_chunk</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    boost::shared_ptr&lt;chunk_to_sort &gt; chunk=chunks.<span class="built_in">pop</span>();  <span class="comment">// 7</span></span><br><span class="line">    <span class="keyword">if</span>(chunk)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">sort_chunk</span>(chunk);  <span class="comment">// 8</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::list&lt;T&gt; <span class="title">do_sort</span><span class="params">(std::list&lt;T&gt;&amp; chunk_data)</span>  <span class="comment">// 9</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(chunk_data.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> chunk_data;</span><br><span class="line">    &#125;</span><br><span class="line">    std::list&lt;T&gt; result;</span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(),chunk_data,chunk_data.<span class="built_in">begin</span>());</span><br><span class="line">    T <span class="type">const</span>&amp; partition_val=*result.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">typename</span> std::list&lt;T&gt;::iterator divide_point=  <span class="comment">// 10</span></span><br><span class="line">       std::<span class="built_in">partition</span>(chunk_data.<span class="built_in">begin</span>(),chunk_data.<span class="built_in">end</span>(),</span><br><span class="line">        [&amp;](T <span class="type">const</span>&amp; val)&#123;<span class="keyword">return</span> val&lt;partition_val;&#125;);</span><br><span class="line">    chunk_to_sort new_lower_chunk;</span><br><span class="line">    new_lower_chunk.data.<span class="built_in">splice</span>(new_lower_chunk.data.<span class="built_in">end</span>(),</span><br><span class="line">       chunk_data,chunk_data.<span class="built_in">begin</span>(),</span><br><span class="line">       divide_point);</span><br><span class="line">    std::future&lt;std::list&lt;T&gt; &gt; new_lower=</span><br><span class="line">      new_lower_chunk.promise.<span class="built_in">get_future</span>();</span><br><span class="line">    chunks.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_lower_chunk));  <span class="comment">// 11</span></span><br><span class="line">    <span class="keyword">if</span>(threads.<span class="built_in">size</span>()&lt;max_thread_count)  <span class="comment">// 12</span></span><br><span class="line">    &#123;</span><br><span class="line">      threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(&amp;sorter&lt;T&gt;::sort_thread,<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::list&lt;T&gt; <span class="title">new_higher</span><span class="params">(do_sort(chunk_data))</span></span>;</span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">end</span>(),new_higher);</span><br><span class="line">    <span class="keyword">while</span>(new_lower.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">0</span>)) !=</span><br><span class="line">       std::future_status::ready)  <span class="comment">// 13</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">try_sort_chunk</span>();  <span class="comment">// 14</span></span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(),new_lower.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sort_chunk</span><span class="params">(boost::shared_ptr&lt;chunk_to_sort&gt; <span class="type">const</span>&amp; chunk)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    chunk-&gt;promise.<span class="built_in">set_value</span>(<span class="built_in">do_sort</span>(chunk-&gt;data));  <span class="comment">// 15</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sort_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!end_of_data)  <span class="comment">// 16</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">try_sort_chunk</span>();  <span class="comment">// 17</span></span><br><span class="line">      std::this_thread::<span class="built_in">yield</span>();  <span class="comment">// 18</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">std::list&lt;T&gt; <span class="title">parallel_quick_sort</span><span class="params">(std::list&lt;T&gt; input)</span>  <span class="comment">// 19</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(input.<span class="built_in">empty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">  &#125;</span><br><span class="line">  sorter&lt;T&gt; s;</span><br><span class="line">  <span class="keyword">return</span> s.<span class="built_in">do_sort</span>(input);  <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，<code>parallel_quick_sort</code>函数⑲代表了<code>sorter</code>类①的功能，其支持在栈上简单的存储无序数据块②，并且对线程进行设置③。<code>do_sort</code>成员函数⑨主要做的就是对数据进行划分⑩。相较于对每一个数据块产生一个新的线程，这次会将这些数据块推到栈上⑪；并在有备用处理器⑫的时候，产生新线程。因为小于部分的数据块可能由其他线程进行处理，那么就得等待这个线程完成⑬。为了让所有事情顺利进行，当线程处于等待状态时⑭，就让当前线程尝试处理栈上的数据。<code>try_sort_chunk</code>只是从栈上弹出一个数据块⑦，并且对其进行排序⑧，将结果存在promise中，让线程对已经存在于栈上的数据块进行提取⑮。</p>
<p>当<code>end_of_data</code>没有被设置时⑯，新生成的线程还在尝试从栈上获取需要排序的数据块⑰。在循环检查中，也要给其他线程机会⑱，可以从栈上取下数据块进行更多的操作。这里的实现依赖于<code>sorter</code>类④对线程的清理。当所有数据都已经排序完成，<code>do_sort</code>将会返回(即使还有工作线程在运行)，所以主线程将会从<code>parallel_quick_sort</code>⑳中返回，在这之后会销毁sorter对象。析构函数会设置<code>end_of_data</code>标志⑤，以及等待所有线程完成工作⑥。标志的设置将终止线程函数内部的循环⑯。</p>
<h2 id="影响并发代码性能的因素"><a href="#影响并发代码性能的因素" class="headerlink" title="影响并发代码性能的因素"></a>影响并发代码性能的因素</h2><h3 id="有多少个处理器？"><a href="#有多少个处理器？" class="headerlink" title="有多少个处理器？"></a>有多少个处理器？</h3><p>处理器个数是影响多线程应用的首要因素。一个单核16芯的处理器和四核双芯或十六核单芯的处理器相同：在任何系统上，都能运行16个并发线程。当线程数量少于16个时，会有处理器处于空闲状态。另一方面，当多于16个线程在运行的时候(都没有阻塞或等待)，应用将会浪费处理器的运算时间在线程间进行切换。</p>
<p>为了扩展应用线程的数量，与硬件所支持的并发线程数量一致，C++标准线程库提供了<code>std::thread::hardware_concurrency()</code>。使用这个函数就能知道在给定硬件上可以扩展的线程数量了。</p>
<p>需要谨慎使用<code>std::thread::hardware_concurrency()</code>，因为代码不会考虑有其他运行在系统上的线程(除非已经将系统信息进行共享)。最坏的情况就是，多线程同时调用<code>std::thread::hardware_concurrency()</code>函数来对线程数量进行扩展，这样将导致庞大的超额认购。</p>
<h3 id="数据争用与乒乓缓存"><a href="#数据争用与乒乓缓存" class="headerlink" title="数据争用与乒乓缓存"></a>数据争用与乒乓缓存</h3><p>当两个线程并发的在不同处理器上执行，并且对同一数据进行读取，通常不会出现问题；因为数据将会拷贝到每个线程的缓存中，并且可以让两个处理器同时进行处理。不过，当有线程对数据进行修改的时候，这个修改需要更新到其他核芯的缓存中去，就要耗费一定的时间。</p>
<p>思考下面简短的代码段：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processing_loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>,std::memory_order_relaxed)&lt;<span class="number">100000000</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>counter变量是全局的，所以任何线程都能调用<code>processing_loop()</code>去修改同一个变量。因此，当新增加的处理器时，counter变量必须要在缓存内做一份拷贝，再改变自己的值，或其他线程以发布的方式对缓存中的拷贝副本进行更新。即使用<code>std::memory_order_relaxed</code>，编译器不会为任何数据做同步操作，fetch_add是一个“读-改-写”操作，因此就要对最新的值进行检索。如果另一个线程在另一个处理器上执行同样的代码，counter的数据需要在两个处理器之间进行传递，那么这两个处理器的缓存中间就存有counter的最新值(当counter的值增加时)。</p>
<p>如果<code>do_something()</code>足够短，或有很多处理器来对这段代码进行处理时，处理器将会互相等待；一个处理器准备更新这个值，另一个处理器正在修改这个值，所以该处理器就不得不等待第二个处理器更新完成，并且完成更新传递时，才能执行更新。这种情况被称为高竞争(high contention)。如果处理器很少需要互相等待，那么这种情况就是低竞争(low contention)。</p>
<p>在这个循环中，counter的数据将在每个缓存中传递若干次。这就叫做乒乓缓存(cache ping-pong)，这种情况会对应用的性能有着重大的影响。当一个处理器因为等待缓存转移而停止运行时。</p>
<p>互斥量的竞争通常不同于原子操作的竞争，最简单的原因是，互斥量通常使用操作系统级别的序列化线程，而非处理器级别的。如果有足够的线程去执行任务，当有线程在等待互斥量时，操作系统会安排其他线程来执行任务，而处理器只会在其他线程运行在目标处理器上时，让该处理器停止工作。不过，对互斥量的竞争，将会影响这些线程的性能；毕竟，只能让一个线程在同一时间运行。</p>
<h3 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h3><p>处理器缓存通常不会用来处理在单个存储位置，但其会用来处理称为缓存行(cache lines)的内存块。内存块通常大小为32或64字节，实际大小需要由正在使用着的处理器模型来决定。因为硬件缓存进处理缓存行大小的内存块，较小的数据项就在同一内存行的相邻内存位置上。</p>
<p>每当线程访问0号数据项，并对其值进行更新时，缓存行的所有权就需要转移给执行该线程的处理器，这仅是为了让更新1号数据项的线程获取1号线程的所有权。缓存行是共享的(即使没有数据存在)，因此使用伪共享来称呼这种方式。这个问题的解决办法就是对数据进行构造，让同一线程访问的数据项存在临近的内存中(就像是放在同一缓存行中)，这样那些能被独立线程访问的数据将分布在相距很远的地方，并且可能是存储在不同的缓存行中。</p>
<h3 id="如何让数据紧凑？"><a href="#如何让数据紧凑？" class="headerlink" title="如何让数据紧凑？"></a>如何让数据紧凑？</h3><p>伪共享发生的原因：某个线程所要访问的数据过于接近另一线程的数据，另一个是与数据布局相关的陷阱会直接影响单线程的性能。问题在于数据过于接近：当数据能被单线程访问时，那么数据就已经在内存中展开，就像是分布在不同的缓存行上。</p>
<p>现在，对于单线程代码来说就很关键了，何至于此呢？原因就是任务切换(task switching)。如果系统中的线程数量要比核芯多，每个核上都要运行多个线程。这就会增加缓存的压力，为了避免伪共享，努力让不同线程访问不同缓存行。因此，当处理器切换线程的时候，就要对不同内存行上的数据进行重新加载，而非对缓存中的数据保持原样(当线程中的数据都在同一缓存行时)。</p>
<p>如果线程数量多于内核或处理器数量，操作系统可能也会选择将一个线程安排给这个核芯一段时间，之后再安排给另一个核芯一段时间。因此就需要将缓存行从一个内核上，转移到另一个内核上；这样的话，就需要转移很多缓存行，也就意味着要耗费很多时间。虽然，操作系统通常避免这样的情况发生，不过当其发生的时候，对性能就会有很大的影响。</p>
<h3 id="超额认购和频繁的任务切换"><a href="#超额认购和频繁的任务切换" class="headerlink" title="超额认购和频繁的任务切换"></a>超额认购和频繁的任务切换</h3><p>多线程系统中，通常线程的数量要多于处理的数量。不过，线程经常会花费时间来等待外部I/O完成，或被互斥量阻塞，或等待条件变量，等等；所以等待不是问题。应用使用额外的线程来完成有用的工作，而非让线程在处理器处以闲置状态时继续等待。</p>
<p>这也并非长久之计，如果有很多额外线程，就会有很多线程准备执行，而且数量远远大于可用处理器的数量，不过操作系统就会忙于在任务间切换，以确保每个任务都有时间运行。</p>
<p>如果只是简单的通过数据划分生成多个线程，那可以限定工作线程的数量。如果超额认购是对工作的天然划分而产生，那么不同的划分方式对这种问题就没有太多益处了。</p>
<p>其他因素也会影响多线程代码的性能。即使CPU类型和时钟周期相同，乒乓缓存的开销可以让程序在两个单核处理器和在一个双核处理器上，产生巨大的性能差，不过这只是那些对性能影响可见的因素。接下来，让我们看一下这些因素如何影响代码与数据结构的设计。</p>
<h2 id="为多线程性能设计数据结构"><a href="#为多线程性能设计数据结构" class="headerlink" title="为多线程性能设计数据结构"></a>为多线程性能设计数据结构</h2><p>为多线程性能而设计数据结构的时候，需要考虑竞争(contention)，伪共享(false sharing)和数据距离(data proximity)。这三个因素对于性能都有着重大的影响，并且你通常可以改善的是数据布局，或者将赋予其他线程的数据元素进行修改。首先，让我们来看一个轻松方案：线程间划分数组元素。</p>
<h3 id="为复杂操作划分数组元素"><a href="#为复杂操作划分数组元素" class="headerlink" title="为复杂操作划分数组元素"></a>为复杂操作划分数组元素</h3><p>线程间划分工作是有很多种方式的。假设矩阵的行或列数量大于处理器的数量，可以让每个线程计算出结果矩阵列上的元素，或是行上的元素，亦或计算一个子矩阵。</p>
<p>对于一个数组来说，访问连续的元素是最好的方式，因为这将会减少缓存的使用，并且降低伪共享的概率。如果要让每个线程处理几行，线程需要读取第一个矩阵中的每一个元素，并且读取第二个矩阵上的相关行上的数据。给定的两个矩阵是以行连续的方式存储，这就意味着当你访问第一个矩阵的第一行的前N个元素，然后是第二行的前N个元素，以此类推(N是列的数量)。其他线程会访问每行的的其他元素；很明显的，应该访问相邻的列，所以从行上读取的N个元素也是连续的，这将最大程度的降低伪共享的几率。</p>
<p>另一方面，当每个线程处理一组行，就需要读取第二个矩阵上的每一个数据，还要读取第一个矩阵中的相关行上的值，不过这里只需要对行上的值进行写入。因为矩阵是以行连续的方式存储，那么现在可以以N行的方式访问所有的元素。如果再次选择相邻行，这就意味着线程现在只能写入N行，这里就有不能被其他线程所访问的连续内存块。</p>
<p>第三个选择——将矩阵分成小矩阵块？这可以看作先对列进行划分，再对行进行划分。因此，划分列的时候，同样有伪共享的问题存在。如果你可以选择内存块所拥有行的数量，就可以有效的避免伪共享；将大矩阵划分为小块，对于读取来说是有好处的：就不再需要读取整个源矩阵了。这里，只需要读取目标矩形里面相关行列的值就可以了。具体的来看，考虑1,000行和1,000列的两个矩阵相乘。就会有1百万个元素。如果有100个处理器，这样就可以每次处理10行的数据，也就是10,000个元素。不过，为了计算10,000个元素，就需要对第二个矩阵中的全部内容进行访问(1百万个元素)，再加上10,000个相关行(第一个矩阵)上的元素，大概就要访问1,010,000个元素。另外，硬件能处理100x100的数据块(总共10,000个元素)，这就需要对第一个矩阵中的100行进行访问(100x1,000=100,000个元素)，还有第二个矩阵中的100列(另外100,000个)。这才只有200,000个元素，就需要五轮读取才能完成。如果这里读取的元素少一些，缓存缺失的情况就会少一些，对于性能来说就好一些。</p>
<p>因此，将矩阵分成小块或正方形的块，要比使用单线程来处理少量的列好的多。当然，可以根据源矩阵的大小和处理器的数量，在运行时对块的大小进行调整。和之前一样，当性能是很重要的指标，就需要对目标架构上的各项指标进行测量。</p>
<h3 id="其他数据结构中的数据访问模式"><a href="#其他数据结构中的数据访问模式" class="headerlink" title="其他数据结构中的数据访问模式"></a>其他数据结构中的数据访问模式</h3><p>根本上讲，同样的考虑适用于想要优化数据结构的数据访问模式，就像优化对数组的访问：</p>
<ul>
<li>尝试调整数据在线程间的分布，就能让同一线程中的数据紧密联系在一起。</li>
<li>尝试减少线程上所需的数据量。</li>
<li>尝试让不同线程访问不同的存储位置，以避免伪共享。</li>
</ul>
<p>假设你有一个简单的类，包含一些数据项和一个用于保护数据的互斥量(在多线程环境下)。如果互斥量和数据项在内存中很接近，对一个需要获取互斥量的线程来说是很理想的情况；需要的数据可能早已存入处理器的缓存中了，因为在之前为了对互斥量进行修改，已经加载了需要的数据。不过，这还有一个缺点：当其他线程尝试锁住互斥量时(第一个线程还没有是释放)，线程就能对对应的数据项进行访问。互斥锁是当做一个“读-改-写”原子操作实现的，对于相同位置的操作都需要先获取互斥量，如果互斥量已锁，那就会调用系统内核。这种“读-改-写”操作，可能会让数据存储在缓存中，让线程获取的互斥量变得毫无作用。从目前互斥量的发展来看，这并不是个问题；线程不会直到互斥量解锁，才接触互斥量。不过，当互斥量共享同一缓存行时，其中存储的是线程已使用的数据，这时拥有互斥量的线程将会遭受到性能打击，因为其他线程也在尝试锁住互斥量。</p>
<p>一种测试伪共享问题的方法是：对大量的数据块填充数据，让不同线程并发的进行访问。比如，你可以使用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">protected_data</span></span><br><span class="line">&#123;</span><br><span class="line">  std::mutex m;</span><br><span class="line">  <span class="type">char</span> padding[<span class="number">65536</span>];  <span class="comment">// 65536字节已经超过一个缓存行的数量级</span></span><br><span class="line">  my_data data_to_protect;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>用来测试互斥量竞争或<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">my_data</span></span><br><span class="line">&#123;</span><br><span class="line">  data_item1 d1;</span><br><span class="line">  data_item2 d2;</span><br><span class="line">  <span class="type">char</span> padding[<span class="number">65536</span>];</span><br><span class="line">&#125;;</span><br><span class="line">my_data some_array[<span class="number">256</span>];</span><br></pre></td></tr></table></figure></p>
<p>用来测试数组数据中的伪共享。如果这样能够提高性能，你就能知道伪共享在这里的确存在。</p>
<h2 id="设计并发代码的注意事项"><a href="#设计并发代码的注意事项" class="headerlink" title="设计并发代码的注意事项"></a>设计并发代码的注意事项</h2><p>虽然，非扩展性代码依旧可以正常工作——单线程应用就无法扩展——例如，异常安全是一个正确性问题。如果你的代码不是异常安全的，最终会破坏不变量，或是造成条件竞争，亦或是你的应用意外终止，因为某个操作会抛出异常。有了这个想法，我们就率先来看一下异常安全的问题。</p>
<h3 id="并行算法中的异常安全"><a href="#并行算法中的异常安全" class="headerlink" title="并行算法中的异常安全"></a>并行算法中的异常安全</h3><p>异常安全是衡量C++代码一个很重要的指标，并发代码也不例外。实际上，相较于串行算法，并行算法常会格外要求注意异常问题。当一个操作在串行算法中抛出一个异常，算法只需要考虑对其本身进行处理，以避免资源泄露和损坏不变量；这里可以允许异常传递给调用者，由调用者对异常进行处理。通过对比，在并行算法中很多操作要运行在独立的线程上。在这种情况下，异常就不再允许被传播，因为这将会使调用堆栈出现问题。如果一个函数在创建一个新线程后带着异常退出，那么这个应用将会终止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">accumulate_block</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator first,Iterator last,T&amp; result)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    result=std::<span class="built_in">accumulate</span>(first,last,result);  <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">parallel_accumulate</span><span class="params">(Iterator first,Iterator last,T init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> length=std::<span class="built_in">distance</span>(first,last);  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">if</span>(!length)</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> min_per_thread=<span class="number">25</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> max_threads=</span><br><span class="line">    (length+min_per_thread<span class="number">-1</span>)/min_per_thread;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hardware_threads=</span><br><span class="line">    std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> num_threads=</span><br><span class="line">    std::<span class="built_in">min</span>(hardware_threads!=<span class="number">0</span>?hardware_threads:<span class="number">2</span>,max_threads);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> block_size=length/num_threads;</span><br><span class="line">  <span class="function">std::vector&lt;T&gt; <span class="title">results</span><span class="params">(num_threads)</span></span>;  <span class="comment">// 3</span></span><br><span class="line">  <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(num_threads<span class="number">-1</span>)</span></span>;  <span class="comment">// 4</span></span><br><span class="line">  Iterator block_start=first;  <span class="comment">// 5</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;(num_threads<span class="number">-1</span>);++i)</span><br><span class="line">  &#123;</span><br><span class="line">    Iterator block_end=block_start;  <span class="comment">// 6</span></span><br><span class="line">    std::<span class="built_in">advance</span>(block_end,block_size);</span><br><span class="line">    threads[i]=std::<span class="built_in">thread</span>(  <span class="comment">// 7</span></span><br><span class="line">      <span class="built_in">accumulate_block</span>&lt;Iterator,T&gt;(),</span><br><span class="line">      block_start,block_end,std::<span class="built_in">ref</span>(results[i]));</span><br><span class="line">    block_start=block_end;  <span class="comment">// 8</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">accumulate_block</span>()(block_start,last,results[num_threads<span class="number">-1</span>]);  <span class="comment">// 9</span></span><br><span class="line">  std::for_each(threads.<span class="built_in">begin</span>(),threads.<span class="built_in">end</span>(),</span><br><span class="line">    std::<span class="built_in">mem_fn</span>(&amp;std::thread::join));</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(results.<span class="built_in">begin</span>(),results.<span class="built_in">end</span>(),init);  <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在让我们来看一下异常要在哪抛出：基本上就是在调用函数的地方抛出异常，或在用户定义类型上执行某个操作时可能抛出异常。</p>
<p>首先，需要调用distance②，其会对用户定义的迭代器类型进行操作。因为，这时还没有做任何事情，所以对于调用线程来说，所有事情都没问题。接下来，就需要分配results③和threads④。再后，调用线程依旧没有做任何事情，或产生新的线程，所以到这里也是没有问题的。当然，如果在构造threads抛出异常，那么对已经分配的results将会被清理，析构函数会帮你打理好一切。</p>
<p>跳过<code>block_start</code>⑤的初始化(因为也是安全的)，来到了产生新线程的循环⑥⑦⑧。当在⑦处创建了第一个线程，如果再抛出异常，就会出问题的；对于新的<code>std::thread</code>对象将会销毁，程序将调用<code>std::terminate</code>来中断程序的运行。使用<code>std::terminate</code>的地方，可不是什么好地方。</p>
<p><code>accumulate_block</code>⑨的调用就可能抛出异常，就会产生和上面类似的结果；线程对象将会被销毁，并且调用<code>std::terminate</code>。另一方面，最终调用<code>std::accumulate</code>⑩可能会抛出异常，不过处理起来没什么难度，因为所有的线程在这里已经汇聚回主线程了。</p>
<p>上面只是对于主线程来说的，不过还有很多地方会抛出异常：对于调用<code>accumulate_block</code>的新线程来说就会抛出异常①。没有任何catch块，所以这个异常不会被处理，并且当异常发生的时候会调用<code>std::terminater()</code>来终止应用的运行。</p>
<p>也许这里的异常问题并不明显，不过这段代码是非异常安全的。</p>
<p>如果你仔细的了解过新线程用来完成什么样的工作，要返回一个计算的结果的同时，允许代码产生异常。这可以将<code>std::packaged_task</code>和<code>std::future</code>相结合，来解决这个问题。如果使用<code>std::packaged_task</code>重新构造代码，代码可能会是如下模样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">accumulate_block</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator first,Iterator last)</span>  <span class="comment">// 1</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(first,last,<span class="built_in">T</span>());  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">parallel_accumulate</span><span class="params">(Iterator first,Iterator last,T init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> length=std::<span class="built_in">distance</span>(first,last);</span><br><span class="line">  <span class="keyword">if</span>(!length)</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> min_per_thread=<span class="number">25</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> max_threads=</span><br><span class="line">    (length+min_per_thread<span class="number">-1</span>)/min_per_thread;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hardware_threads=</span><br><span class="line">    std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> num_threads=</span><br><span class="line">    std::<span class="built_in">min</span>(hardware_threads!=<span class="number">0</span>?hardware_threads:<span class="number">2</span>,max_threads);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> block_size=length/num_threads;</span><br><span class="line">  std::vector&lt;std::future&lt;T&gt; &gt; <span class="built_in">futures</span>(num_threads<span class="number">-1</span>);  <span class="comment">// 3</span></span><br><span class="line">  <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(num_threads<span class="number">-1</span>)</span></span>;</span><br><span class="line">  Iterator block_start=first;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;(num_threads<span class="number">-1</span>);++i)</span><br><span class="line">  &#123;</span><br><span class="line">    Iterator block_end=block_start;</span><br><span class="line">    std::<span class="built_in">advance</span>(block_end,block_size);</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">T</span><span class="params">(Iterator,Iterator)</span>&gt; <span class="title">task</span><span class="params">(  <span class="comment">// 4</span></span></span></span><br><span class="line"><span class="params"><span class="function">      accumulate_block&lt;Iterator,T&gt;())</span></span>;</span><br><span class="line">    futures[i]=task.<span class="built_in">get_future</span>();  <span class="comment">// 5</span></span><br><span class="line">    threads[i]=std::<span class="built_in">thread</span>(std::<span class="built_in">move</span>(task),block_start,block_end);  <span class="comment">// 6</span></span><br><span class="line">    block_start=block_end;</span><br><span class="line">  &#125;</span><br><span class="line">  T last_result=<span class="built_in">accumulate_block</span>()(block_start,last);  <span class="comment">// 7</span></span><br><span class="line">  std::for_each(threads.<span class="built_in">begin</span>(),threads.<span class="built_in">end</span>(),</span><br><span class="line">    std::<span class="built_in">mem_fn</span>(&amp;std::thread::join));</span><br><span class="line">  T result=init;  <span class="comment">// 8</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;(num_threads<span class="number">-1</span>);++i)</span><br><span class="line">  &#123;</span><br><span class="line">    result+=futures[i].<span class="built_in">get</span>();  <span class="comment">// 9</span></span><br><span class="line">  &#125;</span><br><span class="line">  result += last_result;  <span class="comment">// 10</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个修改就是调用<code>accumulate_block</code>的操作现在就是直接将结果返回，而非使用引用将结果存储在某个地方①。使用<code>std::packaged_task</code>和<code>std::future</code>是线程安全的，所以你可以使用它们来对结果进行转移。当调用<code>std::accumulate</code>②时，需要你显示传入T的默认构造函数，而非复用result的值，不过这只是一个小改动。</p>
<p>下一个改动就是，不用向量来存储结果，而使用<code>futures</code>向量为每个新生线程存储<code>std::future&lt;T&gt;</code>③。在新线程生成循环中，首先要为<code>accumulate_block</code>创建一个任务④。<code>std::packaged_task&lt;T(Iterator,Iterator)&gt;</code>声明，需要操作的两个Iterators和一个想要获取的T。然后，从任务中获取future⑤，再将需要处理的数据块的开始和结束信息传入⑥，让新线程去执行这个任务。当任务执行时，future将会获取对应的结果，以及任何抛出的异常。</p>
<p>使用future，就不能获得到一组结果数组，所以需要将最终数据块的结果赋给一个变量进行保存⑦，而非对一个数组进行填槽。同样，因为需要从future中获取结果，使用简单的for循环，就要比使用<code>std::accumulate</code>好的多；循环从提供的初始值开始⑧，并且将每个future上的值进行累加⑨。如果相关任务抛出一个异常，那么异常就会被future捕捉到，并且使用<code>get()</code>的时候获取数据时，这个异常会再次抛出。最后，在返回结果给调用者之前，将最后一个数据块上的结果添加入结果中⑩。</p>
<p>这样，一个问题就已经解决：在工作线程上抛出的异常，可以在主线程上抛出。如果不止一个工作线程抛出异常，那么只有一个能在主线程中抛出，不过这不会有产生太大的问题。如果这个问题很重要，你可以使用类似<code>std::nested_exception</code>来对所有抛出的异常进行捕捉。</p>
<p>剩下的问题就是，当生成第一个新线程和当所有线程都汇入主线程时，抛出异常；这样会让线程产生泄露。最简单的方法就是捕获所有抛出的线程，汇入的线程依旧是<code>joinable()</code>的，并且会再次抛出异常：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;(num_threads<span class="number">-1</span>);++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ... as before</span></span><br><span class="line">  &#125;</span><br><span class="line">  T last_result=<span class="built_in">accumulate_block</span>()(block_start,last);</span><br><span class="line">  std::for_each(threads.<span class="built_in">begin</span>(),threads.<span class="built_in">end</span>(),</span><br><span class="line">  std::<span class="built_in">mem_fn</span>(&amp;std::thread::join));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;(num_thread<span class="number">-1</span>);++i)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span>(threads[i].<span class="built_in">joinable</span>())</span><br><span class="line">    thread[i].<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在好了，无论线程如何离开这段代码，所有线程都可以被汇入。不过，try-catch很不美观，并且这里有重复代码。可以将“正常”控制流上的线程在catch块上执行的线程进行汇入。重复代码是没有必要的，因为这就意味着更多的地方需要改变。不过，现在让我们来提取一个对象的析构函数；毕竟，析构函数是C++中处理资源的惯用方式。看一下你的类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">join_threads</span></span><br><span class="line">&#123;</span><br><span class="line">  std::vector&lt;std::thread&gt;&amp; threads;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">join_threads</span><span class="params">(std::vector&lt;std::thread&gt;&amp; threads_)</span>:</span></span><br><span class="line"><span class="function">    threads(threads_)</span></span><br><span class="line"><span class="function">  &#123;</span>&#125;</span><br><span class="line">  ~<span class="built_in">join_threads</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;threads.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(threads[i].<span class="built_in">joinable</span>())</span><br><span class="line">        threads[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当创建了线程容器，就对新类型创建了一个实例①，可让退出线程进行汇入。然后，可以再显式的汇入循环中将线程删除，在原理上来说是安全的：因为线程，无论怎么样退出，都需要汇入主线程。注意这里对<code>futures[i].get()</code>②的调用，将会阻塞线程，直到结果准备就绪，所以这里不需要显式的将线程进行汇入。和清单8.2中的原始代码不同：原始代码中，你需要将线程汇入，以确保results向量被正确填充。不仅需要异常安全的代码，还需要较短的函数实现，因为这里已经将汇入部分的代码放到新(可复用)类型中去了。</p>
<p>现在，你已经了解了，当需要显式管理线程的时候，需要代码是异常安全的。那现在让我们来看一下使用<code>std::async()</code>是怎么样完成异常安全的。在本例中，标准库对线程进行了较好的管理，并且当“期望”处以就绪状态的时候，就能生成一个新的线程。对于异常安全，还需要注意一件事，如果在没有等待的情况下对“期望”实例进行销毁，析构函数会等待对应线程执行完毕后才执行。这就能桥面的必过线程泄露的问题，因为线程还在执行，且持有数据的引用。下面的代码将展示使用<code>std::async()</code>完成异常安全的实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">parallel_accumulate</span><span class="params">(Iterator first,Iterator last,T init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> length=std::<span class="built_in">distance</span>(first,last);  <span class="comment">// 1</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> max_chunk_size=<span class="number">25</span>;</span><br><span class="line">  <span class="keyword">if</span>(length&lt;=max_chunk_size)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(first,last,init);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    Iterator mid_point=first;</span><br><span class="line">    std::<span class="built_in">advance</span>(mid_point,length/<span class="number">2</span>);  <span class="comment">// 3</span></span><br><span class="line">    std::future&lt;T&gt; first_half_result=</span><br><span class="line">      std::<span class="built_in">async</span>(parallel_accumulate&lt;Iterator,T&gt;,  <span class="comment">// 4</span></span><br><span class="line">        first,mid_point,init);</span><br><span class="line">    T second_half_result=<span class="built_in">parallel_accumulate</span>(mid_point,last,<span class="built_in">T</span>());  <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">return</span> first_half_result.<span class="built_in">get</span>()+second_half_result;  <span class="comment">// 6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个版本对数据进行递归划分，而非在预计算后对数据进行分块；因此，这个版本要比之前的版本简单很多，并且这个版本也是异常安全的。和之前一样，一开始要确定序列的长度①，如果其长度小于数据块包含数据的最大数量，那么可以直接调用std::accumulate②。如果元素的数量超出了数据块包含数据的最大数量，那么就需要找到数量中点③，将这个数据块分成两部分，然后再生成一个异步任务对另一半数据进行处理④。第二半的数据是通过直接的递归调用来处理的⑤，之后将两个块的结果加和到一起⑥。标准库能保证std::async的调用能够充分的利用硬件线程，并且不会产生线程的超额认购，一些“异步”调用是在调用get()⑥后同步执行的。</p>
<p>优雅的地方，不仅在于利用硬件并发的优势，并且还能保证异常安全。如果有异常在递归调用⑤中抛出，通过调用std::async④所产生的“期望”，将会在异常传播时被销毁。这就需要依次等待异步任务的完成，因此也能避免悬空线程的出现。另外，当异步任务抛出异常，且被future所捕获，在对get()⑥调用的时候，future中存储的异常，会再次抛出。</p>
<h2 id="在实践中设计并发代码"><a href="#在实践中设计并发代码" class="headerlink" title="在实践中设计并发代码"></a>在实践中设计并发代码</h2><h3 id="并行实现：std-for-each"><a href="#并行实现：std-for-each" class="headerlink" title="并行实现：std::for_each"></a>并行实现：std::for_each</h3><p><code>std::for_each</code>的原理很简单：其对某个范围中的元素，依次调用用户提供的函数。并行和串行调用的最大区别就是函数的调用顺序。<code>std::for_each</code>是对范围中的第一个元素调用用户函数，接着是第二个，以此类推，而在并行实现中对于每个元素的处理顺序就不能保证了，并且它们可能(我们希望如此)被并发的处理。</p>
<p>为了实现这个函数的并行版本，需要对每个线程上处理的元素进行划分。你事先知道元素数量，所以可以处理前对数据进行划分。假设只有并行任务运行，就可以使用<code>std::thread::hardware_concurrency()</code>来决定线程的数量。同样，这些元素都能被独立的处理，所以可以使用连续的数据块来避免伪共享。</p>
<p>这里的算法有点类似于并行版的<code>std::accumulate</code>，不过比起计算每一个元素的加和，这里对每个元素仅仅使用了一个指定功能的函数。因为不需要返回结果，可以假设这可能会对简化代码，不过想要将异常传递给调用者，就需要使用<code>std::packaged_task</code>和<code>std::future</code>机制对线程中的异常进行转移。这里展示一个样本实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_for_each</span><span class="params">(Iterator first,Iterator last,Func f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> length=std::<span class="built_in">distance</span>(first,last);</span><br><span class="line">    <span class="keyword">if</span>(!length)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> min_per_thread=<span class="number">25</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> max_threads=</span><br><span class="line">        (length+min_per_thread<span class="number">-1</span>)/min_per_thread;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hardware_threads=</span><br><span class="line">        std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> num_threads=</span><br><span class="line">        std::<span class="built_in">min</span>(hardware_threads!=<span class="number">0</span>?hardware_threads:<span class="number">2</span>,max_threads);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> block_size=length/num_threads;</span><br><span class="line">    std::vector&lt;std::future&lt;<span class="type">void</span>&gt; &gt; <span class="built_in">futures</span>(num_threads<span class="number">-1</span>);    <span class="comment">// 1</span></span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(num_threads<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="function">join_threads <span class="title">joiner</span><span class="params">(threads)</span></span>;</span><br><span class="line">    Iterator block_start=first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;(num_threads<span class="number">-1</span>);++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Iterator block_end=block_start;</span><br><span class="line">        std::<span class="built_in">advance</span>(block_end,block_size);</span><br><span class="line">        <span class="function">std::packaged_task&lt;<span class="title">void</span><span class="params">(<span class="type">void</span>)</span>&gt; <span class="title">task</span><span class="params">(    <span class="comment">// 2</span></span></span></span><br><span class="line"><span class="params"><span class="function">            [=]()</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::for_each(block_start,block_end,f);</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;)</span></span>;</span><br><span class="line">        futures[i]=task.<span class="built_in">get_future</span>();</span><br><span class="line">        threads[i]=std::<span class="built_in">thread</span>(std::<span class="built_in">move</span>(task));    <span class="comment">// 3</span></span><br><span class="line">        block_start=block_end;</span><br><span class="line">    &#125;</span><br><span class="line">    std::for_each(block_start,last,f);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;(num_threads<span class="number">-1</span>);++i)</span><br><span class="line">    &#123;</span><br><span class="line">        futures[i].<span class="built_in">get</span>();  <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最重要的不同在于<code>futures</code>向量对<code>std::future&lt;void&gt;</code>类型①变量进行存储，因为工作线程不会返回值，并且简单的lambda函数会对block_start到block_end上的任务②执行f函数。这是为了避免传入线程的构造函数③。当工作线程不需要返回一个值时，调用<code>futures[i].get()</code>④只是提供检索工作线程异常的方法；如果不想把异常传递出去，就可以省略这一步。</p>
<p>实现并行<code>std::accumulate</code>的时候，使用<code>std::async</code>会简化代码；同样，<code>parallel_for_each</code>也可以使用<code>std::async</code>。实现如下所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_for_each</span><span class="params">(Iterator first,Iterator last,Func f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> length=std::<span class="built_in">distance</span>(first,last);</span><br><span class="line">  <span class="keyword">if</span>(!length)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> min_per_thread=<span class="number">25</span>;</span><br><span class="line">  <span class="keyword">if</span>(length&lt;(<span class="number">2</span>*min_per_thread))</span><br><span class="line">  &#123;</span><br><span class="line">    std::for_each(first,last,f);  <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    Iterator <span class="type">const</span> mid_point=first+length/<span class="number">2</span>;</span><br><span class="line">    std::future&lt;<span class="type">void</span>&gt; first_half=  <span class="comment">// 2</span></span><br><span class="line">      std::<span class="built_in">async</span>(&amp;parallel_for_each&lt;Iterator,Func&gt;,</span><br><span class="line">                 first,mid_point,f);</span><br><span class="line">    <span class="built_in">parallel_for_each</span>(mid_point,last,f);  <span class="comment">// 3</span></span><br><span class="line">    first_half.<span class="built_in">get</span>();  <span class="comment">// 4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和基于<code>std::async</code>的<code>parallel_accumulate</code>一样，是在运行时对数据进行迭代划分的，而非在执行前划分好，这是因为你不知道你的库需要使用多少个线程。像之前一样，当你将每一级的数据分成两部分，异步执行另外一部分②，剩下的部分就不能再进行划分了，所以直接运行这一部分③；这样就可以直接对<code>std::for_each</code>①进行使用了。这里再次使用<code>std::async</code>和<code>std::future</code>的<code>get()</code>成员函数④来提供对异常的传播。</p>
<h3 id="并行实现：std-find"><a href="#并行实现：std-find" class="headerlink" title="并行实现：std::find"></a>并行实现：std::find</h3><p>接下来是std::find算法，因为这是一种不需要对数据元素做任何处理的算法。比如，当第一个元素就满足查找标准，那就没有必要对其他元素进行搜索了。将会看到，算法属性对于性能具有很大的影响，并且对并行实现的设计有着直接的影响。这个算法是一个很特别的例子，数据访问模式都会对代码的设计产生影响。该类中的另一些算法包括<code>std::equal</code>和<code>std::any_of</code>。</p>
<p>如果不中断其他线程，那么串行版本的性能可能会超越并行版，因为串行算法可以在找到匹配元素的时候，停止搜索并返回。如果系统能支持四个并发线程，那么每个线程就可以对总数据量的1/4进行检查，并且在我们的实现只需要单核完成的1/4的时间，就能完成对所有元素的查找。如果匹配的元素在第一个1/4块中，串行算法将会返回第一个，因为算法不需要对剩下的元素进行处理了。</p>
<p>一种办法，中断其他线程的一个办法就是使用一个原子变量作为一个标识，在处理过每一个元素后就对这个标识进行检查。如果标识被设置，那么就有线程找到了匹配元素，所以算法就可以停止并返回了。用这种方式来中断线程，就可以将那些没有处理的数据保持原样，并且在更多的情况下，相较于串行方式，性能能提升很多。缺点就是，加载原子变量是一个很慢的操作，会阻碍每个线程的运行。</p>
<p>如何返回值和传播异常呢？现在你有两个选择。你可以使用一个future数组，使用<code>std::packaged_task</code>来转移值和异常，在主线程上对返回值和异常进行处理；或者使用<code>std::promise</code>对工作线程上的最终结果直接进行设置。这完全依赖于你想怎么样处理工作线程上的异常。如果想停止第一个异常(即使还没有对所有元素进行处理)，就可以使用<code>std::promise</code>对异常和最终值进行设置。另外，如果想要让其他工作线程继续查找，可以使用<code>std::packaged_task</code>来存储所有的异常，当线程没有找到匹配元素时，异常将再次抛出。</p>
<p>这种情况下，我会选择<code>std::promise</code>，因为其行为和<code>std::find</code>更为接近。这里需要注意一下搜索的元素是不是在提供的搜索范围内。因此，在所有线程结束前，获取future上的结果。如果被future阻塞住，所要查找的值不在范围内，就会持续的等待下去。实现代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> MatchType&gt;</span></span><br><span class="line"><span class="function">Iterator <span class="title">parallel_find</span><span class="params">(Iterator first,Iterator last,MatchType match)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">find_element</span>  <span class="comment">// 1</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator begin,Iterator end,</span></span></span><br><span class="line"><span class="params"><span class="function">                    MatchType match,</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::promise&lt;Iterator&gt;* result,</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::atomic&lt;<span class="type">bool</span>&gt;* done_flag)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">for</span>(;(begin!=end) &amp;&amp; !done_flag-&gt;<span class="built_in">load</span>();++begin)  <span class="comment">// 2</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span>(*begin==match)</span><br><span class="line">          &#123;</span><br><span class="line">            result-&gt;<span class="built_in">set_value</span>(begin);  <span class="comment">// 3</span></span><br><span class="line">            done_flag-&gt;<span class="built_in">store</span>(<span class="literal">true</span>);  <span class="comment">// 4</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">catch</span>(...)  <span class="comment">// 5</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">          result-&gt;<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());  <span class="comment">// 6</span></span><br><span class="line">          done_flag-&gt;<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span>(...)  <span class="comment">// 7</span></span><br><span class="line">        &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> length=std::<span class="built_in">distance</span>(first,last);</span><br><span class="line">  <span class="keyword">if</span>(!length)</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> min_per_thread=<span class="number">25</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> max_threads=</span><br><span class="line">    (length+min_per_thread<span class="number">-1</span>)/min_per_thread;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hardware_threads=</span><br><span class="line">    std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> num_threads=</span><br><span class="line">    std::<span class="built_in">min</span>(hardware_threads!=<span class="number">0</span>?hardware_threads:<span class="number">2</span>,max_threads);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> block_size=length/num_threads;</span><br><span class="line">  std::promise&lt;Iterator&gt; result;  <span class="comment">// 8</span></span><br><span class="line">  <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">done_flag</span><span class="params">(<span class="literal">false</span>)</span></span>;  <span class="comment">// 9</span></span><br><span class="line">  <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(num_threads<span class="number">-1</span>)</span></span>;</span><br><span class="line">  &#123;  <span class="comment">// 10</span></span><br><span class="line">    <span class="function">join_threads <span class="title">joiner</span><span class="params">(threads)</span></span>;</span><br><span class="line">    Iterator block_start=first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;(num_threads<span class="number">-1</span>);++i)</span><br><span class="line">    &#123;</span><br><span class="line">      Iterator block_end=block_start;</span><br><span class="line">      std::<span class="built_in">advance</span>(block_end,block_size);</span><br><span class="line">      threads[i]=std::<span class="built_in">thread</span>(<span class="built_in">find_element</span>(),  <span class="comment">// 11</span></span><br><span class="line">                             block_start,block_end,match,</span><br><span class="line">                             &amp;result,&amp;done_flag);</span><br><span class="line">      block_start=block_end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">find_element</span>()(block_start,last,match,&amp;result,&amp;done_flag);  <span class="comment">// 12</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!done_flag.<span class="built_in">load</span>())  <span class="comment">//13</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.<span class="built_in">get_future</span>().<span class="built_in">get</span>();  <span class="comment">// 14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数主体与之前的例子相似。这次，由<code>find_element</code>类①的函数调用操作实现，来完成查找工作的。循环通过在给定数据块中的元素，检查每一步上的标识②。如果匹配的元素被找到，就将最终的结果设置到promise③当中，并且在返回前对done_flag④进行设置。</p>
<p>如果有一个异常被抛出，那么它就会被通用处理代码⑤捕获，并且在promise⑥尝中试存储前，对done_flag进行设置。如果对应promise已经被设置，设置在promise上的值可能会抛出一个异常，所以这里⑦发生的任何异常，都可以捕获并丢弃。</p>
<p>这意味着，当线程调用find_element查询一个值，或者抛出一个异常时，如果其他线程看到done_flag被设置，那么其他线程将会终止。如果多线程同时找到匹配值或抛出异常，它们将会对promise产生竞争。不过，这是良性的条件竞争；因为，成功的竞争者会作为“第一个”返回线程，因此这个结果可以接受。</p>
<p>回到parallel_find函数本身，其拥有用来停止搜索的promise⑧和标识⑨；随着对范围内的元素的查找⑪，promise和标识会传递到新线程中。主线程也使用find_element来对剩下的元素进行查找⑫。像之前提到的，需要在全部线程结束前，对结果进行检查，因为结果可能是任意位置上的匹配元素。这里将“启动-汇入”代码放在一个块中⑩，所以所有线程都会在找到匹配元素时⑬进行汇入。如果找到匹配元素，就可以调用<code>std::future&lt;Iterator&gt;</code>的成员函数get()来获取返回值或异常。</p>
<p>不过，这里假设你会使用硬件上所有可用的的并发线程，或使用其他机制对线程上的任务进行提前划分。就像之前一样，可以使用<code>std::async</code>，以及递归数据划分的方式来简化实现(同时使用C++标准库中提供的自动缩放工具)。使用<code>std::async</code>的<code>parallel_find</code>实现如下所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> MatchType&gt;  <span class="comment">// 1</span></span><br><span class="line"><span class="function">Iterator <span class="title">parallel_find_impl</span><span class="params">(Iterator first,Iterator last,MatchType match,</span></span></span><br><span class="line"><span class="params"><span class="function">                            std::atomic&lt;<span class="type">bool</span>&gt;&amp; done)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> length=std::<span class="built_in">distance</span>(first,last);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> min_per_thread=<span class="number">25</span>;  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span>(length&lt;(<span class="number">2</span>*min_per_thread))  <span class="comment">// 3</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span>(;(first!=last) &amp;&amp; !done.<span class="built_in">load</span>();++first)  <span class="comment">// 4</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span>(*first==match)</span><br><span class="line">        &#123;</span><br><span class="line">          done=<span class="literal">true</span>;  <span class="comment">// 5</span></span><br><span class="line">          <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> last;  <span class="comment">// 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; </span><br><span class="line">      Iterator <span class="type">const</span> mid_point=first+(length/<span class="number">2</span>);  <span class="comment">// 7</span></span><br><span class="line">      std::future&lt;Iterator&gt; async_result=</span><br><span class="line">        std::<span class="built_in">async</span>(&amp;parallel_find_impl&lt;Iterator,MatchType&gt;,  <span class="comment">// 8</span></span><br><span class="line">                   mid_point,last,match,std::<span class="built_in">ref</span>(done));</span><br><span class="line">      Iterator <span class="type">const</span> direct_result=</span><br><span class="line">        <span class="built_in">parallel_find_impl</span>(first,mid_point,match,done);  <span class="comment">// 9</span></span><br><span class="line">      <span class="keyword">return</span> (direct_result==mid_point)?</span><br><span class="line">        async_result.<span class="built_in">get</span>():direct_result;  <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(...)</span><br><span class="line">  &#123;</span><br><span class="line">    done=<span class="literal">true</span>;  <span class="comment">// 11</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> MatchType&gt;</span></span><br><span class="line"><span class="function">Iterator <span class="title">parallel_find</span><span class="params">(Iterator first,Iterator last,MatchType match)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">done</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parallel_find_impl</span>(first,last,match,done);  <span class="comment">// 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要在找到匹配项时结束，就需要在线程之间设置一个标识来表明匹配项已经被找到。因此，需要将这个标识递归的传递。通过函数①的方式来实现是最简单的办法，只需要增加一个参数——一个done标识的引用，这个表示通过程序的主入口点传入⑫。</p>
<p>核心实现和之前的代码一样。通常函数的实现中，会让单个线程处理最少的数据项②；如果数据块大小不足于分成两半，就要让当前线程完成所有的工作了③。实际算法在一个简单的循环当中(给定范围)，直到在循环到指定范围中的最后一个，或找到匹配项，并对标识进行设置④。如果找到匹配项，标识done就会在返回前进行设置⑤。无论是因为已经查找到最后一个，还是因为其他线程对done进行了设置，都会停止查找。如果没有找到，会将最后一个元素last进行返回⑥。</p>
<p>如果给定范围可以进行划分，首先要在<code>std::async</code>在对第二部分进行查找⑧前，要找数据中点⑦，而且需要使用<code>std::ref</code>将done以引用的方式传递。同时，可以通过对第一部分直接进行递归查找。两部分都是异步的，并且在原始范围过大时，直接递归查找的部分可能会再细化。</p>
<p>如果直接查找返回的是mid_point，这就意味着没有找到匹配项，所以就要从异步查找中获取结果。如果在另一半中没有匹配项的话，返回的结果就一定是last，这个值的返回就代表了没有找到匹配的元素⑩。如果“异步”调用被延迟(非真正的异步)，那么实际上这里会运行get()；这种情况下，如果对下半部分的元素搜索成功，那么就不会执行对上半部分元素的搜索了。如果异步查找真实的运行在其他线程上，那么async_result变量的析构函数将会等待该线程完成，所以这里不会有线程泄露。</p>
<p>像之前一样，<code>std::async</code>可以用来提供“异常-安全”和“异常-传播”特性。如果直接递归抛出异常，future的析构函数就能让异步执行的线程提前结束；如果异步调用抛出异常，那么这个异常将会通过对get()成员函数的调用进行传播⑩。使用try/catch块只能捕捉在done发生的异常，并且当有异常抛出⑪时，所有线程都能很快的终止运行。不过，不使用try/catch的实现依旧没问题，不同的就是要等待所有线程的工作是否完成。</p>
<p>实现中一个重要的特性就是，不能保证所有数据都能被std::find串行处理。其他并行算法可以借鉴这个特性，因为要让一个算法并行起来这是必须具有的特性。如果有顺序问题，元素就不能并发的处理了。如果每个元素独立，虽然对于parallel_for_each不是很重要，不过对于parallel_find，即使在开始部分已经找到了匹配元素，也有可能返回范围中最后一个元素；如果在知道结果的前提下，这样的结果会让人很惊讶。</p>
<h3 id="并行实现：std-partial-sum"><a href="#并行实现：std-partial-sum" class="headerlink" title="并行实现：std::partial_sum"></a>并行实现：std::partial_sum</h3><p><code>std::partial_sum</code>会计算给定范围中的每个元素，并用计算后的结果将原始序列中的值替换掉。比如，有一个序列[1，2，3，4，5]，在执行该算法后会成为：[1，3(1+2)，6(1+2+3)，10(1+2+3+4)，15(1+2+3+4+5)]。让这样一个算法并行起来会很有趣，因为这里不能讲任务分块，对每一块进行独立的计算。比如，原始序列中的第一个元素需要加到后面的一个元素中去。</p>
<p>将原始数据分割成块，加上之前块的部分和就能够并行了。如果每个块中的末尾元素都是第一个被更新的，那么块中其他的元素就能被其他线程所更新，同时另一个线程对下一块进行更新，等等。当处理的元素比处理核心的个数多的时候，这样完成工作没问题，因为每一个核芯在每一个阶段都有合适的数据可以进行处理。</p>
<p>比起将数据块中的最后一个元素的结果向后面的元素块传递，可以对部分结果进行传播：第一次与相邻的元素(距离为1)相加和(和之前一样)，之后和距离为2的元素相加，在后来和距离为4的元素相加，以此类推。比如，初始序列为[1，2，3，4，5，6，7，8，9]，第一次后为[1，3，5，7，9，11，13，15，17]，第二次后为[1，3，6，10，14，18, 22，26，30]，下一次就要隔4个元素了。第三次后[1, 3, 6, 10, 15, 21, 28, 36, 44]，下一次就要隔8个元素了。第四次后[1, 3, 6, 10, 15, 21, 28, 36, 45]，这就是最终的结果。虽然，比起第一种方法多了很多步骤，不过在可并发平台下，这种方法提高了并行的可行性；每个处理器可在每一步中处理一个数据项。</p>
<p>总体来说，当有N个操作时(每步使用一个处理器)第二种方法需要<code>log(N)</code>步；在本节中，N就相当于数据链表的长度。比起第一种，每个线程对分配块做N/k个操作，然后在做N/k次结果传递(这里的k是线程的数量)。因此，第一种方法的时间复杂度为O(N)，不过第二种方法的时间复杂度为Q(Nlog(N))。当数据量和处理器数量相近时，第二种方法需要每个处理器上log(N)个操作，第一种方法中每个处理器上执行的操作数会随着k的增加而增多，因为需要对结果进行传递。对于处理单元较少的情况，第一种方法会比较合适；对于大规模并行系统，第二种方法比较合适。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_partial_sum</span><span class="params">(Iterator first,Iterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type value_type;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">process_chunk</span>  <span class="comment">// 1</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator begin,Iterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::future&lt;value_type&gt;* previous_end_value,</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::promise&lt;value_type&gt;* end_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">        Iterator end=last;</span><br><span class="line">        ++end;</span><br><span class="line">        std::<span class="built_in">partial_sum</span>(begin,end,begin);  <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span>(previous_end_value)  <span class="comment">// 3</span></span><br><span class="line">        &#123;</span><br><span class="line">          value_type&amp; addend=previous_end_value-&gt;<span class="built_in">get</span>();  <span class="comment">// 4</span></span><br><span class="line">          *last+=addend;  <span class="comment">// 5</span></span><br><span class="line">          <span class="keyword">if</span>(end_value)</span><br><span class="line">          &#123;</span><br><span class="line">            end_value-&gt;<span class="built_in">set_value</span>(*last);  <span class="comment">// 6</span></span><br><span class="line">          &#125;</span><br><span class="line">          std::for_each(begin,last,[addend](value_type&amp; item)  <span class="comment">// 7</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          item+=addend;</span><br><span class="line">                        &#125;);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(end_value)</span><br><span class="line">         &#123;</span><br><span class="line">           end_value-&gt;<span class="built_in">set_value</span>(*last);  <span class="comment">// 8</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">catch</span>(...)  <span class="comment">// 9</span></span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span>(end_value)</span><br><span class="line">         &#123;</span><br><span class="line">           end_value-&gt;<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());  <span class="comment">// 10</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">           <span class="keyword">throw</span>;  <span class="comment">// 11</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> length=std::<span class="built_in">distance</span>(first,last);</span><br><span class="line">  <span class="keyword">if</span>(!length)</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> min_per_thread=<span class="number">25</span>;  <span class="comment">// 12</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> max_threads=</span><br><span class="line">    (length+min_per_thread<span class="number">-1</span>)/min_per_thread;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hardware_threads=</span><br><span class="line">    std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> num_threads=</span><br><span class="line">    std::<span class="built_in">min</span>(hardware_threads!=<span class="number">0</span>?hardware_threads:<span class="number">2</span>,max_threads);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> block_size=length/num_threads;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type value_type;</span><br><span class="line">  <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(num_threads<span class="number">-1</span>)</span></span>;  <span class="comment">// 13</span></span><br><span class="line">  std::vector&lt;std::promise&lt;value_type&gt; &gt;</span><br><span class="line">    <span class="built_in">end_values</span>(num_threads<span class="number">-1</span>);  <span class="comment">// 14</span></span><br><span class="line">  std::vector&lt;std::future&lt;value_type&gt; &gt;</span><br><span class="line">    previous_end_values;  <span class="comment">// 15</span></span><br><span class="line">  previous_end_values.<span class="built_in">reserve</span>(num_threads<span class="number">-1</span>);  <span class="comment">// 16</span></span><br><span class="line">  <span class="function">join_threads <span class="title">joiner</span><span class="params">(threads)</span></span>;</span><br><span class="line">  Iterator block_start=first;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;(num_threads<span class="number">-1</span>);++i)</span><br><span class="line">  &#123;</span><br><span class="line">    Iterator block_last=block_start;</span><br><span class="line">    std::<span class="built_in">advance</span>(block_last,block_size<span class="number">-1</span>);  <span class="comment">// 17</span></span><br><span class="line">    threads[i]=std::<span class="built_in">thread</span>(<span class="built_in">process_chunk</span>(),  <span class="comment">// 18</span></span><br><span class="line">                           block_start,block_last,</span><br><span class="line">                           (i!=<span class="number">0</span>)?&amp;previous_end_values[i<span class="number">-1</span>]:<span class="number">0</span>,</span><br><span class="line">                           &amp;end_values[i]);</span><br><span class="line">    block_start=block_last;</span><br><span class="line">    ++block_start;  <span class="comment">// 19</span></span><br><span class="line">    previous_end_values.<span class="built_in">push_back</span>(end_values[i].<span class="built_in">get_future</span>());  <span class="comment">// 20</span></span><br><span class="line">  &#125;</span><br><span class="line">  Iterator final_element=block_start;</span><br><span class="line">  std::<span class="built_in">advance</span>(final_element,std::<span class="built_in">distance</span>(block_start,last)<span class="number">-1</span>);  <span class="comment">// 21</span></span><br><span class="line">  <span class="built_in">process_chunk</span>()(block_start,final_element,  <span class="comment">// 22</span></span><br><span class="line">                  (num_threads&gt;<span class="number">1</span>)?&amp;previous_end_values.<span class="built_in">back</span>():<span class="number">0</span>,</span><br><span class="line">                  <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个实现中，使用的结构体和之前算法中的一样，将问题进行分块解决，每个线程处理最小的数据块⑫。其中，有一组线程⑬和一组promise⑭，用来存储每块中的最后一个值；并且实现中还有一组future⑮，用来对前一块中的最后一个值进行检索。可以为future⑯做些储备，以避免生成新线程时，再分配内存。</p>
<p>主循环和之前一样，不过这次是让迭代器指向了每个数据块的最后一个元素，而不是作为一个普通值传递到最后⑰，这样就方便向其他块传递当前块的最后一个元素了。实际处理是在<code>process_chunk</code>函数对象中完成的，这个结构体看上去不是很长；当前块的开始和结束迭代器和前块中最后一个值的future一起，作为参数进行传递，并且promise用来保留当前范围内最后一个值的原始值⑱。</p>
<p>生成新的线程后，就对开始块的ID进行更新，别忘了传递最后一个元素⑲，并且将当前块的最后一个元素存储到future，上面的数据将在循环中再次使用到⑳。</p>
<p>在处理最后一个数据块前，需要获取之前数据块中最后一个元素的迭代器(21)，这样就可以将其作为参数传入process_chunk(22)中了。<code>std::partial_sum</code>不会返回一个值，所以在最后一个数据块被处理后，就不用再做任何事情了。当所有线程的操作完成时，求部分和的操作也就算完成了。</p>
<p>OK，现在来看一下<code>process_chunk</code>函数对象①。对于整块的处理是始于对<code>std::partial_sum</code>的调用，包括对于最后一个值的处理②，不过得要知道当前块是否是第一块③。如果当前块不是第一块，就会有一个<code>previous_end_value</code>值从前面的块传过来，所以这里需要等待这个值的产生④。为了将算法最大程度的并行，首先需要对最后一个元素进行更新⑤，这样你就能将这个值传递给下一个数据块(如果有下一个数据块的话)⑥。当完成这个操作，就可以使用<code>std::for_each</code>和简单的lambda函数⑦对剩余的数据项进行更新。</p>
<p>如果<code>previous_end_value</code>值为空，当前数据块就是第一个数据块，所以只需要为下一个数据块更新end_value⑧(如果有下一个数据块的话——当前数据块可能是唯一的数据块)。</p>
<p>最后，如果有任意一个操作抛出异常，就可以将其捕获⑨，并且存入promise⑩，如果下一个数据块尝试获取前一个数据块的最后一个值④时，异常会再次抛出。处理最后一个数据块时，异常会全部重新抛出⑪，因为抛出动作一定会在主线程上进行。</p>
<p>因为线程间需要同步，这里的代码就不容易使用<code>std::async</code>重写。任务等待会让线程中途去执行其他的任务，所以所有的任务必须同时执行。</p>
<p>基于块，以传递末尾元素值的方法就介绍到这里，让我们来看一下第二种计算方式。</p>
<p>实现以2的幂级数为距离部分和算法</p>
<p>第二种算法通过增加距离的方式，让更多的处理器充分发挥作用。在这种情况下，没有进一步同步的必要了，因为所有中间结果都直接传递到下一个处理器上去了。不过，在实际中我们很少见到，单个处理器处理对一定数量的元素执行同一条指令，这种方式成为单指令-多数据流(SIMD)。因此，代码必须能处理通用情况，并且需要在每步上对线程进行显式同步。</p>
<p>完成这种功能的一种方式是使用栅栏(barrier)——一种同步机制：只有所有线程都到达栅栏处，才能进行之后的操作；先到达的线程必须等待未到达的线程。C++11标准库没有直接提供这样的工具，所以你得自行设计一个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">barrier</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">const</span> count;</span><br><span class="line">  std::atomic&lt;<span class="type">unsigned</span>&gt; spaces;</span><br><span class="line">  std::atomic&lt;<span class="type">unsigned</span>&gt; generation;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">barrier</span><span class="params">(<span class="type">unsigned</span> count_)</span>:  // <span class="number">1</span></span></span><br><span class="line"><span class="function">    count(count_),spaces(count),generation(<span class="number">0</span>)</span></span><br><span class="line"><span class="function">  &#123;</span>&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">const</span> my_generation=generation;  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span>(!--spaces)  <span class="comment">// 3</span></span><br><span class="line">    &#123;</span><br><span class="line">      spaces=count;  <span class="comment">// 4</span></span><br><span class="line">      ++generation;  <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span>(generation==my_generation)  <span class="comment">// 6</span></span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>();  <span class="comment">// 7</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个实现中，用一定数量的“座位”构造了一个barrier①，这个数量将会存储count变量中。起初，栅栏中的spaces与count数量相当。当有线程都在等待时，spaces的数量就会减少③。当spaces的数量减到0时，spaces的值将会重置为count④，并且generation变量会增加，以向线程发出信号，让这些等待线程能够继续运行⑤。如果spaces没有到达0，那么线程会继续等待。这个实现使用了一个简单的自旋锁⑥，对generation的检查会在wait()开始的时候进行②。因为generation只会在所有线程都到达栅栏的时候更新⑤，在等待的时候使用<code>yield()</code>⑦就不会让CPU处于忙等待的状态。</p>
<p>这个实现比较“简单”的真实意义：使用自旋等待的情况下，如果让线程等待很长时间就不会很理想，并且如果超过count数量的线程对<code>wait()</code>进行调用，这个实现就没有办法工作了。如果想要很好的处理这样的情况，必须使用一个更加健壮(更加复杂)的实现。我依旧坚持对原子变量操作顺序的一致性，因为这会让事情更加简单，不过有时还是需要放松这样的约束。全局同步对于大规模并行架构来说是消耗巨大的，因为相关处理器会穿梭于存储栅栏状态的缓存行中，所以需要格外的小心，来确保使用的是最佳同步方法。</p>
<p>不论怎么样，这些都需要你考虑到；需要有固定数量的线程执行同步循环。好吧，大多数情况下线程数量都是固定的。你可能还记得，代码起始部分的几个数据项，只需要几步就能得到其最终值。这就意味着，无论是让所有线程循环处理范围内的所有元素，还是让栅栏来同步线程，都会递减count的值。我会选择后者，因为其能避免线程做不必要的工作，仅仅是等待最终步骤完成。</p>
<p>这意味着你要将count改为一个原子变量，这样在多线程对其进行更新的时候，就不需要添加额外的同步：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">unsigned</span>&gt; count;</span><br></pre></td></tr></table></figure></p>
<p>初始化保持不变，不过当spaces的值被重置后，你需要显式的对count进行load()操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spaces=count.<span class="built_in">load</span>();</span><br></pre></td></tr></table></figure></p>
<p>这就是要对<code>wait()</code>函数的改动；现在需要一个新的成员函数来递减count。这个函数命名为done_waiting()，因为当一个线程完成其工作，并在等待的时候，才能对其进行调用它：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">done_waiting</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  --count;  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">if</span>(!--spaces)  <span class="comment">// 2</span></span><br><span class="line">  &#123;</span><br><span class="line">    spaces=count.<span class="built_in">load</span>();  <span class="comment">// 3</span></span><br><span class="line">    ++generation;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现中，首先要减少count①，所以下一次spaces将会被重置为一个较小的数。然后，需要递减spaces的值②。如果不做这些操作，有些线程将会持续等待，因为spaces被旧的count初始化，大于期望值。一组当中最后一个线程需要对计数器进行重置，并且递增generation的值③，就像在<code>wait()</code>里面做的那样。最重要的区别：最后一个线程不需要等待。当最后一个线程结束，整个等待也就随之结束！</p>
<p>现在就准备开始写部分和的第二个实现吧。在每一步中，每一个线程都在栅栏出调用<code>wait()</code>，来保证线程所处步骤一致，并且当所有线程都结束，那么最后一个线程会调用<code>done_waiting()</code>来减少count的值。如果使用两个缓存对原始数据进行保存，栅栏也可以提供你所需要的同步。每一步中，线程都会从原始数据或是缓存中读取数据，并且将新值写入对应位置。如果有线程先从原始数据处获取数据，那下一步就从缓存上获取数据(或相反)。这就能保证在读与写都是由独立线程完成，并不存在条件竞争。当线程结束等待循环，就能保证正确的值最终被写入到原始数据当中。下面的代码就是这样的实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">barrier</span></span><br><span class="line">&#123;</span><br><span class="line">  std::atomic&lt;<span class="type">unsigned</span>&gt; count;</span><br><span class="line">  std::atomic&lt;<span class="type">unsigned</span>&gt; spaces;</span><br><span class="line">  std::atomic&lt;<span class="type">unsigned</span>&gt; generation;</span><br><span class="line">  <span class="built_in">barrier</span>(<span class="type">unsigned</span> count_):</span><br><span class="line">    <span class="built_in">count</span>(count_),<span class="built_in">spaces</span>(count_),<span class="built_in">generation</span>(<span class="number">0</span>)</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">const</span> gen=generation.<span class="built_in">load</span>();</span><br><span class="line">    <span class="keyword">if</span>(!--spaces)</span><br><span class="line">    &#123;</span><br><span class="line">      spaces=count.<span class="built_in">load</span>();</span><br><span class="line">      ++generation;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span>(generation.<span class="built_in">load</span>()==gen)</span><br><span class="line">      &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">done_waiting</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    --count;</span><br><span class="line">    <span class="keyword">if</span>(!--spaces)</span><br><span class="line">    &#123;</span><br><span class="line">      spaces=count.<span class="built_in">load</span>();</span><br><span class="line">      ++generation;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_partial_sum</span><span class="params">(Iterator first,Iterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type value_type;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">process_element</span>  <span class="comment">// 1</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator first,Iterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::vector&lt;value_type&gt;&amp; buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">unsigned</span> i,barrier&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      value_type&amp; ith_element=*(first+i);</span><br><span class="line">      <span class="type">bool</span> update_source=<span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">unsigned</span> step=<span class="number">0</span>,stride=<span class="number">1</span>;stride&lt;=i;++step,stride*=<span class="number">2</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        value_type <span class="type">const</span>&amp; source=(step%<span class="number">2</span>)?  <span class="comment">// 2</span></span><br><span class="line">          buffer[i]:ith_element;</span><br><span class="line">        value_type&amp; dest=(step%<span class="number">2</span>)?</span><br><span class="line">          ith_element:buffer[i];</span><br><span class="line">        value_type <span class="type">const</span>&amp; addend=(step%<span class="number">2</span>)?  <span class="comment">// 3</span></span><br><span class="line">          buffer[i-stride]:*(first+i-stride);</span><br><span class="line">        dest=source+addend;  <span class="comment">// 4</span></span><br><span class="line">        update_source=!(step%<span class="number">2</span>);</span><br><span class="line">        b.<span class="built_in">wait</span>();  <span class="comment">// 5</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(update_source)  <span class="comment">// 6</span></span><br><span class="line">      &#123;</span><br><span class="line">        ith_element=buffer[i];</span><br><span class="line">      &#125;</span><br><span class="line">      b.<span class="built_in">done_waiting</span>();  <span class="comment">// 7</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> length=std::<span class="built_in">distance</span>(first,last);</span><br><span class="line">  <span class="keyword">if</span>(length&lt;=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="function">std::vector&lt;value_type&gt; <span class="title">buffer</span><span class="params">(length)</span></span>;</span><br><span class="line">  <span class="function">barrier <span class="title">b</span><span class="params">(length)</span></span>;</span><br><span class="line">  <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(length<span class="number">-1</span>)</span></span>;  <span class="comment">// 8</span></span><br><span class="line">  <span class="function">join_threads <span class="title">joiner</span><span class="params">(threads)</span></span>;</span><br><span class="line">  Iterator block_start=first;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;(length<span class="number">-1</span>);++i)</span><br><span class="line">  &#123;</span><br><span class="line">    threads[i]=std::<span class="built_in">thread</span>(<span class="built_in">process_element</span>(),first,last,  <span class="comment">// 9</span></span><br><span class="line">                           std::<span class="built_in">ref</span>(buffer),i,std::<span class="built_in">ref</span>(b));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">process_element</span>()(first,last,buffer,length<span class="number">-1</span>,b);  <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码的整体结构应该不用说了。<code>process_element</code>类有函数调用操作可以用来做具体的工作①，就是运行一组线程⑨，并将线程存储到vector中⑧，同样还需要在主线程中对其进行调用⑩。这里与之前最大的区别就是，线程的数量是根据列表中的数据量来定的，而非根据<code>std::thread::hardware_concurrency</code>。如我之前所说，除非你使用的是一个大规模并行的机器，因为这上面的线程都十分廉价(虽然这样的方式并不是很好)，还能为我们展示了其整体结构。这个结构在有较少线程的时候，每一个线程只能处理源数据中的部分数据，当没有足够的线程支持该结构时，效率要比传递算法低。</p>
<p>不管怎样，主要的工作都是调用<code>process_element</code>的函数操作符来完成的。每一步，都会从原始数据或缓存中获取第i个元素②，并且将获取到的元素加到指定stride的元素中去③，如果从原始数据开始读取的元素，加和后的数需要存储在缓存中④。然后，在开始下一步前，会在栅栏处等待⑤。当stride超出了给定数据的范围，当最终结果已经存在缓存中时，就需要更新原始数据中的数据，同样这也意味着本次加和结束。最后，在调用栅栏中的done_waiting()函数⑦。</p>
<p>注意这个解决方案并不是异常安全的。如果某个线程在<code>process_element</code>执行时抛出一个异常，其就会终止整个应用。这里可以使用一个std::promise来存储异常，就像在清单8.9中parallel_find的实现，或仅使用一个被互斥量保护的std::exception_ptr即可。</p>
<h1 id="高级线程管理"><a href="#高级线程管理" class="headerlink" title="高级线程管理"></a>高级线程管理</h1><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="最简单的线程池"><a href="#最简单的线程池" class="headerlink" title="最简单的线程池"></a>最简单的线程池</h3><p>作为最简单的线程池，其拥有固定数量的工作线程(通常工作线程数量与<code>std::thread::hardware_concurrency()</code>相同)。当工作需要完成时，可以调用函数将任务挂在任务队列中。每个工作线程都会从任务队列上获取任务，然后执行这个任务，执行完成后再回来获取新的任务。在最简单的线程池中，线程就不需要等待其他线程完成对应任务了。如果需要等待，就需要对同步进行管理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">thread_pool</span></span><br><span class="line">&#123;</span><br><span class="line">  std::atomic_bool done;</span><br><span class="line">  thread_safe_queue&lt;std::function&lt;<span class="type">void</span>()&gt; &gt; work_queue;  <span class="comment">// 1</span></span><br><span class="line">  std::vector&lt;std::thread&gt; threads;  <span class="comment">// 2</span></span><br><span class="line">  join_threads joiner;  <span class="comment">// 3</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!done)  <span class="comment">// 4</span></span><br><span class="line">    &#123;</span><br><span class="line">      std::function&lt;<span class="type">void</span>()&gt; task;</span><br><span class="line">      <span class="keyword">if</span>(work_queue.<span class="built_in">try_pop</span>(task))  <span class="comment">// 5</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">task</span>();  <span class="comment">// 6</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>();  <span class="comment">// 7</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">thread_pool</span>():</span><br><span class="line">    <span class="built_in">done</span>(<span class="literal">false</span>),<span class="built_in">joiner</span>(threads)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">const</span> thread_count=std::thread::<span class="built_in">hardware_concurrency</span>();  <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">unsigned</span> i=<span class="number">0</span>;i&lt;thread_count;++i)</span><br><span class="line">      &#123;</span><br><span class="line">        threads.<span class="built_in">push_back</span>( </span><br><span class="line">          std::<span class="built_in">thread</span>(&amp;thread_pool::worker_thread,<span class="keyword">this</span>));  <span class="comment">// 9</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...)</span><br><span class="line">    &#123;</span><br><span class="line">      done=<span class="literal">true</span>;  <span class="comment">// 10</span></span><br><span class="line">      <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">thread_pool</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    done=<span class="literal">true</span>;  <span class="comment">// 11</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FunctionType&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">submit</span><span class="params">(FunctionType f)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    work_queue.<span class="built_in">push</span>(std::<span class="built_in">function</span>&lt;<span class="built_in">void</span>()&gt;(f));  <span class="comment">// 12</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实现中有一组工作线程②，并且使用了一个线程安全队列①来管理任务队列。这种情况下，用户不用等待任务，并且任务不需要返回任何值，所以可以使用<code>std::function&lt;void()&gt;</code>对任务进行封装。submit()函数会将函数或可调用对象包装成一个<code>std::function&lt;void()&gt;</code>实例，并将其推入队列中⑫。</p>
<p>线程始于构造函数：使用<code>std::thread::hardware_concurrency()</code>来获取硬件支持多少个并发线程⑧，这些线程会在<code>worker_thread()</code>成员函数中执行⑨。</p>
<p>当有异常抛出时，线程启动就会失败，所以需要保证任何已启动的线程都能停止，并且能在这种情况下清理干净。当有异常抛出时，通过使用try-catch来设置done标志⑩，还有<code>join_threads</code>类的实例③用来汇聚所有线程。当然也需要析构函数：仅设置done标志⑪，并且join_threads确保所有线程在线程池销毁前全部执行完成。注意成员声明的顺序很重要：done标志和worker_queue必须在threads数组之前声明，而数据必须在joiner前声明。这就能确保成员能以正确的顺序销毁；比如，所有线程都停止运行时，队列就可以安全的销毁了。</p>
<p><code>worker_thread</code>函数很简单：从任务队列上获取任务⑤，以及同时执行这些任务⑥，执行一个循环直到done标志被设置④。如果任务队列上没有任务，函数会调用std::this_thread::yield()让线程休息⑦，并且给予其他线程向任务队列上推送任务的机会。</p>
<h3 id="等待提交到线程池中的任务"><a href="#等待提交到线程池中的任务" class="headerlink" title="等待提交到线程池中的任务"></a>等待提交到线程池中的任务</h3><p>使用线程池，就需要等待任务提交到线程池中，而非直接提交给单个线程。虽然，会增加代码的复杂度，不过，要比直接对任务进行等待的方式好很多。</p>
<p>通过增加线程池的复杂度，可以直接等待任务完成。使用<code>submit()</code>函数返回一个对任务描述的句柄，用来等待任务的完成。任务句柄会用条件变量或future进行包装，这样能使用线程池来简化代码。</p>
<p>一种特殊的情况是，执行任务的线程需要返回一个结果到主线程上进行处理。下边展示了对简单线程池的修改，通过修改就能等待任务完成，以及在工作线程完成后，返回一个结果到等待线程中去，不过<code>std::packaged_task&lt;&gt;</code>实例是不可拷贝的，仅是可移动的，所以不能再使用<code>std::function&lt;&gt;</code>来实现任务队列，因为<code>std::function&lt;&gt;</code>需要存储可复制构造的函数对象。包装一个自定义函数，用来处理只可移动的类型。这就是一个带有函数操作符的类型擦除类。只需要处理那些没有函数和无返回的函数，所以这是一个简单的虚函数调用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">function_wrapper</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">impl_base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">call</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">impl_base</span>() &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  std::unique_ptr&lt;impl_base&gt; impl;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">impl_type</span>: impl_base</span><br><span class="line">  &#123;</span><br><span class="line">    F f;</span><br><span class="line">    <span class="built_in">impl_type</span>(F&amp;&amp; f_): <span class="built_in">f</span>(std::<span class="built_in">move</span>(f_)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123; <span class="built_in">f</span>(); &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function">  <span class="title">function_wrapper</span><span class="params">(F&amp;&amp; f)</span>:</span></span><br><span class="line"><span class="function">    impl(new impl_type&lt;F&gt;(std::move(f)))</span></span><br><span class="line"><span class="function">  &#123;</span>&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123; impl-&gt;<span class="built_in">call</span>(); &#125;</span><br><span class="line">  <span class="built_in">function_wrapper</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">function_wrapper</span>(function_wrapper&amp;&amp; other):</span><br><span class="line">    <span class="built_in">impl</span>(std::<span class="built_in">move</span>(other.impl))</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  function_wrapper&amp; <span class="keyword">operator</span>=(function_wrapper&amp;&amp; other)</span><br><span class="line">  &#123;</span><br><span class="line">    impl=std::<span class="built_in">move</span>(other.impl);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">function_wrapper</span>(<span class="type">const</span> function_wrapper&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">function_wrapper</span>(function_wrapper&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">  function_wrapper&amp; <span class="keyword">operator</span>=(<span class="type">const</span> function_wrapper&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_pool</span></span><br><span class="line">&#123;</span><br><span class="line">  thread_safe_queue&lt;function_wrapper&gt; work_queue;  <span class="comment">// 使用function_wrapper，而非使用std::function</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!done)</span><br><span class="line">    &#123;</span><br><span class="line">      function_wrapper task;</span><br><span class="line">      <span class="keyword">if</span>(work_queue.<span class="built_in">try_pop</span>(task))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">task</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> FunctionType&gt;</span><br><span class="line">  std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="built_in">FunctionType</span>()&gt;::type&gt;  <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">submit</span>(FunctionType f)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">FunctionType</span>()&gt;::type</span><br><span class="line">      result_type;  <span class="comment">// 2</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">result_type</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(std::move(f))</span></span>;  <span class="comment">// 3</span></span><br><span class="line">    <span class="function">std::future&lt;result_type&gt; <span class="title">res</span><span class="params">(task.get_future())</span></span>;  <span class="comment">// 4</span></span><br><span class="line">    work_queue.<span class="built_in">push</span>(std::<span class="built_in">move</span>(task));  <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">return</span> res;  <span class="comment">// 6</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 休息一下</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>首先，修改的是<code>submit()</code>函数①返回一个<code>std::future&lt;&gt;</code>保存任务的返回值，并且允许调用者等待任务完全结束。因为需要知道提供函数f的返回类型，所以使用<code>std::result_of&lt;&gt;</code>：<code>std::result_of&lt;FunctionType()&gt;::type</code>是<code>FunctionType</code>类型的引用实例(如，f)，并且没有参数。同样，函数中可以对<code>result_type typedef</code>②使用<code>std::result_of&lt;&gt;</code>。</p>
<p>然后，将<code>f</code>包装入<code>std::packaged_task&lt;result_type()&gt;</code>③，因为<code>f</code>是一个无参数的函数或是可调用对象，能够返回result_type类型的实例。向任务队列推送任务⑤和返回future⑥前，就可以从<code>std::packaged_task&lt;&gt;</code>中获取future④。注意，要将任务推送到任务队列中时，只能使用<code>std::move()</code>，因为<code>std::packaged_task&lt;&gt;</code>是不可拷贝的。为了对任务进行处理，队列里面存的就是<code>function_wrapper</code>对象，而非<code>std::function&lt;void()&gt;</code>对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">parallel_accumulate</span><span class="params">(Iterator first,Iterator last,T init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> length=std::<span class="built_in">distance</span>(first,last);</span><br><span class="line">  <span class="keyword">if</span>(!length)</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> block_size=<span class="number">25</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> num_blocks=(length+block_size<span class="number">-1</span>)/block_size;  <span class="comment">// 1</span></span><br><span class="line">  std::vector&lt;std::future&lt;T&gt; &gt; <span class="built_in">futures</span>(num_blocks<span class="number">-1</span>);</span><br><span class="line">  thread_pool pool;</span><br><span class="line">  Iterator block_start=first;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;(num_blocks<span class="number">-1</span>);++i)</span><br><span class="line">  &#123;</span><br><span class="line">    Iterator block_end=block_start;</span><br><span class="line">    std::<span class="built_in">advance</span>(block_end,block_size);</span><br><span class="line">    futures[i]=pool.<span class="built_in">submit</span>(<span class="built_in">accumulate_block</span>&lt;Iterator,T&gt;());  <span class="comment">// 2</span></span><br><span class="line">    block_start=block_end;</span><br><span class="line">  &#125;</span><br><span class="line">  T last_result=<span class="built_in">accumulate_block</span>&lt;Iterator,T&gt;()(block_start,last);</span><br><span class="line">  T result=init;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;(num_blocks<span class="number">-1</span>);++i)</span><br><span class="line">  &#123;</span><br><span class="line">    result+=futures[i].<span class="built_in">get</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  result += last_result;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，工作量是依据使用的块数(num_blocks①)，而不是线程的数量。为了利用线程池的最大化可扩展性，需要将工作块划分为最小工作块。当线程池中线程不多时，每个线程将会处理多个工作块，不过随着硬件可用线程数量的增长，会有越来越多的工作块并发执行。</p>
<p>当你选择“因为能并发执行，最小工作块值的一试”时，就需要谨慎了。向线程池提交一个任务有一定的开销；让工作线程执行这个任务，并且将返回值保存在<code>std::future&lt;&gt;</code>中，对于太小的任务，这样的开销不划算。如果任务块太小，使用线程池的速度可能都不及单线程。</p>
<p>假设，任务块的大小合理，就不用为这些事而担心：打包任务、获取future或存储之后要汇入的<code>std::thread</code>对象；使用线程池的时候，这些都需要注意。之后，就是调用<code>submit()</code>来提交任务②。</p>
<p>线程池也需要注意异常安全。任何异常都会通过<code>submit()</code>返回给future，并在获取future的结果时，抛出异常。如果函数因为异常退出，线程池的析构函数会丢掉那些没有完成的任务，等待线程池中的工作线程完成工作。</p>
<p>在简单的例子中，这个线程池工作的还算不错，因为这里的任务都是相互独立的。不过，当任务队列中的任务有依赖关系时，这个线程池就不能胜任了。</p>
<h3 id="等待依赖任务"><a href="#等待依赖任务" class="headerlink" title="等待依赖任务"></a>等待依赖任务</h3><p>快速排序算法为例，原理很简单：数据与中轴数据项比较，在中轴项两侧分为大于和小于的两个序列，然后再对这两组序列进行排序。这两组序列会递归排序，最后会整合成一个全排序序列。要将这个算法写成并发模式，需要保证递归调用能够使用硬件的并发能力。</p>
<p>回到第4章，第一次接触这个例子，我们使用<code>std::async</code>来执行每一层的调用，让标准库来选择，是在新线程上执行这个任务，还是当对应<code>get()</code>调用时，进行同步执行。运行起来很不错，因为每一个任务都在其自己的线程上执行，或当需要的时候进行调用。</p>
<p>在这样的情况下，使用了栈来挂起要排序的数据块。当每个线程在为一个数据块排序前，会向数据栈上添加一组要排序的数据，然后对当前数据块排序结束后，接着对另一块进行排序。这里，等待其他线程完成排序，可能会造成死锁，因为这会消耗有限的线程。有一种情况很可能会出现，就是所有线程都在等某一个数据块被排序，不过没有线程在做排序。通过拉取栈上数据块的线程，对数据块进行排序，来解决这个问题；因为，已处理的指定数据块，就是其他线程都在等待排序的数据块。</p>
<p>最简单的方法就是在thread_pool中添加一个新函数，来执行任务队列上的任务，并对线程池进行管理。高级线程池的实现可能会在等待函数中添加逻辑，或等待其他函数来处理这个任务，优先的任务会让其他的任务进行等待。下面清单中的实现，就展示了一个新<code>run_pending_task()</code>函数，对于快速排序的修改将会在清单9.5中展示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_pool::run_pending_task</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  function_wrapper task;</span><br><span class="line">  <span class="keyword">if</span>(work_queue.<span class="built_in">try_pop</span>(task))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">task</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>run_pending_task()</code>的实现去掉了在<code>worker_thread()</code>函数的主循环。函数任务队列中有任务的时候，执行任务；要是没有的话，就会让操作系统对线程进行重新分配。</p>
<p>下面快速排序算法的实现要简单许多，因为所有线程管理逻辑都被移入到线程池。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sorter</span>  <span class="comment">// 1</span></span><br><span class="line">&#123;</span><br><span class="line">  thread_pool pool;  <span class="comment">// 2</span></span><br><span class="line">  <span class="function">std::list&lt;T&gt; <span class="title">do_sort</span><span class="params">(std::list&lt;T&gt;&amp; chunk_data)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(chunk_data.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> chunk_data;</span><br><span class="line">    &#125;</span><br><span class="line">    std::list&lt;T&gt; result;</span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(),chunk_data,chunk_data.<span class="built_in">begin</span>());</span><br><span class="line">    T <span class="type">const</span>&amp; partition_val=*result.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">typename</span> std::list&lt;T&gt;::iterator divide_point=</span><br><span class="line">      std::<span class="built_in">partition</span>(chunk_data.<span class="built_in">begin</span>(),chunk_data.<span class="built_in">end</span>(),</span><br><span class="line">                     [&amp;](T <span class="type">const</span>&amp; val)&#123;<span class="keyword">return</span> val&lt;partition_val;&#125;);</span><br><span class="line">    std::list&lt;T&gt; new_lower_chunk;</span><br><span class="line">    new_lower_chunk.<span class="built_in">splice</span>(new_lower_chunk.<span class="built_in">end</span>(),</span><br><span class="line">                           chunk_data,chunk_data.<span class="built_in">begin</span>(),</span><br><span class="line">                           divide_point);</span><br><span class="line">    std::future&lt;std::list&lt;T&gt; &gt; new_lower=  <span class="comment">// 3</span></span><br><span class="line">      pool.<span class="built_in">submit</span>(std::<span class="built_in">bind</span>(&amp;sorter::do_sort,<span class="keyword">this</span>,</span><br><span class="line">                            std::<span class="built_in">move</span>(new_lower_chunk)));</span><br><span class="line">    <span class="function">std::list&lt;T&gt; <span class="title">new_higher</span><span class="params">(do_sort(chunk_data))</span></span>;</span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">end</span>(),new_higher);</span><br><span class="line">    <span class="keyword">while</span>(!new_lower.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">0</span>)) ==</span><br><span class="line">      std::future_status::timeout)</span><br><span class="line">    &#123;</span><br><span class="line">      pool.<span class="built_in">run_pending_task</span>();  <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(),new_lower.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">std::list&lt;T&gt; <span class="title">parallel_quick_sort</span><span class="params">(std::list&lt;T&gt; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(input.<span class="built_in">empty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">  &#125;</span><br><span class="line">  sorter&lt;T&gt; s;</span><br><span class="line">  <span class="keyword">return</span> s.<span class="built_in">do_sort</span>(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将实际工作放在sorter类模板的<code>do_sort()</code>成员函数中执行①，即使例子中仅对thread_pool实例进行包装②。</p>
<p>线程和任务管理，在线程等待的时候，就会少向线程池中提交一个任务③，并且执行任务队列上未完成的任务④。需要显式的管理线程和栈上要排序的数据块。当有任务提交到线程池中，可以使用<code>std::bind()</code>绑定this指针到<code>do_sort()</code>上，绑定是为了让数据块进行排序。这种情况下，需要对<code>new_lower_chunk</code>使用<code>std::move()</code>将其传入函数，数据移动要比拷贝的方式开销少。</p>
<p>虽然，使用等待其他任务的方式，解决了死锁问题，这个线程池距离理想的线程池很远。</p>
<p>首先，每次对<code>submit()</code>的调用和对<code>run_pending_task()</code>的调用，访问的都是同一个队列。</p>
<h3 id="避免队列中的任务竞争"><a href="#避免队列中的任务竞争" class="headerlink" title="避免队列中的任务竞争"></a>避免队列中的任务竞争</h3><p>线程每次调用线程池的<code>submit()</code>函数，都会推送一个任务到工作队列中。就像工作线程为了执行任务，从任务队列中获取任务一样。这意味着随着处理器的增加，在任务队列上就会有很多的竞争，这会让性能下降。使用无锁队列会让任务没有明显的等待，但是乒乓缓存会消耗大量的时间。</p>
<p>为了避免乒乓缓存，每个线程建立独立的任务队列。这样，每个线程就会将新任务放在自己的任务队列上，并且当线程上的任务队列没有任务时，去全局的任务列表中取任务。下面列表中的实现，使用了一个thread_local变量，来保证每个线程都拥有自己的任务列表(如全局列表那样)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">thread_pool</span></span><br><span class="line">&#123;</span><br><span class="line">  thread_safe_queue&lt;function_wrapper&gt; pool_work_queue;</span><br><span class="line">  <span class="keyword">typedef</span> std::queue&lt;function_wrapper&gt; local_queue_type;  <span class="comment">// 1</span></span><br><span class="line">  <span class="type">static</span> <span class="keyword">thread_local</span> std::unique_ptr&lt;local_queue_type&gt;</span><br><span class="line">    local_work_queue;  <span class="comment">// 2</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    local_work_queue.<span class="built_in">reset</span>(<span class="keyword">new</span> local_queue_type);  <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">while</span>(!done)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">run_pending_task</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> FunctionType&gt;</span><br><span class="line">  std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="built_in">FunctionType</span>()&gt;::type&gt;</span><br><span class="line">    <span class="built_in">submit</span>(FunctionType f)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">FunctionType</span>()&gt;::type result_type;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">result_type</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(f)</span></span>;</span><br><span class="line">    <span class="function">std::future&lt;result_type&gt; <span class="title">res</span><span class="params">(task.get_future())</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(local_work_queue)  <span class="comment">// 4</span></span><br><span class="line">    &#123;</span><br><span class="line">      local_work_queue-&gt;<span class="built_in">push</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      pool_work_queue.<span class="built_in">push</span>(std::<span class="built_in">move</span>(task));  <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run_pending_task</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    function_wrapper task;</span><br><span class="line">    <span class="keyword">if</span>(local_work_queue &amp;&amp; !local_work_queue-&gt;<span class="built_in">empty</span>())  <span class="comment">// 6</span></span><br><span class="line">    &#123;</span><br><span class="line">      task=std::<span class="built_in">move</span>(local_work_queue-&gt;<span class="built_in">front</span>());</span><br><span class="line">      local_work_queue-&gt;<span class="built_in">pop</span>();</span><br><span class="line">      <span class="built_in">task</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pool_work_queue.<span class="built_in">try_pop</span>(task))  <span class="comment">// 7</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">task</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// rest as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为不希望非线程池中的线程也拥有一个任务队列，使用<code>std::unique_ptr&lt;&gt;</code>指向线程本地的工作队列②；这个指针在<code>worker_thread()</code>中进行初始化③。<code>std:unique_ptr&lt;&gt;</code>的析构函数会保证在线程退出的时候，工作队列被销毁。</p>
<p><code>submit()</code>会检查当前线程是否具有一个工作队列④。如果有，就是线程池中的线程，可以将任务放入线程的本地队列中；否者，就像之前一样将这个任务放在线程池中的全局队列中⑤。</p>
<p><code>run_pending_task()</code>⑥中的检查和之前类似，只是要对是否存在本地任务队列进行检查。如果存在，就会从队列中的第一个任务开始处理；注意本地任务队列可以是一个普通的std::queue&lt;&gt;①，因为这个队列只能被一个线程所访问，就不存在竞争。如果本地线程上没有任务，就会从全局工作列表上获取任务⑦。</p>
<p>这样就能有效避免竞争，不过当任务分配不均时，造成的结果就是：某个线程本地队列中有很多任务的同时，其他线程无所事事。例如：举一个快速排序的例子，只有一开始的数据块能在线程池上被处理，因为剩余部分会放在工作线程的本地队列上进行处理，这样的使用方式也违背使用线程池的初衷。</p>
<p>幸好，这个问题是有解：本地工作队列和全局工作队列上没有任务时，可从别的线程队列中窃取任务。</p>
<h3 id="窃取任务"><a href="#窃取任务" class="headerlink" title="窃取任务"></a>窃取任务</h3><p>为了让没有任务的线程能从其他线程的任务队列中获取任务，就需要本地任务列表可以进行访问，这样才能让<code>run_pending_tasks()</code>窃取任务。需要每个线程在线程池队列上进行注册，或由线程池指定一个线程。同样，还需要保证数据队列中的任务适当的被同步和保护，这样队列的不变量就不会被破坏。</p>
<p>实现一个无锁队列，让其拥有线程在其他线程窃取任务的时候，能够推送和弹出一个任务是可能的；不过，这个队列的实现就超出了本书的讨论范围。为了证明这种方法的可行性，将使用一个互斥量来保护队列中的数据。我们希望任务窃取是一个不常见的现象，这样就会减少对互斥量的竞争，并且使得简单队列的开销最小。下面，实现了一个简单的基于锁的任务窃取队列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">work_stealing_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> function_wrapper data_type;</span><br><span class="line">  std::deque&lt;data_type&gt; the_queue;  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">mutable</span> std::mutex the_mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">work_stealing_queue</span>()</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  <span class="built_in">work_stealing_queue</span>(<span class="type">const</span> work_stealing_queue&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  work_stealing_queue&amp; <span class="keyword">operator</span>=(</span><br><span class="line">    <span class="type">const</span> work_stealing_queue&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(data_type data)</span>  <span class="comment">// 2</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(the_mutex)</span></span>;</span><br><span class="line">    the_queue.<span class="built_in">push_front</span>(std::<span class="built_in">move</span>(data));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(the_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> the_queue.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(data_type&amp; res)</span>  <span class="comment">// 3</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(the_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(the_queue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res=std::<span class="built_in">move</span>(the_queue.<span class="built_in">front</span>());</span><br><span class="line">    the_queue.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">try_steal</span><span class="params">(data_type&amp; res)</span>  <span class="comment">// 4</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(the_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(the_queue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res=std::<span class="built_in">move</span>(the_queue.<span class="built_in">back</span>());</span><br><span class="line">    the_queue.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个队列对<code>std::deque&lt;fuction_wrapper&gt;</code>进行了简单的包装①，就能通过一个互斥锁来对所有访问进行控制了。<code>push()</code>②和<code>try_pop()</code>③对队列的前端进行操作，<code>try_steal()</code>④对队列的后端进行操作。</p>
<p>这就说明每个线程中的“队列”是一个后进先出的栈，最新推入的任务将会第一个执行。从缓存角度来看，这将对性能有所提升，因为任务相关的数据一直存于缓存中，要比提前将任务相关数据推送到栈上好。同样，这种方式很好的映射到某个算法上，例如：快速排序。之前的实现中，每次调用<code>do_sort()</code>都会推送一个任务到栈上，并且等待这个任务执行完毕。通过对最新推入任务的处理，就可以保证在将当前所需数据块处理完成前，其他任务是否需要这些数据块，从而可以减少活动任务的数量和栈的使用次数。<code>try_steal()</code>从队列末尾获取任务，为了减少与<code>try_pop()</code>之间的竞争。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">thread_pool</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> function_wrapper task_type;</span><br><span class="line"></span><br><span class="line">  std::atomic_bool done;</span><br><span class="line">  thread_safe_queue&lt;task_type&gt; pool_work_queue;</span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;work_stealing_queue&gt; &gt; queues;  <span class="comment">// 1</span></span><br><span class="line">  std::vector&lt;std::thread&gt; threads;</span><br><span class="line">  join_threads joiner;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="keyword">thread_local</span> work_stealing_queue* local_work_queue;  <span class="comment">// 2</span></span><br><span class="line">  <span class="type">static</span> <span class="keyword">thread_local</span> <span class="type">unsigned</span> my_index;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">(<span class="type">unsigned</span> my_index_)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    my_index=my_index_;</span><br><span class="line">    local_work_queue=queues[my_index].<span class="built_in">get</span>();  <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">while</span>(!done)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">run_pending_task</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">pop_task_from_local_queue</span><span class="params">(task_type&amp; task)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> local_work_queue &amp;&amp; local_work_queue-&gt;<span class="built_in">try_pop</span>(task);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">pop_task_from_pool_queue</span><span class="params">(task_type&amp; task)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pool_work_queue.<span class="built_in">try_pop</span>(task);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">pop_task_from_other_thread_queue</span><span class="params">(task_type&amp; task)</span>  <span class="comment">// 4</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> i=<span class="number">0</span>;i&lt;queues.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">const</span> index=(my_index+i<span class="number">+1</span>)%queues.<span class="built_in">size</span>();  <span class="comment">// 5</span></span><br><span class="line">      <span class="keyword">if</span>(queues[index]-&gt;<span class="built_in">try_steal</span>(task))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">thread_pool</span>():</span><br><span class="line">    <span class="built_in">done</span>(<span class="literal">false</span>),<span class="built_in">joiner</span>(threads)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">const</span> thread_count=std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">unsigned</span> i=<span class="number">0</span>;i&lt;thread_count;++i)</span><br><span class="line">      &#123;</span><br><span class="line">        queues.<span class="built_in">push_back</span>(std::<span class="built_in">unique_ptr</span>&lt;work_stealing_queue&gt;(  <span class="comment">// 6</span></span><br><span class="line">                         <span class="keyword">new</span> work_stealing_queue));</span><br><span class="line">        threads.<span class="built_in">push_back</span>(</span><br><span class="line">          std::<span class="built_in">thread</span>(&amp;thread_pool::worker_thread,<span class="keyword">this</span>,i));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...)</span><br><span class="line">    &#123;</span><br><span class="line">      done=<span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">thread_pool</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    done=<span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> FunctionType&gt;</span><br><span class="line">  std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="built_in">FunctionType</span>()&gt;::type&gt; <span class="built_in">submit</span>(</span><br><span class="line">    FunctionType f)</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">FunctionType</span>()&gt;::type result_type;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">result_type</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(f)</span></span>;</span><br><span class="line">    <span class="function">std::future&lt;result_type&gt; <span class="title">res</span><span class="params">(task.get_future())</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(local_work_queue)</span><br><span class="line">    &#123;</span><br><span class="line">      local_work_queue-&gt;<span class="built_in">push</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      pool_work_queue.<span class="built_in">push</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run_pending_task</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    task_type task;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pop_task_from_local_queue</span>(task) ||  <span class="comment">// 7</span></span><br><span class="line">       <span class="built_in">pop_task_from_pool_queue</span>(task) ||  <span class="comment">// 8</span></span><br><span class="line">       <span class="built_in">pop_task_from_other_thread_queue</span>(task))  <span class="comment">// 9</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">task</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2><h3 id="启动和中断线程"><a href="#启动和中断线程" class="headerlink" title="启动和中断线程"></a>启动和中断线程</h3><p>先看一下外部接口，需要从可中断线程上获取些什么？最起码需要和<code>std::thread</code>相同的接口，还要多加一个<code>interrupt()</code>函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">interruptible_thread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FunctionType&gt;</span></span><br><span class="line"><span class="function">  <span class="title">interruptible_thread</span><span class="params">(FunctionType f)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">joinable</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">interrupt</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>类内部可以使用<code>std::thread</code>来管理线程，并且使用一些自定义数据结构来处理中断。现在，从线程的角度能看到什么呢？“能用这个类来中断线程”——需要一个断点(interruption point)。在不添加多余的数据的前提下，为了使断点能够正常使用，就需要使用一个没有参数的函数：<code>interruption_point()</code>。这意味着中断数据结构可以访问<code>thread_local</code>变量，并在线程运行时，对变量进行设置，因此当线程调用<code>interruption_point()</code>函数时，就会去检查当前运行线程的数据结构。我们将在后面看到<code>interruption_point()</code>的具体实现。</p>
<p><code>thread_local</code>标志是不能使用普通的<code>std::thread</code>管理线程的主要原因；需要使用一种方法分配出一个可访问的<code>interruptible_thread</code>实例，就像新启动一个线程一样。在使用已提供函数来做这件事情前，需要将<code>interruptible_thread</code>实例传递给<code>std::thread</code>的构造函数，创建一个能够执行的线程，就像下面的代码清单所实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">interrupt_flag</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_set</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">thread_local</span> interrupt_flag this_thread_interrupt_flag;  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">interruptible_thread</span></span><br><span class="line">&#123;</span><br><span class="line">  std::thread internal_thread;</span><br><span class="line">  interrupt_flag* flag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FunctionType&gt;</span></span><br><span class="line"><span class="function">  <span class="title">interruptible_thread</span><span class="params">(FunctionType f)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::promise&lt;interrupt_flag*&gt; p;  <span class="comment">// 2</span></span><br><span class="line">    internal_thread=std::<span class="built_in">thread</span>([f,&amp;p]&#123;  <span class="comment">// 3</span></span><br><span class="line">      p.<span class="built_in">set_value</span>(&amp;this_thread_interrupt_flag);</span><br><span class="line">      <span class="built_in">f</span>();  <span class="comment">// 4</span></span><br><span class="line">    &#125;);</span><br><span class="line">    flag=p.<span class="built_in">get_future</span>().<span class="built_in">get</span>();  <span class="comment">// 5</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">interrupt</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">      flag-&gt;<span class="built_in">set</span>();  <span class="comment">// 6</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>提供函数<code>f</code>是包装了一个lambda函数③，线程将会持有f副本和本地promise变量(p)的引用②。在新线程中，lambda函数设置promise变量的值到<code>this_thread_interrupt_flag</code>(在<code>thread_local</code>①中声明)的地址中，为的是让线程能够调用提供函数的副本④。调用线程会等待与其future相关的promise就绪，并且将结果存入到flag成员变量中⑤。注意，即使lambda函数在新线程上执行，对本地变量p进行悬空引用，都没有问题，因为在新线程返回之前，<code>interruptible_thread</code>构造函数会等待变量p，直到变量p不被引用。实现没有考虑处理汇入线程，或分离线程。所以，需要flag变量在线程退出或分离前已经声明，这样就能避免悬空问题。</p>
<p><code>interrupt()</code>函数相对简单：需要一个线程去做中断时，需要一个合法指针作为一个中断标志，所以可以仅对标志进行设置⑥。</p>
<h3 id="检查线程是否中断"><a href="#检查线程是否中断" class="headerlink" title="检查线程是否中断"></a>检查线程是否中断</h3><p>现在就可以设置中断标志了，不过不检查线程是否被中断，这样的意义就不大了。使用<code>interruption_point()</code>函数最简单的情况；可以在一个安全的地方调用这个函数，如果标志已经设置，就可以抛出一个<code>thread_interrupted</code>异常：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">interruption_point</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(this_thread_interrupt_flag.<span class="built_in">is_set</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">thread_interrupted</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中可以在适当的地方使用这个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!done)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">interruption_point</span>();</span><br><span class="line">    <span class="built_in">process_next_item</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用std-condition-variable-any中断等待"><a href="#使用std-condition-variable-any中断等待" class="headerlink" title="使用std::condition_variable_any中断等待"></a>使用std::condition_variable_any中断等待</h3><p><code>std::condition_variable_any</code>与<code>std::condition_variable</code>的不同在于，<code>std::condition_variable_any</code>可以使用任意类型的锁，而不仅有<code>std::unique_lock&lt;std::mutex&gt;</code>。可以让事情做起来更加简单，并且<code>std::condition_variable_any</code>可以比<code>std::condition_variable</code>做的更好。因为能与任意类型的锁一起工作，就可以设计自己的锁，上锁/解锁interrupt_flag的内部互斥量set_clear_mutex，并且锁也支持等待调用，就像下面的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">interrupt_flag</span></span><br><span class="line">&#123;</span><br><span class="line">  std::atomic&lt;<span class="type">bool</span>&gt; flag;</span><br><span class="line">  std::condition_variable* thread_cond;</span><br><span class="line">  std::condition_variable_any* thread_cond_any;</span><br><span class="line">  std::mutex set_clear_mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">interrupt_flag</span>(): </span><br><span class="line">    <span class="built_in">thread_cond</span>(<span class="number">0</span>),<span class="built_in">thread_cond_any</span>(<span class="number">0</span>)</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    flag.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(set_clear_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(thread_cond)</span><br><span class="line">    &#123;</span><br><span class="line">      thread_cond-&gt;<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(thread_cond_any)</span><br><span class="line">    &#123;</span><br><span class="line">      thread_cond_any-&gt;<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Lockable&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">wait</span><span class="params">(std::condition_variable_any&amp; cv,Lockable&amp; lk)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">custom_lock</span></span><br><span class="line">    &#123;</span><br><span class="line">      interrupt_flag* self;</span><br><span class="line">      Lockable&amp; lk;</span><br><span class="line">      <span class="built_in">custom_lock</span>(interrupt_flag* self_,</span><br><span class="line">                  std::condition_variable_any&amp; cond,</span><br><span class="line">                  Lockable&amp; lk_):</span><br><span class="line">        <span class="built_in">self</span>(self_),<span class="built_in">lk</span>(lk_)</span><br><span class="line">      &#123;</span><br><span class="line">        self-&gt;set_clear_mutex.<span class="built_in">lock</span>();  <span class="comment">// 1</span></span><br><span class="line">        self-&gt;thread_cond_any=&amp;cond;  <span class="comment">// 2</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span>  <span class="comment">// 3</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        lk.<span class="built_in">unlock</span>();</span><br><span class="line">        self-&gt;set_clear_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        std::<span class="built_in">lock</span>(self-&gt;set_clear_mutex,lk);  <span class="comment">// 4</span></span><br><span class="line">      &#125;</span><br><span class="line">      ~<span class="built_in">custom_lock</span>()</span><br><span class="line">      &#123;</span><br><span class="line">        self-&gt;thread_cond_any=<span class="number">0</span>;  <span class="comment">// 5</span></span><br><span class="line">        self-&gt;set_clear_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">custom_lock <span class="title">cl</span><span class="params">(<span class="keyword">this</span>,cv,lk)</span></span>;</span><br><span class="line">    <span class="built_in">interruption_point</span>();</span><br><span class="line">    cv.<span class="built_in">wait</span>(cl);</span><br><span class="line">    <span class="built_in">interruption_point</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// rest as before</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Lockable&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">interruptible_wait</span><span class="params">(std::condition_variable_any&amp; cv,</span></span></span><br><span class="line"><span class="params"><span class="function">                        Lockable&amp; lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  this_thread_interrupt_flag.<span class="built_in">wait</span>(cv,lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义的锁类型在构造的时候，需要所锁住内部<code>set_clear_mutex</code>①，对<code>thread_cond_any</code>指针进行设置，并引用<code>std::condition_variable_any</code>传入锁的构造函数中②。Lockable引用将会在之后进行存储，其变量必须被锁住。现在可以安心的检查中断，不用担心竞争了。如果这时中断标志已经设置，那么标志一定是在锁住<code>set_clear_mutex</code>时设置的。当条件变量调用自定义锁的<code>unlock()</code>函数中的<code>wait()</code>时，就会对Lockable对象和set_clear_mutex进行解锁③。这就允许线程可以尝试中断其他线程获取set_clear_mutex锁；以及在内部wait()调用之后，检查<code>thread_cond_any</code>指针。这就是在替换<code>std::condition_variable</code>后，所拥有的功能(不包括管理)。当<code>wait()</code>结束等待(因为等待，或因为伪苏醒)，因为线程将会调用lock()函数，这里依旧要求锁住内部set_clear_mutex，并且锁住Lockable对象④。现在，在wait()调用时，custom_lock的析构函数中⑤清理<code>thread_cond_any</code>指针(同样会解锁set_clear_mutex)之前，可以再次对中断进行检查。</p>
<h3 id="中断其他阻塞调用"><a href="#中断其他阻塞调用" class="headerlink" title="中断其他阻塞调用"></a>中断其他阻塞调用</h3><p>这次轮到中断条件变量的等待了，不过其他阻塞情况，比如：互斥锁，等待future等等，该怎么办呢？通常情况下，可以使用<code>std::condition_variable</code>的超时选项，因为在实际运行中不可能很快的将条件变量的等待终止(不访问内部互斥量或future的话)。不过，在某些情况下，你知道知道你在等待什么，这样就可以让循环在<code>interruptible_wait()</code>函数中运行。作为一个例子，这里为<code>std::future&lt;&gt;</code>重载了<code>interruptible_wait()</code>的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">interruptible_wait</span><span class="params">(std::future&lt;T&gt;&amp; uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!this_thread_interrupt_flag.<span class="built_in">is_set</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(uf.<span class="built_in">wait_for</span>(lk,std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>)==</span><br><span class="line">       std::future_status::ready)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">interruption_point</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>等待会在中断标志设置好的时候，或future准备就绪的时候停止，不过实现中每次等待future的时间只有1ms。这就意味着，中断请求被确定前，平均等待的时间为0.5ms(这里假设存在一个高精度的时钟)。通常wait_for至少会等待一个时钟周期，所以如果时钟周期为15ms，那么结束等待的时间将会是15ms，而不是1ms。接受与不接受这种情况，都得视情况而定。</p>
<h3 id="处理中断"><a href="#处理中断" class="headerlink" title="处理中断"></a>处理中断</h3><p>从中断线程的角度看，中断就是thread_interrupted异常，因此能像处理其他异常那样进行处理。</p>
<p>特别是使用标准catch块对其进行捕获：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(thread_interrupted&amp;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">handle_interruption</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>捕获中断，进行处理。其他线程再次调用interrupt()时，线程将会再次被中断，这就被称为断点(interruption point)。如果线程执行的是一系列独立的任务，就会需要断点；中断一个任务，就意味着这个任务被丢弃，并且该线程就会执行任务列表中的其他任务。</p>
<p>因为<code>thread_interrupted</code>是一个异常，在能够被中断的代码中，之前线程安全的注意事项都是适用的，就是为了确保资源不会泄露，并在数据结构中留下对应的退出状态。通常，让线程中断是可行的，所以只需要让异常传播即可。不过，当异常传入<code>std::thread</code>的析构函数时，<code>std::terminate()</code>将会调用，并且整个程序将会终止。为了避免这种情况，需要在每个将<code>interruptible_thread</code>变量作为参数传入的函数中放置catch(thread_interrupted)处理块，可以将catch块包装进interrupt_flag的初始化过程中。因为异常将会终止独立进程，就能保证未处理的中断是异常安全的。<code>interruptible_thread</code>构造函数中对线程的初始化，实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">internal_thread=std::<span class="built_in">thread</span>([f,&amp;p]&#123;</span><br><span class="line">        p.<span class="built_in">set_value</span>(&amp;this_thread_interrupt_flag);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">f</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span>(thread_interrupted <span class="type">const</span>&amp;)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure></p>
<p>下面，我们来看个更加复杂的例子。</p>
<h3 id="应用退出时中断后台任务"><a href="#应用退出时中断后台任务" class="headerlink" title="应用退出时中断后台任务"></a>应用退出时中断后台任务</h3><p>试想，在桌面上查找一个应用。这就需要与用户互动，应用的状态需要能在显示器上显示，就能看出应用有什么改变。为了避免影响GUI的响应时间，通常会将处理线程放在后台运行。后台进程需要一直执行，直到应用退出；后台线程会作为应用启动的一部分被启动，并且在应用终止的时候停止运行。通常这样的应用只有在机器关闭时，才会退出，因为应用需要更新应用最新的状态，就需要全时间运行。在某些情况下，当应用被关闭，需要使用有序的方式将后台线程关闭，其中一种方式就是中断。</p>
<p>下面清单中为一个系统实现了简单的线程管理部分。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">std::mutex config_mutex;</span><br><span class="line">std::vector&lt;interruptible_thread&gt; background_threads;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">background_thread</span><span class="params">(<span class="type">int</span> disk_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">interruption_point</span>();  <span class="comment">// 1</span></span><br><span class="line">    fs_change fsc=<span class="built_in">get_fs_changes</span>(disk_id);  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span>(fsc.<span class="built_in">has_changes</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">update_index</span>(fsc);  <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">start_background_processing</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  background_threads.<span class="built_in">push_back</span>(</span><br><span class="line">    <span class="built_in">interruptible_thread</span>(background_thread,disk_1));</span><br><span class="line">  background_threads.<span class="built_in">push_back</span>(</span><br><span class="line">    <span class="built_in">interruptible_thread</span>(background_thread,disk_2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">start_background_processing</span>();  <span class="comment">// 4</span></span><br><span class="line">  <span class="built_in">process_gui_until_exit</span>();  <span class="comment">// 5</span></span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(config_mutex)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">unsigned</span> i=<span class="number">0</span>;i&lt;background_threads.<span class="built_in">size</span>();++i)</span><br><span class="line">  &#123;</span><br><span class="line">    background_threads[i].<span class="built_in">interrupt</span>();  <span class="comment">// 6</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">unsigned</span> i=<span class="number">0</span>;i&lt;background_threads.<span class="built_in">size</span>();++i)</span><br><span class="line">  &#123;</span><br><span class="line">    background_threads[i].<span class="built_in">join</span>(); <span class="comment">// 7</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>启动时，后台线程就已经启动④。之后，对应线程将会处理GUI⑤。当用户要求进程退出时，后台进程将会被中断⑥，并且主线程会等待每一个后台线程结束后才退出⑦。后台线程运行在一个循环中，并时刻检查磁盘的变化②，对其序号进行更新③。调用<code>interruption_point()</code>函数，可以在循环中对中断进行检查。</p>
<h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a><condition_variable>头文件</h2><p><code>&lt;condition_variable&gt;</code>头文件提供了条件变量的定义。其作为基本同步机制，允许被阻塞的线程在某些条件达成或超时时，解除阻塞继续执行。</p>
<p>头文件内容<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">enum class</span> <span class="title class_">cv_status</span> &#123; timeout, no_timeout &#125;;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">condition_variable</span>;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">condition_variable_any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="std-condition-variable类"><a href="#std-condition-variable类" class="headerlink" title="std::condition_variable类"></a>std::condition_variable类</h3><p>std::condition_variable允许阻塞一个线程，直到条件达成。</p>
<p><code>std::condition_variable</code>实例不支持CopyAssignable(拷贝赋值), CopyConstructible(拷贝构造), MoveAssignable(移动赋值)和 MoveConstructible(移动构造)。</p>
<p>类型定义<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">condition_variable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">condition_variable</span>();</span><br><span class="line">  ~<span class="built_in">condition_variable</span>();</span><br><span class="line">  <span class="built_in">condition_variable</span>(condition_variable <span class="type">const</span>&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line">  condition_variable&amp; <span class="keyword">operator</span>=(condition_variable <span class="type">const</span>&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">notify_one</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">notify_all</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(std::unique_lock&lt;std::mutex&gt;&amp; lock)</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Predicate&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(std::unique_lock&lt;std::mutex&gt;&amp; lock,Predicate pred)</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Clock, <span class="keyword">typename</span> Duration&gt;</span><br><span class="line">  <span class="function">cv_status <span class="title">wait_until</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">       std::unique_lock&lt;std::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">const</span> std::chrono::time_point&lt;Clock, Duration&gt;&amp; absolute_time)</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Clock, <span class="keyword">typename</span> Duration, <span class="keyword">typename</span> Predicate&gt;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">wait_until</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">       std::unique_lock&lt;std::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">const</span> std::chrono::time_point&lt;Clock, Duration&gt;&amp; absolute_time,</span></span></span><br><span class="line"><span class="params"><span class="function">       Predicate pred)</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Period&gt;</span><br><span class="line">  <span class="function">cv_status <span class="title">wait_for</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">       std::unique_lock&lt;std::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt;&amp; relative_time)</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Period, <span class="keyword">typename</span> Predicate&gt;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">wait_for</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">       std::unique_lock&lt;std::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt;&amp; relative_time,</span></span></span><br><span class="line"><span class="params"><span class="function">       Predicate pred)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_all_at_thread_exit</span><span class="params">(condition_variable&amp;,unique_lock&lt;mutex&gt;)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="std-condition-variable-any类"><a href="#std-condition-variable-any类" class="headerlink" title="std::condition_variable_any类"></a>std::condition_variable_any类</h3><p><code>std::condition_variable_any</code>类允许线程等待某一条件为true的时候继续运行。不过<code>std::condition_variable</code>只能和<code>std::unique_lock&lt;std::mutex&gt;</code>一起使用，<code>std::condition_variable_any</code>可以和任意可上锁(Lockable)类型一起使用。</p>
<p><code>std::condition_variable_any</code>实例不能进行拷贝赋值(CopyAssignable)、拷贝构造(CopyConstructible)、移动赋值(MoveAssignable)或移动构造(MoveConstructible)。</p>
<p>类型定义<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">condition_variable_any</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">condition_variable_any</span>();</span><br><span class="line">  ~<span class="built_in">condition_variable_any</span>();</span><br><span class="line">  <span class="built_in">condition_variable_any</span>(</span><br><span class="line">      condition_variable_any <span class="type">const</span>&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line">  condition_variable_any&amp; <span class="keyword">operator</span>=(</span><br><span class="line">      condition_variable_any <span class="type">const</span>&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">notify_one</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">notify_all</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Lockable&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">wait</span><span class="params">(Lockable&amp; lock)</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Lockable, <span class="keyword">typename</span> Predicate&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(Lockable&amp; lock, Predicate pred)</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Lockable, <span class="keyword">typename</span> Clock,<span class="keyword">typename</span> Duration&gt;</span><br><span class="line">  <span class="function">std::cv_status <span class="title">wait_until</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      Lockable&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> std::chrono::time_point&lt;Clock, Duration&gt;&amp; absolute_time)</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;</span><br><span class="line">      <span class="keyword">typename</span> Lockable, <span class="keyword">typename</span> Clock,</span><br><span class="line">      <span class="keyword">typename</span> Duration, <span class="keyword">typename</span> Predicate&gt;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">wait_until</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      Lockable&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> std::chrono::time_point&lt;Clock, Duration&gt;&amp; absolute_time,</span></span></span><br><span class="line"><span class="params"><span class="function">      Predicate pred)</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Lockable, <span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Period&gt;</span><br><span class="line">  <span class="function">std::cv_status <span class="title">wait_for</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      Lockable&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt;&amp; relative_time)</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;</span><br><span class="line">      <span class="keyword">typename</span> Lockable, <span class="keyword">typename</span> Rep,</span><br><span class="line">      <span class="keyword">typename</span> Period, <span class="keyword">typename</span> Predicate&gt;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">wait_for</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      Lockable&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt;&amp; relative_time,</span></span></span><br><span class="line"><span class="params"><span class="function">      Predicate pred)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/18/modern-cpp-tutorial/" rel="prev" title="modern-cpp-tutorial">
      <i class="fa fa-chevron-left"></i> modern-cpp-tutorial
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/09/07/colab%E4%B8%8A%E4%BD%BF%E7%94%A8cuda/" rel="next" title="Colab上使用cuda">
      Colab上使用cuda <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC1%E7%AB%A0-%E4%BD%A0%E5%A5%BD%EF%BC%8CC-%E7%9A%84%E5%B9%B6%E5%8F%91%E4%B8%96%E7%95%8C"><span class="nav-number">1.</span> <span class="nav-text">第1章 你好，C++的并发世界!</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B%E5%85%A5%E9%97%A8"><span class="nav-number">1.1.</span> <span class="nav-text">开始入门</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">线程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="nav-number">2.1.</span> <span class="nav-text">线程管理的基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.1.1.</span> <span class="nav-text">启动线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B%E5%AE%8C%E6%88%90"><span class="nav-number">2.1.2.</span> <span class="nav-text">等待线程完成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E7%AD%89%E5%BE%85"><span class="nav-number">2.1.3.</span> <span class="nav-text">特殊情况下的等待</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.1.4.</span> <span class="nav-text">后台运行线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%91%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="nav-number">2.2.</span> <span class="nav-text">向线程函数传递参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AC%E7%A7%BB%E7%BA%BF%E7%A8%8B%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-number">2.3.</span> <span class="nav-text">转移线程所有权</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%B3%E5%AE%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F"><span class="nav-number">2.4.</span> <span class="nav-text">运行时决定线程数量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%86%E5%88%AB%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.5.</span> <span class="nav-text">识别线程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="nav-number">3.</span> <span class="nav-text">线程间共享数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">3.1.</span> <span class="nav-text">共享数据带来的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89"><span class="nav-number">3.1.1.</span> <span class="nav-text">条件竞争</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%81%B6%E6%80%A7%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89"><span class="nav-number">3.1.2.</span> <span class="nav-text">避免恶性条件竞争</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%87%8F%E4%BF%9D%E6%8A%A4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="nav-number">3.2.</span> <span class="nav-text">使用互斥量保护共享数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-number">3.2.1.</span> <span class="nav-text">C++中使用互斥量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B2%BE%E5%BF%83%E7%BB%84%E7%BB%87%E4%BB%A3%E7%A0%81%E6%9D%A5%E4%BF%9D%E6%8A%A4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="nav-number">3.2.2.</span> <span class="nav-text">精心组织代码来保护共享数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%86%85%E5%9C%A8%E7%9A%84%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89"><span class="nav-number">3.2.3.</span> <span class="nav-text">发现接口内在的条件竞争</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%EF%BC%9A%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">3.2.4.</span> <span class="nav-text">死锁：问题描述及解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%E7%9A%84%E8%BF%9B%E9%98%B6%E6%8C%87%E5%AF%BC"><span class="nav-number">3.2.5.</span> <span class="nav-text">避免死锁的进阶指导</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%B5%8C%E5%A5%97%E9%94%81"><span class="nav-number">3.2.5.1.</span> <span class="nav-text">避免嵌套锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%9C%A8%E6%8C%81%E6%9C%89%E9%94%81%E6%97%B6%E8%B0%83%E7%94%A8%E7%94%A8%E6%88%B7%E6%8F%90%E4%BE%9B%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">3.2.5.2.</span> <span class="nav-text">避免在持有锁时调用用户提供的代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9B%BA%E5%AE%9A%E9%A1%BA%E5%BA%8F%E8%8E%B7%E5%8F%96%E9%94%81"><span class="nav-number">3.2.5.3.</span> <span class="nav-text">使用固定顺序获取锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%94%81%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.5.4.</span> <span class="nav-text">使用锁的层次结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-unique-lock%E2%80%94%E2%80%94%E7%81%B5%E6%B4%BB%E7%9A%84%E9%94%81"><span class="nav-number">3.2.6.</span> <span class="nav-text">std::unique_lock——灵活的锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E5%9F%9F%E4%B8%AD%E4%BA%92%E6%96%A5%E9%87%8F%E6%89%80%E6%9C%89%E6%9D%83%E7%9A%84%E4%BC%A0%E9%80%92"><span class="nav-number">3.2.7.</span> <span class="nav-text">不同域中互斥量所有权的传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6"><span class="nav-number">3.2.8.</span> <span class="nav-text">锁的粒度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9B%BF%E4%BB%A3%E8%AE%BE%E6%96%BD"><span class="nav-number">3.3.</span> <span class="nav-text">保护共享数据的替代设施</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">3.3.1.</span> <span class="nav-text">保护共享数据的初始化过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E5%BE%88%E5%B0%91%E6%9B%B4%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.2.</span> <span class="nav-text">保护很少更新的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E9%94%81"><span class="nav-number">3.3.3.</span> <span class="nav-text">嵌套锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C"><span class="nav-number">4.</span> <span class="nav-text">同步并发操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E6%88%96%E5%85%B6%E4%BB%96%E6%9D%A1%E4%BB%B6"><span class="nav-number">4.1.</span> <span class="nav-text">等待一个事件或其他条件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6%E8%BE%BE%E6%88%90"><span class="nav-number">4.1.1.</span> <span class="nav-text">等待条件达成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E6%9E%84%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97"><span class="nav-number">4.1.2.</span> <span class="nav-text">使用条件变量构建线程安全队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%9F%E6%9C%9B%E7%AD%89%E5%BE%85%E4%B8%80%E6%AC%A1%E6%80%A7%E4%BA%8B%E4%BB%B6"><span class="nav-number">4.2.</span> <span class="nav-text">使用期望等待一次性事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1"><span class="nav-number">4.2.1.</span> <span class="nav-text">带返回值的后台任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E4%B8%8E%E6%9C%9F%E6%9C%9B"><span class="nav-number">4.2.2.</span> <span class="nav-text">任务与期望</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8std-promises"><span class="nav-number">4.2.3.</span> <span class="nav-text">使用std::promises</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E2%80%9C%E6%9C%9F%E6%9C%9B%E2%80%9D%E5%AD%98%E5%82%A8%E2%80%9C%E5%BC%82%E5%B8%B8%E2%80%9D"><span class="nav-number">4.2.4.</span> <span class="nav-text">为“期望”存储“异常”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AD%89%E5%BE%85"><span class="nav-number">4.2.5.</span> <span class="nav-text">多个线程的等待</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%90%E5%AE%9A%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4"><span class="nav-number">4.3.</span> <span class="nav-text">限定等待时间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%92%9F"><span class="nav-number">4.3.1.</span> <span class="nav-text">时钟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E5%BB%B6"><span class="nav-number">4.3.2.</span> <span class="nav-text">时延</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%82%B9"><span class="nav-number">4.3.3.</span> <span class="nav-text">时间点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E6%9C%89%E8%B6%85%E6%97%B6%E5%8A%9F%E8%83%BD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.4.</span> <span class="nav-text">具有超时功能的函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C"><span class="nav-number">5.</span> <span class="nav-text">C++内存模型和原子类型操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%92%8C%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.1.</span> <span class="nav-text">C++中的原子操作和原子类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.1.1.</span> <span class="nav-text">标准原子类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-atomic-flag%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="nav-number">5.1.2.</span> <span class="nav-text">std::atomic_flag的相关操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-atomic%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="nav-number">5.1.3.</span> <span class="nav-text">std::atomic的相关操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-atomic-%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="nav-number">5.1.4.</span> <span class="nav-text">std::atomic:指针运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E7%9A%84%E5%8E%9F%E5%AD%90%E6%95%B4%E5%9E%8B%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="nav-number">5.1.5.</span> <span class="nav-text">标准的原子整型的相关操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-atomic-lt-gt-%E4%B8%BB%E8%A6%81%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="nav-number">5.1.6.</span> <span class="nav-text">std::atomic&lt;&gt;主要类的模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E9%87%8A%E6%94%BE%E5%87%BD%E6%95%B0"><span class="nav-number">5.1.7.</span> <span class="nav-text">原子操作的释放函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%93%8D%E4%BD%9C%E5%92%8C%E5%BC%BA%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">5.2.</span> <span class="nav-text">同步操作和强制排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%8F%91%E7%94%9F"><span class="nav-number">5.2.1.</span> <span class="nav-text">同步发生</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F"><span class="nav-number">5.2.2.</span> <span class="nav-text">先行发生</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F"><span class="nav-number">5.2.3.</span> <span class="nav-text">原子操作的内存顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%E9%98%9F%E5%88%97%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="nav-number">5.2.4.</span> <span class="nav-text">释放队列与同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%85%E6%A0%8F"><span class="nav-number">5.2.5.</span> <span class="nav-text">栅栏</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">6.</span> <span class="nav-text">基于锁的并发数据结构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">6.1.</span> <span class="nav-text">基于锁的并发数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%A0%88%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E9%94%81"><span class="nav-number">6.1.1.</span> <span class="nav-text">线程安全栈——使用锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A0%E9%94%81%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">7.</span> <span class="nav-text">无锁并发数据结构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E6%84%8F%E4%B9%89"><span class="nav-number">7.1.</span> <span class="nav-text">定义和意义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">7.1.1.</span> <span class="nav-text">非阻塞数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E9%94%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">7.1.2.</span> <span class="nav-text">无锁数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E7%AD%89%E5%BE%85%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">7.1.3.</span> <span class="nav-text">无等待数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E9%94%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%A9%E4%B8%8E%E5%BC%8A"><span class="nav-number">7.1.4.</span> <span class="nav-text">无锁数据结构的利与弊</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E9%94%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">7.2.</span> <span class="nav-text">无锁数据结构的例子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E4%B8%80%E4%B8%AA%E6%97%A0%E9%94%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%A0%88"><span class="nav-number">7.2.1.</span> <span class="nav-text">写一个无锁的线程安全栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%9C%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%97%A0%E9%94%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98"><span class="nav-number">7.2.2.</span> <span class="nav-text">停止内存泄露：使用无锁数据结构管理内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E4%BD%BF%E7%94%A8%E9%A3%8E%E9%99%A9%E6%8C%87%E9%92%88-%E4%B8%8D%E5%8F%AF%E5%9B%9E%E6%94%B6-%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">7.2.3.</span> <span class="nav-text">检测使用风险指针(不可回收)的节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E4%BA%8E%E6%97%A0%E9%94%81%E6%A0%88%E4%B8%8A%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.2.4.</span> <span class="nav-text">应用于无锁栈上的内存模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1"><span class="nav-number">8.</span> <span class="nav-text">并发代码设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%88%92%E5%88%86%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%8A%80%E6%9C%AF"><span class="nav-number">8.1.</span> <span class="nav-text">线程间划分工作的技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%88%92%E5%88%86"><span class="nav-number">8.1.1.</span> <span class="nav-text">递归划分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%B1%E5%93%8D%E5%B9%B6%E5%8F%91%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="nav-number">8.2.</span> <span class="nav-text">影响并发代码性能的因素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%9F"><span class="nav-number">8.2.1.</span> <span class="nav-text">有多少个处理器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BA%89%E7%94%A8%E4%B8%8E%E4%B9%92%E4%B9%93%E7%BC%93%E5%AD%98"><span class="nav-number">8.2.2.</span> <span class="nav-text">数据争用与乒乓缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E5%85%B1%E4%BA%AB"><span class="nav-number">8.2.3.</span> <span class="nav-text">伪共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E6%95%B0%E6%8D%AE%E7%B4%A7%E5%87%91%EF%BC%9F"><span class="nav-number">8.2.4.</span> <span class="nav-text">如何让数据紧凑？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B6%85%E9%A2%9D%E8%AE%A4%E8%B4%AD%E5%92%8C%E9%A2%91%E7%B9%81%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2"><span class="nav-number">8.2.5.</span> <span class="nav-text">超额认购和频繁的任务切换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">8.3.</span> <span class="nav-text">为多线程性能设计数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E5%A4%8D%E6%9D%82%E6%93%8D%E4%BD%9C%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="nav-number">8.3.1.</span> <span class="nav-text">为复杂操作划分数组元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F"><span class="nav-number">8.3.2.</span> <span class="nav-text">其他数据结构中的数据访问模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%8F%91%E4%BB%A3%E7%A0%81%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">8.4.</span> <span class="nav-text">设计并发代码的注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8"><span class="nav-number">8.4.1.</span> <span class="nav-text">并行算法中的异常安全</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E5%AE%9E%E8%B7%B5%E4%B8%AD%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%8F%91%E4%BB%A3%E7%A0%81"><span class="nav-number">8.5.</span> <span class="nav-text">在实践中设计并发代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%AE%9E%E7%8E%B0%EF%BC%9Astd-for-each"><span class="nav-number">8.5.1.</span> <span class="nav-text">并行实现：std::for_each</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%AE%9E%E7%8E%B0%EF%BC%9Astd-find"><span class="nav-number">8.5.2.</span> <span class="nav-text">并行实现：std::find</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%AE%9E%E7%8E%B0%EF%BC%9Astd-partial-sum"><span class="nav-number">8.5.3.</span> <span class="nav-text">并行实现：std::partial_sum</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">高级线程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">9.1.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">9.1.1.</span> <span class="nav-text">最简单的线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E6%8F%90%E4%BA%A4%E5%88%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="nav-number">9.1.2.</span> <span class="nav-text">等待提交到线程池中的任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E4%BE%9D%E8%B5%96%E4%BB%BB%E5%8A%A1"><span class="nav-number">9.1.3.</span> <span class="nav-text">等待依赖任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%AB%9E%E4%BA%89"><span class="nav-number">9.1.4.</span> <span class="nav-text">避免队列中的任务竞争</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%83%E5%8F%96%E4%BB%BB%E5%8A%A1"><span class="nav-number">9.1.5.</span> <span class="nav-text">窃取任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B"><span class="nav-number">9.2.</span> <span class="nav-text">中断线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%92%8C%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B"><span class="nav-number">9.2.1.</span> <span class="nav-text">启动和中断线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%B8%AD%E6%96%AD"><span class="nav-number">9.2.2.</span> <span class="nav-text">检查线程是否中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8std-condition-variable-any%E4%B8%AD%E6%96%AD%E7%AD%89%E5%BE%85"><span class="nav-number">9.2.3.</span> <span class="nav-text">使用std::condition_variable_any中断等待</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%85%B6%E4%BB%96%E9%98%BB%E5%A1%9E%E8%B0%83%E7%94%A8"><span class="nav-number">9.2.4.</span> <span class="nav-text">中断其他阻塞调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%AD"><span class="nav-number">9.2.5.</span> <span class="nav-text">处理中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E9%80%80%E5%87%BA%E6%97%B6%E4%B8%AD%E6%96%AD%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1"><span class="nav-number">9.2.6.</span> <span class="nav-text">应用退出时中断后台任务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%93"><span class="nav-number">10.</span> <span class="nav-text">库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">10.1.</span> <span class="nav-text">头文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#std-condition-variable%E7%B1%BB"><span class="nav-number">10.1.1.</span> <span class="nav-text">std::condition_variable类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-condition-variable-any%E7%B1%BB"><span class="nav-number">10.1.2.</span> <span class="nav-text">std::condition_variable_any类</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
