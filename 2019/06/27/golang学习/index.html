<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zn-ch">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="golang," />










<meta name="description" content="开始学学golang这门伟大的语言。 结构Go的基础组成有以下几个部分：  包声明 引入包 函数 变量 语句 &amp; 表达式 注释  123456789package main&#x2F;* 包的名字是main，每个程序都有一个main的包  *&#x2F;import &quot;fmt&quot;&#x2F;* 需要fmt这个包  *&#x2F;func main() &amp;#123;   &#x2F;* 这是我的第一个简单的程序 *&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="golang学习">
<meta property="og:url" content="http://yoursite.com/2019/06/27/golang%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="开始学学golang这门伟大的语言。 结构Go的基础组成有以下几个部分：  包声明 引入包 函数 变量 语句 &amp; 表达式 注释  123456789package main&#x2F;* 包的名字是main，每个程序都有一个main的包  *&#x2F;import &quot;fmt&quot;&#x2F;* 需要fmt这个包  *&#x2F;func main() &amp;#123;   &#x2F;* 这是我的第一个简单的程序 *&#x2F;">
<meta property="og:locale" content="zn_CH">
<meta property="article:published_time" content="2019-06-27T09:47:15.000Z">
<meta property="article:modified_time" content="2022-10-01T04:03:34.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/06/27/golang学习/"/>





  <title>golang学习 | Hao Yu's blog</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/27/golang%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">golang学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-27T17:47:15+08:00">
                2019-06-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>开始学学golang这门伟大的语言。</p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>Go的基础组成有以下几个部分：</p>
<ul>
<li>包声明</li>
<li>引入包</li>
<li>函数</li>
<li>变量</li>
<li>语句 &amp; 表达式</li>
<li>注释</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">/* 包的名字是main，每个程序都有一个main的包  */</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">/* 需要fmt这个包  */</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   /* 这是我的第一个简单的程序 */</span><br><span class="line">   fmt.Println(&quot;Hello, World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（太奇葩了，竟然是以大小写作为权限控制的。）当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。</p>
<p>运行的话：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run hello.go</span><br></pre></td></tr></table></figure></p>
<p><strong>最奇葩的是 { 不能单独放在一行</strong></p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="行分隔符"><a href="#行分隔符" class="headerlink" title="行分隔符"></a>行分隔符</h2><p>在 Go 程序中，一行代表一个语句结束。每个语句不需要像C一样以分号结尾，因为这些工作都将由 Go 编译器自动完成。</p>
<p>标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母、数字、下划线组成的序列，但是第一个字符必须是字母或下划线而不能是数字。</p>
<p>Go 语言的字符串可以通过 + 实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;Google&quot; + &quot;Runoob&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>在 Go 编程语言中，数据类型用于声明函数和变量。</p>
<p>数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。</p>
<p>Go 语言按类别有以下几种数据类型：</p>
<ul>
<li>布尔型：布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。</li>
<li>数字类型：整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</li>
<li>字符串类型：字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</li>
<li>派生类型:<ul>
<li>(a) 指针类型（Pointer）</li>
<li>(b) 数组类型</li>
<li>(c) 结构化类型(struct)</li>
<li>(d) Channel 类型</li>
<li>(e) 函数类型</li>
<li>(f) 切片类型</li>
<li>(g) 接口类型（interface）</li>
<li>(h) Map 类型</li>
</ul>
</li>
</ul>
<h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>Go 也有基于架构的类型，例如：int、uint 和 uintptr。</p>
<ul>
<li>uint8：无符号 8 位整型 (0 到 255)</li>
<li>uint16：无符号 16 位整型 (0 到 65535)</li>
<li>uint32：无符号 32 位整型 (0 到 4294967295)</li>
<li>uint64：无符号 64 位整型 (0 到 18446744073709551615)</li>
<li>int8：有符号 8 位整型 (-128 到 127)</li>
<li>int16：有符号 16 位整型 (-32768 到 32767)</li>
<li>int32：有符号 32 位整型 (-2147483648 到 2147483647)</li>
<li>int64：有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</li>
</ul>
<p>浮点型</p>
<ul>
<li>float32：IEEE-754 32位浮点型数</li>
<li>float64：IEEE-754 64位浮点型数</li>
<li>complex64：32 位实数和虚数</li>
<li>complex128：64 位实数和虚数</li>
</ul>
<p>其他数字类型</p>
<ul>
<li>byte：类似 uint8</li>
<li>rune：类似 int32</li>
<li>uint：32 或 64 位</li>
<li>int：与 uint 一样大小</li>
<li>uintptr：无符号整型，用于存放一个指针</li>
</ul>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。</p>
<p>声明变量的一般形式是使用 var 关键字：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var identifier type</span><br></pre></td></tr></table></figure><br>可以一次声明多个变量：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var identifier1, identifier2 type</span><br></pre></td></tr></table></figure><br>实例<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var a string = &quot;Runoob&quot;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line"></span><br><span class="line">    var b, c int = 1, 2</span><br><span class="line">    fmt.Println(b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>第一种，指定变量类型，如果没有初始化，则变量默认为零值。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var v_name v_type</span><br><span class="line">v_name = value</span><br></pre></td></tr></table></figure><br>未初始化的时候：</p>
<ul>
<li>数值类型（包括complex64/128）为 0</li>
<li>布尔类型为 false</li>
<li>字符串为 “”（空字符串）</li>
<li>以下几种类型为 nil：<ul>
<li>var a *int</li>
<li>var a []int</li>
<li>var a map[string] int</li>
<li>var a chan int</li>
<li>var a func(string) int</li>
<li>var a error // error 是接口</li>
</ul>
</li>
</ul>
<p>第二种，根据值自行判定变量类型。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var v_name = value</span><br></pre></td></tr></table></figure><br>实例<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var d = true</span><br><span class="line">    fmt.Println(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第三种，省略 var, 注意 := 左侧如果没有声明新的变量，就产生编译错误，格式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v_name := value</span><br></pre></td></tr></table></figure><br>例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var intVal int </span><br><span class="line">intVal :=1 // 这时候会产生编译错误</span><br><span class="line">intVal,intVal1 := 1,2 // 此时不会产生编译错误，因为有声明新的变量，因为 := 是一个声明语句</span><br></pre></td></tr></table></figure><br>可以将 <code>var f string = &quot;Runoob&quot;</code> 简写为 <code>f := &quot;Runoob&quot;</code></p>
<p>实例<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    f := &quot;Runoob&quot; // var f string = &quot;Runoob&quot;</span><br><span class="line"></span><br><span class="line">    fmt.Println(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>多变量声明<br>//类型相同多个变量, 非全局变量<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var vname1, vname2, vname3 type</span><br><span class="line">vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line">var vname1, vname2, vname3 = v1, v2, v3 // 和 python 很像,不需要显示声明类型，自动推断</span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3 // 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误</span><br></pre></td></tr></table></figure></p>
<p>这种因式分解关键字的写法一般用于声明全局变量<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    vname1 v_type1</span><br><span class="line">    vname2 v_type2</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>可以在变量的初始化时省略变量的类型而由系统自动推断，声明语句写上 var 关键字其实是显得有些多余了，因此我们可以将它们简写为 a := 50 或 b := false。</p>
<p>a 和 b 的类型（int 和 bool）将由编译器自动推断。</p>
<p>这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。使用操作符 := 可以高效地创建一个新的变量，称之为初始化声明。</p>
<p>如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a := 20 就是不被允许的，编译器会提示错误 no new variables on left side of :=，但是 a = 20 是可以的，因为这是给相同的变量赋予一个新的值。</p>
<p>如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。</p>
<p><strong>如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误</strong></p>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。</p>
<p>常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p>
<p>常量的定义格式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const identifier [type] = value</span><br></pre></td></tr></table></figure><br>你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。</p>
<p>显式类型定义： const b string = “abc”<br>隐式类型定义： const b = “abc”<br>多个相同类型的声明可以简写为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const c_name1, c_name2 = value1, value2</span><br></pre></td></tr></table></figure></p>
<p>常量还可以用作枚举：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    Unknown = 0</span><br><span class="line">    Female = 1</span><br><span class="line">    Male = 2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>数字 0、1 和 2 分别代表未知性别、女性和男性。</p>
<p>常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过</p>
<h1 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h1><p>iota，特殊常量，可以认为是一个可以被编译器修改的常量。</p>
<p>iota 在 const 关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。</p>
<p>iota 可以被用作枚举值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    a = iota</span><br><span class="line">    b = iota</span><br><span class="line">    c = iota</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    a = iota</span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>iota 用法</p>
<p>实例<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    const (</span><br><span class="line">            a = iota   //0</span><br><span class="line">            b          //1</span><br><span class="line">            c          //2</span><br><span class="line">            d = &quot;ha&quot;   //独立值，iota += 1</span><br><span class="line">            e          //&quot;ha&quot;   iota += 1</span><br><span class="line">            f = 100    //iota +=1</span><br><span class="line">            g          //100  iota +=1</span><br><span class="line">            h = iota   //7,恢复计数</span><br><span class="line">            i          //8</span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上实例运行结果为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 ha ha 100 100 7 8</span><br></pre></td></tr></table></figure><br>再看个有趣的的 iota 实例：</p>
<p>实例<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">const (</span><br><span class="line">    i=1&lt;&lt;iota</span><br><span class="line">    j=3&lt;&lt;iota</span><br><span class="line">    k</span><br><span class="line">    l</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;i=&quot;,i)</span><br><span class="line">    fmt.Println(&quot;j=&quot;,j)</span><br><span class="line">    fmt.Println(&quot;k=&quot;,k)</span><br><span class="line">    fmt.Println(&quot;l=&quot;,l)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上实例运行结果为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i= 1</span><br><span class="line">j= 6</span><br><span class="line">k= 12</span><br><span class="line">l= 24</span><br></pre></td></tr></table></figure><br>iota 表示从 0 开始自动加 1，所以 i=1&lt;&lt;0, j=3&lt;&lt;1（&lt;&lt; 表示左移的意思），即：i=1, j=6，这没问题，关键在 k 和 l，从输出结果看 k=3&lt;&lt;2，l=3&lt;&lt;3。</p>
<p>简单表述:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=1：左移 0 位,不变仍为 1;</span><br><span class="line">j=3：左移 1 位,变为二进制 110, 即 6;</span><br><span class="line">k=3：左移 2 位,变为二进制 1100, 即 12;</span><br><span class="line">l=3：左移 3 位,变为二进制 11000,即 24。</span><br></pre></td></tr></table></figure></p>
<h1 id="部分运算符"><a href="#部分运算符" class="headerlink" title="部分运算符"></a>部分运算符</h1><p>假定 A 为60，B 为13：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;</code></td>
<td>按位与运算符”&amp;”是双目运算符。 其功能是参与运算的两数各对应的二进位相与。</td>
<td>(A &amp; B) 结果为 12, 二进制为 0000 1100</td>
</tr>
<tr>
<td>竖线或</td>
<td>按位或运算符是双目运算符。 其功能是参与运算的两数各对应的二进位相或。</td>
<td>(A 或 B) 结果为 61, 二进制为 0011 1101</td>
</tr>
<tr>
<td>^</td>
<td>按位异或运算符”^”是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。</td>
<td>(A ^ B) 结果为 49, 二进制为 0011 0001</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移运算符”&lt;&lt;”是双目运算符。左移n位就是乘以2的n次方。 其功能把”&lt;&lt;”左边的运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td>
<td>A &lt;&lt; 2 结果为 240 ，二进制为 1111 0000</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移运算符<code>&gt;&gt;</code>是双目运算符。右移n位就是除以2的n次方。 其功能是把<code>&gt;&gt;</code>左边的运算数的各二进位全部右移若干位，<code>&gt;&gt;</code>右边的数指定移动的位数。</td>
<td>A &gt;&gt; 2 结果为 15 ，二进制为 0000 1111</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>返回变量存储地址</td>
<td>&a; 将给出变量的实际地址。</td>
</tr>
<tr>
<td>*</td>
<td>指针变量。</td>
<td>*a; 是一个指针变量</td>
</tr>
</tbody>
</table>
</div>
<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><h2 id="if-语句的语法如下："><a href="#if-语句的语法如下：" class="headerlink" title="if 语句的语法如下："></a>if 语句的语法如下：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if 布尔表达式 &#123;</span><br><span class="line">   /* 在布尔表达式为 true 时执行 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If 在布尔表达式为 true 时，其后紧跟的语句块执行，如果为 false 则不执行。</p>
<p>Go 编程语言中 if…else 语句的语法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if 布尔表达式 &#123;</span><br><span class="line">   /* 在布尔表达式为 true 时执行 */</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  /* 在布尔表达式为 false 时执行 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>If 在布尔表达式为 true 时，其后紧跟的语句块执行，如果为 false 则执行 else 语句块。</p>
<p>Go 编程语言中 if…else 语句的语法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if 布尔表达式 1 &#123;</span><br><span class="line">   /* 在布尔表达式 1 为 true 时执行 */</span><br><span class="line">   if 布尔表达式 2 &#123;</span><br><span class="line">      /* 在布尔表达式 2 为 true 时执行 */</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上至下逐一测试，直到匹配为止。</p>
<p>switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加 break。</p>
<p>switch 默认情况下 case 最后自带 break 语句，匹配成功后就不会执行其他 case，如果我们需要执行后面的 case，可以使用 fallthrough 。</p>
<p>语法<br>Go 编程语言中 switch 语句的语法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch var1 &#123;</span><br><span class="line">    case val1:</span><br><span class="line">        ...</span><br><span class="line">    case val2:</span><br><span class="line">        ...</span><br><span class="line">    default:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。</p>
<p>您可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：case val1, val2, val3。</p>
<p>switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。</p>
<p>Type Switch 语法格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch x.(type)&#123;</span><br><span class="line">    case type:</span><br><span class="line">       statement(s);      </span><br><span class="line">    case type:</span><br><span class="line">       statement(s); </span><br><span class="line">    /* 你可以定义任意个数的case */</span><br><span class="line">    default: /* 可选 */</span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h2><p>使用 fallthrough 会强制执行后面的 case 语句，fallthrough 不会判断下一条 case 的表达式结果是否为 true。</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。</p>
<p>select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。</p>
<p>语法<br>Go 编程语言中 select 语句的语法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">    case communication clause  :</span><br><span class="line">       statement(s);      </span><br><span class="line">    case communication clause  :</span><br><span class="line">       statement(s); </span><br><span class="line">    /* 你可以定义任意数量的 case */</span><br><span class="line">    default : /* 可选 */</span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以下描述了 select 语句的语法：</p>
<ul>
<li>每个 case 都必须是一个通信</li>
<li>所有 channel 表达式都会被求值</li>
<li>所有被发送的表达式都会被求值</li>
<li>如果任意某个通信可以进行，它就执行，其他被忽略。</li>
<li>如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。 </li>
</ul>
<p>否则：</p>
<ul>
<li>如果有 default 子句，则执行该语句。</li>
<li>如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。</li>
</ul>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>Go语言的For循环有3中形式，只有其中的一种使用分号。</p>
<p>和 C 语言的 for 一样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for init; condition; post &#123; &#125;</span><br></pre></td></tr></table></figure><br>和 C 的 while 一样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for condition &#123; &#125;</span><br></pre></td></tr></table></figure><br>和 C 的 for(;;) 一样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>init： 一般为赋值表达式，给控制变量赋初值；</li>
<li>condition： 关系表达式或逻辑表达式，循环控制条件；</li>
<li>post： 一般为赋值表达式，给控制变量增量或减量。</li>
</ul>
<p>for语句执行过程如下：</p>
<ul>
<li>先对表达式1赋初值；</li>
<li>判别赋值表达式 init 是否满足给定条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition；</li>
<li>否则判断 condition 的值为假，不满足条件，就终止for循环，执行循环体外语句。</li>
</ul>
<p>for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for key, value := range oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h2><p>Go 语言循环语句 Go语言循环语句</p>
<p>Go 语言中 break 语句用于以下两方面：</p>
<ul>
<li>用于循环语句中跳出循环，并开始执行循环之后的语句。</li>
<li>break 在 switch（开关语句）中在执行一条case后跳出语句的作用。</li>
</ul>
<p>Go 语言的 continue 语句 有点像 break 语句。但是 continue 不是跳出循环，而是跳过当前循环执行下一次循环语句。</p>
<p>for 循环中，执行 continue 语句会触发for增量语句的执行。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数是基本的代码块，用于执行一个任务。</p>
<p>Go 语言最少有个 main() 函数。</p>
<p>你可以通过函数来划分不同功能，逻辑上每个函数执行的是指定的任务。函数声明告诉了编译器函数的名称，返回类型，和参数。</p>
<p>Go 语言标准库提供了多种可动用的内置的函数。例如，len() 函数可以接受不同类型参数并返回该类型的长度。如果我们传入的是字符串则返回字符串的长度，如果传入的是数组，则返回数组中包含的元素个数。</p>
<p>Go 语言函数定义格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func function_name( [parameter list] ) [return_types] &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>func：函数由 func 开始声明</li>
<li>function_name：函数名称，函数名和参数列表一起构成了函数签名。</li>
<li>parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li>
<li>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li>
<li>函数体：函数定义的代码集合。</li>
</ul>
<h2 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a><strong>函数返回多个值</strong></h2><p>Go 函数可以返回多个值，例如：</p>
<p>实例<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func swap(x, y string) (string, string) &#123;</span><br><span class="line">   return y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   a, b := swap(&quot;Google&quot;, &quot;Runoob&quot;)</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h2><p>传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</p>
<h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><p>引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
<p>引用传递指针参数传递到函数内，以下是交换函数 swap() 使用了引用传递：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* 定义交换值函数*/</span><br><span class="line">func swap(x *int, y *int) &#123;</span><br><span class="line">   var temp int</span><br><span class="line">   temp = *x    /* 保持 x 地址上的值 */</span><br><span class="line">   *x = *y      /* 将 y 值赋给 x */</span><br><span class="line">   *y = temp    /* 将 temp 值赋给 y */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数作为实参"><a href="#函数作为实参" class="headerlink" title="函数作为实参"></a>函数作为实参</h2><p>Go 语言可以很灵活的创建函数，并作为另外一个函数的实参。以下实例中我们在定义的函数中初始化一个变量，该函数仅仅是为了使用内置函数 math.sqrt()，实例为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">   &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">   /* 声明函数变量 */</span><br><span class="line">   getSquareRoot := func(x float64) float64 &#123;</span><br><span class="line">      return math.Sqrt(x)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /* 使用函数 */</span><br><span class="line">   fmt.Println(getSquareRoot(9))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数闭包"><a href="#函数闭包" class="headerlink" title="函数闭包"></a>函数闭包</h2><p>go支持匿名函数，可作为闭包。匿名函数是一个”内联”语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</p>
<p>以下实例中，我们创建了函数 getSequence() ，返回另外一个函数。该函数的目的是在闭包中递增 i 变量，代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func getSequence() func() int &#123;</span><br><span class="line">   i:=0</span><br><span class="line">   return func() int &#123;</span><br><span class="line">      i+=1</span><br><span class="line">     return i  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">   /* nextNumber 为一个函数，函数 i 为 0 */</span><br><span class="line">   nextNumber := getSequence()  </span><br><span class="line"></span><br><span class="line">   /* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   </span><br><span class="line">   /* 创建新的函数 nextNumber1，并查看结果 */</span><br><span class="line">   nextNumber1 := getSequence()  </span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。语法格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (variable_name variable_data_type) function_name() [return_type]&#123;</span><br><span class="line">   /* 函数体*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面定义一个结构体类型和该类型的一个方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;  </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">/* 定义结构体 */</span><br><span class="line">type Circle struct &#123;</span><br><span class="line">  radius float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  var c1 Circle</span><br><span class="line">  c1.radius = 10.00</span><br><span class="line">  fmt.Println(&quot;圆的面积 = &quot;, c1.getArea())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//该 method 属于 Circle 类型对象中的方法</span><br><span class="line">func (c Circle) getArea() float64 &#123;</span><br><span class="line">  //c.radius 即为 Circle 类型对象中的属性</span><br><span class="line">  return 3.14 * c.radius * c.radius</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><p>作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。</p>
<p>Go 语言中变量可以在三个地方声明：</p>
<ul>
<li>函数内定义的变量称为局部变量</li>
<li>函数外定义的变量称为全局变量</li>
<li>函数定义中的变量称为形式参数</li>
</ul>
<p>接下来让我们具体了解局部变量、全局变量和形式参数。</p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。</p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用。</p>
<p>Go 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑。</p>
<h2 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h2><p>形式参数会作为函数的局部变量来使用。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>Go 语言提供了数组类型的数据结构。</p>
<p>数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整形、字符串或者自定义类型。</p>
<p>相对于去声明 number0, number1, …, number99 的变量，使用数组形式 numbers[0], numbers[1] …, numbers[99] 更加方便且易于扩展。</p>
<p>数组元素可以通过索引（位置）来读取（或者修改），索引从 0 开始，第一个元素索引为 0，第二个索引为 1，以此类推。</p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>Go 语言支持多维数组，以下为常用的多维数组声明方式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type</span><br></pre></td></tr></table></figure><br>以下实例声明了三维的整型数组：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var threedim [5][10][4]int</span><br></pre></td></tr></table></figure><br>二维数组是最简单的多维数组，二维数组本质上是由一维数组组成的。二维数组定义方式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arrayName [ x ][ y ] variable_type</span><br></pre></td></tr></table></figure></p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>Go 语言的取地址符是<code>&amp;</code>，放到一个变量前使用就会返回相应变量的内存地址。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   var a int = 10   </span><br><span class="line"></span><br><span class="line">   fmt.Printf(&quot;变量的地址: %x\n&quot;, &amp;a  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>指针使用流程：</p>
<ul>
<li>定义指针变量。</li>
<li>为指针变量赋值。</li>
<li>访问指针变量中指向地址的值。</li>
</ul>
<p>在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。</p>
<h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p>当一个指针被定义后没有分配到任何变量时，它的值为 nil。nil 指针也称为空指针。nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。</p>
<p>一个指针变量通常缩写为 ptr。</p>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。</p>
<p>结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。</p>
<h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><p>结构体定义需要使用 type 和 struct 语句。struct 语句定义一个新的数据类型，结构体有中有一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type struct_variable_type struct &#123;</span><br><span class="line">   member definition;</span><br><span class="line">   member definition;</span><br><span class="line">   ...</span><br><span class="line">   member definition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一旦定义了结构体类型，它就能用于变量的声明，语法格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable_name := structure_variable_type &#123;value1, value2...valuen&#125;</span><br></pre></td></tr></table></figure><br>或<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable_name := structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以像其他数据类型一样将结构体类型作为参数传递给函数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func printBook( book Books ) &#123;</span><br><span class="line">   fmt.Printf( &quot;Book title : %s\n&quot;, book.title);</span><br><span class="line">   fmt.Printf( &quot;Book author : %s\n&quot;, book.author);</span><br><span class="line">   fmt.Printf( &quot;Book subject : %s\n&quot;, book.subject);</span><br><span class="line">   fmt.Printf( &quot;Book book_id : %d\n&quot;, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>Go 语言切片是对数组的抽象。</p>
<p>Go 数组的长度不可改变，因此提供了一种灵活，功能强悍的内置类型切片(“动态数组”),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</p>
<h2 id="定义切片"><a href="#定义切片" class="headerlink" title="定义切片"></a>定义切片</h2><p>你可以声明一个未指定大小的数组来定义切片：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var identifier []type</span><br></pre></td></tr></table></figure><br>切片不需要说明长度。</p>
<p>或使用make()函数来创建切片:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var slice1 []type = make([]type, len)</span><br></pre></td></tr></table></figure><br>也可以简写为<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice1 := make([]type, len)</span><br></pre></td></tr></table></figure><br>也可以指定容量，其中capacity为可选参数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make([]T, length, capacity)</span><br></pre></td></tr></table></figure><br>这里 len 是数组的长度并且也是切片的初始长度。</p>
<h2 id="切片初始化"><a href="#切片初始化" class="headerlink" title="切片初始化"></a>切片初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s :=[] int &#123;1,2,3 &#125; </span><br></pre></td></tr></table></figure>
<p>直接初始化切片，[]表示是切片类型，{1,2,3}初始化值依次是1,2,3.其cap=len=3<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[:] </span><br></pre></td></tr></table></figure><br>初始化切片s,是数组arr的引用<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[startIndex:endIndex] </span><br></pre></td></tr></table></figure><br>将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[startIndex:] </span><br></pre></td></tr></table></figure><br>缺省endIndex时将表示一直到arr的最后一个元素<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[:endIndex] </span><br></pre></td></tr></table></figure><br>缺省startIndex时将表示从arr的第一个元素开始<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 := s[startIndex:endIndex] </span><br></pre></td></tr></table></figure><br>通过切片s初始化切片s1<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s :=make([]int,len,cap) </span><br></pre></td></tr></table></figure><br>通过内置函数make()初始化切片s,[]int 标识为其元素类型为int的切片</p>
<h2 id="len-和-cap-函数"><a href="#len-和-cap-函数" class="headerlink" title="len() 和 cap() 函数"></a>len() 和 cap() 函数</h2><p>切片是可索引的，并且可以由 len() 方法获取长度。</p>
<p>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</p>
<h2 id="空-nil-切片"><a href="#空-nil-切片" class="headerlink" title="空(nil)切片"></a>空(nil)切片</h2><p>一个切片在未初始化之前默认为 nil，长度为 0.</p>
<h1 id="范围（range）"><a href="#范围（range）" class="headerlink" title="范围（range）"></a>范围（range）</h1><p> range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对的 key 值。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kvs := map[string]string&#123;&quot;a&quot;: &quot;apple&quot;, &quot;b&quot;: &quot;banana&quot;&#125;</span><br><span class="line">    for k, v := range kvs &#123;</span><br><span class="line">        fmt.Printf(&quot;%s -&gt; %s\n&quot;, k, v)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Map-集合"><a href="#Map-集合" class="headerlink" title="Map(集合)"></a>Map(集合)</h1><p>Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。</p>
<p>Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。</p>
<h2 id="定义-Map"><a href="#定义-Map" class="headerlink" title="定义 Map"></a>定义 Map</h2><p>可以使用内建函数 make 也可以使用 map 关键字来定义 Map:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* 声明变量，默认 map 是 nil */</span><br><span class="line">var map_variable map[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line">/* 使用 make 函数 */</span><br><span class="line">map_variable := make(map[key_data_type]value_data_type)</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var countryCapitalMap map[string]string /*创建集合 */</span><br><span class="line">    countryCapitalMap = make(map[string]string)</span><br><span class="line"></span><br><span class="line">    /* map插入key - value对,各个国家对应的首都 */</span><br><span class="line">    countryCapitalMap [ &quot;France&quot; ] = &quot;巴黎&quot;</span><br><span class="line">    countryCapitalMap [ &quot;Italy&quot; ] = &quot;罗马&quot;</span><br><span class="line">    countryCapitalMap [ &quot;Japan&quot; ] = &quot;东京&quot;</span><br><span class="line">    countryCapitalMap [ &quot;India &quot; ] = &quot;新德里&quot;</span><br></pre></td></tr></table></figure></p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>Go 语言支持递归。但我们在使用递归时，开发者需要设置退出条件，否则递归将陷入无限循环中。</p>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>类型转换用于将一种数据类型的变量转换为另外一种类型的变量。Go 语言类型转换基本格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type_name(expression)</span><br></pre></td></tr></table></figure><br>type_name 为类型，expression 为表达式。</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type interface_name interface &#123;</span><br><span class="line">   method_name1 [return_type]</span><br><span class="line">   method_name2 [return_type]</span><br><span class="line">   method_name3 [return_type]</span><br><span class="line">   ...</span><br><span class="line">   method_namen [return_type]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 定义结构体 */</span><br><span class="line">type struct_name struct &#123;</span><br><span class="line">   /* variables */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 实现接口方法 */</span><br><span class="line">func (struct_name_variable struct_name) method_name1() [return_type] &#123;</span><br><span class="line">   /* 方法实现 */</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">func (struct_name_variable struct_name) method_namen() [return_type] &#123;</span><br><span class="line">   /* 方法实现*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>Go 语言通过内置的错误接口提供了非常简单的错误处理机制。</p>
<p>error类型是一个接口类型，这是它的定义：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type error interface &#123;</span><br><span class="line">    Error() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以在编码中通过实现 error 接口类型来生成错误信息。</p>
<p>函数通常在最后的返回值中返回错误信息。使用errors.New 可返回一个错误信息：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func Sqrt(f float64) (float64, error) &#123;</span><br><span class="line">    if f &lt; 0 &#123;</span><br><span class="line">        return 0, errors.New(&quot;math: square root of negative number&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在下面的例子中，我们在调用Sqrt的时候传递的一个负数，然后就得到了non-nil的error对象，将此对象与nil比较，结果为true，所以fmt.Println(fmt包在处理error时会调用Error方法)被调用，以输出错误，请看下面调用的示例代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result, err:= Sqrt(-1)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">   fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>Go 语言支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。</p>
<p>goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。</p>
<p>goroutine 语法格式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go 函数名( 参数列表 )</span><br></pre></td></tr></table></figure><br>例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go f(x, y, z)</span><br></pre></td></tr></table></figure><br>开启一个新的 goroutine:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x, y, z)</span><br></pre></td></tr></table></figure><br>Go 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine 共享同一个地址空间。</p>
<h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h1><p>通道（channel）是用来传递数据的一个数据结构。</p>
<p>通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 &lt;- 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    // 把 v 发送到通道 ch</span><br><span class="line">v := &lt;-ch  // 从 ch 接收数据</span><br><span class="line">           // 并把值赋给 v</span><br></pre></td></tr></table></figure></p>
<p>声明一个通道很简单，我们使用chan关键字即可，通道在使用前必须先创建：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int)</span><br></pre></td></tr></table></figure><br>注意：默认情况下，通道是不带缓冲区的。发送端发送数据，同时必须又接收端相应的接收数据。</p>
<p>以下实例通过两个 goroutine 来计算数字之和，在 goroutine 完成计算后，它会计算两个结果的和：</p>
<h2 id="通道缓冲区"><a href="#通道缓冲区" class="headerlink" title="通道缓冲区"></a>通道缓冲区</h2><p>通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int, 100)</span><br></pre></td></tr></table></figure></p>
<p>带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。</p>
<p>不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。</p>
<p>注意：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</p>
<h2 id="遍历通道与关闭通道"><a href="#遍历通道与关闭通道" class="headerlink" title="遍历通道与关闭通道"></a>遍历通道与关闭通道</h2><p>Go 通过 range 关键字来实现遍历读取到的数据，类似于与数组或切片。格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure><br>如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 close() 函数来关闭。</p>
<h1 id="Go语言并发之道1-3章"><a href="#Go语言并发之道1-3章" class="headerlink" title="Go语言并发之道1-3章"></a>Go语言并发之道1-3章</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性是指一个操作在运行的环境中是不可被分割的或不可被中断的。操作的原子性是根据当前定义的范围而改变的，上下文不同则一个操作可能不是原子性的。</p>
<p>使一个操作变为原子操作取决于你想让它在哪个上下文中，如果上下文是没有并发的，则该代码是原子性的。</p>
<h3 id="内存访问同步"><a href="#内存访问同步" class="headerlink" title="内存访问同步"></a>内存访问同步</h3><p>程序中需要独占访问共享资源的部分叫做“临界区”，看一个例子<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var memoryAccess sync.Mutex</span><br><span class="line">    var value int</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        memoryAccess.Lock()</span><br><span class="line">        value++</span><br><span class="line">        memoryAccess.Unlock()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    memoryAccess.Lock()</span><br><span class="line">    if value == 0 &#123;</span><br><span class="line">        fmt.Printf(&quot;the value is %v.\n&quot;, value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fmt.Printf(&quot;the value is %v.\n&quot;, value)</span><br><span class="line">    &#125;</span><br><span class="line">    memoryAccess.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们添加了一个sync.Mutex类型，声明一下在哪个部分里应该独占value这个变量。如果想要访问value这个变量，就要首先调用Lock，当访问结束后，调用Unlock。当然，也可能造成维护和性能的问题。</p>
<h3 id="defer关键字"><a href="#defer关键字" class="headerlink" title="defer关键字"></a>defer关键字</h3><p>defer代码块会在函数调用链表中增加一个函数调用。这个函数调用不是普通的函数调用，而是会在函数正常返回，也就是return之后添加一个函数调用。因此，defer通常用来释放函数内部变量。</p>
<h4 id="当defer被声明时，其参数就会被实时解析"><a href="#当defer被声明时，其参数就会被实时解析" class="headerlink" title="当defer被声明时，其参数就会被实时解析"></a>当defer被声明时，其参数就会被实时解析</h4><p>我们通过以下代码来解释这条规则:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func a() &#123;</span><br><span class="line">	i := 0</span><br><span class="line">	defer fmt.Println(i)</span><br><span class="line">	i++</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>虽然我们在defer后面定义的是一个带变量的函数: fmt.Println(i). 但这个变量在defer被声明的时候，就已经确定其确定的值了。 换言之，上面的代码等同于下面的代码:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func a() &#123;</span><br><span class="line">	i := 0</span><br><span class="line">	defer fmt.Println(0) //因为i=0，所以此时就明确告诉golang在程序退出时，执行输出0的操作</span><br><span class="line">	i++</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了更为明确的说明这个问题，我们继续定义一个defer:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func a() &#123;</span><br><span class="line">	i := 0</span><br><span class="line">	defer fmt.Println(i) //输出0，因为i此时就是0</span><br><span class="line">	i++</span><br><span class="line">	defer fmt.Println(i) //输出1，因为i此时就是1</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过运行结果，可以看到defer输出的值，就是定义时的值。而不是defer真正执行时的变量值(很重要，搞不清楚的话就会产生于预期不一致的结果)</p>
<p>但为什么是先输出1，在输出0呢？ 看下面的规则二。</p>
<h4 id="defer执行顺序为先进后出"><a href="#defer执行顺序为先进后出" class="headerlink" title="defer执行顺序为先进后出"></a>defer执行顺序为先进后出</h4><p>当同时定义了多个defer代码块时，golang安装先定义后执行的顺序依次调用defer。不要为什么，golang就是这么定义的。我们用下面的代码加深记忆和理解:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func b() &#123;</span><br><span class="line">	for i := 0; i &lt; 4; i++ &#123;</span><br><span class="line">		defer fmt.Print(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在循环中，依次定义了四个defer代码块。结合规则一，我们可以明确得知每个defer代码块应该输出什么值。 安装先进后出的原则，我们可以看到依次输出了3210.</p>
<h4 id="defer可以读取有名返回值"><a href="#defer可以读取有名返回值" class="headerlink" title="defer可以读取有名返回值"></a>defer可以读取有名返回值</h4><p>先看下面的代码:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func c() (i int) &#123;</span><br><span class="line">	defer func() &#123; i++ &#125;()</span><br><span class="line">	return 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出结果是12. 在开头的时候，我们说过defer是在return调用之后才执行的。 这里需要明确的是defer代码块的作用域仍然在函数之内，结合上面的函数也就是说，defer的作用域仍然在c函数之内。因此defer仍然可以读取c函数内的变量(如果无法读取函数内变量，那又如何进行变量清除呢….)。</p>
<p>当执行return 1 之后，i的值就是1. 此时此刻，defer代码块开始执行，对i进行自增操作。 因此输出2.</p>
<p>掌握了defer以上三条使用规则，那么当我们遇到defer代码块时，就可以明确得知defer的预期结果。</p>
<h3 id="死锁、活锁、饥饿"><a href="#死锁、活锁、饥饿" class="headerlink" title="死锁、活锁、饥饿"></a>死锁、活锁、饥饿</h3><p>死锁是所有并发进程等待的程序，在这种情况下，如果没有外界干预，这个程序将无法恢复。</p>
<h4 id="Coffman条件"><a href="#Coffman条件" class="headerlink" title="Coffman条件"></a>Coffman条件</h4><p>出现死锁的条件有以下几个必要条件：</p>
<ul>
<li>相互排斥：并发进程同时拥有资源的独占权</li>
<li>等待条件：并发进程必须同时拥有一个资源，并等待额外的资源</li>
<li>没有抢占：并发进程拥有的资源只能被该进程释放</li>
<li>循环等待：一个并发进程只能等待一系列其他并发进程，这些并发进程也在等待</li>
</ul>
<h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>正在主动执行并发操作的程序，但是无法向前推进程序的状态。看起来程序在工作。</p>
<h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>在任何情况下，并发进程欧步伐获得执行工作所需的所有资源。饥饿通常意味着有一个或多个贪婪的并发进程，它们不公平地阻止一个或多个并发进程，以尽可能地有效完成工作，或者阻止全部并发进程。</p>
<h2 id="通信顺序进程"><a href="#通信顺序进程" class="headerlink" title="通信顺序进程"></a>通信顺序进程</h2><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p>并行属于一个运行中的程序，并发属于代码。</p>
<h3 id="并发哲学"><a href="#并发哲学" class="headerlink" title="并发哲学"></a>并发哲学</h3><p>CSP即Communicating Sequential Process，通信顺序进程。</p>
<p>Go的运行时自动将goroutine映射到系统的线程上，并管理调度，因此可以在像goroutine阻塞等待IO之类的事情上进行内省，从而智能的把OS的线程分配到没有阻塞的goroutine上。</p>
<p>如果有一块产生计算结果并想共享结果给其他代码块的代码，则需要传递数据的所有权。并发程序安全就是保证同时只有一个并发上下文拥有数据的所有权。通过channel类型解决，可以创建一个带缓存的channel实现低成本的在内存中的队列来解耦生产者和消费者。</p>
<p>使用channel时可以更简单的控制软件中出现的复杂性。</p>
<h2 id="并发组件"><a href="#并发组件" class="headerlink" title="并发组件"></a>并发组件</h2><h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><p>每个Go程序中都有至少一个goroutine： main goroutine。goroutine是一个并发的函数，在一个函数前添加go关键字来触发。匿名函数也行：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go func() &#123;</span><br><span class="line">	fmt.Println(&quot;hello&quot;)</span><br><span class="line">&#125; ()</span><br></pre></td></tr></table></figure><br>函数赋值也行：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sayhello := func() &#123;</span><br><span class="line">	fmt.Println(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go sayhello()</span><br></pre></td></tr></table></figure></p>
<p>go中的goroutine是一个更高级别的抽象，称为<strong>协程</strong>，一中非抢占式的简单并发子程序，不能被中断，允许暂停或重入。Go的运行时会观察goroutine的运行时行为，并在它们阻塞时自动挂起它们，然后在它们不被阻塞时自动恢复它们。</p>
<p>go的主机托管机制是一个名为M:N调度器的实现。将M个绿色线程映射到N个OS线程，然后将goroutine安排在绿色线程上。</p>
<p>go遵循一个fork-join并发模型，将执行的子分支与其父节点同时运行，这些并发的执行分支将会在未来合并在一起。为了创建一个join点，必须对程序进行同步，这里可以通过sync.Watigroup实现。</p>
<p>在下边这个程序中，输出的是“world”，因此可以说明goroutine在它们所创建的相同地址空间内执行。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    salutation := &quot;hello&quot;</span><br><span class="line">    wg.Add(1)</span><br><span class="line">    go func()&#123;</span><br><span class="line">        defer wg.Done()</span><br><span class="line">        salutation = &quot;world&quot;</span><br><span class="line">    &#125;()</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(salutation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>可以以如下方式将参数传到函数中，以输出正确结果。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for _, salt := range []string&#123;&quot;hello&quot;, &quot;greetings&quot;, &quot;good day&quot;&#125; &#123;</span><br><span class="line">    wg.Add(1)</span><br><span class="line">    go func(salt string) &#123;</span><br><span class="line">        defer wg.Done()</span><br><span class="line">        fmt.Println(salt)</span><br><span class="line">    &#125; (salt)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="sync包"><a href="#sync包" class="headerlink" title="sync包"></a>sync包</h3><p>sync包包含了对低级别内存访问同步最有用的并发原语。</p>
<h4 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h4><p>可以调用Add表明n个goroutine已经开始了，使用defer关键字确保在goroutine退出之前执行Done操作。执行Wait操作将会阻塞main goroutine直到所有goroutine表明它们已经退出。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">wg.Add(1)</span><br><span class="line">go func() &#123;</span><br><span class="line">    defer wg.Done()</span><br><span class="line">    fmt.Println(&quot;1st goroutine sleeping&quot;)</span><br><span class="line">    time.Sleep(1)</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line">wg.Add(1)</span><br><span class="line">go func() &#123;</span><br><span class="line">    defer wg.Done()</span><br><span class="line">    fmt.Println(&quot;2nd goroutine sleeping&quot;)</span><br><span class="line">    time.Sleep(2)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(&quot;All goroutine complete&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>WaitGroup调用通过传入的整数执行Add操作增加计数器的增量，并<strong>调用Done递减</strong>，Wait阻塞，直到计数器为0.</p>
<h4 id="互斥锁和读写锁"><a href="#互斥锁和读写锁" class="headerlink" title="互斥锁和读写锁"></a>互斥锁和读写锁</h4><p>channel通过通信共享内存，而Mutex通过开发人员的约定同步访问共享内存。</p>
<p>Mutex有两个函数，Lock和Unlock，在defer中调用Unlock保证即使出现了panic，也可以及时调用Unlock，避免死锁。</p>
<p>进入和退出一个临界区是有开销的，所以要减少临界区的范围，可能存在多个并发进程之间共享内存，但这些进程不是都需要读写此内存，可以利用不同类型的互斥对象，sync.RWMutex。可以请求一个锁用于读或者写。</p>
<h4 id="cond"><a href="#cond" class="headerlink" title="cond"></a>cond</h4><p>cond是一个goroutine的集合点，等待或发布一个event，在这里一个event是两个或两个以上的goroutine之间的任意信号。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">c.L.Lock()</span><br><span class="line">for conditionTrue() == false &#123;</span><br><span class="line">	c.Wait()</span><br><span class="line">&#125;</span><br><span class="line">c.L.Unlock()</span><br></pre></td></tr></table></figure><br>上述代码实例化一个cond，NewCond创建一个类型，cond类型能够以一种并发安全的方式与其他goroutine协调。</p>
<p>Broadcast提供了同时与多个goroutine通信的方法，在Clicked Cond上调用Broadcast，则所有三个函数都将运行。它内部维护一个FIFO列表，等待接收信号，向所有等待的goroutine发送信号。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    type Button struct &#123;</span><br><span class="line">        Clicked *sync.Cond</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    button := Button&#123; Clicked: sync.NewCond(&amp;sync.Mutex&#123;&#125;)  &#125;</span><br><span class="line">    subscribe := func(c *sync.Cond, fn func()) &#123;</span><br><span class="line">        var goroutineRunning sync.WaitGroup</span><br><span class="line">        goroutineRunning.Add(1)</span><br><span class="line">        go func()&#123;</span><br><span class="line">            goroutineRunning.Done()</span><br><span class="line">            c.L.Lock()</span><br><span class="line">            defer c.L.Unlock()</span><br><span class="line">            c.Wait()</span><br><span class="line">            fn()</span><br><span class="line">        &#125;()</span><br><span class="line">        goroutineRunning.Wait()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var clickRegistered sync.WaitGroup</span><br><span class="line">    clickRegistered.Add(3)</span><br><span class="line">    subscribe(button.Clicked, func() &#123;</span><br><span class="line">        fmt.Println(&quot;Maximizing window&quot;)</span><br><span class="line">        clickRegistered.Done()</span><br><span class="line">    &#125;)</span><br><span class="line">    subscribe(button.Clicked, func() &#123;</span><br><span class="line">        fmt.Println(&quot;Displaying annoying dialog box!&quot;)</span><br><span class="line">        clickRegistered.Done()</span><br><span class="line">    &#125;)</span><br><span class="line">    subscribe(button.Clicked, func() &#123;</span><br><span class="line">    fmt.Println(&quot;Mouse clicked&quot;)</span><br><span class="line">    clickRegistered.Done()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    button.Clicked.Broadcast()</span><br><span class="line">    clickRegistered.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="once"><a href="#once" class="headerlink" title="once"></a>once</h4><p>sync.Once在内部调用一些原语，确保即使在不同的goroutine上也只会调用一次Do方法处理传进来的函数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var count int</span><br><span class="line">increment := func() &#123;count++&#125;</span><br><span class="line">decrement := func() &#123;count--&#125;</span><br><span class="line"></span><br><span class="line">var once sync.Once</span><br><span class="line">once.Do(increment)</span><br><span class="line">once.Do(decrement)</span><br></pre></td></tr></table></figure><br>上述程序输出的是<strong>1</strong>，因为once只计算Do调用的次数，不管Do函数里边的参数是什么。</p>
<h3 id="池"><a href="#池" class="headerlink" title="池"></a>池</h3><p>Pool模式是一种创建和提供可供使用的固定数量实例或Pool实例的方法，用于约束创建昂贵的场景，以便只创建固定数量的实例，但不确定数量的操作仍然可以请求访问这些场景。</p>
<p>Pool的主接口是Get方法，首先检查池中是否有可用的实例，如果没有则调用new方法创建一个，完成时调用者调用Put方法将实例归还。</p>
<p>Pool也用来尽可能快地将预先分配的对象缓存加载启动，通过提前加载获取引用到另一个对象所需的时间，来节省消费者的时间。</p>
<ul>
<li>实例化sync.Pool时，使用new方法创建一个成员变量，在调用时是线程安全的。</li>
<li>收到来自Get的实例时，不要对接收的对象的状态做出任何假设。</li>
<li>当你用完了从Pool中取出的对象时一定要调用Put否则Pool无法复用这个实例。</li>
<li>Pool内的分布大致均匀。</li>
</ul>
<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>channel充当着信息传送的管道，值可以沿着channel传递。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var dataStream chan interface&#123;&#125;</span><br><span class="line">dataStream = make(chan interface&#123;&#125;)</span><br></pre></td></tr></table></figure><br>上面声明了一个新channel，因为声明的类型是空接口，所以类型是interface{}，并且使用内置的make函数实例化channel。</p>
<p>声明一个单向channel只需包含“&lt;-”，声明一个只能读取的channel，将“&lt;-”放在左边：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var dataStream &lt;-chan interface&#123;&#125;</span><br><span class="line">dataStream = make(&lt;-chan interface&#123;&#125;)</span><br></pre></td></tr></table></figure></p>
<p>声明一个只能发送的channel，则将“&lt;-”放在右边。</p>
<p>通过将“&lt;-”放到channel的右边实现发送操作，通过将“&lt;-”放到channel的左边实现接收操作。另一种方法是数据流向箭头所指方向的变量。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stringStream := make(chan string)</span><br><span class="line">go func()&#123;</span><br><span class="line">	stringStream &lt;- &quot;hello&quot;</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(&lt;-stringStream)</span><br></pre></td></tr></table></figure><br>上述代码实现了将字符串文本传递到stringStream channel并读取channel的字符串并打印到stdout。</p>
<p>可以从channel中获取，然后通过range遍历，并且在channel关闭时自动中断循环：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">intStream := make(chan int)</span><br><span class="line">go func() &#123;</span><br><span class="line">    defer close(intStream)</span><br><span class="line">    for i:= 1; i &lt;= 5; i ++ &#123;</span><br><span class="line">        intStream &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line">for integer := range intStream &#123;</span><br><span class="line">    fmt.Printf(&quot;%v &quot;,integer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>关闭channel也是一种同时给多个goroutine发信号的方法，如果有n个goroutine在一个channel上等待，而不是在channel上写n次来打开每个goroutine，可以简单地关闭channel。</p>
<p>更可以创建buffered channel，在实例化时提供容量。即使没有在channel上执行读取操作，goroutine仍然可以写入n次。</p>
<p>如果说channel是满的，那么写入channel阻塞。无缓冲的channel容量为0，因此在任何写入之前就已经满了，缓冲channel是一个内存中的FIFO队列，用于并发进程通信。</p>
<p>我们需要在正确的环境中配置channel，channel的所有者对channel拥有写访问视图，使用者只有读访问视图。拥有channel的goroutine应该：</p>
<ol>
<li>实例化channel；</li>
<li>执行写操作，或将所有权传递给另一个goroutine；</li>
<li>关闭channel</li>
<li>通过只读channel将上述三件事暴露出来。</li>
</ol>
<h3 id="select-1"><a href="#select-1" class="headerlink" title="select"></a>select</h3><p>select是将channel绑定在一起的粘合剂，在一个系统中两个或多个组件的交集中，可以在本地、单个函数或类型以及全局范围内找到select语句绑定在一起的channel。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var c1, c2 &lt;-chan interface&#123;&#125;</span><br><span class="line">var c3 chan&lt;- interface&#123;&#125;</span><br><span class="line">select &#123;</span><br><span class="line">	case &lt;- c1:</span><br><span class="line">		....</span><br><span class="line">	case &lt;- c2:</span><br><span class="line">		....</span><br><span class="line">	case &lt;- c3:</span><br><span class="line">		....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果多个channel是可用的，则执行伪随机选择，每一个都可能被执行到。如果没有任何channel可用，则我们需要使用time包中的超时机制，time.After。</p>
<h3 id="GOMAXPROCS控制"><a href="#GOMAXPROCS控制" class="headerlink" title="GOMAXPROCS控制"></a>GOMAXPROCS控制</h3><p>这是runtime中的一个函数，这个函数控制的OS线程的数量将承载所谓的“工作队列”。runtime.GOMAXPROCS总是被设置成为主机上逻辑CPU的数量。</p>
<h1 id="Go语言并发之道第4章"><a href="#Go语言并发之道第4章" class="headerlink" title="Go语言并发之道第4章"></a>Go语言并发之道第4章</h1><p>提示：interface{}可用于向函数传递任意类型的变量，但对于函数内部，该变量仍然为interface{}类型（空接口类型），</p>
<h2 id="Go的并发模式"><a href="#Go的并发模式" class="headerlink" title="Go的并发模式"></a>Go的并发模式</h2><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>约束是一种确保了信息只能从一个并发过程中获取到的简单且强大的方法，特定约束是指通过公约实现约束，词法约束涉及使用词法作用域仅公开用于多个并发进程的正确数据和并发原语。</p>
<h3 id="for-select循环"><a href="#for-select循环" class="headerlink" title="for-select循环"></a>for-select循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">	// 要不就无限循环，要不就使用range循环</span><br><span class="line">	select &#123;</span><br><span class="line">		//使用channel作业</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="向channel发送迭代变量"><a href="#向channel发送迭代变量" class="headerlink" title="向channel发送迭代变量"></a>向channel发送迭代变量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for _, s := range []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125; &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">		case &lt;- done:</span><br><span class="line">			return</span><br><span class="line">		case stringStream &lt;- s: </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="循环等待停止"><a href="#循环等待停止" class="headerlink" title="循环等待停止"></a>循环等待停止</h4><p>创建循环，无限直至停止。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">		case &lt;- done:</span><br><span class="line">			return</span><br><span class="line">		default:</span><br><span class="line">	&#125;</span><br><span class="line">	// 非抢占式任务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="防止goroutine泄露"><a href="#防止goroutine泄露" class="headerlink" title="防止goroutine泄露"></a>防止goroutine泄露</h3><p>main goroutine可能会在其生命周期内将其他的goroutine设置为自旋，导致内存利用率下降。减轻这种情况的方法是在父goroutine和子goroutine之间建立一个信号，让父goroutine向其子goroutine发出信号通知。父goroutine将该channel发送给子goroutine，然后在想要取消子goroutine时关闭该channel。</p>
<p>确保：如果goroutine负责创建goroutine，那么它也负责确保可以停止goroutine。</p>
<h3 id="or-channel"><a href="#or-channel" class="headerlink" title="or-channel"></a>or-channel</h3><p>使用or-channel模式将多个channel组合起来。通过递归和goroutine创建一个符合done channel</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    var or func(channels ...&lt;-chan interface&#123;&#125;) &lt;-chan interface&#123;&#125;</span><br><span class="line">    or = func(channels ...&lt;-chan interface&#123;&#125;) &lt;-chan interface&#123;&#125; &#123;</span><br><span class="line">        switch len(channels) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                return nil</span><br><span class="line">            case 1:</span><br><span class="line">                return channels[0]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        orDone := make(chan interface&#123;&#125;)</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer close()</span><br><span class="line">            switch len(channels):</span><br><span class="line">                case 2:</span><br><span class="line">                    select&#123;</span><br><span class="line">                        case &lt;-channels[0]:</span><br><span class="line">                        case &lt;-channels[1]:</span><br><span class="line">                        case &lt;-channels[1]:</span><br><span class="line">                        case &lt;-channels[2]:</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">type Result struct &#123;</span><br><span class="line">    Error error</span><br><span class="line">    Response *http.Response</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">    checkStatus := func(</span><br><span class="line">        done &lt;-chan interface&#123;&#125;,</span><br><span class="line">        urls ...string,</span><br><span class="line">    ) &lt;-chan Result &#123;</span><br><span class="line">        results := make(chan Result)</span><br><span class="line">        go func()&#123;</span><br><span class="line">            defer close(results)</span><br><span class="line">            for _, url := range urls &#123;</span><br><span class="line">                var result Result</span><br><span class="line">                resp, err := http.Get(url)</span><br><span class="line">                result = Result&#123;Error: err, Response: resp&#125;</span><br><span class="line">                select &#123;</span><br><span class="line">                    case &lt;-done:</span><br><span class="line">                        return</span><br><span class="line">                    case results &lt;-result:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        return results</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done := make(chan interface&#123;&#125;)</span><br><span class="line">    defer close(done)</span><br><span class="line">    urls := []string&#123;&quot;https://www.baidu.com&quot;, &quot;https://badhost&quot;&#125;</span><br><span class="line">    for result := range checkStatus(done, urls...)&#123;</span><br><span class="line">        if result.Error != nil &#123;</span><br><span class="line">            fmt.Printf(&quot;Error: %v.\n&quot;, result.Error)</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(&quot;Response: %v.\n&quot;, result.Response.Status)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3><p>一个stage是将数据输入，对其进行转换并将数据发回。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">multiply := func(values []int, len(values)) []int &#123;&#125;</span><br><span class="line">add := func(values []int, additive int) []int &#123;&#125;</span><br><span class="line"></span><br><span class="line">ints := []int&#123;1, 2, 3, 4&#125;</span><br><span class="line">for _, v := range add(multiply(ints, 2), 1) &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在range子句中结合加法和乘法，这样构建了一个具有pipeline stage的属性，组合形成pipeline。</p>
<p>pipeline stage的属性是：</p>
<ul>
<li>一个stage消耗并返回相同的类型；</li>
<li>一个stage必须用语言来表达，以便可以被传递；</li>
</ul>
<p>channel适合在Go中构建pipeline，可以接受和产生值，且可以安全的使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    generator := func(done &lt;-chan interface&#123;&#125;, integers ...int) &lt;-chan int &#123;</span><br><span class="line">        intStream := make(chan int)</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer close(intStream)</span><br><span class="line">            for _, i := range integers &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;-done:</span><br><span class="line">                    return</span><br><span class="line">                case intStream &lt;- i:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        return intStream</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    multiply := func(done &lt;-chan interface&#123;&#125;, intStream &lt;-chan int, multiplier int) &lt;-chan int &#123;</span><br><span class="line">        multipliedStream := make(chan int)</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer close(multipliedStream)</span><br><span class="line">            for i := range intStream &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;-done:</span><br><span class="line">                    return</span><br><span class="line">                case multipliedStream &lt;- i * multiplier:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        return multipliedStream</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add := func(done &lt;-chan interface&#123;&#125;, intStream &lt;-chan int, additive int) &lt;-chan int &#123;</span><br><span class="line"></span><br><span class="line">        addedStream := make(chan int)</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer close(addedStream)</span><br><span class="line">            for i := range intStream &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;-done:</span><br><span class="line">                    return</span><br><span class="line">                case addedStream &lt;- i + additive:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        return addedStream</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done := make(chan interface&#123;&#125;)</span><br><span class="line">    defer close(done)</span><br><span class="line"></span><br><span class="line">    intStream := generator(done, 1, 2, 3, 4)</span><br><span class="line">    pipeline := multiply(done, add(done, multiply(done, intStream, 2), 1), 2)</span><br><span class="line"></span><br><span class="line">    for v := range pipeline &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>挺有意思的，显示了流水线的操作。</p>
<p>generator接受一个可变的整数切片，构造一个缓存长度等于输入片段的整数channel，启动goroutine并返回构造的channel，将一组离散值转化成一个channel上的数据流。</p>
<h3 id="扇入扇出"><a href="#扇入扇出" class="headerlink" title="扇入扇出"></a>扇入扇出</h3><p>扇出是描述启动多个goroutine以处理来自pipeline的输入的过程；扇入是描述将多个结果组合到一个channel的过程中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">primeStream := primeFinder(done, randIntStream)</span><br><span class="line"></span><br><span class="line">numFinders := runtime.NumCPU()</span><br><span class="line">finders := make([]&lt;-chan int, numFinders)</span><br><span class="line">for i := 0; i &lt; numFinders; i ++ &#123;</span><br><span class="line">	finders[i] = primeFinder(done, randIntStream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里启动了stage的多个副本，有n个goroutine从随机数发生器中拉出并试图确定数字是否为素数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">package pips</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type PrimePip struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewPrimePip() *PrimePip &#123;</span><br><span class="line">    primePip := &amp;PrimePip&#123;&#125;</span><br><span class="line">    return primePip</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (primePip *PrimePip) RepeatFn(</span><br><span class="line">    done &lt;-chan interface&#123;&#125;,</span><br><span class="line">    fn func() interface&#123;&#125;,</span><br><span class="line">) &lt;-chan interface&#123;&#125; &#123;</span><br><span class="line">    valueStream := make(chan interface&#123;&#125;)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer close(valueStream)</span><br><span class="line">        for &#123;</span><br><span class="line">            select &#123;</span><br><span class="line">            case &lt;-done:</span><br><span class="line">                return</span><br><span class="line">            case valueStream &lt;- fn():</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return valueStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (primePip *PrimePip) Take(</span><br><span class="line">    done &lt;-chan interface&#123;&#125;,</span><br><span class="line">    valueStream &lt;-chan interface&#123;&#125;,</span><br><span class="line">    num int,</span><br><span class="line">) &lt;-chan interface&#123;&#125; &#123;</span><br><span class="line">    takeStream := make(chan interface&#123;&#125;)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer close(takeStream)</span><br><span class="line">        for i := 0; i &lt; num; i++ &#123;</span><br><span class="line">            select &#123;</span><br><span class="line">            case &lt;-done:</span><br><span class="line">                return</span><br><span class="line">            case takeStream &lt;- &lt;-valueStream:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return takeStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (primePip *PrimePip) ToInt(</span><br><span class="line">    done &lt;-chan interface&#123;&#125;,</span><br><span class="line">    valueStream &lt;-chan interface&#123;&#125;,</span><br><span class="line">) &lt;-chan int &#123;</span><br><span class="line">    intStream := make(chan int)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer close(intStream)</span><br><span class="line">        for v := range valueStream &#123;</span><br><span class="line">            select &#123;</span><br><span class="line">            case &lt;-done:</span><br><span class="line">                return</span><br><span class="line">            case intStream &lt;- v.(int):</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return intStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (primePip *PrimePip) PrimeFinder(</span><br><span class="line">    done &lt;-chan interface&#123;&#125;,</span><br><span class="line">    intStream &lt;-chan int,</span><br><span class="line">) &lt;-chan interface&#123;&#125; &#123;</span><br><span class="line">    primeStream := make(chan interface&#123;&#125;)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer close(primeStream)</span><br><span class="line">        for integer := range intStream &#123;</span><br><span class="line">            integer -= 1</span><br><span class="line">            prime := true</span><br><span class="line">            for divisor := integer - 1; divisor &gt; 1; divisor-- &#123;</span><br><span class="line">                if integer%divisor == 0 &#123;</span><br><span class="line">                    prime = false</span><br><span class="line">                    break</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if prime &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;-done:</span><br><span class="line">                    return</span><br><span class="line">                case primeStream &lt;- integer:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return primeStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (primePip *PrimePip) FanIn(</span><br><span class="line">    done &lt;-chan interface&#123;&#125;,</span><br><span class="line">    channels ...&lt;-chan interface&#123;&#125;,</span><br><span class="line">) &lt;-chan interface&#123;&#125; &#123;</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    multiplexedStream := make(chan interface&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    multiplexed := func(c &lt;-chan interface&#123;&#125;) &#123;</span><br><span class="line">        defer wg.Done()</span><br><span class="line">        for i := range c &#123;</span><br><span class="line">            select &#123;</span><br><span class="line">            case &lt;-done:</span><br><span class="line">                return</span><br><span class="line">            case multiplexedStream &lt;- i:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Add(len(channels))</span><br><span class="line">    for _, c := range channels &#123;</span><br><span class="line">        go multiplexed(c)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        wg.Wait()</span><br><span class="line">        close(multiplexedStream)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    return multiplexedStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="or-done-channel"><a href="#or-done-channel" class="headerlink" title="or-done-channel"></a>or-done-channel</h3><p>用于处理来自系统各个分散部分的channel，需要用channel中的select语句来包装我们的读操作，并从已完成的channel中进行选择。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">orDone := func(done, c &lt;-chan interface&#123;&#125;) &lt;-chan interface&#123;&#125; &#123;</span><br><span class="line">	valStream := make(chan interface&#123;&#125;)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		defer close(valStream)</span><br><span class="line">		for &#123;</span><br><span class="line">			select &#123;</span><br><span class="line">				case &lt;-done:</span><br><span class="line">					return </span><br><span class="line">				case v, ok := &lt;-c:</span><br><span class="line">				if ok == false&#123;</span><br><span class="line">					return</span><br><span class="line">				&#125;</span><br><span class="line">				select &#123;</span><br><span class="line">					case valStream &lt;- v:</span><br><span class="line">					case &lt;-done:</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; ()</span><br><span class="line">	return valStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tee-channel"><a href="#tee-channel" class="headerlink" title="tee-channel"></a>tee-channel</h3><p>分割一个来自channel的值，以便将他们发送到代码的两个独立区域。</p>
<h3 id="队列排队"><a href="#队列排队" class="headerlink" title="队列排队"></a>队列排队</h3><p>在队列尚未准备好的时候开始接受请求，只要stage完成了工作，就会把结果存放在一个稍后其他stage可以获取到的临时位置。</p>
<ul>
<li>在一个stage批处理请求节省时间</li>
<li>如果stage中的延迟产生反馈回路进入系统。</li>
</ul>
<h3 id="context包"><a href="#context包" class="headerlink" title="context包"></a>context包</h3><p>主要包括：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Canceled = errors.New(&quot;context canceled&quot;)</span><br><span class="line">var DeadlineExceeded error = deadlineExceededError&#123;&#125;</span><br><span class="line"></span><br><span class="line">type CancelFunc</span><br><span class="line">type Context</span><br><span class="line"></span><br><span class="line">func Background() Context</span><br><span class="line">func TODO() Context</span><br><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</span><br><span class="line">func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)</span><br><span class="line">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</span><br><span class="line">func WithValue(parent Context, key, val interface&#123;&#125;) Context</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>上下文包有两个目的：</p>
<ul>
<li>提供可以取消调用图中分支的API</li>
<li>提供用于通过呼叫传输请求范围数据的数据包</li>
</ul>
<p>context类型将是函数的第一个参数，此外，接收context的函数并不能取消它，这保护了调用堆栈上的函数被子函数取消上下文的情况。</p>
<p>上述context包中的函数都接收一个Context参数，并返回一个Context。WithCancel返回新Context，它在调用返回的cancel函数时关闭其done channel。WithDeadline返回一个新的Context，当机器的时钟超过给定的最后期限时，它关闭完成的channel。WithTimeout返回一个新的Context，它在给定的超时时间后关闭完成的channel。</p>
<p>如果函数以某种方式在调用图中取消它后面的函数，它将调用其中一个函数并传递给它的上下文，然后将返回的上下文传递给它的子元素，如果函数不需要修改取消行为，则只传递给定的上下文。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    defer cancel() </span><br><span class="line">    wg.Add(1)</span><br><span class="line">    </span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer wg.Done()</span><br><span class="line">        if err := printGreeting(ctx); err != nil &#123;</span><br><span class="line">            fmt.Printf(&quot;cannot print greeting: %v\n&quot;, err)</span><br><span class="line">            cancel()</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;() </span><br><span class="line">    </span><br><span class="line">    wg.Add(1)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer wg.Done()</span><br><span class="line">        if err := printFarewell(ctx); err != nil &#123;</span><br><span class="line">            fmt.Printf(&quot;cannot print greeting: %v\n&quot;, err)</span><br><span class="line">            cancel()</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;() </span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">func printGreeting(ctx context.Context) error &#123;</span><br><span class="line">    greeting, err := genGreeting(ctx)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;%s world!\n&quot;, greeting)</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printFarewell(ctx context.Context) error &#123;</span><br><span class="line">    farewell, err := genFarewell(ctx)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;%s world!\n&quot;, farewell)</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func genGreeting(ctx context.Context) (string, error) &#123;</span><br><span class="line">    ctx, cancel := context.WithTimeout(ctx, 1*time.Second)</span><br><span class="line">    defer cancel()</span><br><span class="line">    switch locale, err := locale(ctx); &#123;</span><br><span class="line">    case err != nil:</span><br><span class="line">        return &quot;&quot;, err</span><br><span class="line">    case locale == &quot;EN/US&quot;:</span><br><span class="line">        return &quot;hello&quot;, nil</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;&quot;, fmt.Errorf(&quot;unsupported locale&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func genFarewell(ctx context.Context) (string, error) &#123;</span><br><span class="line">    switch locale, err := locale(ctx); &#123;</span><br><span class="line">    case err != nil:</span><br><span class="line">        return &quot;&quot;, err</span><br><span class="line">    case locale == &quot;EN/US&quot;:</span><br><span class="line">        return &quot;godbye&quot;, nil</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;&quot;, fmt.Errorf(&quot;unsupported locale&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func locale(ctx context.Context) (string, error) &#123;</span><br><span class="line">    if deadline, ok := ctx.Deadline(); ok &#123;</span><br><span class="line">        if deadline.Sub(time.Now().Add(1*time.Minute)) &lt;= 0 &#123;</span><br><span class="line">            return &quot;&quot;, context.DeadlineExceeded</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-ctx.Done():</span><br><span class="line">        return &quot;&quot;, ctx.Err()</span><br><span class="line">    case &lt;-time.After(1 * time.Minute):</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;EN/US&quot;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述程序允许locale函数快速失败，不必实际等待超时发生。</p>
<p>context包的另一个功能是用于存储和检索请求范围数据的Context数据包。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func ProcessRequest(userID, authToken string) &#123;</span><br><span class="line">    ctx := context.WithValue(context.Background(), &quot;userID&quot;, userID)</span><br><span class="line">    ctx = context.WithValue(ctx, &quot;authToken&quot;, authToken)</span><br><span class="line"></span><br><span class="line">    HandleResponse(ctx)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func HandleResponse(ctx context.Context) &#123;</span><br><span class="line">    fmt.Printf(&quot;handling response for %v (%v)\n&quot;, ctx.Value(&quot;userID&quot;), ctx.Value(&quot;authToken&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<ul>
<li>我们使用的键值必须满足Go的可比性概念，即==和!=在使用时需要返回正确的结果。</li>
<li>返回值必须安全，才能从多个goroutine访问</li>
</ul>
<p>由于context的键和值都被定义为interface{}，所以当试图检索值时，我们会失去Go的类型安全性，key可以是不同的类型，或者与我们提供的key略有不同。建议在软件包里定义一个自定义键类型：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type foo int</span><br><span class="line">type bar int</span><br><span class="line"></span><br><span class="line">m := make(map[interface&#123;&#125;] int)</span><br><span class="line">m[foo(1)] = 1</span><br><span class="line">m[bar(1)] = 1</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%v&quot;, m)</span><br></pre></td></tr></table></figure></p>
<p>输出为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[1:1, 2:2]</span><br></pre></td></tr></table></figure></p>
<p>虽然基础值是相同的，但是科通通过不同的类型信息在map中区分它们。</p>
<h1 id="Go语言并发之道第5章"><a href="#Go语言并发之道第5章" class="headerlink" title="Go语言并发之道第5章"></a>Go语言并发之道第5章</h1><h2 id="异常传递"><a href="#异常传递" class="headerlink" title="异常传递"></a>异常传递</h2><p>我们需要对传入的异常信息进行传递和处理，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func PostReport(id string) error &#123;</span><br><span class="line">	result, err := lowlevel.DoWork()</span><br><span class="line">	if err != nil&#123;</span><br><span class="line">		if _, ok := err.(lowlevel.Error); ok &#123;</span><br><span class="line">			err = WrapErr(err, &quot;cannot post report with id %q&quot;, id)</span><br><span class="line">		&#125;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里检查接收到的异常信息，确保结构良好，使用一个假设的函数将传入的异常和模块相关信息封装起来，并赋予一个新类型。</p>
<p>创建一个异常类型：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">type MyError struct &#123;</span><br><span class="line">    Inner      error</span><br><span class="line">    Message    string</span><br><span class="line">    StackTrace string</span><br><span class="line">    Misc       map[string]interface&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func wrapError(err error, messagef string, msgArgs ...interface&#123;&#125;) MyError &#123;</span><br><span class="line">    return MyError&#123;</span><br><span class="line">        Inner:      err,</span><br><span class="line">        Message:    fmt.Sprintf(messagef, msgArgs...),</span><br><span class="line">        StackTrace: &quot;stack!!!&quot;,</span><br><span class="line">        Misc:       make(map[string]interface&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (err MyError) Error() string &#123;</span><br><span class="line">    return err.Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type LowLevelErr struct &#123;</span><br><span class="line">    error</span><br><span class="line">&#125;</span><br><span class="line">func isGloballyExec(path string) (bool, error) &#123;</span><br><span class="line">    info, err := os.Stat(path)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return false, LowLevelErr&#123;(wrapError(err, err.Error()))&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return info.Mode().Perm()&amp;0100 == 0100, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type IntermediateErr struct &#123;</span><br><span class="line">    error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func runJob(id string) error &#123;</span><br><span class="line">    const jobBinPath = &quot;/bad/job/binary&quot;</span><br><span class="line">    isExecutable, err := isGloballyExec(jobBinPath)</span><br><span class="line"></span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return IntermediateErr&#123;wrapError(err, &quot;cannot run job %q: requisite binaries not available&quot;, id)&#125;</span><br><span class="line">    &#125; else if isExecutable == false &#123;</span><br><span class="line">        return wrapError(nil, &quot;job binary is not executable&quot;, id)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return exec.Command(jobBinPath, &quot;--id=&quot;+id).Run()</span><br><span class="line">&#125;</span><br><span class="line">func handleError(key int, err error, message string) &#123;</span><br><span class="line">    log.SetPrefix(fmt.Sprintf(&quot;[logID: %v]: &quot;, key))</span><br><span class="line">    log.Printf(&quot;%#v&quot;, err)</span><br><span class="line">    fmt.Printf(&quot;[%v] %v&quot;, key, message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    log.SetOutput(os.Stdout)</span><br><span class="line">    log.SetFlags(log.Ltime | log.LUTC)</span><br><span class="line">    err := runJob(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        msg := &quot;There was an unexpected issue; please report this as a bug.&quot;</span><br><span class="line">        if _, ok := err.(IntermediateErr); ok &#123;</span><br><span class="line">            msg = err.Error()</span><br><span class="line">        &#125;</span><br><span class="line">        handleError(1, err, msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="超时和取消"><a href="#超时和取消" class="headerlink" title="超时和取消"></a>超时和取消</h2><p>有几个原因使我们需要支持超时：</p>
<ol>
<li>系统饱和：希望超出的请求返回超时，而不是花很长时间等待响应。请求在超时时不太可能重复，或没有资源来存储请求，或者对系统响应或请求发送数据有时效性的要求时，需要超时操作。</li>
<li>陈旧的数据：数据通常有窗口期，如果并发进程处理数据需要的时间比这个窗口期长，则会想返回超时并取消并发进程。可以使用context.WithDeadline或者context.WithTimeout创建的context.Context传递给并发进程。</li>
<li>试图防止死锁：为了防止死锁，建议在所有并发操作中增加超时操作。</li>
</ol>
<h2 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h2><p>有两种不同的心跳：</p>
<ul>
<li>一段时间间隔内发出的心跳</li>
<li>在工作单元开始时发出的心跳</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    doWork := func(</span><br><span class="line">        done &lt;-chan interface&#123;&#125;,</span><br><span class="line">        pulseInterval time.Duration,</span><br><span class="line">    ) (&lt;-chan interface&#123;&#125;, &lt;-chan time.Time) &#123;</span><br><span class="line"></span><br><span class="line">// 建立一个发送心跳的channel，返回给doWork</span><br><span class="line"></span><br><span class="line">        heartbeat := make(chan interface&#123;&#125;)</span><br><span class="line">        results := make(chan time.Time)</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer close(heartbeat)</span><br><span class="line">            defer close(results)</span><br><span class="line"></span><br><span class="line">            pulse := time.Tick(pulseInterval)</span><br><span class="line">            workGen := time.Tick(2 * pulseInterval)</span><br><span class="line">// 设定心跳间隔</span><br><span class="line">            sendPulse := func() &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case heartbeat &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class="line">                default:</span><br><span class="line">                // 可能没有人接收心跳，所以加一个default</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sendResult := func(r time.Time) &#123;</span><br><span class="line">                for &#123;</span><br><span class="line">                    select &#123;</span><br><span class="line">                    case &lt;-done:</span><br><span class="line">                        return</span><br><span class="line">                    case &lt;-pulse:</span><br><span class="line">                        sendPulse()</span><br><span class="line">                    case results &lt;- r:</span><br><span class="line">                        return</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;-done:</span><br><span class="line">                    return</span><br><span class="line">                case &lt;-pulse:</span><br><span class="line">                    sendPulse()</span><br><span class="line">                case r := &lt;-workGen:</span><br><span class="line">                    sendResult(r)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        return heartbeat, results</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done := make(chan interface&#123;&#125;)</span><br><span class="line">    time.AfterFunc(10*time.Second, func() &#123; close(done) &#125;)</span><br><span class="line"></span><br><span class="line">    const timeout = 2 * time.Second</span><br><span class="line">    // 设置了超时时间</span><br><span class="line">    heartbeat, results := doWork(done, timeout/2)</span><br><span class="line">    // timeout/2 使我们的心跳有额外的响应时间</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        // 处理心跳，如果没有消息时，至少timeout/2后会从心跳channel发出一条消息</span><br><span class="line">        case _, ok := &lt;-heartbeat:</span><br><span class="line">            if ok == false &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(&quot;pulse&quot;)</span><br><span class="line">        case r, ok := &lt;-results:</span><br><span class="line">            if ok == false &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(&quot;result %v\n&quot;, r.Second())</span><br><span class="line">        case &lt;-time.After(timeout):</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以下是每个工作单元开始之前发出的心跳<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    doWork := func(</span><br><span class="line">        done &lt;-chan interface&#123;&#125;,</span><br><span class="line">    ) (&lt;-chan interface&#123;&#125;, &lt;-chan int) &#123;</span><br><span class="line">        heartbeatStream := make(chan interface&#123;&#125;, 1)</span><br><span class="line">// 创建一个缓冲区大小为1的heartbeat channel，确保了即使没有及时接收发送消息也能发出一个心跳</span><br><span class="line"></span><br><span class="line">        workStream := make(chan int)</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer close(heartbeatStream)</span><br><span class="line">            defer close(workStream)</span><br><span class="line"></span><br><span class="line">            for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case heartbeatStream &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class="line">                default:</span><br><span class="line">                &#125;</span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;-done:</span><br><span class="line">                    return</span><br><span class="line">                case workStream &lt;- rand.Intn(10):</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">// 这里为心跳设置了单独的select块，将发送result和发送心跳分开，如果接收者没有准备好接受结果，作为替代它将收到一个心跳，而代表当前结果的值将会丢失。</span><br><span class="line">// 为了防止没人接收心跳，增加了default，因为我们的heart channel创建时有一个缓冲区，所以如果有人正在监听暗示没有及时收到第一个心跳，接收者也可以收到心跳。     </span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        return heartbeatStream, workStream</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done := make(chan interface&#123;&#125;)</span><br><span class="line">    defer close(done)</span><br><span class="line"></span><br><span class="line">    heartbeat, results := doWork(done)</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case _, ok := &lt;-heartbeat:</span><br><span class="line">            if ok == false &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fmt.Println(&quot;pulse&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        case r, ok := &lt;-results:</span><br><span class="line">            if ok == false &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fmt.Printf(&quot;result %v\n&quot;, r)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>一些外部因素会导致goroutine花费更长的时间来进行第一次迭代，无论goroutine在调度上是否是第一位执行的。使用goroutine来解决这个问题。</p>
<h2 id="复制请求"><a href="#复制请求" class="headerlink" title="复制请求"></a>复制请求</h2><p>可以将请求分发到多个处理程序，其中一个将比其他处理程序返回更快，可以立即返回结果。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    doWork := func(</span><br><span class="line">        done &lt;-chan interface&#123;&#125;,</span><br><span class="line">        id int,</span><br><span class="line">        wg *sync.WaitGroup,</span><br><span class="line">        result chan&lt;- int,</span><br><span class="line">    ) &#123;</span><br><span class="line">        started := time.Now()</span><br><span class="line">        defer wg.Done()</span><br><span class="line"></span><br><span class="line">        simulatedLoadTime := time.Duration(1+rand.Intn(5)) * time.Second</span><br><span class="line">        select &#123;</span><br><span class="line">        case &lt;-done:</span><br><span class="line">        case &lt;-time.After(simulatedLoadTime):</span><br><span class="line">        &#125;</span><br><span class="line">        select &#123;</span><br><span class="line">        case &lt;-done:</span><br><span class="line">        case result &lt;- id:</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        took := time.Since(started)</span><br><span class="line">        if took &lt; simulatedLoadTime &#123;</span><br><span class="line">            took = simulatedLoadTime</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(&quot;%v took %v.\n&quot;, id, took)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done := make(chan interface&#123;&#125;)</span><br><span class="line">    result := make(chan int)</span><br><span class="line"></span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    wg.Add(10)</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        go doWork(done, i, &amp;wg, result)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    firstReturned := &lt;-result</span><br><span class="line">    close(done)</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;Received an answer from #%v.\n&quot;, firstReturned)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这里我们启动了10个处理程序来处理请求，并获得了第一个返回值，如果得到了第一个返回值，则取消其它的处理程序，以保证不会做多余的工作。</p>
<h2 id="速率限制"><a href="#速率限制" class="headerlink" title="速率限制"></a>速率限制</h2><p>速率限制允许你将系统的性能和稳定性平衡在可控范围内。Go中大多数的限速是基于令牌算法的。</p>
<p>如果要访问资源，必须拥有资源的访问令牌，没有令牌的请求会被拒绝。假设令牌存储在一个等待被检索使用的桶中，桶的深度是d，表示一个桶可以容纳d个访问令牌。</p>
<p>每当需要访问资源时，都会在桶中删除一个令牌，请求必须排队等待直到有令牌可以用，或者被拒绝操作。将r定义为向桶中添加令牌的速率。只要用户拥有可用的令牌，集中的请求可能会使用户突破系统的可用范围。有些用户会间歇性访问系统，但是又想要尽可能快的获得结果，就会出现突发性的事件，只需要确保系统能同时处理所有用户的突发请求，或者在统计上不会有太多用户同时突发访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">func Open() *APIConnection &#123;</span><br><span class="line">    return &amp;APIConnection&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type APIConnection struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (a *APIConnection) ReadFile(ctx context.Context) error &#123;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *APIConnection) ResolveAddress(ctx context.Context) error &#123;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    defer log.Printf(&quot;Done.&quot;)</span><br><span class="line">    log.SetOutput(os.Stdout)</span><br><span class="line">    log.SetFlags(log.Ltime | log.LUTC)</span><br><span class="line"></span><br><span class="line">    apiConnection := Open()</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    wg.Add(20)</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer wg.Done()</span><br><span class="line">            err := apiConnection.ReadFile(context.Background())</span><br><span class="line">            if err != nil &#123;</span><br><span class="line">                log.Printf(&quot;cannot ReadFile: %v&quot;, err)</span><br><span class="line">            &#125;</span><br><span class="line">            log.Printf(&quot;ReadFile&quot;)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer wg.Done()</span><br><span class="line">            err := apiConnection.ResolveAddress(context.Background())</span><br><span class="line">            if err != nil &#123;</span><br><span class="line">                log.Printf(&quot;cannot ResolveAddress: %v&quot;, err)</span><br><span class="line">            &#125;</span><br><span class="line">            log.Printf(&quot;ResolveAddress&quot;)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的API请求同时进行，没有进行限速，所以客户端可以自由访问系统，下面引入限速器，把限速器放在APIConnection中。这里用到了<code>golang.org/x/time/rate</code>包中的令牌桶限速器实现，具体安装如下：</p>
<p><code>golang.org/x</code>包放到了<code>https://github.com/golang/time.git</code>中，下载时需要先在本地建立<code>golang.org/x</code>的目录后，再下载。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p golang.org/x</span><br><span class="line">git clone https://github.com/golang/time.git</span><br></pre></td></tr></table></figure><br>我们使用了这个包的两个部分，分别是Limit类型和NewLimiter函数。Limit表示某个事件的最大频率，每秒事件数；NewLimiter返回一个新的Limit，允许事件速率为r，并允许最大为b的token。</p>
<p>rate包也包含一个辅助方法Every，将时间间隔转换为Limit。针对每次操作的间隔时间进行测量：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Per(eventCount int, duration time.Duration) rate.Limit &#123;</span><br><span class="line">    return rate.Every(duration / time.Duration(eventCount))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>创建rate.Limiter后，使用它来阻塞我们的请求，直到获得访问令牌，使用Wait实现。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (lim *Limiter) Wait(ctx context.Context) </span><br><span class="line">// Wait是WaitN(ctx, 1)的缩写</span><br><span class="line">// WaitN会执行直到有n个事件发生，</span><br><span class="line">// 如果n超过Limiter的突发大小，ctx被取消，或者逾期等待时间超过context的deadline，会返回一个错误</span><br><span class="line"></span><br><span class="line">func (lim *Limiter) WaitN(ctx context.Context, n int) (err error)</span><br></pre></td></tr></table></figure></p>
<p>修改后的APIConnection：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func Open() *APIConnection &#123;</span><br><span class="line">    return &amp;APIConnection&#123;</span><br><span class="line">        rateLimiter: rate.NewLimiter(rate.Limit(1), 1),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type APIConnection struct &#123;</span><br><span class="line">    rateLimiter *rate.Limiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *APIConnection) ReadFile(ctx context.Context) error &#123;</span><br><span class="line">    if err := a.rateLimiter.Wait(ctx); err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *APIConnection) ResolveAddress(ctx context.Context) error &#123;</span><br><span class="line">    if err := a.rateLimiter.Wait(ctx); err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    defer log.Printf(&quot;Done.&quot;)</span><br><span class="line">    log.SetOutput(os.Stdout)</span><br><span class="line">    log.SetFlags(log.Ltime | log.LUTC)</span><br><span class="line"></span><br><span class="line">    apiConnection := Open()</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    wg.Add(20)</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer wg.Done()</span><br><span class="line">            err := apiConnection.ReadFile(context.Background())</span><br><span class="line">            if err != nil &#123;</span><br><span class="line">                log.Printf(&quot;cannot ReadFile: %v&quot;, err)</span><br><span class="line">            &#125;</span><br><span class="line">            log.Printf(&quot;ReadFile&quot;)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer wg.Done()</span><br><span class="line">            err := apiConnection.ResolveAddress(context.Background())</span><br><span class="line">            if err != nil &#123;</span><br><span class="line">                log.Printf(&quot;cannot ResolveAddress: %v&quot;, err)</span><br><span class="line">            &#125;</span><br><span class="line">            log.Printf(&quot;ResolveAddress&quot;)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样实现了所有API连接的速率限制为每秒一次。</p>
<p>聚合限速器：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">type RateLimiter interface &#123;</span><br><span class="line">    Wait(context.Context) error</span><br><span class="line">    Limit() rate.Limit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func MultiLimiter(limiters ...RateLimiter) *multiLimiter &#123;</span><br><span class="line">    byLimit := func(i, j int) bool &#123;</span><br><span class="line">        return limiters[i].Limit() &lt; limiters[j].Limit()</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Slice(limiters, byLimit)</span><br><span class="line">    return &amp;multiLimiter&#123;limiters: limiters&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type multiLimiter struct &#123;</span><br><span class="line">    limiters []RateLimiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (l *multiLimiter) Wait(ctx context.Context) error &#123;</span><br><span class="line">    for _, l := range l.limiters &#123;</span><br><span class="line">        if err := l.Wait(ctx); err != nil &#123;</span><br><span class="line">            return err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (l *multiLimiter) Limit() rate.Limit &#123;</span><br><span class="line">    return l.limiters[0].Limit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义了一个RateLimiter接口，使MultiLimiter可以递归定义其他的MultiLimiter实例，并且实现了一个优化，根据每个RateLimiter的Limit()排序，可以直接返回限制最多的限制器，这将是切片（slice）的第一个元素。</p>
<p>Wait犯法会遍历所有的子限速器，并调用Wait。</p>
<p>可以考虑增加对API请求的限制，对磁盘的限制：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func Open() *APIConnection &#123;</span><br><span class="line">    return &amp;APIConnection&#123;</span><br><span class="line">        apiLimit: MultiLimiter(</span><br><span class="line">            rate.NewLimiter(Per(2, time.Second), 2)</span><br><span class="line">            rate.NewLimiter(Per(10, time.Minute), 10),</span><br><span class="line">            ),</span><br><span class="line">        diskLimit: MultiLimiter(</span><br><span class="line">            rate.NewLimiter(rate.Limit(1), 1)</span><br><span class="line">            ),</span><br><span class="line">        networkLimit: MultiLimiter(</span><br><span class="line">            rate.NewLimiter(Per(3, time.Second), 3),</span><br><span class="line">            ),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *APIConnection) ReadFile(ctx context.Context) error &#123;</span><br><span class="line">    if err := MultiLimiter(a.apiLimit,a.diskLimit).Wait(ctx); err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *APIConnection) ResolveAddress(ctx context.Context) error &#123;</span><br><span class="line">    if err := MultiLimiter(a.apiLimit,a.diskLimit).Wait(ctx); err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>上面为API调用和磁盘读取设置了限速器。</p>
<h2 id="治愈异常的goroutine"><a href="#治愈异常的goroutine" class="headerlink" title="治愈异常的goroutine"></a>治愈异常的goroutine</h2><p>建立一个机制来监控goroutine是否处于健康的状态，当它们变得异常时就可以尽快重启。需要使用心跳模式来检查正在监控的goroutine是否活跃，心跳的类型取决于想要监控的内容，如果goroutine有可能会产生活锁，需要确保心跳包含某些信息，表明goroutine正在工作而不是只是活着。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">type startGoroutineFn func(</span><br><span class="line">    done &lt;-chan interface&#123;&#125;,</span><br><span class="line">    pulseInterval time.Duration,</span><br><span class="line">) (heartbeat &lt;-chan interface&#123;&#125;)</span><br><span class="line">//定义一个可以监控和重启goroutine的信号。</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    newSteward := func(</span><br><span class="line">        timeout time.Duration,</span><br><span class="line">        startGoroutine startGoroutineFn,</span><br><span class="line">    ) startGoroutineFn &#123;</span><br><span class="line">        return func(</span><br><span class="line">            done &lt;-chan interface,</span><br><span class="line">            pulseInterval time.Duration,</span><br><span class="line">// 监控goroutine需要timeout变量，一个函数startGoroutineFn表示管理员本身也是可监控的</span><br><span class="line"></span><br><span class="line">        ) (&lt;-chan interface&#123;&#125;) &#123; </span><br><span class="line">            heartbeat :=make(chan interface&#123;&#125;)</span><br><span class="line">            go func() &#123;</span><br><span class="line">                defer close(heartbeat)</span><br><span class="line">                var wardDone chan interface&#123;&#125;</span><br><span class="line">                var wardHeartbeat &lt;- chan interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">                startWard := func() &#123;</span><br><span class="line">                    wardDone = make(chan interface&#123;&#125;)</span><br><span class="line">                    wardHeartbeat = startGoroutine(or(wardDone, done),timeout/2)</span><br><span class="line">                &#125;</span><br><span class="line">// 定义了一个闭包，实现了统一的方法来启动正在监视的goroutine</span><br><span class="line">// 创建一个新的channel，如果需要发出停止信号则使用它传入goroutine</span><br><span class="line">// 启动将要监控的goroutine，如果管理员被停止或者想要停止goroutine，希望这些信息能传给管理区的goroutine</span><br><span class="line">// 所以使用了逻辑或来包装。</span><br><span class="line"></span><br><span class="line">                startWard()</span><br><span class="line">                pulse := time.Tick(pulseInterval)</span><br><span class="line"></span><br><span class="line">            monitorLoop:</span><br><span class="line">                for &#123;</span><br><span class="line">                    timeoutSignal := time.After(timeout)</span><br><span class="line">                    for &#123;</span><br><span class="line">                        select &#123;</span><br><span class="line">                        case &lt;-pulse:</span><br><span class="line">                            select&#123;</span><br><span class="line">                            case heartbeat &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class="line">                            default:</span><br><span class="line">                            &#125;</span><br><span class="line">                        case &lt;-wardHeartbeat:</span><br><span class="line">                            continue monitorLoop</span><br><span class="line">                        case &lt;-timeoutSignal:</span><br><span class="line">                            log.Println(&quot;steward: ward unhealthy; restarting&quot;)</span><br><span class="line">                            close(wardDone)</span><br><span class="line">                            startWard()</span><br><span class="line">                            continue monitorLoop</span><br><span class="line">                        case &lt;-done:</span><br><span class="line">                            return</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;()</span><br><span class="line">            return heartbeat</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.SetOutput(os.Stdout)</span><br><span class="line">    log.SetFlags(log.Ltime | log.LUTC)</span><br><span class="line"></span><br><span class="line">    doWork := func(done &lt;-chan interface&#123;&#125;, _ time.Duration) &lt;-chan interface&#123;&#125; &#123;</span><br><span class="line">        log.Println(&quot;ward: hello, I&#x27;m irresponsible!&quot;)</span><br><span class="line">        go func()&#123;</span><br><span class="line">            &lt;-done</span><br><span class="line">            log.Println(&quot;ward: I am halting&quot;)</span><br><span class="line">        &#125;()</span><br><span class="line">        retunr nil</span><br><span class="line">    &#125;</span><br><span class="line">    doWorkWithSteward := newSteward(4*time.Second, doWork)</span><br><span class="line">// 超时时间是4s</span><br><span class="line"></span><br><span class="line">    done := make(chan interface&#123;&#125;)</span><br><span class="line">    time.AfterFunc(9*time.Second, func()&#123;</span><br><span class="line">        log.Println(&quot;main: halting steward and ward.&quot;)</span><br><span class="line">        close(done)</span><br><span class="line">    &#125;)</span><br><span class="line">// 9s后停止管理员和goroutine</span><br><span class="line"></span><br><span class="line">    for range doWorkWithSteward(done, 4*time.Second) &#123;&#125;</span><br><span class="line">    log.Println(&quot;done&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>管理区可以使用桥接channel模式向消费者提供公用的channel，避免中断，使用这些技术，管理区可以简单的通过组合各种模式变得任意复杂：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">log.SetOutput(os.Stdout)</span><br><span class="line">log.SetFlags(log.Ltime | log.LUTC)</span><br><span class="line"></span><br><span class="line">done := make(chan interface&#123;&#125;)</span><br><span class="line">defer close(done)</span><br><span class="line"></span><br><span class="line">doWork, intStream := doWorkFn(done, 1, 2, -1, 3, 4, 5)</span><br><span class="line">// 创建管理区函数，允许结束可变整数切片，返回用来返回的流</span><br><span class="line"></span><br><span class="line">doWorkWithSteward := newSteward(1*time.Millisecond, doWork)</span><br><span class="line">// 创建管理员，监听doWork    </span><br><span class="line"></span><br><span class="line">doWorkWithSteward(done, 1*time.Hour)</span><br><span class="line">// 启动管理区并开始监控</span><br><span class="line"></span><br><span class="line">for intVal := range take(done, intStream, 6) &#123;</span><br><span class="line">    fmt.Println(&quot;Received %v.\n&quot;, intVal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Go语言并发之道第6章"><a href="#Go语言并发之道第6章" class="headerlink" title="Go语言并发之道第6章"></a>Go语言并发之道第6章</h1><h2 id="goroutine和Go语言进行时"><a href="#goroutine和Go语言进行时" class="headerlink" title="goroutine和Go语言进行时"></a>goroutine和Go语言进行时</h2><h3 id="工作窃取"><a href="#工作窃取" class="headerlink" title="工作窃取"></a>工作窃取</h3><p>为了确保所有CPU有相同的使用率，可以在所有可用的处理器上平均分配负载。在实际使用过程中，基于朴素策略在处理器上分配任务可能会导致其中一个处理器利用率不足。不仅如此，还可能导致缓存的位置偏差，因为需要调用这些数据的任务跑在其他处理器上。</p>
<p>可以采取：工作任务加入队列中进行调度，处理器在有空闲的时候将任务出队，或者阻塞连接。这样引入了一个集中化的队列，所有的处理器都必须使用这个数据结构，每次想要入队或出队一个任务时继续要将这个队列加载到每个处理器的缓存中。</p>
<p>也可以拆分工作队列，给每个处理器一个独立线程和双端队列。</p>
<p>首先需要强调，Go遵循fork-join模型进行并发，在goroutine开始的时候fork，join点事两个或更多的goroutine通过channel或sync包中的类型进行同步。工作窃取算法对于给定线程：</p>
<ol>
<li>在fork点，将任务添加到与线程相关的双端队列尾部；</li>
<li>如果线程空闲则随机选取一个线程，从它关联的双端队列头部窃取工作；</li>
<li>如果在未准备好的join点则将工作从线程的双端队列尾部出栈；</li>
<li>如果线程的双端队列是空的，则暂停加入或从随机线程关联的双端队列中窃取工作。</li>
</ol>
<p>以下是计算fibonacci数列的程序<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var fib func(n int) &lt;-chan int</span><br><span class="line">    fib = func(n int) &lt;-chan int &#123;</span><br><span class="line">        result := make(chan int)</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer close(result)</span><br><span class="line">            if n &lt;= 2 &#123;</span><br><span class="line">                result &lt;- 1</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            result &lt;- &lt;-fib(n-1) + &lt;-fib(n-2)</span><br><span class="line">        &#125;()</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;fib(4) = %d.\n&quot;, &lt;-fib(4))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先只有一个goroutine，main goroutine，假设在处理器1上；接下来调用fib(4)，这个goroutine被安排在T1的工作队列尾部，并且父goroutine将继续运行；此时根据时机不同，可能会发生T1或T2盗取调用fib(4)的goroutine，如果fib(4)在T1上，则在T1的工作队列上将添加fib(3)和fib(2)。</p>
<p>此时T2仍然是空闲的，所以从T1的队列头部取出fib(3)。此时fib(2)是fib(4)推入队列的最后一个任务，因此T1最有可能需要计算的第一个任务仍然在T1上！与此同时，由于在fib(3)和fib(2)返回的channel上等待着，T1不足以继续处理fib(4)，它会自己从队列中出栈一个fib(2)。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>T1调用栈</th>
<th>T1工作队列</th>
<th>T2调用栈</th>
<th>T2工作队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>(main goroutine)(等待join)</td>
<td></td>
<td>fib(3)</td>
<td></td>
</tr>
<tr>
<td>fib(4)(等待join)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fib(2)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>调用fib(3)的goroutine：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>T1调用栈</th>
<th>T1工作队列</th>
<th>T2调用栈</th>
<th>T2工作队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>(main goroutine)(等待join)</td>
<td></td>
<td>fib(3)</td>
<td>fib(2)</td>
</tr>
<tr>
<td>fib(4)(等待join)</td>
<td></td>
<td></td>
<td>fib(1)</td>
</tr>
<tr>
<td>fib(2)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>T1到达了Fibonacci收敛处，返回1：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>T1调用栈</th>
<th>T1工作队列</th>
<th>T2调用栈</th>
<th>T2工作队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>(main goroutine)(等待join)</td>
<td></td>
<td>fib(3)</td>
<td>fib(2)</td>
</tr>
<tr>
<td>fib(4)(等待join)</td>
<td></td>
<td></td>
<td>fib(1)</td>
</tr>
<tr>
<td>fib(1)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>T2到达了join点，并从其队列的尾部出栈一个任务：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>T1调用栈</th>
<th>T1工作队列</th>
<th>T2调用栈</th>
<th>T2工作队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>(main goroutine)(等待join)</td>
<td></td>
<td>fib(3)(等待join)</td>
<td>fib(2)</td>
</tr>
<tr>
<td>fib(4)(等待join)</td>
<td></td>
<td>fib(1)</td>
<td></td>
</tr>
<tr>
<td>return 1</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>T1又一次处于空闲所以从T2的队列中窃取工作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>T1调用栈</th>
<th>T1工作队列</th>
<th>T2调用栈</th>
<th>T2工作队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>(main goroutine)(等待join)</td>
<td></td>
<td>fib(3)(等待join)</td>
<td></td>
</tr>
<tr>
<td>fib(4)(等待join)</td>
<td></td>
<td>fib(1)</td>
<td></td>
</tr>
<tr>
<td>fib(2)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>T2到达终点返回1：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>T1调用栈</th>
<th>T1工作队列</th>
<th>T2调用栈</th>
<th>T2工作队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>(main goroutine)(等待join)</td>
<td></td>
<td>fib(3)(等待join)</td>
<td></td>
</tr>
<tr>
<td>fib(4)(等待join)</td>
<td></td>
<td>return 1</td>
<td></td>
</tr>
<tr>
<td>fib(2)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>T1到达终点返回1：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>T1调用栈</th>
<th>T1工作队列</th>
<th>T2调用栈</th>
<th>T2工作队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>(main goroutine)(等待join)</td>
<td></td>
<td>fib(3)(等待join)</td>
<td></td>
</tr>
<tr>
<td>fib(4)(等待join)</td>
<td></td>
<td>return 1</td>
<td></td>
</tr>
<tr>
<td>return 1</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>T2对fib(3)的调用现在有两个已完成的join点，fib(2)和fib(1)已经通过channel返回了结果，并且fib(3)产生的两个goroutine已经运行结束。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>T1调用栈</th>
<th>T1工作队列</th>
<th>T2调用栈</th>
<th>T2工作队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>(main goroutine)(等待join)</td>
<td></td>
<td>return 2</td>
<td></td>
</tr>
<tr>
<td>fib(4)(等待join)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>fib(4)调用的goroutine有两个join点，fib(3)和fib(2)，在T2最后一个任务结束时完成了fib(2)的join。执行加法，通过fib(4)的channel返回。</p>
<p>位于队列尾部的任务：</p>
<ol>
<li>最有可能完成父进程join的任务</li>
<li>最有可能存在于处理器缓存中的任务</li>
</ol>
<p>当一个线程到达join时，必须暂停等待回调以窃取任务。</p>
<h2 id="Go中的调度器"><a href="#Go中的调度器" class="headerlink" title="Go中的调度器"></a>Go中的调度器</h2><p>G：goroutine</p>
<p>M：OS线程，在源代码中也称为机器</p>
<p>P：上下文，在源代码中也被称为处理器</p>
<p>在Go的运行时中，首先启动M，然后是P，最后是调度运行G。</p>
<p>正如之前说的，设置GOMAXPROCS可以控制运行时使用多少上下文。默认设置是主机上每个逻辑CPU分配一个上下文。并且总会有足够的系统线程可以用来处理每个上下文。这使运行时可以进行一些重要的优化。</p>
<p>如果一个goroutine被阻塞，管理goroutine的系统线程也会被阻塞，并且无法继续执行或切换到其他的goroutine。从性能上，Go会进行更多的处理以尽可能让机器上的处理器保持活跃，Go会从系统线程分离上下文，将上下文切换到另一个无阻塞的系统线程上。当goroutine阻塞最终结束时，主机系统线程会尝试使用一个其他系统线程来回退上下文，以便它可以继续执行先前被阻塞的goroutine。或者把它的goroutine放在全局上下文中然后线程进入休眠状态，并将其放入运行时的线程池以供将来使用。</p>
<h2 id="竞争检测"><a href="#竞争检测" class="headerlink" title="竞争检测"></a>竞争检测</h2><p>在Go中为大多数命令增加了race参数。</p>
<p>竞争检测器可以自动检测代码中的竞态条件。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var data int</span><br><span class="line">    go func() &#123;</span><br><span class="line">        data++</span><br><span class="line">    &#125;()</span><br><span class="line">    if data == 0 &#123;</span><br><span class="line">        fmt.Printf(&quot;the value is %d.\n&quot;, data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>执行<code>go run -race test19.go</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">the value is 0.</span><br><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Write at 0x00c0000200c8 by goroutine 6:</span><br><span class="line">  main.main.func1()</span><br><span class="line">      /home/yuhao/tool/go/test/test19.go:8 +0x4e</span><br><span class="line"></span><br><span class="line">Previous read at 0x00c0000200c8 by main goroutine:</span><br><span class="line">  main.main()</span><br><span class="line">      /home/yuhao/tool/go/test/test19.go:10 +0x88</span><br><span class="line"></span><br><span class="line">Goroutine 6 (running) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      /home/yuhao/tool/go/test/test19.go:7 +0x7a</span><br><span class="line">==================</span><br><span class="line">Found 1 data race(s)</span><br><span class="line">exit status 66</span><br></pre></td></tr></table></figure><br>分别表示goroutine试图进行非同步内存写入，或者试图读取相同的内存。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/golang/" rel="tag"># golang</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/28/cpp%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/" rel="next" title="C++模板元编程">
                <i class="fa fa-chevron-left"></i> C++模板元编程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/29/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/" rel="prev" title="清华大学操作系统课程实验">
                清华大学操作系统课程实验 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">130</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%8C%E5%88%86%E9%9A%94%E7%AC%A6"><span class="nav-number">2.1.</span> <span class="nav-text">行分隔符</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.</span> <span class="nav-text">数字类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">4.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="nav-number">4.1.</span> <span class="nav-text">变量声明</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">5.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#iota"><span class="nav-number">6.</span> <span class="nav-text">iota</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%83%A8%E5%88%86%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">7.</span> <span class="nav-text">部分运算符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">8.</span> <span class="nav-text">条件语句</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#if-%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%AF%AD%E6%B3%95%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="nav-number">8.1.</span> <span class="nav-text">if 语句的语法如下：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch"><span class="nav-number">8.2.</span> <span class="nav-text">switch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fallthrough"><span class="nav-number">8.3.</span> <span class="nav-text">fallthrough</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select"><span class="nav-number">8.4.</span> <span class="nav-text">select</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF"><span class="nav-number">9.</span> <span class="nav-text">循环</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#break-%E8%AF%AD%E5%8F%A5"><span class="nav-number">9.1.</span> <span class="nav-text">break 语句</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">10.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E5%80%BC"><span class="nav-number">10.1.</span> <span class="nav-text">函数返回多个值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92"><span class="nav-number">10.2.</span> <span class="nav-text">值传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="nav-number">10.3.</span> <span class="nav-text">引用传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%AE%9E%E5%8F%82"><span class="nav-number">10.4.</span> <span class="nav-text">函数作为实参</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85"><span class="nav-number">10.5.</span> <span class="nav-text">函数闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">10.6.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">11.</span> <span class="nav-text">变量作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">11.1.</span> <span class="nav-text">局部变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-number">11.2.</span> <span class="nav-text">全局变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0"><span class="nav-number">11.3.</span> <span class="nav-text">形式参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">12.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">12.1.</span> <span class="nav-text">多维数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">13.</span> <span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88"><span class="nav-number">13.1.</span> <span class="nav-text">空指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">14.</span> <span class="nav-text">结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">14.1.</span> <span class="nav-text">定义结构体</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%87%E7%89%87"><span class="nav-number">15.</span> <span class="nav-text">切片</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%88%87%E7%89%87"><span class="nav-number">15.1.</span> <span class="nav-text">定义切片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E7%89%87%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">15.2.</span> <span class="nav-text">切片初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#len-%E5%92%8C-cap-%E5%87%BD%E6%95%B0"><span class="nav-number">15.3.</span> <span class="nav-text">len() 和 cap() 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA-nil-%E5%88%87%E7%89%87"><span class="nav-number">15.4.</span> <span class="nav-text">空(nil)切片</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%EF%BC%88range%EF%BC%89"><span class="nav-number">16.</span> <span class="nav-text">范围（range）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Map-%E9%9B%86%E5%90%88"><span class="nav-number">17.</span> <span class="nav-text">Map(集合)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-Map"><span class="nav-number">17.1.</span> <span class="nav-text">定义 Map</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">18.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">19.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">20.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">21.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">22.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%9A%E9%81%93"><span class="nav-number">23.</span> <span class="nav-text">通道</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E9%81%93%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">23.1.</span> <span class="nav-text">通道缓冲区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E9%80%9A%E9%81%93%E4%B8%8E%E5%85%B3%E9%97%AD%E9%80%9A%E9%81%93"><span class="nav-number">23.2.</span> <span class="nav-text">遍历通道与关闭通道</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%931-3%E7%AB%A0"><span class="nav-number">24.</span> <span class="nav-text">Go语言并发之道1-3章</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">24.1.</span> <span class="nav-text">原子性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E5%90%8C%E6%AD%A5"><span class="nav-number">24.1.1.</span> <span class="nav-text">内存访问同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">24.1.2.</span> <span class="nav-text">defer关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%93defer%E8%A2%AB%E5%A3%B0%E6%98%8E%E6%97%B6%EF%BC%8C%E5%85%B6%E5%8F%82%E6%95%B0%E5%B0%B1%E4%BC%9A%E8%A2%AB%E5%AE%9E%E6%97%B6%E8%A7%A3%E6%9E%90"><span class="nav-number">24.1.2.1.</span> <span class="nav-text">当defer被声明时，其参数就会被实时解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defer%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E4%B8%BA%E5%85%88%E8%BF%9B%E5%90%8E%E5%87%BA"><span class="nav-number">24.1.2.2.</span> <span class="nav-text">defer执行顺序为先进后出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defer%E5%8F%AF%E4%BB%A5%E8%AF%BB%E5%8F%96%E6%9C%89%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">24.1.2.3.</span> <span class="nav-text">defer可以读取有名返回值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E3%80%81%E6%B4%BB%E9%94%81%E3%80%81%E9%A5%A5%E9%A5%BF"><span class="nav-number">24.1.3.</span> <span class="nav-text">死锁、活锁、饥饿</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Coffman%E6%9D%A1%E4%BB%B6"><span class="nav-number">24.1.3.1.</span> <span class="nav-text">Coffman条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BB%E9%94%81"><span class="nav-number">24.1.3.2.</span> <span class="nav-text">活锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A5%A5%E9%A5%BF"><span class="nav-number">24.1.3.3.</span> <span class="nav-text">饥饿</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E9%A1%BA%E5%BA%8F%E8%BF%9B%E7%A8%8B"><span class="nav-number">24.2.</span> <span class="nav-text">通信顺序进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="nav-number">24.2.1.</span> <span class="nav-text">并行与并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%93%B2%E5%AD%A6"><span class="nav-number">24.2.2.</span> <span class="nav-text">并发哲学</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BB%84%E4%BB%B6"><span class="nav-number">24.3.</span> <span class="nav-text">并发组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#goroutine"><span class="nav-number">24.3.1.</span> <span class="nav-text">goroutine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sync%E5%8C%85"><span class="nav-number">24.3.2.</span> <span class="nav-text">sync包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#WaitGroup"><span class="nav-number">24.3.2.1.</span> <span class="nav-text">WaitGroup</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">24.3.2.2.</span> <span class="nav-text">互斥锁和读写锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cond"><span class="nav-number">24.3.2.3.</span> <span class="nav-text">cond</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#once"><span class="nav-number">24.3.2.4.</span> <span class="nav-text">once</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%A0"><span class="nav-number">24.3.3.</span> <span class="nav-text">池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#channel"><span class="nav-number">24.3.4.</span> <span class="nav-text">channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-1"><span class="nav-number">24.3.5.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GOMAXPROCS%E6%8E%A7%E5%88%B6"><span class="nav-number">24.3.6.</span> <span class="nav-text">GOMAXPROCS控制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E7%AC%AC4%E7%AB%A0"><span class="nav-number">25.</span> <span class="nav-text">Go语言并发之道第4章</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Go%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="nav-number">25.1.</span> <span class="nav-text">Go的并发模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A6%E6%9D%9F"><span class="nav-number">25.1.1.</span> <span class="nav-text">约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-select%E5%BE%AA%E7%8E%AF"><span class="nav-number">25.1.2.</span> <span class="nav-text">for-select循环</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91channel%E5%8F%91%E9%80%81%E8%BF%AD%E4%BB%A3%E5%8F%98%E9%87%8F"><span class="nav-number">25.1.2.1.</span> <span class="nav-text">向channel发送迭代变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E5%81%9C%E6%AD%A2"><span class="nav-number">25.1.2.2.</span> <span class="nav-text">循环等待停止</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B2%E6%AD%A2goroutine%E6%B3%84%E9%9C%B2"><span class="nav-number">25.1.3.</span> <span class="nav-text">防止goroutine泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#or-channel"><span class="nav-number">25.1.4.</span> <span class="nav-text">or-channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-1"><span class="nav-number">25.1.5.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pipeline"><span class="nav-number">25.1.6.</span> <span class="nav-text">pipeline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%87%E5%85%A5%E6%89%87%E5%87%BA"><span class="nav-number">25.1.7.</span> <span class="nav-text">扇入扇出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#or-done-channel"><span class="nav-number">25.1.8.</span> <span class="nav-text">or-done-channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tee-channel"><span class="nav-number">25.1.9.</span> <span class="nav-text">tee-channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E6%8E%92%E9%98%9F"><span class="nav-number">25.1.10.</span> <span class="nav-text">队列排队</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#context%E5%8C%85"><span class="nav-number">25.1.11.</span> <span class="nav-text">context包</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E7%AC%AC5%E7%AB%A0"><span class="nav-number">26.</span> <span class="nav-text">Go语言并发之道第5章</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E4%BC%A0%E9%80%92"><span class="nav-number">26.1.</span> <span class="nav-text">异常传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E5%92%8C%E5%8F%96%E6%B6%88"><span class="nav-number">26.2.</span> <span class="nav-text">超时和取消</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%83%E8%B7%B3"><span class="nav-number">26.3.</span> <span class="nav-text">心跳</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E8%AF%B7%E6%B1%82"><span class="nav-number">26.4.</span> <span class="nav-text">复制请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9F%E7%8E%87%E9%99%90%E5%88%B6"><span class="nav-number">26.5.</span> <span class="nav-text">速率限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B2%BB%E6%84%88%E5%BC%82%E5%B8%B8%E7%9A%84goroutine"><span class="nav-number">26.6.</span> <span class="nav-text">治愈异常的goroutine</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93%E7%AC%AC6%E7%AB%A0"><span class="nav-number">27.</span> <span class="nav-text">Go语言并发之道第6章</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#goroutine%E5%92%8CGo%E8%AF%AD%E8%A8%80%E8%BF%9B%E8%A1%8C%E6%97%B6"><span class="nav-number">27.1.</span> <span class="nav-text">goroutine和Go语言进行时</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96"><span class="nav-number">27.1.1.</span> <span class="nav-text">工作窃取</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="nav-number">27.2.</span> <span class="nav-text">Go中的调度器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AB%9E%E4%BA%89%E6%A3%80%E6%B5%8B"><span class="nav-number">27.3.</span> <span class="nav-text">竞争检测</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
