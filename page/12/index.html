<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
<meta property="og:type" content="website">
<meta property="og:title" content="Hao Yu&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/12/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
<meta property="og:locale" content="zn_CH">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="HPC PC IA">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zn-ch'
  };
</script>

  <title>Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/27/python%E7%9A%84%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/27/python%E7%9A%84%E5%BA%93/" class="post-title-link" itemprop="url">python的PIL库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-08-27 10:23:00" itemprop="dateCreated datePublished" datetime="2019-08-27T10:23:00+08:00">2019-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-07 14:13:53" itemprop="dateModified" datetime="2022-01-07T14:13:53+08:00">2022-01-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Python的PIL库"><a href="#Python的PIL库" class="headerlink" title="Python的PIL库"></a>Python的PIL库</h1><p>Image读出来的是PIL的类型，而skimage.io读出来的数据是numpy格式的<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Image和skimage读图片</span></span><br><span class="line"><span class="keyword">import</span> Image <span class="keyword">as</span> img</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plot</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io,transform</span><br><span class="line">img_file1 = img.<span class="built_in">open</span>(<span class="string">&#x27;./CXR_png/MCUCXR_0042_0.png&#x27;</span>)</span><br><span class="line">img_file2 = io.imread(<span class="string">&#x27;./CXR_png/MCUCXR_0042_0.png&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>输出可以看出Img读图片的大小是图片的(width, height)；而skimage的是(height,width, channel)，这也是为什么caffe在单独测试时要要在代码中设置：transformer.set_transpose(‘data’,(2,0,1))，因为caffe可以处理的图片的数据格式是(channel,height,width)，所以要转换数据。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#读图片后数据的大小：</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;the picture&#x27;s size: &quot;</span>, img_file1.size</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;the picture&#x27;s shape: &quot;</span>, img_file2.shape</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">the picture&#x27;s size:  (4892, 4020)</span><br><span class="line">the picture&#x27;s shape:  (4020, 4892)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#得到像素：</span></span><br><span class="line"><span class="built_in">print</span>(img_file1.getpixel((<span class="number">500</span>,<span class="number">1000</span>)), img_file2[<span class="number">500</span>][<span class="number">1000</span>])</span><br><span class="line"><span class="built_in">print</span>(img_file1.getpixel((<span class="number">500</span>,<span class="number">1000</span>)), img_file2[<span class="number">1000</span>][<span class="number">500</span>])</span><br><span class="line"><span class="built_in">print</span>(img_file1.getpixel((<span class="number">1000</span>,<span class="number">500</span>)), img_file2[<span class="number">500</span>][<span class="number">1000</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(0, 139)</span><br><span class="line">(0, 0)</span><br><span class="line">(139, 139)</span><br></pre></td></tr></table></figure>
<p>Img读出来的图片获得某点像素用getpixel((w,h))可以直接返回这个点三个通道的像素值<br>skimage读出来的图片可以直接img_file2[0][0]获得，但是一定记住它的格式，并不是你想的(channel,height,width)</p>
<h2 id="在图片上面加文字"><a href="#在图片上面加文字" class="headerlink" title="在图片上面加文字"></a>在图片上面加文字</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#新建绘图对象</span></span><br><span class="line">draw = ImageDraw.Draw(image)，</span><br><span class="line"><span class="comment">#获取图像的宽和高</span></span><br><span class="line">width, height = image.size；</span><br><span class="line"><span class="comment">#** ImageFont模块**</span></span><br><span class="line"><span class="comment">#选择文字字体和大小</span></span><br><span class="line">setFont = ImageFont.truetype(<span class="string">&#x27;C:/windows/fonts/Dengl.ttf&#x27;</span>, <span class="number">20</span>)，</span><br><span class="line"><span class="comment">#设置文字颜色</span></span><br><span class="line">fillColor = <span class="string">&quot;#ff0000&quot;</span></span><br><span class="line"><span class="comment">#写入文字</span></span><br><span class="line">draw.text((<span class="number">40</span>, height - <span class="number">100</span>), <span class="string">u&#x27;广告&#x27;</span>, font=setFont, fill=fillColor)</span><br></pre></td></tr></table></figure>
<h2 id="图片信息"><a href="#图片信息" class="headerlink" title="图片信息"></a>图片信息</h2><p>如果我们想知道一些skimage图片信息<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data</span><br><span class="line">img = data.chelsea()</span><br><span class="line">io.imshow(img)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(img))  <span class="comment">#显示类型</span></span><br><span class="line"><span class="built_in">print</span>(img.shape)  <span class="comment">#显示尺寸</span></span><br><span class="line"><span class="built_in">print</span>(img.shape[<span class="number">0</span>])  <span class="comment">#图片高度</span></span><br><span class="line"><span class="built_in">print</span>(img.shape[<span class="number">1</span>])  <span class="comment">#图片宽度</span></span><br><span class="line"><span class="built_in">print</span>(img.shape[<span class="number">2</span>])  <span class="comment">#图片通道数</span></span><br><span class="line"><span class="built_in">print</span>(img.size)   <span class="comment">#显示总像素个数</span></span><br><span class="line"><span class="built_in">print</span>(img.<span class="built_in">max</span>())  <span class="comment">#最大像素值</span></span><br><span class="line"><span class="built_in">print</span>(img.<span class="built_in">min</span>())  <span class="comment">#最小像素值</span></span><br><span class="line"><span class="built_in">print</span>(img.mean()) <span class="comment">#像素平均值</span></span><br><span class="line"><span class="built_in">print</span>(img[<span class="number">0</span>][<span class="number">0</span>])<span class="comment">#图像的像素值</span></span><br></pre></td></tr></table></figure><br>PIL image 查看图片信息，可用如下的方法<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(img)</span><br><span class="line"><span class="built_in">print</span> img.size  <span class="comment">#图片的尺寸</span></span><br><span class="line"><span class="built_in">print</span> img.mode  <span class="comment">#图片的模式</span></span><br><span class="line"><span class="built_in">print</span> img.<span class="built_in">format</span>  <span class="comment">#图片的格式</span></span><br><span class="line"><span class="built_in">print</span>(img.getpixel((<span class="number">0</span>,<span class="number">0</span>)))<span class="comment">#得到像素：</span></span><br><span class="line"><span class="comment">#img读出来的图片获得某点像素用getpixel((w,h))可以直接返回这个点三个通道的像素值</span></span><br></pre></td></tr></table></figure><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取图像的灰度值范围</span></span><br><span class="line">width = img.size[<span class="number">0</span>]</span><br><span class="line">height = img.size[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出图片的像素值</span></span><br><span class="line">count = <span class="number">0</span> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, width):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, height):</span><br><span class="line">        <span class="keyword">if</span> img.getpixel((i, j))&gt;=<span class="number">0</span> <span class="keyword">and</span> img.getpixel((i, j))&lt;=<span class="number">255</span>:</span><br><span class="line">            count +=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span> count</span><br><span class="line"><span class="built_in">print</span>(height*width)</span><br></pre></td></tr></table></figure></p>
<p>使用python进行数字图片处理，还得安装Pillow包。虽然python里面自带一个PIL（python images library), 但这个库现在已经停止更新了，所以使用Pillow, 它是由PIL发展而来的。</p>
<h3 id="pil能处理的图片类型"><a href="#pil能处理的图片类型" class="headerlink" title="pil能处理的图片类型"></a>pil能处理的图片类型</h3><p>pil可以处理光栅图片(像素数据组成的的块)。</p>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>一个图片可以包含一到多个数据通道，如果这些通道具有相同的维数和深度，Pil允许将这些通道进行叠加<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">模式</span><br><span class="line">1             1位像素，黑和白，存成8位的像素</span><br><span class="line">L             8位像素，黑白</span><br><span class="line">P             8位像素，使用调色板映射到任何其他模式</span><br><span class="line">RGB           3×8位像素，真彩</span><br><span class="line">RGBA          4×8位像素，真彩+透明通道</span><br><span class="line">CMYK          4×8位像素，颜色隔离</span><br><span class="line">YCbCr         3×8位像素，彩色视频格式</span><br><span class="line">I             32位整型像素</span><br><span class="line">F             32位浮点型像素</span><br></pre></td></tr></table></figure></p>
<h3 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h3><p>Pil采取左上角为(0,0)的坐标系统</p>
<h1 id="图片的打开与显示"><a href="#图片的打开与显示" class="headerlink" title="图片的打开与显示"></a>图片的打开与显示</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img=Image.<span class="built_in">open</span>(<span class="string">&#x27;d:/dog.png&#x27;</span>)</span><br><span class="line">img.show()</span><br></pre></td></tr></table></figure>
<p>虽然使用的是Pillow，但它是由PIL fork而来，因此还是要从PIL中进行import. 使用open()函数来打开图片，使用show()函数来显示图片。<br>这种图片显示方式是调用操作系统自带的图片浏览器来打开图片，有些时候这种方式不太方便，因此我们也可以使用另上一种方式，让程序来绘制图片。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">img=Image.open(&#x27;d:/dog.png&#x27;)</span><br><span class="line">plt.figure(&quot;dog&quot;)</span><br><span class="line">plt.figure(num=1, figsize=(8,5),)</span><br><span class="line">plt.title(&#x27;The image title&#x27;)</span><br><span class="line">plt.axis(&#x27;off&#x27;) # 不显示坐标轴</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br>这种方法虽然复杂了些，但推荐使用这种方法，它使用一个matplotlib的库来绘制图片进行显示。matplotlib是一个专业绘图的库，相当于matlab中的plot,可以设置多个figure,设置figure的标题，甚至可以使用subplot在一个figure中显示多张图片。matplotlib 可以直接安装.<br>figure默认是带axis的，如果没有需要，我们可以关掉<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.axis(&#x27;off&#x27;)</span><br></pre></td></tr></table></figure><br>图像加标题<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.title(&#x27;The image title&#x27;)</span><br></pre></td></tr></table></figure></p>
<h2 id="matplotlib标准模式"><a href="#matplotlib标准模式" class="headerlink" title="matplotlib标准模式"></a>matplotlib标准模式</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(num=<span class="number">5</span>, figsize=(<span class="number">8</span>,<span class="number">5</span>),)</span><br><span class="line"><span class="comment">#plt.figure(num=&#x27;newimage&#x27;, figsize=(8,5),)</span></span><br><span class="line">plt.title(<span class="string">&#x27;The image title&#x27;</span>, color=<span class="string">&#x27;#0000FF&#x27;</span>)</span><br><span class="line">plt.imshow(lena) <span class="comment"># 显示图片</span></span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>) <span class="comment"># 不显示坐标轴</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>PIL image 查看图片信息，可用如下的方法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print type(img)</span><br><span class="line">print img.size  #图片的尺寸</span><br><span class="line">print img.mode  #图片的模式</span><br><span class="line">print img.format  #图片的格式</span><br></pre></td></tr></table></figure></p>
<h2 id="图片的保存"><a href="#图片的保存" class="headerlink" title="图片的保存"></a>图片的保存</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.save(&#x27;d:/dog.jpg&#x27;)</span><br></pre></td></tr></table></figure>
<p>就一行代码，非常简单。这行代码不仅能保存图片，还是转换格式，如本例中，就由原来的png图片保存为了jpg图片。</p>
<h2 id="图像通道-几何变换-裁剪"><a href="#图像通道-几何变换-裁剪" class="headerlink" title="图像通道\几何变换\裁剪"></a>图像通道\几何变换\裁剪</h2><p>PIL可以对图像的颜色进行转换，并支持诸如24位彩色、8位灰度图和二值图等模式，简单的转换可以通过Image.convert(mode)函数完 成，其中mode表示输出的颜色模式，例如’’L’’表示灰度，’’1’’表示二值图模式等。但是利用convert函数将灰度图转换为二值图时，是采用 固定的阈 值127来实现的，即灰度高于127的像素值为1，而灰度低于127的像素值为0。</p>
<h3 id="彩色图像转灰度图"><a href="#彩色图像转灰度图" class="headerlink" title="彩色图像转灰度图"></a>彩色图像转灰度图</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">img=Image.<span class="built_in">open</span>(<span class="string">&#x27;d:/ex.jpg&#x27;</span>)</span><br><span class="line">gray=img.convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">plt.figure(<span class="string">&quot;beauty&quot;</span>)</span><br><span class="line">plt.imshow(gray,cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;The color image to gray image&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>使用函数convert()来进行转换，它是图像实例对象的一个方法，接受一个 mode 参数，用以指定一种色彩模式，mode 的取值可以是如下几种：</p>
<ul>
<li>1 (1-bit pixels, black and white, stored with one pixel per byte)</li>
<li>L (8-bit pixels, black and white)</li>
<li>P (8-bit pixels, mapped to any other mode using a colour palette)</li>
<li>RGB (3x8-bit pixels, true colour)</li>
<li>RGBA (4x8-bit pixels, true colour with transparency mask)</li>
<li>CMYK (4x8-bit pixels, colour separation)</li>
<li>YCbCr (3x8-bit pixels, colour video format)</li>
<li>I (32-bit signed integer pixels)</li>
<li>F (32-bit floating point pixels)</li>
</ul>
<h2 id="通道分离与合并"><a href="#通道分离与合并" class="headerlink" title="通道分离与合并"></a>通道分离与合并</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">img=Image.<span class="built_in">open</span>(<span class="string">&#x27;d:/ex.jpg&#x27;</span>)  <span class="comment">#打开图像</span></span><br><span class="line">gray=img.convert(<span class="string">&#x27;L&#x27;</span>)   <span class="comment">#转换成灰度</span></span><br><span class="line">r,g,b=img.split()   <span class="comment">#分离三通道</span></span><br><span class="line">pic=Image.merge(<span class="string">&#x27;RGB&#x27;</span>,(r,g,b)) <span class="comment">#合并三通道</span></span><br><span class="line">plt.figure(<span class="string">&quot;beauty&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>), plt.title(<span class="string">&#x27;origin&#x27;</span>)</span><br><span class="line">plt.imshow(img),plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>), plt.title(<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.imshow(gray,cmap=<span class="string">&#x27;gray&#x27;</span>),plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>), plt.title(<span class="string">&#x27;merge&#x27;</span>)</span><br><span class="line">plt.imshow(pic),plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>), plt.title(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.imshow(r,cmap=<span class="string">&#x27;gray&#x27;</span>),plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>), plt.title(<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">plt.imshow(g,cmap=<span class="string">&#x27;gray&#x27;</span>),plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>), plt.title(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.imshow(b,cmap=<span class="string">&#x27;gray&#x27;</span>),plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h3 id="水平拼接图片"><a href="#水平拼接图片" class="headerlink" title="水平拼接图片"></a>水平拼接图片</h3><p>给老板整理材料，顺手写了两个脚本，拼接图片用的<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">from PIL import Image</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">file_num = len(sys.argv) - 2;</span><br><span class="line">quali = int(sys.argv[1])</span><br><span class="line">file_list = sys.argv[2:]</span><br><span class="line">print(file_list)</span><br><span class="line">min_height=999999</span><br><span class="line">sum_width = 0</span><br><span class="line">img_list=[]</span><br><span class="line">for file_name in file_list:</span><br><span class="line">    img = Image.open(file_name)</span><br><span class="line">    img_list.append(img)</span><br><span class="line">    if(img.size[1]&lt;min_height):</span><br><span class="line">        min_height = img.size[1]</span><br><span class="line">    sum_width = sum_width + img.size[0]</span><br><span class="line">print(&quot;asdf&quot;)</span><br><span class="line">out_list=[]</span><br><span class="line">for file_name in file_list:</span><br><span class="line">    img = Image.open(file_name)</span><br><span class="line">    out = img.resize((img.size[0],min_height),Image.ANTIALIAS) #resize image with high-quality</span><br><span class="line">    out.save(file_name)</span><br><span class="line"></span><br><span class="line">target = Image.new(&#x27;RGB&#x27;,(sum_width,min_height))</span><br><span class="line">left = 0</span><br><span class="line">right = 0</span><br><span class="line">for file_name in file_list:</span><br><span class="line">    image = Image.open(file_name)</span><br><span class="line">    right += image.size[0]</span><br><span class="line">    target.paste(image,(left,0,right,min_height))</span><br><span class="line">    print(&quot;aaa&quot;)</span><br><span class="line">    left += image.size[0]</span><br><span class="line">    #right += image.size[1]</span><br><span class="line"></span><br><span class="line">target.save(&#x27;result.jpg&#x27;,quality=quali)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="竖直拼接图片"><a href="#竖直拼接图片" class="headerlink" title="竖直拼接图片"></a>竖直拼接图片</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">file_num = <span class="built_in">len</span>(sys.argv) - <span class="number">2</span></span><br><span class="line">quali = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">file_list = sys.argv[<span class="number">2</span>:]</span><br><span class="line"><span class="built_in">print</span>(file_list)</span><br><span class="line">min_width=<span class="number">999999</span></span><br><span class="line">sum_height = <span class="number">0</span></span><br><span class="line">img_list=[]</span><br><span class="line"><span class="keyword">for</span> file_name <span class="keyword">in</span> file_list:</span><br><span class="line">    img = Image.<span class="built_in">open</span>(file_name)</span><br><span class="line">    img_list.append(img)</span><br><span class="line">    <span class="keyword">if</span>(img.size[<span class="number">0</span>]&lt;min_width):</span><br><span class="line">        min_width = img.size[<span class="number">0</span>]</span><br><span class="line">    sum_height = sum_height + img.size[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;asdf&quot;</span>)</span><br><span class="line">out_list=[]</span><br><span class="line"><span class="keyword">for</span> file_name <span class="keyword">in</span> file_list:</span><br><span class="line">    img = Image.<span class="built_in">open</span>(file_name)</span><br><span class="line">    out = img.resize((min_width,img.size[<span class="number">1</span>]),Image.ANTIALIAS) <span class="comment">#resize image with high-quality</span></span><br><span class="line">    out.save(file_name)</span><br><span class="line"></span><br><span class="line">target = Image.new(<span class="string">&#x27;RGB&#x27;</span>,(min_width,sum_height))</span><br><span class="line">left = <span class="number">0</span></span><br><span class="line">right = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> file_name <span class="keyword">in</span> file_list:</span><br><span class="line">    image = Image.<span class="built_in">open</span>(file_name)</span><br><span class="line">    right += image.size[<span class="number">1</span>]</span><br><span class="line">    target.paste(image,(<span class="number">0</span>,left,min_width,right))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">    left += image.size[<span class="number">1</span>]</span><br><span class="line">    <span class="comment">#right += image.size[1]</span></span><br><span class="line"></span><br><span class="line">target.save(<span class="string">&#x27;result.jpg&#x27;</span>,quality=quali)</span><br></pre></td></tr></table></figure>
<h2 id="裁剪图片"><a href="#裁剪图片" class="headerlink" title="裁剪图片"></a>裁剪图片</h2><p>从原图片中裁剪感兴趣区域（roi),裁剪区域由4-tuple决定，该tuple中信息为(left, upper, right, lower)。 Pillow左边系统的原点（0，0）为图片的左上角。坐标中的数字单位为像素点。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">img=Image.open(&#x27;d:/ex.jpg&#x27;)  #打开图像</span><br><span class="line">plt.figure(&quot;beauty&quot;)</span><br><span class="line">plt.subplot(1,2,1), plt.title(&#x27;origin&#x27;)</span><br><span class="line">plt.imshow(img),plt.axis(&#x27;off&#x27;)</span><br><span class="line">#box变量是一个四元组(左，上，右，下)。  </span><br><span class="line">box=(80,100,260,300)</span><br><span class="line">roi=img.crop(box)</span><br><span class="line">plt.subplot(1,2,2)</span><br><span class="line">plt.title(&#x27;roi&#x27;)</span><br><span class="line">plt.imshow(roi)</span><br><span class="line">plt.axis(&#x27;off&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br>用plot绘制显示出图片后，将鼠标移动到图片上，会在右下角出现当前点的坐标，以及像素值。</p>
<h2 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h2><p>Image类有resize()、rotate()和transpose()方法进行几何变换。<br>图像的缩放和旋转<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dst = img.resize((128, 128))</span><br><span class="line">dst = img.rotate(45) # 顺时针角度表示</span><br></pre></td></tr></table></figure></p>
<h2 id="转换图像"><a href="#转换图像" class="headerlink" title="转换图像"></a>转换图像</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dst = im.transpose(Image.FLIP_LEFT_RIGHT) #左右互换</span><br><span class="line">dst = im.transpose(Image.FLIP_TOP_BOTTOM) #上下互换</span><br><span class="line">dst = im.transpose(Image.ROTATE_90)  #顺时针旋转</span><br><span class="line">dst = im.transpose(Image.ROTATE_180)</span><br><span class="line">dst = im.transpose(Image.ROTATE_270)</span><br></pre></td></tr></table></figure>
<p>transpose()和rotate()没有性能差别。</p>
<h2 id="python图像处理库Image模块"><a href="#python图像处理库Image模块" class="headerlink" title="python图像处理库Image模块"></a>python图像处理库Image模块</h2><h3 id="创建一个新的图片"><a href="#创建一个新的图片" class="headerlink" title="创建一个新的图片"></a>创建一个新的图片</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Image.new(mode, size)  </span><br><span class="line">Image.new(mode, size, color)  </span><br></pre></td></tr></table></figure>
<h2 id="层叠图片"><a href="#层叠图片" class="headerlink" title="层叠图片"></a>层叠图片</h2><p>层叠两个图片，img2和img2,alpha是一个介于[0,1]的浮点数，如果为0，效果为img1，如果为1.0，效果为img2。当然img1和img2的尺寸和模式必须相同。这个函数可以做出很漂亮的效果来，而图形的算术加减后边会说到。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Image.blend(img1, img2, alpha)  </span><br></pre></td></tr></table></figure><br>composite可以使用另外一个图片作为蒙板(mask)，所有的这三张图片必须具备相同的尺寸，mask图片的模式可以为“1”，“L”，“RGBA”<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Image.composite(img1, img2, mask) </span><br></pre></td></tr></table></figure></p>
<h2 id="添加水印"><a href="#添加水印" class="headerlink" title="添加水印"></a>添加水印</h2><h3 id="添加文字水印"><a href="#添加文字水印" class="headerlink" title="添加文字水印"></a>添加文字水印</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image, ImageDraw,ImageFont</span><br><span class="line">im = Image.open(&quot;d:/pic/lena.jpg&quot;).convert(&#x27;RGBA&#x27;)</span><br><span class="line">txt=Image.new(&#x27;RGBA&#x27;, im.size, (0,0,0,0))</span><br><span class="line">fnt=ImageFont.truetype(&quot;c:/Windows/fonts/Tahoma.ttf&quot;, 20)</span><br><span class="line">d=ImageDraw.Draw(txt)</span><br><span class="line">d.text((txt.size[0]-80,txt.size[1]-30), &quot;cnBlogs&quot;,font=fnt, fill=(255,255,255,255))</span><br><span class="line">out=Image.alpha_composite(im, txt)</span><br><span class="line">out.show()</span><br></pre></td></tr></table></figure>
<h3 id="添加小图片水印"><a href="#添加小图片水印" class="headerlink" title="添加小图片水印"></a>添加小图片水印</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">im = Image.open(&quot;d:/pic/lena.jpg&quot;)</span><br><span class="line">mark=Image.open(&quot;d:/logo_small.gif&quot;)</span><br><span class="line">layer=Image.new(&#x27;RGBA&#x27;, im.size, (0,0,0,0))</span><br><span class="line">layer.paste(mark, (im.size[0]-150,im.size[1]-60))</span><br><span class="line">out=Image.composite(layer,im,layer)</span><br><span class="line">out.show()</span><br></pre></td></tr></table></figure>
<h3 id="PIL-Image-图像互转-numpy-数组"><a href="#PIL-Image-图像互转-numpy-数组" class="headerlink" title="PIL Image 图像互转 numpy 数组"></a>PIL Image 图像互转 numpy 数组</h3><p>将 PIL Image 图片转换为 numpy 数组<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">im_array = np.array(im)</span><br><span class="line"># 也可以用 np.asarray(im) 区别是 np.array() 是深拷贝，np.asarray() 是浅拷贝</span><br></pre></td></tr></table></figure></p>
<h3 id="numpy-image-查看图片信息，可用如下的方法"><a href="#numpy-image-查看图片信息，可用如下的方法" class="headerlink" title="numpy image 查看图片信息，可用如下的方法"></a>numpy image 查看图片信息，可用如下的方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print img.shape  </span><br><span class="line">print img.dtype </span><br></pre></td></tr></table></figure>
<h3 id="将-numpy-数组转换为-PIL-图片"><a href="#将-numpy-数组转换为-PIL-图片" class="headerlink" title="将 numpy 数组转换为 PIL 图片"></a>将 numpy 数组转换为 PIL 图片</h3><p>这里采用 matplotlib.image 读入图片数组，注意这里读入的数组是 float32 型的，范围是 0-1，而 PIL.Image 数据是 uinit8 型的，范围是0-255，所以要进行转换：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.image as mpimg</span><br><span class="line">from PIL import Image</span><br><span class="line">lena = mpimg.imread(&#x27;lena.png&#x27;) # 这里读入的数据是 float32 型的，范围是0-1</span><br><span class="line">im = Image.fromarray(np.uinit8(lena*255))</span><br><span class="line">im.show()</span><br></pre></td></tr></table></figure></p>
<h3 id="PIL-image-查看图片信息，可用如下的方法"><a href="#PIL-image-查看图片信息，可用如下的方法" class="headerlink" title="PIL image 查看图片信息，可用如下的方法"></a>PIL image 查看图片信息，可用如下的方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print type(img)</span><br><span class="line">print img.size  #图片的尺寸</span><br><span class="line">print img.mode  #图片的模式</span><br><span class="line">print img.format  #图片的格式</span><br><span class="line">print(img.getpixel((0,0))[0])#得到像素：</span><br><span class="line">#img读出来的图片获得某点像素用getpixel((w,h))可以直接返回这个点三个通道的像素值</span><br></pre></td></tr></table></figure>
<h1 id="图像中的像素访问"><a href="#图像中的像素访问" class="headerlink" title="图像中的像素访问"></a>图像中的像素访问</h1><p>前面的一些例子中，我们都是利用Image.open（）来打开一幅图像，然后直接对这个PIL对象进行操作。如果只是简单的操作还可以，但是如果操作稍微复杂一些，就比较吃力了。因此，通常我们加载完图片后，都是把图片转换成矩阵来进行更加复杂的操作。<br>打开图像并转化为矩阵，并显示<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">img=np.array(Image.open(&#x27;d:/lena.jpg&#x27;))  #打开图像并转化为数字矩阵</span><br><span class="line">plt.figure(&quot;dog&quot;)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.axis(&#x27;off&#x27;)</span><br><span class="line">plt.title(&#x27;The image title&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br>调用numpy中的array（）函数就可以将PIL对象转换为数组对象。</p>
<p>查看图片信息，可用如下的方法<br>PIL image 查看图片信息，可用如下的方法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print type(img)</span><br><span class="line">print img.size  #图片的尺寸</span><br><span class="line">print img.mode  #图片的模式</span><br><span class="line">print img.format  #图片的格式</span><br><span class="line">print(img.getpixel((0,0))[0])#得到像素：</span><br><span class="line">#img读出来的图片获得某点像素用getpixel((w,h))可以直接返回这个点三个通道的像素值</span><br></pre></td></tr></table></figure></p>
<p>如果是RGB图片，那么转换为array之后，就变成了一个rowscolschannels的三维矩阵,因此，我们可以使用<br>img[i,j,k]来访问像素值。</p>
<p>例1：打开图片，并随机添加一些椒盐噪声<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">img=np.array(Image.open(&#x27;d:/ex.jpg&#x27;))</span><br><span class="line"></span><br><span class="line">#随机生成5000个椒盐</span><br><span class="line">rows,cols,dims=img.shape</span><br><span class="line">for i in range(5000):</span><br><span class="line">    x=np.random.randint(0,rows)</span><br><span class="line">    y=np.random.randint(0,cols)</span><br><span class="line">    img[x,y,:]=255</span><br><span class="line">    </span><br><span class="line">plt.figure(&quot;beauty&quot;)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.axis(&#x27;off&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>例2：将lena图像二值化，像素值大于128的变为1，否则变为0<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">img=np.array(Image.open(&#x27;d:/pic/lena.jpg&#x27;).convert(&#x27;L&#x27;))</span><br><span class="line"></span><br><span class="line">rows,cols=img.shape</span><br><span class="line">for i in range(rows):</span><br><span class="line">    for j in range(cols):</span><br><span class="line">        if (img[i,j]&lt;=128):</span><br><span class="line">            img[i,j]=0</span><br><span class="line">        else:</span><br><span class="line">            img[i,j]=1</span><br><span class="line">            </span><br><span class="line">plt.figure(&quot;lena&quot;)</span><br><span class="line">plt.imshow(img,cmap=&#x27;gray&#x27;)</span><br><span class="line">plt.axis(&#x27;off&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>如果要对多个像素点进行操作，可以使用数组切片方式访问。切片方式返回的是以指定间隔下标访问 该数组的像素值。下面是有关灰度图像的一些例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img[i,:] = im[j,:] # 将第 j 行的数值赋值给第 i 行</span><br><span class="line">img[:,i] = 100 # 将第 i 列的所有数值设为 100</span><br><span class="line">img[:100,:50].sum() # 计算前 100 行、前 50 列所有数值的和</span><br><span class="line">img[50:100,50:100] # 50~100 行，50~100 列（不包括第 100 行和第 100 列）</span><br><span class="line">img[i].mean() # 第 i 行所有数值的平均值</span><br><span class="line">img[:,-1] # 最后一列</span><br><span class="line">img[-2,:] (or im[-2]) # 倒数第二行</span><br></pre></td></tr></table></figure></p>
<h2 id="直接操作像素点"><a href="#直接操作像素点" class="headerlink" title="直接操作像素点"></a>直接操作像素点</h2><p>不但可以对每个像素点进行操作，而且，每一个通道都可以独立的进行操作。比如，将每个像素点的亮度(不知道有没有更专业的词)增大20%<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">out = img.point(lambda i : i * 1.2)</span><br><span class="line">#注意这里用到一个匿名函数(那个可以把i的1.2倍返回的函数)  </span><br><span class="line"></span><br><span class="line">argument * scale + offset  </span><br><span class="line">e.g  </span><br><span class="line">out = img.point(lambda i: i*1.2 + 10)</span><br></pre></td></tr></table></figure></p>
<h2 id="图像直方图"><a href="#图像直方图" class="headerlink" title="图像直方图"></a>图像直方图</h2><p>我们先来看两个函数reshape和flatten:<br>假设我们先生成一个一维数组：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vec=np.arange(15)</span><br><span class="line">print vec</span><br></pre></td></tr></table></figure></p>
<p>如果我们要把这个一维数组，变成一个<code>3*5</code>二维矩阵，我们可以使用reshape来实现<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mat= vec.reshape(3,5)</span><br><span class="line">print mat</span><br></pre></td></tr></table></figure><br>现在如果我们返过来，知道一个二维矩阵，要变成一个一维数组，就不能用reshape了，只能用flatten. 我们来看两者的区别<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a1=mat.reshape(1,-1)  #-1表示为任意，让系统自动计算</span><br><span class="line">print a1</span><br><span class="line">a2=mat.flatten()</span><br><span class="line">print a2</span><br></pre></td></tr></table></figure></p>
<p>可以看出，用reshape进行变换，实际上变换后还是二维数组，两个方括号，因此只能用flatten.<br>我们要对图像求直方图，就需要先把图像矩阵进行flatten操作，使之变为一维数组，然后再进行统计</p>
<h3 id="画灰度图直方图"><a href="#画灰度图直方图" class="headerlink" title="画灰度图直方图"></a>画灰度图直方图</h3><p>绘图都可以调用matplotlib.pyplot库来进行，其中的hist函数可以直接绘制直方图。<br>调用方式：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n, bins, patches = plt.hist(arr, bins=<span class="number">50</span>, normed=<span class="number">1</span>, facecolor=<span class="string">&#x27;green&#x27;</span>, alpha=<span class="number">0.75</span>)</span><br></pre></td></tr></table></figure><br>hist的参数非常多，但常用的就这五个，只有第一个是必须的，后面四个可选<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr: 需要计算直方图的一维数组</span><br><span class="line">bins: 直方图的柱数，可选项，默认为10</span><br><span class="line">normed: 是否将得到的直方图向量归一化。默认为0</span><br><span class="line">facecolor: 直方图颜色</span><br><span class="line">alpha: 透明度</span><br></pre></td></tr></table></figure><br>返回值 ：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n: 直方图向量，是否归一化由参数设定</span><br><span class="line">bins: 返回各个bin的区间范围</span><br><span class="line">patches: 返回每个bin里面包含的数据，是一个list</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">img=np.array(Image.open(&#x27;d:/pic/lena.jpg&#x27;).convert(&#x27;L&#x27;))</span><br><span class="line"></span><br><span class="line">plt.figure(&quot;lena&quot;)</span><br><span class="line">arr=img.flatten()</span><br><span class="line">n, bins, patches = plt.hist(arr, bins=256, normed=1, facecolor=&#x27;green&#x27;, alpha=0.75)  </span><br><span class="line">plt.title(&#x27;The image title&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<h3 id="彩色图片直方图"><a href="#彩色图片直方图" class="headerlink" title="彩色图片直方图"></a>彩色图片直方图</h3><p>实际上是和灰度直方图一样的，只是分别画出三通道的直方图，然后叠加在一起。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">src=Image.<span class="built_in">open</span>(<span class="string">&#x27;d:/ex.jpg&#x27;</span>)</span><br><span class="line">r,g,b=src.split()</span><br><span class="line">plt.figure(<span class="string">&quot;lena&quot;</span>)</span><br><span class="line">ar=np.array(r).flatten()</span><br><span class="line">plt.hist(ar, bins=<span class="number">256</span>, normed=<span class="number">1</span>,facecolor=<span class="string">&#x27;r&#x27;</span>,edgecolor=<span class="string">&#x27;r&#x27;</span>,hold=<span class="number">1</span>)</span><br><span class="line">ag=np.array(g).flatten()</span><br><span class="line">plt.hist(ag, bins=<span class="number">256</span>, normed=<span class="number">1</span>, facecolor=<span class="string">&#x27;g&#x27;</span>,edgecolor=<span class="string">&#x27;g&#x27;</span>,hold=<span class="number">1</span>)</span><br><span class="line">ab=np.array(b).flatten()</span><br><span class="line">plt.hist(ab, bins=<span class="number">256</span>, normed=<span class="number">1</span>, facecolor=<span class="string">&#x27;b&#x27;</span>,edgecolor=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;The image title&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<h2 id="Python如何读取指定文件夹下的所有图像"><a href="#Python如何读取指定文件夹下的所有图像" class="headerlink" title="Python如何读取指定文件夹下的所有图像"></a>Python如何读取指定文件夹下的所有图像</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Load the image files form the folder</span></span><br><span class="line"><span class="string">input:</span></span><br><span class="line"><span class="string">    imgDir: the direction of the folder</span></span><br><span class="line"><span class="string">    imgName:the name of the folder</span></span><br><span class="line"><span class="string">output:</span></span><br><span class="line"><span class="string">    data:the data of the dataset</span></span><br><span class="line"><span class="string">    label:the label of the datset</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_Img</span>(<span class="params">imgDir,imgFoldName</span>):</span><br><span class="line">    imgs = os.listdir(imgDir+imgFoldName)</span><br><span class="line">    imgNum = <span class="built_in">len</span>(imgs)</span><br><span class="line">    data = np.empty((imgNum,<span class="number">1</span>,<span class="number">12</span>,<span class="number">12</span>),dtype=<span class="string">&quot;float32&quot;</span>)</span><br><span class="line">    label = np.empty((imgNum,),dtype=<span class="string">&quot;uint8&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (imgNum):</span><br><span class="line">        img = Image.<span class="built_in">open</span>(imgDir+imgFoldName+<span class="string">&quot;/&quot;</span>+imgs[i])</span><br><span class="line">        arr = np.asarray(img,dtype=<span class="string">&quot;float32&quot;</span>)</span><br><span class="line">        data[i,:,:,:] = arr</span><br><span class="line">        label[i] = <span class="built_in">int</span>(imgs[i].split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> data,label</span><br></pre></td></tr></table></figure>
<p>调用方式<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">craterDir = &quot;./data/CraterImg/Adjust/&quot;</span><br><span class="line">foldName = &quot;East_CraterAdjust12&quot;</span><br><span class="line">data, label = load_Img(craterDir,foldName)</span><br></pre></td></tr></table></figure></p>
<h2 id="Python图形图像处理库ImageEnhance模块图像增强"><a href="#Python图形图像处理库ImageEnhance模块图像增强" class="headerlink" title="Python图形图像处理库ImageEnhance模块图像增强"></a>Python图形图像处理库ImageEnhance模块图像增强</h2><p>可以使用ImageEnhance模块，其中包含了大量的预定义的图片加强方式<br>加强器包括，色彩平衡，亮度平衡，对比度，锐化度等。通过使用这些加强器，可以很轻松的做到图片的色彩调整，亮度调整，锐化等操作，google picasa中提供的一些基本的图片加强功能都可以实现。</p>
<p>颜色加强color用于调整图片的色彩平衡，相当于彩色电视机的色彩调整。这个类实现了上边提到的接口的enhance方法。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageEnhance.Color(img)#获得色彩加强器实例  </span><br></pre></td></tr></table></figure></p>
<p>然后即可使用enhance(factor)方法进行调整。</p>
<p>亮度加强brightness用于调整图片的明暗平衡。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageEnhance.Brightness(img)#获得亮度加强器实例  </span><br></pre></td></tr></table></figure><br>factor=1返回一个黑色的图片对象，0返回原始图片对象</p>
<p>对比度加强contrast用于调整图片的对比度，相当于彩色电视机的对比度调整。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageEnhance.Contrast(image) #获得对比度加强器实例  </span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import ImageEnhance  </span><br><span class="line">enh = ImageEnhance.Contrast(im)  </span><br><span class="line">enh.ehhance(1.5).show(&quot;50% more contrast&quot;)</span><br></pre></td></tr></table></figure></p>
<p>锐化度加强sharpness用于锐化/钝化图片。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageEnhance.Sharpness(image) #返回锐化加强器实例  </span><br></pre></td></tr></table></figure><br>应该注意的是锐化操作的factor是一个0-2的浮点数，当factor=0时，返回一个完全模糊的图片对象，当factor=1时，返回一个完全锐化的图片对象，factor=1时，返回原始图片对象</p>
<h2 id="Python图像处理库ImageChops模块"><a href="#Python图像处理库ImageChops模块" class="headerlink" title="Python图像处理库ImageChops模块"></a>Python图像处理库ImageChops模块</h2><p>这个模块主要包括对图片的算术运算，叫做通道运算(channel operations)。这个模块可以用于多种途径，包括一些特效制作，图片整合，算数绘图等等方面。</p>
<p>Invert:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageChops.invert(image) </span><br></pre></td></tr></table></figure><br>图片反色，类似于集合操作中的求补集，最大值为Max，每个像素做减法，取出反色.<br>公式<br>out = MAX - image</p>
<p>lighter:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageChops.lighter(image1, image2)  </span><br></pre></td></tr></table></figure></p>
<p>darker:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageChops.darker(image1, image2)  </span><br></pre></td></tr></table></figure></p>
<p>difference<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageChops.difference(image1, image2)</span><br></pre></td></tr></table></figure><br>求出两张图片的绝对值，逐像素的做减法</p>
<p>multiply<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageChops.multiply(image1, image2)</span><br></pre></td></tr></table></figure><br>将两张图片互相叠加，如果用纯黑色与某图片进行叠加操作，会得到一个纯黑色的图片。如果用纯白色与图片作叠加，图片不受影响。<br>计算的公式如下公式<br>out = img1 * img2 / MAX</p>
<p>screen:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageChops.screen(image1, image2)  </span><br></pre></td></tr></table></figure><br>先反色，后叠加。<br>公式<br>out = MAX - ((MAX - image1) * (MAX - image2) / MAX)</p>
<p>add:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageChops.add(img1, img2, scale, offset)  </span><br></pre></td></tr></table></figure><br>对两张图片进行算术加法，按照一下公式进行计算<br>公式<br>out = (img1+img2) / scale + offset</p>
<p>如果尺度和偏移被忽略的化，scale=1.0, offset=0.0即<br>out = img1 + img2</p>
<p>subtract:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageChops.subtract(img1, img2, scale, offset)  </span><br></pre></td></tr></table></figure><br>对两张图片进行算术减法：<br>公式<br>out = (img1-img2) / scale + offset</p>
<h2 id="Python图形图像处理库ImageFilter模块图像滤镜"><a href="#Python图形图像处理库ImageFilter模块图像滤镜" class="headerlink" title="Python图形图像处理库ImageFilter模块图像滤镜"></a>Python图形图像处理库ImageFilter模块图像滤镜</h2><p>ImageFilter是PIL的滤镜模块，通过这些预定义的滤镜，可以方便的对图片进行一些过滤操作，从而去掉图片中的噪音(部分的消除)，这样可以降低将来处理的复杂度(如模式识别等)。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>滤镜名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ImageFilter.BLUR</td>
<td>模糊滤镜</td>
</tr>
<tr>
<td>ImageFilter.CONTOUR</td>
<td>轮廓</td>
</tr>
<tr>
<td>ImageFilter.EDGE_ENHANCE</td>
<td>边界加强</td>
</tr>
<tr>
<td>ImageFilter.EDGE_ENHANCE_MORE</td>
<td>边界加强(阀值更大)</td>
</tr>
<tr>
<td>ImageFilter.EMBOSS</td>
<td>浮雕滤镜</td>
</tr>
<tr>
<td>ImageFilter.FIND_EDGES</td>
<td>边界滤镜</td>
</tr>
<tr>
<td>ImageFilter.SMOOTH</td>
<td>平滑滤镜</td>
</tr>
<tr>
<td>ImageFilter.SMOOTH_MORE</td>
<td>平滑滤镜(阀值更大)</td>
</tr>
<tr>
<td>ImageFilter.SHARPEN</td>
<td>锐化滤镜</td>
</tr>
</tbody>
</table>
</div>
<p>要使用PIL的滤镜功能，需要引入ImageFilter模块<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import Image, ImageFilter  </span><br><span class="line">  </span><br><span class="line">def inHalf(img):  </span><br><span class="line">    w,h = img.size  </span><br><span class="line">    return img.resize((w/2, h/2))  </span><br><span class="line">  </span><br><span class="line">def filterDemo():  </span><br><span class="line">    img = Image.open(&quot;sandstone_half.jpg&quot;)  </span><br><span class="line">    #img = inHalf(img)  </span><br><span class="line">    imgfilted = img.filter(ImageFilter.SHARPEN)  </span><br><span class="line">    #imgfilted.show()  </span><br><span class="line">    imgfilted.save(&quot;sandstone_sharpen.jpg&quot;)  </span><br><span class="line">  </span><br><span class="line">if __name__ == &quot;__main__&quot;:  </span><br><span class="line">    filterDemo()</span><br></pre></td></tr></table></figure></p>
<h1 id="Python-netcdf4包的使用"><a href="#Python-netcdf4包的使用" class="headerlink" title="Python netcdf4包的使用"></a>Python netcdf4包的使用</h1><p>netCDF4包的文档：<a href="http://unidata.github.io/netcdf4-python/netCDF4/index.html">http://unidata.github.io/netcdf4-python/netCDF4/index.html</a></p>
<p>netCDF files come in five flavors. </p>
<ul>
<li>NETCDF3_CLASSIC was the original netcdf binary format, and was limited to file sizes less than 2 Gb. </li>
<li>NETCDF3_64BIT_OFFSET was introduced in version 3.6.0 of the library, and extended the original binary format to allow for file sizes greater than 2 Gb. </li>
<li>NETCDF3_64BIT_DATA is a new format that requires version 4.4.0 of the C library - it extends the NETCDF3_64BIT_OFFSET binary format to allow for unsigned/64 bit integer data types and 64-bit dimension sizes. </li>
<li>NETCDF3_64BIT is an alias for NETCDF3_64BIT_OFFSET. </li>
<li>NETCDF4_CLASSIC files use the version 4 disk format (HDF5), but omits features not found in the version 3 API. They can be read by netCDF 3 clients only if they have been relinked against the netCDF 4 library. They can also be read by HDF5 clients. NETCDF4 files use the version 4 disk format (HDF5) and use the new features of the version 4 API. The netCDF4 module can read and write files in any of these formats. When creating a new file, the format may be specified using the format keyword in the Dataset constructor. The default format is NETCDF4. To see how a given file is formatted, you can examine the data_model attribute. </li>
</ul>
<p>Closing the netCDF file is accomplished via the Dataset.close method of the Dataset instance.</p>
<p>因为要使用netCDF4格式的文件，所以学了一下如何把一个nc文件复制成另一个。在创建新文件时，format只能设置成“NETCDF3_CLASSIC”，否则在public2机器上无法读取，应该是HDF5的问题。下边的程序就比较齐全了，无论是维度的设置、变量及其属性的设置、全局属性的设置等都有了。复制出来的两个nc文件是一样的。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> netCDF4 <span class="keyword">import</span> Dataset</span><br><span class="line"></span><br><span class="line">nc = Dataset(<span class="string">&quot;wind2018100700.nc&quot;</span>)</span><br><span class="line">newnc = Dataset(<span class="string">&quot;new_wind.nc&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">format</span>=<span class="string">&#x27;NETCDF3_CLASSIC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ncdimensions = nc.dimensions</span><br><span class="line"><span class="keyword">for</span> dim <span class="keyword">in</span> nc.dimensions.values():</span><br><span class="line">    newncdim_sample = newnc.createDimension(dim.name, dim.size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> nc.variables.values():</span><br><span class="line">    <span class="built_in">print</span>(var)</span><br><span class="line">    <span class="built_in">print</span>(var.datatype)</span><br><span class="line">    <span class="built_in">print</span>(var.ncattrs())</span><br><span class="line">    <span class="built_in">print</span>(var.dimensions)</span><br><span class="line">    new_var = newnc.createVariable(var.name, var.datatype, var.dimensions, shuffle=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> var.ncattrs():</span><br><span class="line">        new_var.setncattr(attr, var.getncattr(attr))</span><br><span class="line">    newnc[var.name][:] = nc[var.name][:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> attr <span class="keyword">in</span> nc.ncattrs():</span><br><span class="line">    newnc.setncattr(attr,nc.getncattr(attr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nc.close()</span><br><span class="line">newnc.close()</span><br></pre></td></tr></table></figure>
<h1 id="Python-用matplotlib画三角形"><a href="#Python-用matplotlib画三角形" class="headerlink" title="Python 用matplotlib画三角形"></a>Python 用matplotlib画三角形</h1><p>老是得画三角形，所以用Python写了个简单的脚本备忘。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">lists = [<span class="string">&quot;(-29.548464, -48.168283)(101.860675, -115.334736)(-95.193356, 86.781746)&quot;</span>,</span><br><span class="line">        <span class="string">&quot;(-95.193356, 86.781746)(101.860675, -115.334736)(101.860675, 86.781746)&quot;</span></span><br><span class="line">]</span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;[-+]?[0-9]*\.?[0-9]+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> lists:</span><br><span class="line">    datas = pattern.findall(l)</span><br><span class="line">	length = <span class="built_in">len</span>(datas)</span><br><span class="line">	<span class="keyword">if</span> (length % <span class="number">2</span> != <span class="number">0</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">		exit(<span class="number">0</span>)</span><br><span class="line">	lons = []</span><br><span class="line">	lats = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(length/<span class="number">2</span>)):</span><br><span class="line">		lons.append(<span class="built_in">float</span>(datas[i*<span class="number">2</span>]))</span><br><span class="line">		lats.append(<span class="built_in">float</span>(datas[i*<span class="number">2</span>+<span class="number">1</span>]))</span><br><span class="line">	plt.scatter(lons, lats, c=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lons)):</span><br><span class="line">		plt.text(lons[i]*<span class="number">1.01</span>, lats[i]*<span class="number">1.01</span>, <span class="built_in">str</span>(lons[i])+<span class="string">&quot;\n&quot;</span>+<span class="built_in">str</span>(lats[i]))</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">		plt.plot([lons[j], lons[(j+<span class="number">1</span>)%<span class="number">3</span>]], [lats[j], lats[(j+<span class="number">1</span>)%<span class="number">3</span>]], color=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<h1 id="Python使用thinter写界面"><a href="#Python使用thinter写界面" class="headerlink" title="Python使用thinter写界面"></a>Python使用thinter写界面</h1><p>找了一个样例，以后以此为模板。注意前边的import，在python3下可以正常运行，python3自带了Tkinter。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _tkinter</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">LOG_LINE_NUM = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MY_GUI</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,init_window_name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.init_window_name = init_window_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#设置窗口</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_init_window</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.init_window_name.title(<span class="string">&quot;文本处理工具_v1.2&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.init_window_name.geometry(<span class="string">&#x27;1068x681+10+10&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.init_window_name[<span class="string">&quot;bg&quot;</span>] = <span class="string">&quot;white&quot;</span>                                    <span class="comment">#窗口背景色，其他背景色见：blog.csdn.net/chl0000/article/details/7657887</span></span><br><span class="line">        <span class="variable language_">self</span>.init_window_name.attributes(<span class="string">&quot;-alpha&quot;</span>,<span class="number">0.9</span>)                          <span class="comment">#虚化，值越小虚化程度越高</span></span><br><span class="line">        <span class="comment">#标签</span></span><br><span class="line">        <span class="variable language_">self</span>.init_data_label = Label(<span class="variable language_">self</span>.init_window_name, text=<span class="string">&quot;待处理数据&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.init_data_label.grid(row=<span class="number">0</span>, column=<span class="number">0</span>)</span><br><span class="line">        <span class="variable language_">self</span>.result_data_label = Label(<span class="variable language_">self</span>.init_window_name, text=<span class="string">&quot;输出结果&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.result_data_label.grid(row=<span class="number">0</span>, column=<span class="number">12</span>)</span><br><span class="line">        <span class="variable language_">self</span>.log_label = Label(<span class="variable language_">self</span>.init_window_name, text=<span class="string">&quot;日志&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.log_label.grid(row=<span class="number">12</span>, column=<span class="number">0</span>)</span><br><span class="line">        <span class="comment">#文本框</span></span><br><span class="line">        <span class="variable language_">self</span>.init_data_Text = Text(<span class="variable language_">self</span>.init_window_name, width=<span class="number">67</span>, height=<span class="number">35</span>)  <span class="comment">#原始数据录入框</span></span><br><span class="line">        <span class="variable language_">self</span>.init_data_Text.grid(row=<span class="number">1</span>, column=<span class="number">0</span>, rowspan=<span class="number">10</span>, columnspan=<span class="number">10</span>)</span><br><span class="line">        <span class="variable language_">self</span>.result_data_Text = Text(<span class="variable language_">self</span>.init_window_name, width=<span class="number">70</span>, height=<span class="number">49</span>)  <span class="comment">#处理结果展示</span></span><br><span class="line">        <span class="variable language_">self</span>.result_data_Text.grid(row=<span class="number">1</span>, column=<span class="number">12</span>, rowspan=<span class="number">15</span>, columnspan=<span class="number">10</span>)</span><br><span class="line">        <span class="variable language_">self</span>.log_data_Text = Text(<span class="variable language_">self</span>.init_window_name, width=<span class="number">66</span>, height=<span class="number">9</span>)  <span class="comment"># 日志框</span></span><br><span class="line">        <span class="variable language_">self</span>.log_data_Text.grid(row=<span class="number">13</span>, column=<span class="number">0</span>, columnspan=<span class="number">10</span>)</span><br><span class="line">        <span class="comment">#按钮</span></span><br><span class="line">        <span class="variable language_">self</span>.str_trans_to_md5_button = Button(<span class="variable language_">self</span>.init_window_name, text=<span class="string">&quot;字符串转MD5&quot;</span>, bg=<span class="string">&quot;lightblue&quot;</span>, width=<span class="number">10</span>,command=<span class="variable language_">self</span>.str_trans_to_md5)</span><br><span class="line">        <span class="variable language_">self</span>.str_trans_to_md5_button.grid(row=<span class="number">1</span>, column=<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#功能函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">str_trans_to_md5</span>(<span class="params">self</span>):</span><br><span class="line">        src = <span class="variable language_">self</span>.init_data_Text.get(<span class="number">1.0</span>,END).strip().replace(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;&quot;</span>).encode()</span><br><span class="line">        <span class="comment">#print(&quot;src =&quot;,src)</span></span><br><span class="line">        <span class="keyword">if</span> src:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                myMd5 = hashlib.md5()</span><br><span class="line">                myMd5.update(src)</span><br><span class="line">                myMd5_Digest = myMd5.hexdigest()</span><br><span class="line">                <span class="comment">#print(myMd5_Digest)</span></span><br><span class="line">                <span class="comment">#输出到界面</span></span><br><span class="line">                <span class="variable language_">self</span>.result_data_Text.delete(<span class="number">1.0</span>,END)</span><br><span class="line">                <span class="variable language_">self</span>.result_data_Text.insert(<span class="number">1.0</span>,myMd5_Digest)</span><br><span class="line">                <span class="variable language_">self</span>.write_log_to_Text(<span class="string">&quot;INFO:str_trans_to_md5 success&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="variable language_">self</span>.result_data_Text.delete(<span class="number">1.0</span>,END)</span><br><span class="line">                <span class="variable language_">self</span>.result_data_Text.insert(<span class="number">1.0</span>,<span class="string">&quot;字符串转MD5失败&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.write_log_to_Text(<span class="string">&quot;ERROR:str_trans_to_md5 failed&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取当前时间</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_current_time</span>(<span class="params">self</span>):</span><br><span class="line">        current_time = time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>,time.localtime(time.time()))</span><br><span class="line">        <span class="keyword">return</span> current_time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#日志动态打印</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write_log_to_Text</span>(<span class="params">self,logmsg</span>):</span><br><span class="line">        <span class="keyword">global</span> LOG_LINE_NUM</span><br><span class="line">        current_time = <span class="variable language_">self</span>.get_current_time()</span><br><span class="line">        logmsg_in = <span class="built_in">str</span>(current_time) +<span class="string">&quot; &quot;</span> + <span class="built_in">str</span>(logmsg) + <span class="string">&quot;\n&quot;</span>      <span class="comment">#换行</span></span><br><span class="line">        <span class="keyword">if</span> LOG_LINE_NUM &lt;= <span class="number">7</span>:</span><br><span class="line">            <span class="variable language_">self</span>.log_data_Text.insert(END, logmsg_in)</span><br><span class="line">            LOG_LINE_NUM = LOG_LINE_NUM + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.log_data_Text.delete(<span class="number">1.0</span>,<span class="number">2.0</span>)</span><br><span class="line">            <span class="variable language_">self</span>.log_data_Text.insert(END, logmsg_in)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gui_start</span>():</span><br><span class="line">    init_window = Tk()              <span class="comment">#实例化出一个父窗口</span></span><br><span class="line">    ZMJ_PORTAL = MY_GUI(init_window)</span><br><span class="line">    <span class="comment"># 设置根窗口默认属性</span></span><br><span class="line">    ZMJ_PORTAL.set_init_window()</span><br><span class="line"></span><br><span class="line">    init_window.mainloop()          <span class="comment">#父窗口进入事件循环，可以理解为保持窗口运行，否则界面不展示</span></span><br><span class="line"></span><br><span class="line">gui_start()</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/12/%E8%B0%88%E8%B0%88%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84ACID/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/12/%E8%B0%88%E8%B0%88%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84ACID/" class="post-title-link" itemprop="url">谈谈数据库的ACID</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-08-12 21:20:00 / Modified: 21:50:09" itemprop="dateCreated datePublished" datetime="2019-08-12T21:20:00+08:00">2019-08-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<a href="https://blog.csdn.net/shuaihj/article/details/14163713">https://blog.csdn.net/shuaihj/article/details/14163713</a></p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>定义：所谓事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。</p>
<p>准备工作：为了说明事务的ACID原理，我们使用银行账户及资金管理的案例进行分析。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 创建数据库</span><br><span class="line">create table account(</span><br><span class="line">   idint primary key not null,</span><br><span class="line">   namevarchar(40),</span><br><span class="line">   moneydouble</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 有两个人开户并存钱</span><br><span class="line">insert into account values(1,&#x27;A&#x27;,1000);</span><br><span class="line">insert into account values(2,&#x27;B&#x27;,1000);</span><br></pre></td></tr></table></figure></p>
<h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><p>ACID，是指在可靠数据库管理系统（DBMS）中，事务(transaction)所应该具有的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）.这是可靠数据库所应具备的几个特性.下面针对这几个特性进行逐个讲解.</p>
<h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><p>原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>A给B转帐100元钱<br><img src="/img/20131105115813406.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">begin transaction</span><br><span class="line">update account set money= money - 100where name=&#x27;A&#x27;;</span><br><span class="line">update account set money= money +100where name=&#x27;B&#x27;;</span><br><span class="line">if Error then</span><br><span class="line">       rollback</span><br><span class="line">else</span><br><span class="line">       commit</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在事务中的扣款和加款两条语句，要么都执行，要么就都不执行。否则如果只执行了扣款语句，就提交了，此时如果突然断电，A账号已经发生了扣款，B账号却没收到加款，在生活中就会引起纠纷。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在数据库管理系统（DBMS）中，默认情况下一条SQL就是一个单独事务，事务是自动提交的。只有显式的使用start transaction开启一个事务，才能将一个代码块放在事务中执行。保障事务的原子性是数据库管理系统的责任，为此许多数据源采用日志机制。例如，SQL Server使用一个预写事务日志，在将数据提交到实际数据页面前，先写在事务日志上。</p>
<h1 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h1><p>一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</p>
<h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><p>对银行转帐事务，不管事务成功还是失败，应该保证事务结束后ACCOUNT表中aaa和bbb的存款总额为2000元。</p>
<h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h2><p>保障事务的一致性，可以从以下两个层面入手</p>
<h3 id="数据库机制层面"><a href="#数据库机制层面" class="headerlink" title="数据库机制层面"></a>数据库机制层面</h3><p>数据库层面的一致性是，在一个事务执行之前和之后，数据会符合你设置的约束（唯一约束，外键约束,Check约束等)和触发器设置。这一点是由SQL SERVER进行保证的。比如转账，则可以使用CHECK约束两个账户之和等于2000来达到一致性目的</p>
<h3 id="业务层面"><a href="#业务层面" class="headerlink" title="业务层面"></a>业务层面</h3><p>对于业务层面来说，一致性是保持业务的一致性。这个业务一致性需要由开发人员进行保证。当然，很多业务方面的一致性，也可以通过转移到数据库机制层面进行保证。</p>
<h1 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h1><p>多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。</p>
<p>这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p>
<p>在Windows中，如果多个进程对同一个文件进行修改是不允许的，Windows通过这种方式来保证不同进程的隔离性。</p>
<p>企业开发中，事务最复杂问题都是由事务隔离性引起的。当多个事务并发时，SQL Server利用加锁和阻塞来保证事务之间不同等级的隔离性。一般情况下，完全的隔离性是不现实的，完全的隔离性要求数据库同一时间只执行一条事务，这样会严重影响性能。想要理解SQL Server中对于隔离性的保障，首先要了解并发事务之间是如何干扰的.</p>
<h2 id="事务之间的相互影响"><a href="#事务之间的相互影响" class="headerlink" title="事务之间的相互影响"></a>事务之间的相互影响</h2><p>事务之间的相互影响分为几种，分别为：脏读，不可重复读，幻读，丢失更新</p>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>脏读意味着一个事务读取了另一个事务未提交的数据，而这个数据是有可能回滚的；如下案例，此时如果事务1回滚，则B账户必将有损失。<br><img src="/img/20131105115822218.png" alt=""></p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>不可重复读意味着，在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。如下案例，事务1必然会变得糊涂，不知道发生了什么。<br><img src="/img/20131105115826281.png" alt=""></p>
<h3 id="幻读（虚读）"><a href="#幻读（虚读）" class="headerlink" title="幻读（虚读）"></a>幻读（虚读）</h3><p>幻读，是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.<br><img src="/img/20131105115830531.png" alt=""></p>
<h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><p>两个事务同时读取同一条记录，A先修改记录，B也修改记录（B是不知道A修改过），B提交数据后B的修改结果覆盖了A的修改结果。</p>
<h2 id="理解SQL-SERVER中的隔离级别"><a href="#理解SQL-SERVER中的隔离级别" class="headerlink" title="理解SQL SERVER中的隔离级别"></a>理解SQL SERVER中的隔离级别</h2><p>数据库的事务隔离级别（TRANSACTION ISOLATION LEVEL）是一个数据库上很基本的一个概念。为什么会有事务隔离级别，SQL Server上实现了哪些事务隔离级别？事务隔离级别的前提是一个多用户、多进程、多线程的并发系统，在这个系统中为了保证数据的一致性和完整性，我们引入了事务隔离级别这个概念，对一个单用户、单线程的应用来说则不存在这个问题。</p>
<p>为了避免上述几种事务之间的影响，SQL Server通过设置不同的隔离级别来进行不同程度的避免。因为高的隔离等级意味着更多的锁，从而牺牲性能。所以这个选项开放给了用户根据具体的需求进行设置。不过默认的隔离级别Read Commited符合了多数的实际需求.<br><img src="/img/20190812005.jpg" alt=""></p>
<p>SQL Server隔离事务之间的影响是通过锁来实现的，通过阻塞来阻止上述影响。不同的隔离级别是通过加不同的锁，造成阻塞来实现的，所以会以付出性能作为代价；安全级别越高，处理效率越低；安全级别越低，效率高。</p>
<p>使用方法：SET TRANSACTIONISOLATION LEVEL REPEATABLE READ</p>
<p>未提交读： 在读数据时不会检查或使用任何锁。因此，在这种隔离级别中可能读取到没有提交的数据。  </p>
<p>已提交读：只读取提交的数据并等待其他事务释放排他锁。读数据的共享锁在读操作完成后立即释放。已提交读是SQL Server的默认隔离级别。 </p>
<p>可重复读： 像已提交读级别那样读数据，但会保持共享锁直到事务结束。  </p>
<p>可串行读：工作方式类似于可重复读。但它不仅会锁定受影响的数据，还会锁定这个范围。这就阻止了新数据插入查询所涉及的范围。</p>
<h1 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h1><p>持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p>
<p>即使出现了任何事故比如断电等，事务一旦提交，则持久化保存在数据库中。</p>
<p>SQL SERVER通过write-ahead transaction log来保证持久性。write-ahead transaction log的意思是，事务中对数据库的改变在写入到数据库之前，首先写入到事务日志中。而事务日志是按照顺序排号的（LSN）。当数据库崩溃或者服务器断点时，重启动SQL SERVER，SQLSERVER首先会检查日志顺序号，将本应对数据库做更改而未做的部分持久化到数据库，从而保证了持久性。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>事务的（ACID）特性是由关系数据库管理系统（RDBMS，数据库系统）来实现的。数据库管理系统采用日志来保证事务的原子性、一致性和持久性。日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。</p>
<p>数据库管理系统采用锁机制来实现事务的隔离性。当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。</p>
<h1 id="数据库查询优化"><a href="#数据库查询优化" class="headerlink" title="数据库查询优化"></a>数据库查询优化</h1><h2 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h2><p>应尽量避免全表扫描，首先应考虑在 where 及 order by ,group by 涉及的列上建立索引</p>
<h2 id="优化-SQL-语句"><a href="#优化-SQL-语句" class="headerlink" title="优化 SQL 语句"></a>优化 SQL 语句</h2><ol>
<li><p>通过 explain(查询优化神器)用来查看 SQL 语句的执行效果</p>
<ul>
<li>可以帮助选择更好的索引和优化查询语句， 写出更好的优化语句。 通常我们可以对比较复杂的尤其是涉及到多表的 SELECT 语句， 把关键字 EXPLAIN 加到前面， 查看执行计划。例如： explain select * from news;</li>
</ul>
</li>
<li><p>任何地方都不要使用 <code>select * from t</code>。用具体的字段列表代替<code>*</code> ，不要返回用不到的任何字段。</p>
<ul>
<li>不需要的字段会增加数据传输的时间，即使mysql服务器和客户端是在同一台机器上，使用的协议还是tcp，通信也是需要额外的时间。</li>
<li>要取的字段、索引的类型，和这两个也是有关系的。举个例子，对于user表，有name和phone的联合索引，select name from user where phone=12345678912 和 select * from user where phone=12345678912，前者要比后者的速度快，因为name可以在索引上直接拿到，不再需要读取这条记录了。</li>
<li>大字段，例如很长的varchar，blob，text。准确来说，长度超过728字节的时候，会把超出的数据放到另外一个地方，因此读取这条记录会增加一次io操作。</li>
</ul>
</li>
<li><p>索引列不能参与计算，保持列“干净”</p>
<ul>
<li>比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);</li>
</ul>
</li>
<li><p>查询尽可能使用 limit 减少返回的行数， 减少数据传输时间和带宽浪费。</p>
</li>
</ol>
<h2 id="优化数据库对象"><a href="#优化数据库对象" class="headerlink" title="优化数据库对象"></a>优化数据库对象</h2><ol>
<li><p>优化表的数据类型</p>
<ul>
<li>使用 procedure analyse()函数对表进行分析， 该函数可以对表中列的数据类型提出优化建议。 能小就用小。 表数据类型第一个原则是： 使用能正确的表示和存储数据的最短类型。 这样可以减少对磁盘空间、 内存、 cpu 缓存的使用。</li>
<li>使用方法： select * from 表名 procedure analyse();</li>
</ul>
</li>
<li><p>对表进行拆分</p>
<ul>
<li>通过拆分表可以提高表的访问效率。 有 2 种拆分方法</li>
<li>垂直拆分。把主键和一些列放在一个表中， 然后把主键和另外的列放在另一个表中。 如果一个表中某些列常用， 而另外一些不常用， 则可以采用垂直拆分。</li>
<li>水平拆分。根据一列或者多列数据的值把数据行放到二个独立的表中。</li>
</ul>
</li>
<li><p>使用中间表来提高查询速度</p>
<ul>
<li>创建中间表， 表结构和源表结构完全相同， 转移要统计的数据到中间表， 然后在中间表上进行统计， 得出想要的结果。</li>
</ul>
</li>
</ol>
<h2 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h2><ol>
<li>CPU 的优化<ul>
<li>选择多核和主频高的 CPU。</li>
</ul>
</li>
<li>内存的优化<ul>
<li>使用更大的内存。 将尽量多的内存分配给 MYSQL 做缓存。</li>
</ul>
</li>
<li>磁盘 I/O 的优化<ul>
<li>使用磁盘阵列。RAID 0 没有数据冗余， 没有数据校验的磁盘陈列。 实现 RAID 0至少需要两块以上的硬盘，它将两块以上的硬盘合并成一块， 数据连续地分割在每块盘上。</li>
<li>RAID1 是将一个两块硬盘所构成 RAID 磁盘阵列， 其容量仅等于一块硬盘的容量， 因为另一块只是当作数据“镜像”。使用 RAID-0+1 磁盘阵列。 RAID 0+1 是 RAID 0 和 RAID 1 的组合形式。 它在提供与 RAID 1 一样的数据安全保障的同时， 也提供了与 RAID 0 近似的存储性能。</li>
</ul>
</li>
<li>调整磁盘调度算法<ul>
<li>选择合适的磁盘调度算法， 可以减少磁盘的寻道时间</li>
</ul>
</li>
</ol>
<h2 id="MySQL-自身的优化"><a href="#MySQL-自身的优化" class="headerlink" title="MySQL 自身的优化"></a>MySQL 自身的优化</h2><ol>
<li>对 MySQL 自身的优化主要是对其配置文件 my.cnf 中的各项参数进行优化调整。 如指定 MySQL 查询缓冲区的大小， 指定 MySQL 允许的最大连接进程数等。</li>
</ol>
<h2 id="应用优化"><a href="#应用优化" class="headerlink" title="应用优化"></a>应用优化</h2><ol>
<li>使用数据库连接池</li>
<li>使用查询缓存<ul>
<li>它的作用是存储 select 查询的文本及其相应结果。 如果随后收到一个相同的查询， 服务器会从查询缓存中直接得到查询结果。 查询缓存适用的对象是更新不频繁的表， 当表中数据更改后， 查询缓存中的相关条目就会被清空。</li>
</ul>
</li>
</ol>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h2><p>存储过程是一些预编译的SQL语句。</p>
<p>更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。</p>
<p>存储过程是一个预编译的代码块，执行效率比较高<br>一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率<br>可以一定程度上确保数据安全</p>
<h2 id="索引是什么？有什么作用以及优缺点？"><a href="#索引是什么？有什么作用以及优缺点？" class="headerlink" title="索引是什么？有什么作用以及优缺点？"></a>索引是什么？有什么作用以及优缺点？</h2><p>索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构</p>
<p>你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。</p>
<p>MySQL数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引</p>
<p>索引加快数据库的检索速度<br>索引降低了插入、删除、修改等维护任务的速度<br>唯一索引可以确保每一行数据的唯一性<br>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能<br>索引需要占物理和数据空间</p>
<h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><p>事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。</p>
<h2 id="数据库的乐观锁和悲观锁是什么？"><a href="#数据库的乐观锁和悲观锁是什么？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？"></a>数据库的乐观锁和悲观锁是什么？</h2><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。</p>
<p>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
<p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作<br>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p>
<h2 id="触发器的作用？"><a href="#触发器的作用？" class="headerlink" title="触发器的作用？"></a>触发器的作用？</h2><p>触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p>
<h2 id="索引的作用？和它的优点缺点是什么？"><a href="#索引的作用？和它的优点缺点是什么？" class="headerlink" title="索引的作用？和它的优点缺点是什么？"></a>索引的作用？和它的优点缺点是什么？</h2><p>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p>
<p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<p>为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</p>
<p>创建索引可以大大提高系统的性能（优点）：</p>
<ul>
<li>第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
<li>第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ul>
<p>也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面：</p>
<ul>
<li>第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ul>
<p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。</p>
<p>一般来说，应该在这些列上创建索引：</p>
<ul>
<li>在经常需要搜索的列上，可以加快搜索的速度；</li>
<li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</li>
<li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</li>
<li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li>
<li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li>
<li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li>
</ul>
<p>同样，对于有些列不应该创建索引：</p>
<ul>
<li>第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li>
<li>第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li>
<li>第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</li>
<li>第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li>
</ul>
<h2 id="使用索引查询一定能提高查询的性能吗？为什么"><a href="#使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么"></a>使用索引查询一定能提高查询的性能吗？为什么</h2><p>通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.</p>
<p>索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况:</p>
<p>基于一个范围的检索,一般查询返回结果集小于表中记录数的30%<br>基于非唯一性索引的检索</p>
<h2 id="简单说一说drop、delete与truncate的区别"><a href="#简单说一说drop、delete与truncate的区别" class="headerlink" title="简单说一说drop、delete与truncate的区别"></a>简单说一说drop、delete与truncate的区别</h2><p>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别</p>
<p>delete和truncate只删除表的数据不删除表的结构<br>速度,一般来说: drop&gt; truncate &gt;delete<br>delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;<br>如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.</p>
<h2 id="drop、delete与truncate分别在什么场景之下使用？"><a href="#drop、delete与truncate分别在什么场景之下使用？" class="headerlink" title="drop、delete与truncate分别在什么场景之下使用？"></a>drop、delete与truncate分别在什么场景之下使用？</h2><p>不再需要一张表的时候，用drop<br>想删除部分数据行时候，用delete，并且带上where子句<br>保留表而删除所有数据的时候用truncate</p>
<h2 id="超键、候选键、主键、外键分别是什么？"><a href="#超键、候选键、主键、外键分别是什么？" class="headerlink" title="超键、候选键、主键、外键分别是什么？"></a>超键、候选键、主键、外键分别是什么？</h2><p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p>
<p>候选键：是最小超键，即没有冗余元素的超键。</p>
<p>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</p>
<p>外键：在一个表中存在的另一个表的主键称此表的外键。</p>
<h2 id="什么是视图？以及视图的使用场景有哪些？"><a href="#什么是视图？以及视图的使用场景有哪些？" class="headerlink" title="什么是视图？以及视图的使用场景有哪些？"></a>什么是视图？以及视图的使用场景有哪些？</h2><p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</p>
<p>只暴露部分字段给访问者，所以就建一个虚表，就是视图。<br>查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异</p>
<h2 id="说一说三个范式。"><a href="#说一说三个范式。" class="headerlink" title="说一说三个范式。"></a>说一说三个范式。</h2><p>第一范式（1NF，确保每列保持原子性）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</p>
<p>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。<br><img src="/img/2012040114023352.png" alt=""><br>上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。</p>
<p>第二范式（2NF，确保表中的每列都和主键相关）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。 </p>
<p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p>
<p>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示。<br><img src="/img/2012040114063976.png" alt=""></p>
<p>这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。</p>
<p>而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示。<br><img src="/img/2012040114082156.png" alt=""></p>
<p>这样设计，在很大程度上减小了数据库的冗余。如果要获取订单的商品信息，使用商品编号到商品信息表中查询即可。</p>
<p>第三范式（3NF，确保每列都和主键列直接相关，而不是间接相关）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y</p>
<p>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。</p>
<p><img src="/img/2012040114105477.png" alt=""></p>
<p>这样在查询订单信息的时候，就可以使用客户编号来引用客户信息表中的记录，也不必在订单信息表中多次输入客户信息的内容，减小了数据冗余。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/29/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/29/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">清华大学操作系统课程笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-06-29 23:56:00" itemprop="dateCreated datePublished" datetime="2019-06-29T23:56:00+08:00">2019-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-06 19:10:54" itemprop="dateModified" datetime="2022-01-06T19:10:54+08:00">2022-01-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第五讲-物理内存管理"><a href="#第五讲-物理内存管理" class="headerlink" title="第五讲 物理内存管理"></a>第五讲 物理内存管理</h1><h2 id="5-1-计算机体系结构和内存层次"><a href="#5-1-计算机体系结构和内存层次" class="headerlink" title="5.1 计算机体系结构和内存层次"></a>5.1 计算机体系结构和内存层次</h2><p>一个进程使用内存时要满足其要求，在不用时应及时回收。<br>寄存器是非常小的；内存的最小访问是8bit，一次读写32位的话也要注意对齐问题。<br>高速缓存如果不命中，则到内存中查找，在内存中找不到，就读取到内存中再读取，需要操作系统的介入。<br>内存中每一个字节有一个物理地址，硬盘中扇区512字节最小单位，我们希望将线性的物理内存空间转换成逻辑内存空间；很好的把保护（独立地址空间）和共享（访问相同内存）结合，虚拟化（实现更大的逻辑空间）。<br>操作系统中采用的内存管理：重定位（段地址+offset）、分段（希望他能够不连续，将程序分成三个相对独立的空间，代码数据加堆栈）、分页（把内存分成最基本的单位）。<br>MMU（内存管理单元）</p>
<h2 id="5-2-地址空间和地址生成"><a href="#5-2-地址空间和地址生成" class="headerlink" title="5.2 地址空间和地址生成"></a>5.2 地址空间和地址生成</h2><p>物理地址空间是硬件支持的地址空间，多少位就是有多少条地址线；逻辑地址是CPU运行时进程看到的地址，对应可执行文件中的区域，进程的逻辑地址空间需要转换成物理地址空间，最后在总线上访问相应的物理单元。<br>逻辑地址生成：将程序转成汇编码，添加逻辑地址，再进行链接，把多个模块和函数库排成线性的序列，在程序加载要进行重定位，把链接时生成的地址进行平移。<br>在编译时，如果已知运行时起始地址，则可以直接生成地址，如果起始地址改变则要重新编译；在加载时也可生成绝对地址，编译器生成可重定位的代码；执行时地址生成出现在使用虚拟存储的情况下，在执行指令时进行地址转换，最灵活，可以移动指令实现虚拟内存。</p>
<p>CPU：ALU需要逻辑地址的内存内容，MMU进行逻辑地址和内存地址的转换，CPU控制逻辑给总线发送物理地址请求，内存发送物理地址的内容给CPU，操作系统建立逻辑地址和物理地址的映射。<br>CPU在执行指令时，如果访问数据段的数据，如果数据段基址+offset超过了数据段，则内存访问异常，执行失败，调用中断处理程序；如果正确那在段基址寄存器配合下得到相应的地址。  </p>
<h2 id="5-3-连续内存分配"><a href="#5-3-连续内存分配" class="headerlink" title="5.3 连续内存分配"></a>5.3 连续内存分配</h2><p>为了提高效率，采用动态分配算法。<br>连续内存分配指给进程分配一块不小于指定大小的连续物理内存区域，会产生一些碎片，一种是两块分配单元之间的未被使用的内存，内部碎片是分配单元内部的未被使用的内存，取决于分配单元大小是否要考虑取整和对齐。<br>动态分区分配是指程序加载时分配一个进程指定大小可变的分区，分配得到的地址是连续的。操作系统维护两个数据结构，一个是所有进程已分配的分区，另一个是空闲分区。动态分区分配策略有很多：<br>最先匹配（从空闲分区列表里找第一个符合的，释放时检查是不是可以和邻近的空闲分区合并，在高地址有大块的空闲分区，但有很多外部碎片，分配大块时较慢）；<br>最佳匹配（全找一遍，找最合适的，空闲分区按照从小往大排序，释放时跟邻近地址的合并，并且重排序，大部分分配的尺寸较小时比较好，避免大的空闲分区被拆分，减小外部碎片，但是增加了无用的小碎片）；<br>最差匹配（找相差最大的，空闲分区从大到小拍，分配时找最大的，释放时检查可否与邻近的空闲分区合并，进行合并并重排序，如果中等大小的分配较多，则最好，避免出现太多小碎片，但是释放分区比较慢，容易破坏大的空闲分区）。  </p>
<h2 id="5-4碎片整理"><a href="#5-4碎片整理" class="headerlink" title="5.4碎片整理"></a>5.4碎片整理</h2><p>调整已分配的进程占用的分区位置来减少或避免分区碎片，通过移动分配给进程的内存分区，以合并外部碎片。保证所有程序可动态重定位！<br>分区对换：通过抢占并回收处于等待状态进程的分区，以增大可用内存空间。采用对换使多个进程同时运行。</p>
<h2 id="5-5-伙伴系统"><a href="#5-5-伙伴系统" class="headerlink" title="5.5 伙伴系统"></a>5.5 伙伴系统</h2><p>连续内存分配实例。<br>整个可分配的分区约定为2^U，需要的分区大小为2^(U-1) &lt; s &lt; 2^(U)，把整个块分配给这个进程。如s&lt;2^(i-1)-1，将大小为2^i的当前分区划分成2个大小为2^(i-1)的空闲分区，重复划分过程，直到2^(i-1)-1&lt;\s&lt;2^(i)，把一个空闲分区分配给该进程。<br>数据结构：空闲块按照大小和起始地址组织成二维数组，初始时只有一个大小为2^U的块，由小到大在空闲数组找最小的，如果空闲块过大，则进行二等分，直到得到需要的大小是空闲块的1/2还大些。总之，找比它大的最小的空闲块，看是不是比它的二倍大，如果是，就切块，不是的话就分配给它。合并：大小相同且地址相邻，起始地址较小的块的起始地址必须是2^(i+1)的倍数。两个块具有相同大小，且它们物理地址连续。</p>
<blockquote>
<p>为了便于页面的维护，将多个页面组成内存块，每个内存块都有 2 的方幂个页，方幂的指数被称为阶 order。order相同的内存块被组织到一个空闲链表中。伙伴系统基于2的方幂来申请释放内存页。<br>当申请内存页时，伙伴系统首先检查与申请大小相同的内存块链表中，检看是否有空闲页，如果有就将其分配出去，并将其从链表中删除，否则就检查上一级，即大小为申请大小的2倍的内存块空闲链表，如果该链表有空闲内存，就将其分配出去，同时将剩余的一部分（即未分配出去的一半）加入到下一级空闲链表中；如果这一级仍没有空闲内存；就检查它的上一级，依次类推，直到分配成功或者彻底失败，在成功时还要按照伙伴系统的要求，将未分配的内存块进行划分并加入到相应的空闲内存块链表<br>在释放内存页时，会检查其伙伴是否也是空闲的，如果是就将它和它的伙伴合并为更大的空闲内存块，该检查会递归进行，直到发现伙伴正在被使用或者已经合并成了最大的内存块。</p>
</blockquote>
<h1 id="第六讲-物理内存管理-非连续内存分配"><a href="#第六讲-物理内存管理-非连续内存分配" class="headerlink" title="第六讲 物理内存管理: 非连续内存分配"></a>第六讲 物理内存管理: 非连续内存分配</h1><h2 id="6-1-非连续内存分配的需求背景"><a href="#6-1-非连续内存分配的需求背景" class="headerlink" title="6.1 非连续内存分配的需求背景"></a>6.1 非连续内存分配的需求背景</h2><p>一种是段，一种是页，还有段页式。<br>非连续分配的目的是提高内存利用效率和管理灵活性：</p>
<ol>
<li>允许一个程序使用非连续的物理地址空间；</li>
<li>允许共享代码与数据；</li>
<li>支持动态加载和动态链接。<br>如何实现虚拟地址和物理地址的转换？软/硬件。  </li>
</ol>
<h2 id="6-2-段式存储管理"><a href="#6-2-段式存储管理" class="headerlink" title="6.2 段式存储管理"></a>6.2 段式存储管理</h2><p>段的地址空间是如何组织的，内存访问如何进行。<br>进程的地址空间看成若干个段，主代码段、子模块代码段、公用库代码段、堆栈段、初始化数据段、符号表等。段式管理更精细。把逻辑地址空间转换成一个不连续的物理地址空间集。<br>每一个段是访问方式和存储数据等属性一致的一段地址空间；对应一个连续的内存块，若干个段组成了逻辑地址空间，把逻辑地址分成一个二元组（段号，段内偏移地址），再转换成原来的地址。<br>程序访问物理单元时，首先用段号查段表，找到段的起始地址和长度，硬件的存储管理单元（MMU）检查越界，在MMU里利用段地址和偏移找到实际地址。  </p>
<h2 id="6-3-页式存储管理"><a href="#6-3-页式存储管理" class="headerlink" title="6.3 页式存储管理"></a>6.3 页式存储管理</h2><p>物理内存空间分成“帧”，大小是2的n次幂，让这个转换变得方便，逻辑地址空间里也划分成相同大小的基本分配单位“页”，页面到页帧的转换涉及了“页表”、MMU/TLB。<br>物理地址组织成二元组（帧号，帧内偏移量）。逻辑地址空间也是二元组（p，o），逻辑地址中页号是连续的，物理地址的帧号是不连续的，逻辑地址中页号是p，物理地址的帧号是f，用p到页表中找对应的f，页表中保存了每个页的页表基址，用p就可以找到。每个帧的大小是2的n次方，把f左移s位再把页内偏移加上，就可以找到物理地址。  </p>
<h2 id="6-4-页表概述"><a href="#6-4-页表概述" class="headerlink" title="6.4 页表概述"></a>6.4 页表概述</h2><p>从逻辑页号到物理页号的转换，每一个逻辑页号对应一个物理帧号，且随着程序运行变化，动态调整分配给程序的内存大小。这个表存在页表基址寄存器，告诉你这个页表放在哪。页表项中有帧号f，有几个标志位：</p>
<blockquote>
<p>存在位：如果有对应的物理帧则为1；<br>修改位：是否修改对应页面的内容；<br>引用位：在过去一段时间里是否有过引用。</p>
</blockquote>
<p>内存访问性能：访问一个内存单元需要2次内存访问，先获取页表项，再访问数据。<br>页表大小问题：页表可能非常大。<br>处理缓存或者间接访问（一个很长的表，多级页表等）</p>
<h2 id="6-5-快表和多级页表"><a href="#6-5-快表和多级页表" class="headerlink" title="6.5 快表和多级页表"></a>6.5 快表和多级页表</h2><p>快表：缓存近期访问的页表项，在TLB使用关联存储实现，查找对应的key，并行查找表项，具备快速访问性能。如果没有命中只能再次查找内存中的页表并把它加到快表中。<br>多级页表：通过间接引用将页号分为k级。整个访问次数是k+1。建立页表树。先查第一段逻辑地址作为第一级页表的偏移，找到第二级页表的起始，第二段地址作为第二级页表项的偏移，找到第三级页表项的起始。就是说第一段地址是这个页在第一级页表中的偏移，第二段是这个页在第二级页表中的偏移地址。利用多级页表减少了整个页表的长度。  </p>
<h2 id="6-6-反置页表"><a href="#6-6-反置页表" class="headerlink" title="6.6 反置页表"></a>6.6 反置页表</h2><p>对于大地址空间系统，多级页表变得繁琐，让页表项和物理地址空间的大小对应，不让页表项和逻辑地址空间的大小对应。这样进程数目的增加和虚拟地址空间的增大对页表占用空间没影响。<br>页寄存器：每个帧和一个页寄存器关联，寄存器里有：使用位表示此帧是否被使用；占用页号表明对应的页号p，保护位表明使用方式是读或者写。<br>页寄存器中的地址转换：CPU生成的逻辑地址如何找对应的物理地址？对逻辑地址做Hash映射，并解决Hash冲突，利用快表缓存页表项，如果出现冲突，遍历所有的对应页表项，查找失败时产生异常。</p>
<h2 id="6-7-段页式存储管理"><a href="#6-7-段页式存储管理" class="headerlink" title="6.7 段页式存储管理"></a>6.7 段页式存储管理</h2><p>在段式管理的基础上，给每个段加一级页表，得到段的页表，再得到页的地址。</p>
<h1 id="第七讲-实验二-物理内存管理"><a href="#第七讲-实验二-物理内存管理" class="headerlink" title="第七讲 实验二 物理内存管理"></a>第七讲 实验二 物理内存管理</h1><h2 id="7-1-x86保护模式的特权级"><a href="#7-1-x86保护模式的特权级" class="headerlink" title="7.1 x86保护模式的特权级"></a>7.1 x86保护模式的特权级</h2><p>x86的特权级有0，1，2，3，一般只需要0（Kernel）和3（user），有些指令只能在ring 0中执行，CPU在某些情况下也会检查特权级。<br>段选择子位于段寄存器中，程序在代码段中执行，指令执行会访问代码段和数据段。它的DPL位于段描述符中，来进行特权控制。中断门和陷入门中也有对应的DPL。产生中断和内存访问都有对应的CPL和RPL，进行检查确保当前的操作合法。 RPL处于数据段（DS或ES中最低两位），CPL处于指令代码段中（CS最低两位）。<br>数字越低特权级越高，数字越高特权级越低。<br>DPL是要被访问的目标的特权级。访问门时代码段的CPL要小于门的DPL，门的特权级要比较低，执行代码段的特权级比较高，这样才允许通过门（中断陷入什么的）一般特权级的应用程序可以访问处于内核态的操作系统提供的服务；访问段的时候CPL和RPL中的最大值小于DPL，即发出请求的特权级要高于对应目标，DPL的特权级要比较小。</p>
<h2 id="7-2-了解特权级切换过程"><a href="#7-2-了解特权级切换过程" class="headerlink" title="7.2 了解特权级切换过程"></a>7.2 了解特权级切换过程</h2><p>通过中断切换特权级。有一个中断门，通过中断描述符表进行切换，如果产生了中断，内核态ring 0中的栈会压入一系列东西（当前执行的程序的堆栈信息SS，ESP，EFLAGS，保存了回去的地址CS，EIP等）以便恢复现场。如何回到ring3？如果是从ring0跳到ring3的，在栈中会存SS（RPL=3）和ESP，用户的ss和内核态的ss不是同一个数据段，这是特权级的转换，内核栈把数据弹出来了。通过构造一个能返回ring3的栈，再通过iret指令把相关信息弹出栈，这时候运行环境已经变成用户态。<br>从ring3到ring0的转换，建立中断门，一旦产生中断需要保存一些信息。通过对堆栈修改，使其执行完iret后留在ring0执行，修改CS使其指向内核态的代码段。<br>TSS是特殊段，任务状态段，在内存中，保存了不同特权级的堆栈信息。在全局描述符表中有一个专门指向这个TSS。硬件有一个专门的寄存器缓存TSS中的内容，建立TSS是在pmm.c中。</p>
<h2 id="7-3-了解段-页表"><a href="#7-3-了解段-页表" class="headerlink" title="7.3 了解段/页表"></a>7.3 了解段/页表</h2><p>x86内存管理单元MMU<br>有一系列寄存器和段描述符，寄存器里的信息最高端的十几位作为索引来找全局描述符表（GDT）里的一项，找对应的项，一项就是一个段描述符，描述了地址和基址，base address+EIP这个offset找到最终的线性地址。 如果没有页机制的话，线性地址就是物理地址。<br>MMU放在内存中，每次访问要先查找GDT（段表），靠硬件实现把建立在GDT里的段描述符的相关信息放在一些寄存器中的隐藏部分，缓存了基址和段大小等隐藏信息，放在CPU内部的。<br>在entry.S中建立了映射机制，lab1建立的是对等映射，而lab2中base_address是 -0xC0000000，虚地址比线性地址大0xC0000000.只是这个用到的映射关系（放在GDT中的信息）不同。</p>
<h2 id="7-4-了解UCORE建立段-页表"><a href="#7-4-了解UCORE建立段-页表" class="headerlink" title="7.4 了解UCORE建立段/页表"></a>7.4 了解UCORE建立段/页表</h2><p>一个虚拟地址它分了三块，一个典型的二级页表是32位的地址，第一个是Offset，占了12位，中间的二级页表对应的页表项占了10位，高的页目录项也占了10位。那么高的这10位是用来作为index查找这个页目录表里面的对应的项，这叫PDE，是页目录的entry，PDE记录的是二级页表里面的起始地址。所以说根据PDE里面的信息可以找到Page Table的起始地址。同时根据第二级Table这里面的10位作为index来查这个Page Table对应的项。称之为PTE。这个PTE就是Page Table Entry。存的是这个线性地址它所对应的一个页的起始地址。这一个页大小多其实由它的Offset可以算出来，12位意味着一个页的大小是4k。base_address加上offset得到了地址。<br>进入保护模式后段机制一定存在，为了保护。<br>根据地址的前10位找到Page Table的物理地址，中间12位找到PDE，计算物理页的基址。利用PDE和PTE加上offset算出地址。<br>CR3寄存器保存了页目录地址。  CR0的31位如果置1的话就打开了页机制。<br>页的基址、页表的基址都是20位，剩下12位存下了一些信息（只读？用户态或内核态）<br>分配一个4k的页作为页目录的Table，清理这个Page做初始化，建立页表，在页目录表和页表中填好对应信息。0xC0000000到0xF8000000这块空间会映射到物理地址的0x00000000到0x38000000这么一个地址，它的偏移值是0xC0000000，链接时用到的起始地址就是0xC0000000，把0x00000000到0x00100000映射到0x00100000的对等映射，且把CR0的31位置1，即enable了页机制，需要UPDATE GDT，使段机制的不对等映射变成对等映射，又做了取消0x00000000到0x00100000映射的操作。  </p>
<h1 id="第八讲-虚拟存储概念"><a href="#第八讲-虚拟存储概念" class="headerlink" title="第八讲 虚拟存储概念"></a>第八讲 虚拟存储概念</h1><h2 id="8-1-虚拟存储的需求背景"><a href="#8-1-虚拟存储的需求背景" class="headerlink" title="8.1 虚拟存储的需求背景"></a>8.1 虚拟存储的需求背景</h2><p>对存储容量的需求，需要容量更大、速度更快、价格更便宜的非易失性存储器。</p>
<h2 id="8-2-覆盖和交换"><a href="#8-2-覆盖和交换" class="headerlink" title="8.2 覆盖和交换"></a>8.2 覆盖和交换</h2><p>覆盖：在较小的内存中运行较大的程序，依据程序逻辑结构，将程序划分为若干功能独立的模块，不会同时执行的模块共享同一块内存。必要部分通常是常用功能，常驻内存，可选部分不常用只需要在用到时装入内存。不存在调用关系的部分共享一部分内存。<strong>将程序分成多组，每组按照这一组里最大的内存进行分配</strong>。开发难度增加，由程序员进行模块划分，确定模块间的覆盖关系；也增加了执行时间，从外存装入覆盖模块。<br>交换：增加正在运行或需要运行的程序的内存，将暂时不运行的程序放到外存。这是以进程为单位的交换技术。只有当内存空间不够或有不够的可能时才换出。交换区是用来存放所有用户进程的所有内存映像的拷贝。程序换入时采用动态地址映射的方法，重定位。</p>
<h2 id="8-3-局部性原理"><a href="#8-3-局部性原理" class="headerlink" title="8.3 局部性原理"></a>8.3 局部性原理</h2><p>把内存中的信息放到外存中来需要准备工作。只把部分程序放到内存中，从而运行比物理内存大的程序，操作系统自动加载而不需要程序猿干预。实现进程在内外存之间的交换，从而获得更多的空闲内存空间。<br>局部性原理：所谓局部性原理呢是指程序在执行的过程当中在一个较短的时间里，它所执行的指令和指令操作数的地址分别局限于在一定区域里，因为通常情况下我们指令是存在代码段里的，指令所访问的操作数呢通常是存在数据段里的，这两个各是一个地方，那这两个的地方分别局限在一定区域里头。</p>
<ol>
<li>第一个叫时间局部性，也就是说我一条指令的连续两次执行和一个数据的连续两次访问通常情况下都集中在一段较短的时间里；</li>
<li>空间局部性，我相邻的几条指令访问的相邻的几个数据通常情况下是局限在一个较小的区域里头；</li>
<li>叫分支局部性，一条跳转指令的两次执行很多时候是会跳转到同一个地址的。<br>如果能判断他们局部的地区在哪，就可以充分利用这种局部性，虚拟存储也具有可行性。</li>
</ol>
<h2 id="8-4-虚拟存储概念"><a href="#8-4-虚拟存储概念" class="headerlink" title="8.4 虚拟存储概念"></a>8.4 虚拟存储概念</h2><p>将不常用的内存块暂存到外存。<br>装载程序时只需将当前指令所需要的页面加载到内存，指令执行中需要的指令或数据不在内存时处理器通知操作系统将相应的页面调入内存。<br>基本特征：</p>
<ol>
<li>不连续性：物理内存分配非连续，虚拟地址空间使用非连续；</li>
<li>大用户空间：提供给用户的虚拟内存可以大于实际的物理内存；</li>
<li>部分交换：只对部分虚拟地址空间进行调入和调出。 </li>
</ol>
<p>硬件支持：页式或短时存储的地址转换机制。<br>操作系统：管理内存和外存页面或段的换入换出。  </p>
<h2 id="8-5-虚拟页式存储"><a href="#8-5-虚拟页式存储" class="headerlink" title="8.5 虚拟页式存储"></a>8.5 虚拟页式存储</h2><p>在页式存储管理的基础上增加请求调页和页面置换。当用户程序要装载到内存中时只装入部分页面就启动程序运行，进程在发现运行中需要的代码或数据不在内存中时，发送缺页异常请求，操作系统在处理缺页异常时将外村中相应的页面调入内存，使进程能继续运行。需要一个缺页异常的处理例程。<br>造成的修改：原来以逻辑页号为序号就可以找到物理帧号，有了这个物理页帧号之后，就能转换出相应的物理地址。现在增加一些标志位：</p>
<ol>
<li>驻留位：它是表示该页面是否在内存当中，如果是1表示在内存当中，此时一定可以找到它的页帧号，可以转换成物理内存单元的地址；如果它是0，表示这一页在外存中这时候就会导致缺页。</li>
<li>修改位：表示这一页在内存当中是否被修改，这必须是驻留位有效的情况下。这一页如果被修改过，若想把这一页淘汰，必须把内存当中修改的内容写回到外存当中。</li>
<li>访问位：表示是否被访问过，用于页面置换算法；</li>
<li>保护位：可读可写可执行等。  </li>
</ol>
<p>在32位x86系统中，有12位的页内偏移，两个10位的二级页表项，物理地址也是32位，其中20位是物理页帧号。这时使用二级页表。页表项的起始地址是CR3，一个页表项四字节，4k为一页，一页里有1024页表项，刚好是10位。<br>地址转换：先是一级页表项里头的页号到以及页表中，作为它的偏移找到相应的页表项。这个页表项里有一个第二级页表项的物理页号，这时再加上第二级的页号，第二级页表项里 以它页号作为偏移找到相应的页表项，这时就是要访问的物理页面的物理帧号，帧号和偏移加在一起得到你的物理地址。<br>变化的是页表项内部的东西：前20位的物理页帧号无变化，后边的标志位有变化。用户态标志U表示是否可以在用户态访问；保留位AVL；WT位写出到缓存还是直接写出到内存，CD缓存是否有效。</p>
<h2 id="8-6-缺页异常"><a href="#8-6-缺页异常" class="headerlink" title="8.6 缺页异常"></a>8.6 缺页异常</h2><p>在CPU要访问一条指令，load M，去找M对应的表项，如果M无效，抛出异常调用缺页异常服务例程。首先找到对应的一页在外存中的位置，找到了且有空闲页则读进来并修改对应的页表项。<br>如果空闲页没找到，则根据页面替换算法找到被替换的物理页帧，再判断这个物理页帧是否修改过，如果修改过，就写回。修改各种驻留位。重新执行产生缺页的指令。<br>外存管理：在何处保存未被映射的页？外存中有对换区。<br>虚拟页式存储中的外存选择：代码段直接指向可执行文件；动态加载的共享库指向动态库文件；其他段就可以放到对换区中。<br>有效存储访问时间：访存时间*(1-p) + 缺页异常处理时间*缺页率p</p>
<h1 id="第九讲-页面置换算法"><a href="#第九讲-页面置换算法" class="headerlink" title="第九讲 页面置换算法"></a>第九讲 页面置换算法</h1><h2 id="9-1-页面置换算法的概念"><a href="#9-1-页面置换算法的概念" class="headerlink" title="9.1 页面置换算法的概念"></a>9.1 页面置换算法的概念</h2><p>出现缺页异常时，调入新页面且内存已满时置换页面。尽可能减少页面调入调出次数。把近期不再访问的页面调出。有些页面必须常驻内存，或是操作系统的关键部分，或是要求响应速度的页面，加上一个锁定位。  </p>
<blockquote>
<p>局部页面置换：置换页面的选择仅限于当前进程占用的物理页面；最优算法、先进先出、最近最久未使用<br>全局置换算法：选择所有可换出的物理页面</p>
</blockquote>
<h2 id="9-2-最优算法、先进先出算法和最近最久未使用算法"><a href="#9-2-最优算法、先进先出算法和最近最久未使用算法" class="headerlink" title="9.2 最优算法、先进先出算法和最近最久未使用算法"></a>9.2 最优算法、先进先出算法和最近最久未使用算法</h2><ol>
<li>最优算法：缺页时计算内存中每个页面的下一次访问时间，选择未来最长时间不被访问的页面。缺页次数最少，但无法实现，无法预知每个页面在下次访问的间隔时间。可以作为置换算法的评测依据。  </li>
<li>先进先出算法：选择在内存中驻留时间最长的页面进行置换。维护一个记录所有位于内存中的逻辑页面链表，链表元素按照驻留内存时间排序，链首时间最长。出现缺页时把链首页面进行置换，新加的页面加到链尾。性能差，调出的页面可能是经常访问的，可能出现belady现象。  </li>
<li>最近最久未使用算法：选择最长时间没有被引用的页面进行替换，如果某些页面长时间未访问，那在未来可能也不访问。缺页时计算每个逻辑页面上次访问时间。  </li>
</ol>
<p>LRU可能的实现：</p>
<ol>
<li>页面链表。系统维护一个按最近一次访问时间排序的页面链表，链表首节点是最近刚刚使用过的页面，尾节点是最久未使用的页面。访问内存时，找到相应页面并将其移动到链表之首，缺页时替换尾节点的页面。</li>
<li>活动页面栈，访问时将页号压入栈顶，并将栈内相同页号抽出，缺页时置换栈底页面。开销大！</li>
</ol>
<h2 id="9-3-时钟置换算法和最不常用算法"><a href="#9-3-时钟置换算法和最不常用算法" class="headerlink" title="9.3 时钟置换算法和最不常用算法"></a>9.3 时钟置换算法和最不常用算法</h2><ol>
<li><p>时钟置换算法：对页面访问进行大致统计，过去一段时间访问过就不管它，如果没访问过就按照时间踢出去。先对数据结构做了一些改动，页表项里增加了一个访问位，用来描述在过去一段时间里这个页是否被访问过，把这些页面组织成一个环形链表，定义指针在环形链表上进行周期性的循环，这也是我们这个时钟这个词的。指针指向最先调入的页面。访问页面时在页表项中记录页面访问，缺页时从指针处开始顺序查找未被访问的页面进行置换。  </p>
<blockquote>
<p>装入页面时访问位初始化为0，访问时页面置为1，缺页时，从指针当前顺序检查环形链表，访问位为0则置换，访问位为1，则访问位置为0，指针移动到下一个页面，直到找到可替换的页面。</p>
</blockquote>
</li>
<li><p>改进的Clock算法：减少修改页的缺页处理开销。在页表项中加入修改位，并在访问时进行修改，缺页时，修改页面标志位，跳过有修改的页面。如果访问位和修改位都是0，那就直接替换。<strong>访问1修改0</strong>的改成<strong>访问0修改0</strong>，<strong>访问1修改1</strong>的改成<strong>访问0修改1</strong>，改修改标志的时候并不写出，由系统执行写出。主要修改时考虑了修改的页面，推迟了被修改页面的替换。</p>
</li>
<li>最不常用算法（LFU）：每个页面设置一个访问计数，访问页面时访问次数加一，缺页时置换计数最小的页面。可能有开始常用但是之后不常用的，这时需要定期对计数器进行衰减。LRU关注多久未访问，LFU关注访问次数。</li>
</ol>
<h2 id="9-4-BELADY现象和局部置换算法比较"><a href="#9-4-BELADY现象和局部置换算法比较" class="headerlink" title="9.4 BELADY现象和局部置换算法比较"></a>9.4 BELADY现象和局部置换算法比较</h2><p>belady现象是指采用FIFO等算法时，可能出现随着分配的页面增加，缺页次数反而升高的现象。原因是FIFO算法的置换特征与进程访问内存的动态特征矛盾，被他置换出去的页面并不一定是进程近期不会访问的。LRU是没有belady现象的。类似于栈的算法（LRU）一般不会有belady现象。<br>比较：</p>
<blockquote>
<p>LRU依据页面的最近访问时间排序，动态调整；<br>FIFO依据页面进入内存时间排序，页面进入时间固定不变；<br>CLOCK是折中，页面访问时不动态调整页面在链表中的顺序，缺页时再把它移动到链表末尾。</p>
</blockquote>
<h2 id="9-5-工作集置换算法"><a href="#9-5-工作集置换算法" class="headerlink" title="9.5 工作集置换算法"></a>9.5 工作集置换算法</h2><p>全局置换算法之一：工作集置换算法<br>为进程非配可变数目的物理页面。进程的内存需求时有变化，分配给进程的内存也要在不同阶段变化，全局置换算法需要确定分配给进程的物理页面数量。<br>CPU利用率和并发进程的关系：</p>
<blockquote>
<p>随着并发进程增加CPU利用率增加；<br>但是之后随着内存吃紧，利用率下降；<br>进程数少时提高并发进程数，可以提高CPU利用率；<br>并发进程导致了内存访问增加；<br>并发进程的内存访问会降低访存的局部性特征，导致了缺页率上升。  </p>
</blockquote>
<p>工作集是进程当前使用的逻辑页面集合，表示为二元函数（t, delta），t是当前执行时刻，delta是工作集窗口，代表定长页面访问时间窗口。W(t, delta)是当前时刻t前的delta时间窗口的所有访问页面组成的集合。<br>工作集变化：</p>
<blockquote>
<p>进程开始执行时，随着访问新页面逐步建立稳定的工作集；<br>当内存访问的局部性区域位置大致稳定时，工作及大小也逐步稳定；<br>局部性区域改变位置时，工作集快速扩张和收缩过渡到下一个稳定值。  </p>
</blockquote>
<p>令全局置换算法与工作集变化曲线相拟合。<br><strong>常驻集是进程实际驻留内存的页面集合</strong>，<strong>工作集是进程在运行中的固有属性，而常驻集是取决于系统分配给进程的物理页面数目和页面置换算法</strong>。<br>常驻集如果包含了工作集，缺页率比较小；工作集发生剧烈变动时，缺页较多；进程常驻集达到一定大小之后，缺页率也不会明显下降。</p>
<p><strong>工作集置换算法</strong><br>换出不在工作集中的页面。维护一个访存页面链表，访存时换出不在工作集的页面，更新访存链表，缺页时换入页面，更新访存链表。</p>
<blockquote>
<ul>
<li>工作集的大小是变化的。</li>
<li>相对比较稳定的阶段和快速变化的阶段交替出现。</li>
<li>根据局部性原理，进程会在一段时间内相对稳定在某些页面构成的工作集上。</li>
<li>当局部性区域的位置改变时，工作集大小快速变化。</li>
<li>当工作集窗口滑过这些页面后，工作集又稳定在一个局部性阶段。</li>
<li>工作集精确度与窗口尺寸 ∆ 的选择有关。如果 ∆ 太小，那么它不能表示进程的局部特征；如果 ∆ 为无穷大，那么工作集合是进程执行需要的所有页面的集合。</li>
<li>如果页面正在使用，它就落在工作集中；如果不再使用，它将不出现在相应的工作集中。</li>
<li>工作集是局部性原理的近似表示。</li>
<li>如果能找出一个作业的各个工作集，并求出其页面数最大者，就可估计出该进程所需的物理块数。</li>
<li>利用工作集模型可以进行页面置换。工作集页面置换法的基本思想：找出一个不在工作集中的页面，把它淘汰。</li>
</ul>
</blockquote>
<h2 id="9-6-缺页率置换算法"><a href="#9-6-缺页率置换算法" class="headerlink" title="9.6 缺页率置换算法"></a>9.6 缺页率置换算法</h2><p>缺页率：缺页次数与内存访问次数的比值，或缺页平均时间间隔的倒数，受到页面置换算法、分配给进程的物理页面数目、页面大小和程序本身的影响。缺页率随着物理页面的增加而降低。<br>通过调节常驻集的大小，使每个进程的缺页率保持在合理范围内，若进程缺页率过高，则增加常驻集以分配更多物理页面，若进程缺页率过低，则减少常驻集以给其他进程分配更多物理页面。<br>方法：访存时设置引用位标志，出现缺页时计算从上次缺页时间到现在时间的时间间隔，如果隔的时间比较长，则置换这段时间被没有被引用的页，认为这段时间的缺页率比较低；如果这段时间大于特定的值，则认为这段时间的缺页率较高，则增加常驻集。<br><strong>进程驻留在内存中的页面是有变化的。与前边的工作集算法的区别主要在于缺页率置换把置换放到缺页中断中完成</strong></p>
<h2 id="9-7-抖动和负载控制"><a href="#9-7-抖动和负载控制" class="headerlink" title="9.7 抖动和负载控制"></a>9.7 抖动和负载控制</h2><p>抖动是指进程物理页面较少，不能包含工作集，造成<strong>大量缺页</strong>，频繁置换，使进程运行速度变慢。主要原因是随着驻留内存进程数目不断增加，分配给每个进程的物理页面数量不断减少，缺页率不断上升。因此，操作系统需要在并发数目和缺页率之间达到一个平衡，选择适当的进程数目和进程需要的物理页面数。<br>通过调节并发进程数来进行系统负载均衡。<br>平均缺页间隔时间（MTBF） 是否等于 缺页异常处理时间（PFST）。间隔大于处理时间则处理是可以完成的，比较好。</p>
<h1 id="第十讲-实验三-虚拟内存管理"><a href="#第十讲-实验三-虚拟内存管理" class="headerlink" title="第十讲 实验三 虚拟内存管理"></a>第十讲 实验三 虚拟内存管理</h1><h2 id="10-1-实验目标：虚存管理"><a href="#10-1-实验目标：虚存管理" class="headerlink" title="10.1 实验目标：虚存管理"></a>10.1 实验目标：虚存管理</h2><p>有关虚拟内存管理。提供给比实际物理内存空间更大的虚拟内存空间。完成Page Fault异常和FIFO页替换算法。</p>
<h2 id="10-2-回顾历史和了解当下"><a href="#10-2-回顾历史和了解当下" class="headerlink" title="10.2 回顾历史和了解当下"></a>10.2 回顾历史和了解当下</h2><p>Lab1 完成了保护模式和段机制的建立，完成了中断机制，可以输出字符串。<br>中断描述符表寄存器存了中断门，记录了当产生一个中断时用哪个例程处理这个中断。一旦产生中断，根据它的编号找到IDT，记录了一个offset和一个选择子，这个选择子作为一个索引来查找另外一个表GDT全局描述符表（段表），找到基址，这个基址加上offset形成了中断服务例程的入口地址。<br>Lab2完成物理内存管理，查找物理内存，建立基于连续物理内存空间的动态内存分配与释放算法，完成了页机制的建立。<br>页表的起始地址放在CR3寄存器中，页目录表中每一项是一个页目录项，其中的address指向对应页表的起始地址，对页表项，存放着物理页页帧的起始地址，加上页内偏移形成最终地址。<br>初始化函数在kern_init中，vmm_init。关键数据结构：vma_struct和mm_struct。swap.c和swap.h中有相应说明。</p>
<h2 id="10-3-处理流程、关键数据结构和功能"><a href="#10-3-处理流程、关键数据结构和功能" class="headerlink" title="10.3 处理流程、关键数据结构和功能"></a>10.3 处理流程、关键数据结构和功能</h2><p>swap_init：如何建立交换分区并完成以页为单位的硬盘读写。<br>vmm_init：分配一定物理页，如何建立模拟访问机制访问特定虚拟页。  </p>
<h2 id="10-4-页访问异常"><a href="#10-4-页访问异常" class="headerlink" title="10.4 页访问异常"></a>10.4 页访问异常</h2><p>产生页访问异常时，调用_alltrap的trap进行处理，调用pgfault_handler，进一步调用do_pgfault，建立一个使用者的虚拟环境，根据缺页异常的地址查找，看是不是硬盘中的一个页，把这一页读到内存中，建立映射关系，这样可以正确访问内存了。重新执行产生缺页异常的指令。  </p>
<h2 id="10-5-页换入换出机制"><a href="#10-5-页换入换出机制" class="headerlink" title="10.5 页换入换出机制"></a>10.5 页换入换出机制</h2><p>应该换出哪个页？在kern/mm/swap.c中有具体说明。建立虚拟页和磁盘扇区的对应关系：用到了swap_entry_t，其中有24bit代表磁盘扇区的编号，虚拟页编号在页表的index中，磁盘扇区的index可以写到页表项（PTE）中，虚拟页和磁盘扇区的对应也可以放到页表项中。 页表项多了一个功能，是虚拟页和磁盘扇区的对应关系，如果present位是0，代表没有映射关系，不存在物理页和虚拟页帧的对应关系，这样就可以代表虚拟页和硬盘扇区的关系。<br>页替换算法：FIFO、Clock等。<br>何时进行页换入换出：主动、被动。  </p>
<h1 id="第十一讲-进程和线程"><a href="#第十一讲-进程和线程" class="headerlink" title="第十一讲 进程和线程"></a>第十一讲 进程和线程</h1><h2 id="11-1-进程的概念"><a href="#11-1-进程的概念" class="headerlink" title="11.1 进程的概念"></a>11.1 进程的概念</h2><p>进程是一个具有一定功能的程序在一个<strong>数据集合</strong>中的一次<strong>动态执行</strong>过程。源代码到可执行文件再到加载到进程地址内存空间（堆、栈、代码段）。进程浩瀚了正在运行的一个程序的所有状态的信息，进程是由：</p>
<ul>
<li>代码</li>
<li>数据</li>
<li>状态寄存器：CPU状态CR0、指令指针IP等</li>
<li>通用寄存器：AX、BX、CX…</li>
<li>进程占用系统资源：打开文件、已分配内存</li>
</ul>
<p>特点：</p>
<ul>
<li>动态性：动态创建</li>
<li>并发性：独立调度并占用处理机运行</li>
<li>独立性：不同进程相互工作不影响</li>
<li>制约性：因访问共享数据和资源或进程间同步产生制约</li>
</ul>
<p>进程是处于运行状态程序的抽象，程序是一个静态的可执行文件，进程是执行中的程序，是程序+执行状态；同一个程序的多次执行过程对应不同进程；进程执行需要内存和CPU。<br>进程是动态的，程序是动态的，程序是有序代码的集合，进程是程序的俄执行，进程有核心态和用户态；进程是暂时的，程序是永久的，进程的组成包括<strong>程序</strong>、<strong>数据</strong>和<strong>进程控制块</strong>。</p>
<h2 id="11-2-进程控制块（PCB）"><a href="#11-2-进程控制块（PCB）" class="headerlink" title="11.2 进程控制块（PCB）"></a>11.2 进程控制块（PCB）</h2><p>是操作系统控制进程运行的信息集合。操作系统用PCB来描述进程的基本情况和运行变化的过程。PCB是<strong>进程存在的唯一标志</strong>。</p>
<ul>
<li>进程创建：生成该进程的PCB；</li>
<li>进程终止：回收PCB；</li>
<li>进程的组织管理：通过对PCB的组织管理实现。</li>
</ul>
<p>进程控制块内容：</p>
<ul>
<li>进程标识信息</li>
<li>处理机现场保存：从进程地址空间抽取PC、SP、其他寄存器保存</li>
<li>进程控制信息：调度和状态信息（调度进程和处理机使用情况）、进程间通信信息（通信相关的标识）、存储管理信息（指向进程映像存储空间数据结构）、进程所用资源（进程使用的系统资源，文件等）、有关数据结构链接信息（与PCB有关的进程队列）</li>
</ul>
<p>进程控制块的组织：</p>
<ul>
<li>链表：同一状态的进程其PCB组织成一个链表，多个状态对应不同链表；</li>
<li>索引表：同一状态的进程归入一个索引表，由索引指向PCB，多个状态对应多个不同的索引表。</li>
</ul>
<h2 id="11-3-进程状态"><a href="#11-3-进程状态" class="headerlink" title="11.3 进程状态"></a>11.3 进程状态</h2><p>操作系统为了维护进程执行中的变化来维护进程的状态。进程的生命周期分为：</p>
<ul>
<li>进程创建：创建PCB、拷贝数据。引起进程创建主要有：系统初始化、用户请求创建进程、正在执行的进程执行了创建进程的调用；</li>
<li>进程就绪：放入等待队列中等待运行；</li>
<li>进程执行：内核选择一个就绪进程，占用处理机并执行；</li>
<li>进程等待：进程执行的某项条件不满足，比如请求并等待系统服务、启动某种操作无法马上完成，<strong>只有进程自身知道何时需要等待某种事件的发生</strong>；</li>
<li>进程抢占：高优先级的进程就绪或进程执行时间片用完；</li>
<li>进程唤醒：被阻塞的进程需要的资源可满足，进程只能被别的进程或操作系统唤醒；</li>
<li>进程结束：把进程执行占用的资源释放，有几种可能：正常、错误退出、致命错误、强制退出。</li>
</ul>
<p>N个进程交替运行，假定进程1执行sleep()，内核里调用计时器，进程1把当前进程占用寄存器的状态保存，切换进程2，如果计时器到点了，计时器产生中断，保存进程2的状态，恢复进程1的状态。</p>
<h2 id="11-4-三状态进程模型"><a href="#11-4-三状态进程模型" class="headerlink" title="11.4 三状态进程模型"></a>11.4 三状态进程模型</h2><p>核心是：</p>
<ul>
<li>就绪：进程获得了除了处理机之外的所有资源，得到处理机即可运行；</li>
<li>运行：进程正在处理机上执行；</li>
<li>等待：进程在等待某一事件在等待。</li>
</ul>
<p>辅助状态两种：</p>
<ul>
<li>创建：一个进程正在被创建，还未被转到就绪状态之前的状态；</li>
<li>结束：进程正在从系统中消失的状态，这是因为进程结束或其他原因所导致。</li>
</ul>
<p>状态转换：</p>
<ul>
<li>创建 -&gt; 就绪：进程被创建并完成初始化，变成就绪状态；</li>
<li>就绪 -&gt; 运行：处于就绪状态的进程被调度程序选中，分配到处理机上运行；</li>
<li>运行 -&gt; 结束：进程表示它已经完成或因为出错，当前运行今晨会由操作系统作结束处理；</li>
<li>运行 -&gt; 就绪：处于运行状态的进程在其运行过程中，由于分配给它的处理机时间片用完而让出处理机；</li>
<li>运行 -&gt; 等待：当进程请求某资源且必须等待时；</li>
<li>等待 -&gt; 就绪：进程等待的某事件到来时，它从阻塞状态变到就绪状态；</li>
</ul>
<h2 id="11-5-挂起进程模型"><a href="#11-5-挂起进程模型" class="headerlink" title="11.5 挂起进程模型"></a>11.5 挂起进程模型</h2><p>处于挂起状态的进程映像在磁盘上，目的是减少进程占用内存。</p>
<ul>
<li>等待挂起：进程在外存并等待某事件的发生；</li>
<li>就绪挂起：进程在外存，但是只要进入内存即可运行；</li>
<li>挂起：把进程从内存转到外存</li>
</ul>
<p>增加了内存的转换：</p>
<ul>
<li>等待 -&gt; 等待挂起：没有进程处于就绪状态或就绪状态要求更多内存资源；</li>
<li>就绪到就绪挂起：有高优先级等待进程（系统认为很快就绪）和低优先级就绪进程；</li>
<li>运行 -&gt; 就绪挂起：对抢先式分时系统，当有高优先级等待挂起进程因事件出现而进入就绪挂起；</li>
</ul>
<p>从外存转到内存的转换：激活</p>
<ul>
<li>就绪挂起 -&gt; 就绪：没有就绪进程或挂起就绪进程优先级高于就绪进程；</li>
<li>等待挂起 -&gt; 等待：进程释放了足够内存，并有高优先级的等待挂起进程；</li>
</ul>
<p>状态队列：有操作系统维护一组队列，表示系统所有进程的当前状态。<br>根据进程状态不同，进程PCB加入不同队列，进程状态切换时，加入不同队列。</p>
<h2 id="11-6-线程的概念"><a href="#11-6-线程的概念" class="headerlink" title="11.6 线程的概念"></a>11.6 线程的概念</h2><ul>
<li>为什么要引入线程<br>在进程内部增加一类实体，满足实体之间可以并发执行且实体之间可以共享相同的地址空间。线程是进程的一部分，描述指令流执行状态，它是进程中指令执行流的最小单元，是CPU调度的单位。这种剥离为并发提供了可能，描述了在进程资源环境中的指令流执行状态；进程扮演了资源分配的角色。<br>原来只有一个指令指针，现在有多个堆栈和指令指针。线程=进程-共享资源。<br>但是如果一个线程有异常，会导致其所属进程的所有线程都崩。  </li>
<li>比较</li>
<li>进程是资源分配单位，线程是CPU调度单位；</li>
<li>进程有一个完整的资源平台，线程只独享指令流执行的必要资源，如寄存器和栈；</li>
<li>线程具有就绪、等待和运行三种基本状态和其转移关系；</li>
<li>线程能减少并发执行的时间和空间开销：</li>
</ul>
<ol>
<li>线程创建时间短；</li>
<li>线程的终止时间比进程短；</li>
<li>同一进程的线程切换时间比进程短；</li>
<li>由于同一进程的各个线程共享内存和文件资源，可不通过内核进行直接通信。</li>
</ol>
<h2 id="11-7-用户线程"><a href="#11-7-用户线程" class="headerlink" title="11.7 用户线程"></a>11.7 用户线程</h2><p>三种实现方式：  </p>
<ul>
<li>用户线程：在用户空间实现，通过用户级的线程库函数完成线程的管理。在操作系统内核中仍然只有进程控制块来描述处理机的调度的情况，操作系统并不感知应用态有多线程的支持，多线程的支持是用户的函数库支持的。在应用程序内部通过构造相应的线程控制块<br>来控制一个进程内部多个线程的交替执行和同步。<br>这种方法不依赖操作系统内核，用于不支持线程的多线程的操作系统。每个进程有私有的<strong>线程控制块(TCB)</strong>，TCB由线程库函数维护；同一进程的用户线程切换速度快，无需用户态/核心态的切换，且允许每个进程有自己的线程调度算法。<br>缺点就是不支持基于线程的处理机抢占， 除非当前运行的线程主动放弃CPU，他所在进程的其他线程无法抢占CPU。<br>POSIX Pthreads、Math C-threads、Solaris threads  </li>
<li>内核线程：在内核中实现，Windows、Solaris、Linux  </li>
<li>轻量级进程：在内核中实现，支持用户进程。</li>
</ul>
<h2 id="11-8-内核线程"><a href="#11-8-内核线程" class="headerlink" title="11.8 内核线程"></a>11.8 内核线程</h2><p>内核通过系统调用完成的线程机制。由内核维护PCB和TCB，线程执行系统调用而阻塞不影响其他线程，以线程为单位的进程调度会更合理。<br><strong>轻权进程</strong>：内核支持的用户线程，一个进程有多个轻量级进程，每个轻权进程由一个单独的内核线程来支持。在内核支持线程，轻权进程来绑定用户线程。<br>用户线程与内核线程的对应关系：一对一、多对一、多对多。</p>
<h1 id="第十二讲-进程控制"><a href="#第十二讲-进程控制" class="headerlink" title="第十二讲 进程控制"></a>第十二讲 进程控制</h1><h2 id="12-1-进程切换"><a href="#12-1-进程切换" class="headerlink" title="12.1 进程切换"></a>12.1 进程切换</h2><p>上下文切换，暂停当前运行的进程，从当前运行状态转变成其他状态，调度另一个进程从就绪状态变成运行状态，在此过程中实现<strong>进程上下文的保存和快速切换</strong>。维护进程生命周期的信息（寄存器等）。</p>
<p>进程控制块PCB：内核为每个进程维护了对应的PCB，将相同状态的进程的PCB放置在同一个队列中。</p>
<p>ucore中的进程控制块结构proc_struct：</p>
<ul>
<li>进程ID、父进程ID，组ID；</li>
<li>进程状态信息、地址空间起始、页表起始、是否允许调度；</li>
<li>进程所占用的资源struct mm_struct* mm；</li>
<li>现场保护的上下文切换的context；</li>
<li>用于描述当前进程在哪个状态队列中的指针，等。</li>
</ul>
<p>ucore的切换流程：开始调度 -&gt; 清除调度标志 -&gt; 查找就绪进程 -&gt; 修改进程状态 -&gt; 进程切换switch_to()。<br>switch_to用汇编写成。。。</p>
<h2 id="12-2-进程创建"><a href="#12-2-进程创建" class="headerlink" title="12.2 进程创建"></a>12.2 进程创建</h2><p>Windows进程创建API：CreateProcess<br>Unix进程创建系统调用：fork/exec，fork()把一个进程复制成两个进程，exec()用新程序重写当前进程。</p>
<p>fork()的地址空间复制：fork调用对子进程就是在调用时间对父进程地址空间的一次复制。执行到fork时，复制一份，只有PID不同。系统调用exec()加载新程序取代当前运行的程序。加载进来后把代码换掉。</p>
<p>ucore中的do_fork：分配进程控制块数据结构、创建堆栈、复制内存数据结构、设置进程标识等。操作系统没有新的任务执行，则创建空闲进程，在proc_init中分配idleproc需要的资源，初始化idleproc的PCB。</p>
<p>fork的开销昂贵，在fork中内存复制是没用的，子进程将可能关闭打开的文件和连接，所以可以将fork和exec联系起来。产生了vfork，创建进程时不再创建一个同样的内存映像，用时再加载，一些时候称为轻量级fork。这时子进程应立即执行exec。现在使用写时复制技术。</p>
<h2 id="12-3-进程加载"><a href="#12-3-进程加载" class="headerlink" title="12.3 进程加载"></a>12.3 进程加载</h2><p>应用程序通过exec加载可执行文件，允许进程加载一个完全不同的程序，并从main开始执行。不同系统加载可执行文件的格式不同，并且允许进程加载时指定启动参数（argc,argv），exec调用成功时，它与运行exec之前是相同的进程，但是运行了不同的程序，且代码段和堆栈重写。主要是可执行文件格式的识别，有sys_exec、do_execv、load_icode函数。</p>
<p>ucore中第一个用户态进程是由proc_init创建的，执行了init_main创建内核线程，创建了shell程序。</p>
<h2 id="12-4-进程等待与退出"><a href="#12-4-进程等待与退出" class="headerlink" title="12.4 进程等待与退出"></a>12.4 进程等待与退出</h2><p>父子进程的交互，完成子进程的资源回收。</p>
<p>子进程通过exit()向父进程返回一个值，父进程通过wait()接受并处理这个返回值。wait()父进程先等待，还是子进程先做exit()，这两种情况会导致它下面的处理有一些区别。</p>
<p>如果有子进程存活，也就是说父进程创建的子进程还有子进程，那这时候父进程进入等待状态，等待子进程的返回结果，父进程先执行wait，等到子进程执行的时候它执行exit()，这是exit ()是在wait之后执行的。这时候，子进程的exit()退出，唤醒父进程，父进程由等待状态回到就绪状态，父进程就处理子进程的返回的这个返回值，这是wait在前exit()在后的情况。</p>
<p>如果不是这样那就有一种情况，就是有僵尸子进程等待，就是子进程先执行exit()，这时它返回一个值，等待父进程的处理，exit()在前，如果子进程还一直处在这个等待的状态，在这里等待父进程的处理，父进程的wait就直接返回，如果有多个的话就从其中一个返回它的值。</p>
<p>进程的有序终止exit()，完成资源回收。</p>
<ul>
<li>调用参数作为进程的结果；</li>
<li>关闭所有打开的文件等占用资源；</li>
<li>释放内存，释放进程相关的内核数据结构；</li>
<li>检查父进程是否存活，如存活则保留结果的值直到父进程需要他。</li>
<li>清理所有等待的僵尸进程。</li>
</ul>
<h1 id="第十三讲-实验四-内核线程管理"><a href="#第十三讲-实验四-内核线程管理" class="headerlink" title="第十三讲 实验四 内核线程管理"></a>第十三讲 实验四 内核线程管理</h1><h2 id="13-1-总体介绍"><a href="#13-1-总体介绍" class="headerlink" title="13.1 总体介绍"></a>13.1 总体介绍</h2><p>了解内核线程创建执行的管理过程。了解内核线程的切换和基本调度过程，对TCB充分了解。</p>
<h2 id="13-2-关键数据结构"><a href="#13-2-关键数据结构" class="headerlink" title="13.2 关键数据结构"></a>13.2 关键数据结构</h2><p>struct proc_struct：TCB</p>
<ul>
<li>pid和name代表了标识符。</li>
<li>state、runs、need_reshed代表了状态和是否需要调度</li>
<li>cr3不太需要，因为共用进程的页表</li>
<li>kstack代表了堆栈</li>
<li>mm_struct不太需要，在ucore的统一管理下</li>
<li>context是通常说的上下文，基本都是寄存器，代表了当前线程的状态</li>
<li>trap_frame代表中断产生时的信息（硬件保存）、段寄存器的信息（软件保存）</li>
<li>一些list，父进程的信息和线程控制块的链表</li>
<li>基于hash的list，查找对应的线程比较快</li>
</ul>
<h2 id="13-3-执行流程"><a href="#13-3-执行流程" class="headerlink" title="13.3 执行流程"></a>13.3 执行流程</h2><p>kern_init最开始初始化，proc_init完成一系列的创建内核线程并执行。</p>
<p>创建第0号内核线程idleproc：</p>
<ul>
<li>alloc_proc创建TCB的内存块<br>-init idle_proc，设置pid、stat、kstack等</li>
</ul>
<p>创建第1个内核线程：</p>
<ul>
<li>initproc：</li>
<li>keep trapframe调用了do_fork，copy_thread等，如何跳到入口正确执行？是用户态还是内核态？</li>
<li>init_proc</li>
<li>init kernel stack，可以放到两个list中执行了</li>
<li>开始调度执行</li>
<li>找到线程队列中哪个是处于就绪的，切换switch kstack、页表、上下文，根据trapframe跳到内核线程的入口地址，开始执行函数。</li>
</ul>
<h2 id="13-4-实际操作"><a href="#13-4-实际操作" class="headerlink" title="13.4 实际操作"></a>13.4 实际操作</h2><p>关注proc_init创建第0、1号线程。switch_to完成两个内核线程的切换。</p>
<h1 id="第十四讲-实验五-用户进程管理"><a href="#第十四讲-实验五-用户进程管理" class="headerlink" title="第十四讲 实验五 用户进程管理"></a>第十四讲 实验五 用户进程管理</h1><h2 id="14-1-总体介绍"><a href="#14-1-总体介绍" class="headerlink" title="14.1 总体介绍"></a>14.1 总体介绍</h2><p>第一个用户进程如何创建、进程管理的实现机制、系统调用的框架实现。<br>构造出第一个用户进程：建立用户代码/数据段 —-&gt; 创建内核线程 —-&gt; 创建用户进程“壳” —-&gt; 填写用户进程 —-&gt; 执行用户进程(特权级转换) —-&gt; 完成系统调用 —-&gt; 结束用户进程(资源回收)</p>
<h2 id="14-2-进程的内存布局"><a href="#14-2-进程的内存布局" class="headerlink" title="14.2 进程的内存布局"></a>14.2 进程的内存布局</h2><p>内核虚拟内存布局有一部分是对实际物理空间的映射，0xC0000000到0xF8000000，映射为物理空间。一个Page Tabel，0xFAC00000到0xB0000000，一开始只是管理内核空间的映射关系，有了用户进程后，页表需要扩展。</p>
<p>进程虚拟内存空间：<br>Ivalid Memory<br>User Stack——————0xB0000000<br>………..<br>User Program &amp; Heap—-0x00800000<br>Invalid Memory<br>User STAB Data(optional，调试信息)<br>Invalid Memory    </p>
<p>Invalid Memory一旦访问为非法，确保访问到这些是产生page fault，使之不能随意访问。</p>
<h2 id="14-3-执行ELF格式的二进制代码-do-execve的实现"><a href="#14-3-执行ELF格式的二进制代码-do-execve的实现" class="headerlink" title="14.3 执行ELF格式的二进制代码-do_execve的实现"></a>14.3 执行ELF格式的二进制代码-do_execve的实现</h2><p>do_execve建好一个壳并把程序加载进来。本实验用到一个PCB（process control block），其实是跟上一个实验的TCB一样的。</p>
<p>首先，把之前的内存空间清空，只留下PCB，换成自己的程序。把cr3这个页表基址指向boot_cr3内核页表；把进程内存管理区域清空，对应页表清空，导致内存没有了；<strong>load_icode</strong>加载执行程序。</p>
<h2 id="14-4-执行ELF格式的二进制代码-load-icode的实现"><a href="#14-4-执行ELF格式的二进制代码-load-icode的实现" class="headerlink" title="14.4 执行ELF格式的二进制代码-load_icode的实现"></a>14.4 执行ELF格式的二进制代码-load_icode的实现</h2><p>前边已经把内存管理清空了，先创建一个新内存管理空间mm_create和新页表setup_pgdir；填上我执行代码的内容，找到要加载的程序的代码段和数据段，根据代码段和数据段的虚拟地址通过mm_map完成对合法空间的建立；从程序的内存区域拷贝过来，建立物理地址和虚拟地址的映射关系；准备all_zero的内存；设置相应堆栈空间（用户态空间），使用mm_map建立；把页表的起始地址换成新建好的页表的起始地址。</p>
<p>完成trapframe的设置。trapframe保存了打断的中断状态保存，完成特权级转变，从kernel转换到user。</p>
<p>x86特权级：从ring 0 —-&gt; ring 3，一个ring 0栈空间，构造一个信息使得执行iret时能回到用户态，重新设置ss和cs，从ring0到ring3。</p>
<p>用户进程有两个栈，用户栈和内核栈，通过系统调用转化。</p>
<h2 id="14-5-进程复制"><a href="#14-5-进程复制" class="headerlink" title="14.5 进程复制"></a>14.5 进程复制</h2><p>父进程如何构造子进程？<br>一个函数叫do_fork，是一个内核函数，完成用户空间的拷贝。首先，父进程创建进程控制块，初始化kernel stack，分配页空间和内核里的虚地址。copy_mm为新进程建立新虚存空间。copy_range拷贝父进程的内存到新进程。拷贝父进程的trapframe到新进程。添加新的proc_struct到proc_list并唤醒新进程。执行完do_fork后父进程得到子进程的pid，子进程得到0。</p>
<h2 id="14-6-内存管理的copy-on-write机制"><a href="#14-6-内存管理的copy-on-write机制" class="headerlink" title="14.6 内存管理的copy-on-write机制"></a>14.6 内存管理的copy-on-write机制</h2><p>进程A通过do_fork创建进程B，二者重用一段空间，使得空间占用量大大减少，如果是只读的话没问题。一旦某进程做了写操作，因为页表设置成只读，则产生page_fault，触发copy-on-write机制，真正为子进程复制页表。进程创建的开销大大减小，且有效减少空间。</p>
<p>一个物理页可能被多个虚拟页引用，这个个数很重要，因为在进程运行时可能会出现换入换出，如何进行有效换入换出，有可能那个页既在内存中也在虚存中。</p>
<p>dup_mmap完成内存管理的复制。</p>
<h1 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h1><h2 id="处理机调度概念"><a href="#处理机调度概念" class="headerlink" title="处理机调度概念"></a>处理机调度概念</h2><p>进程切换是CPU资源的当前占用者的切换，保存当前进程在PCB中的执行上下文（CPU状态），恢复下一个进程的执行上下文。</p>
<p>处理机调度是从就绪队列中找一个占用CPU的进程，从多个可用CPU中挑选就绪进程可使用的CPU资源。</p>
<h2 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h2><h3 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h3><p>操作系统维护进程的状态序列。进程从运行状态切换到等待状态，这样CPU就空闲了，或者进程被终结了，CPU又空闲了。这两种情况对应着非抢占系统，当前进程主动放弃CPU。对可抢占系统，中断请求被服务例程响应完成，或当前进程因为时间片用完时会被抢占，进程从等待切换到就绪，这时更急迫的想占用CPU，也会发生抢占。</p>
<h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><p>进程在CPU计算和IO操作间交替，在时间片机制下，进程可能在结束当前CPU计算之前就被迫放弃CPU。</p>
<p>CPU使用率：CPU处于忙状态的时间百分比。</p>
<p>吞吐率：单位时间内完成的进程数量</p>
<p>周转时间：进程从初始化到结束（包括等待）的时间</p>
<p>等待时间：进程在就绪队列中的时间</p>
<p>响应时间：从提交请求到产生相应所花费的时间</p>
<p>调度算法希望“更快”的服务。</p>
<p>响应时间目标：</p>
<ul>
<li>减少相应时间，及时处理输入请求</li>
<li>减少平均响应时间的波动，提高可预测性</li>
<li>低延迟调度改善了交互体验</li>
</ul>
<p>吞吐量目标：</p>
<ul>
<li>增加吞吐量，减少开销（操作系统开销，上下文切换）</li>
<li>系统资源的高效利用（CPU、IO）</li>
<li>减少等待时间，提高响应性能和吞吐量性能</li>
<li>吞吐量是系统的计算带宽</li>
</ul>
<p>公平性目标：</p>
<ul>
<li>保证每个进程占用相同的CPU时间</li>
<li>公平通常会增加响应时间</li>
</ul>
<h2 id="先来先服务、短进程优先和最高响应比优先调度算法"><a href="#先来先服务、短进程优先和最高响应比优先调度算法" class="headerlink" title="先来先服务、短进程优先和最高响应比优先调度算法"></a>先来先服务、短进程优先和最高响应比优先调度算法</h2><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><p>按照就绪队列的先后顺序排列，进程进入等待或结束状态时，就绪队列中的下一个进程占用CPU。</p>
<p>周转时间：每个进程的平均总时间（等待+执行）</p>
<p>优点：简单，排队依据容易获得。</p>
<p>缺点： 平均等待时间波动大，排队位置对算法影响大，IO和CPU资源利用效率低。</p>
<h3 id="短进程优先"><a href="#短进程优先" class="headerlink" title="短进程优先"></a>短进程优先</h3><p>考虑进程的特征，选择就绪队列中执行时间最短进程占用CPU进入运行状态。它具有最好的平均周转时间。</p>
<p>但可能导致饥饿，连续的短进程会使长进程无法获得CPU资源。且需要预知未来，可以用历史执行时间预估未来的执行时间。</p>
<h3 id="最高响应比优先"><a href="#最高响应比优先" class="headerlink" title="最高响应比优先"></a>最高响应比优先</h3><p>考虑进程在就绪队列中的等待时间。选择就绪队列中响应比R最高的进程。<code>R = (w + s) / s</code>，w是等待时间，s是执行时间。这种算法基于短进程优先算法，不可抢占，关注了进程等待时间，以防止无限等待。</p>
<h2 id="时间片轮转、多级反馈队列、公平共享调度算法和ucore调度框架"><a href="#时间片轮转、多级反馈队列、公平共享调度算法和ucore调度框架" class="headerlink" title="时间片轮转、多级反馈队列、公平共享调度算法和ucore调度框架"></a>时间片轮转、多级反馈队列、公平共享调度算法和ucore调度框架</h2><h3 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h3><p>时间片是分配处理机资源的基本时间单元，各个进程占用一个时间片，仍按照先来先服务策略，时间片结束时按照先来先服务切换到下一个就绪进程，每隔(n-1)个时间片进程执行一个时间片。</p>
<p>时间片太大的话，等待时间过长，退化成先来先服务；若太短，产生了大量上下文切换，影响系统吞吐量。</p>
<p>这时需要选择一个合适的时间片长度。</p>
<h3 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h3><p>就绪队列排成多个子队列，不同队列可以有不同算法，进程可以在队列之间转换。队列间的调度可以采用时间片方法。</p>
<p>多级反馈队列：进程在不同队列间移动的多级队列算法。时间片大小随优先级级别增加而增加，如进程在当前的时间片没有完成，则降到下一个优先级。CPU密集型的进程优先级下降很快，这样时间片会增大，IO密集型的则优先级上升。</p>
<h3 id="公平共享调度算法"><a href="#公平共享调度算法" class="headerlink" title="公平共享调度算法"></a>公平共享调度算法</h3><p>注重资源访问的公平，一些用户比另一些用户重要，保证不重要的组无法垄断资源。未使用的资源按照比例分配，没有达到资源使用率目标的组获得更高的优先级。</p>
<h3 id="uCore的调度队列run-queue"><a href="#uCore的调度队列run-queue" class="headerlink" title="uCore的调度队列run_queue"></a>uCore的调度队列run_queue</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct run_queue&#123;</span><br><span class="line">	list_entry_t run_list;</span><br><span class="line">	unsigned int proc_num;</span><br><span class="line">	int max_time_slice;</span><br><span class="line">	list_entry_t rq_link;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实时调度和多处理器调度"><a href="#实时调度和多处理器调度" class="headerlink" title="实时调度和多处理器调度"></a>实时调度和多处理器调度</h2><p>实时调度对时间有要求，实时操作系统的正确性以来其时间和功能两方面，其性能指标是时间约束的及时性。</p>
<p>周期实时任务：一系列相似任务，任务有规律的重复，周期p=任务请求时间间隔，执行时间e=最大执行时间，使用率U=e/p。</p>
<p>硬实时是指错过任务时限会导致灾难性或非常严重的后果，必须验证，在最坏情况下能满足时限。软实时是指尽量满足任务时限。</p>
<p>可调度性：一个实时操作系统能满足任务时限要求。需要确定实时任务的执行顺序。静态/动态优先级调度。</p>
<p>速率单调调度算法（静态）：通过周期安排优先级，周期越短优先级越高，执行周期最短的任务；</p>
<p>最早截止时间优先算法（动态）：截止时间越早优先级越高，执行截止时间最早的任务。</p>
<h3 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h3><p>针对多个处理机，一条系统总线连接多个物理CPU，一个CPU可能有几个逻辑CPU，处理机之间可以负载共享。</p>
<p>对阵多处理机（SMP）调度：每个处理器运行自己的调度程序，调度程序对共享资源的访问需要同步。</p>
<p>静态进程分配：进程开始执行到结束都被分配到一个固定的处理机上，每个处理机都有自己的就绪队列，调度开销小，但各个处理机可能忙闲不均。</p>
<p>动态进程分配：进程在执行中可以分配到任意空闲处理机执行，所有处理机共享一个公共的就绪队列，调度开销大，各个处理机的负载是均衡的。</p>
<h2 id="优先级反置"><a href="#优先级反置" class="headerlink" title="优先级反置"></a>优先级反置</h2><p>操作系统中出现高优先级进程长时间等待低优先级进程所占用的资源，而导致高优先级进程长时间等待的现象。</p>
<p>优先级继承：占用资源的低优先级进程继承申请资源的高优先级进程的优先级。只有占有资源的低优先级进程被阻塞时才能提高占有资源进程的优先级。</p>
<p>优先级天花板协议：占有资源进程的优先级和所有可能申请该资源的进程的最高优先级相同，不管是否发生等待，都提升占有资源进程的优先级。优先级高于系统中所有被锁定的资源的优先级上限，任务执行临界区就不会被阻塞。</p>
<h1 id="实验六-调度器"><a href="#实验六-调度器" class="headerlink" title="实验六 调度器"></a>实验六 调度器</h1><h2 id="16-1-总体介绍和调度过程"><a href="#16-1-总体介绍和调度过程" class="headerlink" title="16.1 总体介绍和调度过程"></a>16.1 总体介绍和调度过程</h2><p>在lab5中，完成了用户进程的管理。lab6中完成了调度的初始化和调度过程。<br>实现一个调度类，绑定调度类（类似于多态或重载），设定调度点，触发调度时间，调整调度参数和调用调度算法，实现选择新进程和完成进程切换。</p>
<p>把当前进程放到就绪队列中，在就绪队列中选取一个适合的进程，出队然后完成切换。</p>
<h2 id="16-2-调度算法支撑框架"><a href="#16-2-调度算法支撑框架" class="headerlink" title="16.2 调度算法支撑框架"></a>16.2 调度算法支撑框架</h2><p>调度点：出发做调度相关的工作</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>位置</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>proc.c:do_exit</td>
<td>用户线程执行结束，主动放弃CPU</td>
</tr>
<tr>
<td>proc.c:do_wait</td>
<td>用户线程等待着子进程结束，主动放弃CPU</td>
</tr>
<tr>
<td>proc.c:init_main</td>
<td>Init_porc内核线程等待所有用户进程结束；所有用户进程结束后回收系统资源</td>
</tr>
<tr>
<td>proc.c:cpu_idle</td>
<td>idleproc内核线程等待处于就绪态的进程或线程，如果有选择一个并切换</td>
</tr>
<tr>
<td>sync.h:lock</td>
<td>进程无法得到锁，则主动放弃CPU</td>
</tr>
<tr>
<td>trap.c:trap</td>
<td>修改当前进程时间片，若时间片用完，则设置need_resched为1，让当前进程放弃CPU</td>
</tr>
</tbody>
</table>
</div>
<p>进入/离开就绪队列的机制：</p>
<ul>
<li>抽象数据结构，可以不是队列；</li>
<li>可根据调度算法的需求采用多种数据结构</li>
</ul>
<p>schedule是一个总控函数，如果当前进程是 RUNNABLE会调用sched_class_enqueue，放到就绪队列中。</p>
<h2 id="16-3-时间片轮转调度算法（RR调度算法）"><a href="#16-3-时间片轮转调度算法（RR调度算法）" class="headerlink" title="16.3 时间片轮转调度算法（RR调度算法）"></a>16.3 时间片轮转调度算法（RR调度算法）</h2><p>前边介绍完成一个sched_class，</p>
<p>RR_init{<br>    list_init;<br>    run_queue-&gt;proc_num = 0;<br>}</p>
<p>在产生时钟中断时调用<br>RR_proc_tick{<br>    if(proc-&gt;time_slice &gt; 0)<br>        proc-&gt;time_slice —;<br>    if(proc-&gt;time_slice == 0)<br>        proc-&gt;need_resched = 1;<br>}<br>一旦标志位为1，则说明需要调度了</p>
<p>当有一个进程需要进队列，则调用list_add_before，如果要选择一个进程，则选择一个尾list_next</p>
<h2 id="16-4-Stride调度算法"><a href="#16-4-Stride调度算法" class="headerlink" title="16.4 Stride调度算法"></a>16.4 Stride调度算法</h2><p>如果有三个进程，每个进程有2个属性，stride表示现在执行到什么地方，数字大小表示执行进度；pass表示一次前进的步数。</p>
<p>选择当前步长最小的一个进程，执行目标是当前步长加path。</p>
<p>它是基于优先级的且每一步的调度策略是特定的。</p>
<p>可以使用priority_queue实现，又可以用Skew heap（斜堆）的优先队列实现。</p>
<p>stride在不停累加下如何正确判断最大最小？uint32_t！</p>
<h1 id="第十七讲-同步互斥"><a href="#第十七讲-同步互斥" class="headerlink" title="第十七讲 同步互斥"></a>第十七讲 同步互斥</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>独立进程：不和其他进程共享资源或状态，具有确定性（输入决定结果）；可重现（能够重现起始条件）；调度顺序不重要。</p>
<p>并发进程：多个进程之间有资源共享；不确定性；不可重现。某些情况下调度的不一致会造成结果的不一致，也可能出现不可重现性。程序错误也可能是间歇性发生的。</p>
<p>进程需要与计算机中的其他进程和设备合作。有几个好处：</p>
<ol>
<li>共享资源。多个用户使用同一个计算机；</li>
<li>提高速度。IO和计算可以重叠；程序可划分为多个模块放在多个处理器上并行执行；</li>
<li>模块化。将大程序分解成小程序。</li>
</ol>
<p>并发创建新进程时的标识分配：程序调用fork()创建进程，操作系统需要分配一个新的且唯一的进程ID，在内核中，这个系统调用会执行<code>new_pid = next_pid++</code>。</p>
<p>原子操作是一次不存在任何中断或失败的操作。要么成功要么不执行，不会出现部分执行的情况。操作系统需要利用同步机制在并发执行的同时，保证一些操作是原子操作。</p>
<h2 id="现实生活中的同步问题"><a href="#现实生活中的同步问题" class="headerlink" title="现实生活中的同步问题"></a>现实生活中的同步问题</h2><p>利用原子操作实现一个锁。</p>
<ul>
<li>Lock.Acquire()<ul>
<li>在锁被释放前一直等待，然后获得锁；</li>
<li>如果两个线程都在等待同一个锁，那如果锁被释放了，只有一个进程能得到锁</li>
</ul>
</li>
<li>Lock.Release()<ul>
<li>解锁并唤醒任何等待中的进程。</li>
</ul>
</li>
<li>过程：<ul>
<li>进入临界区</li>
<li>操作</li>
<li>退出临界区</li>
</ul>
</li>
</ul>
<p>进程之间的交互关系：相互感知程度。</p>
<ul>
<li>相互不感知（完全不了解其他进程）：独立</li>
<li>间接感知（双方与第三方交互）：通过共享合作</li>
<li>直接感知（直接交互，如通信）：通过通信合作</li>
</ul>
<p>可能会出现如下几种：</p>
<ul>
<li>互斥：一个进程占用，则其他进程不能使用</li>
<li>死锁：多个进程各自占用部分资源，形成循环等待</li>
<li>饥饿：其他进程轮流占用资源，一个进程一直得不到资源</li>
</ul>
<h2 id="临界区和禁用硬件中断同步方法"><a href="#临界区和禁用硬件中断同步方法" class="headerlink" title="临界区和禁用硬件中断同步方法"></a>临界区和禁用硬件中断同步方法</h2><p>临界区是互斥执行的代码，进入区检查进程进入临界区的条件是否成立，进入之前设置相应“正在访问临界区”的标志；退出区清除“正在访问临界区”标志。</p>
<p>临界区访问规则：</p>
<ul>
<li>空闲则入：没有进程在临界区时任何进程可以进入；</li>
<li>忙则等待：有进程在临界区，则其他进程均不能进入临界区；</li>
<li>有限等待：等待进入临界区的进程不能无线等待；</li>
<li>让权等待：不能进入临界区的进程，需要及时释放CPU；</li>
</ul>
<p>实现方法：</p>
<ul>
<li>禁用硬件中断：没有中断和上下文切换，因此没有并发，硬件将中断处理延迟到中断被启用之后，现在计算机体系结构都提供指令来实现禁用中断，进入临界区时禁止所有中断，退出临界区时使能所有中断。这种办法有局限性，关中断之后进程无法停止，也可能导致其他进程处于饥饿状态；临界区可能很长，无法确定相应中断所需的时间。</li>
</ul>
<h2 id="基于软件的同步方法"><a href="#基于软件的同步方法" class="headerlink" title="基于软件的同步方法"></a>基于软件的同步方法</h2><ul>
<li>软件方法：两个线程，T0和T1，线程可以通过共享一些共有变量来同步行为。<ul>
<li>采用共享变量，设置一个共享变量表示允许进入临界区的线程；</li>
<li>设置一个共享变量数组，描述每个变量是否在临界区中，先判断另一个线程的flag是否是1，如果可以进入了，设置自己的flag；可能会同时等待或同时进入；</li>
<li>Peterson算法：turn表示该哪个进程进入临界区，flag[]表示进程是否准备好进入临界区。在进入区进程i要设置flag[i]=true，且turn=j，判断（flag[i] &amp;&amp; turn==j），如果j没有申请进入，则i直接进去没问题。如果j也申请了，看谁先向trun里写数据，谁先写谁进入，由总线仲裁决定先后顺序！</li>
<li>N线程时，采用Eisenberg和McGuire算法，采用一个处理循环。</li>
<li>基于软件的方法很复杂，是一个忙等待</li>
</ul>
</li>
</ul>
<h2 id="高级抽象的同步方法"><a href="#高级抽象的同步方法" class="headerlink" title="高级抽象的同步方法"></a>高级抽象的同步方法</h2><ul>
<li>借用操作系统的支持采用更高级的抽象方法，例如，锁、信号量等，用硬件原语来实现</li>
<li>锁：一个二进制变量（锁定，解锁），Acquire和Release，使用锁控制临界区访问。</li>
<li>原子操作指令：CPU体系结构中一类特殊的指令，把若干操作合成一个原子操作，不会出现部分执行的情况<ul>
<li>测试和置位（TS），从内存中读取，测试值是否为1并返回T/F，内存单元置为1。</li>
<li>交换指令：交换内存中的两个值。</li>
</ul>
</li>
</ul>
<p>使用TS指令实现自旋锁：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Lock &#123;</span><br><span class="line">	int value = 0;</span><br><span class="line">&#125;</span><br><span class="line">Lock::Acquire() &#123;</span><br><span class="line">	while(test_and_set(value))</span><br><span class="line">		; // spin</span><br><span class="line">&#125;</span><br><span class="line">Lock::Release() &#123;</span><br><span class="line">	value = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>用TS指令把value读出来，向里边写入1。</p>
<ul>
<li>如果锁被释放，那么TS指令读取0并将值设置为1<ul>
<li>锁被设置为忙并且需要等待完成</li>
</ul>
</li>
<li>如果锁处于忙状态，那么TS指令读取1并将指令设置为1<ul>
<li>不改变锁的状态并且需要循环</li>
</ul>
</li>
</ul>
<p>无忙等待锁：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Lock &#123;</span><br><span class="line">	int value = 0;</span><br><span class="line">	WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line">Lock::Acquire() &#123;</span><br><span class="line">	while(test_and_set(value))&#123;</span><br><span class="line">		add this TCP to wait queue</span><br><span class="line">		schedule();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Lock::Release() &#123;</span><br><span class="line">	value = 0;</span><br><span class="line">	remove one thread t from q</span><br><span class="line">	wakeup(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原子操作指令锁的特征：</p>
<ul>
<li>优点：<ul>
<li>适用于单处理器或共享内存的多处理器中任意数量的进程</li>
<li>支持多临界区</li>
</ul>
</li>
<li>缺点：<ul>
<li>忙等待的话占用了CPU时间</li>
<li>可能导致饥饿，进程离开临界区时有多个等待进程的话？</li>
<li>可能<strong>死锁</strong>，低优先级的进程占用了临界区，但是请求访问临界区的高优先级进程获得了处理器并等待临界区。</li>
</ul>
</li>
</ul>
<h1 id="第十八讲-信号量与管程"><a href="#第十八讲-信号量与管程" class="headerlink" title="第十八讲 信号量与管程"></a>第十八讲 信号量与管程</h1><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>多线程的引入导致了资源的竞争，同步是协调多线程对共享数据的访问，在任何时候只能有一个线程执行临界区代码。</p>
<p>信号量是操作系统提供的协调共享资源访问的方法，软件同步是平等线程间的一种同步协商机制。信号量是由OS负责管理的，OS作为管理者，地位高于进程。用信号量表示一类资源，信号量的大小表示资源的可用量。</p>
<p>信号量是一种抽象数据类型，由一个整型变量（共享资源数目）和两个原子操作组成。</p>
<ul>
<li>P()（荷兰语尝试减少）<ul>
<li>sem减一</li>
<li>如sem&lt;0，进入等待，否则继续</li>
</ul>
</li>
<li>V()（荷兰语增加）<ul>
<li>sem加一</li>
<li>如sem&lt;=0，唤醒一个等待进程    </li>
</ul>
</li>
</ul>
<p>信号量是被保护的整型变量，初始化完成后只能通过PV操作修改，是由操作系统保证PV操作是原子操作的。</p>
<p>P操作可能阻塞，V操作不会阻塞。P操作中sem可以等于0，但是如果小于0的话，说明我没有资源了，把这个进程放入等待队列，并且阻塞。退出时执行V操作，如果sem++后还小于0，则说明还有等着的，就把一个进程唤醒开始执行。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Semaphore&#123;</span><br><span class="line">	int sem;</span><br><span class="line">	WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line">Semaphore::P()&#123;</span><br><span class="line">	sem --;</span><br><span class="line">	if(sem&lt;0)&#123;</span><br><span class="line">		Add this thread t to q;</span><br><span class="line">		block(p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Semaphore::V()&#123;</span><br><span class="line">	sem++;</span><br><span class="line">	if(sem&lt;=0)&#123;</span><br><span class="line">		remove a thread t from q;</span><br><span class="line">		wakeup(t)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>它的原子性是操作系统保证的，执行不会被打断。</p>
<h2 id="信号量使用"><a href="#信号量使用" class="headerlink" title="信号量使用"></a>信号量使用</h2><p>两种：二进制信号量，资源数目是0或1；资源信号量，资源数目为任意非负值。</p>
<p>一种是临界区的互斥访问。每类资源设置一个信号量，对应一个临界区，信号量初值为1，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutex = new Semaphore(1)</span><br><span class="line"></span><br><span class="line">mutex-&gt;P();</span><br><span class="line">Critical Section</span><br><span class="line">mutex-&gt;V()</span><br></pre></td></tr></table></figure><br>第一个进程进来之后，mutex是0了，第二个进程再执行到P操作时，mutex变成-1，则会等待。第一个进程执行结束后，执行V操作，-1变成0，这时候唤醒第二个进程。</p>
<p>必须成对使用P()和V()操作。P()保证互斥访问，V()操作保证使用后及时释放。</p>
<p>一种是条件同步，初值设置为0。事件出现时设置为1。这个事件就相当于是一种资源。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition = new Semaphore(0)</span><br></pre></td></tr></table></figure></p>
<p>生产者-消费者：一个或多个生产者在生成数据后放在缓冲区总，单个消费者从缓冲区中取出数据，任何时刻只能有一个生产者或消费者可访问缓冲区（互斥关系），也就是缓冲区是一个临界区。缓冲区空时必须等待生产者（条件同步），缓冲区满时生产者必须等待消费者（条件同步）。</p>
<p>三个信号量：二进制信号量mutex描述互斥关系；资源信号量fullBuffer和emptyBuffer代表了条件同步关系。</p>
<p>刚开始时缓冲区都是空的，所以fullBuffers为0，emptyBuffers为n<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class BounderBuffer&#123;</span><br><span class="line">	mutex = new Semaphore(1);</span><br><span class="line">	fullBuffers = new Semphore(0);</span><br><span class="line">	emptyBuffers = new Semphore(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mutex实现了对缓冲区的互斥访问，但是只是这样是不够的，先检查是否有空缓冲区，有的话则检查是否有另外的消费者占用缓冲区。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BounderBuffer::Deposit(c)&#123;</span><br><span class="line">	emptyBuffers-&gt;P();</span><br><span class="line">	mutex-&gt;P();</span><br><span class="line">	Add c to the buffer</span><br><span class="line">	mutex-&gt;V();</span><br><span class="line">	fullBuffers-&gt;V();//生产者写了之后就释放一个资源</span><br><span class="line">&#125;</span><br><span class="line">BounderBuffer::Remove(c)&#123;</span><br><span class="line">	fullBuffers-&gt;P();</span><br><span class="line">	mutex-&gt;P();</span><br><span class="line">	Remove c from buffer</span><br><span class="line">	mutex-&gt;V();</span><br><span class="line">	emptyBuffers-&gt;V();//消费者用了一个之后释放一个</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>在管程内部使用了条件变量，管程是一种用于多线程互斥访问共享资源的程序结构，采用了面向对象的方法，简化了线程间的同步控制，在任意时刻最多只有一个线程执行管程代码。正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复。</p>
<p>收集现在要同步的进程之间共享的数据，放到一起处理。在入口加一个互斥访问的锁，任何一个线程到临界区后排队，挨个进入。管理共享数据的并发访问。需要共享资源时对应相应的条件变量，使用管程中的程序。</p>
<p>条件变量是管程内的等待机制，进入管程的线程因资源占用而进入等待，每个条件变量表示一种等待原因，对应一个等待队列。两个操作：</p>
<ul>
<li>Wait()：将自己阻塞到等待队列中，唤醒一个等待者或释放管程的互斥访问。</li>
<li>Signal()：将等待队列中的一个线程唤醒；如果等待队列为空，则相当于空操作。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Class Condition&#123;</span><br><span class="line">	int numWaiting = 0;</span><br><span class="line">	WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line">Condition::Wait(lock)&#123;</span><br><span class="line">	numWaiting ++;</span><br><span class="line">	Add this thread t to q;</span><br><span class="line">	release();</span><br><span class="line">	schedule();</span><br><span class="line">	require(lock);</span><br><span class="line">&#125;</span><br><span class="line">Condition::Signal()&#123;</span><br><span class="line">	if(numWaiting &gt; 0)&#123;</span><br><span class="line">		Remove a thread t from q;</span><br><span class="line">		wakeup(t);</span><br><span class="line">		numWaiting --;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
numWaiting为正表示有线程处于等待状态；把它自己放到等待队列中，释放管程使用权，开始调度。在Signal中，把一个进程从等待队列中拿出来，开始执行，numWaiting减一，等待的线程数目减少。</li>
</ul>
<p>用信号量解决生产者-消费者问题的话，生产者消费者各对应一个函数，其他地方要使用的话直接调用这两个函数即可。首先放到一个管程里，这是由管程进入的申请和释放，如果没有空的，就在条件变量上等待。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class BoundedBuffer&#123;</span><br><span class="line">	...</span><br><span class="line">	Lock lock;</span><br><span class="line">	int count = 0;</span><br><span class="line">	Condition notFull, notEmpty;</span><br><span class="line">&#125;</span><br><span class="line">BoundedBuffer::Deposit(c)&#123;</span><br><span class="line">	lock-&gt;Acquire();</span><br><span class="line">	while(count == n)</span><br><span class="line">		notFull.Wait(&amp;lock);</span><br><span class="line">	Add c to the buffer;</span><br><span class="line">	count ++;</span><br><span class="line">	notEmpty.Signal();</span><br><span class="line">	lock-&gt;Release();</span><br><span class="line">&#125;</span><br><span class="line">BoundedBuffer::Remove(c)&#123;</span><br><span class="line">	lock-&gt;Acquire();</span><br><span class="line">	while(count == 0)</span><br><span class="line">		notEmpty.Wait(&amp;lock);</span><br><span class="line">	Remove c from buffer;</span><br><span class="line">	count --;</span><br><span class="line">	notFull.Signal();</span><br><span class="line">	lock-&gt;Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>管程可以把PV操作集中在一个函数里。</p>
<h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define N 5</span><br><span class="line">semphore fork[N];</span><br><span class="line">void philosopher(int i)&#123;</span><br><span class="line">	while(TRUE)&#123;</span><br><span class="line">		think();</span><br><span class="line">		if(i%2 == 0)&#123;</span><br><span class="line">			P(fork[i]);</span><br><span class="line">			P(fork[(i+1)%N]);</span><br><span class="line">		&#125; else&#123;</span><br><span class="line">			P(fork[(i+1)%N]);</span><br><span class="line">			P(fork[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		eat();</span><br><span class="line">		V(fork[i]);</span><br><span class="line">		V(fork[(i+1)%N]);		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h2><p>共享数据的两种使用者：读者只读取数据，不修改；写者读取和修改数据。</p>
<p>有三种情况：</p>
<ul>
<li>读读允许：同一时刻允许多个读者同时读</li>
<li>读写互斥：没有读者时写者才能写，没有写者时读者才能读</li>
<li>写写互斥：没有其他写者时写者才能写</li>
</ul>
<p>用信号量描述每个约束。信号量WriteMutex是控制读写操作的互斥，初始化为1.读者计数Rcount是对正在读操作的读者数目，初始化为0。信号量CountMutex控制对读者计数的互斥修改，初始化为1。<br>Writer：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P(WriteMutex);</span><br><span class="line">	write();</span><br><span class="line">V(WriteMutex);</span><br></pre></td></tr></table></figure><br>Reader:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">P(CountMutex);</span><br><span class="line">	if(Rcount == 0)</span><br><span class="line">		P(WriteMutex);</span><br><span class="line">	++Rcount;</span><br><span class="line">V(CountMutex);</span><br><span class="line">read();</span><br><span class="line">P(CountMutex);</span><br><span class="line">	--Rcount;</span><br><span class="line">	if(Rcount == 0)</span><br><span class="line">		V(WriteMutex);</span><br><span class="line">	++Rcount;</span><br><span class="line">V(CountMutex);</span><br></pre></td></tr></table></figure></p>
<p>管程实现读者-写者问题：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Database::Read()&#123;</span><br><span class="line">	StartRead(); </span><br><span class="line">	//Wait until no writers;</span><br><span class="line">	read database;</span><br><span class="line">	DoneRead();</span><br><span class="line">	//checkout - wakeup waiting writers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Database::Write()&#123;</span><br><span class="line">	Wait until no reader/writer;</span><br><span class="line">	write database;</span><br><span class="line">	checkout - wakeup waiting reader/writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>状态变量。正在读和正在写只有一个大于等于0<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AR = 0;  # of active reader</span><br><span class="line">AW = 0;  # of active writer</span><br><span class="line">WR = 0;  # of waiting reader</span><br><span class="line">WW = 0;  # of waiting writer</span><br><span class="line">Lock lock;</span><br><span class="line">Condition okToRead, okToWrite</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Private Database::StartRead()&#123;</span><br><span class="line">	lock.Acquire();</span><br><span class="line">	while(AW + WW &gt; 0)&#123;//写者优先</span><br><span class="line">		WR++;</span><br><span class="line">		okToRead.wait(&amp;lock);</span><br><span class="line">		WR--;</span><br><span class="line">	&#125;</span><br><span class="line">	AR++;</span><br><span class="line">	lock.Release()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Private Database::DoneRead()&#123;</span><br><span class="line">	lock.Acquire();</span><br><span class="line">	AR --;</span><br><span class="line">	if(AR==0 &amp;&amp; WW&gt;0) //没有读者，写者在等</span><br><span class="line">		okToWrite.Signal();</span><br><span class="line">	lock.Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Private Database::StartWrite()&#123;</span><br><span class="line">	lock.Acquire();</span><br><span class="line">	while(AW + AR &gt; 0)&#123;//有正在写的写者或正在读的读者</span><br><span class="line">		WW++;</span><br><span class="line">		okToWrite.wait(&amp;lock);</span><br><span class="line">		WW--;</span><br><span class="line">	&#125;</span><br><span class="line">	AW++;</span><br><span class="line">	lock.Release()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Private Database::DoneWrite()&#123;</span><br><span class="line">	lock.Acquire();</span><br><span class="line">	AW --;</span><br><span class="line">	if(WW&gt;0) //写者优先</span><br><span class="line">		okToWrite.Signal();</span><br><span class="line">	else if(WR &gt; 0)</span><br><span class="line">		okToRead.broadcase();</span><br><span class="line">	lock.Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="第十九讲-实验七-同步互斥"><a href="#第十九讲-实验七-同步互斥" class="headerlink" title="第十九讲 实验七 同步互斥"></a>第十九讲 实验七 同步互斥</h1><h2 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h2><h2 id="底层支撑"><a href="#底层支撑" class="headerlink" title="底层支撑"></a>底层支撑</h2><p>定时器：进程睡眠，进入等待状态（do_sleep）。可以添加一个timer。</p>
<p>时钟中断时会遍历timer链表，看哪个进程的定时器到期了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">	unsigned int expires;</span><br><span class="line">	struct proc_struct* proc;</span><br><span class="line">	list_entry_t timer_link;</span><br><span class="line">&#125; timer_t;</span><br></pre></td></tr></table></figure><br>屏蔽中断完成了互斥的保护，使得这个进程不会被调度或打断。有一个Eflag寄存器，有一个bit叫做Interrupt Enable Flag，这个flag如果置成1，当前允许中断，置成0表示不允许中断。两个指令CLI和STI分别屏蔽中断和使能中断。uCore中使用<code>local_intr_save</code>和<code>local_intr_restore</code>封装。</p>
<p>等待项和等待队列：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">	struct proc_struct* proc;</span><br><span class="line">	uint32_t wakeup_flags;//等待的原因</span><br><span class="line">	wait_queue_t* wait_queue;//等待项在哪个队列中</span><br><span class="line">	list_entry_t wait_link;</span><br><span class="line">&#125; wait_t</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	list_entry_t wait_head;</span><br><span class="line">&#125; wait_queue_t;</span><br></pre></td></tr></table></figure></p>
<h2 id="信号量设计实现"><a href="#信号量设计实现" class="headerlink" title="信号量设计实现"></a>信号量设计实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Semaphore&#123;</span><br><span class="line">	int sem;</span><br><span class="line">	WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line">Semaphore::P()&#123;</span><br><span class="line">	sem --;</span><br><span class="line">	if(sem&lt;0)&#123;</span><br><span class="line">		Add this thread t to q;</span><br><span class="line">		block(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Semaphore::V()&#123;</span><br><span class="line">	sem++;</span><br><span class="line">	if(sem&lt;=0)&#123;</span><br><span class="line">		Remove a thread t from q;</span><br><span class="line">		wakeup(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="管程和条件变量设计实现"><a href="#管程和条件变量设计实现" class="headerlink" title="管程和条件变量设计实现"></a>管程和条件变量设计实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct monitor&#123;</span><br><span class="line">	semaphore_t mutex;</span><br><span class="line">	semaphore_t next;</span><br><span class="line">	int next_count;</span><br><span class="line">	condvar_t *cv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哲学家就餐问题-1"><a href="#哲学家就餐问题-1" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><h1 id="第十九讲-实验七-同步互斥-1"><a href="#第十九讲-实验七-同步互斥-1" class="headerlink" title="第十九讲 实验七 同步互斥"></a>第十九讲 实验七 同步互斥</h1><p>第二十讲 死锁和进程通信</p>
<h2 id="死锁概念"><a href="#死锁概念" class="headerlink" title="死锁概念"></a>死锁概念</h2><p>由于竞争资源或通信关系，两个或更多线程在执行中弧线，永远相互等待只能由其他进程引发的事件。</p>
<p>进程访问资源的流程：资源类型有R1、R2、R3等，每类资源Ri有Wi个实例，进程访问资源时先申请空闲的资源，再占用，最后释放资源。</p>
<p>可重用资源是不能被删除且在任何时刻都只能有一个进程使用，一个进程释放之后其他进程就可以使用了，比如CPU，文件、数据库等，可以被多个进程交替使用。可能出现死锁。</p>
<p>消耗资源：一个进程创建，并有其他进程使用，比如消息等，可能出现死锁。</p>
<p>资源分配图描述了资源和进程之间的分配和占用关系，是一个有向图。一类顶点是系统中的进程，另一类顶点是资源；一类有向边是资源请求边，另一类有向边是资源分配边。如果有循环等待的话，就会出现死锁。但是有循环也可能不会出现死锁。</p>
<p>出现死锁的条件：</p>
<ul>
<li>互斥：任何时刻只能由一个进程使用一个资源实例，如果资源是共享的不会互斥的则不会死锁；</li>
<li>持有并等待：进程保持至少一个资源并正在等待获取其他进程持有的资源；</li>
<li>非抢占：资源只在进程使用后自愿放弃，不可以强行剥夺；</li>
<li>循环等待：存在等待进程集合，0等1，1等2，。。。n-1等n，n等0，类似这样。</li>
</ul>
<h2 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h2><ul>
<li>死锁预防：确保系统永远不会进入死锁状态，四个必要条件的任何一个去掉都可以避免死锁，但是这样的话资源利用率低；</li>
<li>死锁避免：在使用前进行判断，只允许不会出现死锁的进程请求资源；</li>
<li>死锁检测和恢复：在检测到死锁后，进行恢复；</li>
<li>通常由应用进程来处理死锁，操作系统忽略死锁的存在。</li>
</ul>
<p>死锁预防：采用某种机制，限制并发进程对资源的请求，使系统不满足死锁的必要条件。</p>
<ul>
<li>比如可以把互斥的共享资源封装成可以同时访问的，比如打印机，加上缓冲区，在打印机内部协调先后；</li>
<li>持有并等待，进程请求资源时，不能占用其他任何资源，想申请资源时，必须把全部资源都申请到，也可以在进程开始执行时一次请求所有需要的资源，资源利用效率低；</li>
<li>非抢占：如进程请求不能立即分配的资源，则立即释放自己已占有的资源，只有能同时获取到所有需要资源时，才执行分配操作；</li>
<li>循环等待：对资源排序，进程需要按照顺序请求资源，可能先申请的资源后续才用到；</li>
</ul>
<p>死锁避免：利用额外的先验信息，在分配资源时判断是否会出现死锁，如果可能会出现死锁，则不分配。要求进程声明资源需求的最大数目，限定提供与分配的资源数目，确保满足进程的最大需求，且动态检查资源分配状态，确保不会出现死锁。</p>
<p>进程请求资源时，系统判断是否处于安全状态。</p>
<ul>
<li>针对所有已占用进程，存在安全序列；</li>
<li>序列<P1,P2,P3...,Pn>是安全的，则Pi要求的资源&lt;=当前可用资源+所有Pj持有资源（j&lt;\i），如果Pi的资源不能立即分配，则要等待。</li>
</ul>
<h2 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h2><p>判断并保证系统处于安全状态。</p>
<ul>
<li>n=线程数量，m=资源类型数量；</li>
<li>Max（总需求量）：n*m矩阵，线程Ti最多请求类型Rj的资源Max[i,j]个实例</li>
<li>Available(剩余空闲量)：长度为m的向量，当前有Available[i]个类型Ri的资源实例可用</li>
<li>Allocation(已分配量)：n*m矩阵，线程Ti当前分配了Allocation[i,j]个Rj的实例</li>
<li>Need(未来需求量)：n*m矩阵，线程Ti未来需要Need[i,j]个Rj资源实例；</li>
<li>Need[i,j]=Max[i,j]-Allcation[i,j]</li>
</ul>
<p>安全状态判断：</p>
<ol>
<li>Work 和 Finish 分别是长度为 m 和 n 的向量初始化： Work = Available，Finish = false for i = 1,2,…,n</li>
<li>寻找线程 Ti ，Finish[i] = false，Need[i] &lt;= Work，找到 Need 比 Work 小的线程 i ，如果没有找到符合条件的 Ti ，转4</li>
<li>Work = Work + Allocation[i] ，Finish[i] = true，线程i的资源需求量小于当前系统剩余空闲资源，所以配置给他再回收。转2</li>
<li>如果所有线程Ti满足Finish[i]=true，则系统处于安全状态。</li>
<li>这种迭代循环到最后，则是安全的</li>
</ol>
<p>初始化：Requesti：线程Ti的资源请求向量，Requesti[j]：线程Ti请求资源Rj的实例</p>
<p>循环：</p>
<ol>
<li>如果Requesti &lt; Need[i]，转到2，否则拒绝资源申请，因为县城已经超过了其最大要求；</li>
<li>如果Requesti &lt;= Available，转到3，否则Ti必须等待，因为资源部可用；</li>
<li>通过安全状态判断是否分配资源给Ti，生成一个需要判断状态是否安全的资源分配环境：<ul>
<li>Available=Available-Requesti</li>
<li>Allocation[i] = Allocation[i]+Requesti</li>
<li>Need[i] = Need[i]-Requesti</li>
</ul>
</li>
</ol>
<h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p>允许系统进入死锁状态，并维护一个资源分配图，周期性调用死锁检测算法，如果有死锁，就调用死锁处理。</p>
<ul>
<li>Available：长度为m的向量，表示每种类型可用资源的数量；</li>
<li>Allocation：一个n*m矩阵，表示当前分配给各个进程每种类型资源的数量，当前Pi拥有资源Rj的Allocation[i,j]个实例。</li>
</ul>
<p>死锁监测算法：</p>
<ol>
<li>Work是系统中的空闲资源量，Finish时线程是否结束。Work = Available，Allocation[i] &gt; 0时，Finish[i] = false；否哦则Finish[i] = true；</li>
<li>寻找线程Ti满足Finish[i] = false且Requesti &lt;= Work，线程没结束且能满足线程资源请求量。</li>
<li>Work = Work + Allocation[i]，Finish[i] = true，转到2。</li>
<li>如果某个Finish[i] = false，则系统会死锁。</li>
</ol>
<p>死锁检测的使用：</p>
<ul>
<li>多长时间检测一次</li>
<li>多少进程需要回滚</li>
<li>难以分辨造成死锁的关键进程</li>
</ul>
<p>死锁恢复：</p>
<ul>
<li>终止所有的死锁进程</li>
<li>一次终止一个进程，看还会不会死锁</li>
<li>终止进程的顺序应该是<ul>
<li>进程优先级</li>
<li>进程已运行的时间和还需运行的时间</li>
<li>进程已占用资源</li>
<li>进程完成所需要的资源</li>
<li>进程终止数目</li>
<li>进程是交互还是批处理<br>方法</li>
<li>选择被抢占的资源</li>
<li>进程回退</li>
</ul>
</li>
</ul>
<h2 id="进程通信（IPC）概念"><a href="#进程通信（IPC）概念" class="headerlink" title="进程通信（IPC）概念"></a>进程通信（IPC）概念</h2><p>IPC提供两个基本操作：</p>
<ul>
<li>发送：send(message)</li>
<li>接收：recv(message)</li>
</ul>
<p>流程：</p>
<ul>
<li>建立通信链路</li>
<li>通过send/recv交换</li>
</ul>
<p>通信方式：</p>
<ul>
<li><p>间接通信：在通信进程和内核之间建立联系，一个进程把信息发送到内核的消息队列中，另一个进程读取，接受发送的时间可以不一样。通过操作系统维护的消息队列通信，每个消息队列有一个唯一的标识，只有共享了相同消息队列的进程，才能够通信。</p>
<ul>
<li>链接可以单向，也可以双向</li>
<li>每对进程可以共享多个消息队列</li>
<li>创建消息队列、通过消息队列收发消息、撤销消息队列</li>
<li>send(A, message)、recv(A, message)，A是消息队列</li>
<li>阻塞发送是发送方发送后进入等待，直到成功发送</li>
<li>阻塞接受是接收后进入等待，直到成功接受</li>
<li>非阻塞发送是发送方发送后返回</li>
<li>非阻塞接受是没有消息发送时，接收者在请求接受消息后，接受不到消息。</li>
</ul>
</li>
<li><p>直接通信：两个进程同时存在，发方向共享信道里发送，收方读取。进程必须正确的命名接收方。</p>
<ul>
<li>一般自动建立链路</li>
<li>一条链路对应一对通信进程</li>
<li>每对进程之间只有一个链路存在</li>
<li>链路可能单向，也可以双向</li>
</ul>
</li>
</ul>
<p>进程发送的消息在链路上可能有三种缓冲方式：</p>
<ul>
<li>0容量：发送方必须等待接收方</li>
<li>有限容量：通信链路缓冲队列满了，发送方必须等待</li>
<li>无限容量：发送方不需等待</li>
</ul>
<h2 id="信号和管道"><a href="#信号和管道" class="headerlink" title="信号和管道"></a>信号和管道</h2><p>信号是进程间软件中断通知和处理机制，如果执行过程中有意外需要处理，则需要信号，Ctrl-C可以使进程停止，这个处理是通过信号实现。如SIGKILL，SIGSTOP等。</p>
<p>信号的接收处理：</p>
<ul>
<li>捕获：执行进程指定的信号处理函数被调用</li>
<li>忽略：执行操作系统的缺省处理，例如进程终止和挂起等</li>
<li>屏蔽：禁止进程接受和处理信号，可能是暂时的。</li>
</ul>
<p>传送的信息量小，只有一个信号类型，只能做快速的响应知己。</p>
<ol>
<li>首先进程启动时注册相应的信号处理例程到操作系统；</li>
<li>其他程序发出信号时，操作系统分发信号到进程的信号处理函数；</li>
<li>进程执行信号处理函数。</li>
</ol>
<p>管道：进程间基于内存文件的通信机制，内存中建立一个临时文件，子进程从父进程继承文件描述符，缺省文件描述符：0 1 2</p>
<p>进程不知道另一端，可能时从键盘、文件等。</p>
<p>系统调用：</p>
<ul>
<li>读管道read(fd,buffer,nbytes)</li>
<li>写管道write(fd,buffer,nbytes)</li>
<li>创建管道pipe(rgfd)，rgfd时两个文件描述符组成的数组，rgfd[0]是读文件描述符，rgfd[1]是写文件描述符。利用继承的关系在两个进城之间继承文件描述符。</li>
</ul>
<h2 id="消息队列和共享内存"><a href="#消息队列和共享内存" class="headerlink" title="消息队列和共享内存"></a>消息队列和共享内存</h2><p>消息队列是操作系统维护的字节序列为基本单位的间接通信机制，若干个进程可以发送到消息队列中，每个消息是一个字节序列，相同标识的消息组成先进先出顺序的队列。<br>系统调用如下：</p>
<ul>
<li>msgget(key,flags)：获取消息队列标识</li>
<li>msgsnd(QID,buf,size,flags)：发送消息</li>
<li>msgrcv(QID,buf,size,flags)：接收消息</li>
</ul>
<p>消息队列独立于进程，进程结束了之后消息队列可以继续存在，实现两个不同生命周期的进程之间的通信。</p>
<p>共享内存是把同一个物理内存区域同时映射到多个进程的内存地址空间的通信机制。每个进程都有私有内存地址空间，需要明确设置共享内存段。同一进程的线程总是共享相同的内存地址空间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/29/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/29/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/" class="post-title-link" itemprop="url">清华大学操作系统课程实验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-06-29 23:56:00" itemprop="dateCreated datePublished" datetime="2019-06-29T23:56:00+08:00">2019-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-06 19:31:19" itemprop="dateModified" datetime="2022-01-06T19:31:19+08:00">2022-01-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h1><h2 id="操作系统镜像文件ucore-img是如何一步一步生成的？-需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果"><a href="#操作系统镜像文件ucore-img是如何一步一步生成的？-需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果" class="headerlink" title="操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)"></a>操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)</h2><p>用<em>make “V=”</em>看到了所有的编译命令</p>
<p>第178行 create ucore.img，可以看到call函数，  </p>
<p>totarget = $(addprefix $(BINDIR)$(SLASH),$(1))  </p>
<p>这样就调用了addprefix，把$(BINDIR)$(SLASH)变成$(1)的前缀，在makefile里再把$(1)调用call变成要生成的文件，这里需要bootblock和kernel。  </p>
<p>bootblock需要一些.o文件，makefile里的foreach有如下格式：$(foreach &lt; var &gt;,&lt; list &gt;,&lt; text &gt;)  </p>
<p>这个函数的意思是，把参数&lt; list &gt;;中的单词逐一取出放到参数&lt; var &gt;所指定的变量中，然后再执行&lt; text&gt;;所包含的表达式。每一次&lt; text &gt;会返回一个字符串，循环过程中，&lt; text &gt;的所返回的每个字符串会以空格分隔，最后当整个循环结束时，&lt; text &gt;所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</p>
<ul>
<li>通过看makefile生成的编译命令，生成bootasm.o需要bootasm.S</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<ul>
<li>-ggdb  生成可供gdb使用的调试信息。这样才能用qemu+gdb来调试bootloader or ucore。  </li>
<li>-m32  生成适用于32位环境的代码。我们用的模拟硬件是32bit的80386，所以ucore也要是32位。  </li>
<li>-gstabs  生成stabs格式的调试信息。这样要ucore的monitor可以显示出便于开发者阅读的函数调用  </li>
<li>-nostdinc  不使用标准库。标准库是给应用程序用的，我们是编译ucore内核，OS内核是提供服务的，所以所有的服务要自给自足。  </li>
<li>-fno-stack-protector  不生成用于检测缓冲区溢出的代码。这是for 应用程序的，我们是编译内核，ucore内核好像还用不到此功能。  </li>
<li>-Os  为减小代码大小而进行优化。根据硬件spec，主引导扇区只有512字节，我们写的简单bootloader的最终大小不能大于510字节。  </li>
<li>-I&lt; dir &gt;  添加搜索头文件的路径</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<ul>
<li>-m <emulation>  模拟为i386上的连接器  </li>
<li>-nostdlib  不使用标准库  </li>
<li>-N  设置代码段和数据段均可读写  </li>
<li>-e <entry>  指定入口  </li>
<li>-Ttext  制定代码段开始位置  </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kernel = $(call totarget,kernel)</span><br><span class="line"></span><br><span class="line">$(kernel): tools/kernel.ld</span><br><span class="line"></span><br><span class="line">$(kernel): $(KOBJS)</span><br><span class="line">	@echo + ld $@</span><br><span class="line">	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)</span><br><span class="line">	@$(OBJDUMP) -S $@ &gt; $(call asmfile,kernel)</span><br><span class="line">	@$(OBJDUMP) -t $@ | $(SED) &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; $(call symfile,kernel)</span><br><span class="line"></span><br><span class="line">$(call create_target,kernel)</span><br></pre></td></tr></table></figure>
<p>编译命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Ikern/trap/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trapentry.S -o obj/kern/（o文件）</span><br></pre></td></tr></table></figure><br>链接器：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/stdio.o obj/kern/libs/readline.o obj/kern/debug/panic.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/picirq.o obj/kern/driver/intr.o obj/kern/trap/trap.o obj/kern/trap/vectors.o obj/kern/trap/trapentry.o obj/kern/mm/pmm.o  obj/libs/string.o obj/libs/printfmt.o</span><br></pre></td></tr></table></figure></p>
<p>dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。</p>
<p>注意：指定数字的地方若以下列字符结尾，则乘以相应的数字：b=512；c=1；k=1024；w=2<br>参数注释：</p>
<ul>
<li>if=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if=input file &gt;</li>
<li>of=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt;</li>
<li>ibs=bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。</li>
<li>obs=bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。</li>
<li>bs=bytes：同时设置读入/输出的块大小为bytes个字节。</li>
<li>cbs=bytes：一次转换bytes个字节，即指定转换缓冲区大小。</li>
<li>skip=blocks：从输入文件开头跳过blocks个块后再开始复制。</li>
<li>seek=blocks：从输出文件开头跳过blocks个块后再开始复制。<ul>
<li>注意：通常只用当输出文件是磁盘或磁带时才有效，即备份到磁盘或磁带时才有效。</li>
</ul>
</li>
<li>count=blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。</li>
<li>conv=conversion：用指定的参数转换文件。<ul>
<li>ascii：转换ebcdic为ascii</li>
<li>ebcdic：转换ascii为ebcdic</li>
<li>ibm：转换ascii为alternate ebcdic</li>
<li>block：把每一行转换为长度为cbs，不足部分用空格填充</li>
<li>unblock：使每一行的长度都为cbs，不足部分用空格填充</li>
<li>lcase：把大写字符转换为小写字符</li>
<li>ucase：把小写字符转换为大写字符</li>
<li>swab：交换输入的每对字节</li>
<li>noerror：出错时不停止</li>
<li>notrunc：不截短输出文件</li>
<li>sync：将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。</li>
</ul>
</li>
</ul>
<p>生成一个有10000个块的文件，用0填充（答案中说，每个块默认512字节，但是可能要有bs参数指定或者bs默认就是512？）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=bin/ucore.img count=10000</span><br></pre></td></tr></table></figure></p>
<p>把bootblock中的内容写到第一个块<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=bin/bootblock of=bin/ucore.img conv=notrunc</span><br></pre></td></tr></table></figure></p>
<p>从第二个块开始写kernel中的内容<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc</span><br></pre></td></tr></table></figure></p>
<h2 id="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"><a href="#一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？" class="headerlink" title="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"></a>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</h2><p>上课讲过，合法的主引导扇区最后两个字节有特定值<br>0x55、0xAA<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buf一共512个字节</span><br><span class="line">buf[510] = 0x55;</span><br><span class="line">buf[511] = 0xAA;</span><br></pre></td></tr></table></figure></p>
<h2 id="练习2："><a href="#练习2：" class="headerlink" title="练习2："></a>练习2：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file bin/kernel</span><br><span class="line">set architecture i8086</span><br><span class="line">target remote :1234</span><br><span class="line">b *0x7c00</span><br><span class="line">continue</span><br></pre></td></tr></table></figure>
<p>在gdb中输入命令，输出2条instruction<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x /2i $pc</span><br></pre></td></tr></table></figure><br>跟bootasm.S里的汇编代码一致！amazing<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x /2i $pc</span><br><span class="line">=&gt; 0x7c00:	cli    </span><br><span class="line">   0x7c01:	cld    </span><br><span class="line">(gdb) x /10i $pc</span><br><span class="line">=&gt; 0x7c00:	cli    </span><br><span class="line">   0x7c01:	cld    </span><br><span class="line">   0x7c02:	xor    %ax,%ax</span><br><span class="line">   0x7c04:	mov    %ax,%ds</span><br><span class="line">   0x7c06:	mov    %ax,%es</span><br><span class="line">   0x7c08:	mov    %ax,%ss</span><br><span class="line">   0x7c0a:	in     $0x64,%al</span><br><span class="line">   0x7c0c:	test   $0x2,%al</span><br><span class="line">   0x7c0e:	jne    0x7c0a</span><br><span class="line">   0x7c10:	mov    $0xd1,%al</span><br></pre></td></tr></table></figure></p>
<p>在Makefile的debug选项中加入<em>-d in_asm -D q.log</em>，可以生成一个q.log里边是执行的汇编命令（部分）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0xfffffff0:  ljmp   $0xf000,$0xe05b</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x000fe05b:  cmpl   $0x0,%cs:0x6c48</span><br><span class="line">0x000fe062:  jne    0xfd2e1</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x000fe066:  xor    %dx,%dx</span><br><span class="line">0x000fe068:  mov    %dx,%ss</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x000fe06a:  mov    $0x7000,%esp</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x000fe070:  mov    $0xf3691,%edx</span><br><span class="line">0x000fe076:  jmp    0xfd165</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a>练习3</h2><p>分析bootloader进入保护模式的过程。（要求在报告中写出分析）<br>BIOS将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行bootloader。请分析bootloader是如何完成从实模式进入保护模式的。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lab1/boot/bootasm.S</span><br></pre></td></tr></table></figure><br>类似之前，从0x7c00进入，首先<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        .code16</span><br><span class="line">            cli				;禁止中断发生</span><br><span class="line">            cld				;CLD与STD是用来操作方向标志位DF。CLD使DF复位，即D</span><br><span class="line">            				  ;F=0，STD使DF置位，即DF=1.用于串操作指令中。</span><br><span class="line">            xorw %ax, %ax   ;ax置0</span><br><span class="line">            movw %ax, %ds   ;其他寄存器也清空</span><br><span class="line">            movw %ax, %es</span><br><span class="line">            movw %ax, %ss</span><br></pre></td></tr></table></figure><br>.globl指示告诉汇编器，_start这个符号要被链接器用到，所以要在目标文件的符号表中标记它是一个全局符号（在第 5.1 节 “目标文件”详细解释）。_start就像C程序的main函数一样特殊，是整个程序的入口，链接器在链接时会查找目标文件中的_start符号代表的地址，把它设置为整个程序的入口地址，所以每个汇编程序都要提供一个_start符号并且用.globl声明。如果一个符号没有用.globl声明，就表示这个符号不会被链接器用到。</p>
<p>开启A20：到了80286，系统的地址总线有原来的20根发展为24根，这样能够访问的内存可以达到2^24=16M。Intel在设计80286时提出的目标是向下兼容。所以，在实模式下，系统所表现的行为应该和8086/8088所表现的完全一样，也就是说，在实模式下，80286以及后续系列，应该和8086/8088完全兼容。但最终，80286芯片却存在一个BUG：因为有了80286有A20线，如果程序员访问100000H-10FFEFH之间的内存，系统将实际访问这块内存，而不是象8086/8088一样从0开始。为了解决上述兼容性问题，IBM使用键盘控制器上剩余的一些输出线来管理第21根地址线（从0开始数是第20根） 的有效性，被称为A20 Gate:</p>
<blockquote>
<p>如果A20 Gate被打开，则当程序员给出100000H-10FFEFH之间的地址的时候，系统将真正访问这块内存区域； </p>
<p>如果A20 Gate被禁止，则当程序员给出100000H-10FFEFH之间的地址的时候，系统仍然使用8086/8088的方式即取模方式（8086仿真）。绝大多数IBM PC兼容机默认的A20 Gate是被禁止的。现在许多新型PC上存在直接通过BIOS功能调用来控制A20 Gate的功能。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">seta20.1:               </span><br><span class="line">    inb $0x64, %al      ;0x64里的数据放到al中，即从I/O端口读取一个字节(BYTE,;HALF-WORD)</span><br><span class="line">    testb $0x2, %al     ;检测</span><br><span class="line">    jnz seta20.1        ;等到这个端口不忙，没有东西传进来</span><br><span class="line"></span><br><span class="line">    movb $0xd1, %al     ; 0xd1 写到 0x64</span><br><span class="line">    outb %al, $0x64     ;写8042输出端口</span><br><span class="line"></span><br><span class="line">seta20.2:                </span><br><span class="line">    inb $0x64, %al      </span><br><span class="line">    testb $0x2, %al     </span><br><span class="line">    jnz seta20.2		;等不忙</span><br><span class="line"></span><br><span class="line">    movb $0xdf, %al     ;打开A20 0xdf -&gt; port 0x60</span><br><span class="line">    outb %al, $0x60     ;0xdf = 11011111</span><br></pre></td></tr></table></figure><br>初始化GDT表并打开保护模式<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lgdt gdtdesc		   ;让CPU读取gdtr_addr所指向内存内容保存到GDT内存当中</span><br><span class="line">movl %cr0, %eax		   ;cr0寄存器PE位or置1</span><br><span class="line">orl $CR0_PE_ON, %eax   </span><br><span class="line">movl %eax, %cr0</span><br><span class="line">ljmp $PROT_MODE_CSEG, $protcseg ;长跳改cs，基于段机制的寻址</span><br></pre></td></tr></table></figure><br>最后初始化堆栈、寄存器，调用bootmain<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protcseg:</span><br><span class="line">    # 初始化寄存器</span><br><span class="line">    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector</span><br><span class="line">    movw %ax, %ds                                   # -&gt; DS: Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; ES: Extra Segment</span><br><span class="line">    movw %ax, %fs                                   # -&gt; FS</span><br><span class="line">    movw %ax, %gs                                   # -&gt; GS</span><br><span class="line">    movw %ax, %ss                                   # -&gt; SS: Stack Segment</span><br><span class="line"></span><br><span class="line">    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line">    movl $start, %esp</span><br><span class="line">    call bootmain</span><br></pre></td></tr></table></figure></p>
<h2 id="练习四"><a href="#练习四" class="headerlink" title="练习四"></a>练习四</h2><p>对于bootmain.c，它唯一的工作就是从硬盘的第一个扇区启动格式为ELF的内核镜像；控制从boot.S文件开始—这个文件设置了保护模式和一个栈，这样C代码就可以运行了，然后再调用bootmain()。  </p>
<p>对x86.h头文件有：<a href="http://www.codeforge.cn/read/234474/x86.h__html">http://www.codeforge.cn/read/234474/x86.h__html</a><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static inline uchar</span><br><span class="line">inb(ushort port)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">  uchar data;</span><br><span class="line"> </span><br><span class="line">  asm volatile(&quot;in %1,%0&quot; : &quot;=a&quot; (data) : &quot;d&quot; (port));</span><br><span class="line">  //对应 in port,data</span><br><span class="line">  return data;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>0x1F7：读 用来存放读操作后的状态</p>
</blockquote>
<p>readsect(void *dst, uint32_t secno)从secno扇区读取数据到dst  </p>
<ul>
<li>用汇编的方式实现读取1000号逻辑扇区开始的8个扇区  </li>
<li>IDE通道的通讯地址是0x1F0 - 0x1F7  </li>
<li>其中0x1F3 - 0x1F6 4个字节的端口是用来写入LBA地址的  </li>
<li>LBA就是 logical Block Address  </li>
<li>1000的16进制就是0x3E8  </li>
<li>向0x1F3 - 0x1F6写入 0x3E8  </li>
<li>向0x1F2这个地址写入扇区数量，也就是8  </li>
<li>向0X1F7写入要执行的操作命令码，对读操作的命令码是 0x20  </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">out 0x1F3 0x00</span><br><span class="line">out 0x1F4 0x00</span><br><span class="line">out 0x1F5 0x03</span><br><span class="line">out 0x1F6 0xE8</span><br><span class="line">out 0x1F2 0x08</span><br><span class="line">out 0x1F7 0x20</span><br></pre></td></tr></table></figure>
<p>outb的定义在x86.h中，封装out命令，将data输出到port端口<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">outb</span><span class="params">(ushort port, uchar data)</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;out %0,%1&quot;</span> : : <span class="string">&quot;a&quot;</span> (data), <span class="string">&quot;d&quot;</span> (port))</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>业界共同推出了 LBA48，采用 48 个比特来表示逻辑扇区号。如此一来，就可以管理131072 TB 的硬盘容量了。在这里我们采用将采用 LBA28 来访问硬盘。<br>第1步：设置要读取的扇区数量。这个数值要写入0x1f2端口。这是个8位端口，因此每次只能读写255个扇区：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx,0x1f2</span><br><span class="line">mov al,0x01    ;1 个扇区</span><br><span class="line">out dx,al</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：如果写入的值为 0，则表示要读取 256 个扇区。每读一个扇区，这个数值就减一。因此，如果在读写过程中发生错误，该端口包含着尚未读取的扇区数。   </p>
</blockquote>
<p>第2步：设置起始LBA扇区号。扇区的读写是连续的，因此只需要给出第一个扇区的编号就可以了。28 位的扇区号太长，需要将其分成 4 段，分别写入端口 0x1f3、0x1f4、0x1f5 和 0x1f6 号端口。其中，0x1f3 号端口存放的是 0～7 位；0x1f4 号端口存放的是 8～15 位；0x1f5 号端口存放的是 16～23 位，最后 4 位在 0x1f6 号端口。  </p>
<p>第3步:<br>向端口 0x1f7 写入 0x20，请求硬盘读。  </p>
<p>第4步:等待读写操作完成。端口0x1f7既是命令端口，又是状态端口。在通过这个端口发送读写命令之后，硬盘就忙乎开了。在它内部操作期间，它将 0x1f7 端口的第7位置“1”，表明自己很忙。一旦硬盘系统准备就绪，它再将此位清零，说明自己已经忙完了，同时将第3位置“1”，意思是准备好了，请求主机发送或者接收数据。  </p>
<p>第5步:连续取出数据。0x1f0 是硬盘接口的数据端口，而且还是一个16位端口。一旦硬盘控制器空闲，且准备就绪，就可以连续从这个端口写入或者读取数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">outb(0x1F2, 1);                         // 读取第一个数据块</span><br><span class="line">outb(0x1F3, secno &amp; 0xFF);</span><br><span class="line">outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF);</span><br><span class="line">outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF);</span><br><span class="line">outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0);</span><br><span class="line">outb(0x1F7, 0x20);                      // cmd 0x20 - read sectors</span><br><span class="line"></span><br><span class="line">insl(0x1F0, dst, SECTSIZE / 4)          // 第五步</span><br></pre></td></tr></table></figure>
<p>readseg函数简单包装了readsect，可以从设备读取任意长度的内容。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void readseg(uintptr_t va, uint32_t count, uint32_t offset) &#123;</span><br><span class="line">  uintptr_t end_va = va + count;</span><br><span class="line">  va -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">  uint32_t secno = (offset / SECTSIZE) + 1;</span><br><span class="line">  // 看是第几块，加1因为0扇区被引导占用,ELF文件从1扇区开始</span><br><span class="line"></span><br><span class="line">  for (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;</span><br><span class="line">    readsect((void *)va, secno);//调用之前的封装函数对每一块进行处理</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对不同的文件，执行file命令如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">file link.o </span><br><span class="line">link.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</span><br><span class="line"> </span><br><span class="line">file libfoo.so </span><br><span class="line">libfoo.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=871ecaf438d2ccdcd2e54cd8158b9d09a9f971a7, not stripped</span><br><span class="line"> </span><br><span class="line">file p1</span><br><span class="line">p1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=37f75ef01273a9c77f4b4739bcb7b63a4545d729, not stripped</span><br><span class="line"> </span><br><span class="line">file libfoo.so </span><br><span class="line">libfoo.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=871ecaf438d2ccdcd2e54cd8158b9d09a9f971a7, stripped</span><br></pre></td></tr></table></figure><br>以下是主函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">bootmain(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="comment">// read the 1st page off disk</span></span><br><span class="line">    readseg((<span class="type">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看是不是标准的elf</span></span><br><span class="line">    <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// elf头中有elf文件应该加载到什么位置，将表头地址存在ph中</span></span><br><span class="line">    ph = (<span class="keyword">struct</span> proghdr *)((<span class="type">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">        readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到内核的入口，这个函数不返回</span></span><br><span class="line">    ((<span class="type">void</span> (*)(<span class="type">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般的 ELF 文件包括三个索引表：ELF header，Program header table，Section header table。</p>
<ul>
<li>ELF header：在文件的开始，保存了路线图，描述了该文件的组织情况。  </li>
<li>Program header table：告诉系统如何创建进程映像。用来构造进程映像的目标文件必须具有程序头部表，可重定位文件不需要这个表。  </li>
<li>Section header table：包含了描述文件节区的信息，每个节区在表中都有一项，每一项给出诸如节区名称、节区大小这类信息。用于链接的目标文件必须包含节区头部表，其他目标文件可以有，也可以没有这个表。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT]; <span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf64_Half    e_type;         <span class="comment">/* Object file type */</span></span><br><span class="line">  Elf64_Half    e_machine;      <span class="comment">/* Architecture */</span></span><br><span class="line">  Elf64_Word    e_version;      <span class="comment">/* Object file version */</span></span><br><span class="line">  Elf64_Addr    e_entry;        <span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf64_Off e_phoff;        <span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf64_Off e_shoff;        <span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf64_Word    e_flags;        <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf64_Half    e_ehsize;       <span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf64_Half    e_phentsize;        <span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf64_Half    e_phnum;        <span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf64_Half    e_shentsize;        <span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf64_Half    e_shnum;        <span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf64_Half    e_shstrndx;     <span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure>
<p>ELF文件中有很多段，段表（Section Header Table）就是保存这些段的基本信息的结构，包括了段名、段长度、段在文件中的偏移位置、读写权限和其他段属性。<br>objdump工具可以查看ELF文件基本的段结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word    sh_name;        <span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">  Elf64_Word    sh_type;        <span class="comment">/* Section type */</span></span><br><span class="line">  Elf64_Xword   sh_flags;       <span class="comment">/* Section flags */</span></span><br><span class="line">  Elf64_Addr    sh_addr;        <span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf64_Off sh_offset;      <span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf64_Xword   sh_size;        <span class="comment">/* Section size in bytes */</span></span><br><span class="line">  Elf64_Word    sh_link;        <span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf64_Word    sh_info;        <span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf64_Xword   sh_addralign;       <span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf64_Xword   sh_entsize;     <span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure></p>
<h2 id="练习五"><a href="#练习五" class="headerlink" title="练习五"></a>练习五</h2><p>一个比较简单但很绕的逻辑，找到每个函数调用压栈时的指针，找到这个指针也就找到了上一个函数的部分，再找它之前的函数调用压栈的内容。主要问题是忘记了ebp!=0这个条件，忽视了要用16进制。</p>
<ul>
<li>eip是寄存器存放下一个CPU指令存放的内存地址，当CPU执行完当前的指令后，从eip寄存器中读取下一条指令的内存地址，然后继续执行；  </li>
<li>esp是寄存器存放当前线程的栈顶指针；  </li>
<li>ebp存放一个指针，该指针指向系统栈最上面一个栈帧的底部。即EBP寄存器存储的是栈底地址，而这个地址是由ESP在函数调用前传递给EBP的。等到调用结束，EBP会把其地址再次传回给ESP。所以ESP又一次指向了函数调用结束后，栈顶的地址。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void print_stackframe(void) &#123;</span><br><span class="line">     /* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);</span><br><span class="line">      * (2) call read_eip() to get the value of eip. the type is (uint32_t);</span><br><span class="line">      * (3) from 0 .. STACKFRAME_DEPTH</span><br><span class="line">      *    (3.1) printf value of ebp, eip</span><br><span class="line">      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4]</span><br><span class="line">      *    (3.3) cprintf(&quot;\n&quot;);</span><br><span class="line">      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.</span><br><span class="line">      *    (3.5) popup a calling stackframe</span><br><span class="line">      *           NOTICE: the calling funciton&#x27;s return addr eip  = ss:[ebp+4]</span><br><span class="line">      *                   the calling funciton&#x27;s ebp = ss:[ebp]</span><br><span class="line">      */</span><br><span class="line">        uint32_t my_ebp = read_ebp();</span><br><span class="line">        uint32_t my_eip = read_eip();//读取当前的ebp和eip</span><br><span class="line">        int i,j;</span><br><span class="line">        for(i = 0; my_ebp!=0 &amp;&amp; i&lt; STACKFRAME_DEPTH; i++)&#123;</span><br><span class="line">                cprintf(&quot;%0x %0x\n&quot;,my_ebp,my_eip);</span><br><span class="line">                for(j=0;j&lt;4;j++)&#123;</span><br><span class="line">                        cprintf(&quot;%0x\t&quot;,((uint32_t*)my_ebp+2)[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                cprintf(&quot;\n&quot;);</span><br><span class="line">                print_debuginfo(my_eip-1);</span><br><span class="line">                my_ebp = ((uint32_t*)my_ebp)[0];</span><br><span class="line">                my_eip = ((uint32_t*)my_ebp)[1];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ebp（基指针）寄存器主要通过软件约定与堆栈相关联。 在进入C函数时，函数的初始代码通常将先前函数的基本指针推入堆栈来保存，然后在函数持续时间内将当前esp值复制到ebp中。 如果程序中的所有函数都遵循这个约定，那么在程序执行期间的任何给定点，都可以通过跟踪保存的ebp指针链并确切地确定嵌套的函数调用序列引起这个特定的情况来追溯堆栈。 指向要达到的函数。 例如，当某个特定函数导致断言失败时，因为错误的参数传递给它，但您不确定是谁传递了错误的参数。 堆栈回溯可找到有问题的函数。</p>
<p>最后一行对应的是第一个使用堆栈的函数，所以在栈的最深一层，就是bootmain.c中的bootmain。 bootloader起始的堆栈从0x7c00开始，使用”call bootmain”转入bootmain函数。 call指令压栈，所以bootmain中ebp为0x7bf8。</p>
<h2 id="练习六"><a href="#练习六" class="headerlink" title="练习六"></a>练习六</h2><p>一个表项的结构如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*lab1/kern/mm/mmu.h*/</span><br><span class="line">/* Gate descriptors for interrupts and traps */</span><br><span class="line">struct gatedesc &#123;</span><br><span class="line">    unsigned gd_off_15_0 : 16;        // low 16 bits of offset in segment</span><br><span class="line">    unsigned gd_ss : 16;            // segment selector</span><br><span class="line">    unsigned gd_args : 5;            // # args, 0 for interrupt/trap gates</span><br><span class="line">    unsigned gd_rsv1 : 3;            // reserved(should be zero I guess)</span><br><span class="line">    unsigned gd_type : 4;            // type(STS_&#123;TG,IG32,TG32&#125;)</span><br><span class="line">    unsigned gd_s : 1;                // must be 0 (system)</span><br><span class="line">    unsigned gd_dpl : 2;            // descriptor(meaning new) privilege level</span><br><span class="line">    unsigned gd_p : 1;                // Present</span><br><span class="line">    unsigned gd_off_31_16 : 16;        // high bits of offset in segment</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>一个表项占用8字节，其中2-3字节是段选择子，0-1字节和6-7字节拼成位移， 两者联合便是中断处理程序的入口地址。(copy from answer)  </p>
<p>pic_init：中断控制器的初始化；idt_init：建立中断描述符表，并使能中断，intr_enable()</p>
<p>中断向量表可以认为是一个大数组，产生中断时生成一个中断号，来查这个idt表，找到中断服务例程的地址（段选择子加offset）。</p>
<p>主要是调用SETGATE这个宏对interrupt descriptor table进行初始化，是之前看到的对每个字节进行操作。然后调用lidt进行load idt（sti：使能中断）</p>
<p>建立一个中断描述符</p>
<ul>
<li>istrap: 1 是一个trap, 0 代表中断</li>
<li>sel: 中断处理代码段</li>
<li>off: 中断处理代码段偏移</li>
<li>dpl: 描述符的优先级</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define SETGATE(gate, istrap, sel, off, dpl)</span><br></pre></td></tr></table></figure>
<p>除了系统调用中断(T_SYSCALL)使用陷阱门描述符且权限为用户态权限以外，其它中断均使用特权级(DPL)为0的中断门描述符，权限为内核态权限；</p>
<ol>
<li>中断描述符表（Interrupt Descriptor Table）中断描述符表把每个中断或异常编号和一个指向中断服务例程的描述符联系起来。同GDT一样，IDT是一个8字节的描述符数组，但IDT的第一项可以包含一个描述符。CPU把中断（异常）号<em>乘以8</em>做为IDT的索引。IDT可以位于内存的任意位置，CPU通过IDT寄存器（IDTR）的内容来寻址IDT的起始地址。指令LIDT和SIDT用来操作IDTR。两条指令都有一个显示的操作数：一个6字节表示的内存地址。在保护模式下，最多会存在256个Interrupt/Exception Vectors。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        extern uintptr_t __vectors[];</span><br><span class="line">        int i;</span><br><span class="line">        //for(i=0;i&lt;256;i++)</span><br><span class="line">        for(i=0;i&lt; sizeof(idt) / sizeof(struct gatedesc); i++)&#123;</span><br><span class="line">                SETGATE(idt[i],0,GD_KTEXT,__vectors[i],DPL_KERNEL);</span><br><span class="line">        &#125;</span><br><span class="line">//      SETGATE(idt[T_SWITCH_TOK], 0, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);</span><br><span class="line">        SETGATE(idt[T_SWITCH_TOK], 1, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);</span><br><span class="line">        lidt(&amp;idt_pd);</span><br></pre></td></tr></table></figure>
<p>对idt中的每一项，调用SETGATE进行设置，第二个是0表明是一个中断，如果是1表明是一个陷阱；GD_KTEXT是SEG_KTEXT（1，全局段编号）乘8，是处理中断的代码段编号，__vectors[i]是作为在代码段中的偏移量，vectors[i]在kern/trap/vectors.S中定义，定义了255个中断服务例程的地址，这里才是入口，且都跳转到__alltraps。在trap中调用了trap_dispatch，这样就根据传进来的进行switch处理。  </p>
<p>用户态设置在特权级3，内核态设置在特权级0。</p>
<h2 id="练习七"><a href="#练习七" class="headerlink" title="练习七"></a>练习七</h2><p>这个实验实现用户态和内核态的转换，通过看代码基本明白。在init.c中的lab1_switch_to_user函数时一段汇编代码， 触发中断的话，有‘int %0’，就把第二个冒号（输入的数，T_SWITCH_TOK）替换%0， 这样中断号就是T_SWITCH_TOK。  </p>
<p>SETGATE设置中断向量表将每个中断处理例程的入口设成<strong>vector[i]的值，然后在有中断时，找到中断向量表中这个中断的处理例程，都是跳到</strong>alltraps，__alltraps把寄存器（ds es fs gs）压栈，把esp压栈，这样假装构造一个trapframe然后调用trap，trap调用了trap_dispatch</p>
<p>在trap_dispatch中，对从堆栈弹出的段寄存器进行修改，转成User时和转成Kernel时不一样，分别赋值，同时需要修改之前的trapframe，实现中断的恢复。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> //LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.</span><br><span class="line">case T_SWITCH_TOU:</span><br><span class="line">    if(tf-&gt;tf_cs != USER_CS)&#123;</span><br><span class="line">            tf-&gt;tf_cs = USER_CS;</span><br><span class="line">            tf-&gt;tf_ds = USER_DS;</span><br><span class="line">            tf-&gt;tf_es = USER_DS;</span><br><span class="line">            tf-&gt;tf_ss = USER_DS;</span><br><span class="line">            tf-&gt;tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">            *((uint32_t*)tf - 1) = (uint32_t)tf;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">case T_SWITCH_TOK:</span><br><span class="line">    if(tf-&gt;tf_cs != KERNEL_CS) &#123;</span><br><span class="line">    tf-&gt;tf_cs = KERNEL_CS;</span><br><span class="line">    tf-&gt;tf_ds = KERNEL_DS;</span><br><span class="line">    tf-&gt;tf_es = KERNEL_DS;</span><br><span class="line">    tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;</span><br><span class="line">    struct trapframe *switchu2k = (struct trapframe *)(tf-&gt;tf_esp - (sizeof(struct trapframe) - 8));</span><br><span class="line">    memmove(switchu2k,tf,sizeof(struct trapframe)-8);</span><br><span class="line">    *((uint32_t *)tf-1)=(uint32_t)switchu2k;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>
<h1 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h1><h2 id="读代码"><a href="#读代码" class="headerlink" title="读代码"></a>读代码</h2><p>在bootloader进入保护模式前进行探测物理内存分布和大小，基本方式是通过BIOS中断调用，在实模式下完成，在boot/bootasm.S中从probe_memory处到finish_probe处的代码部分完成。以下应该是检测到的物理内存信息：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">memory management: default_pmm_manager</span><br><span class="line">e820map:</span><br><span class="line">  memory: 0009fc00, [00000000, 0009fbff], type = 1.</span><br><span class="line">  memory: 00000400, [0009fc00, 0009ffff], type = 2.</span><br><span class="line">  memory: 00010000, [000f0000, 000fffff], type = 2.</span><br><span class="line">  memory: 07ee0000, [00100000, 07fdffff], type = 1.</span><br><span class="line">  memory: 00020000, [07fe0000, 07ffffff], type = 2.</span><br><span class="line">  memory: 00040000, [fffc0000, ffffffff], type = 2.</span><br></pre></td></tr></table></figure></p>
<p>参考：type是物理内存空间的类型，1是可以使用的，2是暂时不能够使用的。</p>
<p>之前是开启A20的16位地址线，实现20位地址访问。通过写键盘控制器8042的64h端口与60h端口。先转成实模式！<br>获取的物理内存信息是用这种结构存的（内存映射地址描述符），一共20字节：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> nr_map;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uint64_t</span> addr;    <span class="comment">//8字节，unsigned long long，基地址？</span></span><br><span class="line">        <span class="type">uint64_t</span> size;    <span class="comment">//8字节，unsigned long long，大小</span></span><br><span class="line">        <span class="type">uint32_t</span> type;    <span class="comment">//4字节，unsigned long，内存类型</span></span><br><span class="line">    &#125; __attribute__((packed)) <span class="built_in">map</span>[E820MAX];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每探测到一块内存空间，对应的内存映射描述符被写入指定表，以下是通过向INT 15h中断传入e820h参数来探测物理内存空间的信息。”$”美元符号修饰立即数，”%”修饰寄存器。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">probe_memory:</span><br><span class="line">    movl $0, 0x8000     #把0这个立即数写入0x8000地址，</span><br><span class="line">    xorl %ebx, %ebx     #相当于我们设置在0x8000处存放struct e820map, 并清除e820map中的nr_map置0</span><br><span class="line">    movw $0x8004, %di   #0x8004正好就是第一个内存映射地址描述符的地址，因为nr_map是四个字节</span><br><span class="line">start_probe:</span><br><span class="line">    movl $0xE820, %eax  #传入0xE820作为参数，</span><br><span class="line">    movl $20, %ecx      #内存映射地址描述符的大小是20个字节</span><br><span class="line">    movl $SMAP, %edx    #SMAP之前定义是0x534d4150，不知道何用</span><br><span class="line">    int $0x15           #调用INT 15H中断</span><br><span class="line">    jnc cont            #CF=0,则跳转到cont</span><br><span class="line">    movw $12345, 0x8000 </span><br><span class="line">    jmp finish_probe</span><br><span class="line">cont:</span><br><span class="line">    addw $20, %di       #设置下一个内存映射地址描述符的地址</span><br><span class="line">    incl 0x8000         #E820map中的nr_map加一</span><br><span class="line">    cmpl $0, %ebx       #如果INT0x15返回的ebx为零，表示探测结束，如果还有就继续找</span><br><span class="line">    jnz start_probe</span><br><span class="line">finish_probe:</span><br></pre></td></tr></table></figure></p>
<p>调用中断int 15h 之前，需要填充如下寄存器：  </p>
<ul>
<li>eax  int 15h 可以完成许多工作，主要有ax的值决定，我们想要获取内存信息，需要将ax赋值为0E820H。  </li>
<li>ebx  放置着“后续值(continuation value)”，第一次调用时ebx必须为0.  </li>
<li>es:di 指向一个地址范围描述结构 ARDS(Address Range Descriptor Structure), BIOS将会填充此结构。</li>
<li>ecx  es:di所指向的地址范围描述结构的大小，以字节为单位。无论es:di所指向的结构如何设置，BIOS最多将会填充ecx字节。不过，通常情况下无论ecx为多大，BIOS只填充20字节，有些BIOS忽略ecx的值，总是填充20字节。  </li>
<li>edx  0534D4150h(‘SMAP’)——BIOS将会使用此标志，对调用者将要请求的系统映像信息进行校验，这些信息被BIOS放置到es:di所指向的结构中。  </li>
</ul>
<p>中断调用之后，结果存放于下列寄存器之中。  </p>
<ul>
<li>CF  CF=0表示没有错误，否则存在错误。  </li>
<li>eax   0534D4150h(‘SMAP’)  </li>
<li>es:di  返回的地址范围描述符结构指针，和输入值相同。  </li>
<li>ecx BIOS填充在地址范围描述符中的字节数量，被BIOS所返回的最小值是20字节。  </li>
<li>ebx  这里放置着为等到下一个地址描述符所需要的后续值，这个值得实际形势依赖于具体的BIOS的实现，调用者不必关心它的具体形式，自需在下一次迭代时将其原封不动地放置到ebx中，就可以通过它获取下一个地址范围描述符。如果它的值为0，并且CF没有进位，表示它是最后一个地址范围描述符。  </li>
</ul>
<p>由于一个物理页需要占用一个Page结构的空间，Page结构在设计时须尽可能小，以减少对内存的占用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span>                       <span class="comment">// 描述了一个Page</span></span><br><span class="line">    <span class="type">int</span> ref;                        <span class="comment">// 这一页被页表的引用计数，一个页表项设置了一个虚拟页的映射</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;                 <span class="comment">// 描述这个Page的状态，可能每个位表示不同的意思</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> property;          <span class="comment">// property表示这个块中空闲页的数量，用到此成员变量的这个Page比较特殊，</span></span><br><span class="line">                                    <span class="comment">// 是这个连续内存空闲块地址最小的一页（即头一页， Head Page）。</span></span><br><span class="line">    <span class="type">list_entry_t</span> page_link;         <span class="comment">// 链接比它地址小和大的其他连续内存空闲块。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>flag用到了两个bit<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PG_reserved       0       <span class="comment">// 表明了是否被保留，如果被保留，则bit 0会设置位1，且不能放到空闲列表里</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_property       1       <span class="comment">// bit 1表示此页是否是free的，如果设置为1，表示这页是free的，可以被分配；如果设置为0，表示这页已经被分配出去了，不能被再二次分配。</span></span></span><br></pre></td></tr></table></figure><br>总结来说：一个页，里边有各种属性和双向链表的指针段</p>
<ul>
<li>ref表示这个页被页表的引用记数，是映射此物理页的虚拟页个数。一旦某页表中有一个页表项设置了虚拟页到这个Page管理的物理页的映射关系，就会把Page的ref加一。反之，若是解除，那就减一。</li>
<li>flags表示此物理页的状态标记，有两个标志位，第一个表示是否被保留，如果被保留了则设为1（比如内核代码占用的空间）。第二个表示此页是否是free的。如果设置为1，表示这页是free的，可以被分配；如果设置为0，表示这页已经被分配出去了，不能被再二次分配。</li>
<li>property用来记录某连续内存空闲块的大小，这里需要注意的是用到此成员变量的这个Page一定是连续内存块的开始地址（第一页的地址）。</li>
<li>page_link是便于把多个连续内存空闲块链接在一起的双向链表指针，连续内存空闲块利用第一个页的成员变量page_link来链接比它地址小和大的其他连续内存空闲块，用到这个成员变量的是这个块的地址最小的一页。</li>
</ul>
<p>下面简单看看mm/pmm.c中的pmm_init()<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pmm_init - initialize the physical memory management */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> *<span class="title">memmap</span> =</span> (<span class="keyword">struct</span> e820map *)(<span class="number">0x8000</span> + KERNBASE);</span><br><span class="line">    <span class="type">uint64_t</span> maxpa = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">&quot;e820map:\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; memmap-&gt;nr_map; i ++) &#123;</span><br><span class="line">        <span class="type">uint64_t</span> begin = memmap-&gt;<span class="built_in">map</span>[i].addr, end = begin + memmap-&gt;<span class="built_in">map</span>[i].size;</span><br><span class="line">        cprintf(<span class="string">&quot;  memory: %08llx, [%08llx, %08llx], type = %d.\n&quot;</span>,</span><br><span class="line">                memmap-&gt;<span class="built_in">map</span>[i].size, begin, end - <span class="number">1</span>, memmap-&gt;<span class="built_in">map</span>[i].type);</span><br><span class="line">        <span class="keyword">if</span> (memmap-&gt;<span class="built_in">map</span>[i].type == E820_ARM) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxpa &lt; end &amp;&amp; begin &lt; KMEMSIZE) &#123;</span><br><span class="line">                maxpa = end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxpa &gt; KMEMSIZE) &#123;</span><br><span class="line">        maxpa = KMEMSIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">char</span> end[];</span><br><span class="line"></span><br><span class="line">    npage = maxpa / PGSIZE;</span><br><span class="line">    <span class="comment">//起始物理内存地址位0，所以需要管理的页个数为npage，需要管理的所有页的大小位sizeof(struct Page)*npage</span></span><br><span class="line">    pages = (<span class="keyword">struct</span> Page *)ROUNDUP((<span class="type">void</span> *)end, PGSIZE);</span><br><span class="line">    <span class="comment">// pages的地址，最末尾地址按照页大小取整。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npage; i ++) &#123;</span><br><span class="line">        SetPageReserved(pages + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前的这些页设置为已占用的</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uintptr_t</span> freemem = PADDR((<span class="type">uintptr_t</span>)pages + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page) * npage);</span><br><span class="line">    <span class="comment">// 之前设置了占用的页，那空闲的页就是从（pages+sizeof(struct Page)*npage）以上开始的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; memmap-&gt;nr_map; i ++) &#123;</span><br><span class="line">        <span class="type">uint64_t</span> begin = memmap-&gt;<span class="built_in">map</span>[i].addr, end = begin + memmap-&gt;<span class="built_in">map</span>[i].size;</span><br><span class="line">        <span class="keyword">if</span> (memmap-&gt;<span class="built_in">map</span>[i].type == E820_ARM) &#123;</span><br><span class="line">            <span class="keyword">if</span> (begin &lt; freemem) &#123;</span><br><span class="line">                begin = freemem;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (end &gt; KMEMSIZE) &#123;</span><br><span class="line">                end = KMEMSIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">                begin = ROUNDUP(begin, PGSIZE);</span><br><span class="line">                end = ROUNDDOWN(end, PGSIZE);</span><br><span class="line">                <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);</span><br><span class="line">                    <span class="comment">// 通过调用本函数进行空闲的标记</span></span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>SetPageReserved表示把物理地址对应的Page结构中的flags标志设置为PG_reserved ，表示这些页已经被使用了，将来不能被用于分配。而init_memmap函数把空闲物理页对应的Page结构中的flags和引用计数ref清零，并加到free_area.free_list指向的双向列表中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pmm_manager</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;                                 <span class="comment">//物理内存页管理器的名字</span></span><br><span class="line">    <span class="type">void</span> (*init)(<span class="type">void</span>);                               <span class="comment">//初始化内存管理器</span></span><br><span class="line">    <span class="type">void</span> (*init_memmap)(<span class="keyword">struct</span> Page *base, <span class="type">size_t</span> n); <span class="comment">//初始化管理空闲内存页的数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *(*<span class="title">alloc_pages</span>)(<span class="title">size_t</span> <span class="title">n</span>);</span>            <span class="comment">//分配n个物理内存页</span></span><br><span class="line">    <span class="type">void</span> (*free_pages)(<span class="keyword">struct</span> Page *base, <span class="type">size_t</span> n);  <span class="comment">//释放n个物理内存页</span></span><br><span class="line">    <span class="type">size_t</span> (*nr_free_pages)(<span class="type">void</span>);                    <span class="comment">//返回当前剩余的空闲页数</span></span><br><span class="line">    <span class="type">void</span> (*check)(<span class="type">void</span>);                              <span class="comment">//用于检测分配/释放实现是否正确</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">free_area_t</span> - 维护一个双向链表记录没有用到的Page。</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">list_entry_t</span> free_list;         <span class="comment">// 整个双向链表的头节点</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nr_free;           <span class="comment">// 表示空闲页的数量</span></span><br><span class="line">&#125; <span class="type">free_area_t</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> <span class="title">list_entry_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">类似Linux里的双向链表，这只是指针部分，数据部分在其他定义里</span><br></pre></td></tr></table></figure>
<h2 id="练习1-实现first-fit连续物理内存分配算法"><a href="#练习1-实现first-fit连续物理内存分配算法" class="headerlink" title="练习1 实现first-fit连续物理内存分配算法"></a>练习1 实现first-fit连续物理内存分配算法</h2><p>重写函数: default_init, default_init_memmap,default_alloc_pages, default_free_pages。<br>在实现first_fit的回收函数时，注意连续地址空间之间的合并操作。在遍历空闲页块链表时，需要按照空闲块起始地址来排序，形成一个有序的的链表。</p>
<p>首次适应算法（First Fit）：该算法从空闲分区链首开始查找，直至找到一个能满足其大小要求的空闲分区为止。然后再按照需求的大小，从该分区中划出一块内存分配给请求者，余下的空闲分区仍留在空闲分区链中。多使用内存中低地址部分的空闲区，在高地址部分的空闲区很少被利用，从而保留了高地址部分的空闲区。显然为以后到达的大作业分配大的内存空间创造了条件。但是低地址部分不断被划分，留下许多难以利用、很小的空闲区，每次查找又都从低地址部分开始，会增加查找的开销。  </p>
<p>在First Fit算法中，分配器维护一个空闲块列表（free表）。一旦收到内存分配请求，<br>它遍历列表找到第一个满足的块。如果所选块明显大于请求的块，则分开，其余的空间将被添加到列表中下一个free块中。</p>
<ul>
<li>准备：实现First Fit我们需要使用链表管理空闲块，free_area_t被用来管理free块，首先，找到list.h中的”struct list”。结构”list”是一个简单的双向链表实现。使用”list_init”，”list_add”（”list_add_after”和”list_add_before”），”list_del”，<br>“list_next”，”list_prev”。有一个棘手的方法是将一般的”list”结构转换为一个特殊结构（如struct”page”），使用以下宏：”le2page”（在memlayout.h中）。</li>
<li>“default_init”：重用例子中的”default_init”函数来初始化”free_list”并将”nr_free”设置为0。”free_list”用于记录空闲内存块，”nr_free”是可用内存块的总数。</li>
<li>“default_init_memmap”：调用栈为”kern_init” -&gt; “pmm_init” -&gt; “page_init” -&gt; “init_memmap” -&gt; “pmm_manager” -&gt; “init_memmap”。此函数用于初始化空闲块（使用参数”addr_base”，”page_mumber”）。为了初始化一个空闲块，首先，应该在这个空闲块中初始化每个页面（在memlayout.h中定义）。这个程序包括：<ul>
<li>设置”p -&gt; flags”的’PG_property’位，表示该页面为有效。在函数”pmm_init”（在pmm.c中），”p-&gt; flags”的位’PG_reserved”已经设置好了。</li>
<li>如果此页面是free的且不是free区块的第一页，”p-&gt; property”应该设置为0。</li>
<li>如果此页面是free的且是free区块的第一页，”p-&gt; property”应该设置为本空闲块的总页数。</li>
</ul>
</li>
<li>“default_alloc_pages”：在空闲列表中搜索第一个空闲块（块大小&gt;=n），返回该块的地址作为所需的地址.</li>
</ul>
<p>空闲页管理链表的初始化：把free_list的双向链表中的指针都指向自己，且计数器为0<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">default_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    list_init(&amp;free_list);</span><br><span class="line">    nr_free = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_init</span><span class="params">(<span class="type">list_entry_t</span> *elm)</span> &#123;</span><br><span class="line">    elm-&gt;prev = elm-&gt;next = elm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初始化空闲页链表，初始化每一个空闲页，然后计算空闲页的总数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">default_init_memmap</span><span class="params">(<span class="keyword">struct</span> Page *base, <span class="type">size_t</span> n)</span> &#123;   </span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> base;</span><br><span class="line">    <span class="keyword">for</span> (; p != base + n; p ++) &#123;</span><br><span class="line">        assert(PageReserved(p));</span><br><span class="line">        <span class="comment">//这个页是否为保留页,PageReserved(p)返回true才会继续，如果返回true了，说明是保留页</span></span><br><span class="line">        <span class="comment">//设置标志位</span></span><br><span class="line">        p-&gt;flags = <span class="number">0</span>；</span><br><span class="line">        SetPageProperty(p);</span><br><span class="line">        p-&gt;property = <span class="number">0</span>;    <span class="comment">//应该只有第一个页的这个参数有用</span></span><br><span class="line">        set_page_ref(p, <span class="number">0</span>);<span class="comment">//清空引用，现在是没有虚拟内存引用它的</span></span><br><span class="line">        list_add_before(&amp;free_list, &amp;(p-&gt;page_link));<span class="comment">//插入空闲页的链表里面</span></span><br><span class="line">    &#125;</span><br><span class="line">    nr_free += n;  <span class="comment">//连续有n个空闲块，空闲链表的个数加n</span></span><br><span class="line">    base-&gt;property=n; <span class="comment">//连续内存空闲块的大小为n，属于物理页管理链表</span></span><br><span class="line">    <span class="comment">//所有的页都在这个双向链表里且只有第0个页有这个块的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>default_alloc_pages从空闲页链表中查找n个空闲页，如果成功，返回第一个页表的地址。遍历空闲链表，一旦发现有大于等于n的连续空闲页块，便将这n个页从空闲页链表中取出，同时使用SetPageReserved和ClearPageProperty表示该页为使用状态，同时如果该连续页的数目大于n，则从第n+1开始截断，之后为截断的块，重新计算相应的property的值。在贴代码之前先说说几个宏。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将这个le转换成一个Page */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> le2page(le, member)                 \</span></span><br><span class="line"><span class="meta">    to_struct((le), struct Page, member)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * to_struct - get the struct from a ptr</span></span><br><span class="line"><span class="comment"> * @ptr:    a struct pointer of member</span></span><br><span class="line"><span class="comment"> * @type:   the type of the struct this is embedded in</span></span><br><span class="line"><span class="comment"> * @member: the name of the member within the struct</span></span><br><span class="line"><span class="comment"> * 一般用的时候传进来的type是Page类型的，ptr是这个（Page+双向链表的两个指针）块的双向链表指针的开始地址。offsetof算出了page_link在Page中的偏移值，ptr减去双向链表第一个指针的偏移量得到了这个Page的地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> to_struct(ptr, type, member)                               \</span></span><br><span class="line"><span class="meta">    ((type *)((char *)(ptr) - offsetof(type, member)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the offset of &#x27;member&#x27; relative to the beginning of a struct type */</span></span><br><span class="line"><span class="number">0</span>不代表具体地址，这个offsetof代表这个member在这个type中的偏移值</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(type, member)                                      \</span></span><br><span class="line"><span class="meta">    ((size_t)(&amp;((type *)0)-&gt;member))</span></span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> Page * <span class="title function_">default_alloc_pages</span><span class="params">(<span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; nr_free) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n 一定要大于0，且n要小于当前可用的空闲块数</span></span><br><span class="line">    <span class="type">list_entry_t</span> *le, *len;</span><br><span class="line">    le = &amp;free_list;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>=</span><span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>((le=list_next(le)) != &amp;free_list) &#123;</span><br><span class="line">        p = le2page(le, page_link);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;property&gt;=n)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在free_list里遍历每一页，用le2page转换成Page</span></span><br><span class="line">    <span class="comment">//如果找到了一个property大于n的就说明找到了这个符合要求的块</span></span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            len = list_next(le);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span> =</span> le2page(le, page_link);</span><br><span class="line">            SetPageReserved(pp);</span><br><span class="line">            ClearPageProperty(pp);</span><br><span class="line">            list_del(le);</span><br><span class="line">            le = len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果我现在找到的块是大于n的，那就拆开</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;property&gt;n)&#123;</span><br><span class="line">            (le2page(le,page_link))-&gt;property = p-&gt;property - n;</span><br><span class="line">        &#125;</span><br><span class="line">        ClearPageProperty(p);</span><br><span class="line">        SetPageReserved(p);</span><br><span class="line">        nr_free -= n;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>default_free_pages将base为起始地址的n个页面放回到free_list中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">default_free_pages</span><span class="params">(<span class="keyword">struct</span> Page *base, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">list_entry_t</span> *le = &amp;free_list;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> base;</span><br><span class="line">    <span class="comment">//找到比base大的页面地址</span></span><br><span class="line">    <span class="keyword">while</span>((le=list_next(le)) != &amp;free_list)&#123;</span><br><span class="line">        p = le2page(le,page_link);</span><br><span class="line">        <span class="keyword">if</span>(p &gt; base)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在找到的p之前逐个插入</span></span><br><span class="line">    <span class="keyword">for</span>(p = base; p &lt; base + n; p ++)&#123;</span><br><span class="line">       list_add_before(le,&amp;(p-&gt;page_link));</span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;flags=<span class="number">0</span>;</span><br><span class="line">    set_page_ref(base,<span class="number">0</span>);</span><br><span class="line">    ClearPageProperty(base);</span><br><span class="line">    SetPageProperty(base);</span><br><span class="line">    base-&gt;property = n;</span><br><span class="line">    <span class="comment">// 清空flag的信息，清空引用的信息，清空property信息，设置这个Page又是可以被引用的了</span></span><br><span class="line">    <span class="comment">// 当前的base又是n个空闲块的头</span></span><br><span class="line">    p = le2page(le,page_link);</span><br><span class="line">    <span class="keyword">if</span>(base+n==p)&#123;</span><br><span class="line">        base-&gt;property+=p-&gt;property;</span><br><span class="line">        p-&gt;property=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//看是不是可以跟后边的块恰好连在一起，如果连在一起的话就可以合并了</span></span><br><span class="line">    le=list_prev(&amp;(base-&gt;page_link));</span><br><span class="line">    p = le2page(le, page_link);</span><br><span class="line">    <span class="comment">//看是不是可以跟前边的连在一起，如果可以的话这个base就可以把property设成0了</span></span><br><span class="line">    <span class="keyword">if</span>(le!=&amp;free_list &amp;&amp; p==base<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(le!=&amp;free_list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;property)&#123;</span><br><span class="line">                p-&gt;property+=base-&gt;property;</span><br><span class="line">                base-&gt;property=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            le = list_prev(le);</span><br><span class="line">            p=le2page(le,page_link);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nr_free +=n;</span><br><span class="line">    cprintf(<span class="string">&quot;release %d page,last %d.\n&quot;</span>,n,nr_free);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行中出现提示，表明本题成功：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">release 1 page,last 1.</span><br><span class="line">release 1 page,last 2.</span><br><span class="line">release 1 page,last 3.</span><br><span class="line">release 1 page,last 1.</span><br><span class="line">release 1 page,last 32291.</span><br><span class="line">release 1 page,last 32292.</span><br><span class="line">release 1 page,last 32293.</span><br><span class="line">release 3 page,last 3.</span><br><span class="line">release 1 page,last 1.</span><br><span class="line">release 3 page,last 4.</span><br><span class="line">release 1 page,last 4.</span><br><span class="line">release 2 page,last 4.</span><br><span class="line">release 1 page,last 5.</span><br><span class="line">release 5 page,last 32293.</span><br><span class="line">check_alloc_page() succeeded!</span><br></pre></td></tr></table></figure><br>first_fit有一种改进，next_fit，第一次找到之后不暂停，第二次找到之后才真正给分配空间。修改比较简单，第一次找到之后记一个flag，下次再找到就可以分配了。</p>
<h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><h3 id="系统执行中的地址映射。"><a href="#系统执行中的地址映射。" class="headerlink" title="系统执行中的地址映射。"></a>系统执行中的地址映射。</h3><p>mooc中讲到了在段页式管理机制下运行这整个过程中，虚拟地址到物理地址的映射产生了多次变化，实现了最终的段页式映射关系：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virt addr = linear addr = phy addr + 0xC0000000  </span><br></pre></td></tr></table></figure></p>
<p>第一个阶段（<strong>开启保护模式，创建启动段表</strong>）是bootloader阶段，即从bootloader的start函数（在boot/bootasm.S中）到执行ucore kernel的kern_entry函数之前，其虚拟地址、线性地址以及物理地址之间的映射关系与lab1的一样，即：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virt addr = linear addr = phy addr  </span><br></pre></td></tr></table></figure></p>
<p>第二个阶段（<strong>创建初始页目录表，开启分页模式</strong>）从kern_entry函数开始，到pmm_init函数被执行之前。通过几条汇编指令（在kern/init/entry.S中）使能分页机制，主要做了两件事：</p>
<ul>
<li>通过movl %eax, %cr3指令把页目录表的起始地址存入CR3寄存器中；</li>
<li>通过movl %eax, %cr0指令把cr0中的CR0_PG标志位设置上。</li>
</ul>
<p>在此之后，进入了分页机制，地址映射关系如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">virt addr = linear addr = phy addr # 线性地址在0~4MB之内三者的映射关系</span><br><span class="line">virt addr = linear addr = phy addr + 0xC0000000 # 线性地址在0xC0000000~0xC0000000+4MB之内三者的映射关系</span><br></pre></td></tr></table></figure><br>仅仅比第一个阶段增加了下面一行的0xC0000000偏移的映射，并且作用范围缩小到了0~4M。在下一个节点，会将作用范围继续扩充到0~KMEMSIZE。<br>此时的内核（EIP）还在0~4M的低虚拟地址区域运行，而在之后，这个区域的虚拟内存是要给用户程序使用的。为此，需要使用一个绝对跳转来使内核跳转到高虚拟地址（代码在kern/init/entry.S中）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    # update eip</span><br><span class="line">    # now, eip = 0x1.....</span><br><span class="line">    leal next, %eax</span><br><span class="line">    # set eip = KERNBASE + 0x1.....</span><br><span class="line">    jmp *%eax</span><br><span class="line">next:</span><br></pre></td></tr></table></figure><br>跳转完毕后，通过把boot_pgdir[0]对应的第一个页目录表项（0~4MB）清零来取消了临时的页映射关系：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># unmap va 0 ~ 4M, it&#x27;s temporary mapping</span><br><span class="line">xorl %eax, %eax</span><br><span class="line">movl %eax, __boot_pgdir</span><br></pre></td></tr></table></figure><br>最终的地址映射关系如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lab2 stage 2: virt addr = linear addr = phy addr + 0xC0000000 # 线性地址在0~4MB之内三者的映射关系</span><br></pre></td></tr></table></figure><br>第三个阶段（<strong>完善段表和页表</strong>）从pmm_init函数被调用开始。pmm_init函数将页目录表项补充完成（从0~4M扩充到0~KMEMSIZE）。然后，更新了段映射机制，使用了一个新的段表。这个新段表除了包括内核态的代码段和数据段描述符，还包括用户态的代码段和数据段描述符以及TSS（段）的描述符。理论上可以在第一个阶段，即bootloader阶段就将段表设置完全，然后在此阶段继续使用，但这会导致内核的代码和bootloader的代码产生过多的耦合，于是就有了目前的设计。<br>这时形成了我们期望的虚拟地址、线性地址以及物理地址之间的映射关系：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lab2 stage 3: virt addr = linear addr = phy addr + 0xC0000000</span><br></pre></td></tr></table></figure></p>
<p>请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。</p>
<p>页目录项（Pag Director Entry）每一位的含义：</p>
<ul>
<li>前20位表示4K对齐的该PDE对应的页表起始位置（物理地址，该物理地址的高20位即PDE中的高20位，低12位为0）；</li>
<li>第9-11位未被CPU使用，可保留给OS使用；</li>
<li>接下来的第8位可忽略；</li>
<li>第7位用于设置Page大小，0表示4KB；</li>
<li>第6位恒为0；</li>
<li>第5位用于表示该页是否被使用过；</li>
<li>第4位设置为1则表示不对该页进行缓存；</li>
<li>第3位设置是否使用write through缓存写策略；</li>
<li>第2位表示该页的访问需要的特权级；</li>
<li>第1位表示是否允许读写；</li>
<li>第0位为该PDE的存在位；</li>
</ul>
<p>页表项（PTE）中的每项的含义：</p>
<ul>
<li>高20位与PDE相似的，用于表示该PTE指向的物理页的物理地址；</li>
<li>9-11位保留给OS使用；</li>
<li>7-8位恒为0；</li>
<li>第6位表示该页是否为dirty，即是否需要在swap out的时候写回外存；</li>
<li>第5位表示是否被访问；</li>
<li>3-4位恒为0；</li>
<li>0-2位分别表示存在位、是否允许读写、访问该页需要的特权级；</li>
</ul>
<p>PTE和PDE都有一些保留位供操作系统使用，ucore利用保留位来完成一些其他的内存管理相关的算法。</p>
<p>当ucore执行过程中出现了页访问异常，硬件需要完成的事情分别如下：</p>
<ul>
<li>将发生错误的线性地址保存在cr2寄存器中;</li>
<li>在中断栈中依次压入EFLAGS，CS, EIP，以及页访问异常码error code，如果pgfault是发生在用户态，则还需要先压入ss和esp，并且切换到内核栈；</li>
<li>根据中断描述符表查询到对应page fault的处理例程地址如后，跳转到对应处执行。</li>
</ul>
<h3 id="建立虚拟页和物理页帧的地址映射关系"><a href="#建立虚拟页和物理页帧的地址映射关系" class="headerlink" title="建立虚拟页和物理页帧的地址映射关系"></a>建立虚拟页和物理页帧的地址映射关系</h3><p>整个页目录表和页表所占空间大小取决与二级页表要管理和映射的物理页数。<br>假定当前物理内存0~16MB，每物理页（也称Page Frame）大小为4KB，则有4096个物理页，也就意味这有4个页目录项和4096个页表项需要设置。一个页目录项（Page Directory Entry，PDE）和一个页表项（Page Table Entry，PTE）占4B。即使是4个页目录项也需要一个完整的页目录表（占4KB）。而4096个页表项需要16KB（即4096*4B）的空间，也就是4个物理页，16KB的空间。所以对16MB物理页建立一一映射的16MB虚拟页，需要4+1=5个物理页，即20KB的空间来形成二级页表。  </p>
<p>把0~KERNSIZE（明确ucore设定实际物理内存<strong>不能超过KERNSIZE值，即0x38000000字节，896MB，3670016个物理页</strong>）的物理地址一一映射到页目录项和页表项的内容，其大致流程如下：</p>
<ol>
<li>指向页目录表的指针已存储在boot_pgdir变量中。</li>
<li>映射0~4MB的首个页表已经填充好。</li>
<li>调用boot_map_segment函数进一步建立一一映射关系，具体处理过程以页为单位进行设置，即:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linear addr = phy addr + 0xC0000000</span><br></pre></td></tr></table></figure>
<p>设一个32bit线性地址la有一个对应的32bit物理地址pa，如果在以la的高10位为索引值的页目录项中的存在位（PTE_P）为0，表示缺少对应的页表空间，则可通过alloc_page获得一个空闲物理页给页表，页表起始物理地址是按4096字节对齐的，这样填写页目录项的内容为：</p>
<blockquote>
<p>页目录项内容 = (页表起始物理地址 &amp; ~0x0FFF) | PTE_U | PTE_W | PTE_P</p>
</blockquote>
<p>进一步对于页表中以线性地址la的中10位为索引值对应页表项的内容为：</p>
<blockquote>
<p>页表项内容 = (pa &amp; ~0x0FFF) | PTE_P | PTE_W</p>
</blockquote>
<p>其中：</p>
<blockquote>
<p>PTE_U：位3，表示用户态的软件可以读取对应地址的物理内存页内容<br>PTE_W：位2，表示物理内存页内容可写<br>PTE_P：位1，表示物理内存页存在  </p>
</blockquote>
<p>ucore的内存管理经常需要查找页表：<br>给定一个虚拟地址，找出这个虚拟地址在二级页表中对应的项。通过更改此项的值可以方便地将虚拟地址映射到另外的页上。可完成此功能的这个函数是get_pte函数。它的原型为<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pte_t *get_pte(pde_t *pgdir, uintptr_t la, bool create)</span><br></pre></td></tr></table></figure></p>
<p>这里涉及到三个类型<strong>pte_t</strong>、<strong>pde_t</strong>和<strong>uintptr_t</strong>。这三个都是unsigned int类型。  </p>
<ul>
<li>pde_t：page directory entry，一级页表的表项。  </li>
<li>pte_t：page table entry，表示二级页表的表项。  </li>
<li>uintptr_t：表示为线性地址，由于段式管理只做直接映射，所以它也是逻辑地址。  </li>
<li>pgdir：给出页表起始地址。通过查找这个页表，我们需要给出二级页表中对应项的地址。  </li>
</ul>
<p>可以在需要时再添加对应的二级页表。如果在查找二级页表项时，发现对应的二级页表不存在，则需要<strong>根据create参数的值来处理是否创建新的二级页表</strong>。如果create参数为0，则get_pte返回NULL；如果create参数不为0，则get_pte需要申请一个新的物理页（通过alloc_page来实现，可在mm/pmm.h中找到它的定义），再在一级页表中添加页目录项指向表示二级页表的新物理页。  </p>
<blockquote>
<p>注意，新申请的页必须全部设定为零，因为这个页所代表的虚拟地址都没有被映射。  </p>
</blockquote>
<p>当建立从一级页表到二级页表的映射时，需要注意设置控制位。这里应该设置同时设置上PTE_U、PTE_W和PTE_P（定义可在mm/mmu.h）。如果原来就有二级页表，或者新建立了页表，则只需返回对应项的地址即可。  </p>
<p>虚拟地址只有映射上了物理页才可以正常的读写。在完成映射物理页的过程中，除了要在页表的对应表项上填上相应的物理地址外，还要设置正确的控制位。  </p>
<p>只有当一级二级页表的项都设置了用户写权限后，用户才能对对应的物理地址进行读写。由于一个物理页可能被映射到不同的虚拟地址上去（譬如一块内存在不同进程间共享），<strong>当这个页需要在一个地址上解除映射时，操作系统不能直接把这个页回收，而是要先看看它还有没有映射到别的虚拟地址上</strong>。这是通过查找管理该物理页的Page数据结构的成员变量ref（用来表示虚拟页到物理页的映射关系的个数）来实现的，如果ref为0了，表示没有虚拟页到物理页的映射关系了，就可以把这个物理页给回收了，从而这个物理页是free的了，可以再被分配。  </p>
<p>page_insert函数将物理页映射在了页表上。可参看page_insert函数的实现来了解ucore内核是如何维护这个变量的。当不需要再访问这块虚拟地址时，可以把这块物理页回收并在将来用在其他地方。取消映射由page_remove来做，这其实是page_insert的逆操作。<br>建立好一一映射的二级页表结构后，由于分页机制在前一节所述的前两个阶段已经开启，分页机制到此初始化完毕。当执行完毕gdt_init函数后，新的段页式映射已经建立好了。</p>
<p>预备知识copy完了，上练习二和练习三</p>
<h3 id="练习二代码"><a href="#练习二代码" class="headerlink" title="练习二代码"></a>练习二代码</h3><p><strong>预备知识不够用了</strong><br>上mmu.h的代码读读<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">A linear address &#x27;la&#x27; has a three-part structure as follows:</span><br><span class="line">+--------10------+-------10-------+---------12----------+</span><br><span class="line">| Page Directory |   Page Table   | Offset within Page  |</span><br><span class="line">|      Index     |     Index      |                     |</span><br><span class="line">+----------------+----------------+---------------------+</span><br><span class="line"> \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/</span><br><span class="line"> \----------- PPN(la) -----------/</span><br><span class="line">The PDX, PTX, PGOFF, and PPN macros decompose linear addresses as shown.</span><br><span class="line">To construct a linear address la from PDX(la), PTX(la), and PGOFF(la),</span><br><span class="line">use PGADDR(PDX(la), PTX(la), PGOFF(la)).</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get_pte - get Page Table Entry and return the kernel virtual address of this Page Table Entry for la</span></span><br><span class="line"><span class="comment">//        - if the PT contians this Page Table Entry didn&#x27;t exist, alloc a page for PT</span></span><br><span class="line"><span class="comment">// parameter:</span></span><br><span class="line"><span class="comment">//  pgdir:  the kernel virtual base address of PDT （页目录表的入口）</span></span><br><span class="line"><span class="comment">//  la:     the linear address need to map         （线性地址）</span></span><br><span class="line"><span class="comment">//  create: a logical value to decide if alloc a page for PT</span></span><br><span class="line"><span class="comment">// return vaule: the kernel virtual address of this pte （返回这个页表项的虚拟地址）</span></span><br><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">get_pte</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> la, <span class="type">bool</span> create)</span> &#123;</span><br><span class="line"><span class="comment">/*   *   使用KADDR()获得物理地址</span></span><br><span class="line"><span class="comment">     *   PDX(la) = 虚拟地址la在page directory entry 的 index</span></span><br><span class="line"><span class="comment">     *   KADDR(pa) : takes a physical address and returns the corresponding kernel virtual address.</span></span><br><span class="line"><span class="comment">     *   set_page_ref(page,1) : means the page be referenced by one time，这一页被引用了</span></span><br><span class="line"><span class="comment">     *   page2pa(page): get the physical address of memory which this (struct Page *) page manages</span></span><br><span class="line"><span class="comment">     *                  得到这个页管理的内存的物理地址</span></span><br><span class="line"><span class="comment">     *   struct Page * alloc_page() : allocation a page</span></span><br><span class="line"><span class="comment">     *   memset(void *s, char c, size_t n) : sets the first n bytes of the memory area pointed by s</span></span><br><span class="line"><span class="comment">     *                                       to the specified value c.</span></span><br><span class="line"><span class="comment">     * DEFINEs:</span></span><br><span class="line"><span class="comment">     *   PTE_P           0x001                   // page table/directory entry flags bit : Present</span></span><br><span class="line"><span class="comment">     *   PTE_W           0x002                   // page table/directory entry flags bit : Writeable</span></span><br><span class="line"><span class="comment">     *   PTE_U           0x004                   // page table/directory entry flags bit : User can access</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pde_t</span> *pdep = &amp;pgdir[PDX(la)];       <span class="comment">// (1) find page directory entry</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!(*pdep &amp; PTE_P) ) &#123;             <span class="comment">// (2) check if entry is not present</span></span><br><span class="line">        <span class="keyword">if</span> (!create || (page = alloc_page()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     	&#125;	                             <span class="comment">// (3) check if creating is needed, then alloc page for page table</span></span><br><span class="line">        <span class="comment">// CAUTION: this page is used for page table, not for common data page</span></span><br><span class="line">        set_page_ref(page, <span class="number">1</span>);           <span class="comment">// (4) set page reference</span></span><br><span class="line">        <span class="type">uintptr_t</span> pa = page2pa(page);    <span class="comment">// (5) get linear address of page</span></span><br><span class="line">        <span class="built_in">memset</span>(KADDR(pa),<span class="number">0</span>,PGSIZE);      <span class="comment">// (6) clear page content using memset</span></span><br><span class="line">        *pdep = pa | PTE_U | PTE_W | PTE_P;<span class="comment">// (7) set page directory entry&#x27;s permission</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;((<span class="type">pte_t</span> *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];  <span class="comment">// (8) return page table entry</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习三"><a href="#练习三" class="headerlink" title="练习三"></a>练习三</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//page_remove_pte - free an Page sturct which is related linear address la</span><br><span class="line">//                - and clean(invalidate) pte which is related linear address la</span><br><span class="line">//note: PT is changed, so the TLB need to be invalidate</span><br><span class="line">static inline void</span><br><span class="line">page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep) &#123;</span><br><span class="line">    /* LAB2 EXERCISE 3: YOUR CODE</span><br><span class="line">     *</span><br><span class="line">     * Please check if ptep is valid, and tlb must be manually updated if mapping is updated</span><br><span class="line">     *</span><br><span class="line">     * Maybe you want help comment, BELOW comments can help you finish the code</span><br><span class="line">     *</span><br><span class="line">     * Some Useful MACROs and DEFINEs, you can use them in below implementation.</span><br><span class="line">     * MACROs or Functions:</span><br><span class="line">     *   struct Page *page pte2page(*ptep): get the according page from the value of a ptep</span><br><span class="line">     *   free_page : free a page</span><br><span class="line">     *   page_ref_dec(page) : decrease page-&gt;ref. NOTICE: ff page-&gt;ref == 0 , then this page should be free.</span><br><span class="line">     *   tlb_invalidate(pde_t *pgdir, uintptr_t la) : Invalidate a TLB entry, but only if the page tables being</span><br><span class="line">     *                        edited are the ones currently in use by the processor.</span><br><span class="line">     * DEFINEs:</span><br><span class="line">     *   PTE_P           0x001                   // page table/directory entry flags bit : Present</span><br><span class="line">     */</span><br><span class="line">#if 0</span><br><span class="line">    if (0) &#123;                      //(1) check if this page table entry is present</span><br><span class="line">        struct Page *page = NULL; //(2) find corresponding page to pte</span><br><span class="line">                                  //(3) decrease page reference</span><br><span class="line">                                  //(4) and free this page when page reference reachs 0</span><br><span class="line">                                  //(5) clear second page table entry</span><br><span class="line">                                  //(6) flush tlb</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    if (*ptep &amp; PTE_P) &#123; // 确保传进来的二级页表时可用的</span><br><span class="line">        struct Page *page = pte2page(*ptep);// 获取页表项对应的物理页的Page结构</span><br><span class="line">        if (page_ref_dec(page) == 0) &#123;	    // page_ref_dec被用于page-&gt;ref自减1，</span><br><span class="line">        									// 如果返回值是0，那么就说明不存在任何虚拟页指向该物理页，释放该物理页</span><br><span class="line">            free_page(page);</span><br><span class="line">        &#125;</span><br><span class="line">        *ptep = 0;					 // 将PTE的映射关系清空</span><br><span class="line">        tlb_invalidate(pgdir, la);   // 刷新TLB，确保TLB的缓存中不会有错误的映射关系</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？</span><br><span class="line"></span><br><span class="line">存在对应关系：由于页表项中存放着对应的物理页的物理地址，因此可以通过这个物理地址来获取到对应到的Page数组的对应项，具体做法为将物理地址除以一个页的大小，然后乘上一个Page结构的大小获得偏移量，使用偏移量加上Page数组的基地址皆可以或得到对应Page项的地址；</span><br><span class="line"></span><br><span class="line">如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？ 鼓励通过编程来具体完成这个问题。</span><br><span class="line"></span><br><span class="line">由于在完全启动了ucore之后，虚拟地址和线性地址相等，都等于物理地址加上0xc0000000，如果需要虚拟地址和物理地址相等，可以考虑更新gdt，更新段映射，使得virtual address = linear address - 0xc0000000，这样的话就可以实现virtual address = physical address；</span><br><span class="line">reference：https://www.jianshu.com/p/abbe81dfe016</span><br></pre></td></tr></table></figure></p>
<h1 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>在实验二的基础上，借助页表机制和实验一中涉及的中断异常处理机制，完成Pgfault异常处理和FIFO页替换算法的实现，结合磁盘提供的缓存空间，从而能够支持虚存管理，提供一个比实际物理内存空间“更大”的虚拟内存空间给系统使用。<br>这个实验与实际操作系统中的实现比较起来要简单，不过需要了解实验一和实验二的具体实现。实际操作系统系统中的虚拟内存管理设计与实现是相当复杂的，涉及到与进程管理系统、文件系统等的交叉访问。</p>
<h2 id="简单原理"><a href="#简单原理" class="headerlink" title="简单原理"></a>简单原理</h2><blockquote>
<p>copy from gitbook<br>通过内存地址虚拟化，可以使得软件在没有访问某虚拟内存地址时不分配具体的物理内存，而只有在实际访问某虚拟内存地址时，操作系统再动态地分配物理内存，建立虚拟内存到物理内存的页映射关系，这种技术称为按需分页（demand paging）。  </p>
<p>把不经常访问的数据所占的内存空间临时写到硬盘上，这样可以腾出更多的空闲内存空间给经常访问的数据；当CPU访问到不经常访问的数据时，再把这些数据从硬盘读入到内存中，这种技术称为页换入换出（page swap in/out）。这种内存管理技术给了程序员更大的内存“空间”，从而可以让更多的程序在内存中并发运行。</p>
</blockquote>
<p>参考ucore总控函数kern_init的代码，在调用完成虚拟内存初始化的vmm_init函数之前，需要首先调用pmm_init函数完成物理内存的管理，调用pic_init函数完成中断控制器的初始化，调用idt_init函数完成中断描述符表的初始化。  </p>
<p>在调用完idt_init函数之后，将进一步调用新函数<strong>vmm_init、ide_init、swap_init</strong>。  </p>
<p>do_pgfault函数会申请一个空闲物理页，并建立好虚实映射关系，从而使得这样的“合法”虚拟页有实际的物理页帧对应。  </p>
<p>ide_init就是完成对用于页换入换出的硬盘（简称swap硬盘）的初始化工作。完成ide_init函数后，ucore就可以对这个swap硬盘进行读写操作了。</p>
<p>vmm设计包括两部分：mm_struct（mm）和vma_struct（vma）。mm是具有相同PDT的连续虚拟内存区域集的内存管理器。 vma是一个连续的虚拟内存区域。 vma中存在线性链接列表，mm的vma的redblack链接列表。（redblack是啥？）</p>
<p>建立mm_struct和vma_struct数据结构。当访问内存产生pagefault异常时，可获得访问的内存的方式（读或写）以及具体的虚拟内存地址，这样ucore就可以查询此地址，看是否属于vma_struct数据结构中描述的合法地址范围中，如果在，则可根据具体情况进行请求调页/页换入换出处理；如果不在，则报错。</p>
<p>两种数据结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 链接所有属于同一页目录表的虚拟内存空间</span></span><br><span class="line">    <span class="type">list_entry_t</span> mmap_list;</span><br><span class="line">    <span class="comment">// 指向当前正在使用的虚拟内存空间，直接使用这个指针就能找到下一次要用到的虚拟空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">mmap_cache</span>;</span></span><br><span class="line">    <span class="type">pde_t</span> *pgdir; <span class="comment">// 第一级页表的起始地址，即页目录表项PDT。通过访问pgdir可以查找某虚拟地址对应的页表项是否存在以及页表项的属性等</span></span><br><span class="line">    <span class="type">int</span> map_count; <span class="comment">// 记录了链接了的vma_struct个数，共享了几次</span></span><br><span class="line">    <span class="type">void</span> *sm_priv; <span class="comment">// 指向记录页访问情况的链表头。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">// 描述应用程序对虚拟内存“需求”</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span> <span class="comment">// 指向更高抽象层次的数据结构</span></span><br><span class="line">    <span class="comment">// the set of vma using the same PDT</span></span><br><span class="line">    <span class="type">uintptr_t</span> vm_start; <span class="comment">// 连续地址虚拟内存空间的起始位置</span></span><br><span class="line">    <span class="type">uintptr_t</span> vm_end; <span class="comment">// 连续地址虚拟内存空间的结束位置</span></span><br><span class="line">    <span class="type">uint32_t</span> vm_flags; <span class="comment">// 标志属性（读/写/执行）</span></span><br><span class="line">    <span class="comment">//link将一系列虚拟内存空间连接起来</span></span><br><span class="line">    <span class="type">list_entry_t</span> list_link;</span><br><span class="line">&#125;;</span><br><span class="line">vm_flags：</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VM_READ 0x00000001 <span class="comment">//只读</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VM_WRITE 0x00000002 <span class="comment">//可读写</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VM_EXEC 0x00000004 <span class="comment">//可执行</span></span></span><br></pre></td></tr></table></figure></p>
<p>具体函数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// mm_create -  alloc a mm_struct &amp; initialize it.</span><br><span class="line">struct mm_struct * mm_create(void) &#123;</span><br><span class="line">    struct mm_struct *mm = kmalloc(sizeof(struct mm_struct));</span><br><span class="line">    if (mm != NULL) &#123;</span><br><span class="line">        list_init(&amp;(mm-&gt;mmap_list));</span><br><span class="line">        mm-&gt;mmap_cache = NULL;</span><br><span class="line">        mm-&gt;pgdir = NULL;</span><br><span class="line">        mm-&gt;map_count = 0;</span><br><span class="line"></span><br><span class="line">        if (swap_init_ok) swap_init_mm(mm);</span><br><span class="line">        else mm-&gt;sm_priv = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return mm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// mm_destroy - free mm and mm internal fields</span><br><span class="line">void mm_destroy(struct mm_struct *mm) &#123;</span><br><span class="line">    list_entry_t *list = &amp;(mm-&gt;mmap_list), *le;</span><br><span class="line">    while ((le = list_next(list)) != list) &#123;</span><br><span class="line">        list_del(le);</span><br><span class="line">        kfree(le2vma(le, list_link),sizeof(struct vma_struct));  //kfree vma</span><br><span class="line">    &#125;</span><br><span class="line">    kfree(mm, sizeof(struct mm_struct)); //kfree mm</span><br><span class="line">    mm=NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>设备驱动程序或者内核模块中动态开辟内存，不是用malloc，而是kmalloc ,vmalloc，<br>释放内存用的是kfree,vfree，kmalloc函数返回的是虚拟地址(线性地址)。</p>
<p>kmalloc特殊之处在于它分配的内存是物理上连续的,这对于要进行DMA的设备十分重要。<br>而用vmalloc分配的内存只是线性地址连续,物理地址不一定连续,不能直接用于DMA。vmalloc函数的工作方式类似于kmalloc，只不过前者分配的内存虚拟地址是连续的，而物理地址则无需连续。</p>
<p>通过vmalloc获得的页必须一个一个地进行映射，效率不高， 因此，只在不得已(一般是为了获得大块内存)时使用。vmalloc函数返回一个指针，指向逻辑上连续的一块内存区，其大小至少为size。在发生错误 时，函数返回NULL。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// vma_create - 新建一个vma_struct并且初始化(地址范围： vm_start~vm_end)</span><br><span class="line">struct vma_struct * vma_create(uintptr_t vm_start, uintptr_t vm_end, uint32_t vm_flags) &#123;</span><br><span class="line">    struct vma_struct *vma = kmalloc(sizeof(struct vma_struct));</span><br><span class="line"></span><br><span class="line">    if (vma != NULL) &#123;</span><br><span class="line">        vma-&gt;vm_start = vm_start;</span><br><span class="line">        vma-&gt;vm_end = vm_end;</span><br><span class="line">        vma-&gt;vm_flags = vm_flags;</span><br><span class="line">    &#125;</span><br><span class="line">    return vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Page-Fault异常处理"><a href="#Page-Fault异常处理" class="headerlink" title="Page Fault异常处理"></a>Page Fault异常处理</h2><p>处理该异常主要用do_pgfault函数，当启动分页机制以后，如果一条指令或数据的虚拟地址所对应的物理页框不在内存中或者访问的类型有错误（比如写一个只读页或用户态程序访问内核态的数据等），就会发生页访问异常。产生页访问异常的原因主要有：</p>
<blockquote>
<p>目标页帧不存在（页表项全为0，即该线性地址与物理地址尚未建立映射或者已经撤销)；<br>相应的物理页帧不在内存中（页表项非空，但Present标志位=0，比如在swap分区或磁盘文件上)；<br>不满足访问权限（此时页表项P标志=1，但低权限的程序试图访问高权限的地址空间，或者有程序试图写只读页面）。</p>
</blockquote>
<p>当出现上面情况之一，那么就会产生页面page fault（#PF）异常。CPU会把产生异常的线性地址存储在CR2中，并且把表示页访问异常类型的值（简称页访问异常错误码，errorCode）保存在中断栈中。CR2是页故障线性地址寄存器，保存最后一次出现页故障的全32位线性地址。CR2用于发生页异常时报告出错信息。产生页访问异常后，CPU把引起页访问异常的线性地址装到寄存器CR2中，并给出了出错码errorCode，说明了页访问异常的类型。操作系统中对应的中断服务例程可以检查CR2的内容，从而查出线性地址空间中的哪个页引起本次异常。</p>
<p>CPU在当前<strong>内核栈</strong>保存当前被打断的程序现场，即依次压入当前被打断程序使用的EFLAGS，CS，EIP，errorCode；由于页访问异常的中断号是0xE，CPU把异常中断号0xE对应的中断服务例程的地址（vectors.S中的标号vector14处）加载到CS和EIP寄存器中，开始执行中断服务例程。</p>
<p>这时ucore开始处理异常中断，首先需要保存硬件没有保存的寄存器。在vectors.S中的标号vector14处先把中断号压入内核栈，然后再在trapentry.S中的标号__alltraps处把DS、ES和其他通用寄存器都压栈。自此，被打断的程序执行现场（context）被保存在内核栈中。接下来，在trap.c的trap函数开始了中断服务例程的处理流程，大致调用关系为：</p>
<blockquote>
<p>trap —&gt; trap_dispatch —&gt; pgfault_handler —&gt; do_pgfault</p>
</blockquote>
<p>ucore中do_pgfault函数是完成页访问异常处理的主要函数，它根据从CPU的控制寄存器CR2中获取的页访问异常的物理地址以及根据errorCode的错误类型来查找此地址是否在某个VMA的地址范围内以及是否满足正确的读写权限，如果在此范围内并且权限也正确，这认为这是一次<strong>合法访问，但没有建立虚实对应关系</strong>。所以需要分配一个空闲的内存页，并修改页表完成虚地址到物理地址的映射，刷新TLB，然后调用iret产生软中断，返回到产生页访问异常的指令处重新执行此指令。如果该虚地址不在某VMA范围内，则认为是一次非法访问。</p>
<h2 id="页面置换机制的实现"><a href="#页面置换机制的实现" class="headerlink" title="页面置换机制的实现"></a>页面置换机制的实现</h2><p>当缺页中断发生时，操作系统把应用程序当前需要的数据或代码放到内存中来，然后重新执行应用程序产生异常的访存指令。如果在把硬盘中对应的数据或代码调入内存前，操作系统发现物理内存已经没有空闲空间了，这时操作系统必须把它认为“不常用”的页换出到磁盘上去，以腾出内存空闲空间给应用程序所需的数据或代码。 </p>
<ul>
<li><p>先进先出：选择在内存中驻留时间最久的页予以淘汰。将调入内存的页按照调入的先后顺序链接成一个队列，队列头指向内存中驻留时间最久的页，队列尾指向最近被调入内存的页。因为那些常被访问的页，往往在内存中也停留得最久，结果它们因变“老”而不得不被置换出去。FIFO算法的另一个缺点是，它有一种异常现象（Belady现象），即在增加放置页的页帧的情况下，反而使页访问异常次数增多。</p>
</li>
<li><p>时钟替换算法：是LRU算法的一种近似实现。时钟页替换算法把各个页面组织成环形链表的形式，类似于一个钟的表面。然后把一个指针（简称当前指针）指向最老的那个页面，即最先进来的那个页面。另外，时钟算法需要在页表项（PTE）中设置了一位访问位来表示此页表项对应的页当前是否被访问过。当该页被访问时，CPU中的MMU硬件将把访问位置“1”。当操作系统需要淘汰页时，对当前指针指向的页所对应的页表项进行查询，如果访问位为“0”，则淘汰该页，如果该页被写过，则还要把它换出到硬盘上；如果访问位为“1”，则将该页表项的此位置“0”，继续访问下一个页。该算法近似地体现了LRU的思想，且易于实现，开销少，需要硬件支持来设置访问位。时钟页替换算法在本质上与FIFO算法是类似的，不同之处是在时钟页替换算法中跳过了访问位为1的页。</p>
</li>
<li><p>改进时钟页替换算法：在时钟置换算法中，淘汰一个页面时只考虑了页面是否被访问过，但在实际情况中，还应考虑被淘汰的页面是否被修改过。因为淘汰修改过的页面还需要写回硬盘，使得其置换代价大于未修改过的页面，所以<strong>优先淘汰没有修改的页</strong>，减少磁盘操作次数。改进的时钟置换算法除了<strong>考虑页面的访问情况，还需考虑页面的修改情况</strong>。即该算法不但希望淘汰的页面是最近未使用的页，而且还希望被淘汰的页是在主存驻留期间其页面内容未被修改过的。这需要为每一页的对应页表项内容中增加一位引用位和一位修改位。当该页被访问时，CPU中的MMU硬件将把访问位置“1”。当该页被“写”时，CPU中的MMU硬件将把修改位置“1”。这样这两位就存在四种可能的组合情况：（0，0）表示最近未被引用也未被修改，首先选择此页淘汰；（0，1）最近未被使用，但被修改，其次选择；（1，0）最近使用而未修改，再次选择；（1，1）最近使用且修改，最后选择。该算法与时钟算法相比，可进一步减少磁盘的I/O操作次数。</p>
</li>
</ul>
<h2 id="页面置换机制"><a href="#页面置换机制" class="headerlink" title="页面置换机制"></a>页面置换机制</h2><h3 id="可以被换出的页"><a href="#可以被换出的页" class="headerlink" title="可以被换出的页"></a>可以被换出的页</h3><p>只有映射到用户空间且被用户程序直接访问的页面才能被交换，被内核直接使用的内核空间的页面不能被换出！！！操作系统是执行的关键代码，需要保证运行的高效性和实时性，如果在操作系统执行过程中，发生了缺页现象，则操作系统不得不等很长时间（硬盘的访问速度比内存的访问速度慢2到3个数量级），这将导致整个系统运行低效。</p>
<p><strong>当一个Page Table Entry用来描述一般意义上的物理页时，它维护各种权限和映射关系，以及应该有PTE_P标记；但当它用来描述一个被置换出去的物理页时，它被用来维护该物理页与swap磁盘上扇区的映射关系，并且该PTE不应该由MMU将它解释成物理页映射(即没有 PTE_P 标记)</strong>。</p>
<p>与此同时对应的权限则交由mm_struct来维护，当对位于该页的内存地址进行访问的时候，必然导致 page fault，然后ucore能够根据 PTE 描述的swap项将相应的物理页重新建立起来，并根据虚存所描述的权限重新设置好 PTE 使得内存访问能够继续正常进行。</p>
<h3 id="虚存中的页与硬盘上的扇区之间的映射关系"><a href="#虚存中的页与硬盘上的扇区之间的映射关系" class="headerlink" title="虚存中的页与硬盘上的扇区之间的映射关系"></a>虚存中的页与硬盘上的扇区之间的映射关系</h3><p>一个页被换出到硬盘，则PTE最低位present位应该是0，表示虚实地址映射关系不存在，接下来7位为保留位，表示页帧号的24位地址用来表示在硬盘上的地址。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\-----------------------------  </span><br><span class="line">| offset     |       reserved       |       0       |  </span><br><span class="line">\-----------------------------  </span><br><span class="line">24 bits  &amp;nbsp;&amp;nbsp; 7 bits &amp;nbsp;&amp;nbsp; 1 bit  </span><br></pre></td></tr></table></figure></p>
<h3 id="执行换入换出的时机"><a href="#执行换入换出的时机" class="headerlink" title="执行换入换出的时机"></a>执行换入换出的时机</h3><p>当ucore或应用程序访问地址所在的页不在内存时，就会产生page fault异常，引起调用do_pgfault函数，此函数会判断产生访问异常的地址属于check_mm_struct某个vma表示的合法虚拟地址空间，且保存在硬盘swap文件中。</p>
<p>ucore目前大致有两种策略来实现换出操作，即<strong>积极换出策略</strong>和<strong>消极换出策略</strong>。积极换出策略是指操作系统周期性地（或在系统不忙的时候）主动把某些认为“不常用”的页换出到硬盘上，从而确保系统中总有一定数量的空闲页存在，这样当需要空闲页时，基本上能够及时满足需求；消极换出策略是指，只是当试图得到空闲页时，发现当前没有空闲的物理页可供分配，这时才开始查找“不常用”页面，并把一个或多个这样的页换出到硬盘上。</p>
<h3 id="页替换算法的数据结构设计"><a href="#页替换算法的数据结构设计" class="headerlink" title="页替换算法的数据结构设计"></a>页替换算法的数据结构设计</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span>  </span><br><span class="line">……   </span><br><span class="line"><span class="type">list_entry_t</span> pra_page_link;   </span><br><span class="line"><span class="type">uintptr_t</span> pra_vaddr;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>pra_page_link构造了按页的第一次访问时间进行排序的一个链表，这个链表的开始表示第一次访问时间最近的页，链表结尾表示第一次访问时间最远的页。当然链表头可以就可设置为pra_list_head（定义在swap_fifo.c中），构造的时机是在page fault发生后，进行do_pgfault函数时。pra_vaddr可以用来记录此物理页对应的虚拟页起始地址。</p>
<p>当一个物理页（struct Page）需要被swap出去的时候，首先需要确保它已经分配了一个位于磁盘上的swap page（由连续的8个扇区组成）。这里为了简化设计，在swap_check函数中建立了每个虚拟页唯一对应的swap page，其对应关系设定为：<code>虚拟页对应的PTE的索引值 = swap page的扇区起始位置*8</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">swap_manager</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;  </span><br><span class="line">    <span class="comment">/* swap manager 全局初始化 */</span>  </span><br><span class="line">    <span class="type">int</span> (*init) (<span class="type">void</span>);  </span><br><span class="line">    <span class="comment">/* 对mm_struct中的数据进行初始化 */</span>  </span><br><span class="line">    <span class="type">int</span> (*init_mm) (<span class="keyword">struct</span> mm_struct *mm);  </span><br><span class="line">    <span class="comment">/* 时钟中断处理 */</span>  </span><br><span class="line">    <span class="type">int</span> (*tick_event) (<span class="keyword">struct</span> mm_struct *mm);  </span><br><span class="line">    <span class="comment">/* Called when map a swappable page into the mm_struct */</span>  </span><br><span class="line">    <span class="type">int</span> (*map_swappable) (<span class="keyword">struct</span> mm_struct *mm, <span class="type">uintptr_t</span> addr, <span class="keyword">struct</span> Page *page, <span class="type">int</span> swap_in);   </span><br><span class="line">    <span class="comment">/* When a page is marked as shared, this routine is called to delete the addr entry from the swap manager */</span></span><br><span class="line">    <span class="type">int</span> (*set_unswappable) (<span class="keyword">struct</span> mm_struct *mm, <span class="type">uintptr_t</span> addr);  </span><br><span class="line">    <span class="comment">/* Try to swap out a page, return then victim */</span>  </span><br><span class="line">    <span class="type">int</span> (*swap_out_victim) (<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> Page *ptr_page, <span class="type">int</span> in_tick);  </span><br><span class="line">    <span class="comment">/* check the page relpacement algorithm */</span>  </span><br><span class="line">    <span class="type">int</span> (*check_swap)(<span class="type">void</span>);   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>map_swappable函数用于记录页访问情况相关属性，swap_out_vistim函数用于挑选需要换出的页。显然第二个函数依赖于第一个函数记录的页访问情况。tick_event函数指针也很重要，结合定时产生的中断，可以实现一种积极的换页策略。</p>
<ol>
<li>准备：为了实现FIFO置换算法，我们应该管理所有可交换的页面，因此我们可以根据时间顺序将这些页面链接到pra_list_head。 使用list.h中的struct list。 struct list是一个简单的双向链表实现，具体函数包括：list_init，list_add（list_add_after），list_add_before，list_del，list_next，list_prev。 将通用列表结构转换为特殊结构（例如结构页面）。可以找到一些宏：le2page（在memlayout.h中），le2vma（在vmm.h中），le2proc（在proc.h中）等；</li>
<li>_fifo_init_mm：初始化pra_list_head并让mm -&gt; sm_priv指向pra_list_head的addr。 现在，从内存控制struct mm_struct，我们可以调用FIFO算法；</li>
<li>_fifo_map_swappable：将最近访问的页放到 pra_list_head 队列最后；</li>
<li>_fifo_swap_out_victim：最早访问的页面从pra_list_head队列中剔除，然后*ptr_page赋值为这一页。</li>
</ol>
<h2 id="读代码-1"><a href="#读代码-1" class="headerlink" title="读代码"></a>读代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">与虚拟地址范围[VPT，VPT + PTSIZE]对应的页面目录条目(page directory entry,PDE)指向页面目录本身。 因此，页面目录被视为页面表和页面目录。</span><br><span class="line">将页面目录视为页表的一个结果是可以通过虚拟地址VPT处的“虚拟页表(virtual page table,VPT)”访问所有PTE。 数字n的PTE存储在vpt[n]中。</span><br><span class="line">第二个结果是当前页面目录的内容将始终在虚拟地址PGADDR（PDX（VPT），PDX（VPT），0）处可用，vpd设置如下。</span><br><span class="line">*/</span><br><span class="line">pte_t * const vpt = (pte_t *)VPT;</span><br><span class="line">pde_t * const vpd = (pde_t *)PGADDR(PDX(VPT), PDX(VPT), 0);</span><br></pre></td></tr></table></figure>
<h2 id="练习1：给未被映射的地址映射上物理页"><a href="#练习1：给未被映射的地址映射上物理页" class="headerlink" title="练习1：给未被映射的地址映射上物理页"></a>练习1：给未被映射的地址映射上物理页</h2><p>完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限的时候 需要参考页面所在VMA的权限，同时需要注意映射物理页时需要操作内存控制结构所指定的页表，而不是内核的页表。</p>
<p>引入虚拟内存后，可能会出现某一些虚拟内存空间是合法的（在vma中），但是还没有为其分配具体的内存页，这样的话，在访问这些虚拟页的时候就会产生pagefault异常，从而使得OS可以在异常处理时完成对这些虚拟页的物理页分配，在中端返回之后就可以正常进行内存的访问了。将出现了异常的线性地址保存在cr2寄存器中；再到trap_dispatch函数，在该函数中会根据中断号，将page fault的处理交给pgfault_handler函数，进一步交给do_pgfault函数进行处理。产生页面异常的原因主要有:</p>
<ul>
<li>目标页面不存在（页表项全为0，即该线性地址与物理地址尚未建立映射或者已经撤销）；</li>
<li>相应的物理页面不在内存中（页表项非空，但Present标志位=0，比如在swap分区或磁盘文件上）；</li>
<li>访问权限不符合（此时页表项P标志=1，比如企图写只读页面）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do_pgfault - 处理缺页中断的中断处理例程 interrupt handler to process the page fault execption</span><br><span class="line">@mm         : the control struct for a set of vma using the same PDT</span><br><span class="line">@error_code : the error code recorded in trapframe-&gt;tf_err which is setted by x86 hardware</span><br><span class="line">@addr       : the addr which causes a memory access exception, (the contents of the CR2 register)</span><br></pre></td></tr></table></figure>
<p>调用栈： trap—&gt; trap_dispatch—&gt;pgfault_handler—&gt;do_pgfault</p>
<p>处理器为ucore的do_pgfault函数提供了两项信息，以帮助诊断异常并从中恢复。</p>
<p>(1) CR2寄存器的内容。 处理器使用产生异常的32位线性地址加载CR2寄存器。 do_pgfault可以使用此地址来查找相应的页面目录和页表条目。</p>
<p>(2) 在内核栈中的错误码。缺页错误码与其他异常的错误码不同，错误码可以通知中断处理例程以下信息:</p>
<ul>
<li>P flag(bit 0) 表明异常是否是因为一个不存在的页(0)或违反访问权限或使用保留位(1)；</li>
<li>W/R flag(bit 1) 表明引起异常的访存操作是读(0)还是写(1)；</li>
<li>U/S flag (bit 2) 表明引起异常时处理器是在用户态(1)还是内核态(0)</li>
</ul>
<blockquote>
<p><code>do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr)</code></p>
</blockquote>
<p>第一个是一个mm_struct变量，其中保存了所使用的PDT，合法的虚拟地址空间（使用链表组织），以及与后文的swap机制相关的数据；而第二个参数是产生pagefault的时候硬件产生的error code，可以用于帮助判断发生page fault的原因，而最后一个参数则是出现page fault的线性地址（保存在cr2寄存器中的线性地址）。</p>
<ol>
<li>查询mm_struct中的虚拟地址链表（线性地址对等映射，因此线性地址等于虚拟地址），确定出现page_fault的线性地址是否合法；</li>
<li>使用error code（包含了这次内存访问为读/写，对应物理页是否存在）判断是否出现权限问题，如果出现问题则直接返回；</li>
<li>根据合法虚拟地址（mm_struct中保存的合法虚拟地址链表中）生成对应产生的物理页的权限；</li>
<li>使用get_pte获取出错的线性地址所对应的虚拟页起始地址对应到的页表项，同时使用页表项保存物理地址（P为1）和被换出的物理页在swap中的位置（P为0），并规定swap中第0个页空出来不用于交换。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_pgfault</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="type">uint32_t</span> error_code, <span class="type">uintptr_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据传进的mm和地址addr，找一个vma，这个vma是在mm的mmap_cache中的，find_vma主要是先找mm中的mmap_cache，如果还不存在，就在mm的mmap_list中找，这个vma用le2vma宏进行转换，直到找到一个地址空间合适的vma，把这个vma赋值给mmap_cache。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">vma</span> =</span> find_vma(mm, addr);</span><br><span class="line"></span><br><span class="line">    pgfault_num++;</span><br><span class="line">    <span class="comment">//检查找到的vma是否为空或符合地址范围</span></span><br><span class="line">    <span class="keyword">if</span> (vma == <span class="literal">NULL</span> || vma-&gt;vm_start &gt; addr) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;not valid addr %x, and  can not find it in vma\n&quot;</span>, addr);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果present位是0，代表没有映射关系，不存在物理页和虚拟页帧的对应关系</span></span><br><span class="line">    <span class="comment">//error_code在cr2寄存器中的后几位，对这个errorcode进行判断，确定读写权限和p位是否为1</span></span><br><span class="line">    <span class="keyword">switch</span> (error_code &amp; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">/* error code flag : default is 3 ( W/R=1, P=1): write, present */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">/* error code flag : (W/R=1, P=0): write, not present */</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE)) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;do_pgfault failed: error code flag = write AND not present, but the addr&#x27;s vma cannot write</span></span><br><span class="line"><span class="string">\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">/* error code flag : (W/R=0, P=1): read, present */</span></span><br><span class="line">        cprintf(<span class="string">&quot;do_pgfault failed: error code flag = read AND present\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* error code flag : (W/R=0, P=0): read, not present */</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;do_pgfault failed: error code flag = read AND not present, but the addr&#x27;s vma cannot read or exec\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* IF (write an existed addr ) OR</span></span><br><span class="line"><span class="comment">     *    (write an non_existed addr &amp;&amp; addr is writable) OR</span></span><br><span class="line"><span class="comment">     *    (read  an non_existed addr &amp;&amp; addr is readable)</span></span><br><span class="line"><span class="comment">     * THEN</span></span><br><span class="line"><span class="comment">     *    continue process</span></span><br><span class="line"><span class="comment">     * 写一个存在的地址、写一个不存在的地址但是地址是可写的、读一个不存在的地址但是地址是可读的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint32_t</span> perm = PTE_U;</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE) &#123;</span><br><span class="line">        perm |= PTE_W;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成一个权限控制</span></span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">    <span class="comment">// 向下舍入到n的最接近的倍数</span></span><br><span class="line"></span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="type">pte_t</span> *ptep=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*LAB3 EXERCISE 1: YOUR CODE</span></span><br><span class="line"><span class="comment">    * 本次实验用到的宏和定义：</span></span><br><span class="line"><span class="comment">    *   get_pte : 获得pte，返回pte的线性地址、虚拟地址</span></span><br><span class="line"><span class="comment">    *             if the PT contians this pte didn&#x27;t exist, alloc a page for PT (notice the 3th parameter &#x27;1&#x27;)</span></span><br><span class="line"><span class="comment">    *   pgdir_alloc_page : 调用alloc_page 和 page_insert 分配一个页大小的内存空间，设置物理地址和线性地址的映射关系</span></span><br><span class="line"><span class="comment">    * DEFINES:</span></span><br><span class="line"><span class="comment">    *   VM_WRITE  : If vma-&gt;vm_flags &amp; VM_WRITE == 1/0, then the vma is writable/non writable</span></span><br><span class="line"><span class="comment">    *   PTE_W           0x002                   // page table/directory entry flags bit : Writeable</span></span><br><span class="line"><span class="comment">    *   PTE_U           0x004                   // page table/directory entry flags bit : User can access</span></span><br><span class="line"><span class="comment">    * VARIABLES:</span></span><br><span class="line"><span class="comment">    *   mm-&gt;pgdir : the PDT of these vma</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*LAB3 EXERCISE 1: YOUR CODE*/</span></span><br><span class="line">    ptep = get_pte(mm-&gt;pgdir, addr, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 第三个参数create代表是否在查找page_directory的过程中没找到的话要不要创建，在这里要创建</span></span><br><span class="line">    <span class="keyword">if</span> (ptep == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;get_pte return a NULL.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(1) 找到一个pte，如果需要的物理页是没有分配而不是被换出到外存中</span></span><br><span class="line">    <span class="comment">//如果物理地址不存在，则分配一个页面并使用逻辑地址映射物理地址，pgdir_alloc_page一个函数就能分配页和设置映射关系</span></span><br><span class="line">    <span class="keyword">if</span> (*ptep == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span>* <span class="title">page</span> =</span> pgdir_alloc_page(mm-&gt;pgdir, addr, perm);</span><br><span class="line">        <span class="keyword">if</span>(page == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;pgdir_alloc_page return a NULL.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*LAB3 EXERCISE 2: YOUR CODE</span></span><br><span class="line"><span class="comment">    * 现在我们认为这个pte是一个swap的，我们应该将数据从disk加载到带有物理地址的页面，并将物理地址映射到逻辑地址，触发交换管理器来记录该页面的访问情况。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *  MACROs or Functions:</span></span><br><span class="line"><span class="comment">    *    swap_in(mm, addr, &amp;page) : 分配一个内存页，根据PTE中的swap地址找到磁盘页的地址，读进内存页中</span></span><br><span class="line"><span class="comment">    *    page_insert ： 创建页的物理地址和线性地址的映射关系</span></span><br><span class="line"><span class="comment">    *    swap_map_swappable ： 设置这一个页是可交换的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">if</span>(swap_init_ok) &#123;    <span class="comment">// 判断是否当前交换机制正确被初始化</span></span><br><span class="line">            <span class="keyword">struct</span> Page *page=<span class="literal">NULL</span>;</span><br><span class="line">            ret = swap_in(mm, addr, &amp;page);   <span class="comment">// 将物理页换入到内存中</span></span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">                cprintf(<span class="string">&quot;swap_in failed.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> failed;</span><br><span class="line">            &#125;</span><br><span class="line">            page_insert(mm-&gt;pgdir, page, addr, perm);</span><br><span class="line">            <span class="comment">//(2) According to the mm, addr AND page, setup the map of phy addr &lt;---&gt; logical addr</span></span><br><span class="line">            <span class="comment">// 将物理页与虚拟页建立映射关系</span></span><br><span class="line">            swap_map_swappable(mm, addr, page, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//(3) make the page swappable。设置当前的物理页为可交换的</span></span><br><span class="line">            page-&gt;pra_vaddr = addr;</span><br><span class="line">            <span class="comment">//同时在物理页中维护其对应到的虚拟页的信息；</span></span><br><span class="line">            <span class="comment">//网上有人说这个语句最好应当放置在page_insert函数中，</span></span><br><span class="line">            <span class="comment">//在该建立映射关系的函数外对物理page对应的虚拟地址进行维护显得有些不太合适（感觉好有道理）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;no swap_init_ok but ptep is %x, failed\n&quot;</span>,*ptep);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ret = <span class="number">0</span>;</span><br><span class="line">failed:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：</p>
<ul>
<li>请描述页目录项（Page Director Entry）和页表（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。</li>
</ul>
<p>首先不妨先分析PDE以及PTE中各个组成部分以及其含义；</p>
<p>接下来先描述页目录项的每个组成部分，PDE（页目录项）的具体组成如下图所示；描述每一个组成部分的含义如下：</p>
<ul>
<li>前20位表示4K对齐的该PDE对应的页表起始位置（物理地址，该物理地址的高20位即PDE中的高20位，低12位为0）；</li>
<li>第9-11位未被CPU使用，可保留给OS使用；</li>
<li>接下来的第8位可忽略；</li>
<li>第7位用于设置Page大小，0表示4KB；</li>
<li>第6位恒为0；</li>
<li>第5位用于表示该页是否被使用过；</li>
<li>第4位设置为1则表示不对该页进行缓存；</li>
<li>第3位设置是否使用write through缓存写策略；</li>
<li>第2位表示该页的访问需要的特权级；</li>
<li>第1位表示是否允许读写；</li>
<li>第0位为该PDE的存在位；</li>
</ul>
<p>接下来描述页表项（PTE）中的每个组成部分的含义，具体组成如下图所示：</p>
<ul>
<li>高20位与PDE相似的，用于表示该PTE指向的物理页的物理地址；</li>
<li>9-11位保留给OS使用；</li>
<li>7-8位恒为0；</li>
<li>第6位表示该页是否为dirty，即是否需要在swap out的时候写回外存；</li>
<li>第5位表示是否被访问；</li>
<li>3-4位恒为0；</li>
<li>0-2位分别表示存在位、是否允许读写、访问该页需要的特权级；</li>
</ul>
<p>可以发现无论是PTE还是TDE，都具有着一些保留的位供操作系统使用，也就是说ucore可以利用这些位来完成一些其他的内存管理相关的算法，比如可以在这些位里保存最近一段时间内该页的被访问的次数（仅能表示0-7次），用于辅助近似地实现虚拟内存管理中的换出策略的LRU之类的算法；也就是说这些保留位有利于OS进行功能的拓展；</p>
<blockquote>
<p>作者：AmadeusChan<br>链接：<a href="https://www.jianshu.com/p/8d6ce61ac678">https://www.jianshu.com/p/8d6ce61ac678</a><br>来源：简书</p>
</blockquote>
<p>如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？</p>
<p>考虑到ucore的缺页服务例程如果在访问内容中出现了缺页异常，则会有可能导致ucore最终无法完成缺页的处理，因此一般不应该将缺页的ISR以及OS中的其他一些关键代码或者数据换出到外存中，以确保操作系统的正常运行；如果缺页ISR在执行过程中遇到页访问异常，则最终硬件需要完成的处理与正常出现页访问异常的处理相一致，均为：</p>
<ul>
<li>将发生错误的线性地址保存在cr2寄存器中;</li>
<li>在中断栈中依次压入EFLAGS，CS, EIP，以及页访问异常码errorcode，由于ISR一定是运行在内核态下的，因此不需要压入ss和esp以及进行栈的切换；</li>
<li>根据中断描述符表查询到对应页访问异常的ISR，跳转到对应的ISR处执行，接下来将由软件进行处理；</li>
</ul>
<h2 id="练习2：补充完成基于FIFO的页面替换算法"><a href="#练习2：补充完成基于FIFO的页面替换算法" class="headerlink" title="练习2：补充完成基于FIFO的页面替换算法"></a>练习2：补充完成基于FIFO的页面替换算法</h2><p>维基百科：最简单的页面替换算法（Page Replace Algorithm）是FIFO算法。先进先出页面替换算法是一种低开销算法。这个想法从名称中可以明显看出 - 操作系统跟踪队列中内存中的所有页面，最近到达的放在后面，最早到达的放在前面。当需要更换页面时，会选择队列最前面的页面（最旧的页面）。虽然FIFO开销小且直观，但在实际应用中表现不佳。因此，它很少以未修改的形式使用。该算法存在Belady异常。</p>
<p> FIFO的详细信息</p>
<ol>
<li>准备：为了实现FIFO，我们应该管理所有可交换的页面，这样我们就可以按照时间顺序将这些页面链接到pra_list_head。将通用list换为特殊结构（例如Page）；</li>
<li>_fifo_init_mm：初始化pra_list_head并让mm-&gt; sm_priv指向pra_list_head的addr。 现在，从内存控制struct mm_struct，我们可以访问FIFO；</li>
<li>_fifo_map_swappable: 最近到达的页需要放到pra_list_head队列的最末尾；</li>
<li>_fifo_swap_out_victim: 最早到达的页面在pra_list_head队列最前边，我们应该将它踢出去。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">将当前的物理页面插入到FIFO算法中维护的可被交换出去的物理页面链表中的末尾，从而保证该链表中越接近链表头的物理页面在内存中的驻留时间越长；</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _fifo_map_swappable(<span class="keyword">struct</span> mm_struct *mm, <span class="type">uintptr_t</span> addr, <span class="keyword">struct</span> Page *page, <span class="type">int</span> swap_in)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">list_entry_t</span> *head=(<span class="type">list_entry_t</span>*) mm-&gt;sm_priv;</span><br><span class="line">    <span class="comment">// 找到链表入口</span></span><br><span class="line">    <span class="type">list_entry_t</span> *entry=&amp;(page-&gt;pra_page_link); </span><br><span class="line">    <span class="comment">// 找到当前物理页用于组织成链表的list_entry_t</span></span><br><span class="line"></span><br><span class="line">    assert(entry != <span class="literal">NULL</span> &amp;&amp; head != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span></span><br><span class="line">    <span class="comment">// link the most recent arrival page at the back of the pra_list_head qeueue</span></span><br><span class="line">    <span class="comment">// 将当前指定的物理页插入到链表的末尾</span></span><br><span class="line">    list_add(head, entry);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick)</span><br><span class="line">&#123;</span><br><span class="line">     list_entry_t *head=(list_entry_t*) mm-&gt;sm_priv; </span><br><span class="line">     // 找到链表的入口</span><br><span class="line">     assert(head != NULL);</span><br><span class="line">     assert(in_tick==0);</span><br><span class="line">     /* Select the victim */</span><br><span class="line">     /*LAB3 EXERCISE 2: YOUR CODE*/</span><br><span class="line">     // unlink the earliest arrival page in front of pra_list_head qeueue</span><br><span class="line">     //list_entry_t *le = head-&gt;prev; the given answer</span><br><span class="line">     list_entry_t *le = list_next(head);</span><br><span class="line">     // 取出链表头，即最早进入的物理页面</span><br><span class="line">     assert(le != NULL);</span><br><span class="line">     // 确保链表非空</span><br><span class="line">     struct Page *p = le2page(le,pra_page_link);</span><br><span class="line">     // 找到对应的物理页面的Page结构</span><br><span class="line">     list_del(le);</span><br><span class="line">     // 从链表上删除取出的即将被换出的物理页面</span><br><span class="line">     assert(p != NULL);</span><br><span class="line">     *ptr_page = p;</span><br><span class="line">     // assign the value of *ptr_page to the addr of this page</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在_fifo_map_swappable函数中使用的是list_add_before的话，在_fifo_swap_out_victim中应该使用list_next(head)取得要被删除的页；如果在_fifo_map_swappable函数中使用的是list_add的话，在_fifo_swap_out_victim中应该使用head-&gt;prev取得要被删除的页；这个链表是双向循环链表！</p>
<p>如果要在ucore上实现”extended clock页替换算法”请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题</p>
<p>在现有框架基础上可以支持Extended clock算法。</p>
<p>根据上文中提及到的PTE的组成部分可知，PTE中包含了dirty位和访问位，因此可以确定某一个虚拟页是否被访问过以及写过，但是，考虑到在替换算法的时候是将物理页面进行换出，而可能存在着多个虚拟页面映射到同一个物理页面这种情况，也就是说某一个物理页面是否dirty和是否被访问过是有这些所有的虚拟页面共同决定的，而在原先的实验框架中，物理页的描述信息Page结构中默认只包括了一个对应的虚拟页的地址，应当采用链表的方式，在Page中扩充一个成员，把物理页对应的所有虚拟页都给保存下来；而物理页的dirty位和访问位均为只需要某一个对应的虚拟页对应位被置成1即可置成1；</p>
<p>完成了上述对物理页描述信息的拓展之后，考虑对FIFO算法的框架进行修改得到拓展时钟算法的框架，由于这两种算法都是将所有可以换出的物理页面均按照进入内存的顺序连成一个环形链表，因此初始化，将某个页面置为可以/不可以换出这些函数均不需要进行大的修改(小的修改包括在初始化当前指针等)，唯一需要进行重写的函数是选择换出物理页的函数swap_out_victim，对该函数的修改如下：</p>
<p>从当前指针开始，对环形链表进行扫描，根据指针指向的物理页的状态（表示为(access, dirty)）来确定应当进行何种修改：如果状态是(0, 0)，则将该物理页面从链表上去下，该物理页面记为换出页面，但是由于这个时候这个页面不是dirty的，因此事实上不需要将其写入swap分区；</p>
<p>如果状态是(0,1)，则将该物理页对应的虚拟页的PTE中的dirty位都改成0，并且将该物理页写入到外存中，然后指针跳转到下一个物理页；如果状态是(1, 0), 将该物理页对应的虚拟页的PTE中的访问位都置成0，然后指针跳转到下一个物理页面；如果状态是(1, 1)，则该物理页的所有对应虚拟页的PTE中的访问为置成0，然后指针跳转到下一个物理页面；</p>
<p>需要被换出的页的特征是什么？</p>
<p>该物理页在当前指针上一次扫过之前没有被访问过；<br>该物理页的内容与其在外存中保存的数据是一致的, 即没有被修改过;</p>
<p>在ucore中如何判断具有这样特征的页？</p>
<p>在ucore中判断具有这种特征的页的方式已经在上文设计方案中提及过了，具体为：</p>
<p>假如某物理页对应的所有虚拟页中存在一个dirty的页，则认为这个物理页为dirty，否则不这么认为；<br>假如某物理页对应的所有虚拟页中存在一个被访问过的页，则认为这个物理页为被访问过的，否则不这么认为；</p>
<p>何时进行换入和换出操作？</p>
<p>在产生page fault的时候进行换入操作；<br>换出操作源于在算法中将物理页的dirty从1修改成0的时候，因此这个时候如果不进行写出到外存，就会造成数据的不一致，具体写出内存的时机是比较细节的问题, 可以在修改dirty的时候写入外存，或者是在这个物理页面上打一个需要写出的标记，到了最终删除这个物理页面的时候，如果发现了这个写出的标记，则在这个时候再写入外存；后者使用一个写延迟标记，有利于多个写操作的合并，从而降低缺页的代价；</p>
<h1 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>了解内核线程创建/执行的管理过程<br>了解内核线程的切换和基本调度过程</p>
<h2 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a>实验内容</h2><p>当一个程序加载到内存中运行时，首先通过ucore OS的内存管理子系统分配合适的空间，然后就需要考虑如何分时使用CPU来“并发”执行多个程序，让每个运行的程序（这里用线程或进程表示）“感到”它们各自拥有“自己”的CPU。</p>
<p>内核线程是一种特殊的进程，内核线程与用户进程的区别有两个：</p>
<ul>
<li>内核线程只运行在内核态</li>
<li>用户进程会在在用户态和内核态交替运行</li>
<li>所有内核线程共用ucore内核内存空间，不需为每个内核线程维护单独的内存空间</li>
<li>用户进程需要维护各自的用户内存空间</li>
</ul>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="内核线程管理"><a href="#内核线程管理" class="headerlink" title="内核线程管理"></a>内核线程管理</h3><p>本实验实现了让ucore实现分时共享CPU，实现多条控制流能够并发执行。<strong>内核线程</strong>是一种特殊的进程，内核线程与用户进程的区别有两个：</p>
<ul>
<li><strong>内核线程只运行在内核态而用户进程会在在用户态和内核态交替运行</strong>；</li>
<li><strong>所有内核线程直接使用共同的ucore内核内存空间</strong>，不需为每个内核线程维护单独的内存空间而用户进程需要维护各自的用户内存空间。</li>
</ul>
<p>设计管理线程的数据结构，即进程控制块(PCB)。创建内核线程对应的进程控制块，把这些进程控制块通过链表连在一起，便于随时进行插入，删除和查找操作。通过调度器（scheduler）来让不同的内核线程在不同的时间段占用CPU执行，实现对CPU的分时共享。</p>
<p>kern/init/init.c中的kern_init函数中，当完成虚拟内存的初始化工作vmm_init()后，就调用了proc_init函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    list_init(&amp;proc_list);</span><br><span class="line">    <span class="comment">// initialize the process double linked list</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HASH_LIST_SIZE; i ++) &#123;</span><br><span class="line">        list_init(hash_list + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((idleproc = alloc_proc()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;cannot alloc idleproc.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idleproc-&gt;pid = <span class="number">0</span>;</span><br><span class="line">    idleproc-&gt;state = PROC_RUNNABLE;</span><br><span class="line">    idleproc-&gt;kstack = (<span class="type">uintptr_t</span>)bootstack;</span><br><span class="line">    idleproc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 完成了idleproc内核线程创建   </span></span><br><span class="line">    set_proc_name(idleproc, <span class="string">&quot;idle&quot;</span>);</span><br><span class="line">    nr_process ++;</span><br><span class="line"></span><br><span class="line">    current = idleproc;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = kernel_thread(init_main, <span class="string">&quot;Hello world!!&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;create init_main failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initproc = find_proc(pid);</span><br><span class="line">    <span class="comment">// initproc内核线程的创建</span></span><br><span class="line">    set_proc_name(initproc, <span class="string">&quot;init&quot;</span>);</span><br><span class="line"></span><br><span class="line">    assert(idleproc != <span class="literal">NULL</span> &amp;&amp; idleproc-&gt;pid == <span class="number">0</span>);</span><br><span class="line">    assert(initproc != <span class="literal">NULL</span> &amp;&amp; initproc-&gt;pid == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>idleproc内核线程的工作就是不停地查询，看是否有其他内核线程可以执行了，如果有，马上让调度器选择那个内核线程执行（请参考cpu_idle函数的实现）。所以<strong>idleproc内核线程是在ucore操作系统没有其他内核线程可执行的情况下才会被调用</strong>。</p>
<p>接着就是调用kernel_thread函数来创建initproc内核线程。initproc内核线程的工作就是显示“Hello World”，表明自己存在且能正常工作了。<br>调度器会在特定的调度点上执行调度，完成进程切换。</p>
<p>在lab4中，这个调度点就一处，即在cpu_idle函数中，此函数如果发现当前进程（也就是idleproc）的need_resched置为1（在初始化idleproc的进程控制块时就置为1了），则调用schedule函数，完成进程调度和进程切换。进程调度的过程其实比较简单，就是在进程控制块链表中查找到一个“合适”的内核线程，所谓“合适”就是指内核线程处于“PROC_RUNNABLE”状态。</p>
<p>在接下来的switch_to函数(在后续有详细分析，有一定难度，需深入了解一下)完成具体的进程切换过程。一旦切换成功，那么initproc内核线程就可以通过显示字符串来表明本次实验成功。</p>
<p>进程管理信息用struct proc_struct表示，在kern/process/proc.h中定义如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct proc_struct &#123;</span><br><span class="line">    enum proc_state state;        // Process state</span><br><span class="line">    int pid;                      // Process ID</span><br><span class="line">    int runs;                     // the running times of Proces</span><br><span class="line">    uintptr_t kstack;             // Process kernel stack</span><br><span class="line">    volatile bool need_resched;   // need to be rescheduled to release CPU?</span><br><span class="line">    struct proc_struct *parent;   // the parent process</span><br><span class="line">    struct mm_struct *mm;         // Process&#x27;s memory management field</span><br><span class="line">    struct context context;       // Switch here to run process</span><br><span class="line">    struct trapframe *tf;         // Trap frame for current interrupt</span><br><span class="line">    uintptr_t cr3;                // the base addr of Page Directroy Table(PDT)</span><br><span class="line">    uint32_t flags;               // Process flag</span><br><span class="line">    char name[PROC_NAME_LEN + 1]; // Process name</span><br><span class="line">    list_entry_t list_link;       // Process link list</span><br><span class="line">    list_entry_t hash_link;       // Process hash list</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>mm：内存管理的信息。在lab3中有涉及，主要包括内存映射列表、页表指针等。<strong>在实际OS中，内核线程常驻内存，不需要考虑swap page问题</strong>，在用户进程中考虑进程用户内存空间的swap_page问题时mm才会发挥作用。所以在lab4中mm对于内核线程就没有用了，这样内核线程的proc_struct的成员变量<em>mm=0是合理的。mm里有个很重要的项pgdir，记录的是该进程使用的一级页表的物理地址。由于</em>mm=NULL，所以在proc_struct数据结构中需要有一个代替pgdir项来记录页表起始地址，这就是proc_struct数据结构中的<strong>cr3</strong>成员变量。</li>
<li>state：进程所处的状态。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> &#123;</span></span><br><span class="line">    PROC_UNINIT = <span class="number">0</span>,  <span class="comment">// uninitialized</span></span><br><span class="line">    PROC_SLEEPING,    <span class="comment">// sleeping</span></span><br><span class="line">    PROC_RUNNABLE,    <span class="comment">// runnable(maybe running)</span></span><br><span class="line">    PROC_ZOMBIE,      <span class="comment">// almost dead, and wait parent proc to reclaim his resource</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>parent：用户进程的父进程（创建它的进程）。在所有进程中，只有一个进程没有父进程，就是内核创建的第一个内核线程idleproc。内核根据这个父子关系建立一个树形结构，用于维护一些特殊的操作，例如确定某个进程是否可以对另外一个进程进行某种操作等等。</li>
<li>context：进程的上下文，用于进程切换（参见switch.S）。在uCore中，所有的进程在内核中也是相对独立的（例如独立的内核堆栈以及上下文等等）。使用context保存寄存器的目的就在于在内核态中能够进行上下文之间的切换。实际利用context进行上下文切换的函数是在kern/process/switch.S中定义switch_to。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在上下文切换时保存寄存器信息，其中有些寄存器貌似不被保存，为了省事</span><br><span class="line">// The 这个结构体的布局要跟switch.S中的switch_to操作对应。</span><br><span class="line">struct context &#123;</span><br><span class="line">    uint32_t eip;</span><br><span class="line">    uint32_t esp;</span><br><span class="line">    uint32_t ebx;</span><br><span class="line">    uint32_t ecx;</span><br><span class="line">    uint32_t edx;</span><br><span class="line">    uint32_t esi;</span><br><span class="line">    uint32_t edi;</span><br><span class="line">    uint32_t ebp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>tf：中断帧的指针，总是指向内核栈的某个位置：当进程从用户空间跳到内核空间时，<strong>中断帧记录了进程在被中断前的状态</strong>。当内核需要跳回用户空间时，需要调整中断帧以<strong>恢复让进程继续执行的各寄存器值</strong>。除此之外，uCore内核允许嵌套中断。因此为了保证嵌套中断发生时tf总是能够指向当前的trapframe，uCore在内核栈上维护了tf的链。</li>
<li>cr3: cr3 保存页表的物理地址，目的就是进程切换的时候方便直接使用lcr3实现页表切换，避免每次都根据 mm 来计算 cr3。mm数据结构是用来实现用户空间的虚存管理的，但是内核线程没有用户空间，它执行的只是内核中的一小段代码（通常是一小段函数），所以它没有mm结构，也就是NULL。当某个进程是一个普通用户态进程的时候，PCB中的cr3就是mm中页表（pgdir）的物理地址；而当它是内核线程的时候，cr3等于boot_cr3。而boot_cr3指向了uCore启动时建立好的内核虚拟空间的页目录表首地址。</li>
<li>kstack: 每个线程都有一个<strong>内核栈</strong>，并且位于内核地址空间的不同位置。对于内核线程，该栈就是运行时的程序使用的栈；而<strong>对于普通进程，该栈是发生特权级改变的时候使保存被打断的硬件信息用的栈</strong>。uCore在创建进程时分配了 2 个连续的物理页（参见memlayout.h中KSTACKSIZE的定义）作为内核栈的空间。这个栈很小，所以内核中的代码应该尽可能的紧凑，并且避免在栈上分配大的数据结构，以免栈溢出，导致系统崩溃。kstack记录了分配给该进程/线程的内核栈的位置。主要作用有以下几点。</li>
</ul>
<blockquote>
<p>首先，当内核准备从一个进程切换到另一个的时候，需要根据kstack 的值正确的设置好tss，以便在进程切换以后再发生中断时能够使用正确的栈。</p>
<p>其次，内核栈位于内核地址空间，并且是不共享的（每个线程都拥有自己的内核栈），因此不受到 mm 的管理，当进程退出的时候，内核能够根据 kstack 的值快速定位栈的位置并进行回收。uCore 的这种内核栈的设计借鉴的是 linux 的方法（但由于内存管理实现的差异，它实现的远不如 linux 的灵活），它使得每个线程的内核栈在不同的位置，这样从某种程度上方便调试，但同时也使得内核对栈溢出变得十分不敏感，因为一旦发生溢出，它极可能污染内核中其它的数据使得内核崩溃。如果能够通过页表，将所有进程的内核栈映射到固定的地址上去，能够避免这种问题，但又会使得进程切换过程中对栈的修改变得相当繁琐。</p>
</blockquote>
<p>为了管理系统中所有的进程控制块，uCore维护了如下全局变量（位于kern/process/proc.c）：</p>
<ul>
<li>static struct proc *current：当前占用CPU且处于“运行”状态进程控制块指针。通常这个变量是只读的，只有在进程切换的时候才进行修改，并且整个切换和修改过程需要保证操作的原子性，目前至少需要屏蔽中断。可以参考 switch_to 的实现。</li>
<li>static struct proc *initproc：本实验中，指向一个内核线程。本实验以后，此指针将指向第一个用户态进程。</li>
<li>static list_entry_t hash_list[HASH_LIST_SIZE]：所有进程控制块的哈希表，proc_struct中的成员变量hash_link将基于pid链接入这个哈希表中。</li>
<li>list_entry_t proc_list：所有进程控制块的双向线性列表，proc_struct中的成员变量list_link将链接入这个链表中。</li>
</ul>
<h3 id="创建并执行内核线程"><a href="#创建并执行内核线程" class="headerlink" title="创建并执行内核线程"></a>创建并执行内核线程</h3><p>ucore实现了一个简单的进程/线程机制，进程包含独立的地址空间，至少一个线程、内核数据、进程状态、文件等。ucore需要高效地管理所有细节。在ucore，一个线程看成一个特殊的进程（process）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>进程状态</th>
<th>意义</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>PROC_UNINIT</td>
<td>uninitialized</td>
<td>alloc_proc</td>
</tr>
<tr>
<td>PROC_SLEEPING</td>
<td>sleeping</td>
<td>try_free_pages, do_wait, do_sleep</td>
</tr>
<tr>
<td>PROC_RUNNABLE</td>
<td>runnable(maybe running)</td>
<td>proc_init, wakeup_proc,</td>
</tr>
<tr>
<td>PROC_ZOMBIE</td>
<td>almost dead</td>
<td>do_exit</td>
</tr>
</tbody>
</table>
</div>
<p>进程之间的关系：</p>
<ul>
<li>parent:           proc-&gt;parent  (proc is children)</li>
<li>children:         proc-&gt;cptr    (proc is parent)</li>
<li>older sibling:    proc-&gt;optr    (proc is younger sibling)</li>
<li>younger sibling:  proc-&gt;yptr    (proc is older sibling)</li>
</ul>
<p>建立进程控制块（proc.c中的alloc_proc函数）。首先，考虑最简单的内核线程，它通常只是内核中的一小段代码或者函数，没有自己的“专属”空间。这是由于在uCore OS启动后，已经对整个内核内存空间进行了管理，通过设置页表建立了内核虚拟空间（即boot_cr3指向的二级页表描述的空间）。所以uCore OS内核中的所有线程都不需要再建立各自的页表，只需共享这个内核虚拟空间就可以访问整个物理内存了。从这个角度看，内核线程被uCore OS内核这个大“内核进程”所管理。</p>
<h3 id="创建第-0-个内核线程-idleproc"><a href="#创建第-0-个内核线程-idleproc" class="headerlink" title="创建第 0 个内核线程 idleproc"></a>创建第 0 个内核线程 idleproc</h3><p>在init.c中的kern_init函数调用了proc.c中的proc_init函数。proc_init函数启动了创建内核线程的步骤。</p>
<p>首先当前的执行上下文（从kern_init启动至今）就可以看成是uCore内核（也可看做是内核进程）中的一个内核线程的上下文。为此，uCore通过给当前执行的上下文分配一个进程控制块以及对它进行相应初始化，将其打造成第0个内核线程——idleproc。具体步骤如下：</p>
<ul>
<li>首先调用alloc_proc函数来通过kmalloc函数获得proc_struct结构的一块内存块，作为第0个进程控制块，并把proc进行初步初始化（即把proc_struct中的各个成员变量清零）。但有些成员变量设置了特殊的值，比如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proc-&gt;state = PROC_UNINIT;  设置进程为“初始”态</span><br><span class="line">proc-&gt;pid = <span class="number">-1</span>;             设置进程pid的未初始化值</span><br><span class="line">proc-&gt;cr3 = boot_cr3;       由于该内核线程在内核中运行，故采用为uCore内核已经建立的页表，</span><br><span class="line">							即设置为在uCore内核页表的起始地址boot_cr3，使用内核页目录表的基址</span><br></pre></td></tr></table></figure>
<p>内核线程共用一个映射内核空间的页表，这表示内核空间对所有内核线程都是“可见”的，所以更精确地说，这些内核线程都应该是从属于同一个唯一的“大内核进程”—uCore内核。</p>
<ul>
<li>proc_init函数对idleproc内核线程进行进一步初始化：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">idleproc-&gt;pid = <span class="number">0</span>;</span><br><span class="line">idleproc-&gt;state = PROC_RUNNABLE;</span><br><span class="line">idleproc-&gt;kstack = (<span class="type">uintptr_t</span>)bootstack;</span><br><span class="line">idleproc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">set_proc_name(idleproc, <span class="string">&quot;idle&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>第一条将pid赋值为0，表明idleproc是第0个内核线程。</p>
<p>第二条语句改变了idleproc的状态，使其变为“准备工作”，现在只要uCore调度便可执行。</p>
<p>第三条语句设置了idleproc所使用的内核栈的起始地址。<strong>需要注意以后的其他线程的内核栈都需要通过分配获得，因为uCore启动时设置的内核栈就直接分配给idleproc使用了所以这里不用分配</strong>。</p>
<p>第四条把idleproc-&gt;need_resched设置为“1”，在cpu_idle函数中指明如果进程的need_resched为1那么就可以调度执行其他的了，如果当前idleproc在执行，则只要此标志为1，马上就调用schedule函数要求调度器切换其他进程执行。</p>
<h3 id="创建第-1-个内核线程-initproc"><a href="#创建第-1-个内核线程-initproc" class="headerlink" title="创建第 1 个内核线程 initproc"></a>创建第 1 个内核线程 initproc</h3><p>第0个内核线程主要工作是完成内核中各个子系统的初始化。uCore接下来还需创建其他进程来完成各种工作，通过调用kernel_thread函数创建了一个内核线程init_main。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init_main - the second kernel thread used to create user_main kernel threads</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">init_main</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    cprintf(<span class="string">&quot;this initproc, pid = %d, name = \&quot;%s\&quot;\n&quot;</span>, current-&gt;pid, get_proc_name(current));</span><br><span class="line">    cprintf(<span class="string">&quot;To U: \&quot;%s\&quot;.\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)arg);</span><br><span class="line">    cprintf(<span class="string">&quot;To U: \&quot;en.., Bye, Bye. :)\&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面我们来分析一下创建内核线程的函数kernel_thread。kernel_thread函数采用了局部变量tf来放置保存内核线程的临时中断帧，并把中断帧的指针传递给do_fork函数，而do_fork函数会调用copy_thread函数来在新创建的进程内核栈上专门给进程的中断帧分配一块空间。给中断帧分配完空间后，就需要构造新进程的中断帧，具体过程是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kernel_thread(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">uint32_t</span> clone_flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">tf</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">    <span class="comment">// 给tf进行清零初始化</span></span><br><span class="line">    tf.tf_cs = KERNEL_CS;</span><br><span class="line">    tf.tf_ds = tf_struct.tf_es = tf_struct.tf_ss = KERNEL_DS;</span><br><span class="line">    <span class="comment">// 设置中断帧的代码段（tf.tf_cs）和数据段(tf.tf_ds/tf_es/tf_ss)为内核空间的段（KERNEL_CS/KERNEL_DS）</span></span><br><span class="line">    tf.tf_regs.reg_ebx = (<span class="type">uint32_t</span>)fn;</span><br><span class="line">    <span class="comment">// fn是函数主体</span></span><br><span class="line">    tf.tf_regs.reg_edx = (<span class="type">uint32_t</span>)arg;</span><br><span class="line">    <span class="comment">// arg是fn函数的参数</span></span><br><span class="line">    tf.tf_eip = (<span class="type">uint32_t</span>)kernel_thread_entry;</span><br><span class="line">    <span class="comment">// tf.tf_eip的指出了initproc内核线程从kernel_thread_entry开始执行</span></span><br><span class="line">    <span class="keyword">return</span> do_fork(clone_flags | CLONE_VM, <span class="number">0</span>, &amp;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>kernel_thread_entry是entry.S中实现的汇编函数，它做的事情很简单：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kernel_thread_entry: <span class="meta"># void kernel_thread(void)</span></span><br><span class="line">pushl %edx <span class="meta"># push arg</span></span><br><span class="line">call *%ebx <span class="meta"># call fn</span></span><br><span class="line">pushl %eax <span class="meta"># save the return value of fn(arg)</span></span><br><span class="line">call do_exit <span class="meta"># call do_exit to terminate current thread</span></span><br></pre></td></tr></table></figure><br>从上可以看出，kernel_thread_entry函数主要为内核线程的主体fn函数做了一个准备开始和结束运行的“壳”：</p>
<ul>
<li>把函数fn的参数arg（保存在edx寄存器中）压栈；</li>
<li>调用fn函数</li>
<li>把函数返回值eax寄存器内容压栈</li>
<li>调用do_exit函数退出线程执行。</li>
</ul>
<p>do_fork是创建线程的主要函数。kernel_thread函数通过调用do_fork函数最终完成了内核线程的创建工作。do_fork函数主要做了以下6件事情：</p>
<ul>
<li>分配并初始化进程控制块（alloc_proc函数）；</li>
<li>分配并初始化内核栈（setup_stack函数）；</li>
<li>根据clone_flag标志复制或共享进程内存管理结构（copy_mm函数）；</li>
<li>设置进程在内核（将来也包括用户态）正常运行和调度所需的中断帧和执行上下文（copy_thread函数）；</li>
<li>把设置好的进程控制块放入hash_list和proc_list两个全局进程链表中；</li>
<li>进程已经准备好执行了，把进程状态设置为“就绪”态；设置返回码为子进程的id号。</li>
</ul>
<p>copy_thread函数代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">copy_thread</span><span class="params">(<span class="keyword">struct</span> proc_struct *proc, <span class="type">uintptr_t</span> esp, <span class="keyword">struct</span> trapframe *tf)</span> &#123;</span><br><span class="line">    proc-&gt;tf = (<span class="keyword">struct</span> trapframe *)(proc-&gt;kstack + KSTACKSIZE) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 在内核堆栈的顶部设置中断帧大小的一块栈空间</span></span><br><span class="line">    *(proc-&gt;tf) = *tf; </span><br><span class="line">    <span class="comment">// 拷贝在kernel_thread函数建立的临时中断帧的初始值</span></span><br><span class="line">    proc-&gt;tf-&gt;tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置子进程/线程执行完do_fork后的返回值</span></span><br><span class="line">    proc-&gt;tf-&gt;tf_esp = esp; </span><br><span class="line">    <span class="comment">// 设置中断帧中的栈指针esp</span></span><br><span class="line">    proc-&gt;tf-&gt;tf_eflags |= FL_IF; </span><br><span class="line">    <span class="comment">// 使能中断</span></span><br><span class="line">    <span class="comment">// 以上两句设置中断帧中的栈指针esp和标志寄存器eflags，特别是eflags设置了FL_IF标志，</span></span><br><span class="line">    <span class="comment">// 这表示此内核线程在执行过程中，能响应中断，打断当前的执行。</span></span><br><span class="line">    proc-&gt;context.eip = (<span class="type">uintptr_t</span>)forkret;</span><br><span class="line">    proc-&gt;context.esp = (<span class="type">uintptr_t</span>)(proc-&gt;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于initproc而言，它的中断帧如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所在地址位置</span></span><br><span class="line">initproc-&gt;tf= (proc-&gt;kstack+KSTACKSIZE) – <span class="keyword">sizeof</span> (<span class="keyword">struct</span> trapframe);</span><br><span class="line"><span class="comment">//具体内容</span></span><br><span class="line">initproc-&gt;tf.tf_cs = KERNEL_CS;</span><br><span class="line">initproc-&gt;tf.tf_ds = initproc-&gt;tf.tf_es = initproc-&gt;tf.tf_ss = KERNEL_DS;</span><br><span class="line">initproc-&gt;tf.tf_regs.reg_ebx = (<span class="type">uint32_t</span>)init_main;</span><br><span class="line">initproc-&gt;tf.tf_regs.reg_edx = (<span class="type">uint32_t</span>) ADDRESS of <span class="string">&quot;Helloworld!!&quot;</span>;</span><br><span class="line">initproc-&gt;tf.tf_eip = (<span class="type">uint32_t</span>)kernel_thread_entry;</span><br><span class="line">initproc-&gt;tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">initproc-&gt;tf.tf_esp = esp;</span><br><span class="line">initproc-&gt;tf.tf_eflags |= FL_IF;</span><br></pre></td></tr></table></figure></p>
<p>设置好中断帧后，最后就是设置initproc的进程上下文。uCore调度器选择了initproc执行，需要根据initproc-&gt;context中保存的执行现场来恢复initproc的执行。这里设置了initproc的执行现场中主要的两个信息：</p>
<ul>
<li>上次停止执行时的下一条指令地址context.eip</li>
<li>上次停止执行时的堆栈地址context.esp。</li>
</ul>
<p>可以看出，由于initproc的中断帧占用了实际给initproc分配的栈空间的顶部，所以initproc就只能把栈顶指针context.esp设置在initproc的中断帧的起始位置。根据context.eip的赋值，可以知道initproc实际开始执行的地方在forkret函数（主要完成do_fork函数返回的处理工作）处。至此，initproc内核线程已经做好准备执行了。</p>
<h3 id="调度并执行内核线程-initproc"><a href="#调度并执行内核线程-initproc" class="headerlink" title="调度并执行内核线程 initproc"></a>调度并执行内核线程 initproc</h3><p>在uCore执行完proc_init函数后，就创建好了两个内核线程：<code>idleproc</code>和<code>initproc</code>，这时uCore当前的执行现场就是idleproc，等到执行到init函数的最后一个函数cpu_idle之前，uCore的所有初始化工作就结束了，idleproc将通过执行cpu_idle函数让出CPU，给其它内核线程执行，具体过程如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">cpu_idle</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;need_resched) &#123;</span><br><span class="line">            schedule();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先，判断当前内核线程idleproc的need_resched是否不为0，idleproc中的need_resched本就置为1，所以会马上调用schedule函数找其他处于“就绪”态的进程执行。uCore的调度器为FIFO调度器，其核心就是schedule函数。它的执行逻辑很简单：</p>
<ul>
<li>设置当前内核线程current-&gt;need_resched为0；</li>
<li>在proc_list队列中查找下一个处于“就绪”态的线程或进程；</li>
<li>找到这样的进程后，就调用proc_run函数，保存当前进程current的上下文，恢复新进程的执行现场，完成进程切换。</li>
</ul>
<p>uCore通过proc_run和进一步的switch_to函数完成两个执行现场的切换，具体流程如下：</p>
<ul>
<li>让current指向next内核线程initproc；</li>
<li>设置任务状态段ts中特权态0下的栈顶指针esp0为next内核线程initproc的内核栈的栈顶，即next-&gt;kstack + KSTACKSIZE；</li>
<li>设置CR3寄存器的值为next内核线程initproc的页目录表起始地址next-&gt;cr3，这实际上是完成进程间的页表切换；</li>
<li>由switch_to函数完成具体的两个线程的执行现场切换，即切换各个寄存器，当switch_to函数执行完“ret”指令后，就切换到initproc执行了。</li>
</ul>
<p>注意，在第二步设置任务状态段ts中特权态0下的栈顶指针esp0的目的是<strong>建立好内核线程</strong>或<strong>将来用户线程在执行特权态切换（从特权态0&lt;—&gt;特权态3，或从特权态3&lt;—&gt;特权态0）时能够正确定位处于特权态0时进程的内核栈的栈顶</strong>，而这个栈顶其实放了一个trapframe结构的内存空间。如果是在特权态3发生了中断/异常/系统调用，则CPU会从特权态3—&gt;特权态0，且CPU从此栈顶（当前被打断进程的内核栈顶）开始压栈来保存被中断/异常/系统调用打断的用户态执行现场；如果是在特权态0发生了中断/异常/系统调用，则CPU会从从当前内核栈指针esp所指的位置开始压栈保存被中断/异常/系统调用打断的内核态执行现场。反之，当执行完对中断/异常/系统调用打断的处理后，最后会执行一个“iret”指令。在执行此指令之前，CPU的当前栈指针esp一定指向上次产生中断/异常/系统调用时CPU保存的被打断的指令地址CS和EIP，“iret”指令会根据ESP所指的保存的址CS和EIP恢复到上次被打断的地方继续执行。</p>
<p>第四步proc_run函数调用switch_to函数，参数是前一个进程和后一个进程的执行现场。</p>
<p>switch.S中的switch_to函数的执行流程：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.globl switch_to</span><br><span class="line">switch_to: # switch_to(from, to)</span><br><span class="line">### save from&#x27;s registers ###</span><br><span class="line">movl 4(%esp), %eax # eax points to from</span><br><span class="line">popl 0(%eax)</span><br><span class="line"># esp--&gt; return address, so save return addr in FROM’s context</span><br><span class="line">保存前一个进程的执行现场，前两条汇编指令保存了进程在返回switch_to函数后的指令地址到context.eip中</span><br><span class="line"></span><br><span class="line">movl %esp, 4(%eax)</span><br><span class="line">……</span><br><span class="line">movl %ebp, 28(%eax)</span><br><span class="line"> 7条汇编指令完成了保存前一个进程的其他7个寄存器到context中的相应成员变量中</span><br><span class="line"></span><br><span class="line">### restore to&#x27;s registers ###</span><br><span class="line"> 恢复下一个进程的执行现场，这其实就是上述保存过程的逆执行过程</span><br><span class="line">movl 4(%esp), %eax # not 8(%esp): popped return address already</span><br><span class="line"># eax now points to to</span><br><span class="line"></span><br><span class="line">movl 28(%eax), %ebp</span><br><span class="line">……</span><br><span class="line">movl 4(%eax), %esp</span><br><span class="line"> 从context的高地址的成员变量ebp开始，逐一把相关成员变量的值赋值给对应的寄存器</span><br><span class="line"></span><br><span class="line">pushl 0(%eax) </span><br><span class="line"># push TO’s context’s eip, so return addr = TO’s eip</span><br><span class="line"> 把context中保存的下一个进程要执行的指令地址context.eip放到了堆栈顶</span><br><span class="line"></span><br><span class="line">ret </span><br><span class="line"> after ret, eip= TO’s eip</span><br><span class="line"> 把栈顶的内容赋值给EIP寄存器，这样就切换到下一个进程执行了，即当前进程已经是下一个进程了</span><br></pre></td></tr></table></figure><br>uCore会执行进程切换，让initproc执行。在对initproc进行初始化时，设置了initproc-&gt;context.eip = (uintptr_t)forkret，这样，当执行switch_to函数并返回后，initproc将执行其实际上的执行入口地址forkret。而forkret会调用位于kern/trap/trapentry.S中的forkrets函数执行，具体代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.globl __trapret</span><br><span class="line"> __trapret:</span><br><span class="line"> # restore registers from stack</span><br><span class="line"> popal</span><br><span class="line"> # restore %ds and %es</span><br><span class="line"> popl %es</span><br><span class="line"> popl %ds</span><br><span class="line"> # get rid of the trap number and error code</span><br><span class="line"> addl $0x8, %esp</span><br><span class="line"> iret</span><br><span class="line"></span><br><span class="line"> .globl forkrets</span><br><span class="line"> forkrets:</span><br><span class="line"> # set stack to this new process trapframe</span><br><span class="line"> movl 4(%esp), %esp </span><br><span class="line"> 把esp指向当前进程的中断帧，esp指向了current-&gt;tf.tf_eip</span><br><span class="line"> </span><br><span class="line"> jmp __trapret</span><br></pre></td></tr></table></figure><br>如果此时执行的是initproc，则current-&gt;tf.tf_eip=kernel_thread_entry，initproc-&gt;tf.tf_cs = KERNEL_CS，所以当执行完iret后，就开始在内核中执行kernel_thread_entry函数了。</p>
<p>而initproc-&gt;tf.tf_regs.reg_ebx = init_main，所以在kernl_thread_entry中执行“call %ebx”后，就开始执行initproc的主体了。Initprocde的主体函数很简单就是输出一段字符串，然后就返回到kernel_tread_entry函数，并进一步调用do_exit执行退出操作了。</p>
<h2 id="练习1：分配并初始化一个进程控制块"><a href="#练习1：分配并初始化一个进程控制块" class="headerlink" title="练习1：分配并初始化一个进程控制块"></a>练习1：分配并初始化一个进程控制块</h2><p>alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结 构，用于存储新建立的内核线程的管理信息。比较简单，state、pid和cr3需要考虑，其他的无脑赋0和memset一波带走就行<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static struct proc_struct *</span><br><span class="line">alloc_proc(void) &#123;</span><br><span class="line">    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));</span><br><span class="line">    if (proc != NULL) &#123;</span><br><span class="line">    //LAB4:EXERCISE1 YOUR CODE</span><br><span class="line">    /*</span><br><span class="line">     * below fields in proc_struct need to be initialized</span><br><span class="line">     *       enum proc_state state;                      // Process state</span><br><span class="line">     *       int pid;                                    // Process ID</span><br><span class="line">     *       int runs;                                   // the running times of Proces</span><br><span class="line">     *       uintptr_t kstack;                           // Process kernel stack</span><br><span class="line">     *       volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?</span><br><span class="line">     *       struct proc_struct *parent;                 // the parent process</span><br><span class="line">     *       struct mm_struct *mm;                       // Process&#x27;s memory management field</span><br><span class="line">     *       struct context context;                     // Switch here to run process</span><br><span class="line">     *       struct trapframe *tf;                       // Trap frame for current interrupt</span><br><span class="line">     *       uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)</span><br><span class="line">     *       uint32_t flags;                             // Process flag</span><br><span class="line">     *       char name[PROC_NAME_LEN + 1];               // Process name</span><br><span class="line">     */</span><br><span class="line">        proc-&gt;state = PROC_UNINIT;</span><br><span class="line">        proc-&gt;pid = -1;</span><br><span class="line">        proc-&gt;cr3 = boot_cr3;</span><br><span class="line">       </span><br><span class="line">        proc-&gt;runs = 0;</span><br><span class="line">        proc-&gt;kstack = 0;</span><br><span class="line">        proc-&gt;need_resched = 0;</span><br><span class="line">        proc-&gt;parent = NULL;</span><br><span class="line">        proc-&gt;mm = NULL;</span><br><span class="line">        memset(&amp;proc-&gt;context, 0, sizeof(struct context)); </span><br><span class="line">        proc-&gt;tf = NULL;</span><br><span class="line">        proc-&gt;flags = 0;</span><br><span class="line">        memset(proc-&gt;name, 0, PROC_NAME_LEN);		</span><br><span class="line">    &#125;</span><br><span class="line">    return proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是啥？</p>
<p>结构体中存储了除eax之外的所有通用寄存器以及eip的数值，保存了线程运行的上下文信息；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> eip;</span><br><span class="line">    <span class="type">uint32_t</span> esp;</span><br><span class="line">    <span class="type">uint32_t</span> ebx;</span><br><span class="line">    <span class="type">uint32_t</span> ecx;</span><br><span class="line">    <span class="type">uint32_t</span> edx;</span><br><span class="line">    <span class="type">uint32_t</span> esi;</span><br><span class="line">    <span class="type">uint32_t</span> edi;</span><br><span class="line">    <span class="type">uint32_t</span> ebp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>context用于内核线程之间切换时，保存原先线程运行的上下文</p>
<p><code>struct trapframe *tf</code>的作用：</p>
<ul>
<li>在copy_thread函数中对tf进行了设置。在这个函数中，把context变量的esp设置成tf变量的地址，把eip设置成forkret函数指针。</li>
<li>forkret函数调用了__trapret进行中断返回，tf变量用于构造出新线程时，正确地将控制权转交给新的线程。</li>
</ul>
<h2 id="练习2：为新创建的内核线程分配资源"><a href="#练习2：为新创建的内核线程分配资源" class="headerlink" title="练习2：为新创建的内核线程分配资源"></a>练习2：为新创建的内核线程分配资源</h2><p>创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用do_fork函数完成具体内核线程的创建工作。do_fork函数会调用alloc_proc函数来分配并初始化一个进程控制块，但alloc_proc只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。</p>
<p>ucore一般通过do_fork实际创建新的内核线程。do_fork的作用是：</p>
<blockquote>
<p>创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。为内核线程创建新的线程控制块，并且对控制块中的每个成员变量进行正确的设置，使得之后可以正确切换到对应的线程中执行。练习2完成了在kern/process/proc.c中的do_fork函数中的处理过程。它的大致执行步骤包括：</p>
</blockquote>
<ul>
<li>调用alloc_proc，首先获得一块用户信息块。</li>
<li>为进程分配一个内核栈。</li>
<li>复制原进程的内存管理信息到新进程（但内核线程不必做此事）</li>
<li>复制原进程上下文到新进程</li>
<li>将新进程添加到进程列表</li>
<li>唤醒新进程</li>
<li>返回新进程号</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* do_fork -     parent process for a new child process</span></span><br><span class="line"><span class="comment"> * @clone_flags: used to guide how to clone the child process</span></span><br><span class="line"><span class="comment"> * @stack:       the parent&#x27;s user stack pointer. if stack==0, It means to fork a kernel thread.</span></span><br><span class="line"><span class="comment"> * @tf:          the trapframe info, which will be copied to child process&#x27;s proc-&gt;tf</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">do_fork</span><span class="params">(<span class="type">uint32_t</span> clone_flags, <span class="type">uintptr_t</span> <span class="built_in">stack</span>, <span class="keyword">struct</span> trapframe *tf)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="comment">//LAB4:EXERCISE2 YOUR CODE</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation.</span></span><br><span class="line"><span class="comment">     * MACROs or Functions:</span></span><br><span class="line"><span class="comment">     *   alloc_proc:   create a proc struct and init fields (lab4:exercise1)</span></span><br><span class="line"><span class="comment">     *                 创建进程并初始化</span></span><br><span class="line"><span class="comment">     *   setup_kstack: alloc pages with size KSTACKPAGE as process kernel stack</span></span><br><span class="line"><span class="comment">     *                 创建页，大小为KSTACKPAGE，并作为进程的内核栈</span></span><br><span class="line"><span class="comment">     *   copy_mm:      process &quot;proc&quot; duplicate OR share process &quot;current&quot;&#x27;s mm according clone_flags</span></span><br><span class="line"><span class="comment">     *                 if clone_flags &amp; CLONE_VM, then &quot;share&quot; ; else &quot;duplicate&quot;</span></span><br><span class="line"><span class="comment">     *                 进程复制memory manager，根据clone_flag不同决定不同操作</span></span><br><span class="line"><span class="comment">     *   copy_thread:  setup the trapframe on the  process&#x27;s kernel stack top and</span></span><br><span class="line"><span class="comment">     *                 setup the kernel entry point and stack of process</span></span><br><span class="line"><span class="comment">     *                 在进程内核栈顶建立trapframe</span></span><br><span class="line"><span class="comment">     *   hash_proc:    add proc into proc hash_list</span></span><br><span class="line"><span class="comment">     *                 添加进程到hash_list中</span></span><br><span class="line"><span class="comment">     *   get_pid:      alloc a unique pid for process</span></span><br><span class="line"><span class="comment">     *                 为进程分配一个独特的pid</span></span><br><span class="line"><span class="comment">     *   wakeup_proc:  set proc-&gt;state = PROC_RUNNABLE</span></span><br><span class="line"><span class="comment">     * VARIABLES:</span></span><br><span class="line"><span class="comment">     *   proc_list:    the process set&#x27;s list</span></span><br><span class="line"><span class="comment">     *   nr_process:   the number of process set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. call alloc_proc to allocate a proc_struct</span></span><br><span class="line">    <span class="comment">// 为要创建的新的线程分配线程控制块的空间</span></span><br><span class="line">    proc = alloc_proc();</span><br><span class="line">    <span class="keyword">if</span>(proc == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    <span class="comment">// 判断是否分配到内存空间</span></span><br><span class="line">    <span class="comment">// 2. call setup_kstack to allocate a kernel stack for child process</span></span><br><span class="line">    <span class="comment">// 为新的线程设置栈，在本实验中，每个线程的栈的大小初始均为2个Page, 即8KB</span></span><br><span class="line">    <span class="type">int</span> status = setup_kstack(proc);</span><br><span class="line">    <span class="keyword">if</span>(status != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    <span class="comment">// 3. call copy_mm to dup OR share mm according clone_flag</span></span><br><span class="line">    <span class="comment">// 对虚拟内存空间进行拷贝，由于在本实验中，内核线程之间共享一个虚拟内存空间，因此实际上该函数不需要进行任何操作</span></span><br><span class="line">    status = copy_mm(clone_flags, proc);</span><br><span class="line">    <span class="keyword">if</span>(status != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    <span class="comment">// 4. call copy_thread to setup tf &amp; context in proc_struct</span></span><br><span class="line">    <span class="comment">// 在新创建的内核线程的栈上面设置伪造好的中端帧，便于后文中利用iret命令将控制权转移给新的线程</span></span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf);</span><br><span class="line">    <span class="comment">// 5. insert proc_struct into hash_list &amp;&amp; proc_list</span></span><br><span class="line">    <span class="comment">// 为新的线程创建pid</span></span><br><span class="line">    proc-&gt;pid = get_pid();</span><br><span class="line">    hash_proc(proc);</span><br><span class="line">    <span class="comment">// 将线程放入使用hash组织的链表中，便于加速以后对某个指定的线程的查找</span></span><br><span class="line">    nr_process ++;</span><br><span class="line">    <span class="comment">// 将全局线程的数目加1</span></span><br><span class="line">    list_add(&amp;proc_list, &amp;proc-&gt;list_link);</span><br><span class="line">    <span class="comment">// 将线程加入到所有线程的链表中，便于进行调度</span></span><br><span class="line">    <span class="comment">// 6. call wakeup_proc to make the new child process RUNNABLE</span></span><br><span class="line">    <span class="comment">// 唤醒该线程，即将该线程的状态设置为可以运行</span></span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line">    <span class="comment">// 7. set ret vaule using child proc&#x27;s pid</span></span><br><span class="line">    <span class="comment">// 返回新线程的pid</span></span><br><span class="line">    ret = proc-&gt;pid;</span><br><span class="line">fork_out:     </span><br></pre></td></tr></table></figure>
<p>请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。</p>
<p>可以。ucore中为fork的线程分配pid的函数为get_pid：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get_pid - alloc a unique pid for process</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_pid</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(MAX_PID &gt; MAX_PROCESS);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="type">list_entry_t</span> *<span class="built_in">list</span> = &amp;proc_list, *le;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> next_safe = MAX_PID, last_pid = MAX_PID;</span><br><span class="line">    <span class="keyword">if</span> (++ last_pid &gt;= MAX_PID) &#123;</span><br><span class="line">        last_pid = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> inside;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (last_pid &gt;= next_safe) &#123;</span><br><span class="line">    inside:</span><br><span class="line">        next_safe = MAX_PID;</span><br><span class="line">    repeat:</span><br><span class="line">        le = <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">while</span> ((le = list_next(le)) != <span class="built_in">list</span>) &#123;</span><br><span class="line">            proc = le2proc(le, list_link);</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;pid == last_pid) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++ last_pid &gt;= next_safe) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (last_pid &gt;= MAX_PID) &#123;</span><br><span class="line">                        last_pid = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    next_safe = MAX_PID;</span><br><span class="line">                    <span class="keyword">goto</span> repeat;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (proc-&gt;pid &gt; last_pid &amp;&amp; next_safe &gt; proc-&gt;pid) &#123;</span><br><span class="line">                next_safe = proc-&gt;pid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last_pid;</span><br><span class="line">&#125;            	</span><br></pre></td></tr></table></figure><br>如果有严格的next_safe &gt; last_pid + 1，那么可以直接取last_pid + 1作为新的pid（需要last_pid没有超出MAX_PID从而变成1），</p>
<p>如果在进入函数的时候，这两个变量之后没有合法的取值，也就是说next_safe &gt; last_pid + 1不成立，那么进入循环，在循环之中首先通过if(proc-&gt;pid == last_pid)这一分支确保了不存在任何进程的pid与last_pid重合，然后再通过if (proc-&gt;pid &gt; last_pid &amp;&amp; next_safe &gt; proc-&gt;pid)这一判断语句保证了不存在任何已经存在的pid满足：last_pid&lt; pid &lt; next_safe，这样就确保了最后能够找到这么一个满足条件的区间，获得合法的pid；</p>
<h2 id="练习3：阅读代码，理解-proc-run-函数和它调用的函数如何完成进程切换的。"><a href="#练习3：阅读代码，理解-proc-run-函数和它调用的函数如何完成进程切换的。" class="headerlink" title="练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的。"></a>练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的。</h2><p>唯一调用到这个函数是在线程调度器的schedule函数中，proc_run将proc加载到CPU<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proc_run - make process &quot;proc&quot; running on cpu</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> before call switch_to, should load  base addr of &quot;proc&quot;&#x27;s new PDT</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">proc_run</span><span class="params">(<span class="keyword">struct</span> proc_struct *proc)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断需要运行的线程是否是正在运行的线程</span></span><br><span class="line">    <span class="keyword">if</span> (proc != current) &#123; </span><br><span class="line">        <span class="type">bool</span> intr_flag;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">prev</span> =</span> current, *next = proc;</span><br><span class="line">        <span class="comment">//如果不是的话，获取到切换前后的两个线程</span></span><br><span class="line">        local_intr_save(intr_flag);</span><br><span class="line">        <span class="comment">// 关闭中断</span></span><br><span class="line">        &#123;</span><br><span class="line">            current = proc;</span><br><span class="line">            load_esp0(next-&gt;kstack + KSTACKSIZE);</span><br><span class="line">            lcr3(next-&gt;cr3);</span><br><span class="line">            <span class="comment">// 设置了TSS和cr3，相当于是切换了页表和栈</span></span><br><span class="line">            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</span><br><span class="line">            <span class="comment">// switch_to恢复要运行的线程的上下文，然后由于恢复的上下文中已经将返回地址（copy_thread函数中完成）修改成了forkret函数的地址(如果这个线程是第一运行的话，否则就是切换到这个线程被切换出来的地址)，也就是会跳转到这个函数，最后进一步跳转到了__trapsret函数，调用iret最终将控制权切换到新的线程；</span></span><br><span class="line">        &#125;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">        <span class="comment">// 使能中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>forkret函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forkret -- the first kernel entry point of a new thread/process</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> the addr of forkret is setted in copy_thread function</span></span><br><span class="line"><span class="comment">//       after switch_to, the current proc will execute here.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">forkret</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    forkrets(current-&gt;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在本实验的执行过程中，创建且运行了几个内核线程？</p>
<p>总共创建了两个内核线程，分别为：</p>
<ul>
<li>idleproc: 最初的内核线程，在完成新的内核线程的创建以及各种初始化工作之后，进入死循环，用于调度其他线程；</li>
<li>initproc: 被创建用于打印”Hello World”的线程；</li>
</ul>
<p>语句 local_intr_save(intr_flag);….local_intr_restore(intr_flag);说明理由在这里有何作用? 请说明理由。</p>
<ul>
<li>关闭中断，使得在这个语句块内的内容不会被中断打断，是一个原子操作；</li>
<li>在proc_run函数中，将current指向了要切换到的线程，但是此时还没有真正将控制权转移过去，如果在这个时候出现中断打断这些操作，就会出现current中保存的并不是正在运行的线程的中断控制块，从而出现错误。</li>
</ul>
<h1 id="实验五"><a href="#实验五" class="headerlink" title="实验五"></a>实验五</h1><h2 id="实验目的-1"><a href="#实验目的-1" class="headerlink" title="实验目的"></a>实验目的</h2><p>了解第一个用户进程创建过程<br>了解系统调用框架的实现机制<br>了解ucore如何实现系统调用sys_fork/sys_exec/sys_exit/sys_wait来进行进程管理  </p>
<h2 id="实验内容-2"><a href="#实验内容-2" class="headerlink" title="实验内容"></a>实验内容</h2><p>实验4的线程运行都在内核态。实验5创建了用户进程，让用户进程在用户态执行，且在需要ucore支持时，可通过系统调用来让ucore提供服务。为此需要构造出第一个用户进程，并通过系统调用sys_fork/sys_exec/sys_exit/sys_wait来支持运行不同的应用程序，完成对用户进程的执行过程的基本管理。</p>
<h2 id="预备知识-1"><a href="#预备知识-1" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="实验执行流程概述"><a href="#实验执行流程概述" class="headerlink" title="实验执行流程概述"></a>实验执行流程概述</h3><p>提供各种操作系统功能的<strong>内核线程只能在CPU核心态运行是操作系统自身的要求</strong>，操作系统就要呆在核心态，才能管理整个计算机系统。ucore提供了用户态进程的创建和执行机制，给应用程序执行提供一个用户态运行环境。显然，由于进程的执行空间扩展到了用户态空间，且出现了创建子进程执行应用程序等与lab4有较大不同的地方，所以具体实现的不同主要集中在<strong>进程管理</strong>和<strong>内存管理部分</strong>。</p>
<p>首先，我们从ucore的初始化部分来看，kern_init中调用的物理内存初始化，进程管理初始化等都有一定的变化。在内存管理部分，与lab4最大的区别就是<strong>增加用户态虚拟内存的管理</strong>。</p>
<ul>
<li>首先为了管理用户态的虚拟内存，需要对页表的内容进行扩展，能够<strong>把部分物理内存映射为用户态虚拟内存</strong>。如果某进程执行过程中，CPU在用户态下执行（在CS段寄存器最低两位包含有一个2位的优先级域，如果为0，表示CPU运行在特权态；如果为3，表示CPU运行在用户态。），则可以访问本进程页表描述的用户态虚拟内存，但由于权限不够，不能访问内核态虚拟内存。</li>
<li>另一方面，在用户态内存空间和内核态内核空间之间需要拷贝数据，让<strong>CPU处在内核态才能完成对用户空间的读或写</strong>，为此需要设计专门的拷贝函数（copy_from_user和copy_to_user）完成。但反之则会导致违反CPU的权限管理，导致内存访问异常。</li>
<li>在进程管理方面，主要涉及到的是进程控制块中与内存管理相关的部分，包括建立进程的页表和维护进程可访问空间（可能还没有建立虚实映射关系）的信息；</li>
<li>加载一个ELF格式的程序到进程控制块管理的内存中的方法；</li>
<li>在进程复制（fork）过程中，把父进程的内存空间拷贝到子进程内存空间的技术；</li>
<li>另外一部分与用户态进程生命周期管理相关，包括让进程放弃CPU而睡眠等待某事件、让父进程等待子进程结束、一个进程杀死另一个进程、给进程发消息、建立进程的血缘关系链表。</li>
</ul>
<p>在用户进程管理中，首先，构造出第一个进程idle_proc，作为所有后续进程的祖先；然后，在proc_init函数中，对idle_proc进行进一步初始化，通过alloc把当前ucore的执行环境转变成idle内核线程的执行现场；然后调用kernl_thread来创建第二个内核线程init_main，而init_main内核线程有创建了user_main内核线程。到此，内核线程创建完毕。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proc_init - set up the first kernel thread idleproc &quot;idle&quot; by itself and</span></span><br><span class="line"><span class="comment">//           - create the second kernel thread init_main</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    list_init(&amp;proc_list);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HASH_LIST_SIZE; i ++) &#123;</span><br><span class="line">        list_init(hash_list + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((idleproc = alloc_proc()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;cannot alloc idleproc.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idleproc-&gt;pid = <span class="number">0</span>;</span><br><span class="line">    idleproc-&gt;state = PROC_RUNNABLE;</span><br><span class="line">    idleproc-&gt;kstack = (<span class="type">uintptr_t</span>)bootstack;</span><br><span class="line">    idleproc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">    set_proc_name(idleproc, <span class="string">&quot;idle&quot;</span>);</span><br><span class="line">    nr_process ++;</span><br><span class="line"></span><br><span class="line">    current = idleproc;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = kernel_thread(init_main, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;create init_main failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initproc = find_proc(pid);</span><br><span class="line">    set_proc_name(initproc, <span class="string">&quot;init&quot;</span>);</span><br><span class="line"></span><br><span class="line">    assert(idleproc != <span class="literal">NULL</span> &amp;&amp; idleproc-&gt;pid == <span class="number">0</span>);</span><br><span class="line">    assert(initproc != <span class="literal">NULL</span> &amp;&amp; initproc-&gt;pid == <span class="number">1</span>);</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure></p>
<p>接下来是用户进程的创建过程。第一步实际上是通过user_main函数调用kernel_tread创建子进程，通过kernel_execve调用来把某一具体程序的执行内容放入内存。</p>
<p>具体的放置方式是根据<strong>ld在此文件上的地址分配</strong>为基本原则，把程序的不同部分放到某进程的用户空间中，从而通过此进程来完成程序描述的任务。一旦执行了这一程序对应的进程，就会从内核态切换到用户态继续执行。</p>
<p>以此类推：</p>
<blockquote>
<p><strong>CPU在用户空间执行的用户进程，其地址空间不会被其他用户的进程影响，但由于系统调用（用户进程直接获得操作系统服务的唯一通道）、外设中断和异常中断的会随时产生，从而间接推动了用户进程实现用户态到到内核态的切换工作。当进程执行结束后，需回收进程占用和没消耗完毕的设备整个过程，且为新的创建进程请求提供服务。</strong></p>
</blockquote>
<h3 id="创建用户进程"><a href="#创建用户进程" class="headerlink" title="创建用户进程"></a>创建用户进程</h3><h4 id="应用程序的组成和编译"><a href="#应用程序的组成和编译" class="headerlink" title="应用程序的组成和编译"></a>应用程序的组成和编译</h4><p>lab5中新增了一个文件夹user，其中是用于本实验的用户程序。如hello.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ulib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    cprintf(<span class="string">&quot;Hello world!!.\n&quot;</span>);</span><br><span class="line">    cprintf(<span class="string">&quot;I am process %d.\n&quot;</span>, getpid());</span><br><span class="line">    cprintf(<span class="string">&quot;hello pass.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>按照手册，注释掉Makefile的第六行，编译，（部分）输出如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">gcc -Iuser/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  </span><br><span class="line">-fno-stack-protector -Ilibs/ -Iuser/include/ -Iuser/libs/ -c user/pgdir.c -o obj/user/pgdir.o</span><br><span class="line"></span><br><span class="line">ld -m    elf_i386 -nostdlib -T tools/user.ld -o obj/__user_pgdir.out  </span><br><span class="line">  obj/user/libs/panic.o obj/user/libs/syscall.o obj/user/libs/ulib.o </span><br><span class="line">  obj/user/libs/initcode.o obj/user/libs/stdio.o obj/user/libs/umain.o  </span><br><span class="line">  obj/libs/string.o obj/libs/printfmt.o obj/libs/hash.o obj/libs/rand.o obj/user/pgdir.o</span><br><span class="line"></span><br><span class="line">+ ld bin/kernel</span><br><span class="line">ld -m elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  </span><br><span class="line">  obj/kern/init/entry.o obj/kern/init/init.o obj/kern/libs/stdio.o </span><br><span class="line">  obj/kern/libs/readline.o obj/kern/debug/panic.o obj/kern/debug/kdebug.o</span><br><span class="line">  obj/kern/debug/kmonitor.o obj/kern/driver/ide.o obj/kern/driver/clock.o </span><br><span class="line">  obj/kern/driver/console.o obj/kern/driver/picirq.o obj/kern/driver/intr.o </span><br><span class="line">  obj/kern/trap/trap.o obj/kern/trap/vectors.o obj/kern/trap/trapentry.o </span><br><span class="line">  obj/kern/mm/pmm.o obj/kern/mm/swap_fifo.o obj/kern/mm/vmm.o obj/kern/mm/kmalloc.o </span><br><span class="line">  obj/kern/mm/swap.o obj/kern/mm/default_pmm.o obj/kern/fs/swapfs.o obj/kern/process/entry.o </span><br><span class="line">  obj/kern/process/switch.o obj/kern/process/proc.o obj/kern/schedule/sched.o </span><br><span class="line">  obj/kern/syscall/syscall.o  obj/libs/string.o obj/libs/printfmt.o obj/libs/hash.o obj/libs/rand.o </span><br><span class="line">  -b binary  obj/__user_badarg.out obj/__user_forktree.out obj/__user_faultread.out obj/__user_divzero.out </span><br><span class="line">  obj/__user_exit.out obj/__user_hello.out obj/__user_waitkill.out obj/__user_softint.out obj/__user_spin.out</span><br><span class="line">  obj/__user_yield.out obj/__user_badsegment.out obj/__user_testbss.out obj/__user_faultreadkernel.out </span><br><span class="line">  obj/__user_forktest.out obj/__user_pgdir.out</span><br></pre></td></tr></table></figure><br>从中可以看出，hello应用程序不仅仅是hello.c，还包含了支持hello应用程序的用户态库：</p>
<ul>
<li>user/libs/initcode.S：所有应用程序的起始用户态执行地址“_start”，调整了EBP和ESP后，调用umain函数。</li>
<li>user/libs/umain.c：实现了umain函数，这是所有应用程序执行的第一个C函数，它将调用应用程序的main函数，并在main函数结束后调用exit函数，而exit函数最终将调用sys_exit系统调用，让操作系统回收进程资源。</li>
<li>user/libs/ulib.[ch]：实现了最小的C函数库，除了一些与系统调用无关的函数，其他函数是对访问系统调用的包装。</li>
<li>user/libs/syscall.[ch]：用户层发出系统调用的具体实现。</li>
<li>user/libs/stdio.c：实现cprintf函数，通过系统调用sys_putc来完成字符输出。</li>
<li>user/libs/panic.c：实现__panic/__warn函数，通过系统调用sys_exit完成用户进程退出。</li>
</ul>
<p>在make的最后一步执行了一个ld命令，把hello应用程序的执行码obj/__user_hello.out连接在了ucore kernel的末尾。且ld命令会在kernel中会把__user_hello.out的位置和大小记录在全局变量<strong>_binary_obj___user_hello_out_start</strong>和<strong>_binary_obj___user_hello_out_size</strong>中，这样这个hello用户程序就能够和ucore内核一起被 bootloader加载到内存里中，并且通过这两个全局变量定位hello用户程序执行码的起始位置和大小。</p>
<h4 id="用户进程的虚拟地址空间"><a href="#用户进程的虚拟地址空间" class="headerlink" title="用户进程的虚拟地址空间"></a>用户进程的虚拟地址空间</h4><p>在tools/user.ld描述了用户程序的用户虚拟空间的执行入口虚拟地址：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    /* Load programs at this address: &quot;.&quot; means the current address */</span><br><span class="line">    . = 0x800020;</span><br></pre></td></tr></table></figure></p>
<p>在tools/kernel.ld描述了操作系统的内核虚拟空间的起始入口虚拟地址：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    /* Load the kernel at this address: &quot;.&quot; means the current address */</span><br><span class="line">    . = 0xC0100000;</span><br></pre></td></tr></table></figure><br>这样ucore把用户进程的虚拟地址空间分了两块:</p>
<ul>
<li>一块与内核线程一样，是所有用户进程都共享的内核虚拟地址空间，映射到同样的物理内存空间中，这样在物理内存中只需放置一份内核代码，使得用户进程从用户态进入核心态时，内核代码可以统一应对不同的内核程序；</li>
<li>另外一块是用户虚拟地址空间，虽然虚拟地址范围一样，但映射到不同且没有交集的物理内存空间中。这样当ucore把用户进程的执行代码（即应用程序的执行代码）和数据（即应用程序的全局变量等）放到用户虚拟地址空间中时，确保了各个进程不会“非法”访问到其他进程的物理内存空间。</li>
</ul>
<p>这样ucore给一个用户进程具体设定的虚拟内存空间（kern/mm/memlayout.h）如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> Virtual memory map:                                          Permissions</span><br><span class="line">                                                              kernel/user</span><br><span class="line"></span><br><span class="line">     4G ------------------&gt; +---------------------------------+</span><br><span class="line">                            |                                 |</span><br><span class="line">                            |         Empty Memory (*)        |</span><br><span class="line">                            |                                 |</span><br><span class="line">                            +---------------------------------+ 0xFB000000</span><br><span class="line">                            |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE</span><br><span class="line">     VPT -----------------&gt; +---------------------------------+ 0xFAC00000</span><br><span class="line">                            |        Invalid Memory (*)       | --/--</span><br><span class="line">     KERNTOP -------------&gt; +---------------------------------+ 0xF8000000</span><br><span class="line">                            |                                 |</span><br><span class="line">                            |    Remapped Physical Memory     | RW/-- KMEMSIZE</span><br><span class="line">                            |                                 |</span><br><span class="line">     KERNBASE ------------&gt; +---------------------------------+ 0xC0000000</span><br><span class="line">                            |        Invalid Memory (*)       | --/--</span><br><span class="line">     USERTOP -------------&gt; +---------------------------------+ 0xB0000000</span><br><span class="line">                            |           User stack            |</span><br><span class="line">                            +---------------------------------+</span><br><span class="line">                            |                                 |</span><br><span class="line">                            :                                 :</span><br><span class="line">                            |         ~~~~~~~~~~~~~~~~        |</span><br><span class="line">                            |         ~~~~~~~~~~~~~~~~        |</span><br><span class="line">                            :                                 :</span><br><span class="line">                            |                                 |</span><br><span class="line">                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">                            |       User Program &amp; Heap       |</span><br><span class="line">     UTEXT ---------------&gt; +---------------------------------+ 0x00800000</span><br><span class="line">                            |        Invalid Memory (*)       | --/--</span><br><span class="line">                            |  - - - - - - - - - - - - - - -  |</span><br><span class="line">                            |    User STAB Data (optional)    |</span><br><span class="line">     USERBASE, USTAB------&gt; +---------------------------------+ 0x00200000</span><br><span class="line">                            |        Invalid Memory (*)       | --/--</span><br><span class="line">     0 -------------------&gt; +---------------------------------+ 0x00000000</span><br><span class="line">(*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span><br><span class="line">    &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span><br><span class="line">    there if desired.</span><br><span class="line"></span><br><span class="line">*/                            </span><br></pre></td></tr></table></figure></p>
<h4 id="创建并执行用户进程"><a href="#创建并执行用户进程" class="headerlink" title="创建并执行用户进程"></a>创建并执行用户进程</h4><p>在确定了用户进程的执行代码和数据，以及用户进程的虚拟空间布局后，我们可以来创建用户进程了。在本实验中第一个用户进程是由第二个内核线程initproc通过把hello应用程序执行码覆盖到initproc的用户虚拟内存空间来创建的，相关代码如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// kernel_execve - do SYS_exec syscall to exec a user program called by user_main kernel_thread</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span></span><br><span class="line">    <span class="title function_">kernel_execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> <span class="type">char</span> *binary, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret, len = <span class="built_in">strlen</span>(name);</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;int %1;&quot;</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=a&quot;</span> (ret)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;i&quot;</span> (T_SYSCALL), <span class="string">&quot;0&quot;</span> (SYS_exec), <span class="string">&quot;d&quot;</span> (name), <span class="string">&quot;c&quot;</span> (len), <span class="string">&quot;b&quot;</span> (binary), <span class="string">&quot;D&quot;</span> (size)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> __KERNEL_EXECVE(name, binary, size) (&#123;                          \</span></span><br><span class="line"><span class="meta">            cprintf(<span class="string">&quot;kernel_execve: pid = %d, name = \&quot;%s\&quot;.\n&quot;</span>,        \</span></span><br><span class="line"><span class="meta">                    current-&gt;pid, name);                                \</span></span><br><span class="line"><span class="meta">            kernel_execve(name, binary, (size_t)(size));                \</span></span><br><span class="line"><span class="meta">        &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KERNEL_EXECVE(x) (&#123;                                             \</span></span><br><span class="line"><span class="meta">            extern unsigned char _binary_obj___user_##x##_out_start[],  \</span></span><br><span class="line"><span class="meta">                _binary_obj___user_##x##_out_size[];                    \</span></span><br><span class="line"><span class="meta">            __KERNEL_EXECVE(#x, _binary_obj___user_##x##_out_start,     \</span></span><br><span class="line"><span class="meta">                            _binary_obj___user_##x##_out_size);         \</span></span><br><span class="line"><span class="meta">        &#125;)</span></span><br><span class="line">……</span><br><span class="line"><span class="comment">// init_main - the second kernel thread used to create kswapd_main &amp; user_main kernel threads</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">init_main</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> TEST</span></span><br><span class="line">    KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    KERNEL_EXECVE(hello);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    panic(<span class="string">&quot;kernel_execve failed.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>##的作用是参数的连接，把“exit”这个字符串连接到这个宏中的x对应位置</strong><br><strong>#的作用是使一个东西字符串化</strong></p>
<p>Initproc的执行主体是init_main函数，这个函数在缺省情况下是执行宏KERNEL_EXECVE(hello)，而这个宏最终是调用kernel_execve函数来调用SYS_exec系统调用，由于ld在链接hello应用程序执行码时定义了两全局变量：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_binary_obj___user_hello_out_start：hello执行码的起始位置</span><br><span class="line">_binary_obj___user_hello_out_size中：hello执行码的大小</span><br></pre></td></tr></table></figure></p>
<p>kernel_execve把这两个变量作为SYS_exec系统调用的参数，让ucore来创建此用户进程。当ucore收到此系统调用后，将依次调用如下函数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector128(vectors.S) --&gt;</span><br><span class="line">__alltraps(trapentry.S) --&gt; trap(trap.c) --&gt; trap_dispatch(trap.c) --&gt; syscall(syscall.c) --&gt; sys_exec（syscall.c）--&gt; do_execve(proc.c)</span><br></pre></td></tr></table></figure><br>最终通过do_execve函数来完成用户进程的创建工作。此函数的主要工作流程如下：</p>
<ul>
<li>为加载新的执行码做好<strong>用户态内存空间清空</strong>准备。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。由于此处的initproc是内核线程，所以mm为NULL，整个处理都不会做。</li>
<li><strong>加载应用程序执行码到当前进程的新创建的用户态虚拟空间中</strong>。这里涉及到读ELF格式的文件，申请内存空间，建立用户态虚存空间，加载应用程序执行码等。load_icode函数完成了整个复杂的工作。</li>
<li>load_icode函数的主要工作就是给用户进程建立一个能够让用户进程正常运行的用户环境。此函数有一百多行，完成了如下重要工作：</li>
</ul>
<ol>
<li>调用mm_create函数来申请进程的内存管理数据结构mm所需内存空间，并对mm进行初始化；</li>
<li>调用setup_pgdir来申请一个页目录表所需的一个页大小的内存空间，并把描述ucore内核虚空间映射的内核页表（boot_pgdir所指）的内容拷贝到此新目录表中，最后让mm-&gt;pgdir指向此页目录表，这就是进程新的页目录表了，且能够正确映射内核虚空间；</li>
<li>根据应用程序执行码的起始位置来解析此ELF格式的执行程序，并调用mm_map函数根据ELF格式的执行程序说明的各个段（代码段、数据段、BSS段等）的起始位置和大小建立对应的vma结构，并把vma插入到mm结构中，从而表明了用户进程的合法用户态虚拟地址空间；</li>
<li>调用根据执行程序各个段的大小分配物理内存空间，并根据执行程序各个段的起始位置确定虚拟地址，并在页表中建立好物理地址和虚拟地址的映射关系，然后把执行程序各个段的内容拷贝到相应的内核虚拟地址中，至此应用程序执行码和数据已经根据编译时设定地址放置到虚拟内存中了；</li>
</ol>
<ul>
<li>需要<strong>给用户进程设置用户栈</strong>，为此调用mm_mmap函数建立用户栈的vma结构，明确用户栈的位置在用户虚空间的顶端，大小为256个页，即1MB，并分配一定数量的物理内存且建立好栈的虚地址&lt;—&gt;物理地址映射关系；</li>
<li>至此,进程内的内存管理vma和mm数据结构已经建立完成，于是把<strong>mm-&gt;pgdir赋值到cr3寄存器中</strong>，即<strong>更新了用户进程的虚拟内存空间</strong>，此时的initproc已经被hello的代码和数据覆盖，成为了第一个用户进程，但此时这个用户进程的执行现场还没建立好；</li>
<li>先清空进程的中断帧，再<strong>重新设置进程的中断帧</strong>，使得在执行中断返回指令“iret”后，能够让CPU转到用户态特权级，并回到用户态内存空间，使用用户态的代码段、数据段和堆栈，且能够跳转到用户进程的第一条指令执行，并确保在用户态能够响应中断；</li>
<li>至此，用户进程的用户环境已经搭建完毕。此时initproc将按产生系统调用的函数调用路径原路返回，执行中断返回指令“iret”（位于trapentry.S的最后一句）后，将切换到用户进程hello的第一条语句位置_start处（位于user/libs/initcode.S的第三句）开始执行。</li>
</ul>
<h4 id="进程退出和等待进程"><a href="#进程退出和等待进程" class="headerlink" title="进程退出和等待进程"></a>进程退出和等待进程</h4><p>ucore分了两步来完成进程退出工作，首先，进程本身完成大部分资源的占用内存回收工作，然后父进程完成剩余资源占用内存的回收工作。为何不让进程本身完成所有的资源回收工作呢？这是因为进程要执行回收操作，就表明此进程还存在，还在执行指令，这就需要内核栈的空间不能释放，且表示进程存在的进程控制块不能释放。所以需要父进程来帮忙释放子进程无法完成的这两个资源回收工作。</p>
<p>为此在用户态的函数库中提供了exit函数，此函数最终访问sys_exit系统调用接口让操作系统来帮助当前进程执行退出过程中的部分资源回收。</p>
<p>首先，exit函数会把一个退出码error_code传递给ucore，ucore通过执行内核函数do_exit来完成对当前进程的退出处理，主要工作是回收当前进程所占的大部分内存资源，并通知父进程完成最后的回收工作，具体流程如下：</p>
<ol>
<li>如果current-&gt;mm != NULL，表示是用户进程，则开始回收此用户进程所占用的用户态虚拟内存空间；</li>
</ol>
<ul>
<li>首先执行“lcr3(boot_cr3)”，切换到内核态的页表上，这样当前用户进程目前只能在内核虚拟地址空间执行了，这是为了确保后续释放用户态内存和进程页表的工作能够正常执行；</li>
<li>如果当前进程控制块的成员变量mm的成员变量mm_count减1后为0（表明这个mm没有再被其他进程共享，可以彻底释放进程所占的用户虚拟空间了。），则开始回收用户进程所占的内存资源：</li>
<li>调用exit_mmap函数释放current-&gt;mm-&gt;vma链表中每个vma描述的进程合法空间中实际分配的内存，然后把对应的页表项内容清空，最后还把页表所占用的空间释放并把对应的页目录表项清空；</li>
<li>调用put_pgdir函数释放当前进程的页目录所占的内存；</li>
<li>调用mm_destroy函数释放mm中的vma所占内存，最后释放mm所占内存；</li>
<li>此时设置current-&gt;mm为NULL，表示与当前进程相关的用户虚拟内存空间和对应的内存管理成员变量所占的内核虚拟内存空间已经回收完毕；</li>
</ul>
<ol>
<li>这时，设置当前进程的执行状态<code>current-&gt;state=PROC_ZOMBIE</code>，当前进程的退出码current-&gt;exit_code=error_code。此时当前进程已经不能被调度了，需要此进程的父进程来做最后的回收工作（即回收描述此进程的内核栈和进程控制块）；</li>
<li>如果当前进程的父进程current-&gt;parent处于等待子进程状态：<br><code>current-&gt;parent-&gt;wait_state==WT_CHILD</code>，<br>则唤醒父进程（即执行“<code>wakup_proc(current-&gt;parent)</code>”），让父进程帮助自己完成最后的资源回收；</li>
<li>如果当前进程还有子进程，则需要把这些子进程的父进程指针设置为内核线程initproc，且各个子进程指针需要插入到initproc的子进程链表中。如果某个子进程的执行状态是PROC_ZOMBIE，则需要唤醒initproc来完成对此子进程的最后回收工作。</li>
<li>执行schedule()函数，选择新的进程执行。</li>
</ol>
<p>那么父进程如何完成对子进程的最后回收工作呢？这要求父进程要执行wait用户函数或wait_pid用户函数，这两个函数的区别是，<strong>wait函数等待任意子进程的结束通知</strong>，而<strong>wait_pid函数等待进程id号为pid的子进程结束通知</strong>。这两个函数最终访问sys_wait系统调用接口让ucore来完成对子进程的最后回收工作，即回收子进程的内核栈和进程控制块所占内存空间，具体流程如下：</p>
<ol>
<li>如果pid!=0，表示只找一个进程id号为pid的退出状态的子进程，否则找任意一个处于退出状态的子进程；</li>
<li>如果此子进程的执行状态不为PROC_ZOMBIE，表明此子进程还没有退出，则当前进程只好设置自己的执行状态为PROC_SLEEPING，睡眠原因为WT_CHILD（即等待子进程退出），调用schedule()函数选择新的进程执行，自己睡眠等待，如果被唤醒，则重复跳回步骤1处执行；</li>
<li>如果此子进程的执行状态为PROC_ZOMBIE，表明此子进程处于退出状态，需要当前进程（即子进程的父进程）完成对子进程的最终回收工作，即首先把子进程控制块从两个进程队列proc_list和hash_list中删除，并释放子进程的内核堆栈和进程控制块。自此，子进程才彻底地结束了它的执行过程，消除了它所占用的所有资源。</li>
</ol>
<h4 id="系统调用实现"><a href="#系统调用实现" class="headerlink" title="系统调用实现"></a>系统调用实现</h4><p>用户进程只能在操作系统给它圈定好的“用户环境”中执行，但“用户环境”限制了用户进程能够执行的指令，即用户进程只能执行一般的指令，无法执行特权指令。如果用户进程想执行一些需要特权指令的任务，比如通过网卡发网络包等，只能让操作系统来代劳了。于是就需要一种机制来确保用户进程不能执行特权指令，但能够请操作系统“帮忙”完成需要特权指令的任务，这种机制就是系统调用。</p>
<p>采用系统调用机制为用户进程提供一个获得操作系统服务的统一接口层：</p>
<ul>
<li>一来可简化用户进程的实现，把一些共性的、繁琐的、与硬件相关、与特权指令相关的任务放到操作系统层来实现，但提供一个简洁的接口给用户进程调用；</li>
<li>二来这层接口事先可规定好，且严格检查用户进程传递进来的参数和操作系统要返回的数据，使得让操作系统给用户进程服务的同时，保护操作系统不会被用户进程破坏。</li>
</ul>
<p>从硬件层面上看，需要硬件能够支持在用户态的用户进程通过某种机制切换到内核态。</p>
<h5 id="初始化系统调用对应的中断描述符"><a href="#初始化系统调用对应的中断描述符" class="headerlink" title="初始化系统调用对应的中断描述符"></a>初始化系统调用对应的中断描述符</h5><p>在ucore初始化函数kern_init中调用了idt_init函数来初始化中断描述符表，并设置一个特定中断号的中断门，专门用于用户进程访问系统调用。此事由ide_init函数完成：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">idt_init(void) &#123;</span><br><span class="line">    extern uintptr_t __vectors[];</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; sizeof(idt) / sizeof(struct gatedesc); i ++) &#123;</span><br><span class="line">        SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], DPL_KERNEL);</span><br><span class="line">    &#125;</span><br><span class="line">    SETGATE(idt[T_SYSCALL], 1, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);</span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中，可以看到在执行加载中断描述符表lidt指令前，专门设置了一个特殊的中断描述符idt[T_SYSCALL]，它的特权级设置为DPL_USER，中断向量处理地址在<strong>vectors[T_SYSCALL]处。这样建立好这个中断描述符后，一旦用户进程执行“INT T_SYSCALL”后，由于此中断允许用户态进程产生（注意它的特权级设置为DPL_USER），所以CPU就会从用户态切换到内核态，保存相关寄存器，并跳转到</strong>vectors[T_SYSCALL]处开始执行，形成如下执行路径：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector128(vectors.S) --&gt; </span><br><span class="line">__alltraps(trapentry.S) --&gt; trap(trap.c) --&gt; trap_dispatch(trap.c) --&gt; syscall(syscall.c)</span><br></pre></td></tr></table></figure></p>
<h5 id="建立系统调用的用户库准备"><a href="#建立系统调用的用户库准备" class="headerlink" title="建立系统调用的用户库准备"></a>建立系统调用的用户库准备</h5><p>在操作系统中初始化好系统调用相关的中断描述符、中断处理起始地址等后，还需在用户态的应用程序中初始化好相关工作，简化应用程序访问系统调用的复杂性。为此在用户态建立了一个中间层，即简化的libc实现，在user/libs/ulib.[ch]和user/libs/syscall.[ch]中完成了对访问系统调用的封装。用户态最终的访问系统调用函数是syscall，实现如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static inline int</span><br><span class="line">syscall(int num, ...) &#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, num);</span><br><span class="line">    uint32_t a[MAX_ARGS];</span><br><span class="line">    int i, ret;</span><br><span class="line">    for (i = 0; i &lt; MAX_ARGS; i ++) &#123;</span><br><span class="line">        a[i] = va_arg(ap, uint32_t);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    asm volatile (</span><br><span class="line">        &quot;int %1;&quot;</span><br><span class="line">        : &quot;=a&quot; (ret)</span><br><span class="line">        : &quot;i&quot; (T_SYSCALL),</span><br><span class="line">          &quot;a&quot; (num),</span><br><span class="line">          &quot;d&quot; (a[0]),</span><br><span class="line">          &quot;c&quot; (a[1]),</span><br><span class="line">          &quot;b&quot; (a[2]),</span><br><span class="line">          &quot;D&quot; (a[3]),</span><br><span class="line">          &quot;S&quot; (a[4])</span><br><span class="line">        : &quot;cc&quot;, &quot;memory&quot;);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从中可以看出，应用程序调用的exit/fork/wait/getpid等库函数最终都会调用syscall函数，只是调用的参数不同而已，如果看最终的汇编代码会更清楚：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">  34:    8b 55 d4               mov    -0x2c(%ebp),%edx</span><br><span class="line">  37:    8b 4d d8               mov    -0x28(%ebp),%ecx</span><br><span class="line">  3a:    8b 5d dc               mov    -0x24(%ebp),%ebx</span><br><span class="line">  3d:    8b 7d e0               mov    -0x20(%ebp),%edi</span><br><span class="line">  40:    8b 75 e4               mov    -0x1c(%ebp),%esi</span><br><span class="line">  43:    8b 45 08               mov    0x8(%ebp),%eax</span><br><span class="line">  46:    cd 80                  int    $0x80</span><br><span class="line">  48:    89 45 f0               mov    %eax,-0x10(%ebp)</span><br><span class="line">……</span><br></pre></td></tr></table></figure></p>
<p>可以看到其实是把系统调用号放到EAX，其他5个参数a[0]~a[4]分别保存到EDX/ECX/EBX/EDI/ESI五个寄存器中，及最多用6个寄存器来传递系统调用的参数，且系统调用的返回结果是EAX。比如对于getpid库函数而言，系统调用号（SYS_getpid=18）是保存在EAX中，返回值（调用此库函数的的当前进程号pid）也在EAX中。</p>
<h5 id="与用户进程相关的系统调用"><a href="#与用户进程相关的系统调用" class="headerlink" title="与用户进程相关的系统调用"></a>与用户进程相关的系统调用</h5><p>在本实验中，与进程相关的各个系统调用属性如下所示：<br>|系统调用名  | 含义 | 具体完成服务的函数 |<br>|——|——|——|<br>|SYS_exit   | process exit  |  do_exit |<br>|SYS_fork   | create child process, dup mm  |  do_fork—&gt;wakeup_proc |<br>|SYS_wait   | wait child process | do_wait |<br>|SYS_exec   | after fork, process execute a new program  | load a program and refresh the mm |<br>|SYS_yield  | process flag itself need resecheduling | proc-&gt;need_sched=1, then scheduler will rescheule this process |<br>|SYS_kill   | kill process  |  do_kill—&gt;proc-&gt;flags |= PF_EXITING, —&gt;wakeup_proc—&gt;do_wait—&gt;do_exit |<br>|SYS_getpid | get the process’s pid |  |</p>
<p>s##### 系统调用的执行过程<br>与用户态的函数库调用执行过程相比，系统调用执行过程的有四点主要的不同：</p>
<ul>
<li>不是通过“CALL”指令而是通过“INT”指令发起调用；</li>
<li>不是通过“RET”指令，而是通过“IRET”指令完成调用返回；</li>
<li>当到达内核态后，操作系统需要严格检查系统调用传递的参数，确保不破坏整个系统的安全性；</li>
<li>执行系统调用可导致进程等待某事件发生，从而可引起进程切换；</li>
</ul>
<p>下面我们以getpid系统调用的执行过程大致看看操作系统是如何完成整个执行过程的。当用户进程调用getpid函数，最终执行到<code>INT T_SYSCALL</code>指令后，CPU根据操作系统建立的系统调用中断描述符，转入内核态，并跳转到vector128处（kern/trap/vectors.S），开始了操作系统的系统调用执行过程，函数调用和返回操作的关系如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector128(vectors.S) --&gt; </span><br><span class="line">__alltraps(trapentry.S) --&gt; trap(trap.c) --&gt; trap_dispatch(trap.c) --&gt; syscall(syscall.c) --&gt; sys_getpid(syscall.c) --&gt; …… --&gt; __trapret(trapentry.S)</span><br></pre></td></tr></table></figure><br>在执行trap函数前，软件还需进一步保存执行系统调用前的执行现场，即把与用户进程继续执行所需的相关寄存器等当前内容保存到当前进程的中断帧trapframe中（注意，在创建进程是，把进程的trapframe放在给进程的内核栈分配的空间的顶部）。软件做的工作在vector128和__alltraps的起始部分：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vectors.S::vector128起始处:</span><br><span class="line">  pushl $0</span><br><span class="line">  pushl $128</span><br><span class="line">......</span><br><span class="line">trapentry.S::__alltraps起始处:</span><br><span class="line">pushl %ds</span><br><span class="line">  pushl %es</span><br><span class="line">  pushal</span><br><span class="line">……</span><br></pre></td></tr></table></figure></p>
<p>自此，用于保存用户态的用户进程执行现场的trapframe的内容填写完毕，操作系统可开始完成具体的系统调用服务。在sys_getpid函数中，简单地把当前进程的pid成员变量做为函数返回值就是一个具体的系统调用服务。完成服务后，操作系统按调用关系的路径原路返回到__alltraps中。然后操作系统开始根据当前进程的中断帧内容做恢复执行现场操作。其实就是把trapframe的一部分内容保存到寄存器内容。恢复寄存器内容结束后，调整内核堆栈指针到中断帧的tf_eip处，这是内核栈的结构如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* below here defined by x86 hardware */</span><br><span class="line">    uintptr_t tf_eip;</span><br><span class="line">    uint16_t tf_cs;</span><br><span class="line">    uint16_t tf_padding3;</span><br><span class="line">    uint32_t tf_eflags;</span><br><span class="line">/* below here only when crossing rings */</span><br><span class="line">    uintptr_t tf_esp;</span><br><span class="line">    uint16_t tf_ss;</span><br><span class="line">    uint16_t tf_padding4;</span><br></pre></td></tr></table></figure><br>这时执行<code>IRET</code>指令后，CPU根据内核栈的情况回复到用户态，并把EIP指向tf_eip的值，即<code>INT T_SYSCALL</code>后的那条指令。这样整个系统调用就执行完毕了。</p>
<h2 id="读load-icode有感"><a href="#读load-icode有感" class="headerlink" title="读load_icode有感"></a>读load_icode有感</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* load_icode - load the content of binary program(ELF format) as the new content of current process</span></span><br><span class="line"><span class="comment"> * @binary:  the memory addr of the content of binary program</span></span><br><span class="line"><span class="comment"> * @size:  the size of the content of binary program</span></span><br><span class="line"><span class="comment"> * 读取一个二进制elf文件并为其设置执行场景，并执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">load_icode</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *binary, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;load_icode: current-&gt;mm must be empty.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = -E_NO_MEM;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="comment">//(1) create a new mm for current process</span></span><br><span class="line">    <span class="keyword">if</span> ((mm = mm_create()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(2) create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span></span><br><span class="line">    <span class="keyword">if</span> (setup_pgdir(mm) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_pgdir_cleanup_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(3) copy TEXT/DATA section, build BSS parts in binary to memory space of process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="comment">//(3.1) get the file header of the bianry program (ELF format)</span></span><br><span class="line">    <span class="comment">// 将二进制串转成描述elf的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> *<span class="title">elf</span> =</span> (<span class="keyword">struct</span> elfhdr *)binary;</span><br><span class="line">    <span class="comment">//(3.2) get the entry of the program section headers of the bianry program (ELF format)</span></span><br><span class="line">    <span class="comment">// 获取elf头的起始地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span> =</span> (<span class="keyword">struct</span> proghdr *)(binary + elf-&gt;e_phoff);</span><br><span class="line">    <span class="comment">// 代码段的头</span></span><br><span class="line">    <span class="comment">//(3.3) This program is valid?</span></span><br><span class="line">    <span class="comment">// 第一个实验中说了elf的这个域是ELF_MAGIC</span></span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        ret = -E_INVAL_ELF;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> vm_flags, perm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph_end</span> =</span> ph + elf-&gt;e_phnum;</span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; ph_end; ph ++) &#123;</span><br><span class="line">    <span class="comment">//(3.4) find every program section headers</span></span><br><span class="line">    <span class="comment">// 每一个程序段</span></span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type != ELF_PT_LOAD) &#123;</span><br><span class="line">          <span class="comment">//程序段头里的这个程序段的类型，如可加载的代码、数据、动态链接信息等</span></span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;</span><br><span class="line">            ret = -E_INVAL_ELF;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个段的大小</span></span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//(3.5) call mm_map fun to setup the new vma ( ph-&gt;p_va, ph-&gt;p_memsz)</span></span><br><span class="line">        vm_flags = <span class="number">0</span>, perm = PTE_U;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;</span><br><span class="line">        <span class="comment">// 可读、可写、可执行？</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_WRITE) perm |= PTE_W;</span><br><span class="line">        <span class="keyword">if</span> ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        <span class="comment">// 创建一个vma，并把这个vma加入到mm的list中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *from = binary + ph-&gt;p_offset;</span><br><span class="line">        <span class="type">size_t</span> off, size;</span><br><span class="line">        <span class="type">uintptr_t</span> start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//(3.6) alloc memory, and  copy the contents of every program section (from, from+end) to process&#x27;s memory</span></span><br><span class="line">(la, la+end)</span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_filesz;</span><br><span class="line">     <span class="comment">//(3.6.1) copy TEXT/DATA section of bianry program</span></span><br><span class="line">     <span class="comment">// 分配页</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(page2kva(page) + off, from, size);</span><br><span class="line">            start += size, from += size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//(3.6.2) build BSS section of binary program</span></span><br><span class="line">        end =  ph-&gt;p_va + ph-&gt;p_memsz;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; la) &#123;</span><br><span class="line">            <span class="comment">/* ph-&gt;p_memsz == ph-&gt;p_filesz */</span></span><br><span class="line">            <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start + PGSIZE - la, size = PGSIZE - off;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(4) build user stack memory</span></span><br><span class="line">    vm_flags = VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">    <span class="keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-2</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-3</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-4</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(5) set current process&#x27;s mm, sr3, and set CR3 reg = physical addr of Page Directory</span></span><br><span class="line">    mm_count_inc(mm); <span class="comment">// mm的count加1，计算有多少进程同时使用这个mm</span></span><br><span class="line">    current-&gt;mm = mm; <span class="comment">// 当前进程的mm是这个mm</span></span><br><span class="line">    current-&gt;cr3 = PADDR(mm-&gt;pgdir); <span class="comment">// 虚拟地址转换成物理地址</span></span><br><span class="line">    lcr3(PADDR(mm-&gt;pgdir));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(6) setup trapframe for user environment</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">    <span class="comment">/* LAB5:EXERCISE1 YOUR CODE</span></span><br><span class="line"><span class="comment">     * should set tf_cs,tf_ds,tf_es,tf_ss,tf_esp,tf_eip,tf_eflags</span></span><br><span class="line"><span class="comment">     * NOTICE: If we set trapframe correctly, then the user level process can return to USER MODE from kernel. S</span></span><br><span class="line"><span class="comment">o</span></span><br><span class="line"><span class="comment">     * tf_cs should be USER_CS segment (see memlayout.h)</span></span><br><span class="line"><span class="comment">     * tf_ds=tf_es=tf_ss should be USER_DS segment        </span></span><br><span class="line"><span class="comment">     * tf_esp should be the top addr of user stack (USTACKTOP)</span></span><br><span class="line"><span class="comment">     * tf_eip should be the entry point of this binary program (elf-&gt;e_entry)</span></span><br><span class="line"><span class="comment">     * tf_eflags should be set to enable computer to produce Interrupt</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tf-&gt;tf_cs = USER_CS;</span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">    tf-&gt;tf_esp = USTACKTOP;</span><br><span class="line">    tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">    tf-&gt;tf_eflags = <span class="number">0x00000002</span> | FL_IF; <span class="comment">// to enable interrupt</span></span><br><span class="line">    <span class="comment">//网上这里有的是这么写的，不知道为啥，我觉得应该只要FL_IF就够了，可能是我考虑不周</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #define FL_IF           0x00000200  // Interrupt Flag</span></span><br><span class="line"><span class="comment">    tf-&gt;tf_eflags = FL_IF;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">bad_elf_cleanup_pgdir:</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习1：加载应用程序并执行"><a href="#练习1：加载应用程序并执行" class="headerlink" title="练习1：加载应用程序并执行"></a>练习1：加载应用程序并执行</h2><p>do_execv函数调用了load_icode函数（位于kern/process/proc.c中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序，并建立了相应的用户内存空间来存放应用程序的代码段、数据段 等，且要设置好proc_struct结构中的成员变量trapframe中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。</p>
<p>load_icode函数是由do_execve函数调用的，而该函数是exec系统调用的最终处理的函数，功能为将某一个指定的ELF可执行二进制文件加载到当前内存中来，然后当前进程执行这个可执行文件（先前执行的内容全部清空），而load_icode函数的功能则在于为执行新的程序初始化好内存空间，在调用该函数之前，do_execve中已经退出了当前进程的内存空间，改使用了内核的内存空间，这样使得对原先用户态的内存空间的操作成为可能；</p>
<p>由于最终是在用户态下运行的，所以需要将段寄存器初始化为用户态的代码段、数据段、堆栈段；<br>esp应当指向先前的步骤中创建的用户栈的栈顶；<br>eip应当指向ELF可执行文件加载到内存之后的入口处；<br>eflags中应当初始化为中断使能，注意eflags的第1位是恒为1的；<br>设置ret为0，表示正常返回；<br>见上边的函数代码。</p>
<p>首先在初始化IDT的时候，设置系统调用对应的中断描述符，使其能够在用户态下被调用，并且设置为trap类型。设置系统调用中断是用户态的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">extern</span> <span class="type">uintptr_t</span> __vectors[];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(idt) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> gatedesc); i ++) &#123;</span><br><span class="line">        SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);</span><br><span class="line">    &#125;</span><br><span class="line">    SETGATE(idt[T_SYSCALL], <span class="number">1</span>, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);</span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * Set up a normal interrupt/trap gate descriptor</span></span><br><span class="line"><span class="comment"> *   - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate</span></span><br><span class="line"><span class="comment"> *   - sel: Code segment selector for interrupt/trap handler</span></span><br><span class="line"><span class="comment"> *   - off: Offset in code segment for interrupt/trap handler</span></span><br><span class="line"><span class="comment"> *   - dpl: Descriptor Privilege Level - the privilege level required</span></span><br><span class="line"><span class="comment"> *          for software to invoke this interrupt/trap gate explicitly</span></span><br><span class="line"><span class="comment"> *          using an int instruction.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SETGATE(gate, istrap, sel, off, dpl) &#123;               \</span></span><br><span class="line"><span class="meta">        (gate).gd_off_15_0 = (uint32_t)(off) &amp; 0xffff;      \</span></span><br><span class="line"><span class="meta">        (gate).gd_ss = (sel);                                \</span></span><br><span class="line"><span class="meta">        (gate).gd_args = 0;                                 \</span></span><br><span class="line"><span class="meta">        (gate).gd_rsv1 = 0;                                 \</span></span><br><span class="line"><span class="meta">        (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    \</span></span><br><span class="line"><span class="meta">        (gate).gd_s = 0;                                    \</span></span><br><span class="line"><span class="meta">        (gate).gd_dpl = (dpl);                              \</span></span><br><span class="line"><span class="meta">        (gate).gd_p = 1;                                    \</span></span><br><span class="line"><span class="meta">        (gate).gd_off_31_16 = (uint32_t)(off) &gt;&gt; 16;        \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br></pre></td></tr></table></figure><br>同样是在trap.c里，设置当计时器到点之后，也就是100个时钟周期之后，这个进程就是可以被重新调度的了，实现多线程的并发执行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        ticks++;</span><br><span class="line">        <span class="keyword">if</span>(ticks&gt;=TICK_NUM)&#123;</span><br><span class="line">            assert(current != <span class="literal">NULL</span>);</span><br><span class="line">            current-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//print_ticks();</span></span><br><span class="line">            ticks=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* LAB5 YOUR CODE */</span></span><br><span class="line">        <span class="comment">/* you should upate you lab1 code (just add ONE or TWO lines of code):</span></span><br><span class="line"><span class="comment">         *    Every TICK_NUM cycle, you should set current process&#x27;s current-&gt;need_resched = 1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">-</span><br></pre></td></tr></table></figure><br>在proc_alloc函数中，额外对进程控制块中新增加的wait_state, cptr, yptr, optr成员变量进行初始化；<br>在alloc_proc(void)函数中，对新增的几个变量初始化<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//LAB5 YOUR CODE : (update LAB4 steps)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * below fields(add in LAB5) in proc_struct need to be initialized</span></span><br><span class="line"><span class="comment"> *       uint32_t wait_state;                        // waiting state</span></span><br><span class="line"><span class="comment"> *       struct proc_struct *cptr, *yptr, *optr;     // relations between processes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;cptr = proc-&gt;optr = proc-&gt;yptr = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><br>在do_fork函数中，使用set_links函数来完成将fork的线程添加到线程链表中的过程，值得注意的是，该函数中就包括了将其加入list和对进程总数加1这一操作，因此需要将原先的这个操作给删除掉；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set_links - set the relation links of process</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">set_links</span><span class="params">(<span class="keyword">struct</span> proc_struct *proc)</span> &#123;</span><br><span class="line">    list_add(&amp;proc_list, &amp;(proc-&gt;list_link));</span><br><span class="line">    proc-&gt;yptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((proc-&gt;optr = proc-&gt;parent-&gt;cptr) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        proc-&gt;optr-&gt;yptr = proc;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;parent-&gt;cptr = proc;</span><br><span class="line">    nr_process ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LAB5 YOUR CODE : (update LAB4 steps)</span></span><br><span class="line"><span class="comment">/* Some Functions</span></span><br><span class="line"><span class="comment"> *    set_links:  set the relation links of process.  ALSO SEE: remove_links:  lean the relation links of process</span></span><br><span class="line"><span class="comment"> *    -------------------</span></span><br><span class="line"><span class="comment"> *    update step 1: set child proc&#x27;s parent to current process, make sure current process&#x27;s wait_state is 0</span></span><br><span class="line"><span class="comment"> *    update step 5: insert proc_struct into hash_list &amp;&amp; proc_list, set the relation links of process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 1. call alloc_proc to allocate a proc_struct</span></span><br><span class="line">    proc = alloc_proc();</span><br><span class="line">    <span class="keyword">if</span>(proc == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line"><span class="comment">// 2. call setup_kstack to allocate a kernel stack for child process</span></span><br><span class="line">    proc-&gt;parent = current;</span><br><span class="line">    assert(current-&gt;wait_state == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> status = setup_kstack(proc);</span><br><span class="line">    <span class="keyword">if</span>(status != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line"><span class="comment">// 3. call copy_mm to dup OR share mm according clone_flag</span></span><br><span class="line">    status = copy_mm(clone_flags, proc);</span><br><span class="line">    <span class="keyword">if</span>(status != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line"><span class="comment">// 4. call copy_thread to setup tf &amp; context in proc_struct</span></span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf);</span><br><span class="line"><span class="comment">// 5. insert proc_struct into hash_list &amp;&amp; proc_list</span></span><br><span class="line">    proc-&gt;pid = get_pid();</span><br><span class="line">    hash_proc(proc);</span><br><span class="line">    set_links(proc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete thses two lines !!!</span></span><br><span class="line">    <span class="comment">//nr_process ++;</span></span><br><span class="line">    <span class="comment">//list_add(&amp;proc_list, &amp;proc-&gt;list_link);</span></span><br><span class="line"><span class="comment">// delete thses two lines !!!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. call wakeup_proc to make the new child process RUNNABLE</span></span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line"><span class="comment">// 7. set ret vaule using child proc&#x27;s pid</span></span><br><span class="line">    ret = proc-&gt;pid;</span><br></pre></td></tr></table></figure></p>
<p>请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态） 到具体执行应用程序第一条指令的整个经过。</p>
<ul>
<li>在经过调度器占用了CPU的资源之后，用户态进程调用了exec系统调用，从而转入到了系统调用的处理例程；</li>
<li>调用中断处理例程之后，最终控制权转移到了syscall.c中的syscall函数，然后根据系统调用号转移给了sys_exec函数，在该函数中调用了上文中提及的do_execve函数来完成指定应用程序的加载；</li>
<li>在do_execve中进行了若干设置，包括退出当前进程的页表，换用kernel的PDT之后，使用load_icode函数，完成了对整个用户线程内存空间的初始化，包括堆栈的设置以及将ELF可执行文件的加载，之后通过current-&gt;tf指针修改了当前系统调用的trapframe，使得最终中断返回的时候能够切换到用户态，并且同时可以正确地将控制权转移到应用程序的入口处；</li>
<li>在完成了do_exec函数之后，进行正常的中断返回的流程，由于中断处理例程的栈上面的eip已经被修改成了应用程序的入口处，而cs上的CPL是用户态，因此iret进行中断返回的时候会将堆栈切换到用户的栈，并且完成特权级的切换，并且跳转到要求的应用程序的入口处；</li>
<li>接下来开始具体执行应用程序的第一条指令；</li>
</ul>
<blockquote>
<p>本问题参考：<a href="https://www.jianshu.com/p/8c852af5b403">https://www.jianshu.com/p/8c852af5b403</a></p>
</blockquote>
<h2 id="练习2：父进程复制自己的内存空间给子进程"><a href="#练习2：父进程复制自己的内存空间给子进程" class="headerlink" title="练习2：父进程复制自己的内存空间给子进程"></a>练习2：父进程复制自己的内存空间给子进程</h2><p>创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过copy_range函数（位于 kern/mm/pmm.c中）实现的，请补充copy_range的实现，确保能够正确执行。</p>
<ul>
<li>父进程调用fork()，进入中断处理机制，最终交由syscall函数进行处理；</li>
<li>在syscall，根据系统调用号，交由sys_fork函数处理；</li>
<li>进一步调用do_fork函数，这个函数创建了子进程、并且将父进程的内存空间复制给子进程；</li>
<li>在do_fork函数中，调用copy_mm进行内存空间的复制，在该函数中，进一步调用了dup_mmap。dup_mmap中遍历父进程的所有合法虚拟内存空间，并且将这些空间的内容复制到子进程的内存空间中去；</li>
<li>在copy_range函数中，对需要复制的内存空间按照页为单位从父进程的内存空间复制到子进程的内存空间中去；</li>
</ul>
<p>遍历父进程指定的某一段内存空间中的每一个虚拟页，如果这个虚拟页存在，为子进程对应的同一个地址（但是页目录表是不一样的，因此不是一个内存空间）也申请分配一个物理页，然后将前者中的所有内容复制到后者中去，然后为子进程的这个物理页和对应的虚拟地址（事实上是线性地址）建立映射关系；而在本练习中需要完成的内容就是内存的复制和映射的建立，具体流程如下：</p>
<ul>
<li>找到父进程指定的某一物理页对应的内核虚拟地址；</li>
<li>找到需要拷贝过去的子进程的对应物理页对应的内核虚拟地址；</li>
<li>将前者的内容拷贝到后者中去；</li>
<li>为子进程当前分配这一物理页映射上对应的在子进程虚拟地址空间里的一个虚拟页；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/* copy_range - copy content of memory (start, end) of one process A to another process B</span><br><span class="line"> * @to:    the addr of process B&#x27;s Page Directory</span><br><span class="line"> * @from:  the addr of process A&#x27;s Page Directory</span><br><span class="line"> * @share: flags to indicate to dup OR share. We just use dup method, so it didn&#x27;t be used.</span><br><span class="line"> *</span><br><span class="line"> * CALL GRAPH: copy_mm--&gt;dup_mmap--&gt;copy_range</span><br><span class="line"> */</span><br><span class="line">int</span><br><span class="line">copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end, bool share) &#123;</span><br><span class="line">    assert(start % PGSIZE == 0 &amp;&amp; end % PGSIZE == 0);</span><br><span class="line">    assert(USER_ACCESS(start, end));</span><br><span class="line">    // copy content by page unit.</span><br><span class="line">    do &#123;</span><br><span class="line">        //call get_pte to find process A&#x27;s pte according to the addr start</span><br><span class="line">        pte_t *ptep = get_pte(from, start, 0), *nptep;</span><br><span class="line">        if (ptep == NULL) &#123;</span><br><span class="line">            start = ROUNDDOWN(start + PTSIZE, PTSIZE);</span><br><span class="line">            continue ;</span><br><span class="line">        &#125;</span><br><span class="line">        //call get_pte to find process B&#x27;s pte according to the addr start. If pte is NULL, just alloc a PT</span><br><span class="line">        if (*ptep &amp; PTE_P) &#123;</span><br><span class="line">            if ((nptep = get_pte(to, start, 1)) == NULL) &#123;</span><br><span class="line">                return -E_NO_MEM;</span><br><span class="line">            &#125;</span><br><span class="line">        uint32_t perm = (*ptep &amp; PTE_USER);</span><br><span class="line">        //get page from ptep</span><br><span class="line">        struct Page *page = pte2page(*ptep);</span><br><span class="line">        // alloc a page for process B</span><br><span class="line">        struct Page *npage=alloc_page();</span><br><span class="line">        assert(page!=NULL);</span><br><span class="line">        assert(npage!=NULL);</span><br><span class="line">        int ret=0;</span><br><span class="line">        /* LAB5:EXERCISE2 YOUR CODE</span><br><span class="line">         * replicate content of page to npage, build the map of phy addr of nage with the linear addr start</span><br><span class="line">         *</span><br><span class="line">         * Some Useful MACROs and DEFINEs, you can use them in below implementation.</span><br><span class="line">         * MACROs or Functions:</span><br><span class="line">         *    page2kva(struct Page *page): return the kernel vritual addr of memory which page managed (SEE pmm.</span><br><span class="line">h)</span><br><span class="line">         *    page_insert: build the map of phy addr of an Page with the linear addr la</span><br><span class="line">         *    memcpy: typical memory copy function</span><br><span class="line">         *</span><br><span class="line">         * (1) find src_kvaddr: the kernel virtual address of page</span><br><span class="line">         * (2) find dst_kvaddr: the kernel virtual address of npage</span><br><span class="line">         * (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE</span><br><span class="line">         * (4) build the map of phy addr of  nage with the linear addr start</span><br><span class="line">         */</span><br><span class="line">         char *src_kvaddr = page2kva(page); </span><br><span class="line">         //找到父进程需要复制的物理页在内核地址空间中的虚拟地址，这是由于这个函数执行的时候使用的时内核的地址空间</span><br><span class="line">         char *dst_kvaddr = page2kva(npage); </span><br><span class="line">         // 找到子进程需要被填充的物理页的内核虚拟地址</span><br><span class="line">        memcpy(dst_kvaddr, src_kvaddr, PGSIZE); </span><br><span class="line">        // 将父进程的物理页的内容复制到子进程中去</span><br><span class="line">        page_insert(to, npage, start, perm); </span><br><span class="line">        // 建立子进程的物理页与虚拟页的映射关系</span><br><span class="line">        assert(ret == 0);</span><br><span class="line">        &#125;</span><br><span class="line">        start += PGSIZE;</span><br><span class="line">    &#125; while (start != 0 &amp;&amp; start &lt; end);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure>
<h2 id="练习3：阅读分析源代码，理解进程执行-fork-exec-wait-exit-的实现，以及系统调用的实现（不需要编码）"><a href="#练习3：阅读分析源代码，理解进程执行-fork-exec-wait-exit-的实现，以及系统调用的实现（不需要编码）" class="headerlink" title="练习3：阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）"></a>练习3：阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）</h2><ol>
<li><p>fork：在执行了fork系统调用之后，会执行正常的中断处理流程，到中断向量表里查系统调用入口，最终将控制权转移给syscall，之后根据系统调用号执行sys_fork函数，进一步执行了上文中的do_fork函数，新进程的进程控制块进行初始化、设置、以及调用copy_mm将父进程内存中的内容到子进程的内存的复制工作，然后调用wakeup_proc将新创建的进程放入可执行队列（runnable），之后由调度器对子进程进行调度。</p>
</li>
<li><p>exec：在执行了exec系统调用之后，会执行正常的中断处理流程，到中断向量表里查系统调用入口，最终将控制权转移给syscall，之后根据系统调用号执行sys_exec函数，进一步执行了上文中的do_execve函数。在该函数中，会对内存空间进行清空，然后调用load_icode将将要执行的程序加载到内存中，然后调用lcr3(boot_cr4)设置好中断帧，使得最终中断返回之后可以跳转到指定的应用程序的入口处，就可以正确执行了。</p>
</li>
<li><p>wait：在执行了wait系统调用之后，会执行正常的中断处理流程，到中断向量表里查系统调用入口，最终将控制权转移给syscall，之后根据系统调用号执行sys_wait函数，进一步执行了的do_wait函数，在这个函数中，找一个当前进程的处于ZOMBIE状态的子进程，如果有的话直接将其占用的资源释放掉即可；如果找不到，则将我这个进程的状态改成SLEEPING态，并且标记为等待ZOMBIE态的子进程，然后调用schedule函数将其当前线程从CPU占用中切换出去，直到有对应的子进程结束来唤醒这个进程为止。</p>
</li>
<li><p>exit：在执行了exit系统调用之后，会执行正常的中断处理流程，到中断向量表里查系统调用入口，最终将控制权转移给syscall，之后根据系统调用号执行sys_exit函数，进一步执行了的do_exit函数，首先将释放当前进程的大多数资源，然后将其标记为ZOMBIE态，然后调用wakeup_proc函数将其父进程唤醒（如果父进程执行了wait进入SLEEPING态的话），然后调用schedule函数，让出CPU资源，等待父进程进一步完成其所有资源的回收；</p>
</li>
</ol>
<p>问题回答</p>
<p>请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？</p>
<p>fork不会影响当前进程的执行状态，但是会将子进程的状态标记为RUNNALB，使得可以在后续的调度中运行起来；<br>exec不会影响当前进程的执行状态，但是会修改当前进程中执行的程序；<br>wait系统调用取决于是否存在可以释放资源（ZOMBIE）的子进程，如果有的话不会发生状态的改变，如果没有的话会将当前进程置为SLEEPING态，等待执行了exit的子进程将其唤醒；<br>exit会将当前进程的状态修改为ZOMBIE态，并且会将父进程唤醒（修改为RUNNABLE），然后主动让出CPU使用权；</p>
<h1 id="实验六"><a href="#实验六" class="headerlink" title="实验六"></a>实验六</h1><h2 id="实验目的-2"><a href="#实验目的-2" class="headerlink" title="实验目的"></a>实验目的</h2><ul>
<li>理解操作系统的调度管理机制</li>
<li>熟悉 ucore 的系统调度器框架，以及缺省的Round-Robin 调度算法</li>
<li>基于调度器框架实现一个(Stride Scheduling)调度算法来替换缺省的调度算法</li>
</ul>
<h2 id="实验内容-3"><a href="#实验内容-3" class="headerlink" title="实验内容"></a>实验内容</h2><ul>
<li>实验五完成了用户进程的管理，可在用户态运行多个进程。</li>
<li>之前采用的调度策略是很简单的FIFO调度策略。</li>
<li>本次实验，主要是熟悉ucore的系统调度器框架，以及基于此框架的Round-Robin（RR） 调度算法。</li>
<li>然后参考RR调度算法的实现，完成Stride Scheduling调度算法。</li>
</ul>
<h2 id="调度框架和调度算法设计与实现"><a href="#调度框架和调度算法设计与实现" class="headerlink" title="调度框架和调度算法设计与实现"></a>调度框架和调度算法设计与实现</h2><p>实验六中的kern/schedule/sched.c只实现了调度器框架，而不再涉及具体的调度算法实现，调度算法在单独的文件（default_sched.[ch]）中实现。</p>
<p>在init.c中的kern_init函数中的proc_init之前增加了对sched_init函数的调用。sched_init函数主要完成了对实现特定调度算法的调度类（sched_class，这里是default_sched_class）的绑定，使得ucore在后续的执行中，能够通过调度框架找到实现特定调度算法的调度类并完成进程调度相关工作。</p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span>                      <span class="comment">// Process state</span></span><br><span class="line">    <span class="type">int</span> pid;                                    <span class="comment">// Process ID</span></span><br><span class="line">    <span class="type">int</span> runs;                                   <span class="comment">// the running times of Proces</span></span><br><span class="line">    <span class="type">uintptr_t</span> kstack;                           <span class="comment">// Process kernel stack</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">bool</span> need_resched;                 <span class="comment">// bool value: need to be rescheduled to release CPU?</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">parent</span>;</span>                 <span class="comment">// the parent process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>                       <span class="comment">// Process&#x27;s memory management field</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>                     <span class="comment">// Switch here to run process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>                       <span class="comment">// Trap frame for current interrupt</span></span><br><span class="line">    <span class="type">uintptr_t</span> cr3;                              <span class="comment">// CR3 register: the base addr of Page Directroy Table(PDT)</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;                             <span class="comment">// Process flag</span></span><br><span class="line">    <span class="type">char</span> name[PROC_NAME_LEN + <span class="number">1</span>];               <span class="comment">// Process name</span></span><br><span class="line">    <span class="type">list_entry_t</span> list_link;                     <span class="comment">// Process link list</span></span><br><span class="line">    <span class="type">list_entry_t</span> hash_link;                     <span class="comment">// Process hash list</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ucore定义的进程控制块struct proc_struct包含了成员变量state,用于描述进程的运行状态，而running和runnable共享同一个状态(state)值(PROC_RUNNABLE。不同之处在于处于running态的进程不会放在运行队列中。进程的正常生命周期如下：</p>
<ul>
<li>进程首先在 cpu 初始化或者 sys_fork 的时候被创建，当为该进程分配了一个进程控制块之后，该进程进入 uninit态(在proc.c 中 alloc_proc)。</li>
<li>当进程完全完成初始化之后，该进程转为runnable态。</li>
<li>当到达调度点时，由调度器<code>sched_class</code>根据运行队列run_queue的内容来判断一个进程是否应该被运行，即把处于runnable态的进程转换成running状态，从而占用CPU执行。</li>
<li>running态的进程通过wait等系统调用被阻塞，进入sleeping态。</li>
<li>sleeping态的进程被wakeup变成runnable态的进程。</li>
<li>running态的进程主动 exit 变成zombie态，然后由其父进程完成对其资源的最后释放，子进程的进程控制块成为unused。</li>
<li>所有从runnable态变成其他状态的进程都要出运行队列，反之，被放入某个运行队列中。</li>
</ul>
<h3 id="进程调度实现"><a href="#进程调度实现" class="headerlink" title="进程调度实现"></a>进程调度实现</h3><h4 id="内核抢占点"><a href="#内核抢占点" class="headerlink" title="内核抢占点"></a>内核抢占点</h4><p>对于用户进程而言，由于有中断的产生，可以随时打断用户进程的执行，转到操作系统内部，从而给了操作系统以调度控制权，让操作系统可以根据具体情况（比如用户进程时间片已经用完了）选择其他用户进程执行。这体现了用户进程的可抢占性。</p>
<p>ucore内核执行是不可抢占的（non-preemptive），即在执行“任意”内核代码时，CPU控制权不可被强制剥夺。这里需要注意，不是在所有情况下ucore内核执行都是不可抢占的，有以下几种“固定”情况是例外：</p>
<ol>
<li>进行同步互斥操作，比如争抢一个信号量、锁（lab7中会详细分析）；</li>
<li>进行磁盘读写等耗时的异步操作，由于等待完成的耗时太长，ucore会调用shcedule让其他就绪进程执行。</li>
</ol>
<p>以上两种是因为某个资源（也可称为事件）无法得到满足，无法继续执行下去，从而不得不主动放弃对CPU的控制权。在lab5中有几种情况是调用了schedule函数的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>编号</th>
<th>位置</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>proc.c:do_exit</td>
<td>用户线程执行结束，主动放弃CPU</td>
</tr>
<tr>
<td>2</td>
<td>proc.c:do_wait</td>
<td>用户线程等待着子进程结束，主动放弃CPU</td>
</tr>
<tr>
<td>3</td>
<td>proc.c:init_main</td>
<td>Init_porc内核线程等待所有用户进程结束；所有用户进程结束后回收系统资源</td>
</tr>
<tr>
<td>4</td>
<td>proc.c:cpu_idle</td>
<td>idleproc内核线程等待处于就绪态的进程或线程，如果有选择一个并切换</td>
</tr>
<tr>
<td>5</td>
<td>sync.h:lock</td>
<td>进程无法得到锁，则主动放弃CPU</td>
</tr>
<tr>
<td>6</td>
<td>trap.c:trap</td>
<td>修改当前进程时间片，若时间片用完，则设置need_resched为1，让当前进程放弃CPU</td>
</tr>
</tbody>
</table>
</div>
<p>第1、2、5处的执行位置体现了由于获取某种资源一时等不到满足、进程要退出、进程要睡眠等原因而不得不主动放弃CPU。第3、4处的执行位置比较特殊，initproc内核线程等待用户进程结束而执行schedule函数；idle内核线程在没有进程处于就绪态时才执行，一旦有了就绪态的进程，它将执行schedule函数完成进程调度。这里只有第6处的位置比较特殊：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!in_kernel) &#123;</span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    if (current-&gt;need_resched) &#123;</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只有当进程在用户态执行到“任意”某处用户代码位置时发生了中断，且当前进程控制块成员变量need_resched为1（表示需要调度了）时，才会执行shedule函数。这实际上体现了对用户进程的可抢占性。如果没有第一行的if语句，那么就可以体现对内核代码的可抢占性。但如果要把这一行if语句去掉，我们就不得不实现对ucore中的所有全局变量的互斥访问操作，以防止所谓的race-condition现象，这样ucore的实现复杂度会增加不少。</p>
<p>Race condition旨在描述一个系统或者进程的输出依赖于不受控制的事件出现顺序或者出现时机。此词源自于两个信号试着彼此竞争，来影响谁先输出。 举例来说，如果计算机中的两个进程同时试图修改一个共享内存的内容，在没有并发控制的情况下，最后的结果依赖于两个进程的执行顺序与时机。而且如果发生了并发访问冲突，则最后的结果是不正确的。从维基百科的定义来看，race condition不仅仅是出现在程序中。以下讨论的race conditon全是计算机中多个进程同时访问一个共享内存，共享变量的例子。</p>
<p>要阻止出现race condition情况的关键就是不能让多个进程同时访问那块共享内存。访问共享内存的那段代码就是critical section。所有的解决方法都是围绕这个critical section来设计的。想要成功的解决race condition问题，并且程序还可以正确运行，从理论上应该满足以下四个条件： </p>
<ol>
<li>不会有两个及以上进程同时出现在他们的critical section。 </li>
<li>不要做任何关于CPU速度和数量的假设。 </li>
<li>任何进程在运行到critical section之外时都不能阻塞其他进程。 </li>
<li>不会有进程永远等在critical section之前。</li>
</ol>
<h4 id="进程切换过程"><a href="#进程切换过程" class="headerlink" title="进程切换过程"></a>进程切换过程</h4><p>进程调度函数schedule选择了下一个将占用CPU执行的进程后，将调用进程切换，从而让新的进程得以执行。</p>
<p>两个用户进程，在二者进行进程切换的过程中，具体的步骤如下：</p>
<ol>
<li>首先在执行某进程A的用户代码时，出现了一个<code>trap</code>，这个时候就会从进程A的用户态切换到内核态(过程(1))，并且保存好进程A的trapframe；当内核态处理中断时发现需要进行进程切换时，ucore要通过schedule函数选择下一个将占用CPU执行的进程（即进程B），然后会调用proc_run函数，proc_run函数进一步调用switch_to函数，切换到进程B的内核态(过程(2))，继续进程B上一次在内核态的操作，并通过iret指令，最终将执行权转交给进程B的用户空间(过程(3))。</li>
<li>当进程B由于某种原因发生中断之后(过程(4))，会从进程B的用户态切换到<strong>内核态</strong>，并且保存好进程B的trapframe；当内核态处理中断时发现需要进行进程切换时，即需要切换到进程A，ucore再次切换到进程A(过程(5))，会执行进程A上一次在内核调用schedule函数返回后的下一行代码，这行代码当然还是在进程A的上一次中断处理流程中。最后当进程A的中断处理完毕的时候，执行权又会反交给进程A的用户代码(过程(6))。这就是在只有两个进程的情况下，进程切换间的大体流程。</li>
</ol>
<h3 id="调度框架和调度算法"><a href="#调度框架和调度算法" class="headerlink" title="调度框架和调度算法"></a>调度框架和调度算法</h3><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><p>在操作方面，如果需要选择一个就绪进程，就可以从基于某种组织方式的就绪进程集合中选择出一个进程执行。<strong>选择</strong>是在集合中挑选一个“合适”的进程，<strong>出</strong>意味着离开就绪进程集合。</p>
<p>另外考虑到一个处于运行态的进程还会由于某种原因（比如时间片用完了）回到就绪态而不能继续占用CPU执行，这就会重新进入到就绪进程集合中。这两种情况就形成了调度器相关的三个基本操作：<strong>在就绪进程集合中选择</strong>、<strong>进入就绪进程集合</strong>和<strong>离开就绪进程集合</strong>。这三个操作属于调度器的基本操作。</p>
<p>在进程的执行过程中，<strong>就绪进程的等待时间</strong>和<strong>执行进程的执行时间</strong>是影响调度选择的重要因素。这些进程状态变化的情况需要及时让进程调度器知道，便于选择更合适的进程执行。所以这种进程变化的情况就形成了调度器相关的一个变化感知操作：<strong>timer时间事件感知操作</strong>。这样在进程运行或等待的过程中，调度器可以调整进程控制块中与进程调度相关的属性值（比如消耗的时间片、进程优先级等），并可能导致对进程组织形式的调整（比如以时间片大小的顺序来重排双向链表等），并最终可能导致调选择新的进程占用CPU运行。这个操作属于调度器的进程调度属性调整操作。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li>在 ucore 中，调度器引入 run-queue（简称rq,即运行队列）的概念，通过链表结构管理进程。</li>
<li>由于目前 ucore 设计运行在单CPU上，其内部只有一个全局的运行队列，用来管理系统内全部的进程。</li>
<li>运行队列通过链表的形式进行组织。链表的每一个节点是一个list_entry_t,每个list_entry_t 又对应到了<code>struct proc_struct *</code>，这其间的转换是通过宏<code>le2proc</code>来完成。</li>
<li>具体来说，我们知道在<code>struct proc_struct</code>中有一个叫<code>run_link</code>的<code>list_entry_t</code>，因此可以通过偏移量逆向找到对因某个<code>run_list</code>的<code>struct proc_struct</code>。即进程结构指针<code>proc = le2proc(链表节点指针, run_link)</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The introduction of scheduling classes is borrrowed from Linux, and makes the</span></span><br><span class="line"><span class="comment">// core scheduler quite extensible. These classes (the scheduler modules) encapsulate</span></span><br><span class="line"><span class="comment">// the scheduling policies.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="comment">// the name of sched_class</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="comment">// 初始化运行队列</span></span><br><span class="line">    <span class="type">void</span> (*init)(<span class="keyword">struct</span> run_queue *rq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// put the proc into runqueue, and this function must be called with rq_lock</span></span><br><span class="line">    <span class="comment">// 进程放入运行队列</span></span><br><span class="line">    <span class="type">void</span> (*enqueue)(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the proc out runqueue, and this function must be called with rq_lock</span></span><br><span class="line">    <span class="comment">// 从队列中取出</span></span><br><span class="line">    <span class="type">void</span> (*dequeue)(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// choose the next runnable task</span></span><br><span class="line">    <span class="comment">// 选择下一个可运行的任务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *(*<span class="title">pick_next</span>)(<span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dealer of the time-tick</span></span><br><span class="line">    <span class="comment">// 处理tick中断</span></span><br><span class="line">    <span class="type">void</span> (*proc_tick)(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* for SMP support in the future</span></span><br><span class="line"><span class="comment">     *  load_balance</span></span><br><span class="line"><span class="comment">     *     void (*load_balance)(struct rq* rq);</span></span><br><span class="line"><span class="comment">     *  get some proc from this rq, used in load_balance,</span></span><br><span class="line"><span class="comment">     *  return value is the num of gotten proc</span></span><br><span class="line"><span class="comment">     *  int (*get_proc)(struct rq* rq, struct proc* procs_moved[]);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>proc.h 中的 struct proc_struct 中也记录了一些调度相关的信息：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">struct proc_struct &#123;</span><br><span class="line">    enum proc_state state;                      // Process state</span><br><span class="line">    int pid;                                    // Process ID</span><br><span class="line">    int runs;                                   // the running times of Proces</span><br><span class="line">    uintptr_t kstack;                           // Process kernel stack</span><br><span class="line">    volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?</span><br><span class="line">    struct proc_struct *parent;                 // the parent process</span><br><span class="line">    struct mm_struct *mm;                       // Process&#x27;s memory management field</span><br><span class="line">    struct context context;                     // Switch here to run process</span><br><span class="line">    struct trapframe *tf;                       // Trap frame for current interrupt</span><br><span class="line">    uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)</span><br><span class="line">    uint32_t flags;                             // Process flag</span><br><span class="line">    char name[PROC_NAME_LEN + 1];               // Process name</span><br><span class="line">    list_entry_t list_link;                     // Process link list</span><br><span class="line">    list_entry_t hash_link;                     // Process hash list</span><br><span class="line">    int exit_code;                              // exit code (be sent to parent proc)</span><br><span class="line">    uint32_t wait_state;                        // waiting state</span><br><span class="line">    struct proc_struct *cptr, *yptr, *optr;     // relations between processes</span><br><span class="line">    struct run_queue *rq;                       // running queue contains Process</span><br><span class="line">    list_entry_t run_link;                      // the entry linked in run queue </span><br><span class="line">    // 该进程的调度链表结构，该结构内部的连接组成了 运行队列 列表</span><br><span class="line"></span><br><span class="line">    int time_slice;                             // time slice for occupying the CPU</span><br><span class="line">    // 进程剩余的时间片</span><br><span class="line">    skew_heap_entry_t lab6_run_pool;            // FOR LAB6 ONLY: the entry in the run pool</span><br><span class="line">    //在优先队列中用到的</span><br><span class="line"></span><br><span class="line">    uint32_t lab6_stride;                       // FOR LAB6 ONLY: the current stride of the process</span><br><span class="line">    // 步进值</span><br><span class="line"></span><br><span class="line">    uint32_t lab6_priority;                     // FOR LAB6 ONLY: the priority of process, set by lab6_set_priority(uint32_t)</span><br><span class="line">    // 优先级</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>RR调度算法在<code>RR_sched_class</code>调度策略类中实现。<br>通过数据结构 struct run_queue 来描述完整的 run_queue（运行队列）。它的主要结构如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct run_queue &#123;</span><br><span class="line">    //其运行队列的哨兵结构，可以看作是队列头和尾</span><br><span class="line">    list_entry_t run_list;</span><br><span class="line">    //优先队列形式的进程容器，只在 LAB6 中使用</span><br><span class="line">    skew_heap_entry_t *lab6_run_pool;</span><br><span class="line">    //表示其内部的进程总数</span><br><span class="line">    unsigned int proc_num;</span><br><span class="line">    //每个进程一轮占用的最多时间片</span><br><span class="line">    int max_time_slice;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在 ucore 框架中，运行队列存储的是当前可以调度的进程，所以，只有状态为runnable的进程才能够进入运行队列。当前正在运行的进程并不会在运行队列中。</p>
<h4 id="调度点的相关关键函数"><a href="#调度点的相关关键函数" class="headerlink" title="调度点的相关关键函数"></a>调度点的相关关键函数</h4><p>如果我们能够让<code>wakup_proc</code>、<code>schedule</code>、<code>run_timer_list</code>这三个调度相关函数的实现与具体调度算法无关，那么就可以认为ucore实现了一个与调度算法无关的调度框架。</p>
<p><code>wakeup_proc</code>函数完成了把一个就绪进程放入到就绪进程队列中的工作，为此还调用了一个调度类接口函数<code>sched_class_enqueue</code>，这使得<code>wakeup_proc</code>的实现与具体调度算法无关。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void wakeup_proc(struct proc_struct *proc) &#123;</span><br><span class="line">    assert(proc-&gt;state != PROC_ZOMBIE);</span><br><span class="line">    bool intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        if (proc-&gt;state != PROC_RUNNABLE) &#123;</span><br><span class="line">            proc-&gt;state = PROC_RUNNABLE;</span><br><span class="line">            proc-&gt;wait_state = 0;</span><br><span class="line">            if (proc != current) &#123;</span><br><span class="line">                sched_class_enqueue(proc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            warn(&quot;wakeup runnable process.\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>schedule</code>函数完成了与调度框架和调度算法相关三件事情:</p>
<ul>
<li>把当前继续占用CPU执行的运行进程放放入到就绪进程队列中；</li>
<li>从就绪进程队列中选择一个“合适”就绪进程；</li>
<li>把这个“合适”的就绪进程从就绪进程队列中取出；</li>
<li>如果没有的话，说明现在没有合适的进程可以执行，就执行idle_proc；</li>
<li>加了一个runs，表明这个进程运行过几次了；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void schedule(void) &#123;</span><br><span class="line">    bool intr_flag;</span><br><span class="line">    struct proc_struct *next;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        current-&gt;need_resched = 0;</span><br><span class="line">        if (current-&gt;state == PROC_RUNNABLE) &#123;</span><br><span class="line">            sched_class_enqueue(current);</span><br><span class="line">        &#125;</span><br><span class="line">        if ((next = sched_class_pick_next()) != NULL) &#123;</span><br><span class="line">            sched_class_dequeue(next);</span><br><span class="line">        &#125;</span><br><span class="line">        if (next == NULL) &#123;</span><br><span class="line">            next = idleproc;</span><br><span class="line">        &#125;</span><br><span class="line">        next-&gt;runs ++;</span><br><span class="line">        if (next != current) &#123;</span><br><span class="line">            proc_run(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>run_time_list在lab6中并没有涉及，是在lab7中的。</p>
<p>通过调用三个调度类接口函数<code>sched_class_enqueue</code>、<code>sched_class_pick_next</code>、<code>sched_class_enqueue</code>来使得完成这三件事情与具体的调度算法无关。<code>run_timer_list</code>函数在每次timer中断处理过程中被调用，从而可用来调用调度算法所需的timer时间事件感知操作，调整相关进程的进程调度相关的属性值。通过调用调度类接口函数<code>sched_class_proc_tick</code>使得此操作与具体调度算法无关。<br>这里涉及了一系列调度类接口函数：</p>
<ul>
<li>sched_class_enqueue</li>
<li>sched_class_dequeue</li>
<li>sched_class_pick_next</li>
<li>sched_class_proc_tick</li>
</ul>
<p>这4个函数的实现其实就是调用某基于sched_class数据结构的特定调度算法实现的4个指针函数。采用这样的调度类框架后，如果我们需要实现一个新的调度算法，则我们需要定义一个针对此算法的调度类的实例，一个就绪进程队列的组织结构描述就行了，其他的事情都可交给调度类框架来完成。</p>
<h4 id="RR调度算法"><a href="#RR调度算法" class="headerlink" title="RR调度算法"></a>RR调度算法</h4><p>RR调度算法的调度思想是让所有runnable态的进程分时轮流使用CPU时间。</p>
<p>RR调度器维护当前runnable进程的有序运行队列。当前进程的时间片用完之后，调度器将当前进程放置到运行队列的尾部，再从其头部取出进程进行调度。</p>
<p>RR调度算法的就绪队列在组织结构上也是一个双向链表，只是增加了一个成员变量，表明在此就绪进程队列中的最大执行时间片。而且在进程控制块proc_struct中增加了一个成员变量time_slice，用来记录进程当前的可运行时间片段。这是由于RR调度算法需要考虑执行进程的运行时间不能太长。在每个timer到时的时候，操作系统会递减当前执行进程的time_slice，当time_slice为0时，就意味着这个进程运行了一段时间（这个时间片段称为进程的时间片），需要把CPU让给其他进程执行，于是操作系统就需要让此进程重新回到rq的队列尾，且重置此进程的时间片为就绪队列的成员变量最大时间片max_time_slice值，然后再从rq的队列头取出一个新的进程执行。</p>
<p>RR_enqueue的函数实现如下表所示。即把某进程的进程控制块指针放入到rq队列末尾，且如果进程控制块的时间片为0，则需要把它重置为rq成员变量max_time_slice。这表示如果进程在当前的执行时间片已经用完，需要等到下一次有机会运行时，才能再执行一段时间。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void RR_enqueue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    assert(list_empty(&amp;(proc-&gt;run_link)));</span><br><span class="line">    list_add_before(&amp;(rq-&gt;run_list), &amp;(proc-&gt;run_link));</span><br><span class="line">    if (proc-&gt;time_slice == 0 || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">        proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;rq = rq;</span><br><span class="line">    rq-&gt;proc_num ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>RR_pick_next的函数实现如下表所示。即选取就绪进程队列rq中的队头队列元素，并把队列元素转换成进程控制块指针。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static struct proc_struct *</span><br><span class="line">RR_pick_next(struct run_queue *rq) &#123;</span><br><span class="line">    list_entry_t *le = list_next(&amp;(rq-&gt;run_list));</span><br><span class="line">    if (le != &amp;(rq-&gt;run_list)) &#123;</span><br><span class="line">        return le2proc(le, run_link);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>RR_dequeue的函数实现如下表所示。即把就绪进程队列rq的进程控制块指针的队列元素删除，并把表示就绪进程个数的proc_num减一。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void RR_dequeue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    assert(!list_empty(&amp;(proc-&gt;run_link)) &amp;&amp; proc-&gt;rq == rq);</span><br><span class="line">    list_del_init(&amp;(proc-&gt;run_link));</span><br><span class="line">    rq-&gt;proc_num --;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>RR_proc_tick的函数实现如下表所示。每次timer到时后，trap函数将会间接调用此函数来把当前执行进程的时间片time_slice减一。如果time_slice降到零，则设置此进程成员变量need_resched标识为1，这样在下一次中断来后执行trap函数时，会由于当前进程程成员变量need_resched标识为1而执行schedule函数，从而把当前执行进程放回就绪队列末尾，而从就绪队列头取出在就绪队列上等待时间最久的那个就绪进程执行。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">RR_proc_tick(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    if (proc-&gt;time_slice &gt; 0) &#123;</span><br><span class="line">        proc-&gt;time_slice --;</span><br><span class="line">    &#125;</span><br><span class="line">    if (proc-&gt;time_slice == 0) &#123;</span><br><span class="line">        proc-&gt;need_resched = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Stride-Scheduling"><a href="#Stride-Scheduling" class="headerlink" title="Stride Scheduling"></a>Stride Scheduling</h3><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><ol>
<li>为每个runnable的进程设置一个当前状态stride，表示该进程当前的调度权，也可以表示这个进程执行了多久了。另外定义其对应的pass值，表示对应进程在调度后，stride 需要进行的累加值。</li>
<li>每次需要调度时，从当前 runnable 态的进程中选择<strong>stride最小</strong>的进程调度。</li>
<li>对于获得调度的进程P，将对应的stride加上其对应的步长pass（只与进程的优先权有关系）。</li>
<li>在一段固定的时间之后，回到2步骤，重新调度当前stride最小的进程。</li>
</ol>
<p>可以证明，如果令<code>P.pass =BigStride / P.priority</code>，其中<code>P.priority</code>表示进程的优先权（大于 1），而 BigStride 表示一个预先定义的大常数，则该调度方案为每个进程分配的时间将与其优先级成正比。</p>
<p>将该调度器应用到 ucore 的调度器框架中来，则需要将调度器接口实现如下：</p>
<ul>
<li>init:<ul>
<li>初始化调度器类的信息（如果有的话）。</li>
<li>初始化当前的运行队列为一个空的容器结构。（比如和RR调度算法一样，初始化为一个有序列表）</li>
</ul>
</li>
<li>enqueue<ul>
<li>初始化刚进入运行队列的进程 proc的stride属性。</li>
<li>将 proc插入放入运行队列中去（注意：这里并不要求放置在队列头部）。</li>
</ul>
</li>
<li>dequeue<ul>
<li>从运行队列中删除相应的元素。</li>
</ul>
</li>
<li>pick next<ul>
<li>扫描整个运行队列，返回其中stride值最小的对应进程。</li>
<li>更新对应进程的stride值，即pass = BIG_STRIDE / P-&gt;priority; P-&gt;stride += pass。</li>
</ul>
</li>
<li>proc tick:<ul>
<li>检测当前进程是否已用完分配的时间片。如果时间片用完，应该正确设置进程结构的相关标记来引起进程切换。</li>
<li>一个 process 最多可以连续运行 rq.max_time_slice个时间片。</li>
</ul>
</li>
</ul>
<h4 id="使用优先队列实现-Stride-Scheduling"><a href="#使用优先队列实现-Stride-Scheduling" class="headerlink" title="使用优先队列实现 Stride Scheduling"></a>使用优先队列实现 Stride Scheduling</h4><p>使用优化的优先队列数据结构实现该调度。</p>
<p>优先队列是这样一种数据结构：使用者可以快速的插入和删除队列中的元素，并且在预先指定的顺序下快速取得当前在队列中的最小（或者最大）值及其对应元素。可以看到，这样的数据结构非常符合 Stride 调度器的实现。</p>
<p>libs/skew_heap.h中是优先队列的一个实现。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static inline void skew_heap_init(skew_heap_entry_t *a) __attribute__((always_inline));</span><br><span class="line">// 初始化一个队列节点</span><br><span class="line"></span><br><span class="line">static inline skew_heap_entry_t *skew_heap_merge(</span><br><span class="line">     skew_heap_entry_t *a, skew_heap_entry_t *b,</span><br><span class="line">     compare_f comp);</span><br><span class="line">// 合并两个优先队列</span><br><span class="line"></span><br><span class="line">static inline skew_heap_entry_t *skew_heap_insert(</span><br><span class="line">     skew_heap_entry_t *a, skew_heap_entry_t *b,</span><br><span class="line">     compare_f comp) __attribute__((always_inline));</span><br><span class="line">// 将节点 b 插入至以节点 a 为队列头的队列中去，返回插入后的队列</span><br><span class="line"></span><br><span class="line">static inline skew_heap_entry_t *skew_heap_remove(</span><br><span class="line">     skew_heap_entry_t *a, skew_heap_entry_t *b,</span><br><span class="line">     compare_f comp) __attribute__((always_inline));</span><br><span class="line">// 将节点 b 插入从以节点 a 为队列头的队列中去，返回删除后的队列</span><br></pre></td></tr></table></figure><br>当使用优先队列作为Stride调度器的实现方式之后，运行队列结构也需要作相关改变，其中包括：</p>
<ol>
<li><code>struct run_queue</code>中的<code>lab6_run_pool</code>指针，在使用优先队列的实现中表示当前优先队列的头元素，如果优先队列为空，则其指向空指针（NULL）。</li>
<li><code>struct proc_struct</code>中的<code>lab6_run_pool</code>结构，表示当前进程对应的优先队列节点。本次实验已经修改了系统相关部分的代码，使得其能够很好地适应LAB6新加入的数据结构和接口。而在实验中我们需要做的是用优先队列实现一个正确和高效的Stride调度器，如果用较简略的伪代码描述，则有：</li>
</ol>
<ul>
<li>init(rq):<ul>
<li>Initialize rq-&gt;run_list</li>
<li>Set rq-&gt;lab6_run_pool to NULL</li>
<li>Set rq-&gt;proc_num to 0</li>
</ul>
</li>
<li>enqueue(rq, proc)<ul>
<li>Initialize proc-&gt;time_slice</li>
<li>Insert proc-&gt;lab6_run_pool into rq-&gt;lab6_run_pool</li>
<li>rq-&gt;proc_num ++</li>
</ul>
</li>
<li>dequeue(rq, proc)<ul>
<li>Remove proc-&gt;lab6_run_pool from rq-&gt;lab6_run_pool</li>
<li>rq-&gt;proc_num —</li>
</ul>
</li>
<li>pick_next(rq)<ul>
<li>If rq-&gt;lab6_run_pool == NULL, return NULL</li>
<li>Find the proc corresponding to the pointer rq-&gt;lab6_run_pool</li>
<li>proc-&gt;lab6_stride += BIG_STRIDE / proc-&gt;lab6_priority</li>
<li>Return proc</li>
</ul>
</li>
<li>proc_tick(rq, proc):<ul>
<li>If proc-&gt;time_slice &gt; 0, proc-&gt;time_slice —<br>– If proc-&gt;time_slice == 0, set the flag proc-&gt;need_resched    </li>
</ul>
</li>
</ul>
<h2 id="练习1-使用-Round-Robin-调度算法（不需要编码）"><a href="#练习1-使用-Round-Robin-调度算法（不需要编码）" class="headerlink" title="练习1: 使用 Round Robin 调度算法（不需要编码）"></a>练习1: 使用 Round Robin 调度算法（不需要编码）</h2><p>与之前相比，新增了斜堆数据结构的实现；新增了调度算法Round Robin的实现，具体为调用sched.c文件中的<code>sched_class</code>的一系列函数，主要有enqueue、dequeue、pick_next等。之后，这些函数进一步调用调度器中的相应函数，默认该调度器为Round Robin调度器，这是在<code>default_sched.[c|h]</code>中定义的；新增了set_priority，get_time等函数；</p>
<p>首先在init.c中调用了sched_init函数，在这里把sched_class赋值为default_sched_class，也就是RR，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    list_init(&amp;timer_list);</span><br><span class="line"></span><br><span class="line">    sched_class = &amp;default_sched_class;</span><br><span class="line">    rq = &amp;__rq;</span><br><span class="line">    rq-&gt;max_time_slice = MAX_TIME_SLICE;</span><br><span class="line">    sched_class-&gt;init(rq);</span><br><span class="line">    cprintf(<span class="string">&quot;sched class: %s\n&quot;</span>, sched_class-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>RR_init函数：这个函数会被封装为sched_init函数，用于调度算法的初始化，它是在ucore的init.c里面被调用进行初始化，主要完成了计时器list、run_queue的run_list的初始化；</li>
<li>enqueue函数：将某个进程放入调用算法中的可执行队列中，被封装成sched_class_enqueue函数，这个函数仅在wakeup_proc和schedule函数中被调用，wakeup_proc将某个不是RUNNABLE的进程改成RUNNABLE的并调用enqueue加入可执行队列，而后者是将正在执行的进程换出到可执行队列中去并取出一个可执行进程；</li>
<li>dequeue函数：将某个在队列中的进程取出，sched_class_dequeue将其封装并在schedule中被调用，将调度算法选择的进程从等待的可执行进程队列中取出；</li>
<li>pick_next函数：根据调度算法选择下一个要执行的进程，仅在schedule中被调用；</li>
<li>proc_tick函数：在时钟中断时执行的操作，时间片减一，当时间片为0时，说明这个进程需要重新调度了。仅在进行时间中断的ISR中调用；</li>
</ul>
<blockquote>
<p>请理解并分析sched_calss中各个函数指针的用法，并接合Round Robin 调度算法描述ucore的调度执行过程：</p>
</blockquote>
<ul>
<li>ucore中的调度主要通过schedule和wakeup_proc函数完成，schedule主要把当前执行的进程入队，调用sched_class_pick_next选择下一个执行的进程并将其出队，开始执行。scheduleha函数把当前的进程入队，挑选一个进程将其出队并开始执行。</li>
<li>当需要将某一个进程加入就绪进程队列中，需要调用enqueue，将其插入到使用链表组织run_queue的队尾，将这个进程的能够使用的时间片初始化为max_time_slice；</li>
<li>当需要将某一个进程从就绪队列中取出，需要调用dequeue，调用list_del_init将其直接删除即可；</li>
<li>当需要取出执行的下一个进程时，只需调用pick_next将就绪队列run_queue的队头取出即可；</li>
<li>在一个时钟中断中，调用proc_tick将当前执行的进程的剩余可执行时间减1，一旦减到了0，则这个进程的need_resched为1，设成可以被调度的，这样之后就会调用schedule函数将这个进程切换出去；</li>
</ul>
<blockquote>
<p>请在实验报告中简要说明如何设计实现”多级反馈队列调度算法“，给出概要设计，鼓励给出详细设计;</p>
</blockquote>
<p>调度机制：</p>
<ol>
<li>进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。</li>
<li>设置多个就绪队列。在系统中设置多个就绪队列，并为每个队列赋予不同的优先级，从第一个开始逐个降低。不同队列进程中所赋予的执行时间也不同，优先级越高，时间片越小。</li>
<li>每个队列都采用FCFS（先来先服务）算法。轮到该进程执行时，若在该时间片内完成，便撤离操作系统，否则调度程序将其转入第二队列的末尾等待调度，…….。若进程最后被调到第N队列中时，便采用RR方式运行。</li>
<li>按队列优先级调度。调度按照优先级最高队列中诸进程运行，仅当第一队列空闲时才调度第二队列进程执行。若低优先级队列执行中有优先级高队列进程执行，应立刻将此进程放入队列末尾，把处理机分配给新到高优先级进程。</li>
</ol>
<ul>
<li>设置N个多级反馈队列的入口，Q0，Q1，Q2，Q3，…，编号越靠前的队列优先级越低，优先级越低的队列上时间片的长度越大；</li>
<li>调用sched_init对调度算法初始化的时候需要同时对N个队列进行初始化；</li>
<li>在将进程加入到就绪进程集合的时候，观察这个进程的时间片有没有使用完，如果使用完了，就将所在队列的优先级调低，加入到优先级低一级的队列中去，如果没有使用完时间片，则加入到当前优先级的队列中去；</li>
<li>在同一个优先级的队列内使用时间片轮转算法；</li>
<li>在选择下一个执行的进程的时候，先考虑更高优先级的队列中是否存在任务，如果不存在在去找较低优先级的队列；</li>
<li>从就绪进程集合中删除某一个进程的话直接在对应队列中删除；</li>
</ul>
<h2 id="练习2：实现-Stride-Scheduling-调度算法（需要编码）"><a href="#练习2：实现-Stride-Scheduling-调度算法（需要编码）" class="headerlink" title="练习2：实现 Stride Scheduling 调度算法（需要编码）"></a>练习2：实现 Stride Scheduling 调度算法（需要编码）</h2><p><strong>啊啊啊忘了在trap.c里改怪不得怎么都搞不对啊啊啊啊啊啊啊啊啊这下子总算有170了！！！</strong></p>
<p>还是先看看代码里斜堆（skew heap）的实现吧，好多地方要用到这个结构，具体可以在yuhao0102.github.io里仔细看。<br>在libs/skew.h中定义了skew heap。</p>
<p>猜测这只是一个入口，类似链表那种实现，不包括数据，只有指针。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct skew_heap_entry &#123;</span><br><span class="line">     struct skew_heap_entry *parent, *left, *right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>proc_stride_comp_f</code>函数是用来比较这两个进程的stride的，a比b大返回1，相等返回0，a比b小返回-1。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The compare function for two skew_heap_node_t&#x27;s and the</span></span><br><span class="line"><span class="comment"> * corresponding procs*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">proc_stride_comp_f</span><span class="params">(<span class="type">void</span> *a, <span class="type">void</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> =</span> le2proc(a, lab6_run_pool);</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">q</span> =</span> le2proc(b, lab6_run_pool);</span><br><span class="line">     <span class="type">int32_t</span> c = p-&gt;lab6_stride - q-&gt;lab6_stride;</span><br><span class="line">     <span class="keyword">if</span> (c &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是初始化的函数，把三个指针初始化为NULL<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">skew_heap_init</span><span class="params">(<span class="type">skew_heap_entry_t</span> *a)</span></span><br><span class="line">&#123;</span><br><span class="line">     a-&gt;left = a-&gt;right = a-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个是把两个堆merge在一起的操作，强行内联hhh，这个是递归的！<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">skew_heap_entry_t</span> *</span><br><span class="line"><span class="title function_">skew_heap_merge</span><span class="params">(<span class="type">skew_heap_entry_t</span> *a, <span class="type">skew_heap_entry_t</span> *b,</span></span><br><span class="line"><span class="params">                compare_f comp)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (a == <span class="literal">NULL</span>) <span class="keyword">return</span> b;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="literal">NULL</span>) <span class="keyword">return</span> a;</span><br><span class="line"><span class="comment">// 如果a或b有一个为空，则返回另一个</span></span><br><span class="line"></span><br><span class="line">     <span class="type">skew_heap_entry_t</span> *l, *r;</span><br><span class="line">     <span class="keyword">if</span> (comp(a, b) == <span class="number">-1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          r = a-&gt;left;</span><br><span class="line">          l = skew_heap_merge(a-&gt;right, b, comp);</span><br><span class="line"></span><br><span class="line">          a-&gt;left = l;</span><br><span class="line">          a-&gt;right = r;</span><br><span class="line">          <span class="keyword">if</span> (l) l-&gt;parent = a;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> a;</span><br><span class="line"><span class="comment">// 否则判断a和b的值哪个大，如果a比b小，则a的右子树和b合并，a作为堆顶        </span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          r = b-&gt;left;</span><br><span class="line">          l = skew_heap_merge(a, b-&gt;right, comp);</span><br><span class="line"></span><br><span class="line">          b-&gt;left = l;</span><br><span class="line">          b-&gt;right = r;</span><br><span class="line">          <span class="keyword">if</span> (l) </span><br><span class="line">          	l-&gt;parent = b;</span><br><span class="line">	      <span class="keyword">return</span> b;</span><br><span class="line"><span class="comment">// 另一种情况	      </span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>insert就是把一个单节点的堆跟大堆合并<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">skew_heap_entry_t</span> *</span><br><span class="line"><span class="title function_">skew_heap_insert</span><span class="params">(<span class="type">skew_heap_entry_t</span> *a, <span class="type">skew_heap_entry_t</span> *b,</span></span><br><span class="line"><span class="params">                 compare_f comp)</span></span><br><span class="line">&#123;</span><br><span class="line">     skew_heap_init(b);</span><br><span class="line">     <span class="keyword">return</span> skew_heap_merge(a, b, comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>删除就是把节点的左右子树进行merge，比较简单，记得删掉这个节点之后补充它的parent即可<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">skew_heap_entry_t</span> *</span><br><span class="line"><span class="title function_">skew_heap_remove</span><span class="params">(<span class="type">skew_heap_entry_t</span> *a, <span class="type">skew_heap_entry_t</span> *b,</span></span><br><span class="line"><span class="params">                 compare_f comp)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">skew_heap_entry_t</span> *p   = b-&gt;parent;</span><br><span class="line">     <span class="type">skew_heap_entry_t</span> *rep = skew_heap_merge(b-&gt;left, b-&gt;right, comp);</span><br><span class="line">     <span class="keyword">if</span> (rep) rep-&gt;parent = p;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (p)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span> (p-&gt;left == b)</span><br><span class="line">               p-&gt;left = rep;</span><br><span class="line">          <span class="keyword">else</span> p-&gt;right = rep;</span><br><span class="line">          <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先把default_sched.c中设置RR调度器为默认调度器的部分注释掉，然后把default_sched_stride_c改成default_sched_stride.c，这里对默认调度器进行了重新定义。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">default_sched_class</span> =</span> &#123;</span><br><span class="line">     .name = <span class="string">&quot;stride_scheduler&quot;</span>,</span><br><span class="line">     .init = stride_init,</span><br><span class="line">     .enqueue = stride_enqueue,</span><br><span class="line">     .dequeue = stride_dequeue,</span><br><span class="line">     .pick_next = stride_pick_next,</span><br><span class="line">     .proc_tick = stride_proc_tick,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>针对PCB的初始化，代码如下，综合了几个实验的初始化代码，也是一个总结：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LAB4:EXERCISE1 YOUR CODE</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * below fields in proc_struct need to be initialized</span></span><br><span class="line"><span class="comment"> *       enum proc_state state;                      // Process state</span></span><br><span class="line"><span class="comment"> *       int pid;                                    // Process ID</span></span><br><span class="line"><span class="comment"> *       int runs;                                   // the running times of Proces</span></span><br><span class="line"><span class="comment"> *       uintptr_t kstack;                           // Process kernel stack</span></span><br><span class="line"><span class="comment"> *       volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?</span></span><br><span class="line"><span class="comment"> *       struct proc_struct *parent;                 // the parent process</span></span><br><span class="line"><span class="comment"> *       struct mm_struct *mm;                       // Process&#x27;s memory management field</span></span><br><span class="line"><span class="comment"> *       struct context context;                     // Switch here to run process</span></span><br><span class="line"><span class="comment"> *       struct trapframe *tf;                       // Trap frame for current interrupt</span></span><br><span class="line"><span class="comment"> *       uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)</span></span><br><span class="line"><span class="comment"> *       uint32_t flags;                             // Process flag</span></span><br><span class="line"><span class="comment"> *       char name[PROC_NAME_LEN + 1];               // Process name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        proc-&gt;state = PROC_UNINIT;</span><br><span class="line">        proc-&gt;pid = <span class="number">-1</span>;</span><br><span class="line">        proc-&gt;cr3 = boot_cr3;</span><br><span class="line"></span><br><span class="line">        proc-&gt;runs = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;proc-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> context));</span><br><span class="line">        proc-&gt;tf = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(proc-&gt;name, <span class="number">0</span>, PROC_NAME_LEN);</span><br><span class="line"></span><br><span class="line"><span class="comment">//LAB5 YOUR CODE : (update LAB4 steps)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * below fields(add in LAB5) in proc_struct need to be initialized</span></span><br><span class="line"><span class="comment"> *       uint32_t wait_state;                        // waiting state</span></span><br><span class="line"><span class="comment"> *       struct proc_struct *cptr, *yptr, *optr;     // relations between processes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;cptr = proc-&gt;optr = proc-&gt;yptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//LAB6 YOUR CODE : (update LAB5 steps)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * below fields(add in LAB6) in proc_struct need to be initialized</span></span><br><span class="line"><span class="comment"> *     struct run_queue *rq;                       // running queue contains Process</span></span><br><span class="line"><span class="comment"> *     list_entry_t run_link;                      // the entry linked in run queue</span></span><br><span class="line"><span class="comment"> *     int time_slice;                             // time slice for occupying the CPU</span></span><br><span class="line"><span class="comment"> *     skew_heap_entry_t lab6_run_pool;            // FOR LAB6 ONLY: the entry in the run pool</span></span><br><span class="line"><span class="comment"> *     uint32_t lab6_stride;                       // FOR LAB6 ONLY: the current stride of the process</span></span><br><span class="line"><span class="comment"> *     uint32_t lab6_priority;                     // FOR LAB6 ONLY: the priority of process, set by lab6_set_priority(uint32_t)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        proc-&gt;rq = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;proc-&gt;run_link, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">list_entry_t</span>));</span><br><span class="line">        proc-&gt;time_slice = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;proc-&gt;lab6_run_pool,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">skew_heap_entry_t</span>));</span><br><span class="line">        proc-&gt;lab6_stride=<span class="number">0</span>;</span><br><span class="line">        proc-&gt;lab6_priority=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><br>主要就是在<code>vim kern/schedule/default_sched_stride.c</code>里的修改。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIG_STRIDE ((uint32_t)(1&lt;&lt;31)-3)</span></span><br></pre></td></tr></table></figure><br>BIG_STRIDE应该设置成小于2^32-1的一个常数。</p>
<p>这个函数用来对run_queue进行初始化等操作<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stride_init initializes the run-queue rq with correct assignment for</span></span><br><span class="line"><span class="comment"> * member variables, including:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - run_list: should be a empty list after initialization.</span></span><br><span class="line"><span class="comment"> *   - lab6_run_pool: NULL</span></span><br><span class="line"><span class="comment"> *   - proc_num: 0</span></span><br><span class="line"><span class="comment"> *   - max_time_slice: no need here, the variable would be assigned by the caller.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * hint: see libs/list.h for routines of the list structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">stride_init</span><span class="params">(<span class="keyword">struct</span> run_queue *rq)</span> &#123;</span><br><span class="line">     <span class="comment">/* LAB6: YOUR CODE</span></span><br><span class="line"><span class="comment">      * (1) init the ready process list: rq-&gt;run_list</span></span><br><span class="line"><span class="comment">      * (2) init the run pool: rq-&gt;lab6_run_pool</span></span><br><span class="line"><span class="comment">      * (3) set number of process: rq-&gt;proc_num to 0</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      list_init(&amp;rq-&gt;run_list);</span><br><span class="line">      rq-&gt;lab6_run_pool = <span class="literal">NULL</span>;</span><br><span class="line">      rq-&gt;proc_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stride_enqueue inserts the process ``proc&#x27;&#x27; into the run-queue</span></span><br><span class="line"><span class="comment"> * ``rq&#x27;&#x27;. The procedure should verify/initialize the relevant members</span></span><br><span class="line"><span class="comment"> * of ``proc&#x27;&#x27;, and then put the ``lab6_run_pool&#x27;&#x27; node into the</span></span><br><span class="line"><span class="comment"> * queue(since we use priority queue here). The procedure should also</span></span><br><span class="line"><span class="comment"> * update the meta date in ``rq&#x27;&#x27; structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * proc-&gt;time_slice denotes the time slices allocation for the</span></span><br><span class="line"><span class="comment"> * process, which should set to rq-&gt;max_time_slice.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * hint: see libs/skew_heap.h for routines of the priority</span></span><br><span class="line"><span class="comment"> * queue structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">stride_enqueue</span><span class="params">(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc)</span> &#123;</span><br><span class="line">     <span class="comment">/* LAB6: YOUR CODE</span></span><br><span class="line"><span class="comment">      * (1) insert the proc into rq correctly</span></span><br><span class="line"><span class="comment">      * NOTICE: you can use skew_heap or list. Important functions</span></span><br><span class="line"><span class="comment">      *         skew_heap_insert: insert a entry into skew_heap</span></span><br><span class="line"><span class="comment">      *         list_add_before: insert  a entry into the last of list</span></span><br><span class="line"><span class="comment">      * (2) recalculate proc-&gt;time_slice</span></span><br><span class="line"><span class="comment">      * (3) set proc-&gt;rq pointer to rq</span></span><br><span class="line"><span class="comment">      * (4) increase rq-&gt;proc_num</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      rq-&gt;lab6_run_pool = skew_heap_insert(rq-&gt;lab6_run_pool, &amp;proc-&gt;lab6_run_pool, proc_stride_comp_f);</span><br><span class="line">      <span class="comment">// 做插入操作，把这个进程插到run_pool里。</span></span><br><span class="line">      <span class="keyword">if</span>(proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">          proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果这个进程的时间片不符合要求，就把它初始化成最大值。</span></span><br><span class="line">      proc-&gt;rq = rq;</span><br><span class="line">      rq-&gt;proc_num ++;</span><br><span class="line">      <span class="comment">//run_queue里的进程数++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做删除操作，把这个进程从run_pool里删除，并且将run_queue里的进程数减一。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stride_dequeue removes the process ``proc&#x27;&#x27; from the run-queue</span></span><br><span class="line"><span class="comment"> * ``rq&#x27;&#x27;, the operation would be finished by the skew_heap_remove</span></span><br><span class="line"><span class="comment"> * operations. Remember to update the ``rq&#x27;&#x27; structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * hint: see libs/skew_heap.h for routines of the priority</span></span><br><span class="line"><span class="comment"> * queue structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">stride_dequeue</span><span class="params">(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc)</span> &#123;</span><br><span class="line">     <span class="comment">/* LAB6: YOUR CODE</span></span><br><span class="line"><span class="comment">      * (1) remove the proc from rq correctly</span></span><br><span class="line"><span class="comment">      * NOTICE: you can use skew_heap or list. Important functions</span></span><br><span class="line"><span class="comment">      *         skew_heap_remove: remove a entry from skew_heap</span></span><br><span class="line"><span class="comment">      *         list_del_init: remove a entry from the  list</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      rq-&gt;lab6_run_pool = skew_heap_remove(rq-&gt;lab6_run_pool, &amp;proc-&gt;lab6_run_pool, proc_stride_comp_f);</span><br><span class="line">      rq-&gt;proc_num --;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>pick_next从run_queue中选择stride值最小的进程，即斜堆的根节点对应的进程，并且返回这个proc，同时更新这个proc的stride<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stride_pick_next pick the element from the ``run-queue&#x27;&#x27;, with the</span></span><br><span class="line"><span class="comment"> * minimum value of stride, and returns the corresponding process</span></span><br><span class="line"><span class="comment"> * pointer. The process pointer would be calculated by macro le2proc,</span></span><br><span class="line"><span class="comment"> * see kern/process/proc.h for definition. Return NULL if</span></span><br><span class="line"><span class="comment"> * there is no process in the queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When one proc structure is selected, remember to update the stride</span></span><br><span class="line"><span class="comment"> * property of the proc. (stride += BIG_STRIDE / priority)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * hint: see libs/skew_heap.h for routines of the priority</span></span><br><span class="line"><span class="comment"> * queue structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc_struct *</span><br><span class="line"><span class="title function_">stride_pick_next</span><span class="params">(<span class="keyword">struct</span> run_queue *rq)</span> &#123;</span><br><span class="line">     <span class="comment">/* LAB6: YOUR CODE</span></span><br><span class="line"><span class="comment">      * (1) get a  proc_struct pointer p  with the minimum value of stride</span></span><br><span class="line"><span class="comment">             (1.1) If using skew_heap, we can use le2proc get the p from rq-&gt;lab6_run_poll</span></span><br><span class="line"><span class="comment">             (1.2) If using list, we have to search list to find the p with minimum stride value</span></span><br><span class="line"><span class="comment">      * (2) update p;s stride value: p-&gt;lab6_stride</span></span><br><span class="line"><span class="comment">      * (3) return p</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> (rq-&gt;lab6_run_pool == <span class="literal">NULL</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> =</span> le2proc(rq-&gt;lab6_run_pool, lab6_run_pool);</span><br><span class="line">      p-&gt;lab6_stride += BIG_STRIDE/p-&gt;lab6_priority;</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要在trap的时候调用！！！！如果这个proc的时间片还有的话，就减一，如果这个时间片为0了，就把它设成可调度的，参与调度。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stride_proc_tick works with the tick event of current process. You</span></span><br><span class="line"><span class="comment"> * should check whether the time slices for current process is</span></span><br><span class="line"><span class="comment"> * exhausted and update the proc struct ``proc&#x27;&#x27;. proc-&gt;time_slice</span></span><br><span class="line"><span class="comment"> * denotes the time slices left for current</span></span><br><span class="line"><span class="comment"> * process. proc-&gt;need_resched is the flag variable for process</span></span><br><span class="line"><span class="comment"> * switching.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">stride_proc_tick</span><span class="params">(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc)</span> &#123;</span><br><span class="line">     <span class="comment">/* LAB6: YOUR CODE */</span></span><br><span class="line">        <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                proc-&gt;time_slice --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;</span><br><span class="line">                proc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="实验七"><a href="#实验七" class="headerlink" title="实验七"></a>实验七</h1><h2 id="实验目的-3"><a href="#实验目的-3" class="headerlink" title="实验目的"></a>实验目的</h2><ul>
<li>理解操作系统的同步互斥的设计实现；</li>
<li>理解底层支撑技术：禁用中断、定时器、等待队列；</li>
<li>在ucore中理解信号量（semaphore）机制的具体实现；</li>
<li>理解管程机制，在ucore内核中增加基于管程（monitor）的条件变量（condition variable）的支持；</li>
<li>了解经典进程同步问题，并能使用同步机制解决进程同步问题。</li>
</ul>
<h2 id="实验内容-4"><a href="#实验内容-4" class="headerlink" title="实验内容"></a>实验内容</h2><p>lab6已经可以调度运行多个进程，如果多个进程需要协同操作或访问共享资源，则存在如何同步和有序竞争的问题。本次实验，主要是熟悉ucore的进程同步机制—信号量（semaphore）机制，以及基于信号量的哲学家就餐问题解决方案。然后掌握管程的概念和原理，并参考信号量机制，实现基于管程的条件变量机制和基于条件变量来解决哲学家就餐问题。</p>
<p>在本次实验中，在kern/sync/check_sync.c中提供了一个基于信号量的哲学家就餐问题解法。同时还需完成练习，即实现基于管程（主要是灵活运用条件变量和互斥信号量）的哲学家就餐问题解法。</p>
<p>哲学家就餐问题描述如下：有五个哲学家，他们的生活方式是交替地进行思考和进餐。哲学家们公用一张圆桌，周围放有五把椅子，每人坐一把。在圆桌上有五个碗和五根筷子，当一个哲学家思考时，他不与其他人交谈，饥饿时便试图取用其左、右最靠近他的筷子，但他可能一根都拿不到。只有在他拿到两根筷子时，方能进餐，进餐完后，放下筷子又继续思考。</p>
<h2 id="同步互斥的设计与实现"><a href="#同步互斥的设计与实现" class="headerlink" title="同步互斥的设计与实现"></a>同步互斥的设计与实现</h2><h3 id="实验执行流程概述-1"><a href="#实验执行流程概述-1" class="headerlink" title="实验执行流程概述"></a>实验执行流程概述</h3><p><strong>互斥</strong>是指某一资源同时只允许一个进程对其进行访问，具有<strong>唯一性</strong>和<strong>排它性</strong>，但<strong>互斥不用限制进程对资源的访问顺序</strong>，即访问可以是无序的。<strong>同步</strong>是指在进程间的执行必须严格<strong>按照规定的某种先后次序来运行</strong>，即访问是有序的，这种先后次序取决于要系统完成的任务需求。在进程写资源情况下，进程间要求满足互斥条件。在进程读资源情况下，可允许多个进程同时访问资源。</p>
<p>实验七设计实现了多种同步互斥手段，包括时钟中断管理、等待队列、信号量、管程机制（包含条件变量设计）等，并基于信号量实现了哲学家问题的执行过程。而本次实验的练习是要求用管程机制实现哲学家问题的执行过程。在实现信号量机制和管程机制时，需要让无法进入临界区的进程睡眠，为此在ucore中设计了等待队列wait_queue。当进程无法进入临界区（即无法获得信号量）时，可让进程进入等待队列，这时的进程处于等待状态（也可称为阻塞状态），从而会让实验六中的调度器选择一个处于就绪状态（即RUNNABLE_STATE）的进程，进行进程切换，让新进程有机会占用CPU执行，从而让整个系统的运行更加高效。</p>
<p>lab7/kern/sync/check_sync.c中的check_sync函数可以理解为是实验七的起始执行点，是实验七的总控函数。进一步分析此函数，可以看到这个函数主要分为了两个部分，第一部分是实现基于信号量的哲学家问题，第二部分是实现基于管程的哲学家问题。</p>
<ul>
<li>对于check_sync函数的第一部分，首先实现初始化了一个互斥信号量，然后创建了对应5个哲学家行为的5个信号量，并创建5个内核线程代表5个哲学家，每个内核线程完成了基于信号量的哲学家吃饭睡觉思考行为实现。</li>
<li>对于check_sync函数的第二部分，首先初始化了管程，然后又创建了5个内核线程代表5个哲学家，每个内核线程要完成基于管程的哲学家吃饭、睡觉、思考的行为实现。</li>
</ul>
<h3 id="同步互斥的底层支撑"><a href="#同步互斥的底层支撑" class="headerlink" title="同步互斥的底层支撑"></a>同步互斥的底层支撑</h3><p>由于调度的存在，且进程在访问某类资源暂时无法满足的情况下会进入等待状态，导致了多进程执行时序的不确定性和潜在执行结果的不确定性。为了确保执行结果的正确性，本试验需要设计更加完善的进程等待和互斥的底层支撑机制，确保能正确提供基于信号量和条件变量的同步互斥机制。</p>
<p>由于有定时器、屏蔽/使能中断、等待队列wait_queue支持test_and_set_bit等原子操作机器指令（在本次实验中没有用到）的存在，使得我们在实现进程等待、同步互斥上得到了极大的简化。下面将对定时器、屏蔽/使能中断和等待队列进行进一步讲解。</p>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>在传统的操作系统中，定时器提供了基于时间事件的调度机制。在ucore中，两次时间中断之间的时间间隔为一个时间片，timer splice。</p>
<p>基于此时间单位，操作系统得以向上提供基于时间点的事件，并实现基于时间长度的睡眠等待和唤醒机制。在每个时钟中断发生时，操作系统产生对应的时间事件。</p>
<p>sched.h, sched.c定义了有关timer的各种相关接口来使用 timer 服务，其中主要包括:</p>
<ul>
<li><code>typedef struct &#123;……&#125; timer_t</code>：定义了 timer_t 的基本结构，其可以用 sched.h 中的timer_init函数对其进行初始化。</li>
<li><code>void timer_init(timer t *timer, struct proc_struct *proc, int expires)</code>: 对某定时器进行初始化，让它在expires时间片之后唤醒proc进程。</li>
<li><code>void add_timer(timer t *timer)</code>：向系统添加某个初始化过的timer_t，该定时器在指定时间后被激活，并将对应的进程唤醒至runnable（如果当前进程处在等待状态）。</li>
<li><code>void del_timer(timer_t *time)</code>：向系统删除（或者说取消）某一个定时器。该定时器在取消后不会被系统激活并唤醒进程。</li>
<li><code>void run_timer_list(void)</code>：更新当前系统时间点，遍历当前所有处在系统管理内的定时器，找出所有应该激活的计数器，并激活它们。该过程在且只在每次定时器中断时被调用。在ucore中，其还会调用调度器事件处理程序。</li>
</ul>
<p>一个 timer_t 在系统中的存活周期可以被描述如下：</p>
<ul>
<li>timer_t在某个位置被创建和初始化，并通过add_timer加入系统管理列表中；</li>
<li>系统时间被不断累加，直到 run_timer_list 发现该 timer_t到期；</li>
<li>run_timer_list更改对应的进程状态，并从系统管理列表中移除该timer_t；</li>
</ul>
<h4 id="屏蔽与使能中断"><a href="#屏蔽与使能中断" class="headerlink" title="屏蔽与使能中断"></a>屏蔽与使能中断</h4><p>之前用过，这里简单看看。</p>
<p>在ucore中提供的底层机制包括中断屏蔽/使能控制等。<code>kern/sync.c</code>有开关中断的控制函数<code>local_intr_save(x)</code>和<code>local_intr_restore(x)</code>，它们是基于<code>kern/driver</code>文件下的<code>intr_enable()</code>、<code>intr_disable()</code>函数实现的。具体调用关系为：</p>
<blockquote>
<p>关中断：<code>local_intr_save</code> —&gt; <code>__intr_save</code> —&gt; <code>intr_disable</code> —&gt; <code>cli</code><br>开中断：<code>local_intr_restore</code> —&gt; <code>__intr_restore</code> —&gt; <code>intr_enable</code> —&gt; <code>sti</code></p>
</blockquote>
<p>最终的cli和sti是x86的机器指令，最终实现了关（屏蔽）中断和开（使能）中断，即设置了eflags寄存器中与中断相关的位。通过关闭中断，可以防止对当前执行的控制流被其他中断事件处理所打断。既然不能中断，那也就意味着在内核运行的当前进程无法被打断或被重新调度，即实现了对临界区的互斥操作。所以在单处理器情况下，可以通过开关中断实现对临界区的互斥保护，需要互斥的临界区代码的一般写法为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local_intr_save(intr_flag);</span><br><span class="line">&#123;</span><br><span class="line">  临界区代码</span><br><span class="line">&#125;</span><br><span class="line">local_intr_restore(intr_flag);</span><br></pre></td></tr></table></figure><br>但是，在多处理器情况下，这种方法是无法实现互斥的，因为屏蔽了一个CPU的中断，只能阻止本地CPU上的进程不会被中断或调度，并不意味着其他CPU上执行的进程不能执行临界区的代码。所以，开关中断只对单处理器下的互斥操作起作用。</p>
<h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>在课程中提到用户进程或内核线程可以转入等待状态以等待某个特定事件（比如睡眠,等待子进程结束,等待信号量等），当该事件发生时这些进程能够被再次唤醒。内核实现这一功能的一个底层支撑机制就是<strong>等待队列wait_queue</strong>，等待队列和每一个事件（睡眠结束、时钟到达、任务完成、资源可用等）联系起来。需要等待事件的进程在转入休眠状态后插入到等待队列中。当事件发生之后，内核遍历相应等待队列，唤醒休眠的用户进程或内核线程，并设置其状态为就绪状态（PROC_RUNNABLE），并将该进程从等待队列中清除。</p>
<p>ucore在<code>kern/sync/&#123; wait.h, wait.c &#125;</code>中实现了等待项wait结构和等待队列wait queue结构以及相关函数），这是实现ucore中的信号量机制和条件变量机制的基础，进入wait queue的进程会被设为等待状态（PROC_SLEEPING），直到他们被唤醒。</p>
<p>数据结构定义<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span>     <span class="comment">//等待进程的指针</span></span><br><span class="line">    <span class="type">uint32_t</span> wakeup_flags;        <span class="comment">//进程被放入等待队列的原因标记</span></span><br><span class="line">    <span class="type">wait_queue_t</span> *wait_queue;     <span class="comment">//指向此wait结构所属于的wait_queue</span></span><br><span class="line">    <span class="type">list_entry_t</span> wait_link;       <span class="comment">//用来组织wait_queue中wait节点的连接</span></span><br><span class="line">&#125; <span class="type">wait_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">list_entry_t</span> wait_head;       <span class="comment">//wait_queue的队头</span></span><br><span class="line">&#125; <span class="type">wait_queue_t</span>;</span><br><span class="line"></span><br><span class="line">le2wait(le, member)               <span class="comment">//实现wait_t中成员的指针向wait_t 指针的转化</span></span><br></pre></td></tr></table></figure><br>相关函数说明<br>与wait和wait queue相关的函数主要分为两层，底层函数是对wait queue的初始化、插入、删除和查找操作，相关函数如下：</p>
<p><code>wait_init</code>：初始化wait结构，将放入等待队列的原因标记设置为WT_INTERRUPTED，意为可以被打断等待状态<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wait_init</span><span class="params">(<span class="type">wait_t</span> *wait, <span class="keyword">struct</span> proc_struct *proc)</span> &#123;</span><br><span class="line">    wait-&gt;proc = proc;</span><br><span class="line">    wait-&gt;wakeup_flags = WT_INTERRUPTED;</span><br><span class="line">    list_init(&amp;(wait-&gt;wait_link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wait_in_queue</code>：wait是否在wait queue中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="title function_">wait_in_queue</span><span class="params">(<span class="type">wait_t</span> *wait)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !list_empty(&amp;(wait-&gt;wait_link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wait_queue_init</code>：初始化wait_queue结构<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">wait_queue_init(wait_queue_t *queue) &#123;</span><br><span class="line">    list_init(&amp;(queue-&gt;wait_head));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wait_queue_add</code>：设置当前等待项wait的等待队列，并把wait前插到wait queue中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wait_queue_add</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">wait_t</span> *wait)</span> &#123;</span><br><span class="line">    assert(list_empty(&amp;(wait-&gt;wait_link)) &amp;&amp; wait-&gt;proc != <span class="literal">NULL</span>);</span><br><span class="line">    wait-&gt;wait_queue = <span class="built_in">queue</span>;</span><br><span class="line">    list_add_before(&amp;(<span class="built_in">queue</span>-&gt;wait_head), &amp;(wait-&gt;wait_link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wait_queue_del</code>：从wait queue中删除wait<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wait_queue_del</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">wait_t</span> *wait)</span> &#123;</span><br><span class="line">    assert(!list_empty(&amp;(wait-&gt;wait_link)) &amp;&amp; wait-&gt;wait_queue == <span class="built_in">queue</span>);</span><br><span class="line">    list_del_init(&amp;(wait-&gt;wait_link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wait_queue_next</code>：取得wait_queue中wait等待项的后一个链接指针<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wait_t</span> *</span><br><span class="line"><span class="title function_">wait_queue_next</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">wait_t</span> *wait)</span> &#123;</span><br><span class="line">    assert(!list_empty(&amp;(wait-&gt;wait_link)) &amp;&amp; wait-&gt;wait_queue == <span class="built_in">queue</span>);</span><br><span class="line">    <span class="type">list_entry_t</span> *le = list_next(&amp;(wait-&gt;wait_link));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(<span class="built_in">queue</span>-&gt;wait_head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2wait(le, wait_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wait_queue_prev</code>：取得wait_queue中wait等待项的前一个链接指针<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wait_t</span> *</span><br><span class="line"><span class="title function_">wait_queue_prev</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">wait_t</span> *wait)</span> &#123;</span><br><span class="line">    assert(!list_empty(&amp;(wait-&gt;wait_link)) &amp;&amp; wait-&gt;wait_queue == <span class="built_in">queue</span>);</span><br><span class="line">    <span class="type">list_entry_t</span> *le = list_prev(&amp;(wait-&gt;wait_link));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(<span class="built_in">queue</span>-&gt;wait_head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2wait(le, wait_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wait_queue_first</code>：取得wait queue的第一个wait<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wait_t</span> *</span><br><span class="line"><span class="title function_">wait_queue_first</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="type">list_entry_t</span> *le = list_next(&amp;(<span class="built_in">queue</span>-&gt;wait_head));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(<span class="built_in">queue</span>-&gt;wait_head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2wait(le, wait_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wait_queue_last</code>：取得wait queue的最后一个wait<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wait_t</span> *</span><br><span class="line"><span class="title function_">wait_queue_last</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="type">list_entry_t</span> *le = list_prev(&amp;(<span class="built_in">queue</span>-&gt;wait_head));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(<span class="built_in">queue</span>-&gt;wait_head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2wait(le, wait_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>bool wait_queue_empty</code>：wait queue是否为空<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line">wait_queue_empty(wait_queue_t *queue) &#123;</span><br><span class="line">    return list_empty(&amp;(queue-&gt;wait_head));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>高层函数基于底层函数实现了让进程进入等待队列—wait_current_set，以及从等待队列中唤醒进程—wakeup_wait，相关函数如下：</p>
<p><code>wait_current_set</code>：进程进入等待队列，当前进程的状态设置成睡眠<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wait_current_set</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">wait_t</span> *wait, <span class="type">uint32_t</span> wait_state)</span> &#123;</span><br><span class="line">    assert(current != <span class="literal">NULL</span>);</span><br><span class="line">    wait_init(wait, current);</span><br><span class="line">    current-&gt;state = PROC_SLEEPING;</span><br><span class="line">    current-&gt;wait_state = wait_state;</span><br><span class="line">    wait_queue_add(<span class="built_in">queue</span>, wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wait_current_del</code>：把与当前进程关联的wait从等待队列queue中删除<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> wait_current_del(queue, wait)                                       \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                    \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (wait_in_queue(wait)) &#123;                                          \</span></span><br><span class="line"><span class="meta">            wait_queue_del(queue, wait);                                    \</span></span><br><span class="line"><span class="meta">        &#125;                                                                   \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure></p>
<p><code>wakeup_wait</code>：唤醒等待队列上的wait所关联的进程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup_wait</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">wait_t</span> *wait, <span class="type">uint32_t</span> wakeup_flags, <span class="type">bool</span> del)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (del) &#123;</span><br><span class="line">        wait_queue_del(<span class="built_in">queue</span>, wait);</span><br><span class="line">    &#125;</span><br><span class="line">    wait-&gt;wakeup_flags = wakeup_flags;</span><br><span class="line">    wakeup_proc(wait-&gt;proc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>void wakeup_first</code>：唤醒等待队列上第一个的等待的进程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup_first</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">uint32_t</span> wakeup_flags, <span class="type">bool</span> del)</span> &#123;</span><br><span class="line">    <span class="type">wait_t</span> *wait;</span><br><span class="line">    <span class="keyword">if</span> ((wait = wait_queue_first(<span class="built_in">queue</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        wakeup_wait(<span class="built_in">queue</span>, wait, wakeup_flags, del);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wakeup_queue</code>：唤醒等待队列上的所有等待进程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup_queue</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">uint32_t</span> wakeup_flags, <span class="type">bool</span> del)</span> &#123;</span><br><span class="line">    <span class="type">wait_t</span> *wait;</span><br><span class="line">    <span class="keyword">if</span> ((wait = wait_queue_first(<span class="built_in">queue</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (del) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                wakeup_wait(<span class="built_in">queue</span>, wait, wakeup_flags, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">while</span> ((wait = wait_queue_first(<span class="built_in">queue</span>)) != <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                wakeup_wait(<span class="built_in">queue</span>, wait, wakeup_flags, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">while</span> ((wait = wait_queue_next(<span class="built_in">queue</span>, wait)) != <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是一种同步互斥机制的实现，普遍存在于现在的各种操作系统内核里。相对于spinlock 的应用对象，信号量的应用对象是在临界区中运行的时间较长的进程。等待信号量的进程需要睡眠来减少占用 CPU 的开销。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">semWait</span><span class="params">(semaphore s)</span></span><br><span class="line">&#123;</span><br><span class="line">	s.count--;</span><br><span class="line">	<span class="keyword">if</span> (s.count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* place this process in s.queue */</span>;</span><br><span class="line">		<span class="comment">/* block this process */</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">semSignal</span><span class="params">(semaphore s)</span></span><br><span class="line">&#123;</span><br><span class="line">	s.count++;</span><br><span class="line">	<span class="keyword">if</span> (s.count&lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* remove a process P from s.queue */</span>;</span><br><span class="line">		<span class="comment">/* place process P on ready list */</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>基于上诉信号量实现可以认为，当多个（&gt;1）进程可以进行互斥或同步合作时，一个进程会由于无法满足信号量设置的某条件而在某一位置停止，直到它接收到一个特定的信号（表明条件满足了）。为了发信号，需要使用一个称作信号量的特殊变量。为通过信号量s传送信号，信号量的V操作采用进程可执行原语semSignal(s)；为通过信号量s接收信号，信号量的P操作采用进程可执行原语semWait(s)；如果相应的信号仍然没有发送，则进程被阻塞或睡眠，直到发送完为止。<br>ucore中信号量参照上述原理描述，建立在开关中断机制和wait_queue的基础上进行了具体实现。信号量的数据结构定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;                   <span class="comment">//信号量的当前值</span></span><br><span class="line">    <span class="type">wait_queue_t</span> wait_queue;     <span class="comment">//信号量对应的等待队列</span></span><br><span class="line">&#125; <span class="type">semaphore_t</span>;</span><br></pre></td></tr></table></figure><br><code>semaphore_t</code>是最基本的记录型信号量（record semaphore)结构，包含了用于计数的整数值value，和一个进程等待队列wait_queue，一个等待的进程会挂在此等待队列上。</p>
<p>在ucore中最重要的信号量操作是P操作函数<code>down(semaphore_t *sem)</code>和V操作函数<code>up(semaphore_t *sem)</code>。但这两个函数的具体实现是<code>__down(semaphore_t *sem, uint32_t wait_state)</code>函数和<code>__up(semaphore_t *sem, uint32_t wait_state)</code>函数，二者的具体实现描述如下：</p>
<p><code>__down(semaphore_t *sem, uint32_t wait_state, timer_t *timer)</code>：具体实现信号量的P操作，首先关掉中断，然后判断当前信号量的value是否大于0。如果是&gt;0，则表明可以获得信号量，故让value减一，并打开中断返回即可；如果不是&gt;0，则表明无法获得信号量，故需要将当前的进程加入到等待队列中，并打开中断，然后运行调度器选择另外一个进程执行。如果被V操作唤醒，则把自身关联的wait从等待队列中删除（此过程需要先关中断，完成后开中断）。</p>
<p><code>__up(semaphore_t *sem, uint32_t wait_state)</code>：具体实现信号量的V操作，首先关中断，如果信号量对应的wait queue中没有进程在等待，直接把信号量的value加一，然后开中断返回；如果有进程在等待且进程等待的原因是semophore设置的，则调用wakeup_wait函数将waitqueue中等待的第一个wait删除，且把此wait关联的进程唤醒，最后开中断返回。</p>
<p>对照信号量的原理性描述和具体实现，可以发现二者在流程上基本一致，只是具体实现采用了关中断的方式保证了对共享资源的互斥访问，通过等待队列让无法获得信号量的进程睡眠等待。另外，我们可以看出信号量的计数器value具有有如下性质：</p>
<ul>
<li>value&gt;0，表示共享资源的空闲数</li>
<li>vlaue&lt;0，表示该信号量的等待队列里的进程数</li>
<li>value=0，表示等待队列为空</li>
</ul>
<h3 id="管程和条件变量"><a href="#管程和条件变量" class="headerlink" title="管程和条件变量"></a>管程和条件变量</h3><h4 id="原理回顾"><a href="#原理回顾" class="headerlink" title="原理回顾"></a>原理回顾</h4><p>引入了管程是为了将对共享资源的所有访问及其所需要的同步操作集中并封装起来。Hansan为管程所下的定义：“一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据”。有上述定义可知，管程由四部分组成：</p>
<ul>
<li>管程内部的共享变量；</li>
<li>管程内部的条件变量；</li>
<li>管程内部并发执行的进程；</li>
<li>对局部于管程内部的共享数据设置初始值的语句。</li>
</ul>
<p>局限在管程中的数据结构，只能被局限在管程的操作过程所访问，任何管程之外的操作过程都不能访问它；另一方面，局限在管程中的操作过程也主要访问管程内的数据结构。由此可见，管程相当于一个<strong>隔离区</strong>，它把共享变量和对它进行操作的若干个过程围了起来，所有进程要访问临界资源时，都必须经过管程才能进入，而管程每次只允许一个进程进入管程，从而需要确保进程之间互斥。</p>
<p>但在管程中仅仅有互斥操作是不够用的。进程可能需要等待某个条件Cond为真才能继续执行。如果采用忙等(busy waiting)方式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while not( Cond ) do &#123;&#125;</span><br></pre></td></tr></table></figure><br>在单处理器情况下，将会导致所有其它进程都无法进入临界区使得该条件Cond为真，该管程的执行将会发生死锁。为此，可引入条件变量（Condition Variables，简称CV）。一个条件变量CV可理解为一个进程的等待队列，队列中的进程正等待某个条件Cond变为真。每个条件变量关联着一个条件，如果条件Cond不为真，则进程需要等待，如果条件Cond为真，则进程可以进一步在管程中执行。需要注意当一个进程等待一个条件变量CV（即等待Cond为真），该进程需要退出管程，这样才能让其它进程可以进入该管程执行，并进行相关操作，比如设置条件Cond为真，改变条件变量的状态，并唤醒等待在此条件变量CV上的进程。因此对条件变量CV有两种主要操作：</p>
<ul>
<li>wait_cv： 被一个进程调用，以等待断言Pc被满足后该进程可恢复执行. 进程挂在该条件变量上等待时，不被认为是占用了管程。</li>
<li>signal_cv：被一个进程调用，以指出断言Pc现在为真，从而可以唤醒等待断言Pc被满足的进程继续执行。</li>
</ul>
<p>“哲学家就餐”实例<br>有了互斥和信号量支持的管程就可用用了解决各种同步互斥问题。“用管程解决哲学家就餐问题”如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">monitor dp</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>THINKING, HUNGRY, EATING&#125; state[<span class="number">5</span>];</span><br><span class="line">    condition self[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">pickup</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        state[i] = HUNGRY;</span><br><span class="line">        test(i);</span><br><span class="line">        <span class="keyword">if</span> (state[i] != EATING)</span><br><span class="line">            self[i].wait_cv();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">putdown</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        state[i] = THINKING;</span><br><span class="line">        test((i + <span class="number">4</span>) % <span class="number">5</span>);</span><br><span class="line">        test((i + <span class="number">1</span>) % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((state[(i + <span class="number">4</span>) % <span class="number">5</span>] != EATING) &amp;&amp;</span><br><span class="line">           (state[i] == HUNGRY) &amp;&amp;</span><br><span class="line">           (state[(i + <span class="number">1</span>) % <span class="number">5</span>] != EATING)) &#123;</span><br><span class="line">              state[i] = EATING;</span><br><span class="line">              self[i].signal_cv();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initialization <span class="title function_">code</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        state[i] = THINKING;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h4><p>虽然大部分教科书上说明管程适合在语言级实现比如java等高级语言，没有提及在采用C语言的OS中如何实现。下面我们将要尝试在ucore中用C语言实现采用基于互斥和条件变量机制的管程基本原理。<br>ucore中的管程机制是基于信号量和条件变量来实现的。ucore中的管程的数据结构monitor_t定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span>&#123;</span></span><br><span class="line">    <span class="type">semaphore_t</span> mutex;      <span class="comment">// the mutex lock for going into the routines in monitor, should be initialized to 1</span></span><br><span class="line">    <span class="comment">// the next semaphore is used to </span></span><br><span class="line">    <span class="comment">//    (1) procs which call cond_signal funciton should DOWN next sema after UP cv.sema</span></span><br><span class="line">    <span class="comment">// OR (2) procs which call cond_wait funciton should UP next sema before DOWN cv.sema</span></span><br><span class="line">    <span class="type">semaphore_t</span> next;        </span><br><span class="line">    <span class="type">int</span> next_count;         <span class="comment">// the number of of sleeped procs which cond_signal funciton</span></span><br><span class="line">    <span class="type">condvar_t</span> *cv;          <span class="comment">// the condvars in monitor</span></span><br><span class="line">&#125; <span class="type">monitor_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>管程中的成员变量mutex是一个二值信号量，是实现每次只允许一个进程进入管程的关键元素，确保了互斥访问性质。管程中的条件变量cv通过执行wait_cv，会使得等待某个条件Cond为真的进程能够离开管程并睡眠，且让其他进程进入管程继续执行；而进入管程的某进程设置条件Cond为真并执行signal_cv时，能够让等待某个条件Cond为真的睡眠进程被唤醒，从而继续进入管程中执行。</p>
<p>注意：管程中的成员变量信号量next和整型变量next_count是配合进程对条件变量cv的操作而设置的，这是由于发出signal_cv的进程A会唤醒由于wait_cv而睡眠的进程B，由于管程中只允许一个进程运行，所以进程B执行会导致唤醒进程B的进程A睡眠，直到进程B离开管程，进程A才能继续执行，这个同步过程是通过信号量next完成的；而next_count表示了由于发出singal_cv而睡眠的进程个数。<br>管程中的条件变量的数据结构condvar_t定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">condvar</span>&#123;</span></span><br><span class="line">    <span class="type">semaphore_t</span> sem;     <span class="comment">// the sem semaphore is used to down the waiting proc, and the signaling proc should up the waiting proc</span></span><br><span class="line">    <span class="type">int</span> count;       　    <span class="comment">// the number of waiters on condvar</span></span><br><span class="line">    <span class="type">monitor_t</span> * owner;     <span class="comment">// the owner(monitor) of this condvar</span></span><br><span class="line">&#125; <span class="type">condvar_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>条件变量的定义中也包含了一系列的成员变量，信号量sem用于让发出wait_cv操作的等待某个条件Cond为真的进程睡眠，而让发出signal_cv操作的进程通过这个sem来唤醒睡眠的进程。count表示等在这个条件变量上的睡眠进程的个数。owner表示此条件变量的宿主是哪个管程。</p>
<h4 id="条件变量的signal和wait的设计"><a href="#条件变量的signal和wait的设计" class="headerlink" title="条件变量的signal和wait的设计"></a>条件变量的signal和wait的设计</h4><p>理解了数据结构的含义后，我们就可以开始管程的设计实现了。ucore设计实现了条件变量<code>wait_cv</code>操作和<code>signal_cv</code>操作对应的具体函数，即<code>cond_wait</code>函数和<code>cond_signal</code>函数，此外还有<code>cond_init</code>初始化函数。</p>
<p>首先来看wait_cv的原理实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cv.count++;</span><br><span class="line"><span class="keyword">if</span>(monitor.next_count &gt; <span class="number">0</span>)</span><br><span class="line">   sem_signal(monitor.next);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   sem_signal(monitor.mutex);</span><br><span class="line">sem_wait(cv.sem);</span><br><span class="line">cv.count -- ;</span><br></pre></td></tr></table></figure><br>对照着可分析出cond_wait函数的具体执行过程。可以看出如果进程A执行了cond_wait函数，表示此进程等待某个条件Cond不为真，需要睡眠。因此表示等待此条件的睡眠进程个数cv.count要加一。接下来会出现两种情况。</p>
<p>情况一：如果monitor.next_count如果大于0，表示有大于等于1个进程执行cond_signal函数且睡了，就睡在了monitor.next信号量上（假定这些进程挂在monitor.next信号量相关的等待队列Ｓ上），因此需要唤醒等待队列Ｓ中的一个进程B；然后进程A睡在cv.sem上。如果进程A醒了，则让cv.count减一，表示等待此条件变量的睡眠进程个数少了一个，可继续执行了！</p>
<p>这里隐含这一个现象，即某进程A在时间顺序上先执行了cond_signal，而另一个进程B后执行了cond_wait，这会导致进程A没有起到唤醒进程B的作用。</p>
<p>问题: 在cond_wait有sem_signal(mutex)，但没有看到哪里有sem_wait(mutex)，这好像没有成对出现，是否是错误的？ 答案：其实在管程中的每一个函数的入口处会有wait(mutex)，这样二者就配好对了。</p>
<p>情况二：如果monitor.next_count如果小于等于0，表示目前没有进程执行cond_signal函数且睡着了，那需要唤醒的是由于互斥条件限制而无法进入管程的进程，所以要唤醒睡在monitor.mutex上的进程。然后进程A睡在cv.sem上，如果睡醒了，则让cv.count减一，表示等待此条件的睡眠进程个数少了一个，可继续执行了！<br>然后来看signal_cv的原理实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( cv.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   monitor.next_count ++;</span><br><span class="line">   sem_signal(cv.sem);</span><br><span class="line">   sem_wait(monitor.next);</span><br><span class="line">   monitor.next_count -- ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对照着可分析出cond_signal函数的具体执行过程。首先进程B判断cv.count，如果不大于0，则表示当前没有执行cond_wait而睡眠的进程，因此就没有被唤醒的对象了，直接函数返回即可；如果大于0，这表示当前有执行cond_wait而睡眠的进程A，因此需要唤醒等待在cv.sem上睡眠的进程A。由于只允许一个进程在管程中执行，所以一旦进程B唤醒了别人（进程A），那么自己就需要睡眠。故让monitor.next_count加一，且让自己（进程B）睡在信号量monitor.next上。如果睡醒了，这让monitor.next_count减一。</p>
<h4 id="管程中函数的入口出口设计"><a href="#管程中函数的入口出口设计" class="headerlink" title="管程中函数的入口出口设计"></a>管程中函数的入口出口设计</h4><p>为了让整个管程正常运行，还需在管程中的每个函数的入口和出口增加相关操作，即：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function_in_monitor （…）</span><br><span class="line">&#123;</span><br><span class="line">  sem.wait(monitor.mutex);</span><br><span class="line">//-----------------------------</span><br><span class="line">  the real body of function;</span><br><span class="line">//-----------------------------</span><br><span class="line">  if(monitor.next_count &gt; 0)</span><br><span class="line">     sem_signal(monitor.next);</span><br><span class="line">  else</span><br><span class="line">     sem_signal(monitor.mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样带来的作用有两个，（1）只有一个进程在执行管程中的函数。（2）避免由于执行了cond_signal函数而睡眠的进程无法被唤醒。对于第二点，如果进程A由于执行了cond_signal函数而睡眠（这会让monitor.next_count大于0，且执行sem_wait(monitor.next)），则其他进程在执行管程中的函数的出口，会判断monitor.next_count是否大于0，如果大于0，则执行sem_signal(monitor.next)，从而执行了cond_signal函数而睡眠的进程被唤醒。上诉措施将使得管程正常执行。</p>
<h2 id="练习1：理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题"><a href="#练习1：理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题" class="headerlink" title="练习1：理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题"></a>练习1：理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题</h2><p>首先把trap.c中处理时钟中断的时候调用的sched_class_proc_tick函数替换为run_timer_list函数（后者中已经包括了前者），用于支持定时器机制；</p>
<p>在sem.c定义了内核级信号量机制的函数，先来学习这个文件。sem.h中是定义，这个semphore_t结构体就是信号量的定义了。里边有一个value和一个队列。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KERN_SYNC_SEM_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KERN_SYNC_SEM_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;defs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">wait_queue_t</span> wait_queue;</span><br><span class="line">&#125; <span class="type">semaphore_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">semaphore_t</span> *sem, <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">up</span><span class="params">(<span class="type">semaphore_t</span> *sem)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="type">semaphore_t</span> *sem)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">try_down</span><span class="params">(<span class="type">semaphore_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !__KERN_SYNC_SEM_H__ */</span></span></span><br></pre></td></tr></table></figure><br>sem_init对信号量进行初始化，信号量包括了一个整型数值变量和一个等待队列，该函数将该变量设置为指定的初始值（有几个资源），并且将等待队列初始化即可；wait_queue_init是把这个队列初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sem_init</span><span class="params">(<span class="type">semaphore_t</span> *sem, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    sem-&gt;value = value;</span><br><span class="line">    wait_queue_init(&amp;(sem-&gt;wait_queue));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wait_queue_init</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    list_init(&amp;(<span class="built_in">queue</span>-&gt;wait_head));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>__up</code>: 这个函数是<strong>释放</strong>一个该信号量对应的资源，如果它的等待队列中没有等待的请求，则直接把资源数加一，返回即可；如果在等待队列上有等在这个信号量上的进程，则调用<code>wakeup_wait</code>将其唤醒执行；在函数中禁用了中断，保证了操作的原子性，函数中操作的具体流程为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __noinline <span class="type">void</span> __up(<span class="type">semaphore_t</span> *sem, <span class="type">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">wait_t</span> *wait;</span><br><span class="line">        <span class="comment">//查询等待队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((wait = wait_queue_first(&amp;(sem-&gt;wait_queue))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sem-&gt;value ++;</span><br><span class="line">            <span class="comment">//如果是空的话，没有等待的线程，给整型变量加1；</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">//如果等待队列非空，有等待的线程，取出其中的一个进程唤醒；</span></span><br><span class="line">            assert(wait-&gt;proc-&gt;wait_state == wait_state);</span><br><span class="line">            wakeup_wait(&amp;(sem-&gt;wait_queue), wait, wait_state, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//这个函数找到等待的线程并唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>__down</code>: 是原理课中的P操作，表示请求一个该信号量对应的资源，同样禁用中断，保证原子性。首先查询整型变量看是否大于0，如果大于0则表示存在可分配的资源，整型变量减1，直接返回；如果整型变量小于等于0，表示没有可用的资源，那么当前进程的需求得不到满足，因此在<code>wait_current_set</code>中将其状态改为SLEEPING态，然后调用<code>wait_queue_add</code>将其挂到对应信号量的等待队列中，调用schedule函数进行调度，让出CPU，在资源得到满足，重新被唤醒之后，将自身从等待队列上删除掉；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __noinline <span class="type">uint32_t</span> __down(<span class="type">semaphore_t</span> *sem, <span class="type">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sem-&gt;value --;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">wait_t</span> __wait, *wait = &amp;__wait;</span><br><span class="line">    wait_current_set(&amp;(sem-&gt;wait_queue), wait, wait_state);</span><br><span class="line">    <span class="comment">// 挂起这个等待线程并加入等待队列</span></span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    schedule();</span><br><span class="line"></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    wait_current_del(&amp;(sem-&gt;wait_queue), wait);</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"><span class="comment">// 有可能当前线程被唤醒的原因跟之前等待的原因不一致</span></span><br><span class="line"><span class="comment">// 要把原因返回，由高层判断是否是合理状态。</span></span><br><span class="line">    <span class="keyword">if</span> (wait-&gt;wakeup_flags != wait_state) &#123;</span><br><span class="line">        <span class="keyword">return</span> wait-&gt;wakeup_flags;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wait_current_set</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">wait_t</span> *wait, <span class="type">uint32_t</span> wait_state)</span> &#123;</span><br><span class="line">    assert(current != <span class="literal">NULL</span>);</span><br><span class="line">    wait_init(wait, current);</span><br><span class="line">    current-&gt;state = PROC_SLEEPING;</span><br><span class="line">    current-&gt;wait_state = wait_state;</span><br><span class="line">    wait_queue_add(<span class="built_in">queue</span>, wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>try_down</code>: 简化版的P操作，如果资源数大于0则分配，资源数小于0也不进入等待队列，即使获取资源失败也不会堵塞当前进程；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">try_down</span><span class="params">(<span class="type">semaphore_t</span> *sem)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> intr_flag, ret = <span class="number">0</span>;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sem-&gt;value --, ret = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。</p>
<p>用于保证操作原子性的禁用中断机制、以及CPU提供的Test and Set指令机制都只能在用户态下运行，为了方便起见，可以将信号量机制的实现放在OS中来提供，然后使用系统调用的方法统一提供出若干个管理信号量的系统调用，分别如下所示：</p>
<ul>
<li>申请创建一个信号量的系统调用，可以指定初始值，返回一个信号量描述符(类似文件描述符)；</li>
<li>将指定信号量执行P操作；</li>
<li>将指定信号量执行V操作；</li>
<li>将指定信号量释放掉；</li>
</ul>
<p>给内核级线程提供信号量机制和给用户态进程/线程提供信号量机制的异同点在于：</p>
<blockquote>
<p>相同点：<br>提供信号量机制的代码实现逻辑是相同的；<br>不同点：<br>由于实现原子操作的中断禁用、Test and Set指令等均需要在内核态下运行，因此提供给用户态进程的信号量机制是通过系统调用来实现的，而内核级线程只需要直接调用相应的函数就可以了；</p>
</blockquote>
<h2 id="练习2-完成内核级条件变量和基于内核级条件变量的哲学家就餐问题"><a href="#练习2-完成内核级条件变量和基于内核级条件变量的哲学家就餐问题" class="headerlink" title="练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题"></a>练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题</h2><p>首先掌握管程机制，然后基于信号量实现完成条件变量实现，然后用管程机制实现哲学家就餐问题的解决方案（基于条件变量）。</p>
<p>In [OS CONCEPT] 7.7 section, the accurate define and approximate implementation of MONITOR was introduced.</p>
<p>通常，管程是一种语言结构，编译器通常会强制执行互斥。 将其与信号量进行比较，信号量通常是OS构造。</p>
<ul>
<li>DEFNIE &amp; CHARACTERISTIC:</li>
<li>管程是组合在一起的过程、变量和数据结构的集合。</li>
<li>进程可以调用监视程序但无法访问内部数据结构。</li>
<li>管程中一次只能有一个进程处于活动状态。</li>
<li>条件变量允许阻塞和解除阻塞。<ul>
<li>cv.wait() 阻塞一个进程<ul>
<li>该过程等待条件变量cv。</li>
</ul>
</li>
<li>cv.signal() (也视为 cv.notify) 解除一个等待条件变量cv的进程的阻塞状态。<br>发生这种情况时，我们仍然需要在管程中只有一个进程处于活动状态。 这可以通过以下几种方式完成：<ul>
<li>在某些系统上，旧进程（执行信号的进程）离开管程，新进程进入</li>
<li>在某些系统上，信号必须是管程内执行的最后一个语句。</li>
<li>在某些系统上，旧进程将阻塞，直到管程再次可用。</li>
<li>在某些系统上，新进程（未被信号阻止的进程）将保持阻塞状态，直到管程再次可用。</li>
</ul>
</li>
</ul>
</li>
<li>如果在没有人等待的情况下发出条件变量信号，则信号丢失。 将此与信号量进行比较，其中信号将允许将来执行等待的进程无阻塞。</li>
<li>不应该将条件变量视为传统意义上的变量。</li>
<li>它没有价值。</li>
<li>将其视为OOP意义上的对象。</li>
<li>它有两种方法，wait和signal来操纵调用过程。</li>
<li>定义如下，mutex保证对操作的互斥访问，这些访问主要是对共享变量的访问，所以需要互斥；cv是条件变量。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">monitor mt &#123;</span><br><span class="line">    ----------------variable------------------</span><br><span class="line">    semaphore mutex;</span><br><span class="line">    semaphore next;</span><br><span class="line">    <span class="type">int</span> next_count;</span><br><span class="line">    condvar &#123;<span class="type">int</span> count, sempahore sem&#125;  cv[N];</span><br><span class="line">    other variables in mt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">condvar</span>&#123;</span></span><br><span class="line">    <span class="type">semaphore_t</span> sem;        <span class="comment">// the sem semaphore is used to down the waiting proc, </span></span><br><span class="line">                            <span class="comment">// and the signaling proc should up the waiting proc</span></span><br><span class="line">    <span class="type">int</span> count;              <span class="comment">// the number of waiters on condvar</span></span><br><span class="line">    <span class="type">monitor_t</span> * owner;      <span class="comment">// the owner(monitor) of this condvar</span></span><br><span class="line">&#125; <span class="type">condvar_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span>&#123;</span></span><br><span class="line">    <span class="type">semaphore_t</span> mutex;      <span class="comment">// the mutex lock for going into the routines in monitor, should be initialized to 1    semaphore_t next;       // the next semaphore is used to down the signaling proc itself, </span></span><br><span class="line">                            <span class="comment">// and the other OR wakeuped waiting proc should wake up the sleeped signaling proc.</span></span><br><span class="line">    <span class="type">int</span> next_count;         <span class="comment">// the number of of sleeped signaling proc</span></span><br><span class="line">    <span class="type">condvar_t</span> *cv;          <span class="comment">// the condvars in monitor</span></span><br><span class="line">&#125; <span class="type">monitor_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>这是一个管程里的操作，首先在操作开始和结束有wait和signal，保证对中间的访问是互斥的，条件不满足则执行wait执行等待。特殊信号量next和后边的if-else是有对应关系的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--------routines in monitor---------------</span><br><span class="line">routineA_in_mt () &#123;</span><br><span class="line">   wait(mt.mutex);</span><br><span class="line">   ...</span><br><span class="line">   real body of routineA</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">if</span>(next_count&gt;<span class="number">0</span>)</span><br><span class="line">       signal(mt.next);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       signal(mt.mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>条件变量是管程的重要组成部分。<br>cond_wait: 一个条件得不到满足，则睡眠，如果这个条件得到满足，则另一个进程调用signal唤醒这个进程。该函数的功能为将当前进程等待在指定信号量上。等待队列的计数加1，然后释放管程的锁或者唤醒一个next上的进程来释放锁（否则会造成管程被锁死无法继续访问，同时这个操作不能和前面的等待队列计数加1的操作互换顺序，要不不能保证共享变量访问的互斥性），然后把自己等在条件变量的等待队列上，直到有signal信号将其唤醒，正常退出函数；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--------condvar wait/signal---------------</span><br><span class="line">cond_wait (cv) &#123;</span><br><span class="line">    cv.count ++;</span><br><span class="line">    <span class="keyword">if</span>(mt.next_count&gt;<span class="number">0</span>)</span><br><span class="line">       signal(mt.next)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       signal(mt.mutex);</span><br><span class="line">    wait(cv.sem);<span class="comment">//由于条件不满足，则wait，这里时cv的sem</span></span><br><span class="line">    cv.count --;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Suspend calling thread on a condition variable waiting for condition Atomically unlocks</span></span><br><span class="line"><span class="comment">// mutex and suspends calling thread on conditional variable after waking up locks mutex. Notice: mp is mutex semaphore for monitor&#x27;s procedures</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">cond_wait</span> <span class="params">(<span class="type">condvar_t</span> *cvp)</span> &#123;</span><br><span class="line">    <span class="comment">//LAB7 EXERCISE1: YOUR CODE</span></span><br><span class="line">    cprintf(<span class="string">&quot;cond_wait begin:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner</span><br><span class="line">-&gt;next_count);</span><br><span class="line">    cvp-&gt;count ++;</span><br><span class="line">    <span class="keyword">if</span> (cvp-&gt;owner-&gt;next_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        up(&amp;cvp-&gt;owner-&gt;next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        up(&amp;cvp-&gt;owner-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    down(&amp;cvp-&gt;sem);</span><br><span class="line">    cvp-&gt;count --;</span><br><span class="line">    cprintf(<span class="string">&quot;cond_wait end:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;</span><br><span class="line">next_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>cond_signal: 将指定条件变量上等待队列中的一个线程进行唤醒，并且将控制权转交给这个进程。判断当前的条件变量的等待队列是否大于0，即队列上是否有正在等待的进程，如果没有则不需要进行任何操作；如果有正在等待的进程，则将其中的一个唤醒，这里的等待队列是使用了一个信号量来进行实现的，由于信号量中已经包括了对等待队列的操作，因此要进行唤醒只需要对信号量执行up操作即可；接下来当前进程为了将控制权转交给被唤醒的进程，将自己等待到了这个条件变量所述的管程的next信号量上，这样的话就可以切换到被唤醒的进程。</p>
<p>有线程处于等待时，它的cv.count大于0，会有进一步的操作，唤醒其他进程，自身处于睡眠状态。上边的wait如果A进程中monitor.next_count大于0，那么可以唤醒monitor.next，正好与这里的wait对应。</p>
<p>如果cv.count大于0，有线程正在等待，把线程A从等待队列中移除，并唤醒线程A。在A的real_body之后的那个signal是唤醒B的实际函数。这里的next_count是发出条件变量signal的线程的个数。当B发出了条件变量signal操作，且把自身置成睡眠状态，使得被唤醒的A有机会在它自己退出的时候唤醒B。这是因为A和B都是在管程中执行的函数，都会涉及到对共享变量的访问，但是只允许一个进程对共享变量访问，保证互斥！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cond_signal(cv) &#123;</span><br><span class="line">    <span class="keyword">if</span>(cv.count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">       mt.next_count ++;</span><br><span class="line">       signal(cv.sem);</span><br><span class="line">       wait(mt.next);</span><br><span class="line">       mt.next_count--;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Unlock one of threads waiting on the condition variable.</span><br><span class="line">void</span><br><span class="line">cond_signal (condvar_t *cvp) &#123;</span><br><span class="line">   //LAB7 EXERCISE1: YOUR CODE</span><br><span class="line">   cprintf(&quot;cond_signal begin: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;, cvp, cvp-&gt;count, cvp-&gt;owner</span><br><span class="line">-&gt;next_count);</span><br><span class="line">   if(cvp-&gt;count&gt;0) &#123;</span><br><span class="line">       cvp-&gt;owner-&gt;next_count ++;</span><br><span class="line">       up(&amp;cvp-&gt;sem);</span><br><span class="line">       down(&amp;cvp-&gt;owner-&gt;next);</span><br><span class="line">       cvp-&gt;owner-&gt;next_count --;</span><br><span class="line">   &#125;</span><br><span class="line">   cprintf(&quot;cond_signal end: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;</span><br><span class="line">next_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>哲学家就餐问题：<br>phi_take_forks_condvar表示指定的哲学家尝试获得自己所需要进餐的两把叉子，如果不能获得则阻塞。首先给管程上锁，将哲学家的状态修改为HUNGER，判断当前哲学家是否可以获得足够的资源进行就餐，即判断与之相邻的哲学家是否正在进餐；如果能够进餐，将自己的状态修改成EATING，然后释放锁，离开管程即可；如果不能进餐，等待在自己对应的条件变量上，等待相邻的哲学家释放资源的时候将自己唤醒；<br>最终具体的代码实现如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void phi_take_forks_condvar(int i) &#123;</span><br><span class="line">//--------into routine in monitor--------------</span><br><span class="line">     // LAB7 EXERCISE1: YOUR CODE</span><br><span class="line">     // I am hungry</span><br><span class="line">     // try to get fork</span><br><span class="line">//--------leave routine in monitor--------------</span><br><span class="line">      down(&amp;(mtp-&gt;mutex));</span><br><span class="line">      state_condvar[i]=HUNGRY;</span><br><span class="line">      if(state_condvar[(i+4)%5]!=EATING &amp;&amp; state_condvar[(i+1)%5]!=EATING)&#123;</span><br><span class="line">          state_condvar[i]=EATING;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">          cprintf(&quot;phi_take_forks_condvar: %d didn’t get fork and will wait\n&quot;, i);</span><br><span class="line">          cond_wait(mtp-&gt;cv + i);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if(mtp-&gt;next_count&gt;0)</span><br><span class="line">         up(&amp;(mtp-&gt;next));</span><br><span class="line">      else</span><br><span class="line">         up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>phi_put_forks_condvar函数则是释放当前哲学家占用的叉子，并且唤醒相邻的因为得不到资源而进入等待的哲学家。首先获取管程的锁，将自己的状态修改成THINKING，检查相邻的哲学家是否在自己释放了叉子的占用之后满足了进餐的条件，如果满足，将其从等待中唤醒（使用cond_signal）；释放锁，离开管程；<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void phi_put_forks_condvar(int i) &#123;</span><br><span class="line">//--------into routine in monitor--------------</span><br><span class="line">     // LAB7 EXERCISE1: YOUR CODE</span><br><span class="line">     // I ate over</span><br><span class="line">     // test left and right neighbors</span><br><span class="line">//--------leave routine in monitor--------------</span><br><span class="line">    down(&amp;(mtp-&gt;mutex));</span><br><span class="line">    state_condvar[i] = THINKING;</span><br><span class="line">    cprintf(&quot;phi_put_forks_condvar: %d finished eating\n&quot;, i);</span><br><span class="line">    phi_test_condvar((i + N - 1) % N);</span><br><span class="line">    phi_test_condvar((i + 1) % N);</span><br><span class="line">    if(mtp-&gt;next_count&gt;0)</span><br><span class="line">       up(&amp;(mtp-&gt;next));</span><br><span class="line">    else</span><br><span class="line">       up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>phi_test_sema检查了第i个哲学家左右两边的人是不是处于EATING状态，如果都不是的话，而且第i个人又是HUNGRY的，则唤醒第i个。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define LEFT (i-1+N)%N /* i的左邻号码 */</span><br><span class="line">#define RIGHT (i+1)%N /* i的右邻号码 */</span><br><span class="line">void phi_test_sema(i) /* i：哲学家号码从0到N-1 */</span><br><span class="line">&#123;</span><br><span class="line">    if(state_sema[i]==HUNGRY&amp;&amp;state_sema[LEFT]!=EATING</span><br><span class="line">            &amp;&amp;state_sema[RIGHT]!=EATING)</span><br><span class="line">    &#123;</span><br><span class="line">        state_sema[i]=EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>请在实验报告中给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级 提供条件变量机制的异同。</p>
<p>本实验中管程的实现中互斥访问的保证是完全基于信号量的，如果根据上文中的说明使用系统调用实现用户态的信号量的实现机制，那么就可以按照相同的逻辑在用户态实现管程机制和条件变量机制；</p>
<h1 id="实验八"><a href="#实验八" class="headerlink" title="实验八"></a>实验八</h1><h2 id="实验目的-4"><a href="#实验目的-4" class="headerlink" title="实验目的"></a>实验目的</h2><p>通过完成本次实验，希望能达到以下目标：</p>
<ul>
<li>了解基本的文件系统系统调用的实现方法；</li>
<li>了解一个基于索引节点组织方式的Simple FS文件系统的设计与实现；</li>
<li>了解文件系统抽象层-VFS的设计与实现；</li>
</ul>
<h2 id="实验内容-5"><a href="#实验内容-5" class="headerlink" title="实验内容"></a>实验内容</h2><p>本次实验涉及的是文件系统，通过分析了解ucore文件系统的总体架构设计，完善读写文件操作，从新实现基于文件系统的执行程序机制（即改写do_execve），从而可以完成执行存储在磁盘上的文件和实现文件读写等功能。</p>
<h2 id="文件系统设计与实现"><a href="#文件系统设计与实现" class="headerlink" title="文件系统设计与实现"></a>文件系统设计与实现</h2><h3 id="ucore-文件系统总体介绍"><a href="#ucore-文件系统总体介绍" class="headerlink" title="ucore 文件系统总体介绍"></a>ucore 文件系统总体介绍</h3><p>UNIX提出了四个文件系统抽象概念：文件(file)、目录项(dentry)、索引节点(inode)和安装点(mount point)</p>
<ul>
<li>文件：文件中的内容可理解为是一有序字节，文件有一个方便应用程序识别的文件名称（也称文件路径名）。典型的文件操作有读、写、创建和删除等。</li>
<li>目录项：目录项不是目录（又称文件路径），而是<strong>目录的组成部分</strong>。在UNIX中目录被看作一种特定的文件，而目录项是文件路径中的一部分。如一个文件路径名是“/test/testfile”，则包含的目录项为：<ul>
<li>根目录“/”，</li>
<li>目录“test”和文件“testfile”</li>
<li>这三个都是目录项。</li>
<li>一般而言，目录项包含目录项的名字（文件名或目录名）和目录项的索引节点位置。</li>
</ul>
</li>
<li>索引节点：UNIX将文件的相关元数据信息（如访问控制权限、大小、拥有者、创建时间、数据内容等等信息）存储在一个单独的数据结构中，该结构被称为索引节点。</li>
<li>安装点：在UNIX中，文件系统被安装在一个特定的文件路径位置，这个位置就是安装点。所有的已安装文件系统都作为<strong>根文件系统树中的叶子</strong>出现在系统中。</li>
</ul>
<p>ucore模仿了UNIX的文件系统设计，ucore的文件系统架构主要由四部分组成：</p>
<ul>
<li><strong>通用文件系统访问接口层</strong>：该层提供了一个从用户空间到文件系统的标准访问接口。这一层访问接口让应用程序能够通过一个简单的接口获得ucore内核的文件系统服务。</li>
<li><strong>文件系统抽象层</strong>：向上提供一个一致的接口给内核其他部分（文件系统相关的系统调用实现模块和其他内核功能模块）访问。向下提供一个同样的抽象函数指针列表和数据结构屏蔽不同文件系统的实现细节。</li>
<li><strong>Simple FS文件系统层</strong>：一个基于索引方式的简单文件系统实例。向上通过各种具体函数实现以对应文件系统抽象层提出的抽象函数。向下访问外设接口</li>
<li><strong>外设接口层</strong>：向上提供device访问接口屏蔽不同硬件细节。向下实现访问各种具体设备驱动的接口，比如disk设备接口/串口设备接口/键盘设备接口等。</li>
</ul>
<p>假如应用程序操作文件（打开/创建/删除/读写）：</p>
<ol>
<li>通过文件系统的通用文件系统访问接口层为用户空间提供的访问接口进入文件系统内部；</li>
<li>文件系统抽象层把访问请求转发给某一具体文件系统（比如SFS文件系统）；</li>
<li>具体文件系统（Simple FS文件系统层）把应用程序的访问请求转化为对磁盘上的block的处理请求，并通过外设接口层交给磁盘驱动例程来完成具体的磁盘操作。</li>
</ol>
<ul>
<li>通用文件系统访问接口<ul>
<li>文件系统相关用户库<ul>
<li>write::usr/libs/file.c</li>
</ul>
</li>
<li>用户态文件系统相关系统调用访问接口<ul>
<li>sys_write/sys_call::/usr/libs/syscall.c</li>
</ul>
</li>
<li>内核态文件系统相关系统调用实现<ul>
<li>sys_write::/kern/syscall/syscall.c</li>
</ul>
</li>
</ul>
</li>
<li>文件系统抽象层VFS<ul>
<li>dir接口</li>
<li>file接口</li>
<li>inode接口</li>
<li>etc…</li>
<li>sysfile_write::kern/fs/sysfile.c </li>
<li>file_write::/kern/fs/file.c </li>
<li>vop_write::/kern/fs/vfs/inode.h</li>
</ul>
</li>
<li>Simple FS文件系统实现<ul>
<li>sfs的inode实现</li>
<li>sfs的外设访问接口</li>
<li>sfs_write::kern/fs/sfs/sfs_inode.c</li>
<li>sfs_wbuf::/kern/fs/sfs/sfs_io.c</li>
</ul>
</li>
<li>文件系统IO设备接口<ul>
<li>device访问接口</li>
<li>stdin/stdout访问接口</li>
<li>etc…</li>
<li>dop_io::/kern/fs/devs/dev.h</li>
<li>disk0_io::/kern/fs/devs/dev_disk0.c</li>
</ul>
</li>
<li>硬盘驱动、串口驱动<ul>
<li>ide_write_secs::/kern/driver/ide.c</li>
</ul>
</li>
</ul>
<h4 id="ucore文件系统总体结构"><a href="#ucore文件系统总体结构" class="headerlink" title="ucore文件系统总体结构"></a>ucore文件系统总体结构</h4><p>从ucore操作系统不同的角度来看，ucore中的文件系统架构包含四类主要的数据结构, 它们分别是：</p>
<ul>
<li>超级块（SuperBlock），它主要从<strong>文件系统的全局角度</strong>描述特定文件系统的全局信息。它的作用范围是整个OS空间。</li>
<li>索引节点（inode）：它主要从<strong>文件系统的单个文件的角度</strong>描述了文件的各种属性和数据所在位置。它的作用范围是整个OS空间。</li>
<li>目录项（dentry）：它主要从<strong>文件系统的文件路径的角度</strong>描述了文件路径中的一个特定的目录项（注：一系列目录项形成目录/文件路径）。它的作用范围是整个OS空间。<ul>
<li>对于SFS而言，inode(具体为struct sfs_disk_inode)对应于物理磁盘上的具体对象，</li>
<li>dentry（具体为struct sfs_disk_entry）是一个内存实体，其中的ino成员指向对应的inode number，另外一个成员是file name(文件名).</li>
</ul>
</li>
<li>文件（file），它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识，文件读写的位置，文件引用情况等信息。它的作用范围是某一具体进程。</li>
</ul>
<p><img src="/img/20190629002.png" alt="ucore中文件相关关键数据结构及其关系"></p>
<h3 id="通用文件系统访问接口"><a href="#通用文件系统访问接口" class="headerlink" title="通用文件系统访问接口"></a>通用文件系统访问接口</h3><h4 id="文件和目录相关用户库函数"><a href="#文件和目录相关用户库函数" class="headerlink" title="文件和目录相关用户库函数"></a>文件和目录相关用户库函数</h4><p>在文件操作方面，最基本的相关函数是open、close、read、write。</p>
<ul>
<li>在读写一个文件之前，首先要用open系统调用将其打开。<ul>
<li>open的第一个参数指定文件的路径名，可使用绝对路径名；</li>
<li>第二个参数指定打开的方式，可设置为O_RDONLY、O_WRONLY、O_RDWR，分别表示只读、只写、可读可写。</li>
<li>在打开一个文件后，就可以使用它返回的文件描述符fd对文件进行相关操作。</li>
</ul>
</li>
<li>在使用完一个文件后，还要用close系统调用把它关闭，其参数就是文件描述符fd。这样它的文件描述符就可以空出来，给别的文件使用。</li>
<li>读写文件内容的系统调用是read和write。read系统调用有三个参数：<ul>
<li>一个指定所操作的文件描述符，一个指定读取数据的存放地址，最后一个指定读多少个字节。在C程序中调用该系统调用的方法如下：<code>count = read(filehandle, buffer, nbytes);</code>。</li>
<li>该系统调用会把实际读到的字节数返回给count变量。在正常情形下这个值与nbytes相等，但有时可能会小一些。例如，在读文件时碰上了文件结束符，从而提前结束此次读操作。</li>
</ul>
</li>
</ul>
<p>对于目录而言，最常用的操作是跳转到某个目录，这里对应的用户库函数是<code>chdir</code>。然后就需要读目录的内容了，即列出目录中的文件或目录名，这在处理上与读文件类似，即需要：通过opendir函数打开目录，通过readdir来获取目录中的文件信息，读完后还需通过closedir函数来关闭目录。由于在ucore中把目录看成是一个特殊的文件，所以opendir和closedir实际上就是调用与文件相关的open和close函数。只有readdir需要调用获取目录内容的特殊系统调用sys_getdirentry。而且这里没有写目录这一操作。在目录中增加内容其实就是在此目录中创建文件，需要用到创建文件的函数。</p>
<h4 id="文件和目录访问相关系统调用"><a href="#文件和目录访问相关系统调用" class="headerlink" title="文件和目录访问相关系统调用"></a>文件和目录访问相关系统调用</h4><p>与文件相关的open、close、read、write用户库函数对应的是sys_open、sys_close、sys_read、sys_write四个系统调用接口。与目录相关的readdir用户库函数对应的是sys_getdirentry系统调用。这些系统调用函数接口将通过syscall函数来获得ucore的内核服务。当到了ucore内核后，在调用文件系统抽象层的file接口和dir接口。</p>
<h3 id="文件系统抽象层-VFS"><a href="#文件系统抽象层-VFS" class="headerlink" title="文件系统抽象层 - VFS"></a>文件系统抽象层 - VFS</h3><p>文件系统抽象层是把不同文件系统的对外共性接口提取出来，形成一个<strong>函数指针数组</strong>，这样，通用文件系统访问接口层只需访问文件系统抽象层，而不需关心具体文件系统的实现细节和接口。</p>
<h4 id="file-amp-dir接口"><a href="#file-amp-dir接口" class="headerlink" title="file &amp; dir接口"></a>file &amp; dir接口</h4><p>file&amp;dir接口层定义了进程在内核中直接访问的文件相关信息，这定义在file数据结构中，具体描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,</span><br><span class="line">    &#125; status;                   <span class="comment">//访问文件的执行状态</span></span><br><span class="line">    <span class="type">bool</span> readable;              <span class="comment">//文件是否可读</span></span><br><span class="line">    <span class="type">bool</span> writable;              <span class="comment">//文件是否可写</span></span><br><span class="line">    <span class="type">int</span> fd;                     <span class="comment">//文件在filemap中的索引值</span></span><br><span class="line">    <span class="type">off_t</span> pos;                  <span class="comment">//访问文件的当前位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span>         <span class="comment">//该文件对应的内存inode指针</span></span><br><span class="line">    <span class="type">int</span> open_count;             <span class="comment">//打开此文件的次数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>而在kern/process/proc.h中的proc_struct结构中描述了进程访问文件的数据接口files_struct，其数据结构定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">pwd</span>;</span>           <span class="comment">//进程当前执行目录的内存inode指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fd_array</span>;</span>       <span class="comment">//进程打开文件的数组</span></span><br><span class="line">    <span class="type">atomic_t</span> files_count;        <span class="comment">//访问此文件的线程个数</span></span><br><span class="line">    <span class="type">semaphore_t</span> files_sem;       <span class="comment">//确保对进程控制块中fs_struct的互斥访问</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当创建一个进程后，该进程的files_struct将会被初始化或复制父进程的files_struct。当用户进程打开一个文件时，将从fd_array数组中取得一个空闲file项，然后会把此file的成员变量node指针指向一个代表此文件的inode的起始地址。</p>
<h4 id="inode-接口"><a href="#inode-接口" class="headerlink" title="inode 接口"></a>inode 接口</h4><p>index node是位于内存的索引节点，它是VFS结构中的重要数据结构，因为它实际负责把不同文件系统的特定索引节点信息（甚至不能算是一个索引节点）统一封装起来，避免了进程直接访问具体文件系统。其定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>                                   <span class="comment">//包含不同文件系统特定inode信息的union成员变量</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> __<span class="title">device_info</span>;</span>          <span class="comment">//设备文件系统内存inode信息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> __<span class="title">sfs_inode_info</span>;</span>    <span class="comment">//SFS文件系统内存inode信息</span></span><br><span class="line">    &#125; in_info;   </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        inode_type_device_info = <span class="number">0x1234</span>,</span><br><span class="line">        inode_type_sfs_inode_info,</span><br><span class="line">    &#125; in_type;                          <span class="comment">//此inode所属文件系统类型</span></span><br><span class="line">    <span class="type">atomic_t</span> ref_count;                 <span class="comment">//此inode的引用计数</span></span><br><span class="line">    <span class="type">atomic_t</span> open_count;                <span class="comment">//打开此inode对应文件的个数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">in_fs</span>;</span>                   <span class="comment">//抽象的文件系统，包含访问文件系统的函数指针</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> *<span class="title">in_ops</span>;</span>     <span class="comment">//抽象的inode操作，包含访问inode的函数指针     </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在inode中，有一成员变量为in_ops，这是对此inode的<strong>操作函数指针列表</strong>，其数据结构定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vop_magic;</span><br><span class="line">    <span class="type">int</span> (*vop_open)(<span class="keyword">struct</span> inode *node, <span class="type">uint32_t</span> open_flags);</span><br><span class="line">    <span class="type">int</span> (*vop_close)(<span class="keyword">struct</span> inode *node);</span><br><span class="line">    <span class="type">int</span> (*vop_read)(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> iobuf *iob);</span><br><span class="line">    <span class="type">int</span> (*vop_write)(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> iobuf *iob);</span><br><span class="line">    <span class="type">int</span> (*vop_getdirentry)(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> iobuf *iob);</span><br><span class="line">    <span class="type">int</span> (*vop_create)(<span class="keyword">struct</span> inode *node, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">bool</span> excl, <span class="keyword">struct</span> inode **node_store);</span><br><span class="line">    <span class="type">int</span> (*vop_lookup)(<span class="keyword">struct</span> inode *node, <span class="type">char</span> *path, <span class="keyword">struct</span> inode **node_store);</span><br><span class="line">……</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><br>参照上面对SFS中的索引节点操作函数的说明，可以看出inode_ops是<strong>对常规文件、目录、设备文件所有操作的一个抽象函数表示</strong>。对于某一具体的文件系统中的文件或目录，只需实现相关的函数，就可以被用户进程访问具体的文件了，且用户进程无需了解具体文件系统的实现细节。</p>
<h3 id="Simple-FS-文件系统"><a href="#Simple-FS-文件系统" class="headerlink" title="Simple FS 文件系统"></a>Simple FS 文件系统</h3><p>ucore内核把所有文件都看作是字节流，任何内部逻辑结构都是专用的，由应用程序负责解释。但是ucore区分文件的物理结构。ucore目前支持如下几种类型的文件：</p>
<ul>
<li>常规文件：文件中包括的内容信息是由应用程序输入。SFS文件系统在普通文件上不强加任何内部结构，把其文件内容信息看作为字节。</li>
<li>目录：包含一系列的entry，每个entry包含文件名和指向与之相关联的索引节点（index node）的指针。目录是按层次结构组织的。</li>
<li>链接文件：实际上一个链接文件是一个已经存在的文件的另一个可选择的文件名。</li>
<li>设备文件：不包含数据，但是提供了一个映射物理设备（如串口、键盘等）到一个文件名的机制。可通过设备文件访问外围设备。</li>
<li>管道：管道是进程间通讯的一个基础设施。管道缓存了其输入端所接受的数据，以便在管道输出端读的进程能一个先进先出的方式来接受数据。</li>
</ul>
<p>SFS文件系统中目录和常规文件具有共同的属性，而这些属性保存在索引节点中。SFS通过索引节点来管理目录和常规文件，索引节点包含操作系统所需要的关于某个文件的关键信息，比如文件的属性、访问许可权以及其它控制信息都保存在索引节点中。可以有多个文件名可指向一个索引节点。</p>
<h4 id="文件系统的布局"><a href="#文件系统的布局" class="headerlink" title="文件系统的布局"></a>文件系统的布局</h4><p>文件系统通常保存在磁盘上。在本实验中，第三个磁盘（即disk0，前两个磁盘分别是<code>ucore.img</code>和<code>swap.img</code>）用于存放一个SFS文件系统（Simple Filesystem）。通常文件系统中，磁盘的使用是以扇区（Sector）为单位的，但是为了实现简便，SFS 中以 block （4K，与内存 page 大小相等）为基本单位。<br>SFS文件系统的布局如下图所示。<br><code>superblock -&gt; root-dir inode -&gt; freemap -&gt; inode/file_data/dir_data_blocks</code></p>
<p>第0个块（4K）是超级块（superblock），它包含了关于文件系统的所有关键参数，当计算机被启动或文件系统被首次接触时，超级块的内容就会被装入内存。其定义如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct sfs_super &#123;</span><br><span class="line">    uint32_t magic;                                  /* magic number, should be SFS_MAGIC */</span><br><span class="line">    uint32_t blocks;                                 /* # of blocks in fs */</span><br><span class="line">    uint32_t unused_blocks;                         /* # of unused blocks in fs */</span><br><span class="line">    char info[SFS_MAX_INFO_LEN + 1];                /* infomation for sfs  */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>可以看到，包含：</p>
<ul>
<li>成员变量魔数magic，其值为<code>0x2f8dbe2a</code>，内核通过它来检查磁盘镜像是否是合法的 SFS img；</li>
<li>成员变量blocks记录了SFS中所有block的数量，即 img 的大小；</li>
<li>成员变量unused_block记录了SFS中还没有被使用的block的数量；</li>
<li>成员变量info包含了字符串”simple file system”。</li>
</ul>
<p>第1个块放了一个root-dir的inode，用来记录根目录的相关信息。有关inode还将在后续部分介绍。通过这个root-dir的inode信息就可以定位并查找到根目录下的所有文件信息。</p>
<p>从第2个块开始，根据SFS中所有块的数量，用1个bit来表示一个块的占用和未被占用的情况。这个区域称为SFS的freemap区域，这将占用若干个块空间。为了更好地记录和管理freemap区域，专门提供了两个文件kern/fs/sfs/bitmap.[ch]来完成根据一个块号查找或设置对应的bit位的值。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct bitmap &#123;</span><br><span class="line">    uint32_t nbits;</span><br><span class="line">    uint32_t nwords;</span><br><span class="line">    WORD_TYPE *map;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>最后在剩余的磁盘空间中，存放了所有其他目录和文件的inode信息和内容数据信息。需要注意的是虽然inode的大小小于一个块的大小（4096B），但为了实现简单，每个 inode 都占用一个完整的 block。<br>在sfs_fs.c文件中的sfs_do_mount函数中，完成了加载位于硬盘上的SFS文件系统的超级块superblock和freemap的工作。这样，在内存中就有了SFS文件系统的全局信息。</p>
<p>在fs_init中分别调用了<code>vfs_init()</code>，<code>dev_init()</code>和<code>sfs_init()</code>，<code>sfs_init()</code>中调用了<code>sfs_mount(&quot;disk0&quot;)</code>，<code>sfs_mount</code>中调用了<code>vfs_mount(devname, sfs_do_mount);</code>，<code>vfs_mount()</code>中从设备列表中找到一个名字相同的设备，这个设备的fs应该是NULL，即它是没有被挂载到某个文件系统的。找到这个设备的inode中in_info，调用传进来的mountfunc，即sfs_do_mount<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sfs_do_mount - mount sfs file system.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @dev:        the block device contains sfs file system</span></span><br><span class="line"><span class="comment"> * @fs_store:   the fs struct in memroy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sfs_do_mount</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> fs **fs_store)</span> &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(SFS_BLKSIZE &gt;= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sfs_super));</span><br><span class="line">    <span class="keyword">static_assert</span>(SFS_BLKSIZE &gt;= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sfs_disk_inode));</span><br><span class="line">    <span class="keyword">static_assert</span>(SFS_BLKSIZE &gt;= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sfs_disk_entry));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;d_blocksize != SFS_BLKSIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NA_DEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配一个fs的结构 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((fs = alloc_fs(sfs)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 获取这个sfs的sfs_fs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> *<span class="title">sfs</span> =</span> fsop_info(fs, sfs);</span><br><span class="line">    sfs-&gt;dev = dev;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = -E_NO_MEM;</span><br><span class="line">    <span class="type">void</span> *sfs_buffer;</span><br><span class="line">    <span class="keyword">if</span> ((sfs-&gt;sfs_buffer = sfs_buffer = kmalloc(SFS_BLKSIZE)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_fs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 专门用来读超级块的 */</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_init_read(dev, SFS_BLKN_SUPER, sfs_buffer)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_sfs_buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> *<span class="title">super</span> =</span> sfs_buffer;</span><br><span class="line">    <span class="keyword">if</span> (super-&gt;magic != SFS_MAGIC) &#123;</span><br><span class="line">    	<span class="comment">// 开头一定要是魔数</span></span><br><span class="line">        cprintf(<span class="string">&quot;sfs: wrong magic in superblock. (%08x should be %08x).\n&quot;</span>,</span><br><span class="line">                super-&gt;magic, SFS_MAGIC);</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_sfs_buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (super-&gt;blocks &gt; dev-&gt;d_blocks) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;sfs: fs has %u blocks, device has %u blocks.\n&quot;</span>,</span><br><span class="line">                super-&gt;blocks, dev-&gt;d_blocks);</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_sfs_buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    super-&gt;info[SFS_MAX_INFO_LEN] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    sfs-&gt;super = *super;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* alloc and initialize hash list, 用于inode */</span></span><br><span class="line">    <span class="type">list_entry_t</span> *hash_list;</span><br><span class="line">    <span class="keyword">if</span> ((sfs-&gt;hash_list = hash_list = kmalloc(<span class="keyword">sizeof</span>(<span class="type">list_entry_t</span>) * SFS_HLIST_SIZE)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_sfs_buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SFS_HLIST_SIZE; i ++) &#123;</span><br><span class="line">        list_init(hash_list + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* load and check freemap */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> *<span class="title">freemap</span>;</span></span><br><span class="line">    <span class="type">uint32_t</span> freemap_size_nbits = sfs_freemap_bits(super);</span><br><span class="line">    <span class="keyword">if</span> ((sfs-&gt;freemap = freemap = bitmap_create(freemap_size_nbits)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_hash_list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint32_t</span> freemap_size_nblks = sfs_freemap_blocks(super);</span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_init_freemap(dev, freemap, SFS_BLKN_FREEMAP, freemap_size_nblks, sfs_buffer)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_freemap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> blocks = sfs-&gt;super.blocks, unused_blocks = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; freemap_size_nbits; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bitmap_test(freemap, i)) &#123;</span><br><span class="line">            unused_blocks ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(unused_blocks == sfs-&gt;super.unused_blocks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* and other fields */</span></span><br><span class="line">    sfs-&gt;super_dirty = <span class="number">0</span>;</span><br><span class="line">    sem_init(&amp;(sfs-&gt;fs_sem), <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;(sfs-&gt;io_sem), <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;(sfs-&gt;mutex_sem), <span class="number">1</span>);</span><br><span class="line">    list_init(&amp;(sfs-&gt;inode_list));</span><br><span class="line">    cprintf(<span class="string">&quot;sfs: mount: &#x27;%s&#x27; (%d/%d/%d)\n&quot;</span>, sfs-&gt;super.info,</span><br><span class="line">            blocks - unused_blocks, unused_blocks, blocks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* link addr of sync/get_root/unmount/cleanup funciton  fs&#x27;s function pointers*/</span></span><br><span class="line">    fs-&gt;fs_sync = sfs_sync;</span><br><span class="line">    fs-&gt;fs_get_root = sfs_get_root;</span><br><span class="line">    fs-&gt;fs_unmount = sfs_unmount;</span><br><span class="line">    fs-&gt;fs_cleanup = sfs_cleanup;</span><br><span class="line">    *fs_store = fs;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">failed_cleanup_freemap:</span><br><span class="line">    bitmap_destroy(freemap);</span><br><span class="line">failed_cleanup_hash_list:</span><br><span class="line">    kfree(hash_list);</span><br><span class="line">failed_cleanup_sfs_buffer:</span><br><span class="line">    kfree(sfs_buffer);</span><br><span class="line">failed_cleanup_fs:</span><br><span class="line">    kfree(fs);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h4><p>在SFS文件系统中，需要记录文件内容的存储位置以及文件名与文件内容的对应关系。</p>
<ul>
<li>sfs_disk_inode记录了文件或目录的内容存储的索引信息，该数据结构在硬盘里储存，需要时读入内存。</li>
<li>sfs_disk_entry表示一个目录中的一个文件或目录，包含该项所对应inode的位置和文件名，同样也在硬盘里储存，需要时读入内存。</li>
</ul>
<h5 id="磁盘索引节点"><a href="#磁盘索引节点" class="headerlink" title="磁盘索引节点"></a>磁盘索引节点</h5><p>SFS中的磁盘索引节点代表了一个实际位于磁盘上的文件。首先我们看看在硬盘上的索引节点的内容：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> size;                          如果inode表示常规文件，则size是文件大小</span><br><span class="line">    <span class="type">uint16_t</span> type;                          inode的文件类型</span><br><span class="line">    <span class="type">uint16_t</span> nlinks;                        此inode的硬链接数</span><br><span class="line">    <span class="type">uint32_t</span> blocks;                        此inode的数据块数的个数</span><br><span class="line">    <span class="type">uint32_t</span> direct[SFS_NDIRECT];           此inode的直接数据块索引值（有SFS_NDIRECT个）</span><br><span class="line">    <span class="type">uint32_t</span> indirect;                      此inode的一级间接数据块索引值</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过上表可以看出，如果inode表示的是文件，则成员变量direct[]直接指向了保存文件内容数据的数据块索引值。indirect间接指向了保存文件内容数据的数据块，indirect指向的是间接数据块（indirect_block），此数据块实际存放的全部是数据块索引，这些数据块索引指向的数据块才被用来存放文件内容数据。</p>
<p>默认的，ucore 里 SFS_NDIRECT 是 12，即直接索引的数据页大小为 12 <em> 4k = 48k；当使用一级间接数据块索引时，ucore 支持最大的文件大小为 12 </em> 4k + 1024 * 4k = 48k + 4m。数据索引表内，0 表示一个无效的索引，inode 里 blocks 表示该文件或者目录占用的磁盘的 block 的个数。indiret 为 0 时，表示不使用一级索引块。（因为 block 0 用来保存 super block，它不可能被其他任何文件或目录使用，所以这么设计也是合理的）。</p>
<p>对于普通文件，索引值指向的 block 中保存的是文件中的数据。而对于目录，索引值指向的数据保存的是目录下所有的文件名以及对应的索引节点所在的索引块（磁盘块）所形成的数组。数据结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file entry (on disk) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> ino;                                   索引节点所占数据块索引值</span><br><span class="line">    <span class="type">char</span> name[SFS_MAX_FNAME_LEN + <span class="number">1</span>];               文件名</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>操作系统中，每个文件系统下的 inode 都应该分配唯一的 inode 编号。SFS 下，为了实现的简便，每个 inode 直接用他所在的磁盘 block 的编号作为 inode 编号。比如，root block 的 inode 编号为 1；每个 sfs_disk_entry 数据结构中，name 表示目录下文件或文件夹的名称，ino 表示磁盘 block 编号，通过读取该 block 的数据，能够得到相应的文件或文件夹的 inode。ino 为0时，表示一个无效的 entry。<br>此外，和 inode 相似，每个 sfs_dirent_entry 也占用一个 block。</p>
<h4 id="内存中的索引节点"><a href="#内存中的索引节点" class="headerlink" title="内存中的索引节点"></a>内存中的索引节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* inode for sfs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span>;</span>                     <span class="comment">/* on-disk inode */</span></span><br><span class="line">    <span class="type">uint32_t</span> ino;                                   <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;                                 <span class="comment">/* inode flags */</span></span><br><span class="line">    <span class="type">bool</span> dirty;                                     <span class="comment">/* true if inode modified */</span></span><br><span class="line">    <span class="type">int</span> reclaim_count;                              <span class="comment">/* kill inode if it hits zero */</span></span><br><span class="line">    <span class="type">semaphore_t</span> sem;                                <span class="comment">/* semaphore for din */</span></span><br><span class="line">    <span class="type">list_entry_t</span> inode_link;                        <span class="comment">/* entry for linked-list in sfs_fs */</span></span><br><span class="line">    <span class="type">list_entry_t</span> hash_link;                         <span class="comment">/* entry for hash linked-list in sfs_fs */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到SFS中的内存inode包含了SFS的硬盘inode信息，而且还增加了其他一些信息，这属于是便于进行是判断否改写、互斥操作、回收和快速地定位等作用。需要注意，一个内存inode是在打开一个文件后才创建的，如果关机则相关信息都会消失。而硬盘inode的内容是保存在硬盘中的，只是在进程需要时才被读入到内存中，用于访问文件或目录的具体内容数据</p>
<p>为了方便实现上面提到的多级数据的访问以及目录中 entry 的操作，对 inode SFS实现了一些辅助的函数：</p>
<ul>
<li>sfs_bmap_load_nolock：将对应 sfs_inode 的第 index 个索引指向的 block 的索引值取出存到相应的指针指向的单元（ino_store）。该函数只接受 index &lt;= inode-&gt;blocks 的参数。当 index == inode-&gt;blocks 时，该函数理解为需要为 inode 增长一个 block。并标记 inode 为 dirty（所有对 inode 数据的修改都要做这样的操作，这样，当 inode 不再使用的时候，sfs 能够保证 inode 数据能够被写回到磁盘）。sfs_bmap_load_nolock 调用的 sfs_bmap_get_nolock 来完成相应的操作，阅读 sfs_bmap_get_nolock，了解他是如何工作的。（sfs_bmap_get_nolock 只由 sfs_bmap_load_nolock 调用）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sfs_bmap_load_nolock - according to the DIR&#x27;s inode and the logical index of block in inode, find the NO. of</span></span><br><span class="line"><span class="comment">disk block.</span></span><br><span class="line"><span class="comment"> * @sfs:      sfs file system</span></span><br><span class="line"><span class="comment"> * @sin:      sfs inode in memory</span></span><br><span class="line"><span class="comment"> * @index:    the logical index of disk block in inode</span></span><br><span class="line"><span class="comment"> * @ino_store:the NO. of disk block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sfs_bmap_load_nolock</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs, <span class="keyword">struct</span> sfs_inode *<span class="built_in">sin</span>, <span class="type">uint32_t</span> index, <span class="type">uint32_t</span> *ino_store)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span> =</span> <span class="built_in">sin</span>-&gt;din;</span><br><span class="line">    assert(index &lt;= din-&gt;blocks);</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">uint32_t</span> ino;</span><br><span class="line">    <span class="type">bool</span> create = (index == din-&gt;blocks);</span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_bmap_get_nolock(sfs, <span class="built_in">sin</span>, index, create, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(sfs_block_inuse(sfs, ino));</span><br><span class="line">    <span class="keyword">if</span> (create) &#123;</span><br><span class="line">        din-&gt;blocks ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ino_store != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *ino_store = ino;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sfs_bmap_get_nolock - according sfs_inode and index of block, find the NO. of disk block</span></span><br><span class="line"><span class="comment"> *                       no lock protect</span></span><br><span class="line"><span class="comment"> * @sfs:      sfs file system</span></span><br><span class="line"><span class="comment"> * @sin:      sfs inode in memory</span></span><br><span class="line"><span class="comment"> * @index:    the index of block in inode</span></span><br><span class="line"><span class="comment"> * @create:   BOOL, if the block isn&#x27;t allocated, if create = 1 the alloc a block,  otherwise just do nothing</span></span><br><span class="line"><span class="comment"> * @ino_store: 0 OR the index of already inused block or new allocated block.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sfs_bmap_get_nolock</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs, <span class="keyword">struct</span> sfs_inode *<span class="built_in">sin</span>, <span class="type">uint32_t</span> index, <span class="type">bool</span> create, <span class="type">uint32_t</span> *ino_store)</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span> =</span> <span class="built_in">sin</span>-&gt;din;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">uint32_t</span> ent, ino;</span><br><span class="line">    <span class="comment">// the index of disk block is in the fist SFS_NDIRECT direct blocks</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; SFS_NDIRECT) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ino = din-&gt;direct[index]) == <span class="number">0</span> &amp;&amp; create) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ret = sfs_block_alloc(sfs, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            din-&gt;direct[index] = ino;</span><br><span class="line">            <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the index of disk block is in the indirect blocks.</span></span><br><span class="line">    index -= SFS_NDIRECT;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; SFS_BLK_NENTRY) &#123;</span><br><span class="line">        ent = din-&gt;indirect;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_get_sub_nolock(sfs, &amp;ent, index, create, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ent != din-&gt;indirect) &#123;</span><br><span class="line">            assert(din-&gt;indirect == <span class="number">0</span>);</span><br><span class="line">            din-&gt;indirect = ent;</span><br><span class="line">            <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        panic (<span class="string">&quot;sfs_bmap_get_nolock - index out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    assert(ino == <span class="number">0</span> || sfs_block_inuse(sfs, ino));</span><br><span class="line">    *ino_store = ino;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sfs_bmap_truncate_nolock：将多级数据索引表的最后一个 entry 释放掉。他可以认为是 sfs_bmap_load_nolock 中，index == inode-&gt;blocks 的逆操作。当一个文件或目录被删除时，sfs 会循环调用该函数直到 inode-&gt;blocks 减为 0，释放所有的数据页。函数通过 sfs_bmap_free_nolock 来实现，他应该是 sfs_bmap_get_nolock 的逆操作。和 sfs_bmap_get_nolock 一样，调用 sfs_bmap_free_nolock 也要格外小心。</li>
<li>sfs_dirent_read_nolock：将目录的第 slot 个 entry 读取到指定的内存空间。他通过上面提到的函数来完成。</li>
<li>sfs_dirent_search_nolock：是常用的查找函数。他在目录下查找 name，并且返回相应的搜索结果（文件或文件夹）的 inode 的编号（也是磁盘编号），和相应的 entry 在该目录的 index 编号以及目录下的数据页是否有空闲的 entry。（SFS 实现里文件的数据页是连续的，不存在任何空洞；而对于目录，数据页不是连续的，当某个 entry 删除的时候，SFS 通过设置 entry-&gt;ino 为0将该 entry 所在的 block 标记为 free，在需要添加新 entry 的时候，SFS 优先使用这些 free 的 entry，其次才会去在数据页尾追加新的 entry。</li>
</ul>
<p>注意，这些后缀为 nolock 的函数，只能在已经获得相应 inode 的semaphore才能调用。</p>
<p>inode的文件操作函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_fileops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_openfile,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_read                       = sfs_read,</span><br><span class="line">    .vop_write                      = sfs_write,</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>上述sfs_openfile、sfs_close、sfs_read和sfs_write分别对应用户进程发出的open、close、read、write操作。其中sfs_openfile不用做什么事；sfs_close需要把对文件的修改内容写回到硬盘上，这样确保硬盘上的文件内容数据是最新的；sfs_read和sfs_write函数都调用了一个函数sfs_io，并最终通过访问硬盘驱动来完成对文件内容数据的读写。</p>
<h5 id="inode的目录操作函数"><a href="#inode的目录操作函数" class="headerlink" title="inode的目录操作函数"></a>inode的目录操作函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_dirops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_opendir,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_getdirentry                = sfs_getdirentry,</span><br><span class="line">    .vop_lookup                     = sfs_lookup,                           </span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于目录操作而言，由于目录也是一种文件，所以sfs_opendir、sys_close对应户进程发出的open、close函数。相对于sfs_open，sfs_opendir只是完成一些open函数传递的参数判断，没做其他更多的事情。目录的close操作与文件的close操作完全一致。由于目录的内容数据与文件的内容数据不同，所以读出目录的内容数据的函数是sfs_getdirentry，其主要工作是获取目录下的文件inode信息。</p>
<h3 id="设备层文件-IO-层"><a href="#设备层文件-IO-层" class="headerlink" title="设备层文件 IO 层"></a>设备层文件 IO 层</h3><p>在本实验中，为了统一地访问设备，我们可以把一个设备看成一个文件，通过访问文件的接口来访问设备。目前实现了stdin设备文件文件、stdout设备文件、disk0设备。stdin设备就是键盘，stdout设备就是CONSOLE（串口、并口和文本显示器），而disk0设备是承载SFS文件系统的磁盘设备。下面我们逐一分析ucore是如何让用户把设备看成文件来访问。</p>
<h4 id="关键数据结构-1"><a href="#关键数据结构-1" class="headerlink" title="关键数据结构"></a>关键数据结构</h4><p>为了表示一个设备，需要有对应的数据结构，ucore为此定义了<code>struct device</code>，其描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> d_blocks;    <span class="comment">//设备占用的数据块个数            </span></span><br><span class="line">    <span class="type">size_t</span> d_blocksize;  <span class="comment">//数据块的大小</span></span><br><span class="line">    <span class="type">int</span> (*d_open)(<span class="keyword">struct</span> device *dev, <span class="type">uint32_t</span> open_flags);  <span class="comment">//打开设备的函数指针</span></span><br><span class="line">    <span class="type">int</span> (*d_close)(<span class="keyword">struct</span> device *dev); <span class="comment">//关闭设备的函数指针</span></span><br><span class="line">    <span class="type">int</span> (*d_io)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> iobuf *iob, <span class="type">bool</span> write); <span class="comment">//读写设备的函数指针</span></span><br><span class="line">    <span class="type">int</span> (*d_ioctl)(<span class="keyword">struct</span> device *dev, <span class="type">int</span> op, <span class="type">void</span> *data); <span class="comment">//用ioctl方式控制设备的函数指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个数据结构能够支持对块设备（比如磁盘）、字符设备（比如键盘、串口）的表示，完成对设备的基本操作。ucore虚拟文件系统为了把这些设备链接在一起，还定义了一个设备链表，即双向链表vdev_list，这样通过访问此链表，可以找到ucore能够访问的所有设备文件。</p>
<p>但这个设备描述没有与文件系统以及表示一个文件的inode数据结构建立关系，为此，还需要另外一个数据结构把device和inode联通起来，这就<br>是vfs_dev_t数据结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// device info entry in vdev_list </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *devname;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">devnode</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>;</span></span><br><span class="line">    <span class="type">bool</span> mountable;</span><br><span class="line">    <span class="type">list_entry_t</span> vdev_link;</span><br><span class="line">&#125; <span class="type">vfs_dev_t</span>;</span><br></pre></td></tr></table></figure><br>利用vfs_dev_t数据结构，就可以让文件系统通过一个链接vfs_dev_t结构的双向链表找到device对应的inode数据结构，一个inode节点的成员变量in_type的值是0x1234，则此 inode的成员变量in_info将成为一个device结构。这样inode就和一个设备建立了联系，这个inode就是一个设备文件。</p>
<h4 id="stdout设备文件"><a href="#stdout设备文件" class="headerlink" title="stdout设备文件"></a>stdout设备文件</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>既然stdout设备是设备文件系统的文件，自然有自己的inode结构。在系统初始化时，即只需如下处理过程<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kern_init ——&gt;</span><br><span class="line"> fs_init ——&gt; </span><br><span class="line"> dev_init ——&gt; </span><br><span class="line"> dev_init_stdout ——&gt;</span><br><span class="line"> dev_create_inode ——&gt; </span><br><span class="line"> stdout_device_init ——&gt; </span><br><span class="line"> vfs_add_dev</span><br></pre></td></tr></table></figure><br>在dev_init_stdout中完成了对stdout设备文件的初始化。即首先创建了一个inode，然后通过<code>stdout_device_init</code>完成对inode中的成员变量<code>inode-&gt;__device_info</code>进行初始：<br>这里的stdout设备文件实际上就是指的console外设（它其实是串口、并口和CGA的组合型外设）。这个设备文件是一个只写设备，如果读这个设备，就会出错。接下来我们看看stdout设备的相关处理过程。</p>
<h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><p>stdout设备文件的初始化过程主要由<code>stdout_device_init</code>完成，其具体实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">stdout_device_init</span><span class="params">(<span class="keyword">struct</span> device *dev)</span> &#123;</span><br><span class="line">    dev-&gt;d_blocks = <span class="number">0</span>;</span><br><span class="line">    dev-&gt;d_blocksize = <span class="number">1</span>;</span><br><span class="line">    dev-&gt;d_open = stdout_open;</span><br><span class="line">    dev-&gt;d_close = stdout_close;</span><br><span class="line">    dev-&gt;d_io = stdout_io;</span><br><span class="line">    dev-&gt;d_ioctl = stdout_ioctl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，stdout_open函数完成设备文件打开工作，如果发现用户进程调用open函数的参数flags不是只写（O_WRONLY），则会报错。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">stdout_open</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">uint32_t</span> open_flags)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (open_flags != O_WRONLY) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="访问操作实现"><a href="#访问操作实现" class="headerlink" title="访问操作实现"></a>访问操作实现</h5><p>stdout_io函数完成设备的写操作工作，具体实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">stdout_io</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> iobuf *iob, <span class="type">bool</span> write)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (write) &#123;</span><br><span class="line">        <span class="type">char</span> *data = iob-&gt;io_base;</span><br><span class="line">        <span class="keyword">for</span> (; iob-&gt;io_resid != <span class="number">0</span>; iob-&gt;io_resid --) &#123;</span><br><span class="line">            cputchar(*data ++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，要写的数据放在iob-&gt;io_base所指的内存区域，一直写到iob-&gt;io_resid的值为0为止。每次写操作都是通过cputchar来完成的，此函数最终将通过console外设驱动来完成把数据输出到串口、并口和CGA显示器上过程。另外，也可以注意到，如果用户想执行读操作，则stdout_io函数直接返回错误值-E_INVAL。</p>
<h4 id="stdin-设备文件"><a href="#stdin-设备文件" class="headerlink" title="stdin 设备文件"></a>stdin 设备文件</h4><p>这里的stdin设备文件实际上就是指的键盘。这个设备文件是一个只读设备，如果写这个设备，就会出错。接下来我们看看stdin设备的相关处理过程。</p>
<h5 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h5><p>stdin设备文件的初始化过程主要由stdin_device_init完成了主要的初始化工作，具体实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">stdin_device_init</span><span class="params">(<span class="keyword">struct</span> device *dev)</span> &#123;</span><br><span class="line">    dev-&gt;d_blocks = <span class="number">0</span>;</span><br><span class="line">    dev-&gt;d_blocksize = <span class="number">1</span>;</span><br><span class="line">    dev-&gt;d_open = stdin_open;</span><br><span class="line">    dev-&gt;d_close = stdin_close;</span><br><span class="line">    dev-&gt;d_io = stdin_io;</span><br><span class="line">    dev-&gt;d_ioctl = stdin_ioctl;</span><br><span class="line"></span><br><span class="line">    p_rpos = p_wpos = <span class="number">0</span>;</span><br><span class="line">    wait_queue_init(wait_queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>相对于stdout的初始化过程，stdin的初始化相对复杂一些，<strong>多了一个stdin_buffer缓冲区</strong>，描述缓冲区读写位置的变量p_rpos、p_wpos以及用于等待缓冲区的等待队列wait_queue。在stdin_device_init函数的初始化中，也完成了对p_rpos、p_wpos和wait_queue的初始化。</p>
<h5 id="访问操作实现-1"><a href="#访问操作实现-1" class="headerlink" title="访问操作实现"></a>访问操作实现</h5><p>stdin_io函数负责完成设备的读操作工作，具体实现如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">stdin_io(struct device *dev, struct iobuf *iob, bool write) &#123;</span><br><span class="line">    if (!write) &#123;</span><br><span class="line">        int ret;</span><br><span class="line">        if ((ret = dev_stdin_read(iob-&gt;io_base, iob-&gt;io_resid)) &gt; 0) &#123;</span><br><span class="line">            iob-&gt;io_resid -= ret;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    return -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，如果是写操作，则stdin_io函数直接报错返回。所以这也进一步说明了此设备文件是只读文件。如果此读操作，则此函数进一步调用dev_stdin_read函数完成对键盘设备的读入操作。dev_stdin_read函数的实现相对复杂一些，主要的流程如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">dev_stdin_read</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ret &lt; len; ret ++, p_rpos ++) &#123;</span><br><span class="line">        try_again:</span><br><span class="line">            <span class="keyword">if</span> (p_rpos &lt; p_wpos) &#123;</span><br><span class="line">                *buf ++ = stdin_buffer[p_rpos % stdin_BUFSIZE];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">wait_t</span> __wait, *wait = &amp;__wait;</span><br><span class="line">                wait_current_set(wait_queue, wait, WT_KBD);</span><br><span class="line">                local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">                schedule();</span><br><span class="line"></span><br><span class="line">                local_intr_save(intr_flag);</span><br><span class="line">                wait_current_del(wait_queue, wait);</span><br><span class="line">                <span class="keyword">if</span> (wait-&gt;wakeup_flags == WT_KBD) &#123;</span><br><span class="line">                    <span class="keyword">goto</span> try_again;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在上述函数中可以看出，如果p_rpos &lt; p_wpos，则表示有键盘输入的新字符在stdin_buffer中，于是就从stdin_buffer中取出新字符放到iobuf指向的缓冲区中；如果p_rpos &gt;=p_wpos，则表明没有新字符，这样调用read用户态库函数的用户进程就需要采用等待队列的睡眠操作进入睡眠状态，等待键盘输入字符的产生。</p>
<p>当识别出中断是键盘中断（中断号为IRQ_OFFSET + IRQ_KBD）时，会调用dev_stdin_write函数，来把字符写入到stdin_buffer中，且会通过等待队列的唤醒操作唤醒正在等待键盘输入的用户进程。</p>
<h3 id="实验执行流程概述-2"><a href="#实验执行流程概述-2" class="headerlink" title="实验执行流程概述"></a>实验执行流程概述</h3><p>kern_init函数增加了对fs_init函数的调用。fs_init函数就是文件系统初始化的总控函数，它进一步调用了虚拟文件系统初始化函数vfs_init，与文件相关的设备初始化函数dev_init和Simple FS文件系统的初始化函数sfs_init。这三个初始化函数联合在一起，协同完成了整个虚拟文件系统、SFS文件系统和文件系统对应的设备（键盘、串口、磁盘）的初始化工作。其函数调用关系图如下所示：<br><img src="/img/20190629004.png" alt=""></p>
<p>vfs_init如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vfs_init -  vfs initialize</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vfs_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    sem_init(&amp;bootfs_sem, <span class="number">1</span>);</span><br><span class="line">    vfs_devlist_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>sem_init函数主要是初始化了信号量和等待队列：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sem_init</span><span class="params">(<span class="type">semaphore_t</span> *sem, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    sem-&gt;value = value;</span><br><span class="line">    wait_queue_init(&amp;(sem-&gt;wait_queue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>vfs_devlist_init主要是初始化设备列表，建立了一个device list双向链表vdev_list，为后续具体设备（键盘、串口、磁盘）以文件的形式呈现建立查找访问通道<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vfs_devlist_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    list_init(&amp;vdev_list);</span><br><span class="line">    sem_init(&amp;vdev_list_sem, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>dev_init函数通过进一步调用disk0/stdin/stdout_device_init完成对具体设备的初始化，把它们抽象成一个设备文件，并建立对应的inode数据结构，最后把它们链入到vdev_list中。这样通过虚拟文件系统就可以方便地以文件的形式访问这些设备了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> init_device(x)                                  \</span></span><br><span class="line"><span class="meta">    do &#123;                                                \</span></span><br><span class="line"><span class="meta">        extern void dev_init_##x(void);                 \</span></span><br><span class="line"><span class="meta">        dev_init_##x();                                 \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* dev_init - Initialization functions for builtin vfs-level devices. */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">dev_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">   <span class="comment">// init_device(null);</span></span><br><span class="line">    init_device(<span class="built_in">stdin</span>);</span><br><span class="line">    init_device(<span class="built_in">stdout</span>);</span><br><span class="line">    init_device(disk0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">dev_init_disk0</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((node = dev_create_inode()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;disk0: dev_create_node.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    disk0_device_init(vop_info(node, device));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = vfs_add_dev(<span class="string">&quot;disk0&quot;</span>, node, <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;disk0: vfs_add_dev: %e.\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dev_init_stdin(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((node = dev_create_inode()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;stdin: dev_create_node.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stdin_device_init(vop_info(node, device));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = vfs_add_dev(<span class="string">&quot;stdin&quot;</span>, node, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;stdin: vfs_add_dev: %e.\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">dev_init_stdout</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((node = dev_create_inode()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;stdout: dev_create_node.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stdout_device_init(vop_info(node, device));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = vfs_add_dev(<span class="string">&quot;stdout&quot;</span>, node, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;stdout: vfs_add_dev: %e.\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>sfs_init是完成对Simple FS的初始化工作，并把此实例文件系统挂在虚拟文件系统中，从而让ucore的其他部分能够通过访问虚拟文件系统的接口来进一步访问到SFS实例文件系统。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sfs_init - mount sfs on disk0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CALL GRAPH:</span></span><br><span class="line"><span class="comment"> *   kern_init--&gt;fs_init--&gt;sfs_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sfs_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_mount(<span class="string">&quot;disk0&quot;</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;failed: sfs: sfs_mount: %e.\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在sfs_init中调用了sfs_mount —&gt; vfs_mount 进行挂载：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sfs_mount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *devname)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> vfs_mount(devname, sfs_do_mount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>vfs_mount把一个文件系统挂载到系统上<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * vfs_mount - Mount a filesystem. Once we&#x27;ve found the device, call MOUNTFUNC to</span></span><br><span class="line"><span class="comment"> *             set up the filesystem and hand back a struct fs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The DATA argument is passed through unchanged to MOUNTFUNC.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">vfs_mount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *devname, <span class="type">int</span> (*mountfunc)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> fs **fs_store))</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    lock_vdev_list();</span><br><span class="line">    <span class="comment">// 信号量操作</span></span><br><span class="line">    <span class="type">vfs_dev_t</span> *vdev;</span><br><span class="line">    <span class="keyword">if</span> ((ret = find_mount(devname, &amp;vdev)) != <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">// 找一个同名设备</span></span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vdev-&gt;fs != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -E_BUSY;</span><br><span class="line">        <span class="comment">// 如果这个设备已经被挂载到一个文件系统上了，就不能被再挂载</span></span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(vdev-&gt;devname != <span class="literal">NULL</span> &amp;&amp; vdev-&gt;mountable);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> vop_info(vdev-&gt;devnode, device);</span><br><span class="line">    <span class="keyword">if</span> ((ret = mountfunc(dev, &amp;(vdev-&gt;fs))) == <span class="number">0</span>) &#123;</span><br><span class="line">        assert(vdev-&gt;fs != <span class="literal">NULL</span>);</span><br><span class="line">        cprintf(<span class="string">&quot;vfs: mount %s.\n&quot;</span>, vdev-&gt;devname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    unlock_vdev_list();</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于vop_info：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __vop_info(node, type)                                      \</span></span><br><span class="line"><span class="meta">    (&#123;                                                              \</span></span><br><span class="line"><span class="meta">        struct inode *__node = (node);                              \</span></span><br><span class="line"><span class="meta">        assert(__node != NULL &amp;&amp; check_inode_type(__node, type));   \</span></span><br><span class="line"><span class="meta">        &amp;(__node-&gt;in_info.__##type##_info);                         \</span></span><br><span class="line"><span class="meta">     &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vop_info(node, type)                                        __vop_info(node, type)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br><code>__##type##_info</code>是一个<code>struct device</code>或<code>struct sfs_inode</code>的结构体，一般调用vop_info的时候都是给一个变量赋值为一个设备的结构体。</p>
<p><code>mountfunc</code>竟然是一个参数，流批流批。。。溯源的话有<code>sfs_do_mount</code>作为参数，下文介绍sfs_do_mount，太多了。。。</p>
<h3 id="文件操作实现"><a href="#文件操作实现" class="headerlink" title="文件操作实现"></a>文件操作实现</h3><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>有了上述分析后，我们可以看看如果一个用户进程打开文件会做哪些事情？首先假定用户进程需要打开的文件已经存在在硬盘上。以user/sfs_filetest1.c为例，首先用户进程会调用在main函数中的如下语句：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fd1 = safe_open(&quot;sfs\_filetest1&quot;, O_RDONLY);</span><br></pre></td></tr></table></figure><br>如果ucore能够正常查找到这个文件，就会返回一个代表文件的文件描述符fd1，这样在接下来的读写文件过程中，就直接用这样fd1来代表就可以了。</p>
<p>safe_open实现如下，在open中调用了sys_open，接着调用了syscall，执行系统调用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static int safe_open(const char *path, int open_flags)</span><br><span class="line">&#123;</span><br><span class="line">        int fd = open(path, open_flags);</span><br><span class="line">        printf(&quot;fd is %d\n&quot;,fd);</span><br><span class="line">        assert(fd &gt;= 0);</span><br><span class="line">        return fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="通用文件访问接口层的处理流程"><a href="#通用文件访问接口层的处理流程" class="headerlink" title="通用文件访问接口层的处理流程"></a>通用文件访问接口层的处理流程</h5><p>进一步调用如下用户态函数： <code>open-&gt;sys_open</code>-&gt;<code>syscall</code>，从而引起系统调用进入到内核态。到了内核态后，通过中断处理例程，会调用到<code>sys_open</code>内核函数，并进一步调用<code>sysfile_open</code>内核函数。到了这里，需要把位于用户空间的字符串”sfs_filetest1”拷贝到内核空间中的字符串path中，这里copy_path完成了本功能，这里不再列出。进入到文件系统抽象层的处理流程完成进一步的打开文件操作中。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">sys_open(uint32_t arg[]) &#123;</span><br><span class="line">    const char *path = (const char *)arg[0];</span><br><span class="line">    uint32_t open_flags = (uint32_t)arg[1];</span><br><span class="line">    return sysfile_open(path, open_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* sysfile_open - open file */</span><br><span class="line">int</span><br><span class="line">sysfile_open(const char *__path, uint32_t open_flags) &#123;</span><br><span class="line">    int ret;</span><br><span class="line">    char *path;</span><br><span class="line">    if ((ret = copy_path(&amp;path, __path)) != 0) &#123;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = file_open(path, open_flags);</span><br><span class="line">    kfree(path);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="文件系统抽象层的处理流程"><a href="#文件系统抽象层的处理流程" class="headerlink" title="文件系统抽象层的处理流程"></a>文件系统抽象层的处理流程</h5><ul>
<li><p>分配一个空闲的file数据结构变量file。</p>
<ul>
<li>在文件系统抽象层的处理中，首先调用的是file_open函数，它要给这个即将打开的文件分配一个file数据结构的变量，这个变量其实是当前进程的打开文件数组<code>current-&gt;fs_struct-&gt;filemap[]</code>中的一个空闲元素（即还没用于一个打开的文件），而这个元素的索引值就是最终要返回到用户进程并赋值给变量fd1。到了这一步还仅仅是给当前用户进程分配了一个file数据结构的变量，还没有找到对应的文件索引节点。</li>
</ul>
</li>
<li><p>调用<code>vfs_open</code>函数来找到path指出的文件所对应的基于inode数据结构的VFS索引节点node。</p>
<ul>
<li><code>vfs_open</code>函数需要完成：<ul>
<li>确定读写权限；</li>
<li>通过vfs_lookup找到path对应文件的inode；首先是调用get_device，先对路径字符串进行判断，看是不是声明了设备（有：）或者是绝对路径（有/）。如果是相对路径，调用vfs_get_curdir获得当前的路径。如果有设备名，则根据路径中的设备名在设备list中找到这个设备，返回一个inode。如果是绝对路径，则返回根目录。如果开头有个‘:’，说明是在当前文件系统中，返回的是当前目录。</li>
<li>找到文件设备的根目录“/”的索引节点需要注意，这里的<code>vfs_lookup</code>函数是一个针对目录的操作函数，它会调用<code>vop_lookup</code>函数来找到SFS文件系统中的“/”目录下的“sfs_filetest1”文件。为此，<code>vfs_lookup</code>函数首先调用<code>get_device</code>函数，并进一步调用<code>vfs_get_bootfs</code>函数来找到根目录“/”对应的inode。这个inode就是位于vfs.c中的inode变量bootfs_node。这个变量在init_main函数（位于kern/process/proc.c）执行时获得了赋值。</li>
<li>通过调用vop_lookup函数来查找到根目录“/”下对应文件sfs_filetest1的索引节点，如果找到就返回此索引节点。</li>
</ul>
</li>
<li>调用vop_open函数打开文件。</li>
<li>调用了vop_truncate（应该是这个sfs_truncfile），调整文件大小到适当的大小（按照块个数计算）</li>
<li>调用了vfs_fsync，如果发生了什么使得这个块变成dirty了，就调用d_io把它写进去。</li>
</ul>
</li>
<li><p>把file和node建立联系，设置file的读写权限，如果是append模式的话还要把file的pos设置到末尾。完成后，将返回到file_open函数中，通过执行语句“file-&gt;node=node;”，就把当前进程的current-&gt;fs_struct-&gt;filemap[fd]（即file所指变量）的成员变量node指针指向了代表sfs_filetest1文件的索引节点inode。</p>
</li>
<li>这时返回fd。经过重重回退，通过系统调用返回，用户态的syscall-&gt;sys_open-&gt;open-&gt;safe_open等用户函数的层层函数返回，最终把fd赋值给fd1。自此完成了打开文件操作。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// open file</span><br><span class="line">int</span><br><span class="line">file_open(char *path, uint32_t open_flags) &#123;</span><br><span class="line">    bool readable = 0, writable = 0;</span><br><span class="line">    switch (open_flags &amp; O_ACCMODE) &#123;</span><br><span class="line">        case O_RDONLY: readable = 1; break;</span><br><span class="line">        case O_WRONLY: writable = 1; break;</span><br><span class="line">        case O_RDWR:</span><br><span class="line">            readable = writable = 1;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            return -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ret;</span><br><span class="line">    struct file *file;</span><br><span class="line">    if ((ret = fd_array_alloc(NO_FD, &amp;file)) != 0) &#123;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">//分配一个file数据结构的变量</span><br><span class="line"></span><br><span class="line">    struct inode *node;</span><br><span class="line">    if ((ret = vfs_open(path, open_flags, &amp;node)) != 0) &#123;</span><br><span class="line">        fd_array_free(file);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">//找到path指出的文件所对应的基于inode数据结构的VFS索引节点node</span><br><span class="line"></span><br><span class="line">    file-&gt;pos = 0;</span><br><span class="line">    if (open_flags &amp; O_APPEND) &#123;</span><br><span class="line">        struct stat __stat, *stat = &amp;__stat;</span><br><span class="line">        if ((ret = vop_fstat(node, stat)) != 0) &#123;</span><br><span class="line">            vfs_close(node);</span><br><span class="line">            fd_array_free(file);</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line">        file-&gt;pos = stat-&gt;st_size;</span><br><span class="line">    &#125;</span><br><span class="line">// 根据open_flags找当前指针应该指在文件的什么位置</span><br><span class="line"></span><br><span class="line">    file-&gt;node = node;</span><br><span class="line">    file-&gt;readable = readable;</span><br><span class="line">    file-&gt;writable = writable;</span><br><span class="line">    fd_array_open(file);</span><br><span class="line">    return file-&gt;fd;</span><br><span class="line">&#125;    	</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="SFS文件系统层的处理流程"><a href="#SFS文件系统层的处理流程" class="headerlink" title="SFS文件系统层的处理流程"></a>SFS文件系统层的处理流程</h5><p>在sfs_inode.c中的<code>sfs_node_dirops</code>变量定义了“.vop_lookup = sfs_lookup”，所以我们重点分析sfs_lookup的实现。</p>
<p>sfs_lookup有三个参数：node，path，node_store。其中node是根目录“/”所对应的inode节点；path是文件sfs_filetest1的绝对路径/sfs_filetest1，而node_store是经过查找获得的sfs_filetest1所对应的inode节点。<br>sfs_lookup函数以“/”为分割符，从左至右逐一分解path获得各个子目录和最终文件对应的inode节点。在本例中是调用sfs_lookup_once查找以根目录下的文件sfs_filetest1所对应的inode节点。当无法分解path后，就意味着找到了sfs_filetest1对应的inode节点，就可顺利返回了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * sfs_lookup - Parse path relative to the passed directory</span><br><span class="line"> *              DIR, and hand back the inode for the file it</span><br><span class="line"> *              refers to.</span><br><span class="line"> */</span><br><span class="line">static int</span><br><span class="line">sfs_lookup(struct inode *node, char *path, struct inode **node_store) &#123;</span><br><span class="line">    struct sfs_fs *sfs = fsop_info(vop_fs(node), sfs);</span><br><span class="line">    assert(*path != &#x27;\0&#x27; &amp;&amp; *path != &#x27;/&#x27;);</span><br><span class="line">    vop_ref_inc(node);</span><br><span class="line">    struct sfs_inode *sin = vop_info(node, sfs_inode);</span><br><span class="line">    // 找到sfs_inode __sfs_inode_info。</span><br><span class="line">    if (sin-&gt;din-&gt;type != SFS_TYPE_DIR) &#123;</span><br><span class="line">        vop_ref_dec(node);</span><br><span class="line">        return -E_NOTDIR;</span><br><span class="line">    &#125;</span><br><span class="line">    struct inode *subnode;</span><br><span class="line">    int ret = sfs_lookup_once(sfs, sin, path, &amp;subnode, NULL);</span><br><span class="line">    // 找到与路径相符的inode并加载到subnode里。</span><br><span class="line">    vop_ref_dec(node);</span><br><span class="line">    if (ret != 0) &#123;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    *node_store = subnode;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>用户进程有如下语句：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read(fd, data, len);</span><br></pre></td></tr></table></figure><br>即读取fd对应文件，读取长度为len，存入data中。下面来分析一下读文件的实现。</p>
<h5 id="通用文件访问接口层的处理流程-1"><a href="#通用文件访问接口层的处理流程-1" class="headerlink" title="通用文件访问接口层的处理流程"></a>通用文件访问接口层的处理流程</h5><p>进一步调用如下用户态函数：<code>read-&gt;sys_read-&gt;syscall</code>，从而引起系统调用进入到内核态。到了内核态以后，通过中断处理例程，会调用到<code>sys_read</code>内核函数，并进一步调用<code>sysfile_read</code>内核函数，进入到文件系统抽象层处理流程完成进一步读文件的操作。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">sys_read(uint32_t arg[]) &#123;</span><br><span class="line">    int fd = (int)arg[0];</span><br><span class="line">    void *base = (void *)arg[1];</span><br><span class="line">    size_t len = (size_t)arg[2];</span><br><span class="line">    return sysfile_read(fd, base, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="文件系统抽象层的处理流程-1"><a href="#文件系统抽象层的处理流程-1" class="headerlink" title="文件系统抽象层的处理流程"></a>文件系统抽象层的处理流程</h5><ul>
<li>检查错误，即检查读取长度是否为0和文件是否可读。</li>
<li>分配buffer空间，即调用kmalloc函数分配4096字节的buffer空间。</li>
<li>读文件过程<ul>
<li>实际读文件。<ul>
<li>循环读取文件，每次读取buffer大小。</li>
<li>每次循环中，先检查剩余部分大小，若其小于4096字节，则只读取剩余部分的大小。</li>
<li>调用file_read函数（详细分析见后）将文件内容读取到buffer中，alen为实际大小。</li>
<li>调用copy_to_user函数将读到的内容拷贝到用户的内存空间中。</li>
<li>调整各变量以进行下一次循环读取，直至指定长度读取完成。</li>
<li>最后函数调用层层返回至用户程序，用户程序收到了读到的文件内容。</li>
</ul>
</li>
<li>file_read函数<ul>
<li>这个函数是读文件的核心函数。函数有4个参数，<ul>
<li>fd是文件描述符，</li>
<li>base是缓存的基地址，</li>
<li>len是要读取的长度，</li>
<li>copied_store存放实际读取的长度。</li>
</ul>
</li>
<li>函数首先调用<code>fd2file</code>函数找到对应的file结构，并检查是否可读。</li>
<li>调用<code>filemap_acquire</code>函数使打开这个文件的计数加1。</li>
<li>调用vop_read函数将文件内容读到iob中（详细分析见后）。</li>
<li>调整文件指针偏移量pos的值，使其向后移动实际读到的字节数iobuf_used(iob)。</li>
<li>调用filemap_release函数使打开这个文件的计数减1，若打开计数为0，则释放file。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/* sysfile_read - read file */</span><br><span class="line">int</span><br><span class="line">sysfile_read(int fd, void *base, size_t len) &#123;</span><br><span class="line">    struct mm_struct *mm = current-&gt;mm;</span><br><span class="line">    if (len == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!file_testfd(fd, 1, 0)) &#123;</span><br><span class="line">        return -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">// 检查读取长度是否为0和文件是否可读</span><br><span class="line"></span><br><span class="line">    void *buffer;</span><br><span class="line">    if ((buffer = kmalloc(IOBUF_SIZE)) == NULL) &#123;</span><br><span class="line">        return -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">// 调用kmalloc函数分配4096字节的buffer空间</span><br><span class="line"></span><br><span class="line">    int ret = 0;</span><br><span class="line">    size_t copied = 0, alen;</span><br><span class="line">    while (len != 0) &#123;</span><br><span class="line">        if ((alen = IOBUF_SIZE) &gt; len) &#123;</span><br><span class="line">            alen = len;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = file_read(fd, buffer, alen, &amp;alen);</span><br><span class="line">        // 将文件内容读取到buffer中，alen为实际大小       </span><br><span class="line">        if (alen != 0) &#123;</span><br><span class="line">            lock_mm(mm);</span><br><span class="line">            &#123;</span><br><span class="line">                if (copy_to_user(mm, base, buffer, alen)) &#123;</span><br><span class="line">                    // copy_to_user在vmm.c中，检查权限后memcpy</span><br><span class="line">                    assert(len &gt;= alen);</span><br><span class="line">                    base += alen, len -= alen, copied += alen;</span><br><span class="line">                &#125;</span><br><span class="line">                // 调用copy_to_user函数将读到的内容拷贝到用户的内存空间中</span><br><span class="line">                // 调整各变量以进行下一次循环读取，直至指定长度读取完成</span><br><span class="line">                else if (ret == 0) &#123;</span><br><span class="line">                    ret = -E_INVAL;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            unlock_mm(mm);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ret != 0 || alen == 0) &#123;</span><br><span class="line">            goto out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    kfree(buffer);</span><br><span class="line">    if (copied != 0) &#123;</span><br><span class="line">        return copied;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;                    </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// read file</span><br><span class="line">int</span><br><span class="line">file_read(int fd, void *base, size_t len, size_t *copied_store) &#123;</span><br><span class="line">    int ret;</span><br><span class="line">    struct file *file;</span><br><span class="line">    *copied_store = 0;</span><br><span class="line">    if ((ret = fd2file(fd, &amp;file)) != 0) &#123;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    // 找到对应的file结构</span><br><span class="line"></span><br><span class="line">    if (!file-&gt;readable) &#123;</span><br><span class="line">        return -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    fd_array_acquire(file);</span><br><span class="line">    // 打开这个文件的计数加1</span><br><span class="line"></span><br><span class="line">    struct iobuf __iob, *iob = iobuf_init(&amp;__iob, base, len, file-&gt;pos);</span><br><span class="line">    ret = vop_read(file-&gt;node, iob);</span><br><span class="line">    // 文件内容读到iob中，通过sfs_read --&gt; sfs_io，获取到inode，执行sfs_io_nolock。</span><br><span class="line"></span><br><span class="line">    size_t copied = iobuf_used(iob);</span><br><span class="line">    if (file-&gt;status == FD_OPENED) &#123;</span><br><span class="line">        file-&gt;pos += copied;</span><br><span class="line">    &#125;</span><br><span class="line">    *copied_store = copied;</span><br><span class="line">    fd_array_release(file);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="SFS文件系统层的处理流程-1"><a href="#SFS文件系统层的处理流程-1" class="headerlink" title="SFS文件系统层的处理流程"></a>SFS文件系统层的处理流程</h5><p><code>vop_read</code>函数实际上是对<code>sfs_read</code>的包装。在sfs_inode.c中<code>sfs_node_fileops</code>变量定义了<code>.vop_read = sfs_read</code>，所以下面来分析sfs_read函数的实现。</p>
<ul>
<li>sfs_read函数调用sfs_io函数。<ul>
<li>它有三个参数，node是对应文件的inode，iob是缓存，write表示是读还是写的布尔值（0表示读，1表示写），这里是0。</li>
<li>函数先找到inode对应sfs和sin，</li>
<li>然后调用sfs_io_nolock函数进行读取文件操作，</li>
<li>最后调用iobuf_skip函数调整iobuf的指针。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sfs_io - Rd/Wr file. the wrapper of sfs_io_nolock</span></span><br><span class="line"><span class="comment">            with lock protect</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sfs_io</span><span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> iobuf *iob, <span class="type">bool</span> write)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> *<span class="title">sfs</span> =</span> fsop_info(vop_fs(node), sfs);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> *<span class="title">sin</span> =</span> vop_info(node, sfs_inode);</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    lock_sin(<span class="built_in">sin</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> alen = iob-&gt;io_resid;</span><br><span class="line">        ret = sfs_io_nolock(sfs, <span class="built_in">sin</span>, iob-&gt;io_base, iob-&gt;io_offset, &amp;alen, write);</span><br><span class="line">        <span class="keyword">if</span> (alen != <span class="number">0</span>) &#123;</span><br><span class="line">            iobuf_skip(iob, alen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_sin(<span class="built_in">sin</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * iobuf_skip - change the current position of io buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iobuf_skip</span><span class="params">(<span class="keyword">struct</span> iobuf *iob, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    assert(iob-&gt;io_resid &gt;= n);</span><br><span class="line">    iob-&gt;io_base += n, iob-&gt;io_offset += n, iob-&gt;io_resid -= n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习1-完成读文件操作的实现"><a href="#练习1-完成读文件操作的实现" class="headerlink" title="练习1: 完成读文件操作的实现"></a>练习1: 完成读文件操作的实现</h3><p>首先完成proc.c中process控制块的初始化，在<code>static struct proc_struct *alloc_proc(void)</code>中添加：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc-&gt;filesp = NULL;</span><br></pre></td></tr></table></figure></p>
<p>如果调用了read系统调用，继续调用sys_read函数，和sysfile_read函数，在这个函数中，创建了缓冲区，进一步复制到用户空间的指定位置去；从文件读取数据的函数是file_read。</p>
<p>在file_read函数中，通过文件描述符找到相应文件对应的内存中的inode信息，调用vop_read进行读取处理，vop_read继续调用sfs_read函数，然后调用sfs_io函数和sfs_io_nolock函数。</p>
<ul>
<li>在sfs_io_nolock函数中，<ul>
<li>先计算一些辅助变量，并处理一些特殊情况（比如越界），</li>
<li>然后有<code>sfs_buf_op = sfs_rbuf</code>，<code>sfs_block_op = sfs_rblock</code>，设置读取的函数操作。</li>
<li>先处理起始的没有对齐到块的部分，再以块为单位循环处理中间的部分，最后处理末尾剩余的部分。</li>
<li>每部分中都调用sfs_bmap_load_nolock函数得到blkno对应的inode编号，</li>
<li>并调用<code>sfs_rbuf</code>或<code>sfs_rblock</code>函数读取数据（中间部分调用sfs_rblock，起始和末尾部分调用sfs_rbuf），调整相关变量。</li>
<li>完成后如果<code>offset + alen &gt; din-&gt;fileinfo.size</code>（写文件时会出现这种情况，读文件时不会出现这种情况，alen为实际读写的长度），则调整文件大小为<code>offset + alen</code>并设置dirty变量。</li>
</ul>
</li>
<li><code>sfs_bmap_load_nolock</code>函数将对应<code>sfs_inode</code>的第index个索引指向的block的索引值取出存到相应的指针指向的单元（ino_store）。<ul>
<li>调用sfs_bmap_get_nolock来完成相应的操作。</li>
<li>sfs_rbuf和sfs_rblock函数最终都调用sfs_rwblock_nolock函数完成操作，</li>
<li>而sfs_rwblock_nolock函数调用dop_io-&gt;disk0_io-&gt;disk0_read_blks_nolock-&gt;ide_read_secs完成对磁盘的操作。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sfs_io_nolock - Rd/Wr a file contentfrom offset position to offset+ length  disk blocks&lt;--&gt;buffer (in memroy) * * @sfs:      sfs file system</span></span><br><span class="line"><span class="comment"> * @sin:      sfs inode in memory</span></span><br><span class="line"><span class="comment"> * @buf:      the buffer Rd/Wr</span></span><br><span class="line"><span class="comment"> * @offset:   the offset of file</span></span><br><span class="line"><span class="comment"> * @alenp:    the length need to read (is a pointer). and will RETURN the really Rd/Wr lenght</span></span><br><span class="line"><span class="comment"> * @write:    BOOL, 0 read, 1 write</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sfs_io_nolock</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs, <span class="keyword">struct</span> sfs_inode *<span class="built_in">sin</span>, <span class="type">void</span> *buf, <span class="type">off_t</span> offset, <span class="type">size_t</span> *alenp, <span class="type">bool</span> write)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span> =</span> <span class="built_in">sin</span>-&gt;din;</span><br><span class="line">    assert(din-&gt;type != SFS_TYPE_DIR);</span><br><span class="line">    <span class="type">off_t</span> endpos = offset + *alenp, blkoff;</span><br><span class="line">    *alenp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算出读写的长度，从初始偏移量走到文件的哪个位置</span></span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || offset &gt;= SFS_MAX_FILE_SIZE || offset &gt; endpos) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (offset == endpos) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endpos &gt; SFS_MAX_FILE_SIZE) &#123;</span><br><span class="line">        endpos = SFS_MAX_FILE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 文件过大，到了最大支持的文件长度了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!write) &#123;</span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= din-&gt;size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (endpos &gt; din-&gt;size) &#123;</span><br><span class="line">            endpos = din-&gt;size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果end position超过了文件大小，就把它移动到这个文件的末尾</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*sfs_buf_op)(<span class="keyword">struct</span> sfs_fs *sfs, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">uint32_t</span> blkno, <span class="type">off_t</span> offset);</span><br><span class="line">    <span class="type">int</span> (*sfs_block_op)(<span class="keyword">struct</span> sfs_fs *sfs, <span class="type">void</span> *buf, <span class="type">uint32_t</span> blkno, <span class="type">uint32_t</span> nblks);</span><br><span class="line">    <span class="keyword">if</span> (write) &#123;</span><br><span class="line">        sfs_buf_op = sfs_wbuf, sfs_block_op = sfs_wblock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sfs_buf_op = sfs_rbuf, sfs_block_op = sfs_rblock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置读取/写入的函数操作</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> size, alen = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> ino;</span><br><span class="line">    <span class="type">uint32_t</span> blkno = offset / SFS_BLKSIZE;          <span class="comment">// 起始的block序号</span></span><br><span class="line">    <span class="type">uint32_t</span> nblks = endpos / SFS_BLKSIZE - blkno;  <span class="comment">// 一共要读写多少个block？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//LAB8:EXERCISE1 YOUR CODE </span></span><br><span class="line"><span class="comment">//HINT: call sfs_bmap_load_nolock, sfs_rbuf, sfs_rblock,etc. </span></span><br><span class="line"><span class="comment">// read different kind of blocks in file</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * (1) If offset isn&#x27;t aligned with the first block, Rd/Wr some content from offset to the end of the first block</span></span><br><span class="line"><span class="comment">  * NOTICE: useful function: sfs_bmap_load_nolock, sfs_buf_op</span></span><br><span class="line"><span class="comment">  * Rd/Wr size = (nblks != 0) ? (SFS_BLKSIZE - blkoff) : (endpos - offset)</span></span><br><span class="line"><span class="comment">  * (2) Rd/Wr aligned blocks</span></span><br><span class="line"><span class="comment">  * NOTICE: useful function: sfs_bmap_load_nolock, sfs_block_op</span></span><br><span class="line"><span class="comment">  * (3) If end position isn&#x27;t aligned with the last block, Rd/Wr some content from begin to the (endpos % SFS_BLKSIZE) of the last block</span></span><br><span class="line"><span class="comment">  * NOTICE: useful function: sfs_bmap_load_nolock, sfs_buf_op</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="keyword">if</span> (offset % SFS_BLKSIZE != <span class="number">0</span> || endpos / SFS_BLKSIZE == offset / SFS_BLKSIZE)&#123;</span><br><span class="line">        blkoff = offset % SFS_BLKSIZE;</span><br><span class="line">        size = (nblks != <span class="number">0</span>) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) <span class="keyword">goto</span> out;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != <span class="number">0</span>) <span class="keyword">goto</span> out;</span><br><span class="line">        alen += size;</span><br><span class="line">        buf += size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理如果不是从块的开头开始写的情况，如果偏移量%块大小不是0则是从块内部开始写的。如果nblks是0的话说明只有一个块里的一部分需要写。先把这个写了。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> my_nblks = nblks;</span><br><span class="line">    <span class="keyword">if</span> (offset % SFS_BLKSIZE != <span class="number">0</span> &amp;&amp; my_nblks &gt; <span class="number">0</span>)</span><br><span class="line">        my_nblks --;</span><br><span class="line">    <span class="comment">// 如果是从一个块的一部分开始写的，那在总的块数上需要减一。</span></span><br><span class="line">    <span class="keyword">if</span> (my_nblks &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> temp_blkno = (offset % SFS_BLKSIZE == <span class="number">0</span>) ? blkno: blkno + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, temp_blkno, &amp;ino)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_block_op(sfs, buf, ino, my_nblks)) != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 这里的sfs_block_op是一个循环，把mu_nblks个块进行读写，跟开头和结尾的那个sfs_buf_op不一样</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        size = SFS_BLKSIZE * my_nblks;</span><br><span class="line">        alen += size;</span><br><span class="line">        buf += size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下边就是处理如果最后一部分是最后一块的一部分的了，ino存储了disk上的inode的编号，然后在下边的sfs_buf_op中，处理最后一小块</span></span><br><span class="line">    <span class="keyword">if</span> (endpos % SFS_BLKSIZE != <span class="number">0</span> &amp;&amp; endpos / SFS_BLKSIZE != offset / SFS_BLKSIZE) &#123;</span><br><span class="line">            size = endpos % SFS_BLKSIZE;</span><br><span class="line">            <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, endpos / SFS_BLKSIZE, &amp;ino) == <span class="number">0</span>) != <span class="number">0</span>) <span class="keyword">goto</span> out;</span><br><span class="line">            <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, <span class="number">0</span>)) != <span class="number">0</span>) <span class="keyword">goto</span> out;</span><br><span class="line">            alen += size;</span><br><span class="line">            buf += size;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    *alenp = alen;</span><br><span class="line">    <span class="keyword">if</span> (offset + alen &gt; <span class="built_in">sin</span>-&gt;din-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;din-&gt;size = offset + alen;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<ul>
<li>请在实验报告中给出设计实现”UNIX的PIPE机制“的概要设方案，鼓励给出详细设计方案。<ul>
<li>PIPE机制可以看成是一个缓冲区，可以在磁盘上（或内存中？）保留一部分空间作为pipe机制的缓冲区。当两个进程之间要求建立pipe时，在两个进程的进程控制块上修改某些属性表明这个进程是管道数据的发送方还是接受方，这样就可以将stdin或stdout重定向到生成的临时文件里，在两个进程中打开这个临时文件。</li>
<li>当进程A使用stdout写时，查询PCB中的相关变量，把这些stdout数据输出到临时文件中；</li>
<li>当进程B使用stdin的时候，查询PCB中的信息，从临时文件中读取数据；</li>
</ul>
</li>
</ul>
<h3 id="练习2-完成基于文件系统的执行程序机制的实现"><a href="#练习2-完成基于文件系统的执行程序机制的实现" class="headerlink" title="练习2: 完成基于文件系统的执行程序机制的实现"></a>练习2: 完成基于文件系统的执行程序机制的实现</h3><p>改写proc.c中的load_icode函数和其他相关函数，实现基于文件系统的执行程序机制。首先是在do_execve中进行文件名和命令行参数的复制，执行sysfie_open打开相关文件，fd是已经打开的这个文件。执行： make qemu。如果能看看到sh用户程序的执行界面，则基本成功了。如果在sh用户界面上可 以执行”ls”,”hello”等其他放置在sfs文件系统中的其他执行程序，则可以认为本实验基本成功。</p>
<ul>
<li>给要执行的用户进程创建一个新的内存管理结构mm，</li>
<li>创建用户内存空间的新的页目录表；</li>
<li>将磁盘上的ELF文件的TEXT/DATA/BSS段正确地加载到用户空间中；</li>
<li>从磁盘中读取elf文件的header；</li>
<li>根据elfheader中的信息，获取到磁盘上的program header；</li>
<li>对于每一个program header:<ul>
<li>为TEXT/DATA段在用户内存空间上的保存分配物理内存页，同时建立物理页和虚拟页的映射关系；</li>
<li>从磁盘上读取TEXT/DATA段，并且复制到用户内存空间上去；</li>
<li>根据program header得知是否需要创建BBS段，如果是，则分配相应的内存空间，并且全部初始化成0，并且建立物理页和虚拟页的映射关系；</li>
</ul>
</li>
<li>将用户栈的虚拟空间设置为合法，并且为栈顶部分先分配4个物理页，建立好映射关系；</li>
<li>切换到用户地址空间；</li>
<li>设置好用户栈上的信息，即需要传递给执行程序的参数；</li>
<li>设置好中断帧；</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">load_icode</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> argc, <span class="type">char</span> **kargv)</span> &#123;</span><br><span class="line">    <span class="comment">/* LAB8:EXERCISE2 YOUR CODE  HINT:how to load the file with handler fd  in to process&#x27;s memory? how to setup argc/argv?</span></span><br><span class="line"><span class="comment">     * MACROs or Functions:</span></span><br><span class="line"><span class="comment">     *  mm_create        - create a mm</span></span><br><span class="line"><span class="comment">     *  setup_pgdir      - setup pgdir in mm</span></span><br><span class="line"><span class="comment">     *  load_icode_read  - read raw data content of program file</span></span><br><span class="line"><span class="comment">     *  mm_map           - build new vma</span></span><br><span class="line"><span class="comment">     *  pgdir_alloc_page - allocate new memory for  TEXT/DATA/BSS/stack parts</span></span><br><span class="line"><span class="comment">     *  lcr3             - update Page Directory Addr Register -- CR3</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * (1) create a new mm for current process</span></span><br><span class="line"><span class="comment">     * (2) create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span></span><br><span class="line"><span class="comment">     * (3) copy TEXT/DATA/BSS parts in binary to memory space of process</span></span><br><span class="line"><span class="comment">     *    (3.1) read raw data content in file and resolve elfhdr</span></span><br><span class="line"><span class="comment">     *    (3.2) read raw data content in file and resolve proghdr based on info in elfhdr</span></span><br><span class="line"><span class="comment">     *    (3.3) call mm_map to build vma related to TEXT/DATA</span></span><br><span class="line"><span class="comment">     *    (3.4) callpgdir_alloc_page to allocate page for TEXT/DATA, read contents in file</span></span><br><span class="line"><span class="comment">     *          and copy them into the new allocated pages</span></span><br><span class="line"><span class="comment">     *    (3.5) callpgdir_alloc_page to allocate pages for BSS, memset zero in these pages</span></span><br><span class="line"><span class="comment">     * (4) call mm_map to setup user stack, and put parameters into user stack</span></span><br><span class="line"><span class="comment">     * (5) setup current process&#x27;s mm, cr3, reset pgidr (using lcr3 MARCO)</span></span><br><span class="line"><span class="comment">     * (6) setup uargc and uargv in user stacks</span></span><br><span class="line"><span class="comment">     * (7) setup trapframe for user environment</span></span><br><span class="line"><span class="comment">     * (8) if up steps failed, you should cleanup the env.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;load_icode: current-&gt;mm must be empty.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = -E_NO_MEM;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="comment">//(1) create a new mm for current process</span></span><br><span class="line">    <span class="keyword">if</span> ((mm = mm_create()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(2) create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span></span><br><span class="line">    <span class="keyword">if</span> (setup_pgdir(mm) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_pgdir_cleanup_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(3) copy TEXT/DATA section, build BSS parts in binary to memory space of process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="comment">//(3.1) get the file header of the bianry program (ELF format)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">elf</span>;</span></span><br><span class="line">    <span class="type">off_t</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((ret = load_icode_read(fd, (<span class="type">void</span>*)&amp;elf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> elfhdr), <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// elf header读取到elf中，这里的参数比较复杂需要先取地址再类型转换</span></span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="keyword">if</span> (elf.e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        <span class="comment">//检查是不是魔数，如果是的话才是对的elf文件</span></span><br><span class="line">        ret = -E_INVAL_ELF;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line">    offset += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> elfhdr);</span><br><span class="line">    <span class="comment">// 这个文件已经读取到elf header 之后了</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> vm_flags, perm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> <span class="title">ph</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; elf.e_phnum; i ++) &#123;</span><br><span class="line">    <span class="comment">// e_phnum is number of entries in program header.</span></span><br><span class="line">    <span class="comment">//(3.4) find every program section headers</span></span><br><span class="line">    <span class="comment">// 第二三个参数分别是读取的长度和在文件中的偏移量。</span></span><br><span class="line">    	<span class="type">off_t</span> phoff = elf.e_phoff + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> proghdr) * i;</span><br><span class="line">        load_icode_read(fd, (<span class="type">void</span>*)&amp;ph, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> proghdr), phoff);</span><br><span class="line">        <span class="keyword">if</span> (ph.p_type != ELF_PT_LOAD) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph.p_filesz &gt; ph.p_memsz) &#123;</span><br><span class="line">            ret = -E_INVAL_ELF;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph.p_filesz == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// call mm_map fun to setup the new vma ( ph-&gt;p_va, ph-&gt;p_memsz)</span></span><br><span class="line">        vm_flags = <span class="number">0</span>, perm = PTE_U;</span><br><span class="line">        <span class="keyword">if</span> (ph.p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;</span><br><span class="line">        <span class="keyword">if</span> (ph.p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (ph.p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_WRITE) perm |= PTE_W;</span><br><span class="line">        <span class="keyword">if</span> ((ret = mm_map(mm, ph.p_va, ph.p_memsz, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 虚拟内存管理的权限控制，并设置映射</span></span><br><span class="line">        </span><br><span class="line">	    offset = ph.p_offset;</span><br><span class="line">        <span class="type">size_t</span> off, size;</span><br><span class="line">        <span class="type">uintptr_t</span> start = ph.p_va, end=ph.p_va+ph.p_filesz, la = ROUNDDOWN(start, PGSIZE);</span><br><span class="line">        <span class="comment">// start 和 end 是vma中的segment的起始和结尾</span></span><br><span class="line">        ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            	ret = -E_NO_MEM;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">	        load_icode_read(fd, page2kva(page)+off, size, offset);</span><br><span class="line">            <span class="comment">//memcpy(page2kva(page) + off, from, size);</span></span><br><span class="line">            start += size, offset += size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// build BSS section of binary program</span></span><br><span class="line">        end = ph.p_va + ph.p_memsz;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; la) &#123;</span><br><span class="line">            <span class="comment">/* ph-&gt;p_memsz == ph-&gt;p_filesz */</span></span><br><span class="line">            <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start + PGSIZE - la, size = PGSIZE - off;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            	ret = -E_NO_MEM;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page), <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sysfile_close(fd);</span><br><span class="line">    <span class="comment">//(4) build user stack memory</span></span><br><span class="line">    vm_flags = VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">    <span class="keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> stacktop = USTACKTOP;</span><br><span class="line">    <span class="type">uint32_t</span> argsize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt; argc ; j++)</span><br><span class="line">        argsize += (<span class="number">1</span> + <span class="built_in">strlen</span>(kargv[j]));</span><br><span class="line">    <span class="comment">// 计算传进来的参数的大小和长度，并进行取整</span></span><br><span class="line">    argsize = (argsize / <span class="keyword">sizeof</span>(<span class="type">long</span>)+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="type">long</span>);</span><br><span class="line">    argsize += (<span class="number">2</span>+argc)*<span class="keyword">sizeof</span>(<span class="type">long</span>);</span><br><span class="line">    stacktop = USTACKTOP - argsize;</span><br><span class="line">    <span class="type">uint32_t</span> pagen = argsize / PGSIZE + <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; ++ j) &#123;</span><br><span class="line">        assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE*j , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(5) set current process&#x27;s mm, sr3, and set CR3 reg = physical addr of Page Directory</span></span><br><span class="line">    mm_count_inc(mm);</span><br><span class="line">    current-&gt;mm = mm;</span><br><span class="line">    current-&gt;cr3 = PADDR(mm-&gt;pgdir);</span><br><span class="line">    lcr3(PADDR(mm-&gt;pgdir));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(6) setup trapframe for user environment</span></span><br><span class="line">    <span class="type">uint32_t</span> now_pos = stacktop, argvp;</span><br><span class="line">    *((<span class="type">uint32_t</span>*)now_pos) = argc;</span><br><span class="line">    now_pos += <span class="number">4</span>;</span><br><span class="line">    *((<span class="type">uint32_t</span> *) now_pos) = argvp = now_pos + <span class="number">4</span>;</span><br><span class="line">    now_pos += <span class="number">4</span>;</span><br><span class="line">    now_pos += argc*<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//压栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; argc; ++ j) &#123;</span><br><span class="line">        argsize = <span class="built_in">strlen</span>(kargv[j]) + <span class="number">1</span>; </span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="type">void</span> *) now_pos, kargv[j], argsize);</span><br><span class="line">        *((<span class="type">uint32_t</span> *) (argvp + j * <span class="number">4</span>)) = now_pos;</span><br><span class="line">        now_pos += argsize;</span><br><span class="line">    &#125;	</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* LAB5:EXERCISE1 YOUR CODE</span></span><br><span class="line"><span class="comment">     * should set tf_cs,tf_ds,tf_es,tf_ss,tf_esp,tf_eip,tf_eflags</span></span><br><span class="line"><span class="comment">     * NOTICE: If we set trapframe correctly, then the user level process can return to USER MODE from kernel. So</span></span><br><span class="line"><span class="comment">     *          tf_cs should be USER_CS segment (see memlayout.h)</span></span><br><span class="line"><span class="comment">     *          tf_ds=tf_es=tf_ss should be USER_DS segment</span></span><br><span class="line"><span class="comment">     *          tf_esp should be the top addr of user stack (USTACKTOP)</span></span><br><span class="line"><span class="comment">     *          tf_eip should be the entry point of this binary program (elf-&gt;e_entry)</span></span><br><span class="line"><span class="comment">     *          tf_eflags should be set to enable computer to produce Interrupt</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">    tf-&gt;tf_cs = USER_CS;</span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">    tf-&gt;tf_esp = stacktop;</span><br><span class="line">    tf-&gt;tf_eip = elf.e_entry;</span><br><span class="line">    tf-&gt;tf_eflags = <span class="number">0x2</span> | FL_IF; <span class="comment">// to enable interrupt</span></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">bad_elf_cleanup_pgdir:</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>UNIX的硬链接和软链接机制：</p>
<p>硬链接：</p>
<ul>
<li>文件有相同的 inode 及 data block；</li>
<li>只能对已存在的文件进行创建；</li>
<li>不能交叉文件系统进行硬链接的创建；</li>
<li>不能对目录进行创建，只可对文件创建；</li>
<li>删除一个硬链接文件并不影响其他有相同 inode 号的文件。</li>
</ul>
<p>软链接：</p>
<ul>
<li>软链接有自己的文件属性及权限等；</li>
<li>可对不存在的文件或目录创建软链接；</li>
<li>软链接可交叉文件系统；</li>
<li>软链接可对文件或目录创建；</li>
<li>创建软链接时，链接计数 i_nlink 不会增加；</li>
<li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接</li>
</ul>
<p>硬链接： 与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块<br>软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。</p>
<p>sfs_disk_inode结构体中有一个nlinks变量，如果要创建一个文件的软链接，这个软链接也要创建inode，只是它的类型是链接，找一个域设置它所指向的文件inode，如果文件是一个链接，就可以通过保存的inode位置进行操作；当删除一个软链接时，直接删掉inode即可；</p>
<p>硬链接与文件是共享inode的，如果创建一个硬链接，需要将源文件中的被链接的计数加1；当删除一个硬链接的时候，除了需要删掉inode之外，还需要将硬链接指向的文件的被链接计数减1，如果减到了0，则需要将A删除掉；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/27/golang%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/27/golang%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">golang学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-06-27 17:47:15" itemprop="dateCreated datePublished" datetime="2019-06-27T17:47:15+08:00">2019-06-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-01 12:03:34" itemprop="dateModified" datetime="2022-10-01T12:03:34+08:00">2022-10-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>开始学学golang这门伟大的语言。</p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>Go的基础组成有以下几个部分：</p>
<ul>
<li>包声明</li>
<li>引入包</li>
<li>函数</li>
<li>变量</li>
<li>语句 &amp; 表达式</li>
<li>注释</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">/* 包的名字是main，每个程序都有一个main的包  */</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">/* 需要fmt这个包  */</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   /* 这是我的第一个简单的程序 */</span><br><span class="line">   fmt.Println(&quot;Hello, World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（太奇葩了，竟然是以大小写作为权限控制的。）当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。</p>
<p>运行的话：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run hello.go</span><br></pre></td></tr></table></figure></p>
<p><strong>最奇葩的是 { 不能单独放在一行</strong></p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="行分隔符"><a href="#行分隔符" class="headerlink" title="行分隔符"></a>行分隔符</h2><p>在 Go 程序中，一行代表一个语句结束。每个语句不需要像C一样以分号结尾，因为这些工作都将由 Go 编译器自动完成。</p>
<p>标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母、数字、下划线组成的序列，但是第一个字符必须是字母或下划线而不能是数字。</p>
<p>Go 语言的字符串可以通过 + 实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;Google&quot; + &quot;Runoob&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>在 Go 编程语言中，数据类型用于声明函数和变量。</p>
<p>数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。</p>
<p>Go 语言按类别有以下几种数据类型：</p>
<ul>
<li>布尔型：布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。</li>
<li>数字类型：整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</li>
<li>字符串类型：字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</li>
<li>派生类型:<ul>
<li>(a) 指针类型（Pointer）</li>
<li>(b) 数组类型</li>
<li>(c) 结构化类型(struct)</li>
<li>(d) Channel 类型</li>
<li>(e) 函数类型</li>
<li>(f) 切片类型</li>
<li>(g) 接口类型（interface）</li>
<li>(h) Map 类型</li>
</ul>
</li>
</ul>
<h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>Go 也有基于架构的类型，例如：int、uint 和 uintptr。</p>
<ul>
<li>uint8：无符号 8 位整型 (0 到 255)</li>
<li>uint16：无符号 16 位整型 (0 到 65535)</li>
<li>uint32：无符号 32 位整型 (0 到 4294967295)</li>
<li>uint64：无符号 64 位整型 (0 到 18446744073709551615)</li>
<li>int8：有符号 8 位整型 (-128 到 127)</li>
<li>int16：有符号 16 位整型 (-32768 到 32767)</li>
<li>int32：有符号 32 位整型 (-2147483648 到 2147483647)</li>
<li>int64：有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</li>
</ul>
<p>浮点型</p>
<ul>
<li>float32：IEEE-754 32位浮点型数</li>
<li>float64：IEEE-754 64位浮点型数</li>
<li>complex64：32 位实数和虚数</li>
<li>complex128：64 位实数和虚数</li>
</ul>
<p>其他数字类型</p>
<ul>
<li>byte：类似 uint8</li>
<li>rune：类似 int32</li>
<li>uint：32 或 64 位</li>
<li>int：与 uint 一样大小</li>
<li>uintptr：无符号整型，用于存放一个指针</li>
</ul>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。</p>
<p>声明变量的一般形式是使用 var 关键字：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var identifier type</span><br></pre></td></tr></table></figure><br>可以一次声明多个变量：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var identifier1, identifier2 type</span><br></pre></td></tr></table></figure><br>实例<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var a string = &quot;Runoob&quot;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line"></span><br><span class="line">    var b, c int = 1, 2</span><br><span class="line">    fmt.Println(b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>第一种，指定变量类型，如果没有初始化，则变量默认为零值。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var v_name v_type</span><br><span class="line">v_name = value</span><br></pre></td></tr></table></figure><br>未初始化的时候：</p>
<ul>
<li>数值类型（包括complex64/128）为 0</li>
<li>布尔类型为 false</li>
<li>字符串为 “”（空字符串）</li>
<li>以下几种类型为 nil：<ul>
<li>var a *int</li>
<li>var a []int</li>
<li>var a map[string] int</li>
<li>var a chan int</li>
<li>var a func(string) int</li>
<li>var a error // error 是接口</li>
</ul>
</li>
</ul>
<p>第二种，根据值自行判定变量类型。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var v_name = value</span><br></pre></td></tr></table></figure><br>实例<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var d = true</span><br><span class="line">    fmt.Println(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第三种，省略 var, 注意 := 左侧如果没有声明新的变量，就产生编译错误，格式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v_name := value</span><br></pre></td></tr></table></figure><br>例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var intVal int </span><br><span class="line">intVal :=1 // 这时候会产生编译错误</span><br><span class="line">intVal,intVal1 := 1,2 // 此时不会产生编译错误，因为有声明新的变量，因为 := 是一个声明语句</span><br></pre></td></tr></table></figure><br>可以将 <code>var f string = &quot;Runoob&quot;</code> 简写为 <code>f := &quot;Runoob&quot;</code></p>
<p>实例<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    f := &quot;Runoob&quot; // var f string = &quot;Runoob&quot;</span><br><span class="line"></span><br><span class="line">    fmt.Println(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>多变量声明<br>//类型相同多个变量, 非全局变量<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var vname1, vname2, vname3 type</span><br><span class="line">vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line">var vname1, vname2, vname3 = v1, v2, v3 // 和 python 很像,不需要显示声明类型，自动推断</span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3 // 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误</span><br></pre></td></tr></table></figure></p>
<p>这种因式分解关键字的写法一般用于声明全局变量<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    vname1 v_type1</span><br><span class="line">    vname2 v_type2</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>可以在变量的初始化时省略变量的类型而由系统自动推断，声明语句写上 var 关键字其实是显得有些多余了，因此我们可以将它们简写为 a := 50 或 b := false。</p>
<p>a 和 b 的类型（int 和 bool）将由编译器自动推断。</p>
<p>这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。使用操作符 := 可以高效地创建一个新的变量，称之为初始化声明。</p>
<p>如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a := 20 就是不被允许的，编译器会提示错误 no new variables on left side of :=，但是 a = 20 是可以的，因为这是给相同的变量赋予一个新的值。</p>
<p>如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。</p>
<p><strong>如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误</strong></p>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。</p>
<p>常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p>
<p>常量的定义格式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const identifier [type] = value</span><br></pre></td></tr></table></figure><br>你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。</p>
<p>显式类型定义： const b string = “abc”<br>隐式类型定义： const b = “abc”<br>多个相同类型的声明可以简写为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const c_name1, c_name2 = value1, value2</span><br></pre></td></tr></table></figure></p>
<p>常量还可以用作枚举：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    Unknown = 0</span><br><span class="line">    Female = 1</span><br><span class="line">    Male = 2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>数字 0、1 和 2 分别代表未知性别、女性和男性。</p>
<p>常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过</p>
<h1 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h1><p>iota，特殊常量，可以认为是一个可以被编译器修改的常量。</p>
<p>iota 在 const 关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。</p>
<p>iota 可以被用作枚举值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    a = iota</span><br><span class="line">    b = iota</span><br><span class="line">    c = iota</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    a = iota</span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>iota 用法</p>
<p>实例<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    const (</span><br><span class="line">            a = iota   //0</span><br><span class="line">            b          //1</span><br><span class="line">            c          //2</span><br><span class="line">            d = &quot;ha&quot;   //独立值，iota += 1</span><br><span class="line">            e          //&quot;ha&quot;   iota += 1</span><br><span class="line">            f = 100    //iota +=1</span><br><span class="line">            g          //100  iota +=1</span><br><span class="line">            h = iota   //7,恢复计数</span><br><span class="line">            i          //8</span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上实例运行结果为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 ha ha 100 100 7 8</span><br></pre></td></tr></table></figure><br>再看个有趣的的 iota 实例：</p>
<p>实例<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">const (</span><br><span class="line">    i=1&lt;&lt;iota</span><br><span class="line">    j=3&lt;&lt;iota</span><br><span class="line">    k</span><br><span class="line">    l</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;i=&quot;,i)</span><br><span class="line">    fmt.Println(&quot;j=&quot;,j)</span><br><span class="line">    fmt.Println(&quot;k=&quot;,k)</span><br><span class="line">    fmt.Println(&quot;l=&quot;,l)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上实例运行结果为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i= 1</span><br><span class="line">j= 6</span><br><span class="line">k= 12</span><br><span class="line">l= 24</span><br></pre></td></tr></table></figure><br>iota 表示从 0 开始自动加 1，所以 i=1&lt;&lt;0, j=3&lt;&lt;1（&lt;&lt; 表示左移的意思），即：i=1, j=6，这没问题，关键在 k 和 l，从输出结果看 k=3&lt;&lt;2，l=3&lt;&lt;3。</p>
<p>简单表述:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=1：左移 0 位,不变仍为 1;</span><br><span class="line">j=3：左移 1 位,变为二进制 110, 即 6;</span><br><span class="line">k=3：左移 2 位,变为二进制 1100, 即 12;</span><br><span class="line">l=3：左移 3 位,变为二进制 11000,即 24。</span><br></pre></td></tr></table></figure></p>
<h1 id="部分运算符"><a href="#部分运算符" class="headerlink" title="部分运算符"></a>部分运算符</h1><p>假定 A 为60，B 为13：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;</code></td>
<td>按位与运算符”&amp;”是双目运算符。 其功能是参与运算的两数各对应的二进位相与。</td>
<td>(A &amp; B) 结果为 12, 二进制为 0000 1100</td>
</tr>
<tr>
<td>竖线或</td>
<td>按位或运算符是双目运算符。 其功能是参与运算的两数各对应的二进位相或。</td>
<td>(A 或 B) 结果为 61, 二进制为 0011 1101</td>
</tr>
<tr>
<td>^</td>
<td>按位异或运算符”^”是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。</td>
<td>(A ^ B) 结果为 49, 二进制为 0011 0001</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移运算符”&lt;&lt;”是双目运算符。左移n位就是乘以2的n次方。 其功能把”&lt;&lt;”左边的运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td>
<td>A &lt;&lt; 2 结果为 240 ，二进制为 1111 0000</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移运算符<code>&gt;&gt;</code>是双目运算符。右移n位就是除以2的n次方。 其功能是把<code>&gt;&gt;</code>左边的运算数的各二进位全部右移若干位，<code>&gt;&gt;</code>右边的数指定移动的位数。</td>
<td>A &gt;&gt; 2 结果为 15 ，二进制为 0000 1111</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>返回变量存储地址</td>
<td>&a; 将给出变量的实际地址。</td>
</tr>
<tr>
<td>*</td>
<td>指针变量。</td>
<td>*a; 是一个指针变量</td>
</tr>
</tbody>
</table>
</div>
<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><h2 id="if-语句的语法如下："><a href="#if-语句的语法如下：" class="headerlink" title="if 语句的语法如下："></a>if 语句的语法如下：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if 布尔表达式 &#123;</span><br><span class="line">   /* 在布尔表达式为 true 时执行 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If 在布尔表达式为 true 时，其后紧跟的语句块执行，如果为 false 则不执行。</p>
<p>Go 编程语言中 if…else 语句的语法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if 布尔表达式 &#123;</span><br><span class="line">   /* 在布尔表达式为 true 时执行 */</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  /* 在布尔表达式为 false 时执行 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>If 在布尔表达式为 true 时，其后紧跟的语句块执行，如果为 false 则执行 else 语句块。</p>
<p>Go 编程语言中 if…else 语句的语法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if 布尔表达式 1 &#123;</span><br><span class="line">   /* 在布尔表达式 1 为 true 时执行 */</span><br><span class="line">   if 布尔表达式 2 &#123;</span><br><span class="line">      /* 在布尔表达式 2 为 true 时执行 */</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上至下逐一测试，直到匹配为止。</p>
<p>switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加 break。</p>
<p>switch 默认情况下 case 最后自带 break 语句，匹配成功后就不会执行其他 case，如果我们需要执行后面的 case，可以使用 fallthrough 。</p>
<p>语法<br>Go 编程语言中 switch 语句的语法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch var1 &#123;</span><br><span class="line">    case val1:</span><br><span class="line">        ...</span><br><span class="line">    case val2:</span><br><span class="line">        ...</span><br><span class="line">    default:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。</p>
<p>您可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：case val1, val2, val3。</p>
<p>switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。</p>
<p>Type Switch 语法格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch x.(type)&#123;</span><br><span class="line">    case type:</span><br><span class="line">       statement(s);      </span><br><span class="line">    case type:</span><br><span class="line">       statement(s); </span><br><span class="line">    /* 你可以定义任意个数的case */</span><br><span class="line">    default: /* 可选 */</span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h2><p>使用 fallthrough 会强制执行后面的 case 语句，fallthrough 不会判断下一条 case 的表达式结果是否为 true。</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。</p>
<p>select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。</p>
<p>语法<br>Go 编程语言中 select 语句的语法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">    case communication clause  :</span><br><span class="line">       statement(s);      </span><br><span class="line">    case communication clause  :</span><br><span class="line">       statement(s); </span><br><span class="line">    /* 你可以定义任意数量的 case */</span><br><span class="line">    default : /* 可选 */</span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以下描述了 select 语句的语法：</p>
<ul>
<li>每个 case 都必须是一个通信</li>
<li>所有 channel 表达式都会被求值</li>
<li>所有被发送的表达式都会被求值</li>
<li>如果任意某个通信可以进行，它就执行，其他被忽略。</li>
<li>如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。 </li>
</ul>
<p>否则：</p>
<ul>
<li>如果有 default 子句，则执行该语句。</li>
<li>如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。</li>
</ul>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>Go语言的For循环有3中形式，只有其中的一种使用分号。</p>
<p>和 C 语言的 for 一样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for init; condition; post &#123; &#125;</span><br></pre></td></tr></table></figure><br>和 C 的 while 一样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for condition &#123; &#125;</span><br></pre></td></tr></table></figure><br>和 C 的 for(;;) 一样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>init： 一般为赋值表达式，给控制变量赋初值；</li>
<li>condition： 关系表达式或逻辑表达式，循环控制条件；</li>
<li>post： 一般为赋值表达式，给控制变量增量或减量。</li>
</ul>
<p>for语句执行过程如下：</p>
<ul>
<li>先对表达式1赋初值；</li>
<li>判别赋值表达式 init 是否满足给定条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition；</li>
<li>否则判断 condition 的值为假，不满足条件，就终止for循环，执行循环体外语句。</li>
</ul>
<p>for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for key, value := range oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h2><p>Go 语言循环语句 Go语言循环语句</p>
<p>Go 语言中 break 语句用于以下两方面：</p>
<ul>
<li>用于循环语句中跳出循环，并开始执行循环之后的语句。</li>
<li>break 在 switch（开关语句）中在执行一条case后跳出语句的作用。</li>
</ul>
<p>Go 语言的 continue 语句 有点像 break 语句。但是 continue 不是跳出循环，而是跳过当前循环执行下一次循环语句。</p>
<p>for 循环中，执行 continue 语句会触发for增量语句的执行。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数是基本的代码块，用于执行一个任务。</p>
<p>Go 语言最少有个 main() 函数。</p>
<p>你可以通过函数来划分不同功能，逻辑上每个函数执行的是指定的任务。函数声明告诉了编译器函数的名称，返回类型，和参数。</p>
<p>Go 语言标准库提供了多种可动用的内置的函数。例如，len() 函数可以接受不同类型参数并返回该类型的长度。如果我们传入的是字符串则返回字符串的长度，如果传入的是数组，则返回数组中包含的元素个数。</p>
<p>Go 语言函数定义格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func function_name( [parameter list] ) [return_types] &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>func：函数由 func 开始声明</li>
<li>function_name：函数名称，函数名和参数列表一起构成了函数签名。</li>
<li>parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li>
<li>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li>
<li>函数体：函数定义的代码集合。</li>
</ul>
<h2 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a><strong>函数返回多个值</strong></h2><p>Go 函数可以返回多个值，例如：</p>
<p>实例<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func swap(x, y string) (string, string) &#123;</span><br><span class="line">   return y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   a, b := swap(&quot;Google&quot;, &quot;Runoob&quot;)</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h2><p>传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</p>
<h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><p>引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
<p>引用传递指针参数传递到函数内，以下是交换函数 swap() 使用了引用传递：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* 定义交换值函数*/</span><br><span class="line">func swap(x *int, y *int) &#123;</span><br><span class="line">   var temp int</span><br><span class="line">   temp = *x    /* 保持 x 地址上的值 */</span><br><span class="line">   *x = *y      /* 将 y 值赋给 x */</span><br><span class="line">   *y = temp    /* 将 temp 值赋给 y */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数作为实参"><a href="#函数作为实参" class="headerlink" title="函数作为实参"></a>函数作为实参</h2><p>Go 语言可以很灵活的创建函数，并作为另外一个函数的实参。以下实例中我们在定义的函数中初始化一个变量，该函数仅仅是为了使用内置函数 math.sqrt()，实例为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">   &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">   /* 声明函数变量 */</span><br><span class="line">   getSquareRoot := func(x float64) float64 &#123;</span><br><span class="line">      return math.Sqrt(x)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /* 使用函数 */</span><br><span class="line">   fmt.Println(getSquareRoot(9))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数闭包"><a href="#函数闭包" class="headerlink" title="函数闭包"></a>函数闭包</h2><p>go支持匿名函数，可作为闭包。匿名函数是一个”内联”语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</p>
<p>以下实例中，我们创建了函数 getSequence() ，返回另外一个函数。该函数的目的是在闭包中递增 i 变量，代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func getSequence() func() int &#123;</span><br><span class="line">   i:=0</span><br><span class="line">   return func() int &#123;</span><br><span class="line">      i+=1</span><br><span class="line">     return i  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">   /* nextNumber 为一个函数，函数 i 为 0 */</span><br><span class="line">   nextNumber := getSequence()  </span><br><span class="line"></span><br><span class="line">   /* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   </span><br><span class="line">   /* 创建新的函数 nextNumber1，并查看结果 */</span><br><span class="line">   nextNumber1 := getSequence()  </span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。语法格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (variable_name variable_data_type) function_name() [return_type]&#123;</span><br><span class="line">   /* 函数体*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面定义一个结构体类型和该类型的一个方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;  </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">/* 定义结构体 */</span><br><span class="line">type Circle struct &#123;</span><br><span class="line">  radius float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  var c1 Circle</span><br><span class="line">  c1.radius = 10.00</span><br><span class="line">  fmt.Println(&quot;圆的面积 = &quot;, c1.getArea())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//该 method 属于 Circle 类型对象中的方法</span><br><span class="line">func (c Circle) getArea() float64 &#123;</span><br><span class="line">  //c.radius 即为 Circle 类型对象中的属性</span><br><span class="line">  return 3.14 * c.radius * c.radius</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><p>作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。</p>
<p>Go 语言中变量可以在三个地方声明：</p>
<ul>
<li>函数内定义的变量称为局部变量</li>
<li>函数外定义的变量称为全局变量</li>
<li>函数定义中的变量称为形式参数</li>
</ul>
<p>接下来让我们具体了解局部变量、全局变量和形式参数。</p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。</p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用。</p>
<p>Go 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑。</p>
<h2 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h2><p>形式参数会作为函数的局部变量来使用。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>Go 语言提供了数组类型的数据结构。</p>
<p>数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整形、字符串或者自定义类型。</p>
<p>相对于去声明 number0, number1, …, number99 的变量，使用数组形式 numbers[0], numbers[1] …, numbers[99] 更加方便且易于扩展。</p>
<p>数组元素可以通过索引（位置）来读取（或者修改），索引从 0 开始，第一个元素索引为 0，第二个索引为 1，以此类推。</p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>Go 语言支持多维数组，以下为常用的多维数组声明方式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type</span><br></pre></td></tr></table></figure><br>以下实例声明了三维的整型数组：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var threedim [5][10][4]int</span><br></pre></td></tr></table></figure><br>二维数组是最简单的多维数组，二维数组本质上是由一维数组组成的。二维数组定义方式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arrayName [ x ][ y ] variable_type</span><br></pre></td></tr></table></figure></p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>Go 语言的取地址符是<code>&amp;</code>，放到一个变量前使用就会返回相应变量的内存地址。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   var a int = 10   </span><br><span class="line"></span><br><span class="line">   fmt.Printf(&quot;变量的地址: %x\n&quot;, &amp;a  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>指针使用流程：</p>
<ul>
<li>定义指针变量。</li>
<li>为指针变量赋值。</li>
<li>访问指针变量中指向地址的值。</li>
</ul>
<p>在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。</p>
<h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p>当一个指针被定义后没有分配到任何变量时，它的值为 nil。nil 指针也称为空指针。nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。</p>
<p>一个指针变量通常缩写为 ptr。</p>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。</p>
<p>结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。</p>
<h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><p>结构体定义需要使用 type 和 struct 语句。struct 语句定义一个新的数据类型，结构体有中有一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type struct_variable_type struct &#123;</span><br><span class="line">   member definition;</span><br><span class="line">   member definition;</span><br><span class="line">   ...</span><br><span class="line">   member definition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一旦定义了结构体类型，它就能用于变量的声明，语法格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable_name := structure_variable_type &#123;value1, value2...valuen&#125;</span><br></pre></td></tr></table></figure><br>或<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable_name := structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以像其他数据类型一样将结构体类型作为参数传递给函数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func printBook( book Books ) &#123;</span><br><span class="line">   fmt.Printf( &quot;Book title : %s\n&quot;, book.title);</span><br><span class="line">   fmt.Printf( &quot;Book author : %s\n&quot;, book.author);</span><br><span class="line">   fmt.Printf( &quot;Book subject : %s\n&quot;, book.subject);</span><br><span class="line">   fmt.Printf( &quot;Book book_id : %d\n&quot;, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>Go 语言切片是对数组的抽象。</p>
<p>Go 数组的长度不可改变，因此提供了一种灵活，功能强悍的内置类型切片(“动态数组”),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</p>
<h2 id="定义切片"><a href="#定义切片" class="headerlink" title="定义切片"></a>定义切片</h2><p>你可以声明一个未指定大小的数组来定义切片：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var identifier []type</span><br></pre></td></tr></table></figure><br>切片不需要说明长度。</p>
<p>或使用make()函数来创建切片:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var slice1 []type = make([]type, len)</span><br></pre></td></tr></table></figure><br>也可以简写为<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice1 := make([]type, len)</span><br></pre></td></tr></table></figure><br>也可以指定容量，其中capacity为可选参数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make([]T, length, capacity)</span><br></pre></td></tr></table></figure><br>这里 len 是数组的长度并且也是切片的初始长度。</p>
<h2 id="切片初始化"><a href="#切片初始化" class="headerlink" title="切片初始化"></a>切片初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s :=[] int &#123;1,2,3 &#125; </span><br></pre></td></tr></table></figure>
<p>直接初始化切片，[]表示是切片类型，{1,2,3}初始化值依次是1,2,3.其cap=len=3<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[:] </span><br></pre></td></tr></table></figure><br>初始化切片s,是数组arr的引用<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[startIndex:endIndex] </span><br></pre></td></tr></table></figure><br>将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[startIndex:] </span><br></pre></td></tr></table></figure><br>缺省endIndex时将表示一直到arr的最后一个元素<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[:endIndex] </span><br></pre></td></tr></table></figure><br>缺省startIndex时将表示从arr的第一个元素开始<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 := s[startIndex:endIndex] </span><br></pre></td></tr></table></figure><br>通过切片s初始化切片s1<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s :=make([]int,len,cap) </span><br></pre></td></tr></table></figure><br>通过内置函数make()初始化切片s,[]int 标识为其元素类型为int的切片</p>
<h2 id="len-和-cap-函数"><a href="#len-和-cap-函数" class="headerlink" title="len() 和 cap() 函数"></a>len() 和 cap() 函数</h2><p>切片是可索引的，并且可以由 len() 方法获取长度。</p>
<p>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</p>
<h2 id="空-nil-切片"><a href="#空-nil-切片" class="headerlink" title="空(nil)切片"></a>空(nil)切片</h2><p>一个切片在未初始化之前默认为 nil，长度为 0.</p>
<h1 id="范围（range）"><a href="#范围（range）" class="headerlink" title="范围（range）"></a>范围（range）</h1><p> range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对的 key 值。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kvs := map[string]string&#123;&quot;a&quot;: &quot;apple&quot;, &quot;b&quot;: &quot;banana&quot;&#125;</span><br><span class="line">    for k, v := range kvs &#123;</span><br><span class="line">        fmt.Printf(&quot;%s -&gt; %s\n&quot;, k, v)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Map-集合"><a href="#Map-集合" class="headerlink" title="Map(集合)"></a>Map(集合)</h1><p>Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。</p>
<p>Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。</p>
<h2 id="定义-Map"><a href="#定义-Map" class="headerlink" title="定义 Map"></a>定义 Map</h2><p>可以使用内建函数 make 也可以使用 map 关键字来定义 Map:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* 声明变量，默认 map 是 nil */</span><br><span class="line">var map_variable map[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line">/* 使用 make 函数 */</span><br><span class="line">map_variable := make(map[key_data_type]value_data_type)</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var countryCapitalMap map[string]string /*创建集合 */</span><br><span class="line">    countryCapitalMap = make(map[string]string)</span><br><span class="line"></span><br><span class="line">    /* map插入key - value对,各个国家对应的首都 */</span><br><span class="line">    countryCapitalMap [ &quot;France&quot; ] = &quot;巴黎&quot;</span><br><span class="line">    countryCapitalMap [ &quot;Italy&quot; ] = &quot;罗马&quot;</span><br><span class="line">    countryCapitalMap [ &quot;Japan&quot; ] = &quot;东京&quot;</span><br><span class="line">    countryCapitalMap [ &quot;India &quot; ] = &quot;新德里&quot;</span><br></pre></td></tr></table></figure></p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>Go 语言支持递归。但我们在使用递归时，开发者需要设置退出条件，否则递归将陷入无限循环中。</p>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>类型转换用于将一种数据类型的变量转换为另外一种类型的变量。Go 语言类型转换基本格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type_name(expression)</span><br></pre></td></tr></table></figure><br>type_name 为类型，expression 为表达式。</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type interface_name interface &#123;</span><br><span class="line">   method_name1 [return_type]</span><br><span class="line">   method_name2 [return_type]</span><br><span class="line">   method_name3 [return_type]</span><br><span class="line">   ...</span><br><span class="line">   method_namen [return_type]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 定义结构体 */</span><br><span class="line">type struct_name struct &#123;</span><br><span class="line">   /* variables */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 实现接口方法 */</span><br><span class="line">func (struct_name_variable struct_name) method_name1() [return_type] &#123;</span><br><span class="line">   /* 方法实现 */</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">func (struct_name_variable struct_name) method_namen() [return_type] &#123;</span><br><span class="line">   /* 方法实现*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>Go 语言通过内置的错误接口提供了非常简单的错误处理机制。</p>
<p>error类型是一个接口类型，这是它的定义：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type error interface &#123;</span><br><span class="line">    Error() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以在编码中通过实现 error 接口类型来生成错误信息。</p>
<p>函数通常在最后的返回值中返回错误信息。使用errors.New 可返回一个错误信息：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func Sqrt(f float64) (float64, error) &#123;</span><br><span class="line">    if f &lt; 0 &#123;</span><br><span class="line">        return 0, errors.New(&quot;math: square root of negative number&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在下面的例子中，我们在调用Sqrt的时候传递的一个负数，然后就得到了non-nil的error对象，将此对象与nil比较，结果为true，所以fmt.Println(fmt包在处理error时会调用Error方法)被调用，以输出错误，请看下面调用的示例代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result, err:= Sqrt(-1)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">   fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>Go 语言支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。</p>
<p>goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。</p>
<p>goroutine 语法格式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go 函数名( 参数列表 )</span><br></pre></td></tr></table></figure><br>例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go f(x, y, z)</span><br></pre></td></tr></table></figure><br>开启一个新的 goroutine:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x, y, z)</span><br></pre></td></tr></table></figure><br>Go 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine 共享同一个地址空间。</p>
<h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h1><p>通道（channel）是用来传递数据的一个数据结构。</p>
<p>通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 &lt;- 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    // 把 v 发送到通道 ch</span><br><span class="line">v := &lt;-ch  // 从 ch 接收数据</span><br><span class="line">           // 并把值赋给 v</span><br></pre></td></tr></table></figure></p>
<p>声明一个通道很简单，我们使用chan关键字即可，通道在使用前必须先创建：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int)</span><br></pre></td></tr></table></figure><br>注意：默认情况下，通道是不带缓冲区的。发送端发送数据，同时必须又接收端相应的接收数据。</p>
<p>以下实例通过两个 goroutine 来计算数字之和，在 goroutine 完成计算后，它会计算两个结果的和：</p>
<h2 id="通道缓冲区"><a href="#通道缓冲区" class="headerlink" title="通道缓冲区"></a>通道缓冲区</h2><p>通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int, 100)</span><br></pre></td></tr></table></figure></p>
<p>带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。</p>
<p>不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。</p>
<p>注意：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</p>
<h2 id="遍历通道与关闭通道"><a href="#遍历通道与关闭通道" class="headerlink" title="遍历通道与关闭通道"></a>遍历通道与关闭通道</h2><p>Go 通过 range 关键字来实现遍历读取到的数据，类似于与数组或切片。格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure><br>如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 close() 函数来关闭。</p>
<h1 id="Go语言并发之道1-3章"><a href="#Go语言并发之道1-3章" class="headerlink" title="Go语言并发之道1-3章"></a>Go语言并发之道1-3章</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性是指一个操作在运行的环境中是不可被分割的或不可被中断的。操作的原子性是根据当前定义的范围而改变的，上下文不同则一个操作可能不是原子性的。</p>
<p>使一个操作变为原子操作取决于你想让它在哪个上下文中，如果上下文是没有并发的，则该代码是原子性的。</p>
<h3 id="内存访问同步"><a href="#内存访问同步" class="headerlink" title="内存访问同步"></a>内存访问同步</h3><p>程序中需要独占访问共享资源的部分叫做“临界区”，看一个例子<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var memoryAccess sync.Mutex</span><br><span class="line">    var value int</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        memoryAccess.Lock()</span><br><span class="line">        value++</span><br><span class="line">        memoryAccess.Unlock()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    memoryAccess.Lock()</span><br><span class="line">    if value == 0 &#123;</span><br><span class="line">        fmt.Printf(&quot;the value is %v.\n&quot;, value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fmt.Printf(&quot;the value is %v.\n&quot;, value)</span><br><span class="line">    &#125;</span><br><span class="line">    memoryAccess.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们添加了一个sync.Mutex类型，声明一下在哪个部分里应该独占value这个变量。如果想要访问value这个变量，就要首先调用Lock，当访问结束后，调用Unlock。当然，也可能造成维护和性能的问题。</p>
<h3 id="defer关键字"><a href="#defer关键字" class="headerlink" title="defer关键字"></a>defer关键字</h3><p>defer代码块会在函数调用链表中增加一个函数调用。这个函数调用不是普通的函数调用，而是会在函数正常返回，也就是return之后添加一个函数调用。因此，defer通常用来释放函数内部变量。</p>
<h4 id="当defer被声明时，其参数就会被实时解析"><a href="#当defer被声明时，其参数就会被实时解析" class="headerlink" title="当defer被声明时，其参数就会被实时解析"></a>当defer被声明时，其参数就会被实时解析</h4><p>我们通过以下代码来解释这条规则:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func a() &#123;</span><br><span class="line">	i := 0</span><br><span class="line">	defer fmt.Println(i)</span><br><span class="line">	i++</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>虽然我们在defer后面定义的是一个带变量的函数: fmt.Println(i). 但这个变量在defer被声明的时候，就已经确定其确定的值了。 换言之，上面的代码等同于下面的代码:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func a() &#123;</span><br><span class="line">	i := 0</span><br><span class="line">	defer fmt.Println(0) //因为i=0，所以此时就明确告诉golang在程序退出时，执行输出0的操作</span><br><span class="line">	i++</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了更为明确的说明这个问题，我们继续定义一个defer:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func a() &#123;</span><br><span class="line">	i := 0</span><br><span class="line">	defer fmt.Println(i) //输出0，因为i此时就是0</span><br><span class="line">	i++</span><br><span class="line">	defer fmt.Println(i) //输出1，因为i此时就是1</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过运行结果，可以看到defer输出的值，就是定义时的值。而不是defer真正执行时的变量值(很重要，搞不清楚的话就会产生于预期不一致的结果)</p>
<p>但为什么是先输出1，在输出0呢？ 看下面的规则二。</p>
<h4 id="defer执行顺序为先进后出"><a href="#defer执行顺序为先进后出" class="headerlink" title="defer执行顺序为先进后出"></a>defer执行顺序为先进后出</h4><p>当同时定义了多个defer代码块时，golang安装先定义后执行的顺序依次调用defer。不要为什么，golang就是这么定义的。我们用下面的代码加深记忆和理解:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func b() &#123;</span><br><span class="line">	for i := 0; i &lt; 4; i++ &#123;</span><br><span class="line">		defer fmt.Print(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在循环中，依次定义了四个defer代码块。结合规则一，我们可以明确得知每个defer代码块应该输出什么值。 安装先进后出的原则，我们可以看到依次输出了3210.</p>
<h4 id="defer可以读取有名返回值"><a href="#defer可以读取有名返回值" class="headerlink" title="defer可以读取有名返回值"></a>defer可以读取有名返回值</h4><p>先看下面的代码:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func c() (i int) &#123;</span><br><span class="line">	defer func() &#123; i++ &#125;()</span><br><span class="line">	return 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出结果是12. 在开头的时候，我们说过defer是在return调用之后才执行的。 这里需要明确的是defer代码块的作用域仍然在函数之内，结合上面的函数也就是说，defer的作用域仍然在c函数之内。因此defer仍然可以读取c函数内的变量(如果无法读取函数内变量，那又如何进行变量清除呢….)。</p>
<p>当执行return 1 之后，i的值就是1. 此时此刻，defer代码块开始执行，对i进行自增操作。 因此输出2.</p>
<p>掌握了defer以上三条使用规则，那么当我们遇到defer代码块时，就可以明确得知defer的预期结果。</p>
<h3 id="死锁、活锁、饥饿"><a href="#死锁、活锁、饥饿" class="headerlink" title="死锁、活锁、饥饿"></a>死锁、活锁、饥饿</h3><p>死锁是所有并发进程等待的程序，在这种情况下，如果没有外界干预，这个程序将无法恢复。</p>
<h4 id="Coffman条件"><a href="#Coffman条件" class="headerlink" title="Coffman条件"></a>Coffman条件</h4><p>出现死锁的条件有以下几个必要条件：</p>
<ul>
<li>相互排斥：并发进程同时拥有资源的独占权</li>
<li>等待条件：并发进程必须同时拥有一个资源，并等待额外的资源</li>
<li>没有抢占：并发进程拥有的资源只能被该进程释放</li>
<li>循环等待：一个并发进程只能等待一系列其他并发进程，这些并发进程也在等待</li>
</ul>
<h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>正在主动执行并发操作的程序，但是无法向前推进程序的状态。看起来程序在工作。</p>
<h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>在任何情况下，并发进程欧步伐获得执行工作所需的所有资源。饥饿通常意味着有一个或多个贪婪的并发进程，它们不公平地阻止一个或多个并发进程，以尽可能地有效完成工作，或者阻止全部并发进程。</p>
<h2 id="通信顺序进程"><a href="#通信顺序进程" class="headerlink" title="通信顺序进程"></a>通信顺序进程</h2><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p>并行属于一个运行中的程序，并发属于代码。</p>
<h3 id="并发哲学"><a href="#并发哲学" class="headerlink" title="并发哲学"></a>并发哲学</h3><p>CSP即Communicating Sequential Process，通信顺序进程。</p>
<p>Go的运行时自动将goroutine映射到系统的线程上，并管理调度，因此可以在像goroutine阻塞等待IO之类的事情上进行内省，从而智能的把OS的线程分配到没有阻塞的goroutine上。</p>
<p>如果有一块产生计算结果并想共享结果给其他代码块的代码，则需要传递数据的所有权。并发程序安全就是保证同时只有一个并发上下文拥有数据的所有权。通过channel类型解决，可以创建一个带缓存的channel实现低成本的在内存中的队列来解耦生产者和消费者。</p>
<p>使用channel时可以更简单的控制软件中出现的复杂性。</p>
<h2 id="并发组件"><a href="#并发组件" class="headerlink" title="并发组件"></a>并发组件</h2><h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><p>每个Go程序中都有至少一个goroutine： main goroutine。goroutine是一个并发的函数，在一个函数前添加go关键字来触发。匿名函数也行：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go func() &#123;</span><br><span class="line">	fmt.Println(&quot;hello&quot;)</span><br><span class="line">&#125; ()</span><br></pre></td></tr></table></figure><br>函数赋值也行：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sayhello := func() &#123;</span><br><span class="line">	fmt.Println(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go sayhello()</span><br></pre></td></tr></table></figure></p>
<p>go中的goroutine是一个更高级别的抽象，称为<strong>协程</strong>，一中非抢占式的简单并发子程序，不能被中断，允许暂停或重入。Go的运行时会观察goroutine的运行时行为，并在它们阻塞时自动挂起它们，然后在它们不被阻塞时自动恢复它们。</p>
<p>go的主机托管机制是一个名为M:N调度器的实现。将M个绿色线程映射到N个OS线程，然后将goroutine安排在绿色线程上。</p>
<p>go遵循一个fork-join并发模型，将执行的子分支与其父节点同时运行，这些并发的执行分支将会在未来合并在一起。为了创建一个join点，必须对程序进行同步，这里可以通过sync.Watigroup实现。</p>
<p>在下边这个程序中，输出的是“world”，因此可以说明goroutine在它们所创建的相同地址空间内执行。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    salutation := &quot;hello&quot;</span><br><span class="line">    wg.Add(1)</span><br><span class="line">    go func()&#123;</span><br><span class="line">        defer wg.Done()</span><br><span class="line">        salutation = &quot;world&quot;</span><br><span class="line">    &#125;()</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(salutation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>可以以如下方式将参数传到函数中，以输出正确结果。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for _, salt := range []string&#123;&quot;hello&quot;, &quot;greetings&quot;, &quot;good day&quot;&#125; &#123;</span><br><span class="line">    wg.Add(1)</span><br><span class="line">    go func(salt string) &#123;</span><br><span class="line">        defer wg.Done()</span><br><span class="line">        fmt.Println(salt)</span><br><span class="line">    &#125; (salt)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="sync包"><a href="#sync包" class="headerlink" title="sync包"></a>sync包</h3><p>sync包包含了对低级别内存访问同步最有用的并发原语。</p>
<h4 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h4><p>可以调用Add表明n个goroutine已经开始了，使用defer关键字确保在goroutine退出之前执行Done操作。执行Wait操作将会阻塞main goroutine直到所有goroutine表明它们已经退出。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">wg.Add(1)</span><br><span class="line">go func() &#123;</span><br><span class="line">    defer wg.Done()</span><br><span class="line">    fmt.Println(&quot;1st goroutine sleeping&quot;)</span><br><span class="line">    time.Sleep(1)</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line">wg.Add(1)</span><br><span class="line">go func() &#123;</span><br><span class="line">    defer wg.Done()</span><br><span class="line">    fmt.Println(&quot;2nd goroutine sleeping&quot;)</span><br><span class="line">    time.Sleep(2)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(&quot;All goroutine complete&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>WaitGroup调用通过传入的整数执行Add操作增加计数器的增量，并<strong>调用Done递减</strong>，Wait阻塞，直到计数器为0.</p>
<h4 id="互斥锁和读写锁"><a href="#互斥锁和读写锁" class="headerlink" title="互斥锁和读写锁"></a>互斥锁和读写锁</h4><p>channel通过通信共享内存，而Mutex通过开发人员的约定同步访问共享内存。</p>
<p>Mutex有两个函数，Lock和Unlock，在defer中调用Unlock保证即使出现了panic，也可以及时调用Unlock，避免死锁。</p>
<p>进入和退出一个临界区是有开销的，所以要减少临界区的范围，可能存在多个并发进程之间共享内存，但这些进程不是都需要读写此内存，可以利用不同类型的互斥对象，sync.RWMutex。可以请求一个锁用于读或者写。</p>
<h4 id="cond"><a href="#cond" class="headerlink" title="cond"></a>cond</h4><p>cond是一个goroutine的集合点，等待或发布一个event，在这里一个event是两个或两个以上的goroutine之间的任意信号。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">c.L.Lock()</span><br><span class="line">for conditionTrue() == false &#123;</span><br><span class="line">	c.Wait()</span><br><span class="line">&#125;</span><br><span class="line">c.L.Unlock()</span><br></pre></td></tr></table></figure><br>上述代码实例化一个cond，NewCond创建一个类型，cond类型能够以一种并发安全的方式与其他goroutine协调。</p>
<p>Broadcast提供了同时与多个goroutine通信的方法，在Clicked Cond上调用Broadcast，则所有三个函数都将运行。它内部维护一个FIFO列表，等待接收信号，向所有等待的goroutine发送信号。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    type Button struct &#123;</span><br><span class="line">        Clicked *sync.Cond</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    button := Button&#123; Clicked: sync.NewCond(&amp;sync.Mutex&#123;&#125;)  &#125;</span><br><span class="line">    subscribe := func(c *sync.Cond, fn func()) &#123;</span><br><span class="line">        var goroutineRunning sync.WaitGroup</span><br><span class="line">        goroutineRunning.Add(1)</span><br><span class="line">        go func()&#123;</span><br><span class="line">            goroutineRunning.Done()</span><br><span class="line">            c.L.Lock()</span><br><span class="line">            defer c.L.Unlock()</span><br><span class="line">            c.Wait()</span><br><span class="line">            fn()</span><br><span class="line">        &#125;()</span><br><span class="line">        goroutineRunning.Wait()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var clickRegistered sync.WaitGroup</span><br><span class="line">    clickRegistered.Add(3)</span><br><span class="line">    subscribe(button.Clicked, func() &#123;</span><br><span class="line">        fmt.Println(&quot;Maximizing window&quot;)</span><br><span class="line">        clickRegistered.Done()</span><br><span class="line">    &#125;)</span><br><span class="line">    subscribe(button.Clicked, func() &#123;</span><br><span class="line">        fmt.Println(&quot;Displaying annoying dialog box!&quot;)</span><br><span class="line">        clickRegistered.Done()</span><br><span class="line">    &#125;)</span><br><span class="line">    subscribe(button.Clicked, func() &#123;</span><br><span class="line">    fmt.Println(&quot;Mouse clicked&quot;)</span><br><span class="line">    clickRegistered.Done()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    button.Clicked.Broadcast()</span><br><span class="line">    clickRegistered.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="once"><a href="#once" class="headerlink" title="once"></a>once</h4><p>sync.Once在内部调用一些原语，确保即使在不同的goroutine上也只会调用一次Do方法处理传进来的函数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var count int</span><br><span class="line">increment := func() &#123;count++&#125;</span><br><span class="line">decrement := func() &#123;count--&#125;</span><br><span class="line"></span><br><span class="line">var once sync.Once</span><br><span class="line">once.Do(increment)</span><br><span class="line">once.Do(decrement)</span><br></pre></td></tr></table></figure><br>上述程序输出的是<strong>1</strong>，因为once只计算Do调用的次数，不管Do函数里边的参数是什么。</p>
<h3 id="池"><a href="#池" class="headerlink" title="池"></a>池</h3><p>Pool模式是一种创建和提供可供使用的固定数量实例或Pool实例的方法，用于约束创建昂贵的场景，以便只创建固定数量的实例，但不确定数量的操作仍然可以请求访问这些场景。</p>
<p>Pool的主接口是Get方法，首先检查池中是否有可用的实例，如果没有则调用new方法创建一个，完成时调用者调用Put方法将实例归还。</p>
<p>Pool也用来尽可能快地将预先分配的对象缓存加载启动，通过提前加载获取引用到另一个对象所需的时间，来节省消费者的时间。</p>
<ul>
<li>实例化sync.Pool时，使用new方法创建一个成员变量，在调用时是线程安全的。</li>
<li>收到来自Get的实例时，不要对接收的对象的状态做出任何假设。</li>
<li>当你用完了从Pool中取出的对象时一定要调用Put否则Pool无法复用这个实例。</li>
<li>Pool内的分布大致均匀。</li>
</ul>
<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>channel充当着信息传送的管道，值可以沿着channel传递。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var dataStream chan interface&#123;&#125;</span><br><span class="line">dataStream = make(chan interface&#123;&#125;)</span><br></pre></td></tr></table></figure><br>上面声明了一个新channel，因为声明的类型是空接口，所以类型是interface{}，并且使用内置的make函数实例化channel。</p>
<p>声明一个单向channel只需包含“&lt;-”，声明一个只能读取的channel，将“&lt;-”放在左边：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var dataStream &lt;-chan interface&#123;&#125;</span><br><span class="line">dataStream = make(&lt;-chan interface&#123;&#125;)</span><br></pre></td></tr></table></figure></p>
<p>声明一个只能发送的channel，则将“&lt;-”放在右边。</p>
<p>通过将“&lt;-”放到channel的右边实现发送操作，通过将“&lt;-”放到channel的左边实现接收操作。另一种方法是数据流向箭头所指方向的变量。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stringStream := make(chan string)</span><br><span class="line">go func()&#123;</span><br><span class="line">	stringStream &lt;- &quot;hello&quot;</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(&lt;-stringStream)</span><br></pre></td></tr></table></figure><br>上述代码实现了将字符串文本传递到stringStream channel并读取channel的字符串并打印到stdout。</p>
<p>可以从channel中获取，然后通过range遍历，并且在channel关闭时自动中断循环：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">intStream := make(chan int)</span><br><span class="line">go func() &#123;</span><br><span class="line">    defer close(intStream)</span><br><span class="line">    for i:= 1; i &lt;= 5; i ++ &#123;</span><br><span class="line">        intStream &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line">for integer := range intStream &#123;</span><br><span class="line">    fmt.Printf(&quot;%v &quot;,integer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>关闭channel也是一种同时给多个goroutine发信号的方法，如果有n个goroutine在一个channel上等待，而不是在channel上写n次来打开每个goroutine，可以简单地关闭channel。</p>
<p>更可以创建buffered channel，在实例化时提供容量。即使没有在channel上执行读取操作，goroutine仍然可以写入n次。</p>
<p>如果说channel是满的，那么写入channel阻塞。无缓冲的channel容量为0，因此在任何写入之前就已经满了，缓冲channel是一个内存中的FIFO队列，用于并发进程通信。</p>
<p>我们需要在正确的环境中配置channel，channel的所有者对channel拥有写访问视图，使用者只有读访问视图。拥有channel的goroutine应该：</p>
<ol>
<li>实例化channel；</li>
<li>执行写操作，或将所有权传递给另一个goroutine；</li>
<li>关闭channel</li>
<li>通过只读channel将上述三件事暴露出来。</li>
</ol>
<h3 id="select-1"><a href="#select-1" class="headerlink" title="select"></a>select</h3><p>select是将channel绑定在一起的粘合剂，在一个系统中两个或多个组件的交集中，可以在本地、单个函数或类型以及全局范围内找到select语句绑定在一起的channel。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var c1, c2 &lt;-chan interface&#123;&#125;</span><br><span class="line">var c3 chan&lt;- interface&#123;&#125;</span><br><span class="line">select &#123;</span><br><span class="line">	case &lt;- c1:</span><br><span class="line">		....</span><br><span class="line">	case &lt;- c2:</span><br><span class="line">		....</span><br><span class="line">	case &lt;- c3:</span><br><span class="line">		....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果多个channel是可用的，则执行伪随机选择，每一个都可能被执行到。如果没有任何channel可用，则我们需要使用time包中的超时机制，time.After。</p>
<h3 id="GOMAXPROCS控制"><a href="#GOMAXPROCS控制" class="headerlink" title="GOMAXPROCS控制"></a>GOMAXPROCS控制</h3><p>这是runtime中的一个函数，这个函数控制的OS线程的数量将承载所谓的“工作队列”。runtime.GOMAXPROCS总是被设置成为主机上逻辑CPU的数量。</p>
<h1 id="Go语言并发之道第4章"><a href="#Go语言并发之道第4章" class="headerlink" title="Go语言并发之道第4章"></a>Go语言并发之道第4章</h1><p>提示：interface{}可用于向函数传递任意类型的变量，但对于函数内部，该变量仍然为interface{}类型（空接口类型），</p>
<h2 id="Go的并发模式"><a href="#Go的并发模式" class="headerlink" title="Go的并发模式"></a>Go的并发模式</h2><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>约束是一种确保了信息只能从一个并发过程中获取到的简单且强大的方法，特定约束是指通过公约实现约束，词法约束涉及使用词法作用域仅公开用于多个并发进程的正确数据和并发原语。</p>
<h3 id="for-select循环"><a href="#for-select循环" class="headerlink" title="for-select循环"></a>for-select循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">	// 要不就无限循环，要不就使用range循环</span><br><span class="line">	select &#123;</span><br><span class="line">		//使用channel作业</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="向channel发送迭代变量"><a href="#向channel发送迭代变量" class="headerlink" title="向channel发送迭代变量"></a>向channel发送迭代变量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for _, s := range []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125; &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">		case &lt;- done:</span><br><span class="line">			return</span><br><span class="line">		case stringStream &lt;- s: </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="循环等待停止"><a href="#循环等待停止" class="headerlink" title="循环等待停止"></a>循环等待停止</h4><p>创建循环，无限直至停止。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">		case &lt;- done:</span><br><span class="line">			return</span><br><span class="line">		default:</span><br><span class="line">	&#125;</span><br><span class="line">	// 非抢占式任务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="防止goroutine泄露"><a href="#防止goroutine泄露" class="headerlink" title="防止goroutine泄露"></a>防止goroutine泄露</h3><p>main goroutine可能会在其生命周期内将其他的goroutine设置为自旋，导致内存利用率下降。减轻这种情况的方法是在父goroutine和子goroutine之间建立一个信号，让父goroutine向其子goroutine发出信号通知。父goroutine将该channel发送给子goroutine，然后在想要取消子goroutine时关闭该channel。</p>
<p>确保：如果goroutine负责创建goroutine，那么它也负责确保可以停止goroutine。</p>
<h3 id="or-channel"><a href="#or-channel" class="headerlink" title="or-channel"></a>or-channel</h3><p>使用or-channel模式将多个channel组合起来。通过递归和goroutine创建一个符合done channel</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    var or func(channels ...&lt;-chan interface&#123;&#125;) &lt;-chan interface&#123;&#125;</span><br><span class="line">    or = func(channels ...&lt;-chan interface&#123;&#125;) &lt;-chan interface&#123;&#125; &#123;</span><br><span class="line">        switch len(channels) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                return nil</span><br><span class="line">            case 1:</span><br><span class="line">                return channels[0]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        orDone := make(chan interface&#123;&#125;)</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer close()</span><br><span class="line">            switch len(channels):</span><br><span class="line">                case 2:</span><br><span class="line">                    select&#123;</span><br><span class="line">                        case &lt;-channels[0]:</span><br><span class="line">                        case &lt;-channels[1]:</span><br><span class="line">                        case &lt;-channels[1]:</span><br><span class="line">                        case &lt;-channels[2]:</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">type Result struct &#123;</span><br><span class="line">    Error error</span><br><span class="line">    Response *http.Response</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">    checkStatus := func(</span><br><span class="line">        done &lt;-chan interface&#123;&#125;,</span><br><span class="line">        urls ...string,</span><br><span class="line">    ) &lt;-chan Result &#123;</span><br><span class="line">        results := make(chan Result)</span><br><span class="line">        go func()&#123;</span><br><span class="line">            defer close(results)</span><br><span class="line">            for _, url := range urls &#123;</span><br><span class="line">                var result Result</span><br><span class="line">                resp, err := http.Get(url)</span><br><span class="line">                result = Result&#123;Error: err, Response: resp&#125;</span><br><span class="line">                select &#123;</span><br><span class="line">                    case &lt;-done:</span><br><span class="line">                        return</span><br><span class="line">                    case results &lt;-result:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        return results</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done := make(chan interface&#123;&#125;)</span><br><span class="line">    defer close(done)</span><br><span class="line">    urls := []string&#123;&quot;https://www.baidu.com&quot;, &quot;https://badhost&quot;&#125;</span><br><span class="line">    for result := range checkStatus(done, urls...)&#123;</span><br><span class="line">        if result.Error != nil &#123;</span><br><span class="line">            fmt.Printf(&quot;Error: %v.\n&quot;, result.Error)</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(&quot;Response: %v.\n&quot;, result.Response.Status)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3><p>一个stage是将数据输入，对其进行转换并将数据发回。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">multiply := func(values []int, len(values)) []int &#123;&#125;</span><br><span class="line">add := func(values []int, additive int) []int &#123;&#125;</span><br><span class="line"></span><br><span class="line">ints := []int&#123;1, 2, 3, 4&#125;</span><br><span class="line">for _, v := range add(multiply(ints, 2), 1) &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在range子句中结合加法和乘法，这样构建了一个具有pipeline stage的属性，组合形成pipeline。</p>
<p>pipeline stage的属性是：</p>
<ul>
<li>一个stage消耗并返回相同的类型；</li>
<li>一个stage必须用语言来表达，以便可以被传递；</li>
</ul>
<p>channel适合在Go中构建pipeline，可以接受和产生值，且可以安全的使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    generator := func(done &lt;-chan interface&#123;&#125;, integers ...int) &lt;-chan int &#123;</span><br><span class="line">        intStream := make(chan int)</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer close(intStream)</span><br><span class="line">            for _, i := range integers &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;-done:</span><br><span class="line">                    return</span><br><span class="line">                case intStream &lt;- i:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        return intStream</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    multiply := func(done &lt;-chan interface&#123;&#125;, intStream &lt;-chan int, multiplier int) &lt;-chan int &#123;</span><br><span class="line">        multipliedStream := make(chan int)</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer close(multipliedStream)</span><br><span class="line">            for i := range intStream &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;-done:</span><br><span class="line">                    return</span><br><span class="line">                case multipliedStream &lt;- i * multiplier:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        return multipliedStream</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add := func(done &lt;-chan interface&#123;&#125;, intStream &lt;-chan int, additive int) &lt;-chan int &#123;</span><br><span class="line"></span><br><span class="line">        addedStream := make(chan int)</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer close(addedStream)</span><br><span class="line">            for i := range intStream &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;-done:</span><br><span class="line">                    return</span><br><span class="line">                case addedStream &lt;- i + additive:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        return addedStream</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done := make(chan interface&#123;&#125;)</span><br><span class="line">    defer close(done)</span><br><span class="line"></span><br><span class="line">    intStream := generator(done, 1, 2, 3, 4)</span><br><span class="line">    pipeline := multiply(done, add(done, multiply(done, intStream, 2), 1), 2)</span><br><span class="line"></span><br><span class="line">    for v := range pipeline &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>挺有意思的，显示了流水线的操作。</p>
<p>generator接受一个可变的整数切片，构造一个缓存长度等于输入片段的整数channel，启动goroutine并返回构造的channel，将一组离散值转化成一个channel上的数据流。</p>
<h3 id="扇入扇出"><a href="#扇入扇出" class="headerlink" title="扇入扇出"></a>扇入扇出</h3><p>扇出是描述启动多个goroutine以处理来自pipeline的输入的过程；扇入是描述将多个结果组合到一个channel的过程中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">primeStream := primeFinder(done, randIntStream)</span><br><span class="line"></span><br><span class="line">numFinders := runtime.NumCPU()</span><br><span class="line">finders := make([]&lt;-chan int, numFinders)</span><br><span class="line">for i := 0; i &lt; numFinders; i ++ &#123;</span><br><span class="line">	finders[i] = primeFinder(done, randIntStream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里启动了stage的多个副本，有n个goroutine从随机数发生器中拉出并试图确定数字是否为素数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">package pips</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type PrimePip struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewPrimePip() *PrimePip &#123;</span><br><span class="line">    primePip := &amp;PrimePip&#123;&#125;</span><br><span class="line">    return primePip</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (primePip *PrimePip) RepeatFn(</span><br><span class="line">    done &lt;-chan interface&#123;&#125;,</span><br><span class="line">    fn func() interface&#123;&#125;,</span><br><span class="line">) &lt;-chan interface&#123;&#125; &#123;</span><br><span class="line">    valueStream := make(chan interface&#123;&#125;)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer close(valueStream)</span><br><span class="line">        for &#123;</span><br><span class="line">            select &#123;</span><br><span class="line">            case &lt;-done:</span><br><span class="line">                return</span><br><span class="line">            case valueStream &lt;- fn():</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return valueStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (primePip *PrimePip) Take(</span><br><span class="line">    done &lt;-chan interface&#123;&#125;,</span><br><span class="line">    valueStream &lt;-chan interface&#123;&#125;,</span><br><span class="line">    num int,</span><br><span class="line">) &lt;-chan interface&#123;&#125; &#123;</span><br><span class="line">    takeStream := make(chan interface&#123;&#125;)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer close(takeStream)</span><br><span class="line">        for i := 0; i &lt; num; i++ &#123;</span><br><span class="line">            select &#123;</span><br><span class="line">            case &lt;-done:</span><br><span class="line">                return</span><br><span class="line">            case takeStream &lt;- &lt;-valueStream:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return takeStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (primePip *PrimePip) ToInt(</span><br><span class="line">    done &lt;-chan interface&#123;&#125;,</span><br><span class="line">    valueStream &lt;-chan interface&#123;&#125;,</span><br><span class="line">) &lt;-chan int &#123;</span><br><span class="line">    intStream := make(chan int)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer close(intStream)</span><br><span class="line">        for v := range valueStream &#123;</span><br><span class="line">            select &#123;</span><br><span class="line">            case &lt;-done:</span><br><span class="line">                return</span><br><span class="line">            case intStream &lt;- v.(int):</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return intStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (primePip *PrimePip) PrimeFinder(</span><br><span class="line">    done &lt;-chan interface&#123;&#125;,</span><br><span class="line">    intStream &lt;-chan int,</span><br><span class="line">) &lt;-chan interface&#123;&#125; &#123;</span><br><span class="line">    primeStream := make(chan interface&#123;&#125;)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer close(primeStream)</span><br><span class="line">        for integer := range intStream &#123;</span><br><span class="line">            integer -= 1</span><br><span class="line">            prime := true</span><br><span class="line">            for divisor := integer - 1; divisor &gt; 1; divisor-- &#123;</span><br><span class="line">                if integer%divisor == 0 &#123;</span><br><span class="line">                    prime = false</span><br><span class="line">                    break</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if prime &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;-done:</span><br><span class="line">                    return</span><br><span class="line">                case primeStream &lt;- integer:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return primeStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (primePip *PrimePip) FanIn(</span><br><span class="line">    done &lt;-chan interface&#123;&#125;,</span><br><span class="line">    channels ...&lt;-chan interface&#123;&#125;,</span><br><span class="line">) &lt;-chan interface&#123;&#125; &#123;</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    multiplexedStream := make(chan interface&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    multiplexed := func(c &lt;-chan interface&#123;&#125;) &#123;</span><br><span class="line">        defer wg.Done()</span><br><span class="line">        for i := range c &#123;</span><br><span class="line">            select &#123;</span><br><span class="line">            case &lt;-done:</span><br><span class="line">                return</span><br><span class="line">            case multiplexedStream &lt;- i:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Add(len(channels))</span><br><span class="line">    for _, c := range channels &#123;</span><br><span class="line">        go multiplexed(c)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        wg.Wait()</span><br><span class="line">        close(multiplexedStream)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    return multiplexedStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="or-done-channel"><a href="#or-done-channel" class="headerlink" title="or-done-channel"></a>or-done-channel</h3><p>用于处理来自系统各个分散部分的channel，需要用channel中的select语句来包装我们的读操作，并从已完成的channel中进行选择。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">orDone := func(done, c &lt;-chan interface&#123;&#125;) &lt;-chan interface&#123;&#125; &#123;</span><br><span class="line">	valStream := make(chan interface&#123;&#125;)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		defer close(valStream)</span><br><span class="line">		for &#123;</span><br><span class="line">			select &#123;</span><br><span class="line">				case &lt;-done:</span><br><span class="line">					return </span><br><span class="line">				case v, ok := &lt;-c:</span><br><span class="line">				if ok == false&#123;</span><br><span class="line">					return</span><br><span class="line">				&#125;</span><br><span class="line">				select &#123;</span><br><span class="line">					case valStream &lt;- v:</span><br><span class="line">					case &lt;-done:</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; ()</span><br><span class="line">	return valStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tee-channel"><a href="#tee-channel" class="headerlink" title="tee-channel"></a>tee-channel</h3><p>分割一个来自channel的值，以便将他们发送到代码的两个独立区域。</p>
<h3 id="队列排队"><a href="#队列排队" class="headerlink" title="队列排队"></a>队列排队</h3><p>在队列尚未准备好的时候开始接受请求，只要stage完成了工作，就会把结果存放在一个稍后其他stage可以获取到的临时位置。</p>
<ul>
<li>在一个stage批处理请求节省时间</li>
<li>如果stage中的延迟产生反馈回路进入系统。</li>
</ul>
<h3 id="context包"><a href="#context包" class="headerlink" title="context包"></a>context包</h3><p>主要包括：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Canceled = errors.New(&quot;context canceled&quot;)</span><br><span class="line">var DeadlineExceeded error = deadlineExceededError&#123;&#125;</span><br><span class="line"></span><br><span class="line">type CancelFunc</span><br><span class="line">type Context</span><br><span class="line"></span><br><span class="line">func Background() Context</span><br><span class="line">func TODO() Context</span><br><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</span><br><span class="line">func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)</span><br><span class="line">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</span><br><span class="line">func WithValue(parent Context, key, val interface&#123;&#125;) Context</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>上下文包有两个目的：</p>
<ul>
<li>提供可以取消调用图中分支的API</li>
<li>提供用于通过呼叫传输请求范围数据的数据包</li>
</ul>
<p>context类型将是函数的第一个参数，此外，接收context的函数并不能取消它，这保护了调用堆栈上的函数被子函数取消上下文的情况。</p>
<p>上述context包中的函数都接收一个Context参数，并返回一个Context。WithCancel返回新Context，它在调用返回的cancel函数时关闭其done channel。WithDeadline返回一个新的Context，当机器的时钟超过给定的最后期限时，它关闭完成的channel。WithTimeout返回一个新的Context，它在给定的超时时间后关闭完成的channel。</p>
<p>如果函数以某种方式在调用图中取消它后面的函数，它将调用其中一个函数并传递给它的上下文，然后将返回的上下文传递给它的子元素，如果函数不需要修改取消行为，则只传递给定的上下文。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    defer cancel() </span><br><span class="line">    wg.Add(1)</span><br><span class="line">    </span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer wg.Done()</span><br><span class="line">        if err := printGreeting(ctx); err != nil &#123;</span><br><span class="line">            fmt.Printf(&quot;cannot print greeting: %v\n&quot;, err)</span><br><span class="line">            cancel()</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;() </span><br><span class="line">    </span><br><span class="line">    wg.Add(1)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer wg.Done()</span><br><span class="line">        if err := printFarewell(ctx); err != nil &#123;</span><br><span class="line">            fmt.Printf(&quot;cannot print greeting: %v\n&quot;, err)</span><br><span class="line">            cancel()</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;() </span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">func printGreeting(ctx context.Context) error &#123;</span><br><span class="line">    greeting, err := genGreeting(ctx)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;%s world!\n&quot;, greeting)</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printFarewell(ctx context.Context) error &#123;</span><br><span class="line">    farewell, err := genFarewell(ctx)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;%s world!\n&quot;, farewell)</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func genGreeting(ctx context.Context) (string, error) &#123;</span><br><span class="line">    ctx, cancel := context.WithTimeout(ctx, 1*time.Second)</span><br><span class="line">    defer cancel()</span><br><span class="line">    switch locale, err := locale(ctx); &#123;</span><br><span class="line">    case err != nil:</span><br><span class="line">        return &quot;&quot;, err</span><br><span class="line">    case locale == &quot;EN/US&quot;:</span><br><span class="line">        return &quot;hello&quot;, nil</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;&quot;, fmt.Errorf(&quot;unsupported locale&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func genFarewell(ctx context.Context) (string, error) &#123;</span><br><span class="line">    switch locale, err := locale(ctx); &#123;</span><br><span class="line">    case err != nil:</span><br><span class="line">        return &quot;&quot;, err</span><br><span class="line">    case locale == &quot;EN/US&quot;:</span><br><span class="line">        return &quot;godbye&quot;, nil</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;&quot;, fmt.Errorf(&quot;unsupported locale&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func locale(ctx context.Context) (string, error) &#123;</span><br><span class="line">    if deadline, ok := ctx.Deadline(); ok &#123;</span><br><span class="line">        if deadline.Sub(time.Now().Add(1*time.Minute)) &lt;= 0 &#123;</span><br><span class="line">            return &quot;&quot;, context.DeadlineExceeded</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-ctx.Done():</span><br><span class="line">        return &quot;&quot;, ctx.Err()</span><br><span class="line">    case &lt;-time.After(1 * time.Minute):</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;EN/US&quot;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述程序允许locale函数快速失败，不必实际等待超时发生。</p>
<p>context包的另一个功能是用于存储和检索请求范围数据的Context数据包。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func ProcessRequest(userID, authToken string) &#123;</span><br><span class="line">    ctx := context.WithValue(context.Background(), &quot;userID&quot;, userID)</span><br><span class="line">    ctx = context.WithValue(ctx, &quot;authToken&quot;, authToken)</span><br><span class="line"></span><br><span class="line">    HandleResponse(ctx)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func HandleResponse(ctx context.Context) &#123;</span><br><span class="line">    fmt.Printf(&quot;handling response for %v (%v)\n&quot;, ctx.Value(&quot;userID&quot;), ctx.Value(&quot;authToken&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<ul>
<li>我们使用的键值必须满足Go的可比性概念，即==和!=在使用时需要返回正确的结果。</li>
<li>返回值必须安全，才能从多个goroutine访问</li>
</ul>
<p>由于context的键和值都被定义为interface{}，所以当试图检索值时，我们会失去Go的类型安全性，key可以是不同的类型，或者与我们提供的key略有不同。建议在软件包里定义一个自定义键类型：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type foo int</span><br><span class="line">type bar int</span><br><span class="line"></span><br><span class="line">m := make(map[interface&#123;&#125;] int)</span><br><span class="line">m[foo(1)] = 1</span><br><span class="line">m[bar(1)] = 1</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%v&quot;, m)</span><br></pre></td></tr></table></figure></p>
<p>输出为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[1:1, 2:2]</span><br></pre></td></tr></table></figure></p>
<p>虽然基础值是相同的，但是科通通过不同的类型信息在map中区分它们。</p>
<h1 id="Go语言并发之道第5章"><a href="#Go语言并发之道第5章" class="headerlink" title="Go语言并发之道第5章"></a>Go语言并发之道第5章</h1><h2 id="异常传递"><a href="#异常传递" class="headerlink" title="异常传递"></a>异常传递</h2><p>我们需要对传入的异常信息进行传递和处理，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func PostReport(id string) error &#123;</span><br><span class="line">	result, err := lowlevel.DoWork()</span><br><span class="line">	if err != nil&#123;</span><br><span class="line">		if _, ok := err.(lowlevel.Error); ok &#123;</span><br><span class="line">			err = WrapErr(err, &quot;cannot post report with id %q&quot;, id)</span><br><span class="line">		&#125;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里检查接收到的异常信息，确保结构良好，使用一个假设的函数将传入的异常和模块相关信息封装起来，并赋予一个新类型。</p>
<p>创建一个异常类型：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">type MyError struct &#123;</span><br><span class="line">    Inner      error</span><br><span class="line">    Message    string</span><br><span class="line">    StackTrace string</span><br><span class="line">    Misc       map[string]interface&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func wrapError(err error, messagef string, msgArgs ...interface&#123;&#125;) MyError &#123;</span><br><span class="line">    return MyError&#123;</span><br><span class="line">        Inner:      err,</span><br><span class="line">        Message:    fmt.Sprintf(messagef, msgArgs...),</span><br><span class="line">        StackTrace: &quot;stack!!!&quot;,</span><br><span class="line">        Misc:       make(map[string]interface&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (err MyError) Error() string &#123;</span><br><span class="line">    return err.Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type LowLevelErr struct &#123;</span><br><span class="line">    error</span><br><span class="line">&#125;</span><br><span class="line">func isGloballyExec(path string) (bool, error) &#123;</span><br><span class="line">    info, err := os.Stat(path)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return false, LowLevelErr&#123;(wrapError(err, err.Error()))&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return info.Mode().Perm()&amp;0100 == 0100, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type IntermediateErr struct &#123;</span><br><span class="line">    error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func runJob(id string) error &#123;</span><br><span class="line">    const jobBinPath = &quot;/bad/job/binary&quot;</span><br><span class="line">    isExecutable, err := isGloballyExec(jobBinPath)</span><br><span class="line"></span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return IntermediateErr&#123;wrapError(err, &quot;cannot run job %q: requisite binaries not available&quot;, id)&#125;</span><br><span class="line">    &#125; else if isExecutable == false &#123;</span><br><span class="line">        return wrapError(nil, &quot;job binary is not executable&quot;, id)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return exec.Command(jobBinPath, &quot;--id=&quot;+id).Run()</span><br><span class="line">&#125;</span><br><span class="line">func handleError(key int, err error, message string) &#123;</span><br><span class="line">    log.SetPrefix(fmt.Sprintf(&quot;[logID: %v]: &quot;, key))</span><br><span class="line">    log.Printf(&quot;%#v&quot;, err)</span><br><span class="line">    fmt.Printf(&quot;[%v] %v&quot;, key, message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    log.SetOutput(os.Stdout)</span><br><span class="line">    log.SetFlags(log.Ltime | log.LUTC)</span><br><span class="line">    err := runJob(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        msg := &quot;There was an unexpected issue; please report this as a bug.&quot;</span><br><span class="line">        if _, ok := err.(IntermediateErr); ok &#123;</span><br><span class="line">            msg = err.Error()</span><br><span class="line">        &#125;</span><br><span class="line">        handleError(1, err, msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="超时和取消"><a href="#超时和取消" class="headerlink" title="超时和取消"></a>超时和取消</h2><p>有几个原因使我们需要支持超时：</p>
<ol>
<li>系统饱和：希望超出的请求返回超时，而不是花很长时间等待响应。请求在超时时不太可能重复，或没有资源来存储请求，或者对系统响应或请求发送数据有时效性的要求时，需要超时操作。</li>
<li>陈旧的数据：数据通常有窗口期，如果并发进程处理数据需要的时间比这个窗口期长，则会想返回超时并取消并发进程。可以使用context.WithDeadline或者context.WithTimeout创建的context.Context传递给并发进程。</li>
<li>试图防止死锁：为了防止死锁，建议在所有并发操作中增加超时操作。</li>
</ol>
<h2 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h2><p>有两种不同的心跳：</p>
<ul>
<li>一段时间间隔内发出的心跳</li>
<li>在工作单元开始时发出的心跳</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    doWork := func(</span><br><span class="line">        done &lt;-chan interface&#123;&#125;,</span><br><span class="line">        pulseInterval time.Duration,</span><br><span class="line">    ) (&lt;-chan interface&#123;&#125;, &lt;-chan time.Time) &#123;</span><br><span class="line"></span><br><span class="line">// 建立一个发送心跳的channel，返回给doWork</span><br><span class="line"></span><br><span class="line">        heartbeat := make(chan interface&#123;&#125;)</span><br><span class="line">        results := make(chan time.Time)</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer close(heartbeat)</span><br><span class="line">            defer close(results)</span><br><span class="line"></span><br><span class="line">            pulse := time.Tick(pulseInterval)</span><br><span class="line">            workGen := time.Tick(2 * pulseInterval)</span><br><span class="line">// 设定心跳间隔</span><br><span class="line">            sendPulse := func() &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case heartbeat &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class="line">                default:</span><br><span class="line">                // 可能没有人接收心跳，所以加一个default</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sendResult := func(r time.Time) &#123;</span><br><span class="line">                for &#123;</span><br><span class="line">                    select &#123;</span><br><span class="line">                    case &lt;-done:</span><br><span class="line">                        return</span><br><span class="line">                    case &lt;-pulse:</span><br><span class="line">                        sendPulse()</span><br><span class="line">                    case results &lt;- r:</span><br><span class="line">                        return</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;-done:</span><br><span class="line">                    return</span><br><span class="line">                case &lt;-pulse:</span><br><span class="line">                    sendPulse()</span><br><span class="line">                case r := &lt;-workGen:</span><br><span class="line">                    sendResult(r)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        return heartbeat, results</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done := make(chan interface&#123;&#125;)</span><br><span class="line">    time.AfterFunc(10*time.Second, func() &#123; close(done) &#125;)</span><br><span class="line"></span><br><span class="line">    const timeout = 2 * time.Second</span><br><span class="line">    // 设置了超时时间</span><br><span class="line">    heartbeat, results := doWork(done, timeout/2)</span><br><span class="line">    // timeout/2 使我们的心跳有额外的响应时间</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        // 处理心跳，如果没有消息时，至少timeout/2后会从心跳channel发出一条消息</span><br><span class="line">        case _, ok := &lt;-heartbeat:</span><br><span class="line">            if ok == false &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(&quot;pulse&quot;)</span><br><span class="line">        case r, ok := &lt;-results:</span><br><span class="line">            if ok == false &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(&quot;result %v\n&quot;, r.Second())</span><br><span class="line">        case &lt;-time.After(timeout):</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以下是每个工作单元开始之前发出的心跳<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    doWork := func(</span><br><span class="line">        done &lt;-chan interface&#123;&#125;,</span><br><span class="line">    ) (&lt;-chan interface&#123;&#125;, &lt;-chan int) &#123;</span><br><span class="line">        heartbeatStream := make(chan interface&#123;&#125;, 1)</span><br><span class="line">// 创建一个缓冲区大小为1的heartbeat channel，确保了即使没有及时接收发送消息也能发出一个心跳</span><br><span class="line"></span><br><span class="line">        workStream := make(chan int)</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer close(heartbeatStream)</span><br><span class="line">            defer close(workStream)</span><br><span class="line"></span><br><span class="line">            for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case heartbeatStream &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class="line">                default:</span><br><span class="line">                &#125;</span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;-done:</span><br><span class="line">                    return</span><br><span class="line">                case workStream &lt;- rand.Intn(10):</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">// 这里为心跳设置了单独的select块，将发送result和发送心跳分开，如果接收者没有准备好接受结果，作为替代它将收到一个心跳，而代表当前结果的值将会丢失。</span><br><span class="line">// 为了防止没人接收心跳，增加了default，因为我们的heart channel创建时有一个缓冲区，所以如果有人正在监听暗示没有及时收到第一个心跳，接收者也可以收到心跳。     </span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        return heartbeatStream, workStream</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done := make(chan interface&#123;&#125;)</span><br><span class="line">    defer close(done)</span><br><span class="line"></span><br><span class="line">    heartbeat, results := doWork(done)</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case _, ok := &lt;-heartbeat:</span><br><span class="line">            if ok == false &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fmt.Println(&quot;pulse&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        case r, ok := &lt;-results:</span><br><span class="line">            if ok == false &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fmt.Printf(&quot;result %v\n&quot;, r)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>一些外部因素会导致goroutine花费更长的时间来进行第一次迭代，无论goroutine在调度上是否是第一位执行的。使用goroutine来解决这个问题。</p>
<h2 id="复制请求"><a href="#复制请求" class="headerlink" title="复制请求"></a>复制请求</h2><p>可以将请求分发到多个处理程序，其中一个将比其他处理程序返回更快，可以立即返回结果。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    doWork := func(</span><br><span class="line">        done &lt;-chan interface&#123;&#125;,</span><br><span class="line">        id int,</span><br><span class="line">        wg *sync.WaitGroup,</span><br><span class="line">        result chan&lt;- int,</span><br><span class="line">    ) &#123;</span><br><span class="line">        started := time.Now()</span><br><span class="line">        defer wg.Done()</span><br><span class="line"></span><br><span class="line">        simulatedLoadTime := time.Duration(1+rand.Intn(5)) * time.Second</span><br><span class="line">        select &#123;</span><br><span class="line">        case &lt;-done:</span><br><span class="line">        case &lt;-time.After(simulatedLoadTime):</span><br><span class="line">        &#125;</span><br><span class="line">        select &#123;</span><br><span class="line">        case &lt;-done:</span><br><span class="line">        case result &lt;- id:</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        took := time.Since(started)</span><br><span class="line">        if took &lt; simulatedLoadTime &#123;</span><br><span class="line">            took = simulatedLoadTime</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(&quot;%v took %v.\n&quot;, id, took)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done := make(chan interface&#123;&#125;)</span><br><span class="line">    result := make(chan int)</span><br><span class="line"></span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    wg.Add(10)</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        go doWork(done, i, &amp;wg, result)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    firstReturned := &lt;-result</span><br><span class="line">    close(done)</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;Received an answer from #%v.\n&quot;, firstReturned)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这里我们启动了10个处理程序来处理请求，并获得了第一个返回值，如果得到了第一个返回值，则取消其它的处理程序，以保证不会做多余的工作。</p>
<h2 id="速率限制"><a href="#速率限制" class="headerlink" title="速率限制"></a>速率限制</h2><p>速率限制允许你将系统的性能和稳定性平衡在可控范围内。Go中大多数的限速是基于令牌算法的。</p>
<p>如果要访问资源，必须拥有资源的访问令牌，没有令牌的请求会被拒绝。假设令牌存储在一个等待被检索使用的桶中，桶的深度是d，表示一个桶可以容纳d个访问令牌。</p>
<p>每当需要访问资源时，都会在桶中删除一个令牌，请求必须排队等待直到有令牌可以用，或者被拒绝操作。将r定义为向桶中添加令牌的速率。只要用户拥有可用的令牌，集中的请求可能会使用户突破系统的可用范围。有些用户会间歇性访问系统，但是又想要尽可能快的获得结果，就会出现突发性的事件，只需要确保系统能同时处理所有用户的突发请求，或者在统计上不会有太多用户同时突发访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">func Open() *APIConnection &#123;</span><br><span class="line">    return &amp;APIConnection&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type APIConnection struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (a *APIConnection) ReadFile(ctx context.Context) error &#123;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *APIConnection) ResolveAddress(ctx context.Context) error &#123;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    defer log.Printf(&quot;Done.&quot;)</span><br><span class="line">    log.SetOutput(os.Stdout)</span><br><span class="line">    log.SetFlags(log.Ltime | log.LUTC)</span><br><span class="line"></span><br><span class="line">    apiConnection := Open()</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    wg.Add(20)</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer wg.Done()</span><br><span class="line">            err := apiConnection.ReadFile(context.Background())</span><br><span class="line">            if err != nil &#123;</span><br><span class="line">                log.Printf(&quot;cannot ReadFile: %v&quot;, err)</span><br><span class="line">            &#125;</span><br><span class="line">            log.Printf(&quot;ReadFile&quot;)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer wg.Done()</span><br><span class="line">            err := apiConnection.ResolveAddress(context.Background())</span><br><span class="line">            if err != nil &#123;</span><br><span class="line">                log.Printf(&quot;cannot ResolveAddress: %v&quot;, err)</span><br><span class="line">            &#125;</span><br><span class="line">            log.Printf(&quot;ResolveAddress&quot;)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的API请求同时进行，没有进行限速，所以客户端可以自由访问系统，下面引入限速器，把限速器放在APIConnection中。这里用到了<code>golang.org/x/time/rate</code>包中的令牌桶限速器实现，具体安装如下：</p>
<p><code>golang.org/x</code>包放到了<code>https://github.com/golang/time.git</code>中，下载时需要先在本地建立<code>golang.org/x</code>的目录后，再下载。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p golang.org/x</span><br><span class="line">git clone https://github.com/golang/time.git</span><br></pre></td></tr></table></figure><br>我们使用了这个包的两个部分，分别是Limit类型和NewLimiter函数。Limit表示某个事件的最大频率，每秒事件数；NewLimiter返回一个新的Limit，允许事件速率为r，并允许最大为b的token。</p>
<p>rate包也包含一个辅助方法Every，将时间间隔转换为Limit。针对每次操作的间隔时间进行测量：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Per(eventCount int, duration time.Duration) rate.Limit &#123;</span><br><span class="line">    return rate.Every(duration / time.Duration(eventCount))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>创建rate.Limiter后，使用它来阻塞我们的请求，直到获得访问令牌，使用Wait实现。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (lim *Limiter) Wait(ctx context.Context) </span><br><span class="line">// Wait是WaitN(ctx, 1)的缩写</span><br><span class="line">// WaitN会执行直到有n个事件发生，</span><br><span class="line">// 如果n超过Limiter的突发大小，ctx被取消，或者逾期等待时间超过context的deadline，会返回一个错误</span><br><span class="line"></span><br><span class="line">func (lim *Limiter) WaitN(ctx context.Context, n int) (err error)</span><br></pre></td></tr></table></figure></p>
<p>修改后的APIConnection：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func Open() *APIConnection &#123;</span><br><span class="line">    return &amp;APIConnection&#123;</span><br><span class="line">        rateLimiter: rate.NewLimiter(rate.Limit(1), 1),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type APIConnection struct &#123;</span><br><span class="line">    rateLimiter *rate.Limiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *APIConnection) ReadFile(ctx context.Context) error &#123;</span><br><span class="line">    if err := a.rateLimiter.Wait(ctx); err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *APIConnection) ResolveAddress(ctx context.Context) error &#123;</span><br><span class="line">    if err := a.rateLimiter.Wait(ctx); err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    defer log.Printf(&quot;Done.&quot;)</span><br><span class="line">    log.SetOutput(os.Stdout)</span><br><span class="line">    log.SetFlags(log.Ltime | log.LUTC)</span><br><span class="line"></span><br><span class="line">    apiConnection := Open()</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    wg.Add(20)</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer wg.Done()</span><br><span class="line">            err := apiConnection.ReadFile(context.Background())</span><br><span class="line">            if err != nil &#123;</span><br><span class="line">                log.Printf(&quot;cannot ReadFile: %v&quot;, err)</span><br><span class="line">            &#125;</span><br><span class="line">            log.Printf(&quot;ReadFile&quot;)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer wg.Done()</span><br><span class="line">            err := apiConnection.ResolveAddress(context.Background())</span><br><span class="line">            if err != nil &#123;</span><br><span class="line">                log.Printf(&quot;cannot ResolveAddress: %v&quot;, err)</span><br><span class="line">            &#125;</span><br><span class="line">            log.Printf(&quot;ResolveAddress&quot;)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样实现了所有API连接的速率限制为每秒一次。</p>
<p>聚合限速器：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">type RateLimiter interface &#123;</span><br><span class="line">    Wait(context.Context) error</span><br><span class="line">    Limit() rate.Limit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func MultiLimiter(limiters ...RateLimiter) *multiLimiter &#123;</span><br><span class="line">    byLimit := func(i, j int) bool &#123;</span><br><span class="line">        return limiters[i].Limit() &lt; limiters[j].Limit()</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Slice(limiters, byLimit)</span><br><span class="line">    return &amp;multiLimiter&#123;limiters: limiters&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type multiLimiter struct &#123;</span><br><span class="line">    limiters []RateLimiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (l *multiLimiter) Wait(ctx context.Context) error &#123;</span><br><span class="line">    for _, l := range l.limiters &#123;</span><br><span class="line">        if err := l.Wait(ctx); err != nil &#123;</span><br><span class="line">            return err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (l *multiLimiter) Limit() rate.Limit &#123;</span><br><span class="line">    return l.limiters[0].Limit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义了一个RateLimiter接口，使MultiLimiter可以递归定义其他的MultiLimiter实例，并且实现了一个优化，根据每个RateLimiter的Limit()排序，可以直接返回限制最多的限制器，这将是切片（slice）的第一个元素。</p>
<p>Wait犯法会遍历所有的子限速器，并调用Wait。</p>
<p>可以考虑增加对API请求的限制，对磁盘的限制：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func Open() *APIConnection &#123;</span><br><span class="line">    return &amp;APIConnection&#123;</span><br><span class="line">        apiLimit: MultiLimiter(</span><br><span class="line">            rate.NewLimiter(Per(2, time.Second), 2)</span><br><span class="line">            rate.NewLimiter(Per(10, time.Minute), 10),</span><br><span class="line">            ),</span><br><span class="line">        diskLimit: MultiLimiter(</span><br><span class="line">            rate.NewLimiter(rate.Limit(1), 1)</span><br><span class="line">            ),</span><br><span class="line">        networkLimit: MultiLimiter(</span><br><span class="line">            rate.NewLimiter(Per(3, time.Second), 3),</span><br><span class="line">            ),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *APIConnection) ReadFile(ctx context.Context) error &#123;</span><br><span class="line">    if err := MultiLimiter(a.apiLimit,a.diskLimit).Wait(ctx); err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *APIConnection) ResolveAddress(ctx context.Context) error &#123;</span><br><span class="line">    if err := MultiLimiter(a.apiLimit,a.diskLimit).Wait(ctx); err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>上面为API调用和磁盘读取设置了限速器。</p>
<h2 id="治愈异常的goroutine"><a href="#治愈异常的goroutine" class="headerlink" title="治愈异常的goroutine"></a>治愈异常的goroutine</h2><p>建立一个机制来监控goroutine是否处于健康的状态，当它们变得异常时就可以尽快重启。需要使用心跳模式来检查正在监控的goroutine是否活跃，心跳的类型取决于想要监控的内容，如果goroutine有可能会产生活锁，需要确保心跳包含某些信息，表明goroutine正在工作而不是只是活着。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">type startGoroutineFn func(</span><br><span class="line">    done &lt;-chan interface&#123;&#125;,</span><br><span class="line">    pulseInterval time.Duration,</span><br><span class="line">) (heartbeat &lt;-chan interface&#123;&#125;)</span><br><span class="line">//定义一个可以监控和重启goroutine的信号。</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    newSteward := func(</span><br><span class="line">        timeout time.Duration,</span><br><span class="line">        startGoroutine startGoroutineFn,</span><br><span class="line">    ) startGoroutineFn &#123;</span><br><span class="line">        return func(</span><br><span class="line">            done &lt;-chan interface,</span><br><span class="line">            pulseInterval time.Duration,</span><br><span class="line">// 监控goroutine需要timeout变量，一个函数startGoroutineFn表示管理员本身也是可监控的</span><br><span class="line"></span><br><span class="line">        ) (&lt;-chan interface&#123;&#125;) &#123; </span><br><span class="line">            heartbeat :=make(chan interface&#123;&#125;)</span><br><span class="line">            go func() &#123;</span><br><span class="line">                defer close(heartbeat)</span><br><span class="line">                var wardDone chan interface&#123;&#125;</span><br><span class="line">                var wardHeartbeat &lt;- chan interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">                startWard := func() &#123;</span><br><span class="line">                    wardDone = make(chan interface&#123;&#125;)</span><br><span class="line">                    wardHeartbeat = startGoroutine(or(wardDone, done),timeout/2)</span><br><span class="line">                &#125;</span><br><span class="line">// 定义了一个闭包，实现了统一的方法来启动正在监视的goroutine</span><br><span class="line">// 创建一个新的channel，如果需要发出停止信号则使用它传入goroutine</span><br><span class="line">// 启动将要监控的goroutine，如果管理员被停止或者想要停止goroutine，希望这些信息能传给管理区的goroutine</span><br><span class="line">// 所以使用了逻辑或来包装。</span><br><span class="line"></span><br><span class="line">                startWard()</span><br><span class="line">                pulse := time.Tick(pulseInterval)</span><br><span class="line"></span><br><span class="line">            monitorLoop:</span><br><span class="line">                for &#123;</span><br><span class="line">                    timeoutSignal := time.After(timeout)</span><br><span class="line">                    for &#123;</span><br><span class="line">                        select &#123;</span><br><span class="line">                        case &lt;-pulse:</span><br><span class="line">                            select&#123;</span><br><span class="line">                            case heartbeat &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class="line">                            default:</span><br><span class="line">                            &#125;</span><br><span class="line">                        case &lt;-wardHeartbeat:</span><br><span class="line">                            continue monitorLoop</span><br><span class="line">                        case &lt;-timeoutSignal:</span><br><span class="line">                            log.Println(&quot;steward: ward unhealthy; restarting&quot;)</span><br><span class="line">                            close(wardDone)</span><br><span class="line">                            startWard()</span><br><span class="line">                            continue monitorLoop</span><br><span class="line">                        case &lt;-done:</span><br><span class="line">                            return</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;()</span><br><span class="line">            return heartbeat</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.SetOutput(os.Stdout)</span><br><span class="line">    log.SetFlags(log.Ltime | log.LUTC)</span><br><span class="line"></span><br><span class="line">    doWork := func(done &lt;-chan interface&#123;&#125;, _ time.Duration) &lt;-chan interface&#123;&#125; &#123;</span><br><span class="line">        log.Println(&quot;ward: hello, I&#x27;m irresponsible!&quot;)</span><br><span class="line">        go func()&#123;</span><br><span class="line">            &lt;-done</span><br><span class="line">            log.Println(&quot;ward: I am halting&quot;)</span><br><span class="line">        &#125;()</span><br><span class="line">        retunr nil</span><br><span class="line">    &#125;</span><br><span class="line">    doWorkWithSteward := newSteward(4*time.Second, doWork)</span><br><span class="line">// 超时时间是4s</span><br><span class="line"></span><br><span class="line">    done := make(chan interface&#123;&#125;)</span><br><span class="line">    time.AfterFunc(9*time.Second, func()&#123;</span><br><span class="line">        log.Println(&quot;main: halting steward and ward.&quot;)</span><br><span class="line">        close(done)</span><br><span class="line">    &#125;)</span><br><span class="line">// 9s后停止管理员和goroutine</span><br><span class="line"></span><br><span class="line">    for range doWorkWithSteward(done, 4*time.Second) &#123;&#125;</span><br><span class="line">    log.Println(&quot;done&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>管理区可以使用桥接channel模式向消费者提供公用的channel，避免中断，使用这些技术，管理区可以简单的通过组合各种模式变得任意复杂：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">log.SetOutput(os.Stdout)</span><br><span class="line">log.SetFlags(log.Ltime | log.LUTC)</span><br><span class="line"></span><br><span class="line">done := make(chan interface&#123;&#125;)</span><br><span class="line">defer close(done)</span><br><span class="line"></span><br><span class="line">doWork, intStream := doWorkFn(done, 1, 2, -1, 3, 4, 5)</span><br><span class="line">// 创建管理区函数，允许结束可变整数切片，返回用来返回的流</span><br><span class="line"></span><br><span class="line">doWorkWithSteward := newSteward(1*time.Millisecond, doWork)</span><br><span class="line">// 创建管理员，监听doWork    </span><br><span class="line"></span><br><span class="line">doWorkWithSteward(done, 1*time.Hour)</span><br><span class="line">// 启动管理区并开始监控</span><br><span class="line"></span><br><span class="line">for intVal := range take(done, intStream, 6) &#123;</span><br><span class="line">    fmt.Println(&quot;Received %v.\n&quot;, intVal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Go语言并发之道第6章"><a href="#Go语言并发之道第6章" class="headerlink" title="Go语言并发之道第6章"></a>Go语言并发之道第6章</h1><h2 id="goroutine和Go语言进行时"><a href="#goroutine和Go语言进行时" class="headerlink" title="goroutine和Go语言进行时"></a>goroutine和Go语言进行时</h2><h3 id="工作窃取"><a href="#工作窃取" class="headerlink" title="工作窃取"></a>工作窃取</h3><p>为了确保所有CPU有相同的使用率，可以在所有可用的处理器上平均分配负载。在实际使用过程中，基于朴素策略在处理器上分配任务可能会导致其中一个处理器利用率不足。不仅如此，还可能导致缓存的位置偏差，因为需要调用这些数据的任务跑在其他处理器上。</p>
<p>可以采取：工作任务加入队列中进行调度，处理器在有空闲的时候将任务出队，或者阻塞连接。这样引入了一个集中化的队列，所有的处理器都必须使用这个数据结构，每次想要入队或出队一个任务时继续要将这个队列加载到每个处理器的缓存中。</p>
<p>也可以拆分工作队列，给每个处理器一个独立线程和双端队列。</p>
<p>首先需要强调，Go遵循fork-join模型进行并发，在goroutine开始的时候fork，join点事两个或更多的goroutine通过channel或sync包中的类型进行同步。工作窃取算法对于给定线程：</p>
<ol>
<li>在fork点，将任务添加到与线程相关的双端队列尾部；</li>
<li>如果线程空闲则随机选取一个线程，从它关联的双端队列头部窃取工作；</li>
<li>如果在未准备好的join点则将工作从线程的双端队列尾部出栈；</li>
<li>如果线程的双端队列是空的，则暂停加入或从随机线程关联的双端队列中窃取工作。</li>
</ol>
<p>以下是计算fibonacci数列的程序<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var fib func(n int) &lt;-chan int</span><br><span class="line">    fib = func(n int) &lt;-chan int &#123;</span><br><span class="line">        result := make(chan int)</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer close(result)</span><br><span class="line">            if n &lt;= 2 &#123;</span><br><span class="line">                result &lt;- 1</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            result &lt;- &lt;-fib(n-1) + &lt;-fib(n-2)</span><br><span class="line">        &#125;()</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;fib(4) = %d.\n&quot;, &lt;-fib(4))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先只有一个goroutine，main goroutine，假设在处理器1上；接下来调用fib(4)，这个goroutine被安排在T1的工作队列尾部，并且父goroutine将继续运行；此时根据时机不同，可能会发生T1或T2盗取调用fib(4)的goroutine，如果fib(4)在T1上，则在T1的工作队列上将添加fib(3)和fib(2)。</p>
<p>此时T2仍然是空闲的，所以从T1的队列头部取出fib(3)。此时fib(2)是fib(4)推入队列的最后一个任务，因此T1最有可能需要计算的第一个任务仍然在T1上！与此同时，由于在fib(3)和fib(2)返回的channel上等待着，T1不足以继续处理fib(4)，它会自己从队列中出栈一个fib(2)。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>T1调用栈</th>
<th>T1工作队列</th>
<th>T2调用栈</th>
<th>T2工作队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>(main goroutine)(等待join)</td>
<td></td>
<td>fib(3)</td>
<td></td>
</tr>
<tr>
<td>fib(4)(等待join)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fib(2)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>调用fib(3)的goroutine：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>T1调用栈</th>
<th>T1工作队列</th>
<th>T2调用栈</th>
<th>T2工作队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>(main goroutine)(等待join)</td>
<td></td>
<td>fib(3)</td>
<td>fib(2)</td>
</tr>
<tr>
<td>fib(4)(等待join)</td>
<td></td>
<td></td>
<td>fib(1)</td>
</tr>
<tr>
<td>fib(2)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>T1到达了Fibonacci收敛处，返回1：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>T1调用栈</th>
<th>T1工作队列</th>
<th>T2调用栈</th>
<th>T2工作队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>(main goroutine)(等待join)</td>
<td></td>
<td>fib(3)</td>
<td>fib(2)</td>
</tr>
<tr>
<td>fib(4)(等待join)</td>
<td></td>
<td></td>
<td>fib(1)</td>
</tr>
<tr>
<td>fib(1)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>T2到达了join点，并从其队列的尾部出栈一个任务：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>T1调用栈</th>
<th>T1工作队列</th>
<th>T2调用栈</th>
<th>T2工作队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>(main goroutine)(等待join)</td>
<td></td>
<td>fib(3)(等待join)</td>
<td>fib(2)</td>
</tr>
<tr>
<td>fib(4)(等待join)</td>
<td></td>
<td>fib(1)</td>
<td></td>
</tr>
<tr>
<td>return 1</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>T1又一次处于空闲所以从T2的队列中窃取工作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>T1调用栈</th>
<th>T1工作队列</th>
<th>T2调用栈</th>
<th>T2工作队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>(main goroutine)(等待join)</td>
<td></td>
<td>fib(3)(等待join)</td>
<td></td>
</tr>
<tr>
<td>fib(4)(等待join)</td>
<td></td>
<td>fib(1)</td>
<td></td>
</tr>
<tr>
<td>fib(2)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>T2到达终点返回1：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>T1调用栈</th>
<th>T1工作队列</th>
<th>T2调用栈</th>
<th>T2工作队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>(main goroutine)(等待join)</td>
<td></td>
<td>fib(3)(等待join)</td>
<td></td>
</tr>
<tr>
<td>fib(4)(等待join)</td>
<td></td>
<td>return 1</td>
<td></td>
</tr>
<tr>
<td>fib(2)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>T1到达终点返回1：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>T1调用栈</th>
<th>T1工作队列</th>
<th>T2调用栈</th>
<th>T2工作队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>(main goroutine)(等待join)</td>
<td></td>
<td>fib(3)(等待join)</td>
<td></td>
</tr>
<tr>
<td>fib(4)(等待join)</td>
<td></td>
<td>return 1</td>
<td></td>
</tr>
<tr>
<td>return 1</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>T2对fib(3)的调用现在有两个已完成的join点，fib(2)和fib(1)已经通过channel返回了结果，并且fib(3)产生的两个goroutine已经运行结束。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>T1调用栈</th>
<th>T1工作队列</th>
<th>T2调用栈</th>
<th>T2工作队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>(main goroutine)(等待join)</td>
<td></td>
<td>return 2</td>
<td></td>
</tr>
<tr>
<td>fib(4)(等待join)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>fib(4)调用的goroutine有两个join点，fib(3)和fib(2)，在T2最后一个任务结束时完成了fib(2)的join。执行加法，通过fib(4)的channel返回。</p>
<p>位于队列尾部的任务：</p>
<ol>
<li>最有可能完成父进程join的任务</li>
<li>最有可能存在于处理器缓存中的任务</li>
</ol>
<p>当一个线程到达join时，必须暂停等待回调以窃取任务。</p>
<h2 id="Go中的调度器"><a href="#Go中的调度器" class="headerlink" title="Go中的调度器"></a>Go中的调度器</h2><p>G：goroutine</p>
<p>M：OS线程，在源代码中也称为机器</p>
<p>P：上下文，在源代码中也被称为处理器</p>
<p>在Go的运行时中，首先启动M，然后是P，最后是调度运行G。</p>
<p>正如之前说的，设置GOMAXPROCS可以控制运行时使用多少上下文。默认设置是主机上每个逻辑CPU分配一个上下文。并且总会有足够的系统线程可以用来处理每个上下文。这使运行时可以进行一些重要的优化。</p>
<p>如果一个goroutine被阻塞，管理goroutine的系统线程也会被阻塞，并且无法继续执行或切换到其他的goroutine。从性能上，Go会进行更多的处理以尽可能让机器上的处理器保持活跃，Go会从系统线程分离上下文，将上下文切换到另一个无阻塞的系统线程上。当goroutine阻塞最终结束时，主机系统线程会尝试使用一个其他系统线程来回退上下文，以便它可以继续执行先前被阻塞的goroutine。或者把它的goroutine放在全局上下文中然后线程进入休眠状态，并将其放入运行时的线程池以供将来使用。</p>
<h2 id="竞争检测"><a href="#竞争检测" class="headerlink" title="竞争检测"></a>竞争检测</h2><p>在Go中为大多数命令增加了race参数。</p>
<p>竞争检测器可以自动检测代码中的竞态条件。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var data int</span><br><span class="line">    go func() &#123;</span><br><span class="line">        data++</span><br><span class="line">    &#125;()</span><br><span class="line">    if data == 0 &#123;</span><br><span class="line">        fmt.Printf(&quot;the value is %d.\n&quot;, data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>执行<code>go run -race test19.go</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">the value is 0.</span><br><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Write at 0x00c0000200c8 by goroutine 6:</span><br><span class="line">  main.main.func1()</span><br><span class="line">      /home/yuhao/tool/go/test/test19.go:8 +0x4e</span><br><span class="line"></span><br><span class="line">Previous read at 0x00c0000200c8 by main goroutine:</span><br><span class="line">  main.main()</span><br><span class="line">      /home/yuhao/tool/go/test/test19.go:10 +0x88</span><br><span class="line"></span><br><span class="line">Goroutine 6 (running) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      /home/yuhao/tool/go/test/test19.go:7 +0x7a</span><br><span class="line">==================</span><br><span class="line">Found 1 data race(s)</span><br><span class="line">exit status 66</span><br></pre></td></tr></table></figure><br>分别表示goroutine试图进行非同步内存写入，或者试图读取相同的内存。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/28/cpp%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/28/cpp%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">C++模板元编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-28 23:54:31" itemprop="dateCreated datePublished" datetime="2019-05-28T23:54:31+08:00">2019-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-26 15:33:08" itemprop="dateModified" datetime="2022-12-26T15:33:08+08:00">2022-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<a href="http://blog.jobbole.com/83461/">http://blog.jobbole.com/83461/</a></p>
<p>所谓元编程就是编写直接生成或操纵程序的程序，C++ 模板给 C++ 语言提供了元编程的能力，模板使 C++ 编程变得异常灵活，能实现很多高级动态语言才有的特性（语法上可能比较丑陋，一些历史原因见下文）。普通用户对 C++ 模板的使用可能不是很频繁，大致限于泛型编程，但一些系统级的代码，尤其是对通用性、性能要求极高的基础库（如 STL、Boost）几乎不可避免的都大量地使用 C++ 模板，一个稍有规模的大量使用模板的程序，不可避免的要涉及元编程（如类型计算）。本文就是要剖析 C++ 模板元编程的机制。</p>
<h1 id="C-模板的语法"><a href="#C-模板的语法" class="headerlink" title="C++模板的语法"></a>C++模板的语法</h1><p>函数模板（function template）和类模板（class template）的简单示例如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">// 函数模板</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">bool equivalent(const T&amp; a, const T&amp; b)&#123;</span><br><span class="line">    return !(a &lt; b) &amp;&amp; !(b &lt; a);</span><br><span class="line">&#125;</span><br><span class="line">// 类模板</span><br><span class="line">template&lt;typename T=int&gt; // 默认参数</span><br><span class="line">class bignumber&#123;</span><br><span class="line">    T _v;</span><br><span class="line">public:</span><br><span class="line">    bignumber(T a) : _v(a) &#123; &#125;</span><br><span class="line">    inline bool operator&lt;(const bignumber&amp; b) const; // 等价于 (const bignumber&lt;T&gt; b)</span><br><span class="line">&#125;;</span><br><span class="line">// 在类模板外实现成员函数</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">bool bignumber&lt;T&gt;::operator&lt;(const bignumber&amp; b) const&#123;</span><br><span class="line">    return _v &lt; b._v;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    bignumber&lt;&gt; a(1), b(1); // 使用默认参数，&quot;&lt;&gt;&quot;不能省略</span><br><span class="line">    std::cout &lt;&lt; equivalent(a, b) &lt;&lt; &#x27;\n&#x27;; // 函数模板参数自动推导</span><br><span class="line">    std::cout &lt;&lt; equivalent&lt;double&gt;(1, 2) &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    std::cin.get();    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>程序输出如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><br>关于模板（函数模板、类模板）的模板参数：</p>
<ul>
<li>类型参数（type template parameter），用 typename 或 class 标记；</li>
<li>非类型参数（non-type template parameter）可以是：整数及枚举类型、对象或函数的指针、对象或函数的引用、对象的成员指针，非类型参数是模板实例的常量；</li>
<li>模板型参数（template template parameter），如<code>template&lt;typename T, template&lt;typename&gt; class A&gt; someclass &#123;&#125;;</code>；</li>
<li>模板参数可以有默认值（函数模板参数默认是从 C++11 开始支持）；</li>
<li>函数模板的和函数参数类型有关的模板参数可以自动推导，类模板参数不存在推导机制；</li>
</ul>
<p>模板特例化（template specialization，又称特例、特化）的简单示例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个向量类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vec</span>&#123;</span><br><span class="line">    T _v[N];</span><br><span class="line">    <span class="comment">// ... // 模板通例（primary template），具体实现</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vec</span>&lt;<span class="type">float</span>, <span class="number">4</span>&gt;&#123;</span><br><span class="line">    <span class="type">float</span> _v[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">// ... // 对 Vec&lt;float, 4&gt; 进行专门实现，如利用向量指令进行加速</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vec</span>&lt;<span class="type">bool</span>, N&gt;&#123;</span><br><span class="line">    <span class="type">char</span> _v[(N+<span class="built_in">sizeof</span>(<span class="type">char</span>)<span class="number">-1</span>)/<span class="built_in">sizeof</span>(<span class="type">char</span>)];</span><br><span class="line">    <span class="comment">// ... // 对 Vec&lt;bool, N&gt; 进行专门实现，如用一个比特位表示一个bool</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vec</span>&#123;</span><br><span class="line">    T _v[N];</span><br><span class="line">    <span class="comment">// ... // 模板通例（primary template），具体实现</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vec</span>&lt;<span class="type">float</span>, <span class="number">4</span>&gt;&#123;</span><br><span class="line">    <span class="type">float</span> _v[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">// ... // 对 Vec&lt;float, 4&gt; 进行专门实现，如利用向量指令进行加速</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vec</span>&lt;<span class="type">bool</span>, N&gt;&#123;</span><br><span class="line">    <span class="type">char</span> _v[(N+<span class="built_in">sizeof</span>(<span class="type">char</span>)<span class="number">-1</span>)/<span class="built_in">sizeof</span>(<span class="type">char</span>)];</span><br><span class="line">    <span class="comment">// ... // 对 Vec&lt;bool, N&gt; 进行专门实现，如用一个比特位表示一个bool</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>所谓模板特例化即对于通例中的某种或某些情况做单独专门实现，最简单的情况是对每个模板参数指定一个具体值，这成为完全特例化（full specialization），另外，可以限制模板参数在一个范围取值或满足一定关系等，这称为部分特例化（partial specialization），用数学上集合的概念，通例模板参数所有可取的值组合构成全集U，完全特例化对U中某个元素进行专门定义，部分特例化对U的某个真子集进行专门定义。</p>
<p>更多模板特例化的例子如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> i&gt; <span class="keyword">class</span> <span class="title class_">cp00</span>; <span class="comment">// 用于模板型模板参数</span></span><br><span class="line"><span class="comment">// 通例</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="type">int</span> i, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="type">int</span>&gt; <span class="keyword">class</span> <span class="title class_">CP</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TMP</span>;</span><br><span class="line"><span class="comment">// 完全特例化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TMP</span>&lt;<span class="type">int</span>, <span class="type">float</span>, <span class="number">2</span>, cp00&gt;;</span><br><span class="line"><span class="comment">// 第一个参数有const修饰</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="type">int</span> i, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="type">int</span>&gt; <span class="keyword">class</span> <span class="title class_">CP</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TMP</span>&lt;<span class="type">const</span> T1, T2, i, CP&gt;;</span><br><span class="line"><span class="comment">// 第一二个参数为cp00的实例且满足一定关系，第四个参数为cp00</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> i&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TMP</span>&lt;cp00&lt;T, i&gt;, cp00&lt;T, i<span class="number">+10</span>&gt;, i, cp00&gt;;</span><br><span class="line"><span class="comment">// 编译错误!，第四个参数类型和通例类型不一致</span></span><br><span class="line"><span class="comment">//template&lt;template&lt;int i&gt; CP&gt;</span></span><br><span class="line"><span class="comment">//class TMP&lt;int, float, 10, CP&gt;;</span></span><br></pre></td></tr></table></figure><br>关于模板特例化：</p>
<ul>
<li>在定义模板特例之前必须已经有模板通例（primary template）的声明；</li>
<li>模板特例并不要求一定与通例有相同的接口，但为了方便使用（体会特例的语义）一般都相同；</li>
<li>匹配规则，在模板实例化时如果有模板通例、特例加起来多个模板版本可以匹配，则依据如下规则：对版本AB，如果 A 的模板参数取值集合是B的真子集，则优先匹配 A，如果 AB 的模板参数取值集合是“交叉”关系（AB 交集不为空，且不为包含关系），则发生编译错误，对于函数模板，用函数重载分辨（overload resolution）规则和上述规则结合并优先匹配非模板函数。</li>
</ul>
<p>对模板的多个实例，类型等价（type equivalence）判断规则：同一个模板（模板名及其参数类型列表构成的模板签名（template signature）相同，函数模板可以重载，类模板不存在重载）且指定的模板实参等价（类型参数是等价类型，非类型参数值相同）。如下例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 识别两个类型是否相同，提前进入模板元编程^_^</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="comment">// 通例，返回 false</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">theSameType</span>       &#123; <span class="keyword">public</span>: <span class="keyword">enum</span> &#123; ret = <span class="literal">false</span> &#125;; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;               <span class="comment">// 特例，两类型相同时返回 true</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">theSameType</span>&lt;T, T&gt; &#123; <span class="keyword">public</span>: <span class="keyword">enum</span> &#123; ret = <span class="literal">true</span> &#125;; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> i&gt; <span class="keyword">class</span> <span class="title class_">aTMP</span> &#123; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint; <span class="comment">// typedef 定义类型别名而不是引入新类型</span></span><br><span class="line">    <span class="keyword">typedef</span> uint uint2;</span><br><span class="line">    std::cout &lt;&lt; theSameType&lt;<span class="type">unsigned</span>, uint2&gt;::ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">// 感谢 C++11，连续角括号“&gt;&gt;”不会被当做流输入符号而编译错误</span></span><br><span class="line">    std::cout &lt;&lt; theSameType&lt;aTMP&lt;<span class="type">unsigned</span>, <span class="number">2</span>&gt;, aTMP&lt;uint2, <span class="number">2</span>&gt;&gt;::ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; theSameType&lt;aTMP&lt;<span class="type">int</span>, <span class="number">2</span>&gt;, aTMP&lt;<span class="type">int</span>, <span class="number">3</span>&gt;&gt;::ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><br>关于模板实例化（template instantiation）：</p>
<ul>
<li>指在编译或链接时生成函数模板或类模板的具体实例源代码，即用使用模板时的实参类型替换模板类型参数（还有非类型参数和模板型参数）；</li>
<li>隐式实例化（implicit instantiation）：当使用实例化的模板时自动地在当前代码单元之前插入模板的实例化代码，模板的成员函数一直到引用时才被实例化；</li>
<li>显式实例化（explicit instantiation）：直接声明模板实例化，模板所有成员立即都被实例化；</li>
<li>实例化也是一种特例化，被称为实例化的特例（instantiated (or generated) specialization）。</li>
</ul>
<p>隐式实例化时，成员只有被引用到才会进行实例化，这被称为推迟实例化（lazy instantiation），由此可能带来的问题如下面的例子（文献[6]，文献[7]）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">aTMP</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;f1()\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; std::ccccout &lt;&lt; <span class="string">&quot;f2()\n&quot;</span>; &#125; <span class="comment">// 敲错键盘了，语义错误：没有 std::ccccout</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    aTMP&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    a.<span class="built_in">f1</span>();</span><br><span class="line">    <span class="comment">// a.f2(); // 这句代码被注释时，aTMP&lt;int&gt;::f2() 不被实例化，从而上面的错误被掩盖!</span></span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以模板代码写完后最好写个诸如显示实例化的测试代码，更深入一些，可以插入一些模板调用代码使得编译器及时发现错误，而不至于报出无限长的错误信息。另一个例子如下（GCC 4.8 下编译的输出信息，VS2013 编译输出了 500 多行错误信息）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 计算 N 的阶乘 N!</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">aTMP</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; ret = N==<span class="number">0</span> ? <span class="number">1</span> : N * aTMP&lt;N<span class="number">-1</span>&gt;::ret &#125;; <span class="comment">// Lazy Instantiation，将产生无限递归!</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; aTMP&lt;<span class="number">10</span>&gt;::ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sh-4.2# g++ -std=c++11 -o main *.cpp</span><br><span class="line">main.cpp:7:28: error: template instantiation depth exceeds maximum of 900 (use -ftemplate-depth= to increase the maximum) instantiating &#x27;class aTMP&lt;-890&gt;&#x27;</span><br><span class="line">  enum &#123; ret = N==0 ? 1 : N * aTMP&lt;N-1&gt;::ret &#125;;</span><br><span class="line">                            ^</span><br><span class="line">main.cpp:7:28:   recursively required from &#x27;class aTMP&lt;9&gt;&#x27;</span><br><span class="line">main.cpp:7:28:   required from &#x27;class aTMP&lt;10&gt;&#x27;</span><br><span class="line">main.cpp:11:23:   required from here</span><br><span class="line"> </span><br><span class="line">main.cpp:7:28: error: incomplete type &#x27;aTMP&lt;-890&gt;&#x27; used in nested name specifier</span><br></pre></td></tr></table></figure><br>上面的错误是因为，当编译<code>aTMP&lt;N&gt;</code>时，并不判断 N==0，而仅仅知道其依赖 aTMP<N-1>（lazy instantiation），从而产生无限递归，纠正方法是使用模板特例化，如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 计算 N 的阶乘 N!</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">aTMP</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; ret = N * aTMP&lt;N<span class="number">-1</span>&gt;::ret &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">aTMP</span>&lt;<span class="number">0</span>&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; ret = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; aTMP&lt;<span class="number">10</span>&gt;::ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3228800</span><br></pre></td></tr></table></figure></p>
<p>关于模板的编译和链接：</p>
<ul>
<li>包含模板编译模式：编译器生成每个编译单元中遇到的所有的模板实例，并存放在相应的目标文件中；链接器合并等价的模板实例，生成可执行文件，要求实例化时模板定义可见，不能使用系统链接器；</li>
<li>分离模板编译模式（使用 export 关键字）：不重复生成模板实例，编译器设计要求高，可以使用系统链接器；</li>
<li>包含编译模式是主流，C++11 已经弃用 export 关键字（对模板引入 extern 新用法），一般将模板的全部实现代码放在同一个头文件中并在用到模板的地方用 #include 包含头文件，以防止出现实例不一致（如下面紧接着例子）；</li>
</ul>
<p>实例化，编译链接的简单例子如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: a.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">template</span> MyClass&lt;<span class="type">double</span>&gt;::<span class="built_in">MyClass</span>(); <span class="comment">// 显示实例化构造函数 MyClass&lt;double&gt;::MyClass()</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">long</span>&gt;;        <span class="comment">// 显示实例化整个类 MyClass&lt;long&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T <span class="type">const</span>&amp; m)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;a.cpp: &quot;</span> &lt;&lt; m &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>);   <span class="comment">// print&lt;int&gt;，隐式实例化</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0.1</span>); <span class="comment">// print&lt;double&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fb</span><span class="params">()</span></span>; <span class="comment">// fb() 在 b.cpp 中定义，此处声明</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fa</span>();</span><br><span class="line">    <span class="built_in">fb</span>();</span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// file: b.cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void print(T const&amp; m) &#123; std::cout &lt;&lt; &quot;b.cpp: &quot; &lt;&lt; m &lt;&lt; &#x27;\n&#x27;; &#125;</span><br><span class="line"></span><br><span class="line">void fb() &#123;</span><br><span class="line">    print(&#x27;2&#x27;); // print&lt;char&gt;</span><br><span class="line">    print(0.1); // print&lt;double&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.cpp: 1</span><br><span class="line">a.cpp: 0.1</span><br><span class="line">b.cpp: 2</span><br><span class="line">a.cpp: 0.1</span><br></pre></td></tr></table></figure><br>上例中，由于 a.cpp 和 b.cpp 中的 print<double> 实例等价（模板实例的二进制代码在编译生成的对象文件 a.obj、b.obj 中），故链接时消除了一个（消除哪个没有规定，上面消除了 b.cpp 中的）。</p>
<p>关于 template、typename、this 关键字的使用：</p>
<ul>
<li>依赖于模板参数（template parameter，形式参数，实参英文为 argument）的名字被称为依赖名字（dependent name），C++标准规定，如果解析器在一个模板中遇到一个嵌套依赖名字，它假定那个名字不是一个类型，除非显式用 typename 关键字前置修饰该名字；</li>
<li>和上一条 typename 用法类似，template 用于指明嵌套类型或函数为模板；<br>this 用于指定查找基类中的成员（当基类是依赖模板参数的类模板实例时，由于实例化总是推迟，这时不依赖模板参数的名字不在基类中查找）。</li>
</ul>
<p>一个例子如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">aTMP</span>&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="keyword">typedef</span> <span class="type">const</span> T reType;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;global f()\n&quot;</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="type">int</span> N = <span class="number">99</span>&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">f</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;member f(): &quot;</span> &lt;&lt; N &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typename</span> T::reType m; <span class="comment">// typename 不能省略</span></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="keyword">typename</span> T::reType a) : <span class="built_in">m</span>(a) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">df1</span><span class="params">()</span> </span>&#123; <span class="built_in">f</span>(); &#125;                       <span class="comment">// 调用全局 f()，而非想象中的基类 f()</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">df2</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;<span class="function"><span class="keyword">template</span> <span class="title">f</span><span class="params">()</span></span>; &#125;        <span class="comment">// 基类 f&lt;99&gt;()</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">df3</span><span class="params">()</span> </span>&#123; Base&lt;T&gt;::<span class="keyword">template</span> <span class="built_in">f</span>&lt;<span class="number">22</span>&gt;(); &#125; <span class="comment">// 强制基类 f&lt;22&gt;()</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">df4</span><span class="params">()</span> </span>&#123; ::<span class="built_in">f</span>(); &#125;                     <span class="comment">// 强制全局 f()</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Derived&lt;aTMP&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(<span class="number">10</span>);</span><br><span class="line">    a.<span class="built_in">df1</span>(); a.<span class="built_in">df2</span>(); a.<span class="built_in">df3</span>(); a.<span class="built_in">df4</span>();</span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">global f()</span><br><span class="line">member f(): 99</span><br><span class="line">member f(): 22</span><br><span class="line">global f()</span><br></pre></td></tr></table></figure></p>
<p>C++11 关于模板的新特性：</p>
<ul>
<li>“&gt;&gt;” 根据上下文自动识别正确语义；</li>
<li>函数模板参数默认值；</li>
<li>变长模板参数（扩展 sizeof…() 获取参数个数）；</li>
<li>模板别名（扩展 using 关键字）；</li>
<li>外部模板实例（拓展 extern 关键字），弃用 export template。</li>
</ul>
<p>在本文中，如无特别声明将不使用 C++11 的特性（除了 “&gt;&gt;”）。</p>
<h1 id="模板元编程概述"><a href="#模板元编程概述" class="headerlink" title="模板元编程概述"></a>模板元编程概述</h1><p>如果对 C++ 模板不熟悉（光熟悉语法还不算熟悉），可以先跳过本节，往下看完例子再回来。</p>
<p>C++ 模板最初是为实现泛型编程设计的，但人们发现模板的能力远远不止于那些设计的功能。一个重要的理论结论就是：C++ 模板是图灵完备的（Turing-complete），其证明过程请见文献[8]（就是用 C++ 模板模拟图灵机），理论上说 C++ 模板可以执行任何计算任务，但实际上因为模板是编译期计算，其能力受到具体编译器实现的限制（如递归嵌套深度，C++11 要求至少 1024，C++98 要求至少 17）。C++ 模板元编程是“意外”功能，而不是设计的功能，这也是 C++ 模板元编程语法丑陋的根源。</p>
<p>C++ 模板是图灵完备的，这使得 C++ 成为两层次语言（two-level languages，中文暂且这么翻译，文献[9]），其中，执行编译计算的代码称为静态代码（static code），执行运行期计算的代码称为动态代码（dynamic code），C++ 的静态代码由模板实现（预处理的宏也算是能进行部分静态计算吧，也就是能进行部分元编程，称为宏元编程，见 Boost 元编程库即 BCCL，文献[16]和文献[1] 10.4）。</p>
<p>具体来说 C++ 模板可以做以下事情：编译期数值计算、类型计算、代码计算（如循环展开），其中数值计算实际不太有意义，而类型计算和代码计算可以使得代码更加通用，更加易用，性能更好（也更难阅读，更难调试，有时也会有代码膨胀问题）。编译期计算在编译过程中的位置请见下图（取自文献[10]），可以看到关键是模板的机制在编译具体代码（模板实例）前执行：</p>
<h2 id="C-模板元编程"><a href="#C-模板元编程" class="headerlink" title="C++ 模板元编程"></a>C++ 模板元编程</h2><p>从编程范型（programming paradigm）上来说，C++ 模板是函数式编程（functional programming），它的主要特点是：函数调用不产生任何副作用（没有可变的存储），用递归形式实现循环结构的功能。C++ 模板的特例化提供了条件判断能力，而模板递归嵌套提供了循环的能力，这两点使得其具有和普通语言一样通用的能力（图灵完备性）。</p>
<p>从编程形式来看，模板的“&lt;&gt;”中的模板参数相当于函数调用的输入参数，模板中的 typedef 或 static const 或 enum 定义函数返回值（类型或数值，数值仅支持整型，如果需要可以通过编码计算浮点数），代码计算是通过类型计算进而选择类型的函数实现的（C++ 属于静态类型语言，编译器对类型的操控能力很强）。代码示意如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> i=<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">class</span> someComputing &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">volatile</span> T* retType; <span class="comment">// 类型计算</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; retValume = i + someComputing&lt;T, i<span class="number">-1</span>&gt;::retValume &#125;; <span class="comment">// 数值计算，递归</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;someComputing: i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 模板特例，递归终止条件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">someComputing</span>&lt;T, <span class="number">0</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; retValume = <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">codeComputing</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; T::<span class="built_in">f</span>(); &#125; <span class="comment">// 根据类型调用函数，代码计算</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    someComputing&lt;<span class="type">int</span>&gt;::retType a=<span class="number">0</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 64-bit 程序指针</span></span><br><span class="line">    <span class="comment">// VS2013 默认最大递归深度500，GCC4.8 默认最大递归深度900（-ftemplate-depth=n）</span></span><br><span class="line">    std::cout &lt;&lt; someComputing&lt;<span class="type">int</span>, <span class="number">500</span>&gt;::retValume &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 1+2+...+500</span></span><br><span class="line">    codeComputing&lt;someComputing&lt;<span class="type">int</span>, <span class="number">99</span>&gt;&gt;::<span class="built_in">f</span>();</span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">125250</span><br><span class="line">someComputing: i=99</span><br></pre></td></tr></table></figure></p>
<h2 id="编译期数值计算"><a href="#编译期数值计算" class="headerlink" title="编译期数值计算"></a>编译期数值计算</h2><p>第一个 C++ 模板元程序是 Erwin Unruh 在 1994 年写的（文献[14]），这个程序计算小于给定数 N 的全部素数（又叫质数），程序并不运行（都不能通过编译），而是让编译器在错误信息中显示结果（直观展现了是编译期计算结果，C++ 模板元编程不是设计的功能，更像是在戏弄编译器，当然 C++11 有所改变），由于年代久远，原来的程序用现在的编译器已经不能编译了，下面的代码在原来程序基础上稍作了修改（GCC 4.8 下使用 -fpermissvie，只显示警告信息）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prime number computation by Erwin Unruh</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> i&gt; <span class="keyword">struct</span> <span class="title class_">D</span> &#123; <span class="built_in">D</span>(<span class="type">void</span>*); <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>; &#125;; <span class="comment">// 构造函数参数为 void* 指针</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> p, <span class="type">int</span> i&gt; <span class="keyword">struct</span> <span class="title class_">is_prime</span> &#123; <span class="comment">// 判断 p 是否为素数，即 p 不能整除 2...p-1</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; prim = (p%i) &amp;&amp; is_prime&lt;(i&gt;<span class="number">2</span>?p:<span class="number">0</span>), i<span class="number">-1</span>&gt;::prim &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_prime</span>&lt;<span class="number">0</span>, <span class="number">0</span>&gt; &#123; <span class="keyword">enum</span> &#123; prim = <span class="number">1</span> &#125;; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_prime</span>&lt;<span class="number">0</span>, <span class="number">1</span>&gt; &#123; <span class="keyword">enum</span> &#123; prim = <span class="number">1</span> &#125;; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> i&gt; <span class="keyword">struct</span> <span class="title class_">Prime_print</span> &#123;</span><br><span class="line">    Prime_print&lt;i<span class="number">-1</span>&gt; a;</span><br><span class="line">    <span class="keyword">enum</span> &#123; prim = is_prime&lt;i, i<span class="number">-1</span>&gt;::prim &#125;;</span><br><span class="line">    <span class="comment">// prim 为真时， prim?1:0 为 1，int 到 D&lt;i&gt; 转换报错；假时， 0 为 NULL 指针不报错</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; D&lt;i&gt; d = prim?<span class="number">1</span>:<span class="number">0</span>; a.<span class="built_in">f</span>(); &#125; <span class="comment">// 调用 a.f() 实例化 Prime_print&lt;i-1&gt;::f()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">Prime_print</span>&lt;<span class="number">2</span>&gt; &#123; <span class="comment">// 特例，递归终止</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; prim = <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; D&lt;<span class="number">2</span>&gt; d = prim?<span class="number">1</span>:<span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LAST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Prime_print&lt;LAST&gt; a; a.<span class="built_in">f</span>(); <span class="comment">// 必须调用 a.f() 以实例化 Prime_print&lt;LAST&gt;::f()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">sh-4.2# g++ -std=c++11 -fpermissive -o main *.cpp</span><br><span class="line">main.cpp: In member function &#x27;void Prime_print&lt;2&gt;::f()&#x27;:</span><br><span class="line">main.cpp:17:33: warning: invalid conversion from &#x27;int&#x27; to &#x27;void*&#x27; [-fpermissive]</span><br><span class="line">  void f() &#123; D&lt;2&gt; d = prim ? 1 : 0; &#125;</span><br><span class="line">                                 ^</span><br><span class="line">main.cpp:2:28: warning:   initializing argument 1 of &#x27;D&lt;i&gt;::D(void*) [with int i = 2]&#x27; [-fpermissive]</span><br><span class="line"> template&lt;int i&gt; struct D &#123; D(void*); operator int(); &#125;;</span><br><span class="line">                            ^</span><br><span class="line">main.cpp: In instantiation of &#x27;void Prime_print&lt;i&gt;::f() [with int i = 7]&#x27;:</span><br><span class="line">main.cpp:13:36:   recursively required from &#x27;void Prime_print&lt;i&gt;::f() [with int i = 9]&#x27;</span><br><span class="line">main.cpp:13:36:   required from &#x27;void Prime_print&lt;i&gt;::f() [with int i = 10]&#x27;</span><br><span class="line">main.cpp:25:27:   required from here</span><br><span class="line">main.cpp:13:33: warning: invalid conversion from &#x27;int&#x27; to &#x27;void*&#x27; [-fpermissive]</span><br><span class="line">  void f() &#123; D&lt;i&gt; d = prim ? 1 : 0; a.f(); &#125;</span><br><span class="line">                                 ^</span><br><span class="line">main.cpp:2:28: warning:   initializing argument 1 of &#x27;D&lt;i&gt;::D(void*) [with int i = 7]&#x27; [-fpermissive]</span><br><span class="line"> template&lt;int i&gt; struct D &#123; D(void*); operator int(); &#125;;</span><br><span class="line">                            ^</span><br><span class="line">main.cpp: In instantiation of &#x27;void Prime_print&lt;i&gt;::f() [with int i = 5]&#x27;:</span><br><span class="line">main.cpp:13:36:   recursively required from &#x27;void Prime_print&lt;i&gt;::f() [with int i = 9]&#x27;</span><br><span class="line">main.cpp:13:36:   required from &#x27;void Prime_print&lt;i&gt;::f() [with int i = 10]&#x27;</span><br><span class="line">main.cpp:25:27:   required from here</span><br><span class="line">main.cpp:13:33: warning: invalid conversion from &#x27;int&#x27; to &#x27;void*&#x27; [-fpermissive]</span><br><span class="line">  void f() &#123; D&lt;i&gt; d = prim ? 1 : 0; a.f(); &#125;</span><br><span class="line">                                 ^</span><br><span class="line">main.cpp:2:28: warning:   initializing argument 1 of &#x27;D&lt;i&gt;::D(void*) [with int i = 5]&#x27; [-fpermissive]</span><br><span class="line"> template&lt;int i&gt; struct D &#123; D(void*); operator int(); &#125;;</span><br><span class="line">                            ^</span><br><span class="line">main.cpp: In instantiation of &#x27;void Prime_print&lt;i&gt;::f() [with int i = 3]&#x27;:</span><br><span class="line">main.cpp:13:36:   recursively required from &#x27;void Prime_print&lt;i&gt;::f() [with int i = 9]&#x27;</span><br><span class="line">main.cpp:13:36:   required from &#x27;void Prime_print&lt;i&gt;::f() [with int i = 10]&#x27;</span><br><span class="line">main.cpp:25:27:   required from here</span><br><span class="line">main.cpp:13:33: warning: invalid conversion from &#x27;int&#x27; to &#x27;void*&#x27; [-fpermissive]</span><br><span class="line">  void f() &#123; D&lt;i&gt; d = prim ? 1 : 0; a.f(); &#125;</span><br><span class="line">                                 ^</span><br><span class="line">main.cpp:2:28: warning:   initializing argument 1 of &#x27;D&lt;i&gt;::D(void*) [with int i = 3]&#x27; [-fpermissive]</span><br><span class="line"> template&lt;int i&gt; struct D &#123; D(void*); operator int(); &#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的编译输出信息只给出了前一部分，虽然信息很杂，但还是可以看到其中有 10 以内全部素数：2、3、5、7（已经加粗显示关键行）。</p>
<p>到目前为止，虽然已经看到了阶乘、求和等递归数值计算，但都没涉及原理，下面以求和为例讲解 C++ 模板编译期数值计算的原理：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sumt</span>&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> ret = sumt&lt;N<span class="number">-1</span>&gt;::ret + N;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sumt</span>&lt;<span class="number">0</span>&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; sumt&lt;<span class="number">5</span>&gt;::ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure></p>
<p>当编译器遇到<code>sumt&lt;5&gt;</code>时，试图实例化之，<code>sumt&lt;5&gt;</code>引用了<code>sumt&lt;5-1&gt;</code>即<code>sumt&lt;4&gt;</code>，试图实例化<code>sumt&lt;4&gt;</code>，以此类推，直到<code>sumt&lt;0&gt;</code>，<code>sumt&lt;0&gt;</code>匹配模板特例，<code>sumt&lt;0&gt;::ret</code>为 0，<code>sumt&lt;1&gt;::ret</code>为<code>sumt&lt;0&gt;::ret+1</code>为 1，以此类推，<code>sumt&lt;5&gt;::ret</code>为 15。值得一提的是，虽然对用户来说程序只是输出了一个编译期常量<code>sumt&lt;5&gt;::ret</code>，但在背后，编译器其实至少处理了<code>sumt&lt;0&gt;</code>到<code>sumt&lt;5&gt;</code>共 6 个类型。</p>
<p>从这个例子我们也可以窥探 C++ 模板元编程的函数式编程范型，对比结构化求和程序：for(i=0,sum=0; i&lt;=N; ++i) sum+=i; 用逐步改变存储（即变量 sum）的方式来对计算过程进行编程，模板元程序没有可变的存储（都是编译期常量，是不可变的变量），要表达求和过程就要用很多个常量：sumt<0>::ret，sumt<1>::ret，…，sumt<5>::ret 。函数式编程看上去似乎效率低下（因为它和数学接近，而不是和硬件工作方式接近），但有自己的优势：描述问题更加简洁清晰（前提是熟悉这种方式），没有可变的变量就没有数据依赖，方便进行并行化。</p>
<h2 id="模板下的控制结构"><a href="#模板下的控制结构" class="headerlink" title="模板下的控制结构"></a>模板下的控制结构</h2><p>模板实现的条件 if 和 while 语句如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通例为空，若不匹配特例将报错，很好的调试手段（这里是 bool 就无所谓了）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> c, <span class="keyword">typename</span> Then, <span class="keyword">typename</span> Else&gt; <span class="keyword">class</span> <span class="title class_">IF_</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Then, <span class="keyword">typename</span> Else&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IF_</span>&lt;<span class="literal">true</span>, Then, Else&gt; &#123; <span class="keyword">public</span>: <span class="keyword">typedef</span> Then reType; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Then, <span class="keyword">typename</span> Else&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IF_</span>&lt;<span class="literal">false</span>,Then, Else&gt; &#123; <span class="keyword">public</span>: <span class="keyword">typedef</span> Else reType; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 隐含要求： Condition 返回值 ret，Statement 有类型 Next</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Condition</span>, <span class="keyword">typename</span> Statement&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WHILE_</span> &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Statement&gt; <span class="keyword">class</span> <span class="title class_">STOP</span> &#123; <span class="keyword">public</span>: <span class="keyword">typedef</span> Statement reType; &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span></span><br><span class="line">        IF_&lt;Condition&lt;Statement&gt;::ret,</span><br><span class="line">        WHILE_&lt;Condition, <span class="keyword">typename</span> Statement::Next&gt;,</span><br><span class="line">        STOP&lt;Statement&gt;&gt;::reType::reType</span><br><span class="line">    reType;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>IF_&lt;&gt; 的使用示例见下面：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> len = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line">    IF_&lt;<span class="built_in">sizeof</span>(<span class="type">short</span>)==len, <span class="type">short</span>,</span><br><span class="line">    IF_&lt;<span class="built_in">sizeof</span>(<span class="type">int</span>)==len, <span class="type">int</span>,</span><br><span class="line">    IF_&lt;<span class="built_in">sizeof</span>(<span class="type">long</span>)==len, <span class="type">long</span>,</span><br><span class="line">    IF_&lt;<span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>)==len, <span class="type">long</span> <span class="type">long</span>,</span><br><span class="line">    <span class="type">void</span>&gt;::reType&gt;::reType&gt;::reType&gt;::reType</span><br><span class="line">int_my; <span class="comment">// 定义一个指定字节数的类型</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(int_my) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p>WHILE_&lt;&gt; 的使用示例见下面：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 计算 1^e+2^e+...+n^e</span><br><span class="line">template&lt;int n, int e&gt;</span><br><span class="line">class sum_pow &#123;</span><br><span class="line">    template&lt;int i, int e&gt; class pow_e&#123; public: enum&#123; ret=i*pow_e&lt;i,e-1&gt;::ret &#125;; &#125;;</span><br><span class="line">    template&lt;int i&gt; class pow_e&lt;i,0&gt;&#123; public: enum&#123; ret=1 &#125;; &#125;;</span><br><span class="line">    // 计算 i^e，嵌套类使得能够定义嵌套模板元函数，private 访问控制隐藏实现细节</span><br><span class="line">    template&lt;int i&gt; class pow&#123; public: enum&#123; ret=pow_e&lt;i,e&gt;::ret &#125;; &#125;;</span><br><span class="line">    template&lt;typename stat&gt;</span><br><span class="line">    class cond &#123; public: enum&#123; ret=(stat::ri&lt;=n) &#125;; &#125;;</span><br><span class="line">    template&lt;int i, int sum&gt;</span><br><span class="line">    class stat &#123; public: typedef stat&lt;i+1, sum+pow&lt;i&gt;::ret&gt; Next;</span><br><span class="line">                         enum&#123; ri=i, ret=sum &#125;; &#125;;</span><br><span class="line">public:</span><br><span class="line">    enum&#123; ret = WHILE_&lt;cond, stat&lt;1,0&gt;&gt;::reType::ret &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; sum_pow&lt;10, 2&gt;::ret &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    std::cin.get(); return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">385</span><br></pre></td></tr></table></figure><br>为了展现编译期数值计算的强大能力，下面是一个更复杂的计算：最大公约数（Greatest Common Divisor，GCD）和最小公倍数（Lowest Common Multiple，LCM），经典的辗转相除算法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小公倍数，普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> r, lcm=a*b;</span><br><span class="line">    <span class="keyword">while</span>(r=a%b) &#123; a = b; b = r; &#125; <span class="comment">// 因为用可变的存储，不能写成 a=b; b=a%b;</span></span><br><span class="line">    <span class="keyword">return</span> lcm/b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归函数版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd_r</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b==<span class="number">0</span> ? a : <span class="built_in">gcd_r</span>(b, a%b); &#125; <span class="comment">// 简洁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm_r</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a * b / <span class="built_in">gcd_r</span>(a,b); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 模板版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> a, <span class="type">int</span> b&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lcm_T</span>&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> stat&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">cond</span> &#123; <span class="keyword">public</span>: <span class="keyword">enum</span>&#123; ret=(stat::div!=<span class="number">0</span>) &#125;; &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="type">int</span> a, <span class="type">int</span> b&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">stat</span> &#123; <span class="keyword">public</span>: <span class="keyword">typedef</span> stat&lt;b, a%b&gt; Next; <span class="keyword">enum</span>&#123; div=a%b, ret=b &#125;; &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> gcd = WHILE_&lt;cond, stat&lt;a,b&gt;&gt;::reType::ret;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> ret = a * b / gcd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 递归模板版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> a, <span class="type">int</span> b&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lcm_T_r</span>&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="type">int</span> a, <span class="type">int</span> b&gt; <span class="keyword">class</span> <span class="title class_">gcd</span> &#123; <span class="keyword">public</span>: <span class="keyword">enum</span>&#123; ret = gcd&lt;b,a%b&gt;::ret &#125;; &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="type">int</span> a&gt; <span class="keyword">class</span> <span class="title class_">gcd</span>&lt;a, <span class="number">0</span>&gt; &#123; <span class="keyword">public</span>: <span class="keyword">enum</span>&#123; ret = a &#125;; &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> ret = a * b / gcd&lt;a,b&gt;::ret;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">lcm</span>(<span class="number">100</span>, <span class="number">36</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">lcm_r</span>(<span class="number">100</span>, <span class="number">36</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; lcm_T&lt;<span class="number">100</span>, <span class="number">36</span>&gt;::ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; lcm_T_r&lt;<span class="number">100</span>, <span class="number">36</span>&gt;::ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">900</span><br><span class="line">900</span><br><span class="line">900</span><br><span class="line">900</span><br></pre></td></tr></table></figure></p>
<p>上面例子中，定义一个类的整型常量，可以用 enum，也可以用 static const int，需要注意的是 enum 定义的常量的字节数不会超过 sizeof(int) （文献[2]）。</p>
<h2 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h2><p>文献[11]展示了一个循环展开（loop unrolling）的例子 — 冒泡排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">// std::swap</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// dynamic code, 普通函数版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span>* data, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;<span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i; ++j)</span><br><span class="line">            <span class="keyword">if</span> (data[j]&gt;data[j<span class="number">+1</span>]) std::<span class="built_in">swap</span>(data[j], data[j<span class="number">+1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据长度为 4 时，手动循环展开</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bubbleSort4</span><span class="params">(<span class="type">int</span>* data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMP_SWAP(i, j) <span class="keyword">if</span>(data[i]&gt;data[j]) std::swap(data[i], data[j])</span></span><br><span class="line">    <span class="built_in">COMP_SWAP</span>(<span class="number">0</span>, <span class="number">1</span>); <span class="built_in">COMP_SWAP</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="built_in">COMP_SWAP</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">COMP_SWAP</span>(<span class="number">0</span>, <span class="number">1</span>); <span class="built_in">COMP_SWAP</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">COMP_SWAP</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 递归函数版本，指导模板思路，最后一个参数是哑参数（dummy parameter），仅为分辨重载函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">recursion</span> &#123; &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span>* data, <span class="type">int</span> n, recursion)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n<span class="number">-1</span>; ++j) <span class="keyword">if</span>(data[j]&gt;data[j<span class="number">+1</span>]) std::<span class="built_in">swap</span>(data[j], data[j<span class="number">+1</span>]);</span><br><span class="line">    <span class="built_in">bubbleSort</span>(data, n<span class="number">-1</span>, <span class="built_in">recursion</span>());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// static code, 模板元编程版本</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> i, <span class="type">int</span> j&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">IntSwap</span><span class="params">(<span class="type">int</span>* data)</span> </span>&#123; <span class="comment">// 比较和交换两个相邻元素</span></span><br><span class="line">    <span class="keyword">if</span>(data[i]&gt;data[j]) std::<span class="built_in">swap</span>(data[i], data[j]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> i, <span class="type">int</span> j&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">IntBubbleSortLoop</span><span class="params">(<span class="type">int</span>* data)</span> </span>&#123; <span class="comment">// 一次冒泡，将前 i 个元素中最大的置换到最后</span></span><br><span class="line">    <span class="built_in">IntSwap</span>&lt;j, j<span class="number">+1</span>&gt;(data);</span><br><span class="line">    IntBubbleSortLoop&lt;j&lt;i<span class="number">-1</span>?i:<span class="number">0</span>, <span class="built_in">j</span>&lt;i<span class="number">-1</span>?(j<span class="number">+1</span>):<span class="number">0</span>&gt;(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="built_in">IntBubbleSortLoop</span>&lt;<span class="number">0</span>, <span class="number">0</span>&gt;(<span class="type">int</span>*) &#123; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> n&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">IntBubbleSort</span><span class="params">(<span class="type">int</span>* data)</span> </span>&#123; <span class="comment">// 模板冒泡排序循环展开</span></span><br><span class="line">    <span class="built_in">IntBubbleSortLoop</span>&lt;n<span class="number">-1</span>, <span class="number">0</span>&gt;(data);</span><br><span class="line">    <span class="built_in">IntBubbleSort</span>&lt;n<span class="number">-1</span>&gt;(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="built_in">IntBubbleSort</span>&lt;<span class="number">1</span>&gt;(<span class="type">int</span>* data) &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>对循环次数固定且比较小的循环语句，对其进行展开并内联可以避免函数调用以及执行循环语句中的分支，从而可以提高性能，对上述代码做如下测试，代码在 VS2013 的 Release 下编译运行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">// memcpy</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> t1, t2, t3; <span class="type">const</span> <span class="type">int</span> num=<span class="number">100000000</span>;</span><br><span class="line">    <span class="type">int</span> data[<span class="number">4</span>]; <span class="type">int</span> inidata[<span class="number">4</span>]=&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    t1 = <span class="built_in">omp_get_wtime</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i) &#123; <span class="built_in">memcpy</span>(data, inidata, <span class="number">4</span>); <span class="built_in">bubbleSort</span>(data, <span class="number">4</span>); &#125;</span><br><span class="line">    t1 = <span class="built_in">omp_get_wtime</span>()-t1;</span><br><span class="line">    t2 = <span class="built_in">omp_get_wtime</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i) &#123; <span class="built_in">memcpy</span>(data, inidata, <span class="number">4</span>); <span class="built_in">bubbleSort4</span>(data); &#125;</span><br><span class="line">    t2 = <span class="built_in">omp_get_wtime</span>()-t2;</span><br><span class="line">    t3 = <span class="built_in">omp_get_wtime</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i) &#123; <span class="built_in">memcpy</span>(data, inidata, <span class="number">4</span>); <span class="built_in">IntBubbleSort</span>&lt;<span class="number">4</span>&gt;(data); &#125;</span><br><span class="line">    t3 = <span class="built_in">omp_get_wtime</span>()-t3;</span><br><span class="line">    std::cout &lt;&lt; t1/t3 &lt;&lt; <span class="string">&#x27;\t&#x27;</span> &lt;&lt; t2/t3 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.38643 0.926521</span><br></pre></td></tr></table></figure><br>上述结果表明，模板元编程实现的循环展开能够达到和手动循环展开相近的性能（90% 以上），并且性能是循环版本的 2 倍多（如果扣除 memcpy 函数占据的部分加速比将更高，根据 Amdahl 定律）。这里可能有人会想，既然循环次数固定，为什么不直接手动循环展开呢，难道就为了使用模板吗？当然不是，有时候循环次数确实是编译期固定值，但对用户并不是固定的，比如要实现数学上向量计算的类，因为可能是 2、3、4 维，所以写成模板，把维度作为 int 型模板参数，这时因为不知道具体是几维的也就不得不用循环，不过因为维度信息在模板实例化时是编译期常量且较小，所以编译器很可能在代码优化时进行循环展开，但我们想让这一切发生的更可控一些。</p>
<p>上面用三个函数模板 IntSwap&lt;&gt;()、 IntBubbleSortLoop&lt;&gt;()、 IntBubbleSort&lt;&gt;() 来实现一个排序功能，不但显得分散（和封装原理不符），还暴露了实现细节，我们可以仿照上一节的代码，将 IntBubbleSortLoop&lt;&gt;()、 IntBubbleSort&lt;&gt;() 嵌入其他模板内部，因为函数不允许嵌套，我们只能用类模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整合成一个类模板实现，看着好，但引入了 代码膨胀</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntBubbleSortC</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> i, <span class="type">int</span> j&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">IntSwap</span><span class="params">(<span class="type">int</span>* data)</span> </span>&#123; <span class="comment">// 比较和交换两个相邻元素</span></span><br><span class="line">        <span class="keyword">if</span>(data[i]&gt;data[j]) std::<span class="built_in">swap</span>(data[i], data[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> i, <span class="type">int</span> j&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">IntBubbleSortLoop</span><span class="params">(<span class="type">int</span>* data)</span> </span>&#123; <span class="comment">// 一次冒泡</span></span><br><span class="line">        <span class="built_in">IntSwap</span>&lt;j, j<span class="number">+1</span>&gt;(data);</span><br><span class="line">        IntBubbleSortLoop&lt;j&lt;i<span class="number">-1</span>?i:<span class="number">0</span>, <span class="built_in">j</span>&lt;i<span class="number">-1</span>?(j<span class="number">+1</span>):<span class="number">0</span>&gt;(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="built_in">IntBubbleSortLoop</span>&lt;<span class="number">0</span>, <span class="number">0</span>&gt;(<span class="type">int</span>*) &#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span>* data)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">IntBubbleSortLoop</span>&lt;n<span class="number">-1</span>, <span class="number">0</span>&gt;(data);</span><br><span class="line">        IntBubbleSortC&lt;n<span class="number">-1</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntBubbleSortC</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span>* data)</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data[<span class="number">4</span>] = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    IntBubbleSortC&lt;<span class="number">4</span>&gt;::<span class="built_in">sort</span>(data); <span class="comment">// 如此调用</span></span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码看似很好，不仅整合了代码，借助类成员的访问控制，还隐藏了实现细节。不过它存在着很大问题，如果实例化 IntBubbleSortC<4>、 IntBubbleSortC<3>、 IntBubbleSortC<2>，将实例化成员函数 IntBubbleSortC<4>::IntSwap<0, 1>()、 IntBubbleSortC<4>::IntSwap<1, 2>()、 IntBubbleSortC<4>::IntSwap<2, 3>()、 IntBubbleSortC<3>::IntSwap<0, 1>()、 IntBubbleSortC<3>::IntSwap<1, 2>()、 IntBubbleSortC<2>::IntSwap<0, 1>()，而在原来的看着分散的代码中 IntSwap<0, 1>() 只有一个。这将导致代码膨胀（code bloat），即生成的可执行文件体积变大（代码膨胀另一含义是源代码增大，见文献[1]第11章）。不过这里使用了内联（inline），如果编译器确实内联展开代码则不会导致代码膨胀（除了循环展开本身会带来的代码膨胀），但因为重复编译原本可以复用的模板实例，会增加编译时间。在上一节的例子中，因为只涉及编译期常量计算，并不涉及函数（函数模板，或类模板的成员函数，函数被编译成具体的机器二进制代码），并不会出现代码膨胀。</p>
<p>为了清晰证明上面的论述，我们去掉所有 inline 并将函数实现放到类外面（类里面实现的成员函数都是内联的，因为函数实现可能被包含多次，见文献[2] 10.2.9，不过现在的编译器优化能力很强，很多时候加不加 inline 并不影响编译器自己对内联的选择…），分别编译分散版本和类模板封装版本的冒泡排序代码编译生成的目标文件（VS2013 下是 .obj 文件）的大小，代码均在 VS2013 Debug 模式下编译（防止编译器优化），比较 main.obj （源文件是 main.cpp）大小。</p>
<p>类模板封装版本代码如下，注意将成员函数在外面定义的写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">// std::swap</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 整合成一个类模板实现，看着好，但引入了 代码膨胀</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntBubbleSortC</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> i, <span class="type">int</span> j&gt; <span class="type">static</span> <span class="type">void</span> <span class="title">IntSwap</span><span class="params">(<span class="type">int</span>* data)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> i, <span class="type">int</span> j&gt; <span class="type">static</span> <span class="type">void</span> <span class="title">IntBubbleSortLoop</span><span class="params">(<span class="type">int</span>* data)</span></span>;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="type">static</span> <span class="type">void</span> <span class="built_in">IntBubbleSortLoop</span>&lt;<span class="number">0</span>, <span class="number">0</span>&gt;(<span class="type">int</span>*) &#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span>* data)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntBubbleSortC</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span>* data)</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> n&gt; <span class="keyword">template</span>&lt;<span class="type">int</span> i, <span class="type">int</span> j&gt;</span><br><span class="line"><span class="type">void</span> IntBubbleSortC&lt;n&gt;::<span class="built_in">IntSwap</span>(<span class="type">int</span>* data) &#123;</span><br><span class="line">    <span class="keyword">if</span>(data[i]&gt;data[j]) std::<span class="built_in">swap</span>(data[i], data[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> n&gt; <span class="keyword">template</span>&lt;<span class="type">int</span> i, <span class="type">int</span> j&gt;</span><br><span class="line"><span class="type">void</span> IntBubbleSortC&lt;n&gt;::<span class="built_in">IntBubbleSortLoop</span>(<span class="type">int</span>* data) &#123;</span><br><span class="line">    <span class="built_in">IntSwap</span>&lt;j, j<span class="number">+1</span>&gt;(data);</span><br><span class="line">    IntBubbleSortLoop&lt;j&lt;i<span class="number">-1</span>?i:<span class="number">0</span>, <span class="built_in">j</span>&lt;i<span class="number">-1</span>?(j<span class="number">+1</span>):<span class="number">0</span>&gt;(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> n&gt;</span><br><span class="line"><span class="type">void</span> IntBubbleSortC&lt;n&gt;::<span class="built_in">sort</span>(<span class="type">int</span>* data) &#123;</span><br><span class="line">    <span class="built_in">IntBubbleSortLoop</span>&lt;n<span class="number">-1</span>, <span class="number">0</span>&gt;(data);</span><br><span class="line">    IntBubbleSortC&lt;n<span class="number">-1</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data[<span class="number">40</span>] = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    IntBubbleSortC&lt;<span class="number">2</span>&gt;::<span class="built_in">sort</span>(data);  IntBubbleSortC&lt;<span class="number">3</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSortC&lt;<span class="number">4</span>&gt;::<span class="built_in">sort</span>(data);  IntBubbleSortC&lt;<span class="number">5</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSortC&lt;<span class="number">6</span>&gt;::<span class="built_in">sort</span>(data);  IntBubbleSortC&lt;<span class="number">7</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSortC&lt;<span class="number">8</span>&gt;::<span class="built_in">sort</span>(data);  IntBubbleSortC&lt;<span class="number">9</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSortC&lt;<span class="number">10</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSortC&lt;<span class="number">11</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    IntBubbleSortC&lt;<span class="number">12</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSortC&lt;<span class="number">13</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSortC&lt;<span class="number">14</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSortC&lt;<span class="number">15</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSortC&lt;<span class="number">16</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSortC&lt;<span class="number">17</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSortC&lt;<span class="number">18</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSortC&lt;<span class="number">19</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSortC&lt;<span class="number">20</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSortC&lt;<span class="number">21</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line"> </span><br><span class="line">    IntBubbleSortC&lt;<span class="number">22</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSortC&lt;<span class="number">23</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSortC&lt;<span class="number">24</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSortC&lt;<span class="number">25</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSortC&lt;<span class="number">26</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSortC&lt;<span class="number">27</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSortC&lt;<span class="number">28</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSortC&lt;<span class="number">29</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSortC&lt;<span class="number">30</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSortC&lt;<span class="number">31</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分散定义函数模板版本代码如下，为了更具可比性，也将函数放在类里面作为成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">// std::swap</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// static code, 模板元编程版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> i, <span class="type">int</span> j&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntSwap</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* data)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> i, <span class="type">int</span> j&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntBubbleSortLoop</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">loop</span><span class="params">(<span class="type">int</span>* data)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntBubbleSortLoop</span>&lt;<span class="number">0</span>, <span class="number">0</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">loop</span><span class="params">(<span class="type">int</span>* data)</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntBubbleSort</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span>* data)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntBubbleSort</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span>* data)</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> i, <span class="type">int</span> j&gt;</span><br><span class="line"><span class="type">void</span> IntSwap&lt;i, j&gt;::<span class="built_in">swap</span>(<span class="type">int</span>* data) &#123;</span><br><span class="line">    <span class="keyword">if</span>(data[i]&gt;data[j]) std::<span class="built_in">swap</span>(data[i], data[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> i, <span class="type">int</span> j&gt;</span><br><span class="line"><span class="type">void</span> IntBubbleSortLoop&lt;i, j&gt;::<span class="built_in">loop</span>(<span class="type">int</span>* data) &#123;</span><br><span class="line">    IntSwap&lt;j, j<span class="number">+1</span>&gt;::<span class="built_in">swap</span>(data);</span><br><span class="line">    IntBubbleSortLoop&lt;j&lt;i<span class="number">-1</span>?i:<span class="number">0</span>, j&lt;i<span class="number">-1</span>?(j<span class="number">+1</span>):<span class="number">0</span>&gt;::<span class="built_in">loop</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> n&gt;</span><br><span class="line"><span class="type">void</span> IntBubbleSort&lt;n&gt;::<span class="built_in">sort</span>(<span class="type">int</span>* data) &#123;</span><br><span class="line">    IntBubbleSortLoop&lt;n<span class="number">-1</span>, <span class="number">0</span>&gt;::<span class="built_in">loop</span>(data);</span><br><span class="line">    IntBubbleSort&lt;n<span class="number">-1</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data[<span class="number">40</span>] = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    IntBubbleSort&lt;<span class="number">2</span>&gt;::<span class="built_in">sort</span>(data);  IntBubbleSort&lt;<span class="number">3</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSort&lt;<span class="number">4</span>&gt;::<span class="built_in">sort</span>(data);  IntBubbleSort&lt;<span class="number">5</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSort&lt;<span class="number">6</span>&gt;::<span class="built_in">sort</span>(data);  IntBubbleSort&lt;<span class="number">7</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSort&lt;<span class="number">8</span>&gt;::<span class="built_in">sort</span>(data);  IntBubbleSort&lt;<span class="number">9</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSort&lt;<span class="number">10</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSort&lt;<span class="number">11</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    IntBubbleSort&lt;<span class="number">12</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSort&lt;<span class="number">13</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSort&lt;<span class="number">14</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSort&lt;<span class="number">15</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSort&lt;<span class="number">16</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSort&lt;<span class="number">17</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSort&lt;<span class="number">18</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSort&lt;<span class="number">19</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSort&lt;<span class="number">20</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSort&lt;<span class="number">21</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line"> </span><br><span class="line">    IntBubbleSort&lt;<span class="number">22</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSort&lt;<span class="number">23</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSort&lt;<span class="number">24</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSort&lt;<span class="number">25</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSort&lt;<span class="number">26</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSort&lt;<span class="number">27</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSort&lt;<span class="number">28</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSort&lt;<span class="number">29</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line">    IntBubbleSort&lt;<span class="number">30</span>&gt;::<span class="built_in">sort</span>(data); IntBubbleSort&lt;<span class="number">31</span>&gt;::<span class="built_in">sort</span>(data);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序中条件编译都未打开时（#if 0），main.obj 大小分别为 264 KB 和 211 KB，条件编译打开时（#if 1），main.obj 大小分别为 1073 KB 和 620 KB。可以看到，类模板封装版的对象文件不但绝对大小更大，而且增长更快，这和之前分析是一致的。</p>
<h2 id="表达式模板，向量运算"><a href="#表达式模板，向量运算" class="headerlink" title="表达式模板，向量运算"></a>表达式模板，向量运算</h2><p>文献[12]展示了一个表达式模板（Expression Templates）的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span>    <span class="comment">// std::sqrt()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 表达式类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DExprLiteral</span> &#123;                    <span class="comment">// 文字量</span></span><br><span class="line">    <span class="type">double</span> a_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DExprLiteral</span>(<span class="type">double</span> a) : <span class="built_in">a_</span>(a) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> a_; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DExprIdentity</span> &#123;                   <span class="comment">// 自变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">A</span>, <span class="keyword">class</span> <span class="title class_">B</span>, <span class="keyword">class</span> <span class="title class_">Op</span>&gt;    <span class="comment">// 双目操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBinExprOp</span> &#123;</span><br><span class="line">    A a_; B b_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DBinExprOp</span>(<span class="type">const</span> A&amp; a, <span class="type">const</span> B&amp; b) : <span class="built_in">a_</span>(a), <span class="built_in">b_</span>(b) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Op::<span class="built_in">apply</span>(<span class="built_in">a_</span>(x), <span class="built_in">b_</span>(x)); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">A</span>, <span class="keyword">class</span> <span class="title class_">Op</span>&gt;             <span class="comment">// 单目操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DUnaryExprOp</span> &#123;</span><br><span class="line">    A a_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DUnaryExprOp</span>(<span class="type">const</span> A&amp; a) : <span class="built_in">a_</span>(a) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Op::<span class="built_in">apply</span>(<span class="built_in">a_</span>(x)); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 表达式</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DExpr</span> &#123;</span><br><span class="line">    A a_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DExpr</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">DExpr</span>(<span class="type">const</span> A&amp; a) : <span class="built_in">a_</span>(a) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">a_</span>(x); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 运算符，模板参数 A、B 为参与运算的表达式类型</span></span><br><span class="line"><span class="comment">// operator /, division</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DApDiv</span> &#123; <span class="keyword">public</span>: <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">apply</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123; <span class="keyword">return</span> a / b; &#125; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">A</span>, <span class="keyword">class</span> <span class="title class_">B</span>&gt; DExpr&lt;DBinExprOp&lt;DExpr&lt;A&gt;, DExpr&lt;B&gt;, DApDiv&gt; &gt;</span><br><span class="line"><span class="keyword">operator</span>/(<span class="type">const</span> DExpr&lt;A&gt;&amp; a, <span class="type">const</span> DExpr&lt;B&gt;&amp; b) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> DBinExprOp&lt;DExpr&lt;A&gt;, DExpr&lt;B&gt;, DApDiv&gt; ExprT;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DExpr</span>&lt;ExprT&gt;(<span class="built_in">ExprT</span>(a, b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// operator +, addition</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DApAdd</span> &#123; <span class="keyword">public</span>: <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">apply</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">A</span>, <span class="keyword">class</span> <span class="title class_">B</span>&gt; DExpr&lt;DBinExprOp&lt;DExpr&lt;A&gt;, DExpr&lt;B&gt;, DApAdd&gt; &gt;</span><br><span class="line"><span class="keyword">operator</span>+(<span class="type">const</span> DExpr&lt;A&gt;&amp; a, <span class="type">const</span> DExpr&lt;B&gt;&amp; b) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> DBinExprOp&lt;DExpr&lt;A&gt;, DExpr&lt;B&gt;, DApAdd&gt; ExprT;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DExpr</span>&lt;ExprT&gt;(<span class="built_in">ExprT</span>(a, b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sqrt(), square rooting</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DApSqrt</span> &#123; <span class="keyword">public</span>: <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">apply</span><span class="params">(<span class="type">double</span> a)</span> </span>&#123; <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(a); &#125; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">A</span>&gt; DExpr&lt;DUnaryExprOp&lt;DExpr&lt;A&gt;, DApSqrt&gt; &gt;</span><br><span class="line"><span class="built_in">sqrt</span>(<span class="type">const</span> DExpr&lt;A&gt;&amp; a) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> DUnaryExprOp&lt;DExpr&lt;A&gt;, DApSqrt&gt; ExprT;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DExpr</span>&lt;ExprT&gt;(<span class="built_in">ExprT</span>(a));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// operator-, negative sign</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DApNeg</span> &#123; <span class="keyword">public</span>: <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">apply</span><span class="params">(<span class="type">double</span> a)</span> </span>&#123; <span class="keyword">return</span> -a; &#125; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">A</span>&gt; DExpr&lt;DUnaryExprOp&lt;DExpr&lt;A&gt;, DApNeg&gt; &gt;</span><br><span class="line"><span class="keyword">operator</span>-(<span class="type">const</span> DExpr&lt;A&gt;&amp; a) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> DUnaryExprOp&lt;DExpr&lt;A&gt;, DApNeg&gt; ExprT;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DExpr</span>&lt;ExprT&gt;(<span class="built_in">ExprT</span>(a));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// evaluate()</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Expr&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">evaluate</span><span class="params">(<span class="type">const</span> DExpr&lt;Expr&gt;&amp; expr, <span class="type">double</span> start, <span class="type">double</span> end, <span class="type">double</span> step)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">double</span> i=start; i&lt;end; i+=step) std::cout &lt;&lt; <span class="built_in">expr</span>(i) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DExpr&lt;DExprIdentity&gt; x;</span><br><span class="line">    <span class="built_in">evaluate</span>( -x / <span class="built_in">sqrt</span>( <span class="built_in">DExpr</span>&lt;DExprLiteral&gt;(<span class="number">1.0</span>) + x ) , <span class="number">0.0</span>, <span class="number">10.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-0 -0.707107 -1.1547 -1.5 -1.78885 -2.04124 -2.26779 -2.47487 -2.66667 -2.84605</span><br></pre></td></tr></table></figure></p>
<p>代码有点长（我已经尽量压缩行数），请先看最下面的 main() 函数，表达式模板允许我们以 “-x / sqrt( 1.0 + x )” 这种类似数学表达式的方式传参数，在 evaluate() 内部，将 0-10 的数依次赋给自变量 x 对表达式进行求值，这是通过在 template&lt;&gt; DExpr 类模板内部重载 operator() 实现的。我们来看看这一切是如何发生的。</p>
<p>在 main() 中调用 evaluate() 时，编译器根据全局重载的加号、sqrt、除号、负号推断“-x / sqrt( 1.0 + x )” 的类型是 Dexpr<DBinExprOp<Dexpr<DUnaryExprOp<Dexpr<DExprIdentity>, DApNeg&gt;&gt;, Dexpr<DUnaryExprOp<Dexpr<DBinExprOp<Dexpr<DExprLiteral>, Dexpr<DExprIdentity>, DApAdd&gt;&gt;, DApSqrt&gt;&gt;, DApDiv&gt;&gt;（即将每个表达式编码到一种类型，设这个类型为 ultimateExprType），并用此类型实例化函数模板 evaluate()，类型的推导见下图。在 evaluate() 中，对表达式进行求值 expr(i)，调用 ultimateExprType 的 operator()，这引起一系列的 operator() 和 Op::apply() 的调用，最终遇到基础类型 “表达式类型” DExprLiteral 和 DExprIdentity，这个过程见下图。总结就是，请看下图，从下到上类型推断，从上到下 operator() 表达式求值。</p>
<h2 id="表达式模板，Expression-Templates"><a href="#表达式模板，Expression-Templates" class="headerlink" title="表达式模板，Expression Templates"></a>表达式模板，Expression Templates</h2><p>上面代码函数实现写在类的内部，即内联，如果编译器对内联支持的好的话，上面代码几乎等价于如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span>    <span class="comment">// std::sqrt()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">evaluate</span><span class="params">(<span class="type">double</span> start, <span class="type">double</span> end, <span class="type">double</span> step)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> _temp = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">double</span> i=start; i&lt;end; i+=step)</span><br><span class="line">        std::cout &lt;&lt; -i / std::<span class="built_in">sqrt</span>(_temp + i) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">evaluate</span>(<span class="number">0.0</span>, <span class="number">10.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-0 -0.707107 -1.1547 -1.5 -1.78885 -2.04124 -2.26779 -2.47487 -2.66667 -2.84605</span><br></pre></td></tr></table></figure></p>
<p>和表达式模板类似的技术还可以用到向量计算中，以避免产生临时向量变量，见文献[4] Expression templates 和文献[12]的后面。传统向量计算如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleVec</span>; <span class="comment">// DoubleVec 重载了 + - * / 等向量元素之间的计算</span></span><br><span class="line"><span class="function">DoubleVec <span class="title">y</span><span class="params">(<span class="number">1000</span>)</span>, <span class="title">a</span><span class="params">(<span class="number">1000</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">1000</span>)</span>, <span class="title">c</span><span class="params">(<span class="number">1000</span>)</span>, <span class="title">d</span><span class="params">(<span class="number">1000</span>)</span></span>; <span class="comment">// 向量长度 1000</span></span><br><span class="line"><span class="comment">// 向量计算</span></span><br><span class="line">y = (a + b) / (c - d);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">DoubleVec __t1 = a + b;</span><br><span class="line">DoubleVec __t2 = c - d;</span><br><span class="line">DoubleVec __t3 = __t1 / __t2;</span><br><span class="line">y = __t3;</span><br></pre></td></tr></table></figure></p>
<p>模板代码实现向量计算如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class A&gt; DVExpr;</span><br><span class="line">class DVec&#123;</span><br><span class="line">    // ...</span><br><span class="line">    template&lt;class A&gt;</span><br><span class="line">    DVec&amp; operator=(const DVExpr&lt;A&gt;&amp;); // 由 = 引起向量逐个元素的表达式值计算并赋值</span><br><span class="line">&#125;;</span><br><span class="line">DVec y(1000), a(1000), b(1000), c(1000), d(1000); // 向量长度 1000</span><br><span class="line">// 向量计算</span><br><span class="line">y = (a + b) / (c - d);</span><br><span class="line">// 等价于</span><br><span class="line">for(int i=0; i&lt;1000; ++i) &#123;</span><br><span class="line">    y[i] = (a[i] + b[i]) / (c[i] + d[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过值得一提的是，传统代码可以用 C++11 的右值引用提升性能，C++11 新特性我们以后再详细讨论。</p>
<p>我们这里看下文献[4] Expression templates 实现的版本，它用到了编译期多态，编译期多态示意代码如下（关于这种代码形式有个名字叫 curiously recurring template pattern， CRTP，见文献[4]）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板基类，定义接口，具体实现由模板参数，即子类实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> D&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; <span class="built_in">static_cast</span>&lt;E&amp;&gt;(*<span class="keyword">this</span>).<span class="built_in">f1</span>(); &#125; <span class="comment">// 直接调用子类实现</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> E&amp;&gt;(*<span class="keyword">this</span>).<span class="built_in">f1</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dirived1</span> : <span class="keyword">public</span> base&lt;dirived1&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dirived2</span> : <span class="keyword">public</span> base&lt;dirived2&lt;T&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>简化后（向量长度固定为1000，元素类型为 double）的向量计算代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// A CRTP base class for Vecs with a size and indexing:</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VecExpr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;E <span class="type">const</span>&amp;&gt;(*<span class="keyword">this</span>)[i]; &#125;</span><br><span class="line">    <span class="keyword">operator</span> E <span class="type">const</span>&amp;() <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">const</span> E&amp;&gt;(*<span class="keyword">this</span>); &#125; <span class="comment">// 向下类型转换</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// The actual Vec class:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vec</span> : <span class="keyword">public</span> VecExpr&lt;Vec&gt; &#123;</span><br><span class="line">    <span class="type">double</span> _data[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span>&amp;  <span class="keyword">operator</span>[](<span class="type">int</span> i) &#123; <span class="keyword">return</span> _data[i]; &#125;</span><br><span class="line">    <span class="type">double</span> <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span> &#123; <span class="keyword">return</span> _data[i]; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">    Vec <span class="type">const</span>&amp; <span class="keyword">operator</span>=(VecExpr&lt;E&gt; <span class="type">const</span>&amp; vec) &#123;</span><br><span class="line">        E <span class="type">const</span>&amp; v = vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i) _data[i] = v[i];</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Constructors</span></span><br><span class="line">    <span class="built_in">Vec</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">Vec</span>(<span class="type">double</span> v) &#123; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i) _data[i] = v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E1, <span class="keyword">typename</span> E2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VecDifference</span> : <span class="keyword">public</span> VecExpr&lt;VecDifference&lt;E1, E2&gt; &gt; &#123;</span><br><span class="line">    E1 <span class="type">const</span>&amp; _u; E2 <span class="type">const</span>&amp; _v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VecDifference</span>(VecExpr&lt;E1&gt; <span class="type">const</span>&amp; u, VecExpr&lt;E2&gt; <span class="type">const</span>&amp; v) : _u(u), _v(v) &#123; &#125;</span><br><span class="line">    <span class="type">double</span> <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span> &#123; <span class="keyword">return</span> _u[i] - _v[i]; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VecScaled</span> : <span class="keyword">public</span> VecExpr&lt;VecScaled&lt;E&gt; &gt; &#123;</span><br><span class="line">    <span class="type">double</span> _alpha; E <span class="type">const</span>&amp; _v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VecScaled</span>(<span class="type">double</span> alpha, VecExpr&lt;E&gt; <span class="type">const</span>&amp; v) : _alpha(alpha), _v(v) &#123; &#125;</span><br><span class="line">    <span class="type">double</span> <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span> &#123; <span class="keyword">return</span> _alpha * _v[i]; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Now we can overload operators:</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E1, <span class="keyword">typename</span> E2&gt; VecDifference&lt;E1, E2&gt; <span class="type">const</span></span><br><span class="line"><span class="keyword">operator</span>-(VecExpr&lt;E1&gt; <span class="type">const</span>&amp; u, VecExpr&lt;E2&gt; <span class="type">const</span>&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">VecDifference</span>&lt;E1, E2&gt;(u, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt; VecScaled&lt;E&gt; <span class="type">const</span></span><br><span class="line"><span class="keyword">operator</span>*(<span class="type">double</span> alpha, VecExpr&lt;E&gt; <span class="type">const</span>&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">VecScaled</span>&lt;E&gt;(alpha, v);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Vec <span class="title">u</span><span class="params">(<span class="number">3</span>)</span>, <span class="title">v</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="type">double</span> alpha=<span class="number">9</span>; Vec y;</span><br><span class="line">    y = alpha*(u - v);</span><br><span class="line">    std::cout &lt;&lt; y[<span class="number">999</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure></p>
<p>这里可以看到基类的作用：提供统一的接口，让 operator- 和 operator* 可以写成统一的模板形式。</p>
<h2 id="特性，策略，标签"><a href="#特性，策略，标签" class="headerlink" title="特性，策略，标签"></a>特性，策略，标签</h2><p>利用迭代器，我们可以实现很多通用算法，迭代器在容器与算法之间搭建了一座桥梁。求和函数模板如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> iter&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> iter::value_type <span class="title">mysum</span><span class="params">(iter begin, iter end)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> iter::value_type <span class="title">sum</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(iter i=begin; i!=end; ++i) sum += *i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span>; ++i) v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">mysum</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4950</span><br></pre></td></tr></table></figure></p>
<p>我们想让 mysum() 对指针参数也能工作，毕竟迭代器就是模拟指针，但指针没有嵌套类型 value_type，可以定义 mysum() 对指针类型的特例，但更好的办法是在函数参数和 value_type 之间多加一层 — 特性（traits）（参考了文献[1]第72页，特性详见文献[1] 12.1）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 特性，traits</span><br><span class="line">template&lt;typename iter&gt;</span><br><span class="line">class mytraits&#123;</span><br><span class="line">public: typedef typename iter::value_type value_type;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class mytraits&lt;T*&gt;&#123;</span><br><span class="line">public: typedef T value_type;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">template&lt;typename iter&gt;</span><br><span class="line">typename mytraits&lt;iter&gt;::value_type mysum(iter begin, iter end) &#123;</span><br><span class="line">    typename mytraits&lt;iter&gt;::value_type sum(0);</span><br><span class="line">    for(iter i=begin; i!=end; ++i) sum += *i;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    int v[4] = &#123;1,2,3,4&#125;;</span><br><span class="line">    std::cout &lt;&lt; mysum(v, v+4) &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    std::cin.get(); return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure></p>
<p>其实，C++ 标准定义了类似的 traits：std::iterator_trait（另一个经典例子是 std::numeric_limits） 。特性对类型的信息（如 value_type、 reference）进行包装，使得上层代码可以以统一的接口访问这些信息。C++ 模板元编程会涉及大量的类型计算，很多时候要提取类型的信息（typedef、 常量值等），如果这些类型的信息的访问方式不一致（如上面的迭代器和指针），我们将不得不定义特例，这会导致大量重复代码的出现（另一种代码膨胀），而通过加一层特性可以很好的解决这一问题。另外，特性不仅可以对类型的信息进行包装，还可以提供更多信息，当然，因为加了一层，也带来复杂性。特性是一种提供元信息的手段。</p>
<p>策略（policy）一般是一个类模板，典型的策略是 STL 容器（如 std::vector&lt;&gt;，完整声明是template<class T, class Alloc=allocator<T>&gt; class vector;）的分配器（这个参数有默认参数，即默认存储策略），策略类将模板的经常变化的那一部分子功能块集中起来作为模板参数，这样模板便可以更为通用，这和特性的思想是类似的（详见文献[1] 12.3）。</p>
<p>标签（tag）一般是一个空类，其作用是作为一个独一无二的类型名字用于标记一些东西，典型的例子是 STL 迭代器的五种类型的名字（input_iterator_tag, output_iterator_tag, forward_iterator_tag, bidirectional_iterator_tag, random_access_iterator_tag），std::vector<int>::iterator::iterator_category 就是 random_access_iterator_tag，可以用第1节判断类型是否等价的模板检测这一点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="comment">// 通例，返回 false</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">theSameType</span>       &#123; <span class="keyword">public</span>: <span class="keyword">enum</span> &#123; ret = <span class="literal">false</span> &#125;; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;               <span class="comment">// 特例，两类型相同时返回 true</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">theSameType</span>&lt;T, T&gt; &#123; <span class="keyword">public</span>: <span class="keyword">enum</span> &#123; ret = <span class="literal">true</span> &#125;; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; theSameType&lt; std::vector&lt;<span class="type">int</span>&gt;::iterator::iterator_category,</span><br><span class="line">                              std::random_access_iterator_tag &gt;::ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>有了这样的判断，还可以根据判断结果做更复杂的元编程逻辑（如一个算法以迭代器为参数，根据迭代器标签进行特例化以对某种迭代器特殊处理）。标签还可以用来分辨函数重载，第5节中就用到了这样的标签（recursion）（标签详见文献[1] 12.1）。</p>
<h2 id="更多类型计算"><a href="#更多类型计算" class="headerlink" title="更多类型计算"></a>更多类型计算</h2><p>在第1节我们讲类型等价的时候，已经见到了一个可以判断两个类型是否等价的模板，这一节我们给出更多例子，下面是判断一个类型是否可以隐式转换到另一个类型的模板（参考了文献[6] Static interface checking）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// whether T could be converted to U</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConversionTo</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">char</span> Type1[<span class="number">1</span>]; <span class="comment">// 两种 sizeof 不同的类型</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">char</span> Type2[<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="type">static</span> Type1&amp; <span class="title">Test</span><span class="params">( U )</span></span>; <span class="comment">// 较下面的函数，因为参数取值范围小，优先匹配</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Type2&amp; <span class="title">Test</span><span class="params">(...)</span></span>; <span class="comment">// 变长参数函数，可以匹配任何数量任何类型参数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> T <span class="title">MakeT</span><span class="params">()</span></span>; <span class="comment">// 返回类型 T，用这个函数而不用 T() 因为 T 可能没有默认构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; ret = <span class="built_in">sizeof</span>(<span class="built_in">Test</span>(<span class="built_in">MakeT</span>()))==<span class="built_in">sizeof</span>(Type1) &#125;; <span class="comment">// 可以转换时调用返回 Type1 的 Test()</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; ConversionTo&lt;<span class="type">int</span>, <span class="type">double</span>&gt;::ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; ConversionTo&lt;<span class="type">float</span>, <span class="type">int</span>*&gt;::ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; ConversionTo&lt;<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">int</span>&amp;&gt;::ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>下面这个例子检查某个类型是否含有某个嵌套类型定义（参考了文献[4] Substitution failure is not an erro (SFINAE)），这个例子是个内省（反射的一种）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// thanks to Substitution failure is not an erro (SFINAE)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_typedef_value_type</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">char</span> Type1[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">char</span> Type2[<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt; <span class="type">static</span> Type1&amp; <span class="title">test</span><span class="params">(<span class="keyword">typename</span> C::value_type*)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="type">static</span> Type2&amp; <span class="title">test</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> ret = <span class="built_in">sizeof</span>(<span class="built_in">test</span>&lt;T&gt;(<span class="number">0</span>)) == <span class="built_in">sizeof</span>(Type1); <span class="comment">// 0 == NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span> &#123; <span class="keyword">typedef</span> <span class="type">float</span> lalala; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; has_typedef_value_type&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;::ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; has_typedef_value_type&lt;foo&gt;::ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<p>这个例子是有缺陷的，因为不存在引用的指针，所以不用用来检测引用类型定义。可以看到，因为只涉及类型推断，都是编译期的计算，不涉及任何可执行代码，所以类的成员函数根本不需要具体实现。</p>
<h1 id="元容器"><a href="#元容器" class="headerlink" title="元容器"></a>元容器</h1><p>文献[1]第 13 章讲了元容器，所谓元容器，就是类似于 std::vector&lt;&gt; 那样的容器，不过它存储的是元数据 — 类型，有了元容器，我们就可以判断某个类型是否属于某个元容器之类的操作。</p>
<p>在讲元容器之前，我们先来看看伪变长参数模板，一个可以存储小于某个数（例子中为 4 个）的任意个数，任意类型数据的元组（tuple）的例子如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">null_type</span> &#123;&#125;; <span class="comment">// 标签类，标记参数列表末尾</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">type_shift_node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T0 data_type;</span><br><span class="line">    <span class="keyword">typedef</span> type_shift_node&lt;T1, T2, T3, null_type&gt; next_type; <span class="comment">// 参数移位了</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> num = next_type::num + <span class="number">1</span>; <span class="comment">// 非 null_type 模板参数个数</span></span><br><span class="line">    data_type data; <span class="comment">// 本节点数据</span></span><br><span class="line">    next_type next; <span class="comment">// 后续所有节点数据</span></span><br><span class="line">    <span class="built_in">type_shift_node</span>() :<span class="built_in">data</span>(), <span class="built_in">next</span>() &#123; &#125; <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">type_shift_node</span>(T0 <span class="type">const</span>&amp; d0, T1 <span class="type">const</span>&amp; d1, T2 <span class="type">const</span>&amp; d2, T3 <span class="type">const</span>&amp; d3)</span><br><span class="line">        :<span class="built_in">data</span>(d0), <span class="built_in">next</span>(d1, d2, d3, <span class="built_in">null_type</span>()) &#123; &#125; <span class="comment">// next 参数也移位了</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0&gt; <span class="comment">// 特例，递归终止</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">type_shift_node</span>&lt;T0, null_type, null_type, null_type&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T0 data_type;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    data_type data; <span class="comment">// 本节点数据</span></span><br><span class="line">    <span class="built_in">type_shift_node</span>() :<span class="built_in">data</span>(), <span class="built_in">next</span>() &#123; &#125; <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">type_shift_node</span>(T0 <span class="type">const</span>&amp; d0, null_type, null_type, null_type) : <span class="built_in">data</span>(d0) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 元组类模板，默认参数 + 嵌套递归</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span> T1=null_type, <span class="keyword">typename</span> T2=null_type,</span><br><span class="line">         <span class="keyword">typename</span> T3=null_type&gt;</span><br><span class="line"><span class="keyword">class</span> my_tuple &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> type_shift_node&lt;T0, T1, T2, T3&gt; tuple_type;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> num = tuple_type::num;</span><br><span class="line">    tuple_type t;</span><br><span class="line">    <span class="built_in">my_tuple</span>(T0 <span class="type">const</span>&amp; d0=<span class="built_in">T0</span>(),T1 <span class="type">const</span>&amp; d1=<span class="built_in">T1</span>(),T2 <span class="type">const</span>&amp; d2=<span class="built_in">T2</span>(),T3 <span class="type">const</span>&amp; d3=<span class="built_in">T3</span>())</span><br><span class="line">        : <span class="built_in">t</span>(d0, d1, d2, d3) &#123; &#125; <span class="comment">// 构造函数，默认参数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 为方便访问元组数据，定义 get&lt;unsigned&gt;(tuple) 函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> i, <span class="keyword">typename</span> T0, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">type_shift_node_traits</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span></span><br><span class="line">        type_shift_node_traits&lt;i<span class="number">-1</span>,T0,T1,T2,T3&gt;::node_type::next_type node_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> node_type::data_type data_type;</span><br><span class="line">    <span class="function"><span class="type">static</span> node_type&amp; <span class="title">get_node</span><span class="params">(type_shift_node&lt;T0,T1,T2,T3&gt;&amp; node)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> type_shift_node_traits&lt;i<span class="number">-1</span>,T0,T1,T2,T3&gt;::<span class="built_in">get_node</span>(node).next; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">type_shift_node_traits</span>&lt;<span class="number">0</span>, T0, T1, T2, T3&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> type_shift_node&lt;T0,T1,T2,T3&gt; node_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> node_type::data_type data_type;</span><br><span class="line">    <span class="function"><span class="type">static</span> node_type&amp; <span class="title">get_node</span><span class="params">(type_shift_node&lt;T0,T1,T2,T3&gt;&amp; node)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> node; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> i, <span class="keyword">typename</span> T0, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="keyword">typename</span> type_shift_node_traits&lt;i,T0,T1,T2,T3&gt;::<span class="function">data_type</span></span><br><span class="line"><span class="function"><span class="title">get</span><span class="params">(my_tuple&lt;T0,T1,T2,T3&gt;&amp; tup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type_shift_node_traits&lt;i,T0,T1,T2,T3&gt;::<span class="built_in">get_node</span>(tup.t).data;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> my_tuple&lt;<span class="type">int</span>, <span class="type">char</span>, <span class="type">float</span>&gt; tuple3;</span><br><span class="line">    <span class="function">tuple3 <span class="title">t3</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">1.2f</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; t<span class="number">3.</span>t.data &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">              &lt;&lt; t<span class="number">3.</span>t.next.data &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">              &lt;&lt; t<span class="number">3.</span>t.next.next.data &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; tuple3::num &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t3) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 从 0 开始，不要出现 3，否则将出现不可理解的编译错误</span></span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10 m 1.2</span><br><span class="line">3</span><br><span class="line">1.2</span><br></pre></td></tr></table></figure></p>
<p>C++11 引入了变长模板参数，其背后的原理也是模板递归（文献[1]第 230 页）。</p>
<p>利用和上面例子类似的模板参数移位递归的原理，我们可以构造一个存储“类型”的元组，即元容器，其代码如下（和文献[1]第 237 页的例子不同）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 元容器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0=<span class="type">void</span>, <span class="keyword">typename</span> T1=<span class="type">void</span>, <span class="keyword">typename</span> T2=<span class="type">void</span>, <span class="keyword">typename</span> T3=<span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">class</span> meta_container &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T0 type;</span><br><span class="line">    <span class="keyword">typedef</span> meta_container&lt;T1, T2, T3, <span class="type">void</span>&gt; next_node; <span class="comment">// 参数移位了</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> size = next_node::size + <span class="number">1</span>; <span class="comment">// 非 null_type 模板参数个数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="comment">// 特例，递归终止</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">meta_container</span>&lt;<span class="type">void</span>, <span class="type">void</span>, <span class="type">void</span>, <span class="type">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span> type;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 访问元容器中的数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="type">unsigned</span> i&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">get</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">static_assert</span>(i&lt;C::size, <span class="string">&quot;get&lt;C,i&gt;: index exceed num&quot;</span>); <span class="comment">// C++11 引入静态断言</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> get&lt;C,i<span class="number">-1</span>&gt;::c_type::next_node c_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> c_type::type ret_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">get</span>&lt;C, <span class="number">0</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="number">0</span>&lt;C::size, <span class="string">&quot;get&lt;C,i&gt;: index exceed num&quot;</span>); <span class="comment">// C++11 引入静态断言</span></span><br><span class="line">    <span class="keyword">typedef</span> C c_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> c_type::type ret_type;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在元容器中查找某个类型，找到返回索引，找不到返回 -1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="keyword">class</span> <span class="title class_">same_type</span> &#123; <span class="keyword">public</span>: <span class="keyword">enum</span> &#123; ret = <span class="literal">false</span> &#125;; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">same_type</span>&lt;T, T&gt; &#123; <span class="keyword">public</span>: <span class="keyword">enum</span> &#123; ret = <span class="literal">true</span> &#125;; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> c, <span class="keyword">typename</span> Then, <span class="keyword">typename</span> Else&gt; <span class="keyword">class</span> <span class="title class_">IF_</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Then, <span class="keyword">typename</span> Else&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IF_</span>&lt;<span class="literal">true</span>, Then, Else&gt; &#123; <span class="keyword">public</span>: <span class="keyword">typedef</span> Then reType; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Then, <span class="keyword">typename</span> Else&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IF_</span>&lt;<span class="literal">false</span>, Then, Else&gt; &#123; <span class="keyword">public</span>: <span class="keyword">typedef</span> Else reType; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">find</span> &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="type">int</span> i&gt; <span class="keyword">class</span> <span class="title class_">number</span> &#123; <span class="keyword">public</span>: <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> ret = i; &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="type">int</span> i&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">find_i</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> ret = IF_&lt; same_type&lt;get&lt;C,i&gt;::ret_type, T&gt;::ret,</span><br><span class="line">            number&lt;i&gt;, find_i&lt;C,T,i<span class="number">-1</span>&gt; &gt;::reType::ret;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">find_i</span>&lt;C, T, <span class="number">-1</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> ret = find_i&lt;C, T, C::size<span class="number">-1</span>&gt;::ret;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> meta_container&lt;<span class="type">int</span>, <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&gt; mc;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">9999</span>;</span><br><span class="line">    get&lt;mc, <span class="number">1</span>&gt;::ret_type aref = a;</span><br><span class="line">    std::cout &lt;&lt; mc::size &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; aref &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; find&lt;mc, <span class="type">const</span> <span class="type">int</span>&gt;::ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; find&lt;mc, <span class="type">float</span>&gt;::ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">9999</span><br><span class="line">2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<p>上面例子已经实现了存储类型的元容器，和元容器上的查找算法，但还有一个小问题，就是它不能处理模板，编译器对模板的操纵能力远不如对类型的操纵能力强（提示：类模板实例是类型），我们可以一种间接方式实现存储“模板元素”，即用模板的一个代表实例（如全用 int 为参数的实例）来代表这个模板，这样对任意模板实例，只需判断其模板的代表实例是否在容器中即可，这需要进行类型过滤：对任意模板的实例将其替换为指定模板参数的代表实例，类型过滤实例代码如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/ 类型过滤，meta_filter 使用时只用一个参数，设置四个模板参数是因为，模板通例的参数列表</span><br><span class="line"><span class="comment">// 必须能够包含特例参数列表，后面三个参数设置默认值为 void 或标签模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">dummy_template_1</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span> T1&gt; <span class="keyword">class</span> <span class="title class_">dummy_template_2</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span> T1 = <span class="type">void</span>,</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> tmp_1 = dummy_template_1,</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt; <span class="keyword">class</span> tmp_2 = dummy_template_2&gt;</span><br><span class="line"><span class="keyword">class</span> meta_filter &#123; <span class="comment">// 通例，不改变类型</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T0 ret_type;</span><br><span class="line">&#125;;</span><br><span class="line">                    <span class="comment">// 匹配任何带有一个类型参数模板的实例，将模板实例替换为代表实例</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">tmp_1</span>, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">meta_filter</span>&lt;tmp_1&lt;T&gt;, <span class="type">void</span>, dummy_template_1, dummy_template_2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> tmp_1&lt;<span class="type">int</span>&gt; ret_type;</span><br><span class="line">&#125;;</span><br><span class="line">                    <span class="comment">// 匹配任何带有两个类型参数模板的实例，将模板实例替换为代表实例</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">tmp_2</span>, <span class="keyword">typename</span> T0, <span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">meta_filter</span>&lt;tmp_2&lt;T0, T1&gt;, <span class="type">void</span>, dummy_template_1, dummy_template_2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> tmp_2&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ret_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>现在，只需将上面元容器和元容器查找函数修改为：对模板实例将其换为代表实例，即修改 meta_container&lt;&gt; 通例中“typedef T0 type;”语句为“typedef typename meta_filter<T0>::ret_type type;”，修改 find&lt;&gt; 的最后一行中“T”为“typename meta_filter<T>::ret_type”。修改后，下面代码的执行结果是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">my_tmp_2</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 自动将 my_tmp_2&lt;float, int&gt; 过滤为 my_tmp_2&lt;int, int&gt;</span></span><br><span class="line"><span class="keyword">typedef</span> meta_container&lt;<span class="type">int</span>, <span class="type">float</span>, my_tmp_2&lt;<span class="type">float</span>, <span class="type">int</span>&gt;&gt; mc2;</span><br><span class="line"><span class="comment">// 自动将 my_tmp_2&lt;char, double&gt; 过滤为 my_tmp_2&lt;int, int&gt;</span></span><br><span class="line">std::cout &lt;&lt; find&lt;mc2, my_tmp_2&lt;<span class="type">char</span>, <span class="type">double</span>&gt;&gt;::ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h1 id="模版与特化的概念"><a href="#模版与特化的概念" class="headerlink" title="模版与特化的概念"></a>模版与特化的概念</h1><h2 id="函数模版与类模版"><a href="#函数模版与类模版" class="headerlink" title="函数模版与类模版"></a>函数模版与类模版</h2><p>C++中模板分为函数模板和类模板</p>
<ul>
<li>函数模板：是一种抽象函数定义，它代表一类同构函数。</li>
<li>类模板：是一种更高层次的抽象的类定义。</li>
</ul>
<h2 id="特化的概念"><a href="#特化的概念" class="headerlink" title="特化的概念"></a>特化的概念</h2><p>所谓特化，就是将泛型搞得具体化一些，从字面上来解释，就是为已有的模板参数进行一些使其特殊化的指定，使得以前不受任何约束的模板参数，或受到特定的修饰（例如const或者摇身一变成为了指针之类的东东，甚至是经过别的模板类包装之后的模板类型）或完全被指定了下来。</p>
<h2 id="模板特化的分类"><a href="#模板特化的分类" class="headerlink" title="模板特化的分类"></a>模板特化的分类</h2><p>针对特化的对象不同，分为两类：函数模板的特化和类模板的特化</p>
<h3 id="函数模板的特化"><a href="#函数模板的特化" class="headerlink" title="函数模板的特化"></a>函数模板的特化</h3><p>当函数模板需要对某些类型进行特化处理，称为函数模板的特化。</p>
<h3 id="类模板的特化"><a href="#类模板的特化" class="headerlink" title="类模板的特化"></a>类模板的特化</h3><p>当类模板内需要对某些类型进行特别处理时，使用类模板的特化。</p>
<h2 id="特化整体上分为全特化和偏特化"><a href="#特化整体上分为全特化和偏特化" class="headerlink" title="特化整体上分为全特化和偏特化"></a>特化整体上分为全特化和偏特化</h2><h3 id="全特化"><a href="#全特化" class="headerlink" title="全特化"></a>全特化</h3><p>就是模板中模板参数全被指定为确定的类型。</p>
<p>全特化也就是定义了一个全新的类型，全特化的类中的函数可以与模板类不一样。</p>
<h3 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h3><p>就是模板中的模板参数没有被全部确定，需要编译器在编译时进行确定。</p>
<p>全特化的标志就是产生出完全确定的东西，而不是还需要在编译期间去搜寻适合的特化实现，貌似在我的这种理解下，全特化的 东西不论是类还是函数都有这样的特点，</p>
<ol>
<li>模板函数只能全特化，没有偏特化（以后可能有）。</li>
<li>模板类是可以全特化和偏特化的。</li>
</ol>
<p>template &lt;&gt;然后是完全和模板类型没有一点关系的类实现或者函数定义，如果你要说，都完全确定下来了，那还搞什么模板呀，直接定义不就完事了？</p>
<p>但是很多时候，<strong>我们既需要一个模板能应对各种情形，又需要它对于某个特定的类型（比如bool）有着特别的处理</strong>，这种情形下特化就是需要的了。</p>
<p>全特化的标志：template &lt;&gt;然后是完全和模板类型没有一点关系的类实现或者函数定义<br>偏特化的标志：template</p>
<h1 id="函数模版特化"><a href="#函数模版特化" class="headerlink" title="函数模版特化"></a>函数模版特化</h1><p>目前的标准中，模板函数只能全特化，没有偏特化</p>
<p>至于为什么函数不能偏特化，似乎不是因为语言实现不了，而是因为偏特化的功能可以通过函数的重载完成。</p>
<h2 id="函数模版的特化技巧"><a href="#函数模版的特化技巧" class="headerlink" title="函数模版的特化技巧"></a>函数模版的特化技巧</h2><p>函数模板的特化：当函数模板需要对某些类型进行特别处理，称为函数模板的特化。</p>
<p>例如，我们编写了一个泛化的比较程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">int compare(const T &amp;left, const T&amp;right)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt;&quot;in template&lt;class T&gt;...&quot; &lt;&lt;std::endl;</span><br><span class="line">    return (left - right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数满足我们的需求了么，显然不，它支持常见int, float等类型的数据的比较，但是不支持<code>char*(string)</code>类型。</p>
<p>所以我们必须对其进行特化，以让它支持两个字符串的比较,因此我们实现了如下的特化函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt; &gt;</span><br><span class="line">int compare&lt;const char*&gt;(const char* left, const char* right)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt;&quot;in special template&lt; &gt;...&quot; &lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    return strcmp(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt; &gt;</span><br><span class="line">int compare(const char* left, const char* right)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt;&quot;in special template&lt; &gt;...&quot; &lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    return strcmp(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="示例程序1–比较两个数据"><a href="#示例程序1–比较两个数据" class="headerlink" title="示例程序1–比较两个数据"></a>示例程序1–比较两个数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">///  模版特化</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">int compare(const T left, const T right)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt;&quot;in template&lt;class T&gt;...&quot; &lt;&lt;std::endl;</span><br><span class="line">    return (left - right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//  这个是一个特化的函数模版</span><br><span class="line">template &lt; &gt;</span><br><span class="line">int compare&lt;const char*&gt;(const char* left, const char* right)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt;&quot;in special template&lt; &gt;...&quot; &lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    return strcmp(left, right);</span><br><span class="line">&#125;</span><br><span class="line">//  特化的函数模版, 两个特化的模版本质相同, 因此编译器会报错</span><br><span class="line">// error: redefinition of &#x27;int compare(T, T) [with T = const char*]&#x27;|</span><br><span class="line">//template &lt; &gt;</span><br><span class="line">//int compare(const char* left, const char* right)</span><br><span class="line">//&#123;</span><br><span class="line">//    std::cout &lt;&lt;&quot;in special template&lt; &gt;...&quot; &lt;&lt;std::endl;</span><br><span class="line">//</span><br><span class="line">//    return strcmp(left, right);</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//  这个其实本质是函数重载</span><br><span class="line">int compare(char* left, char* right)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt;&quot;in overload function...&quot; &lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    return strcmp(left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">    compare(1, 4);</span><br><span class="line"></span><br><span class="line">    const char *left = &quot;gatieme&quot;;</span><br><span class="line">    const char *right = &quot;jeancheng&quot;;</span><br><span class="line">    compare(left, right);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数模版的特化，当函数调用发现有特化后的匹配函数时，会优先调用特化的函数，而不再通过函数模版来进行实例化。</p>
<h2 id="示例程序二-判断两个数据是否相等"><a href="#示例程序二-判断两个数据是否相等" class="headerlink" title="示例程序二-判断两个数据是否相等"></a>示例程序二-判断两个数据是否相等</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">//函数模板</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">bool IsEqual(T t1,T t2)&#123;</span><br><span class="line">    return t1==t2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;&gt; //函数模板特化</span><br><span class="line">bool IsEqual(char *t1,char *t2)&#123;</span><br><span class="line">    return strcmp(t1,t2)==0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    char str1[]=&quot;abc&quot;;</span><br><span class="line">    char str2[]=&quot;abc&quot;;</span><br><span class="line">    cout&lt;&lt;&quot;函数模板和函数模板特化&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;IsEqual(1,1)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;IsEqual(str1,str2)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类模版特化"><a href="#类模版特化" class="headerlink" title="类模版特化"></a>类模版特化</h1><p>类模板的特化：与函数模板类似，当类模板内需要对某些类型进行特别处理时，使用类模板的特化。例如：</p>
<p>这里归纳了针对一个模板参数的类模板特化的几种类型</p>
<p>一是特化为绝对类型；</p>
<p>二是特化为引用，指针类型；</p>
<p>三是特化为另外一个类模板。</p>
<p>这里用一个简单的例子来说明这三种情况：</p>
<h2 id="特化为绝对类型"><a href="#特化为绝对类型" class="headerlink" title="特化为绝对类型"></a>特化为绝对类型</h2><p>也就是说直接为某个特定类型做特化，这是我们最常见的一种特化方式， 如特化为float, double等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">// general version</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Compare</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static bool IsEqual(const T&amp; lh, const T&amp; rh)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt;&quot;in the general class...&quot; &lt;&lt;std::endl;</span><br><span class="line">        return lh == rh;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// specialize for float</span><br><span class="line">template&lt;&gt;</span><br><span class="line">class Compare&lt;float&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static bool IsEqual(const float&amp; lh, const float&amp; rh)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt;&quot;in the float special class...&quot; &lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">        return std::abs(lh - rh) &lt; 10e-3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// specialize for double</span><br><span class="line">template&lt;&gt;</span><br><span class="line">class Compare&lt;double&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static bool IsEqual(const double&amp; lh, const double&amp; rh)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt;&quot;in the double special class...&quot; &lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">        return std::abs(lh - rh) &lt; 10e-6;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    Compare&lt;int&gt; comp1;</span><br><span class="line">    std::cout &lt;&lt;comp1.IsEqual(3, 4) &lt;&lt;std::endl;</span><br><span class="line">    std::cout &lt;&lt;comp1.IsEqual(3, 3) &lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    Compare&lt;float&gt; comp2;</span><br><span class="line">    std::cout &lt;&lt;comp2.IsEqual(3.14, 4.14) &lt;&lt;std::endl;</span><br><span class="line">    std::cout &lt;&lt;comp2.IsEqual(3, 3) &lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    Compare&lt;double&gt; comp3;</span><br><span class="line">    std::cout &lt;&lt;comp3.IsEqual(3.14159, 4.14159) &lt;&lt;std::endl;</span><br><span class="line">    std::cout &lt;&lt;comp3.IsEqual(3.14159, 3.14159) &lt;&lt;std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果期望使用偏特化，那么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T1&gt;</span><br><span class="line">class A&lt;T1, int&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特化为引用，指针类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class _Iterator&gt;</span><br><span class="line">struct iterator_traits &#123;</span><br><span class="line">  typedef typename _Iterator::iterator_category iterator_category;</span><br><span class="line">  typedef typename _Iterator::value_type        value_type;</span><br><span class="line">  typedef typename _Iterator::difference_type   difference_type;</span><br><span class="line">  typedef typename _Iterator::pointer           pointer;</span><br><span class="line">  typedef typename _Iterator::reference         reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// specialize for _Tp*</span><br><span class="line">template &lt;class _Tp&gt;</span><br><span class="line">struct iterator_traits&lt;_Tp*&gt; &#123;</span><br><span class="line">  typedef random_access_iterator_tag iterator_category;</span><br><span class="line">  typedef _Tp                         value_type;</span><br><span class="line">  typedef ptrdiff_t                   difference_type;</span><br><span class="line">  typedef _Tp*                        pointer;</span><br><span class="line">  typedef _Tp&amp;                        reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// specialize for const _Tp*</span><br><span class="line">template &lt;class _Tp&gt;</span><br><span class="line">struct iterator_traits&lt;const _Tp*&gt; &#123;</span><br><span class="line">  typedef random_access_iterator_tag iterator_category;</span><br><span class="line">  typedef _Tp                         value_type;</span><br><span class="line">  typedef ptrdiff_t                   difference_type;</span><br><span class="line">  typedef const _Tp*                  pointer;</span><br><span class="line">  typedef const _Tp&amp;                  reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然，除了<code>T*</code>, 我们也可以将T特化为 <code>const T*</code>, <code>T&amp;</code>, <code>const T&amp;</code>等，以下还是以<code>T*</code>为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// specialize for T*</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Compare&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static bool IsEqual(const T* lh, const T* rh)</span><br><span class="line">    &#123;</span><br><span class="line">        return Compare&lt;T&gt;::IsEqual(*lh, *rh);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种特化其实是就不是一种绝对的特化， 它只是对类型做了某些限定，但仍然保留了其一定的模板性，这种特化给我们提供了极大的方便， 如这里， 我们就不需要对<code>int*</code>, <code>float*</code>, <code>double*</code>等等类型分别做特化了。</p>
<p>这其实是第二种方式的扩展，其实也是对类型做了某种限定，而不是绝对化为某个具体类型，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// specialize for vector&lt;T&gt;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Compare&lt;vector&lt;T&gt; &gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static bool IsEqual(const vector&lt;T&gt;&amp; lh, const vector&lt;T&gt;&amp; rh)</span><br><span class="line">    &#123;</span><br><span class="line">        if(lh.size() != rh.size()) return false;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i = 0; i &lt; lh.size(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                if(lh[i] != rh[i]) return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这就把IsEqual的参数限定为一种vector类型， 但具体是vector还是vector， 我们可以不关心， 因为对于这两种类型，我们的处理方式是一样的，我们可以把这种方式称为“半特化”。</p>
<p>当然， 我们可以将其“半特化”为任何我们自定义的模板类类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// specialize for any template class type</span><br><span class="line">template &lt;class T1&gt; </span><br><span class="line">struct SpecializedType</span><br><span class="line">&#123;</span><br><span class="line">    T1 x1;</span><br><span class="line">    T1 x2;</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class Compare&lt;SpecializedType&lt;T&gt; &gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static bool IsEqual(const SpecializedType&lt;T&gt;&amp; lh, const SpecializedType&lt;T&gt;&amp; rh)</span><br><span class="line">    &#123;</span><br><span class="line">        return Compare&lt;T&gt;::IsEqual(lh.x1 + lh.x2, rh.x1 + rh.x2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这就是三种类型的模板特化， 我们可以这么使用这个Compare类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// int</span><br><span class="line">int i1 = 10;</span><br><span class="line">int i2 = 10;</span><br><span class="line">bool r1 = Compare&lt;int&gt;::IsEqual(i1, i2);</span><br><span class="line"></span><br><span class="line">// float</span><br><span class="line">float f1 = 10;</span><br><span class="line">float f2 = 10;</span><br><span class="line">bool r2 = Compare&lt;float&gt;::IsEqual(f1, f2);</span><br><span class="line"></span><br><span class="line">// double</span><br><span class="line">double d1 = 10;</span><br><span class="line">double d2 = 10;</span><br><span class="line">bool r3 = Compare&lt;double&gt;::IsEqual(d1, d2);</span><br><span class="line"></span><br><span class="line">// pointer</span><br><span class="line">int* p1 = &amp;i1;</span><br><span class="line">int* p2 = &amp;i2;</span><br><span class="line">bool r4 = Compare&lt;int*&gt;::IsEqual(p1, p2);</span><br><span class="line"></span><br><span class="line">// vector&lt;T&gt;</span><br><span class="line">vector&lt;int&gt; v1;</span><br><span class="line">v1.push_back(1);</span><br><span class="line">v1.push_back(2);</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v2;</span><br><span class="line">v2.push_back(1);</span><br><span class="line">v2.push_back(2);</span><br><span class="line">bool r5 = Compare&lt;vector&lt;int&gt; &gt;::IsEqual(v1, v2);</span><br><span class="line"></span><br><span class="line">// custom template class </span><br><span class="line">SpecializedType&lt;float&gt; s1 = &#123;10.1f,10.2f&#125;;</span><br><span class="line">SpecializedType&lt;float&gt; s2 = &#123;10.3f,10.0f&#125;;</span><br><span class="line">bool r6 = Compare&lt;SpecializedType&lt;float&gt; &gt;::IsEqual(s1, s2);</span><br></pre></td></tr></table></figure>
<h1 id="类型萃取"><a href="#类型萃取" class="headerlink" title="类型萃取"></a>类型萃取</h1><p>在实现vector的时候，我们遇到了对于不同类型实现拷贝方式的方式不同。<br>比如：对于int，char使用memcpy就已经可以实现了，当然使用operator=也是没问题的，但是显然效率前者会高那么一些。<br>但是对于，string这种对象，或是与深浅拷贝有关的自定义类型，使用memcpy就会出现问题，使用operator=赋值就更加合适，避免出现深浅拷贝时出现的问题。 </p>
<p>那么我有没有一种方法能够在同一个类中实现对不同类型去执行不同的方法，比如上例中的，如果是int，char等我就去执行memcpy方法，如果是string就去执行operator=。 </p>
<p>c++提供了类型萃取，可以实现这种功能</p>
<p>下面从代码的角度来叙述<br>第一步：定义类型，区分内置类型与自定义类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct _TrueType//是无关紧要的类型，即内置类型</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line">struct _FalseType//不是无关紧要的类型，即自定义类型</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>第二步：<br>特化需要特化的类型，自定义类型显然无穷无尽，我们特化不完，所以我们可以把有限的内置类型特化完全。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">struct TypeTraits</span><br><span class="line">&#123;</span><br><span class="line">    typedef _FalseType IsPodType;  //自定义类型，不是无关痛痒的类型</span><br><span class="line">&#125;;</span><br><span class="line">//以下特化内置类型</span><br><span class="line">template&lt;&gt;</span><br><span class="line">struct TypeTraits&lt;int&gt;</span><br><span class="line">&#123;</span><br><span class="line">    typedef _TrueType IsPodType;//是无关痛痒的类型吗？是的</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">struct TypeTraits&lt;char&gt;</span><br><span class="line">&#123;</span><br><span class="line">    typedef _TrueType IsPodType;//是无关痛痒的类型吗？是的</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">struct TypeTraits&lt;double&gt;</span><br><span class="line">&#123;</span><br><span class="line">    typedef _TrueType IsPodType;//是无关痛痒的类型吗？是的</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来，重载拷贝函数，针对自定义类型与内置类型分别给出两种不同的方法，以TrueType，FalseType区分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void __TypeCopy(T* dst,const T* src,size_t size,_TrueType)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;__TrueType&quot;&lt;&lt;endl;</span><br><span class="line">    memcpy(dst,src,size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void __TypeCopy(T* dst,const T* src,size_t size,_FalseType)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;__FalseType&quot;&lt;&lt;endl;</span><br><span class="line">    for(size_t i=0;i&lt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dst[i]=src[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用函数：取出IsPODType，判断是否为无关痛痒的类型，也就是判断你到底是TrueType还是FalseType，然后根据你是什么类型去调你自己的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void TypeCopy(T* dst,const T* src,size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    __TypeCopy(dst,src,size,TypeTraits&lt;T&gt;::IsPodType());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>博文比较长，总结一下所涉及的东西：</p>
<ul>
<li>C++ 模板包括函数模板和类模板，模板参数形式有：类型、模板型、非类型（整型、指针）；</li>
<li>模板的特例化分完全特例化和部分特例化，实例将匹配参数集合最小的特例；</li>
<li>用实例参数替换模板形式参数称为实例化，实例化的结果是产生具体类型（类模板）或函数（函数模板），同一模板实参完全等价将产生等价的实例类型或函数；</li>
<li>模板一般在头文件中定义，可能被包含多次，编译和链接时会消除等价模板实例；</li>
<li>template、typename、this 关键字用来消除歧义，避免编译错误或产生不符预期的结果；</li>
<li>C++11 对模板引入了新特性：“&gt;&gt;”、函数模板也可以有默认参数、变长模板参数、外部模板实例（extern），并弃用 export template；</li>
<li>C++ 模板是图灵完备的，模板编程是函数编程风格，特点是：没有可变的存储、递归，以“&lt;&gt;”为输入，typedef 或静态常量为输出；</li>
<li>编译期数值计算虽然实际意义不大，但可以很好证明 C++ 模板的能力，可以用模板实现类似普通程序中的 if 和 while 语句；</li>
<li>一个实际应用是循环展开，虽然编译器可以自动循环展开，但我们可以让这一切更可控；</li>
<li>C++ 模板编程的两个问题是：难调试，会产生冗长且难以阅读的编译错误信息、代码膨胀（源代码膨胀、二进制对象文件膨胀），改进的方法是：增加一些检查代码，让编译器及时报错，使用特性、策略等让模板更通用，可能的话合并一些模板实例（如将代码提出去做成单独模板）；</li>
<li>表达式模板和向量计算是另一个可加速程序的例子，它们将计算表达式编码到类型，这是通过模板嵌套参数实现的；</li>
<li>特性，策略，标签是模板编程常用技巧，它们可以是模板变得更加通用；</li>
<li>模板甚至可以获得类型的内部信息（是否有某个 typedef），这是反射中的内省，C++ 在语言层面对反射支持很少（typeid），这不利于模板元编程；</li>
<li>可以用递归实现伪变长参数模板，C++11 变长参数模板背后的原理也是模板递归；</li>
<li>元容器存储元信息（如类型）、类型过滤过滤某些类型，它们是元编程的高级特性。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/27/Leetcode501_600/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/27/Leetcode501_600/" class="post-title-link" itemprop="url">Leetcode501 - 600</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-27 10:41:04" itemprop="dateCreated datePublished" datetime="2019-05-27T10:41:04+08:00">2019-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-26 16:02:34" itemprop="dateModified" datetime="2022-12-26T16:02:34+08:00">2022-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Leetcode501-Find-Mode-in-Binary-Search-Tree"><a href="#Leetcode501-Find-Mode-in-Binary-Search-Tree" class="headerlink" title="Leetcode501. Find Mode in Binary Search Tree"></a>Leetcode501. Find Mode in Binary Search Tree</h1><p>Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows:</p>
<p>For example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given BST [1,null,2,2],</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   2</span><br><span class="line">return [2].</span><br></pre></td></tr></table></figure><br>Note: If a tree has more than one mode, you can return them in any order.</p>
<p>这道题让我们求二分搜索树中的众数，这里定义的二分搜索树中左根右结点之间的关系是小于等于的，有些题目中是严格小于的，所以一定要看清题目要求。所谓的众数就是出现最多次的数字，可以有多个，那么这道题比较直接点思路就是利用一个哈希表来记录数字和其出现次数之前的映射，然后维护一个变量mx来记录当前最多的次数值，这样在遍历完树之后，根据这个mx值就能把对应的元素找出来。那么用这种方法的话就不需要用到二分搜索树的性质了，随意一种遍历方式都可以。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; m, <span class="type">int</span>&amp; mx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left, m, mx);</span><br><span class="line">        mx = <span class="built_in">max</span>(mx, ++m[root-&gt;val]);</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right, m, mx);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="type">int</span> mx = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root, m, mx);</span><br><span class="line">        <span class="keyword">for</span>(unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator p = m.<span class="built_in">begin</span>(); p != m.<span class="built_in">end</span>(); p ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;second == mx)</span><br><span class="line">                res.<span class="built_in">push_back</span>(p-&gt;first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode502-IPO"><a href="#Leetcode502-IPO" class="headerlink" title="Leetcode502. IPO"></a>Leetcode502. IPO</h1><p>Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.</p>
<p>You are given several projects. For each project i, it has a pure profit Pi and a minimum capital of Ci is needed to start the corresponding project. Initially, you have W capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.</p>
<p>To sum up, pick a list of at most k distinct projects from given projects to maximize your final capital, and output your final maximized capital.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].</span><br><span class="line"></span><br><span class="line">Output: 4</span><br><span class="line"></span><br><span class="line">Explanation: Since your initial capital is 0, you can only start the project indexed 0.</span><br><span class="line">             After finishing it you will obtain profit 1 and your capital becomes 1.</span><br><span class="line">             With capital 1, you can either start the project indexed 1 or the project indexed 2.</span><br><span class="line">             Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.</span><br><span class="line">             Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>You may assume all numbers in the input are non-negative integers.</li>
<li>The length of Profits array and Capital array will not exceed 50,000.</li>
<li>The answer is guaranteed to fit in a 32-bit signed integer.</li>
</ul>
<p>这道题说初始时我们的资本为0，可以交易k次，并且给了我们提供了交易所需的资本和所能获得的利润，让我们求怎样选择k次交易，使我们最终的资本最大。虽然题目中给我们的资本数组是有序的，但是OJ里的test case肯定不都是有序的，还有就是不一定需要资本大的交易利润就多，该遍历的时候还得遍历。我们可以用贪婪算法来解，每一次都选择资本范围内最大利润的进行交易，那么我们首先应该建立资本和利润对，然后根据资本的大小进行排序，然后我们根据自己当前的资本，用二分搜索法在有序数组中找第一个大于当前资本的交易的位置，然后往前退一步就是最后一个不大于当前资本的交易，然后向前遍历，找到利润最大的那个的进行交易，把利润加入资本W中，然后将这个交易对删除，这样我们就可以保证在进行k次交易后，我们的总资本最大，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaximizedCapital</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> W, vector&lt;<span class="type">int</span>&gt;&amp; Profits, vector&lt;<span class="type">int</span>&gt;&amp; Capital)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Capital.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(&#123;Capital[i], Profits[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>, right = v.<span class="built_in">size</span>(), mx = <span class="number">0</span>, idx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (v[mid].first &lt;= W) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = right - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mx &lt; v[j].second) &#123;</span><br><span class="line">                    mx = v[j].second;</span><br><span class="line">                    idx = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            W += mx;</span><br><span class="line">            v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> W;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看论坛上的大神们都比较喜欢用一些可以自动排序的数据结构来做，比如我们可以使用一个最大堆和一个最小堆，把资本利润对放在最小堆中，这样需要资本小的交易就在队首，然后从队首按顺序取出资本小的交易，如果所需资本不大于当前所拥有的资本，那么就把利润资本存入最大堆中，注意这里资本和利润要翻个，因为我们希望把利润最大的交易放在队首，便于取出，这样也能实现我们的目的，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaximizedCapital</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> W, vector&lt;<span class="type">int</span>&gt;&amp; Profits, vector&lt;<span class="type">int</span>&gt;&amp; Capital)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; maxH;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; minH;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Capital.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            minH.<span class="built_in">push</span>(&#123;Capital[i], Profits[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!minH.<span class="built_in">empty</span>() &amp;&amp; minH.<span class="built_in">top</span>().first &lt;= W) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = minH.<span class="built_in">top</span>(); minH.<span class="built_in">pop</span>();</span><br><span class="line">                maxH.<span class="built_in">push</span>(&#123;t.second, t.first&#125;); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxH.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">            W += maxH.<span class="built_in">top</span>().first; maxH.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> W;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode503-Next-Greater-Element-II"><a href="#Leetcode503-Next-Greater-Element-II" class="headerlink" title="Leetcode503. Next Greater Element II"></a>Leetcode503. Next Greater Element II</h1><p>Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn’t exist, output -1 for this number.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,1]</span><br><span class="line">Output: [2,-1,2]</span><br><span class="line">Explanation: The first 1&#x27;s next greater number is 2; </span><br><span class="line">The number 2 can&#x27;t find next greater number; </span><br><span class="line">The second 1&#x27;s next greater number needs to search circularly, which is also 2.</span><br></pre></td></tr></table></figure><br>我的做法简单粗暴，循环遍历，直到找到正确的最大值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j, size = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = i<span class="number">+1</span>; j &lt; size*<span class="number">2</span>; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt; nums[j%size]) &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(nums[j%size]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == size*<span class="number">2</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>也可以在O(n)内完成，它是一个循环找peek问题，但没关系，复制一份同样的数组，放在它的后面就好了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElements(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        Arrays.fill(ans, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span> * len; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i % len];</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; num)</span><br><span class="line">                ans[stack.pop()] = num;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; len) stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode504-Base-7"><a href="#Leetcode504-Base-7" class="headerlink" title="Leetcode504. Base 7"></a>Leetcode504. Base 7</h1><p>Given an integer, return its base 7 string representation.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 100</span><br><span class="line">Output: &quot;202&quot;</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -7</span><br><span class="line">Output: &quot;-10&quot;</span><br></pre></td></tr></table></figure><br>将数字转化为7进制，用字符串形式输出。若是负数，在不考虑正负号的情况下算出7进制表示的数，最后在前面加上负号就行。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convertToBase7</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> num1 = <span class="built_in">abs</span>(num);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(num1 != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> temp = num1 % <span class="number">7</span>;</span><br><span class="line">            num1 /= <span class="number">7</span>;</span><br><span class="line">            res = <span class="built_in">to_string</span>(temp) + res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">0</span>)</span><br><span class="line">            res = <span class="string">&quot;-&quot;</span> + res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode506-Relative-Ranks"><a href="#Leetcode506-Relative-Ranks" class="headerlink" title="Leetcode506. Relative Ranks"></a>Leetcode506. Relative Ranks</h1><p>Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: “Gold Medal”, “Silver Medal” and “Bronze Medal”.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [5, 4, 3, 2, 1]</span><br><span class="line">Output: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]</span><br><span class="line">Explanation: The first three athletes got the top three highest scores, so they got &quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;. For the left two athletes, you just need to output their relative ranks according to their scores.</span><br></pre></td></tr></table></figure><br>对于给予的得分情况，找出前三名并给予相应的称号，其余以数字作为其名词，记录每个元素的位置和元素值.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRelativeRanks</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            mp[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                res[mp[nums[i]]] = <span class="string">&quot;Gold Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">                res[mp[nums[i]]] = <span class="string">&quot;Silver Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>)</span><br><span class="line">                res[mp[nums[i]]] = <span class="string">&quot;Bronze Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> res[mp[nums[i]]] = <span class="built_in">to_string</span>(i<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>另一种做法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">findRelativeRanks</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dict;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) dict[-nums[i]] = i;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    vector&lt;string&gt; top3&#123;<span class="string">&quot;Gold Medal&quot;</span>, <span class="string">&quot;Silver Medal&quot;</span>, <span class="string">&quot;Bronze Medal&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [k, i]: dict)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt &lt;=<span class="number">3</span>) ans[i] = top3[cnt<span class="number">-1</span>];            </span><br><span class="line">        <span class="keyword">else</span> ans[i] = <span class="built_in">to_string</span>(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode507-Perfect-Number"><a href="#Leetcode507-Perfect-Number" class="headerlink" title="Leetcode507. Perfect Number"></a>Leetcode507. Perfect Number</h1><p>We define the Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself.</p>
<p>Now, given an integer n, write a function that returns true when it is a perfect number and false when it is not.<br>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 28</span><br><span class="line">Output: True</span><br><span class="line">Explanation: 28 = 1 + 2 + 4 + 7 + 14</span><br></pre></td></tr></table></figure><br>把一个数的所有因子找出来然后求和，找一个数的所有因子的时候，并不是从 1 开始直到自身，而是从 1 开始直到 sqrt(自身)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkPerfectNumber</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num/<span class="number">2</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num%i == <span class="number">0</span>)</span><br><span class="line">                sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode508-Most-Frequent-Subtree-Sum"><a href="#Leetcode508-Most-Frequent-Subtree-Sum" class="headerlink" title="Leetcode508. Most Frequent Subtree Sum"></a>Leetcode508. Most Frequent Subtree Sum</h1><p>Given the root of a binary tree, return the most frequent subtree sum. If there is a tie, return all the values with the highest frequency in any order.</p>
<p>The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself).</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,2,-3]</span><br><span class="line">Output: [2,-3,4]</span><br></pre></td></tr></table></figure><br><img src="/img/20210710170900.jpg" alt=""></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,2,-5]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure><br><img src="/img/20210710170901.jpg" alt=""></p>
<p>这道题给了我们一个二叉树，让我们求出现频率最高的子树之和，求树的结点和并不是很难，就是遍历所有结点累加起来即可。那么这道题的暴力解法就是遍历每个结点，对于每个结点都看作子树的根结点，然后再遍历子树所有结点求和，这样也许可以通过 OJ，但是绝对不是最好的方法。我们想下子树有何特点，必须是要有叶结点，单独的一个叶结点也可以当作是子树，那么子树是从下往上构建的，这种特点很适合使用后序遍历，我们使用一个 HashMap 来建立子树和跟其出现频率的映射，用一个变量 cnt 来记录当前最多的次数，递归函数返回的是以当前结点为根结点的子树结点值之和，然后在递归函数中，我们先对当前结点的左右子结点调用递归函数，然后加上当前结点值，然后更新对应的 HashMap 中的值，然后看此时 HashMap 中的值是否大于等于 cnt，大于的话首先要清空 res，等于的话不用，然后将 sum 值加入结果 res 中即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findFrequentTreeSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="built_in">dfs</span>(root, map, res, cnt);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;map, vector&lt;<span class="type">int</span>&gt;&amp; res, <span class="type">int</span> &amp;cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">dfs</span>(root-&gt;left, map, res, cnt);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">dfs</span>(root-&gt;right, map, res, cnt);</span><br><span class="line">        <span class="type">int</span> sum = left + right + root-&gt;val;</span><br><span class="line">        map[sum] ++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map[sum] &gt;= cnt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[sum] &gt; cnt)</span><br><span class="line">                res.<span class="built_in">clear</span>();</span><br><span class="line">            cnt = map[sum];</span><br><span class="line">            res.<span class="built_in">push_back</span>(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode509-Fibonacci-Number"><a href="#Leetcode509-Fibonacci-Number" class="headerlink" title="Leetcode509. Fibonacci Number"></a>Leetcode509. Fibonacci Number</h1><p>The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,</p>
<p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), for N &gt; 1.<br>Given N, calculate F(N).</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>0 ≤ N ≤ 30.</li>
</ul>
<p>斐波那契，不解释。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fib</span>(N<span class="number">-1</span>)+<span class="built_in">fib</span>(N<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>另外的解法：动态规划。使用数组存储以前计算的斐波纳契值。Time Complexity - O(N)，Space Complexity - O(N)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    <span class="type">int</span> memo[N<span class="number">+1</span>];</span><br><span class="line">    memo[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    memo[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=N; i++)</span><br><span class="line">        memo[i] = memo[i<span class="number">-1</span>] + memo[i<span class="number">-2</span>];</span><br><span class="line">    <span class="keyword">return</span> memo[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Solution 3：使用Imperative方法，我们通过循环并通过在两个变量中仅存储两个先前的斐波那契值来优化空间。Time Complexity - O(N)，Space Complexity - O(1)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N &lt; <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode513-Find-Bottom-Left-Tree-Value"><a href="#Leetcode513-Find-Bottom-Left-Tree-Value" class="headerlink" title="Leetcode513. Find Bottom Left Tree Value"></a>Leetcode513. Find Bottom Left Tree Value</h1><p>Given the root of a binary tree, return the leftmost value in the last row of the tree.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [2,1,3]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><br><img src="/img/20210710170902.jpg" alt=""></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,null,5,6,null,null,7]</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure><br><img src="/img/20210710170903.jpg" alt=""></p>
<p>这道题让我们求二叉树的最左下树结点的值，也就是最后一行左数第一个值，那么我首先想的是用先序遍历来做，我们维护一个最大深度和该深度的结点值，由于先序遍历遍历的顺序是根-左-右，所以每一行最左边的结点肯定最先遍历到，那么由于是新一行，那么当前深度肯定比之前的最大深度大，所以我们可以更新最大深度为当前深度，结点值res为当前结点值，这样在遍历到该行其他结点时就不会更新结果res了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res, max_depth = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>, max_depth, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> depth, <span class="type">int</span>&amp; max_depth, <span class="type">int</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, depth<span class="number">+1</span>, max_depth, res);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, depth<span class="number">+1</span>, max_depth, res);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (depth &gt; max_depth) &#123;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            max_depth = depth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode515-Find-Largest-Value-in-Each-Tree-Row"><a href="#Leetcode515-Find-Largest-Value-in-Each-Tree-Row" class="headerlink" title="Leetcode515. Find Largest Value in Each Tree Row"></a>Leetcode515. Find Largest Value in Each Tree Row</h1><p>Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed).</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,3,2,5,3,null,9]</span><br><span class="line">Output: [1,3,9]</span><br></pre></td></tr></table></figure><br><img src="/img/20210710170904.jpg" alt=""></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3]</span><br><span class="line">Output: [1,3]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,null,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure></p>
<p>这道题让我们找二叉树每行的最大的结点值，那么实际上最直接的方法就是用层序遍历，然后在每一层中找到最大值，加入结果res中即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> maxx = INT_MIN;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++) &#123;</span><br><span class="line">                TreeNode* temp = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                maxx = <span class="built_in">max</span>(maxx, temp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;left) q.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;right) q.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(maxx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode516-Longest-Palindromic-Subsequence"><a href="#Leetcode516-Longest-Palindromic-Subsequence" class="headerlink" title="Leetcode516. Longest Palindromic Subsequence"></a>Leetcode516. Longest Palindromic Subsequence</h1><p>Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;bbbab&quot;</span><br><span class="line">Output: 4</span><br><span class="line">One possible longest palindromic subsequence is “bbbb”.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: 2</span><br><span class="line">One possible longest palindromic subsequence is “bb”.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= s.length &lt;= 1000</li>
<li>s consists only of lowercase English letters.</li>
</ul>
<p>这道题给了我们一个字符串，让求最大的回文子序列，子序列和子字符串不同，不需要连续。而关于回文串的题之前也做了不少，处理方法上就是老老实实的两两比较吧。像这种有关极值的问题，最应该优先考虑的就是贪婪算法和动态规划，这道题显然使用DP更加合适。这里建立一个二维的DP数组，其中<code>dp[i][j]</code>表示<code>[i,j]</code>区间内的字符串的最长回文子序列，那么对于递推公式分析一下，如果<code>s[i]==s[j]</code>，那么i和j就可以增加2个回文串的长度，我们知道中间<code>dp[i + 1][j - 1]</code>的值，那么其加上2就是<code>dp[i][j]</code>的值。如果<code>s[i] != s[j]</code>，就可以去掉i或j其中的一个字符，然后比较两种情况下所剩的字符串谁dp值大，就赋给<code>dp[i][j]</code>，那么递推公式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              /  dp[i + 1][j - 1] + 2                       if (s[i] == s[j])</span><br><span class="line">dp[i][j] =</span><br><span class="line">              \  max(dp[i + 1][j], dp[i][j - 1])        if (s[i] != s[j])</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是递归形式的解法，memo 数组这里起到了一个缓存已经计算过了的结果，这样能提高运算效率，使其不会 TLE，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(s, <span class="number">0</span>, n - <span class="number">1</span>, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(string&amp; s, <span class="type">int</span> i, <span class="type">int</span> j, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != <span class="number">-1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">            memo[i][j] = <span class="built_in">helper</span>(s, i + <span class="number">1</span>, j - <span class="number">1</span>, memo) + <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            memo[i][j] = <span class="built_in">max</span>(<span class="built_in">helper</span>(s, i + <span class="number">1</span>, j, memo), <span class="built_in">helper</span>(s, i, j - <span class="number">1</span>, memo));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode518-Coin-Change-2"><a href="#Leetcode518-Coin-Change-2" class="headerlink" title="Leetcode518. Coin Change 2"></a>Leetcode518. Coin Change 2</h1><p>You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.</p>
<p>Note: You can assume that</p>
<ul>
<li>0 &lt;= amount &lt;= 5000</li>
<li>1 &lt;= coin &lt;= 5000</li>
<li>the number of coins is less than 500</li>
<li>the answer is guaranteed to fit into signed 32-bit integer</li>
</ul>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: amount = 5, coins = [1, 2, 5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: there are four ways to make up the amount:</span><br><span class="line">5=5</span><br><span class="line">5=2+2+1</span><br><span class="line">5=2+1+1+1</span><br><span class="line">5=1+1+1+1+1</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: amount = 3, coins = [2]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: the amount of 3 cannot be made up just with coins of 2.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: amount = 10, coins = [10] </span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>这道题是之前那道 Coin Change 的拓展，那道题问我们最少能用多少个硬币组成给定的钱数，而这道题问的是组成给定钱数总共有多少种不同的方法。还是要使用 DP 来做，首先来考虑最简单的情况，如果只有一个硬币的话，那么给定钱数的组成方式就最多有1种，就看此钱数能否整除该硬币值。当有两个硬币的话，组成某个钱数的方式就可能有多种，比如可能由每种硬币单独来组成，或者是两种硬币同时来组成，怎么量化呢？比如我们有两个硬币 [1,2]，钱数为5，那么钱数的5的组成方法是可以看作两部分组成，一种是由硬币1单独组成，那么仅有一种情况 (1+1+1+1+1)；另一种是由1和2共同组成，说明组成方法中至少需要有一个2，所以此时先取出一个硬币2，然后只要拼出钱数为3即可，这个3还是可以用硬币1和2来拼，所以就相当于求由硬币 [1,2] 组成的钱数为3的总方法。是不是不太好理解，多想想。这里需要一个二维的 dp 数组，其中 dp[i][j] 表示用前i个硬币组成钱数为j的不同组合方法，怎么算才不会重复，也不会漏掉呢？我们采用的方法是一个硬币一个硬币的增加，每增加一个硬币，都从1遍历到 amount，对于遍历到的当前钱数j，组成方法就是不加上当前硬币的拼法 dp[i-1][j]，还要加上，去掉当前硬币值的钱数的组成方法，当然钱数j要大于当前硬币值，状态转移方程也在上面的分析中得到了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - 1][j] + (j &gt;= coins[i - 1] ? dp[i][j - coins[i - 1]] : 0)</span><br></pre></td></tr></table></figure><br>注意要初始化每行的第一个位置为0，参见代码如下：      </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(coins.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(amount + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= coins.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= amount; ++j) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + (j &gt;= coins[i - <span class="number">1</span>] ? dp[i][j - coins[i - <span class="number">1</span>]] : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[coins.<span class="built_in">size</span>()][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以对空间进行优化，由于<code>dp[i][j]</code>仅仅依赖于<code>dp[i - 1][j]</code>和<code>dp[i][j - coins[i - 1]]</code>这两项，就可以使用一个一维dp数组来代替，此时的<code>dp[i]</code>表示组成钱数i的不同方法。其实最开始的时候，博主就想着用一维的 dp 数组来写，但是博主开始想的方法是把里面两个 for 循环调换了一个位置，结果计算的种类数要大于正确答案，所以一定要注意 for 循环的顺序不能搞反，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = coin; i &lt;= amount; ++i) &#123;</span><br><span class="line">                dp[i] += dp[i - coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 CareerCup 中，有一道极其相似的题 9.8 Represent N Cents 美分的组成，书里面用的是那种递归的方法，博主想将其解法直接搬到这道题里，但是失败了，博主发现使用那种的递归的解法必须要有值为1的硬币存在，这点无法在这道题里满足。你以为这样博主就没有办法了吗？当然有，博主加了判断，当用到最后一个硬币时，判断当前还剩的钱数是否能整除这个硬币，不能的话就返回0，否则返回1。还有就是用二维数组的 memo 会 TLE，所以博主换成了 map，就可以通过啦～</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (coins.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; memo;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(amount, coins, <span class="number">0</span>, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> idx, map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (idx &gt;= coins.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (idx == coins.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> amount % coins[idx] == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo.<span class="built_in">count</span>(&#123;amount, idx&#125;)) <span class="keyword">return</span> memo[&#123;amount, idx&#125;];</span><br><span class="line">        <span class="type">int</span> val = coins[idx], res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i * val &lt;= amount; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> rem = amount - i * val;</span><br><span class="line">            res += <span class="built_in">helper</span>(rem, coins, idx + <span class="number">1</span>, memo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[&#123;amount, idx&#125;] = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode519-Random-Flip-Matrix"><a href="#Leetcode519-Random-Flip-Matrix" class="headerlink" title="Leetcode519. Random Flip Matrix"></a>Leetcode519. Random Flip Matrix</h1><p>You are given the number of rows n_rows and number of columns n_cols of a 2D binary matrix where all values are initially 0. Write a function flip which chooses a 0 value uniformly at random, changes it to 1, and then returns the position [row.id, col.id] of that value. Also, write a function reset which sets all values back to 0. Try to minimize the number of calls to system’s Math.random() and optimize the time and space complexity.</p>
<p>Note:</p>
<ul>
<li>1 &lt;= n_rows, n_cols &lt;= 10000</li>
<li>0 &lt;= row.id &lt; n_rows and 0 &lt;= col.id &lt; n_cols</li>
<li>flip will not be called when the matrix has no 0 values left.</li>
<li>the total number of calls to flip and reset will not exceed 1000.</li>
</ul>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;Solution&quot;,&quot;flip&quot;,&quot;flip&quot;,&quot;flip&quot;,&quot;flip&quot;]</span><br><span class="line">[[2,3],[],[],[],[]]</span><br><span class="line">Output: [null,[0,1],[1,2],[1,0],[1,1]]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;Solution&quot;,&quot;flip&quot;,&quot;flip&quot;,&quot;reset&quot;,&quot;flip&quot;]</span><br><span class="line">[[1,2],[],[],[],[]]</span><br><span class="line">Output: [null,[0,0],[0,1],null,[0,0]]</span><br><span class="line">Explanation of Input Syntax:</span><br><span class="line">The input is two lists: the subroutines called and their arguments. Solution&#x27;s constructor has two arguments, n_rows and n_cols. flip and resethave no arguments. Arguments are always wrapped with a list, even if there aren&#x27;t any.</span><br></pre></td></tr></table></figure><br>这道题给了一个矩形的长和宽，让每次随机翻转其中的一个点，其中的隐含条件是，之前翻转过的点，下一次不能再翻转回来，而随机生成点是有可能有重复的，一旦很多点都被翻转后，很大概率会重复生成之前的点，所以需要有去重复的操作，而这也是本题的难点所在。可以用一个 HashSet 来记录翻转过了点，这样也方便进行查重操作。所以每次都随机出一个长和宽，然后看这个点是否已经在 HashSe t中了，不在的话，就加入 HashSet，然后返回即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(<span class="type">int</span> n_rows, <span class="type">int</span> n_cols) &#123;</span><br><span class="line">        row = n_rows; col = n_cols;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">rand</span>() % row, y = <span class="built_in">rand</span>() % col;</span><br><span class="line">            <span class="keyword">if</span> (!flipped.<span class="built_in">count</span>(x * col + y)) &#123;</span><br><span class="line">                flipped.<span class="built_in">insert</span>(x * col + y);</span><br><span class="line">                <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flipped.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> row, col;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; flipped;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode520-Detect-Capital"><a href="#Leetcode520-Detect-Capital" class="headerlink" title="Leetcode520. Detect Capital"></a>Leetcode520. Detect Capital</h1><p>Given a word, you need to judge whether the usage of capitals in it is right or not.</p>
<p>We define the usage of capitals in a word to be right when one of the following cases holds:</p>
<ul>
<li>All letters in this word are capitals, like “USA”.</li>
<li>All letters in this word are not capitals, like “leetcode”.</li>
<li>Only the first letter in this word is capital, like “Google”.</li>
<li>Otherwise, we define that this word doesn’t use capitals in a right way.</li>
</ul>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;USA&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;FlaG&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><br>看一个单词是不是只有第一个字母是大写的，或者是所有字母都是大写/小写。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isbig</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">detectCapitalUse</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isbig</span>(word[<span class="number">0</span>]))</span><br><span class="line">            flag = <span class="built_in">isbig</span>(word[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; word.<span class="built_in">length</span>(); i ++)</span><br><span class="line">            <span class="keyword">if</span>(flag != <span class="built_in">isbig</span>(word[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode521-Longest-Uncommon-Subsequence-I"><a href="#Leetcode521-Longest-Uncommon-Subsequence-I" class="headerlink" title="Leetcode521. Longest Uncommon Subsequence I"></a>Leetcode521. Longest Uncommon Subsequence I</h1><p>Given two strings, you need to find the longest uncommon subsequence of this two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other string.</p>
<p>A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.</p>
<p>The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: a = &quot;aba&quot;, b = &quot;cdc&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest uncommon subsequence is &quot;aba&quot;, </span><br><span class="line">because &quot;aba&quot; is a subsequence of &quot;aba&quot;, </span><br><span class="line">but not a subsequence of the other string &quot;cdc&quot;.</span><br><span class="line">Note that &quot;cdc&quot; can be also a longest uncommon subsequence.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a = &quot;aaa&quot;, b = &quot;bbb&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><br>如果两个元素不等长，那么其中长字符本身就不是另一个字符的子序列，输出长度就行，如果等长，那么如果两个字符串相同，返回-1，不同返回长度，因为一个不是另一个的子序列。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLUSlength</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a == b ? <span class="number">-1</span> : <span class="built_in">max</span>(a.<span class="built_in">length</span>(), b.<span class="built_in">length</span>()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode522-Longest-Uncommon-Subsequence-II-题解"><a href="#Leetcode522-Longest-Uncommon-Subsequence-II-题解" class="headerlink" title="Leetcode522. Longest Uncommon Subsequence II  题解"></a>Leetcode522. Longest Uncommon Subsequence II  题解</h1><p>Given a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.</p>
<p>A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.</p>
<p>The input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aba&quot;, &quot;cdc&quot;, &quot;eae&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Note:</span><br><span class="line">All the given strings&#x27; lengths will not exceed 10.</span><br><span class="line">The length of the given list will be in the range of [2, 50].</span><br></pre></td></tr></table></figure></p>
<p>由题意知，给定一个装有多个字符串的容器，我们需要找到其中最长的“非公共子序列”的长度。其中，这里的“子序列”是指：对于一个字符串，去掉这个字符串中任意几个字符，但剩余的字符在这个字符串中相对位置不变的字符串。“非公共子序列”是指某字符串与容器中其它任意字符串都不会构成如上定义的“子序列”关系，即某字符串不是其它字符串的“子序列”。</p>
<p>我们用双重for循环遍历的方法来做这道题，对于每个字符串，使其与其它字符串相比较，当两个字符串相同时，直接跳过。如果一个字符串不是其它任意一个字符串的“子序列”，那么这个字符串就是一个如上定义的“非公共子序列”，我们记录下它的长度。最后取最长的“非公共子序列”的长度返回。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLUSlength</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">issubstr</span>(strs[j], strs[i]))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == len)</span><br><span class="line">                res = <span class="built_in">max</span>(res, (<span class="type">int</span>)(strs[i].<span class="built_in">length</span>()));</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">issubstr</span><span class="params">(string&amp; str1, string&amp; str2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len1 = str<span class="number">1.l</span>ength(), len2 = str<span class="number">2.l</span>ength();</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; len1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p2 &gt;= len2)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (str1[p1] == str2[p2])</span><br><span class="line">                p2 ++;</span><br><span class="line">            p1 ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p2 == len2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode523-Continuous-Subarray-Sum"><a href="#Leetcode523-Continuous-Subarray-Sum" class="headerlink" title="Leetcode523. Continuous Subarray Sum"></a>Leetcode523. Continuous Subarray Sum</h1><p>Given an integer array nums and an integer k, return true if nums has a continuous subarray of size at least two whose elements sum up to a multiple of k, or false otherwise.</p>
<p>An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [23,2,4,6,7], k = 6</span><br><span class="line">Output: true</span><br><span class="line">Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [23,2,6,4,7], k = 6</span><br><span class="line">Output: true</span><br><span class="line">Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.</span><br><span class="line">42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [23,2,6,4,7], k = 13</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个数组和一个数字k，让求是否存在这样的一个连续的子数组，该子数组的数组之和可以整除k。</p>
<p>下面这种方法用了些技巧，那就是，若数字a和b分别除以数字c，若得到的余数相同，那么 (a-b) 必定能够整除c。用一个集合 HashSet 来保存所有出现过的余数，如果当前的累加和除以k得到的余数在 HashSet 中已经存在了，那么说明之前必定有一段子数组和可以整除k。需要注意的是k为0的情况，由于无法取余，就把当前累加和放入 HashSet 中。还有就是题目要求子数组至少需要两个数字，那么需要一个变量 pre 来记录之前的和，每次存入 HashSet 中的是 pre，而不是当前的累积和，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkSubarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), sum = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="type">int</span> t = (k == <span class="number">0</span>) ? sum : (sum % k);</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">count</span>(t)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            st.<span class="built_in">insert</span>(pre);</span><br><span class="line">            pre = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>既然 HashSet 可以做，一般来说用 HashMap 也可以做，这里我们建立余数和当前位置之间的映射，由于有了位置信息，就不需要 pre 变量了，之前用保存的坐标和当前位置i比较判断就可以了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkSubarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), sum = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m&#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="type">int</span> t = (k == <span class="number">0</span>) ? sum : (sum % k);</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(t)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - m[t] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> m[t] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode524-Longest-Word-in-Dictionary-through-Deleting"><a href="#Leetcode524-Longest-Word-in-Dictionary-through-Deleting" class="headerlink" title="Leetcode524. Longest Word in Dictionary through Deleting"></a>Leetcode524. Longest Word in Dictionary through Deleting</h1><p>Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</span><br><span class="line">Output: &quot;apple&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abpcplea&quot;, d = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line">Output: &quot;a&quot;</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>All the strings in the input will only contain lower-case letters.</li>
<li>The size of the dictionary won’t exceed 1,000.</li>
<li>The length of all the strings in the input won’t exceed 1,000.</li>
</ul>
<p>这道题给了我们一个字符串，和一个字典，让我们找到字典中最长的一个单词，这个单词可以通过给定单词通过删除某些字符得到。由于只能删除某些字符，并不能重新排序，所以我们不能通过统计字符出现个数的方法来判断是否能得到该单词，而是只能老老实实的按顺序遍历每一个字符。我们可以给字典排序，通过重写comparator来实现按长度由大到小来排，如果长度相等的就按字母顺序来排。然后我们开始遍历每一个单词，用一个变量i来记录单词中的某个字母的位置，我们遍历给定字符串，如果遍历到单词中的某个字母来，i自增1，如果没有，就继续往下遍历。这样如果最后i和单词长度相等，说明单词中的所有字母都按顺序出现在了字符串s中，由于字典中的单词已经按要求排过序了，所以第一个通过验证的单词一定是正确答案，我们直接返回当前单词即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">comp</span><span class="params">(string&amp; a, string&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">length</span>() == b.<span class="built_in">length</span>())</span><br><span class="line">            <span class="keyword">return</span> a &lt; b;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">length</span>() &gt; b.<span class="built_in">length</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">findLongestWord</span><span class="params">(string s, vector&lt;string&gt;&amp; dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lens = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="built_in">sort</span>(dictionary.<span class="built_in">begin</span>(), dictionary.<span class="built_in">end</span>(), comp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dictionary.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="type">int</span> ps = <span class="number">0</span>, pd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s.<span class="built_in">length</span>(); j ++)</span><br><span class="line">                <span class="keyword">if</span> (s[j] == dictionary[i][pd])</span><br><span class="line">                    pd ++;</span><br><span class="line">            <span class="keyword">if</span> (pd == dictionary[i].<span class="built_in">length</span>())</span><br><span class="line">                <span class="keyword">return</span> dictionary[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode525-Contiguous-Array"><a href="#Leetcode525-Contiguous-Array" class="headerlink" title="Leetcode525. Contiguous Array"></a>Leetcode525. Contiguous Array</h1><p>Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [0,1,0]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个二进制的数组，让找邻近的子数组使其0和1的个数相等。对于求子数组的问题，需要时刻记着求累积和是一种很犀利的工具，但是这里怎么将子数组的和跟0和1的个数之间产生联系呢？这里需要用到一个 trick，遇到1就加1，遇到0，就减1，这样如果某个子数组和为0，就说明0和1的个数相等。知道了这一点，就用一个 HashMap 建立子数组之和跟结尾位置的坐标之间的映射。如果某个子数组之和在 HashMap 里存在了，说明当前子数组减去 HashMap 中存的那个子数组，得到的结果是中间一段子数组之和，必然为0，说明0和1的个数相等，更新结果 res。注意这里需要在 HashMap 初始化一个 0 -&gt; -1 的映射，这是为了当 sum 第一次出现0的时候，即这个子数组是从原数组的起始位置开始，需要计算这个子数组的长度，而不是建立当前子数组之和 sum 和其结束位置之间的映射。比如就拿例子1来说，nums = [0, 1]，当遍历0的时候，sum = -1，此时建立 -1 -&gt; 0 的映射，当遍历到1的时候，此时 sum = 0 了，若 HashMap 中没有初始化一个 0 -&gt; -1 的映射，此时会建立 0 -&gt; 1 的映射，而不是去更新这个满足题意的子数组的长度，所以要这么初始化，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m&#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>)</span><br><span class="line">                sum ++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sum --;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(sum))</span><br><span class="line">                res = <span class="built_in">max</span>(res, i-m[sum]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                m[sum] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode526-Beautiful-Arrangement"><a href="#Leetcode526-Beautiful-Arrangement" class="headerlink" title="Leetcode526. Beautiful Arrangement"></a>Leetcode526. Beautiful Arrangement</h1><p>Suppose you have n integers labeled 1 through n. A permutation of those n integers perm (1-indexed) is considered a beautiful arrangement if for every i (1 &lt;= i &lt;= n), either of the following is true:</p>
<ul>
<li>perm[i] is divisible by i.</li>
<li>i is divisible by perm[i].</li>
</ul>
<p>Given an integer n, return the number of the beautiful arrangements that you can construct.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">The first beautiful arrangement is [1,2]:</span><br><span class="line">    - perm[1] = 1 is divisible by i = 1</span><br><span class="line">    - perm[2] = 2 is divisible by i = 2</span><br><span class="line">The second beautiful arrangement is [2,1]:</span><br><span class="line">    - perm[1] = 2 is divisible by i = 1</span><br><span class="line">    - i = 2 is divisible by perm[2] = 1</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们1到N，总共N个正数，然后定义了一种优美排列方式，对于该排列中的所有数，如果数字可以整除下标，或者下标可以整除数字，那么我们就是优美排列，让我们求出所有优美排列的个数。那么对于求种类个数，或者是求所有情况，这种问题通常要用递归来做，递归简直是暴力的不能再暴力的方法了。而递归方法等难点在于写递归函数，如何确定终止条件，还有for循环中变量的起始位置如何确定。那么这里我们需要一个visited数组来记录数字是否已经访问过，因为优美排列中不能有重复数字。我们用变量pos来标记已经生成的数字的个数，如果大于N了，说明已经找到了一组排列，结果res自增1。在for循环中，i应该从1开始，因为我们遍历1到N中的所有数字，如果该数字未被使用过，且满足和坐标之间的整除关系，那么我们标记该数字已被访问过，再调用下一个位置的递归函数，之后不要忘记了恢复初始状态，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countArrangement</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(n, <span class="number">1</span>, visited, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> cur, vector&lt;<span class="type">bool</span>&gt; visited, <span class="type">int</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur &gt; n) &#123;</span><br><span class="line">            res ++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i<span class="number">-1</span>] || (i%cur != <span class="number">0</span> &amp;&amp; cur%i != <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            visited[i<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(n, cur<span class="number">+1</span>, visited, res);</span><br><span class="line">            visited[i<span class="number">-1</span>] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode528-Random-Pick-with-Weight"><a href="#Leetcode528-Random-Pick-with-Weight" class="headerlink" title="Leetcode528. Random Pick with Weight"></a>Leetcode528. Random Pick with Weight</h1><p>Given an array w of positive integers, where w[i] describes the weight of index i, write a function pickIndex which randomly picks an index in proportion to its weight.</p>
<p>Note:</p>
<ul>
<li>1 &lt;= w.length &lt;= 10000</li>
<li>1 &lt;= w[i] &lt;= 10^5</li>
<li>pickIndex will be called at most 10000 times.</li>
</ul>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;Solution&quot;,&quot;pickIndex&quot;]</span><br><span class="line">[[[1]],[]]</span><br><span class="line">Output: [null,0]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;Solution&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;]</span><br><span class="line">[[[1,3]],[],[],[],[],[]]</span><br><span class="line">Output: [null,0,1,1,1,0]</span><br></pre></td></tr></table></figure></p>
<p>Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution‘s constructor has one argument, the array w. pickIndex has no arguments. Arguments are always wrapped with a list, even if there aren’t any.</p>
<p>这道题给了一个权重数组，让我们根据权重来随机取点，现在的点就不是随机等概率的选取了，而是要根据权重的不同来区别选取。比如题目中例子2，权重为 [1, 3]，表示有两个点，权重分别为1和3，那么就是说一个点的出现概率是四分之一，另一个出现的概率是四分之三。由于我们的rand()函数是等概率的随机，那么我们如何才能有权重的随机呢，我们可以使用一个trick，由于权重是1和3，相加为4，那么我们现在假设有4个点，然后随机等概率取一个点，随机到第一个点后就表示原来的第一个点，随机到后三个点就表示原来的第二个点，这样就可以保证有权重的随机啦。那么我们就可以建立权重数组的累加和数组，比如若权重数组为 [1, 3, 2] 的话，那么累加和数组为 [1, 4, 6]，整个的权重和为6，我们 rand() % 6，可以随机出范围 [0, 5] 内的数，随机到 0 则为第一个点，随机到 1，2，3 则为第二个点，随机到 4，5 则为第三个点，所以我们随机出一个数字x后，然后再累加和数组中查找第一个大于随机数x的数字，使用二分查找法可以找到第一个大于随机数x的数字的坐标，即为所求，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cumulative;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="type">int</span>&gt;&amp; w) &#123;</span><br><span class="line">        cumulative.<span class="built_in">resize</span>(w.<span class="built_in">size</span>(), w[<span class="number">0</span>]);</span><br><span class="line">        sum = w[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; w.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            cumulative[i] = cumulative[i<span class="number">-1</span>] + w[i];</span><br><span class="line">            sum += w[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">rand</span>() % sum;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = cumulative.<span class="built_in">size</span>()<span class="number">-1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            mid = left + (right-left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (cumulative[mid] &lt;= x)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode529-Minesweeper"><a href="#Leetcode529-Minesweeper" class="headerlink" title="Leetcode529. Minesweeper"></a>Leetcode529. Minesweeper</h1><p>Let’s play the minesweeper game (Wikipedia, online game)!</p>
<p>You are given an m x n char matrix board representing the game board where:</p>
<ul>
<li>‘M’ represents an unrevealed mine,</li>
<li>‘E’ represents an unrevealed empty square,</li>
<li>‘B’ represents a revealed blank square that has no adjacent mines (i.e., above, below, left, right, and all 4 diagonals),</li>
<li>digit (‘1’ to ‘8’) represents how many mines are adjacent to this revealed square, and</li>
<li>‘X’ represents a revealed mine.</li>
</ul>
<p>You are also given an integer array click where click = [clickr, clickc] represents the next click position among all the unrevealed squares (‘M’ or ‘E’).</p>
<p>Return the board after revealing this position according to the following rules:</p>
<ol>
<li>If a mine ‘M’ is revealed, then the game is over. You should change it to ‘X’.</li>
<li>If an empty square ‘E’ with no adjacent mines is revealed, then change it to a revealed blank ‘B’ and all of its adjacent unrevealed squares should be revealed recursively.</li>
<li>If an empty square ‘E’ with at least one adjacent mine is revealed, then change it to a digit (‘1’ to ‘8’) representing the number of adjacent mines.</li>
<li>Return the board when no more squares will be revealed.</li>
</ol>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board = [[&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;],[&quot;E&quot;,&quot;E&quot;,&quot;M&quot;,&quot;E&quot;,&quot;E&quot;],[&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;],[&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;]], click = [3,0]</span><br><span class="line">Output: [[&quot;B&quot;,&quot;1&quot;,&quot;E&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;M&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]]</span><br></pre></td></tr></table></figure><br><img src="/img/20210713170200_1.png" alt=""></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board = [[&quot;B&quot;,&quot;1&quot;,&quot;E&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;M&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]], click = [1,2]</span><br><span class="line">Output: [[&quot;B&quot;,&quot;1&quot;,&quot;E&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;X&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]]</span><br></pre></td></tr></table></figure><br><img src="/img/20210713170200_2.png" alt=""></p>
<p>这道题就是经典的扫雷游戏啦，经典到不能再经典，从Win98开始，附件中始终存在的游戏，和纸牌、红心大战、空当接龙一起称为四大天王，曾经消耗了博主太多的时间。小时侯一直不太会玩扫雷，就是瞎点，完全不根据数字分析，每次点几下就炸了，就觉得这个游戏好无聊。后来长大了一些，慢慢的理解了游戏的玩法，才发现这个游戏果然很经典，就像破解数学难题一样，充满了挑战与乐趣。花样百出的LeetCode这次把扫雷出成题，让博主借机回忆了一把小时侯，不错不错，那么来做题吧。题目中图文并茂，相信就算是没玩过扫雷的也能弄懂了，而且规则也说的比较详尽了，那么我们相对应的做法也就明了了。对于当前需要点击的点，我们先判断是不是雷，是的话直接标记X返回即可。如果不是的话，我们就数该点周围的雷个数，如果周围有雷，则当前点变为雷的个数并返回。如果没有的话，我们再对周围所有的点调用递归函数再点击即可。参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; <span class="built_in">updateBoard</span>(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;<span class="type">int</span>&gt;&amp; click) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board.<span class="built_in">empty</span>() || board[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>(), row = click[<span class="number">0</span>], col = click[<span class="number">1</span>], cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[row][col] == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">            board[row][col] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-1</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-1</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                    <span class="type">int</span> x = row + i, y = col + j;</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (board[x][y] == <span class="string">&#x27;M&#x27;</span>) ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                board[row][col] = cnt + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                board[row][col] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-1</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-1</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                        <span class="type">int</span> x = row + i, y = col + j;</span><br><span class="line">                        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span> (board[x][y] == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">                            vector&lt;<span class="type">int</span>&gt; nextPos&#123;x, y&#125;;</span><br><span class="line">                            <span class="built_in">updateBoard</span>(board, nextPos);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面这种解法跟上面的解法思路基本一样，写法更简洁了一些。可以看出上面的解法中的那两个for循环出现了两次，这样显得代码比较冗余，一般来说对于重复代码是要抽离成函数的，但那样还要多加个函数，也麻烦。我们可以根据第一次找周围雷个数的时候，若此时cnt个数为0并且标识是E的位置记录下来，那么如果最后雷个数确实为0了的话，我们直接遍历我们保存下来为E的位置调用递归函数即可，就不用再写两个for循环了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; <span class="built_in">updateBoard</span>(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;<span class="type">int</span>&gt;&amp; click) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board.<span class="built_in">empty</span>() || board[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>(), row = click[<span class="number">0</span>], col = click[<span class="number">1</span>], cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[row][col] == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">            board[row][col] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; neighbors;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-1</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-1</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                    <span class="type">int</span> x = row + i, y = col + j;</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (board[x][y] == <span class="string">&#x27;M&#x27;</span>) ++cnt;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">0</span> &amp;&amp; board[x][y] == <span class="string">&#x27;E&#x27;</span>) neighbors.<span class="built_in">push_back</span>(&#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                board[row][col] = cnt + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> a : neighbors) &#123;</span><br><span class="line">                    board[a[<span class="number">0</span>]][a[<span class="number">1</span>]] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">                    <span class="built_in">updateBoard</span>(board, a);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面这种方法是上面方法的迭代写法，用queue来存储之后要遍历的位置，这样就不用递归调用函数了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; <span class="built_in">updateBoard</span>(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;<span class="type">int</span>&gt;&amp; click) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board.<span class="built_in">empty</span>() || board[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">q</span>(&#123;&#123;click[<span class="number">0</span>], click[<span class="number">1</span>]&#125;&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> row = q.<span class="built_in">front</span>().first, col = q.<span class="built_in">front</span>().second, cnt = <span class="number">0</span>; q.<span class="built_in">pop</span>();</span><br><span class="line">            vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; neighbors;</span><br><span class="line">            <span class="keyword">if</span> (board[row][col] == <span class="string">&#x27;M&#x27;</span>) board[row][col] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-1</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-1</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                        <span class="type">int</span> x = row + i, y = col + j;</span><br><span class="line">                        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span> (board[x][y] == <span class="string">&#x27;M&#x27;</span>) ++cnt;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">0</span> &amp;&amp; board[x][y] == <span class="string">&#x27;E&#x27;</span>) neighbors.<span class="built_in">push_back</span>(&#123;x, y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) board[row][col] = cnt + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> a : neighbors) &#123;</span><br><span class="line">                    board[a.first][a.second] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(a);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode530-Minimum-Absolute-Difference-in-BST"><a href="#Leetcode530-Minimum-Absolute-Difference-in-BST" class="headerlink" title="Leetcode530. Minimum Absolute Difference in BST"></a>Leetcode530. Minimum Absolute Difference in BST</h1><p>Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">    /</span><br><span class="line">   2</span><br><span class="line">Output:</span><br><span class="line">1</span><br></pre></td></tr></table></figure><br>Explanation:<br>The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).</p>
<p>这道题给了我们一棵二叉搜索树，让我们求任意个节点值之间的最小绝对差。由于BST的左&lt;根&lt;右的性质可知，如果按照中序遍历会得到一个有序数组，那么最小绝对差肯定在相邻的两个节点值之间产生。所以我们的做法就是对BST进行中序遍历，然后当前节点值和之前节点值求绝对差并更新结果res。这里需要注意的就是在处理第一个节点值时，由于其没有前节点，所以不能求绝对差。这里我们用变量pre来表示前节点值，这里由于题目中说明了所以节点值不为负数，所以我们给pre初始化-1，这样我们就知道pre是否存在。如果没有题目中的这个非负条件，那么就不能用int变量来，必须要用指针，通过来判断是否为指向空来判断前结点是否存在。还好这里简化了问题，用-1就能搞定了，这里我们先来看中序遍历的递归写法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, <span class="type">int</span> &amp;pre, <span class="type">int</span> &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left, pre, res);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="number">-1</span>)</span><br><span class="line">            res = <span class="built_in">min</span>(<span class="built_in">abs</span>(pre-root-&gt;val), res);</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right, pre, res);</span><br><span class="line">    &#125; </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = INT_MAX, pre = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root, pre, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode532-K-diff-Pairs-in-an-Array"><a href="#Leetcode532-K-diff-Pairs-in-an-Array" class="headerlink" title="Leetcode532. K-diff Pairs in an Array"></a>Leetcode532. K-diff Pairs in an Array</h1><p>Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [3, 1, 4, 1, 5], k = 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).</span><br><span class="line">Although we have two 1s in the input, we should only return the number of unique pairs.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input:[1, 2, 3, 4, 5], k = 1</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 3, 1, 5, 4], k = 0</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: There is one 0-diff pair in the array, (1, 1).</span><br></pre></td></tr></table></figure><br>这道题给了我们一个含有重复数字的无序数组，还有一个整数k，让找出有多少对不重复的数对 (i, j) 使得i和j的差刚好为k。由于k有可能为0，而只有含有至少两个相同的数字才能形成数对，那么就是说需要统计数组中每个数字的个数。可以建立每个数字和其出现次数之间的映射，然后遍历 HashMap 中的数字，如果k为0且该数字出现的次数大于1，则结果 res 自增1；如果k不为0，且用当前数字加上k后得到的新数字也在数组中存在，则结果 res 自增1。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums)</span><br><span class="line">            mp[i] ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : mp) &#123;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span> &amp;&amp; i.second &gt; <span class="number">1</span>)</span><br><span class="line">                res ++;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; mp.<span class="built_in">count</span>(i.first+k)) &#123;</span><br><span class="line">                <span class="comment">//i.second --;</span></span><br><span class="line">                <span class="comment">//mp[i.first+k] --;</span></span><br><span class="line">                <span class="comment">// 不需要减1了，因为可以有重复。</span></span><br><span class="line">                res ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode535-Encode-and-Decode-TinyURL"><a href="#Leetcode535-Encode-and-Decode-TinyURL" class="headerlink" title="Leetcode535. Encode and Decode TinyURL"></a>Leetcode535. Encode and Decode TinyURL</h1><p>Note: This is a companion problem to the <a href="https://leetcode.com/discuss/interview-question/system-design/">System Design</a> problem: Design TinyURL</p>
<p>TinyURL is a URL shortening service where you enter a URL such as <a href="https://leetcode.com/problems/design-tinyurl">https://leetcode.com/problems/design-tinyurl</a> and it returns a short URL such as <a href="http://tinyurl.com/4e9iAk">http://tinyurl.com/4e9iAk</a>.</p>
<p>Design the encode and decode methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.</p>
<p>这道题其实不难，给一个url，要求转成一个短字符串，并且能还原出来。为什么专门做这种题呢，其实是想复习C++一些STL的用法，这道题涉及了string和map的用法，先讲题，再专门开两个md谈用法。我的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; map1;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; map2;</span><br><span class="line">    string s=<span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;</span>;</span><br><span class="line">    <span class="comment">// Encodes a URL to a shortened URL.</span></span><br><span class="line">    <span class="function">string <span class="title">encode</span><span class="params">(string longUrl)</span> </span>&#123;</span><br><span class="line">        map&lt;string,<span class="type">int</span>&gt;::iterator key = map<span class="number">1.f</span>ind(longUrl);</span><br><span class="line">	    <span class="keyword">if</span>(key==map<span class="number">1.</span><span class="built_in">end</span>())</span><br><span class="line">	    &#123;</span><br><span class="line">		    map<span class="number">1.</span><span class="built_in">insert</span>(map&lt;string, <span class="type">int</span>&gt;::<span class="built_in">value_type</span> (longUrl,map<span class="number">1.</span><span class="built_in">size</span>()<span class="number">+1</span>));</span><br><span class="line">            map<span class="number">2.</span><span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span> (map<span class="number">2.</span><span class="built_in">size</span>()<span class="number">+1</span>,longUrl));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n=map<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">string result;</span><br><span class="line">        <span class="comment">// n is the number of longUrl</span></span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d) &quot;</span>,n);</span><br><span class="line">            <span class="type">int</span> r = n%<span class="number">62</span>;</span><br><span class="line">            n /= <span class="number">62</span>;</span><br><span class="line">            result.<span class="built_in">append</span>(<span class="number">1</span>,s[r]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf(&quot;%s\n&quot;,result);</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a shortened URL to its original URL.</span></span><br><span class="line">    <span class="function">string <span class="title">decode</span><span class="params">(string shortUrl)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = shortUrl.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> val=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            val = val*<span class="number">62</span>+s.<span class="built_in">find</span>(shortUrl[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map<span class="number">2.f</span>ind(val)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Solution solution;</span></span><br><span class="line"><span class="comment">// solution.decode(solution.encode(url));</span></span><br></pre></td></tr></table></figure><br>别人的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    string alphabet = <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">    unordered_map&lt;string, string&gt; map;</span><br><span class="line">    string key = <span class="built_in">getRandom</span>();</span><br><span class="line">        </span><br><span class="line">    <span class="function">string <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span> ; i++) &#123;</span><br><span class="line">        s += alphabet[<span class="built_in">rand</span>() % <span class="number">61</span>]; &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// Encodes a URL to a shortened URL.    </span></span><br><span class="line">    <span class="function">string <span class="title">encode</span><span class="params">(string longUrl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(map.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            key = <span class="built_in">getRandom</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        map.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, longUrl));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://tinyurl.com/&quot;</span> + key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Decodes a shortened URL to its original URL.</span></span><br><span class="line">    <span class="function">string <span class="title">decode</span><span class="params">(string shortUrl)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> map.<span class="built_in">at</span>(shortUrl.<span class="built_in">replace</span>(<span class="number">0</span>,shortUrl.<span class="built_in">size</span>()<span class="number">-6</span>,<span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode537-Complex-Number-Multiplication"><a href="#Leetcode537-Complex-Number-Multiplication" class="headerlink" title="Leetcode537. Complex Number Multiplication"></a>Leetcode537. Complex Number Multiplication</h1><p>Given two strings representing two complex numbers. You need to return a string representing their multiplication. Note i2 = -1 according to the definition.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;1+1i&quot;, &quot;1+1i&quot;</span><br><span class="line">Output: &quot;0+2i&quot;</span><br><span class="line">Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;1+-1i&quot;, &quot;1+-1i&quot;</span><br><span class="line">Output: &quot;0+-2i&quot;</span><br><span class="line">Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.</span><br></pre></td></tr></table></figure><br>Note:</p>
<ul>
<li>The input strings will not have extra blank.</li>
<li>The input strings will be given in the form of a+bi, where the integer a and b will both belong to the range of [-100, 100]. - And the output should be also in this form.</li>
</ul>
<p>复数相乘，简单。两种做法，第一种我写的，自己实现字符串解析，memory用的少但是时间慢一些，第二种用了库，时间短但是memory用的多。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">cal</span><span class="params">(string a)</span></span>&#123;</span><br><span class="line">        pair&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; aa;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;a.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;(a[i]&lt;<span class="string">&#x27;0&#x27;</span>||a[i]&gt;<span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;a[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                temp=temp*<span class="number">10</span>+(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            temp=-temp;</span><br><span class="line">        <span class="type">int</span> j=i<span class="number">+1</span>,temp2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;a.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j!=i<span class="number">+1</span>&amp;&amp;(a[j]&lt;<span class="string">&#x27;0&#x27;</span>||a[j]&gt;<span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[j]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;a[j]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                temp2=temp2*<span class="number">10</span>+(a[j]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i<span class="number">+1</span>]==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            temp2=-temp2;</span><br><span class="line">        aa.first=temp;</span><br><span class="line">        aa.second=temp2;</span><br><span class="line">        <span class="keyword">return</span> aa;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">complexNumberMultiply</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        pair&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; aa,bb;</span><br><span class="line">        <span class="comment">//aa=cal(a);</span></span><br><span class="line">        <span class="comment">//bb=cal(b);</span></span><br><span class="line">        <span class="comment">//第一种</span></span><br><span class="line">        <span class="comment">//第二种</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;a.<span class="built_in">length</span>();i++)</span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        aa.first=<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(<span class="number">0</span>,i));</span><br><span class="line">        aa.second=<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(i<span class="number">+1</span>,a.<span class="built_in">length</span>()<span class="number">-2</span>-i));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;b.<span class="built_in">length</span>();i++)</span><br><span class="line">            <span class="keyword">if</span>(b[i]==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        bb.first=<span class="built_in">stoi</span>(b.<span class="built_in">substr</span>(<span class="number">0</span>,i));</span><br><span class="line">        bb.second=<span class="built_in">stoi</span>(b.<span class="built_in">substr</span>(i<span class="number">+1</span>,b.<span class="built_in">length</span>()<span class="number">-2</span>-i));</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> temp1,temp2;</span><br><span class="line">        temp1=aa.first*bb.first - aa.second*bb.second;</span><br><span class="line">        temp2=aa.first*bb.second + aa.second*bb.first;</span><br><span class="line">        </span><br><span class="line">        string res=<span class="built_in">to_string</span>(temp1)+<span class="string">&quot;+&quot;</span>+<span class="built_in">to_string</span>(temp2)+<span class="string">&quot;i&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode538-Convert-BST-to-Greater-Tree"><a href="#Leetcode538-Convert-BST-to-Greater-Tree" class="headerlink" title="Leetcode538. Convert BST to Greater Tree"></a>Leetcode538. Convert BST to Greater Tree</h1><p>Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: The root of a Binary Search Tree like this:</span><br><span class="line">              5</span><br><span class="line">            /   \</span><br><span class="line">           2     13</span><br><span class="line"></span><br><span class="line">Output: The root of a Greater Tree like this:</span><br><span class="line">             18</span><br><span class="line">            /   \</span><br><span class="line">          20     13</span><br></pre></td></tr></table></figure><br>这道题让我们将二叉搜索树转为较大树，通过题目汇总的例子可以明白，是把每个结点值加上所有比它大的结点值总和当作新的结点值。仔细观察题目中的例子可以发现，2变成了20，而20是所有结点之和，因为2是最小结点值，要加上其他所有结点值，所以肯定就是所有结点值之和。5变成了18，是通过20减去2得来的，而13还是13，是由20减去7得来的，而7是2和5之和。通过看论坛，发现还有更巧妙的方法，不用先求出的所有的结点值之和，而是巧妙的将中序遍历左根右的顺序逆过来，变成右根左的顺序，这样就可以反向计算累加和sum，同时更新结点值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, <span class="type">int</span>&amp; sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right, sum);</span><br><span class="line">        root-&gt;val += sum;</span><br><span class="line">        sum = root-&gt;val;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left, sum);   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root, sum);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode539-Minimum-Time-Difference"><a href="#Leetcode539-Minimum-Time-Difference" class="headerlink" title="Leetcode539. Minimum Time Difference"></a>Leetcode539. Minimum Time Difference</h1><p>Given a list of 24-hour clock time points in “Hour:Minutes” format, find the minimum minutes difference between any two time points in the list.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;23:59&quot;,&quot;00:00&quot;]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>The number of time points in the given list is at least 2 and won’t exceed 20000.</li>
<li>The input time is legal and ranges from 00:00 to 23:59.</li>
</ul>
<p>这道题给了我们一系列无序的时间点，让我们求最短的两个时间点之间的差值。那么最简单直接的办法就是给数组排序，这样时间点小的就在前面了，然后我们分别把小时和分钟提取出来，计算差值，注意唯一的特殊情况就是第一个和末尾的时间点进行比较，第一个时间点需要加上24小时再做差值，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">gettime</span><span class="params">(string&amp; timePoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;(timePoint[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span> + (timePoint[<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>), (timePoint[<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span> + (timePoint[<span class="number">4</span>]-<span class="string">&#x27;0&#x27;</span>)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinDifference</span><span class="params">(vector&lt;string&gt;&amp; timePoints)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = timePoints.<span class="built_in">size</span>(), res = INT_MAX, tmp;</span><br><span class="line">        <span class="built_in">sort</span>(timePoints.<span class="built_in">begin</span>(), timePoints.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; firsttime = <span class="built_in">gettime</span>(timePoints[<span class="number">0</span>]), secondtime;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            secondtime = <span class="built_in">gettime</span>(timePoints[(i<span class="number">+1</span>) % n]);</span><br><span class="line">            tmp = secondtime[<span class="number">1</span>]-firsttime[<span class="number">1</span>] + (secondtime[<span class="number">0</span>]-firsttime[<span class="number">0</span>])*<span class="number">60</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == n<span class="number">-1</span>)</span><br><span class="line">                tmp += <span class="number">24</span>*<span class="number">60</span>;</span><br><span class="line">            res = <span class="built_in">min</span>(res, tmp);</span><br><span class="line">            firsttime = secondtime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面这种写法跟上面的大体思路一样，写法上略有不同，是在一开始就把小时和分钟数提取出来并计算总分钟数存入一个新数组，然后再对新数组进行排序，再计算两两之差，最后还是要处理首尾之差，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gettime</span><span class="params">(string&amp; timePoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((timePoint[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span> + timePoint[<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">60</span> + (timePoint[<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span> + timePoint[<span class="number">4</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinDifference</span><span class="params">(vector&lt;string&gt;&amp; timePoints)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = timePoints.<span class="built_in">size</span>(), res = INT_MAX, tmp;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; times;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            times.<span class="built_in">push_back</span>(<span class="built_in">gettime</span>(timePoints[i]));</span><br><span class="line">        <span class="built_in">sort</span>(times.<span class="built_in">begin</span>(), times.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            tmp = times[(i<span class="number">+1</span>)%n] - times[i];</span><br><span class="line">            <span class="keyword">if</span> (i == n<span class="number">-1</span>)</span><br><span class="line">                tmp += <span class="number">24</span>*<span class="number">60</span>;</span><br><span class="line">            res = <span class="built_in">min</span>(res, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode540-Single-Element-in-a-Sorted-Array"><a href="#Leetcode540-Single-Element-in-a-Sorted-Array" class="headerlink" title="Leetcode540. Single Element in a Sorted Array"></a>Leetcode540. Single Element in a Sorted Array</h1><p>Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,2,3,3,4,4,8,8]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,3,7,7,10,11,11]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure></p>
<p>Note: Your solution should run in O(log n) time and O(1) space.</p>
<p>这道题给我们了一个有序数组，说是所有的元素都出现了两次，除了一个元素，让我们找到这个元素。如果没有时间复杂度的限制，我们可以用多种方法来做，最straightforward的解法就是用个双指针，每次检验两个，就能找出落单的。也可以像Single Number里的方法那样，将所有数字亦或起来，相同的数字都会亦或成0，剩下就是那个落单的数字。那么由于有了时间复杂度的限制，需要为O(logn)，而数组又是有序的，不难想到要用二分搜索法来做。二分搜索法的难点在于折半了以后，如何判断将要去哪个分支继续搜索，而这道题确实判断条件不明显，比如下面两个例子：</p>
<p>1  1  2  2  3</p>
<p>1  2  2  3  3</p>
<p>这两个例子初始化的时候left=0, right=4一样，mid算出来也一样为2，但是他们要去的方向不同，如何区分出来呢？仔细观察我们可以发现，如果当前数字出现两次的话，我们可以通过数组的长度跟当前位置的关系，计算出右边和当前数字不同的数字的总个数，如果是偶数个，说明落单数左半边，反之则在右半边。有了这个规律就可以写代码了，为啥我们直接就能跟mid+1比呢，不怕越界吗？当然不会，因为left如何跟right相等，就不会进入循环，所以mid一定会比right小，一定会有mid+1存在。当然mid是有可能为0的，所以此时当mid和mid+1的数字不等时，我们直接返回mid的数字就可以了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == nums[mid<span class="number">+1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((n<span class="number">-1</span>-mid) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                    right = mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid] != nums[mid<span class="number">-1</span>])</span><br><span class="line">                    <span class="keyword">return</span> nums[mid];</span><br><span class="line">                <span class="keyword">if</span> ((n<span class="number">-1</span>-mid) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面这种解法是对上面的分支进行合并，使得代码非常的简洁。使用到了亦或1这个小技巧，为什么要亦或1呢，原来我们可以将坐标两两归为一对，比如0和1，2和3，4和5等等。而亦或1可以直接找到你的小伙伴，比如对于2，亦或1就是3，对于3，亦或1就是2。如果你和你的小伙伴相等了，说明落单数在右边，如果不等，说明在左边，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == nums[mid ^ <span class="number">1</span>]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode541-Reverse-String-II"><a href="#Leetcode541-Reverse-String-II" class="headerlink" title="Leetcode541. Reverse String II"></a>Leetcode541. Reverse String II</h1><p>Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">Output: &quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure><br>这是一道字符逆序操作题<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        string sb = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; len)&#123;</span><br><span class="line">            string tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; k + index &amp;&amp; i &lt; len; i++) &#123;</span><br><span class="line">                tmp += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            index += k;</span><br><span class="line">            <span class="built_in">reverse</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">            sb = sb + tmp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; k + index &amp;&amp; i &lt; len; i++)&#123;</span><br><span class="line">                sb += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            index += k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode542-01-Matrix"><a href="#Leetcode542-01-Matrix" class="headerlink" title="Leetcode542. 01 Matrix"></a>Leetcode542. 01 Matrix</h1><p>Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.</p>
<p>The distance between two adjacent cells is 1.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: mat = [</span><br><span class="line">    [0,0,0],</span><br><span class="line">    [0,1,0],</span><br><span class="line">    [0,0,0]]</span><br><span class="line">Output: [</span><br><span class="line">    [0,0,0],</span><br><span class="line">    [0,1,0],</span><br><span class="line">    [0,0,0]]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat = [[0,0,0],[0,1,0],[1,1,1]]</span><br><span class="line">Output: [[0,0,0],[0,1,0],[1,2,1]]</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个只有0和1的矩阵，让我们求每一个1到离其最近的0的距离，其实也就是求一个BFS。我们可以首先遍历一次矩阵，将值为0的点都存入queue，将值为1的点改为INT_MAX。之前像什么遍历迷宫啊，起点只有一个，而这道题所有为0的点都是起点。然后开始BFS遍历，从queue中取出一个数字，遍历其周围四个点，如果越界或者周围点的值小于等于当前值加1，则直接跳过。因为周围点的距离更小的话，就没有更新的必要，否则将周围点的值更新为当前值加1，然后把周围点的坐标加入queue，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat) &#123;</span><br><span class="line">        <span class="type">int</span> m = mat.<span class="built_in">size</span>(), n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dir = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="keyword">if</span> (mat[i][j] == <span class="number">0</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    mat[i][j] = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; t = q.<span class="built_in">front</span>(); </span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">                <span class="type">int</span> x = t.first + dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> y = t.second + dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || mat[x][y] &lt;= mat[t.first][t.second])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                mat[x][y] = mat[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode543-Diameter-of-Binary-Tree"><a href="#Leetcode543-Diameter-of-Binary-Tree" class="headerlink" title="Leetcode543. Diameter of Binary Tree"></a>Leetcode543. Diameter of Binary Tree</h1><p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree</span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        2   3</span><br><span class="line">       / \     </span><br><span class="line">      4   5    </span><br><span class="line">Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</span><br></pre></td></tr></table></figure><br>递归解题。遍历整个数，根据题意，直径等于左子树深度加上右子树深度，实时更新max，返回值是左右子树较大的深度值加1。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> &amp;maxx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">dfs</span>(root-&gt;left, maxx);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">dfs</span>(root-&gt;right, maxx);</span><br><span class="line">        maxx = <span class="built_in">max</span>(right+left, maxx);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(right, left) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxx = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root, maxx);</span><br><span class="line">        <span class="keyword">return</span> maxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode547-Number-of-Provinces"><a href="#Leetcode547-Number-of-Provinces" class="headerlink" title="Leetcode547. Number of Provinces"></a>Leetcode547. Number of Provinces</h1><p>There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.</p>
<p>A province is a group of directly or indirectly connected cities and no other cities outside of the group.</p>
<p>You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.</p>
<p>Return the total number of provinces.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>这道题让我们求省的个数，题目中对于省的定义是可以传递的，比如A和B同省，B和C是同省，那么即使A和C不同省，那么他们三人也属于同省。那么比较直接的解法就是 DFS 搜索，对于某个城市，遍历其临近城市，然后再遍历其邻居的邻居，那么就能把属于同一个省的城市都遍历一遍，同时标记出已经遍历过的城市，然后累积省的个数，再去对于没有遍历到的城市在找临近的城市，这样就能求出个数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isConnected.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = isConnected.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">helper</span>(isConnected, i, n, visited);</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; isConnected, <span class="type">int</span> i, <span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        visited[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; n; ii ++)</span><br><span class="line">            <span class="keyword">if</span> (isConnected[i][ii] &amp;&amp; !visited[ii])</span><br><span class="line">                <span class="built_in">helper</span>(isConnected, ii, n, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode551-Student-Attendance-Record-I"><a href="#Leetcode551-Student-Attendance-Record-I" class="headerlink" title="Leetcode551. Student Attendance Record I"></a>Leetcode551. Student Attendance Record I</h1><p>You are given a string representing an attendance record for a student. The record only contains the following three characters:</p>
<ul>
<li>‘A’ : Absent.</li>
<li>‘L’ : Late.</li>
<li>‘P’ : Present.<br>A student could be rewarded if his attendance record doesn’t contain more than one ‘A’ (absent) or more than two continuous ‘L’ (late).</li>
</ul>
<p>You need to return whether the student could be rewarded according to his attendance record.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;PPALLP&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;PPALLL&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><br>简单字符串统计，如果出席记录不包含多于一个“A”（缺席）或超过两个连续的“L”（晚），学生可以获得奖励。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkRecord</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> aa[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">                aa[<span class="number">0</span>] ++;</span><br><span class="line">                aa[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                aa[<span class="number">1</span>] ++; </span><br><span class="line">                <span class="keyword">if</span>(aa[<span class="number">1</span>] &gt; <span class="number">2</span>) </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                aa[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(aa[<span class="number">0</span>] &lt;= <span class="number">1</span> &amp;&amp; aa[<span class="number">1</span>] &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode553-Optimal-Division"><a href="#Leetcode553-Optimal-Division" class="headerlink" title="Leetcode553. Optimal Division"></a>Leetcode553. Optimal Division</h1><p>You are given an integer array nums. The adjacent integers in nums will perform the float division.</p>
<p>For example, for nums = [2,3,4], we will evaluate the expression “2/3/4”.<br>However, you can add any number of parenthesis at any position to change the priority of operations. You want to add these parentheses such the value of the expression after the evaluation is maximum.</p>
<p>Return the corresponding expression that has the maximum value in string format.</p>
<p>Note: your expression should not contain redundant parenthesis.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1000,100,10,2]</span><br><span class="line">Output: &quot;1000/(100/10/2)&quot;</span><br><span class="line">Explanation:</span><br><span class="line">1000/(100/10/2) = 1000/((100/10)/2) = 200</span><br><span class="line">However, the bold parenthesis in &quot;1000/((100/10)/2)&quot; are redundant, since they don&#x27;t influence the operation priority. So you should return &quot;1000/(100/10/2)&quot;.</span><br><span class="line">Other cases:</span><br><span class="line">1000/(100/10)/2 = 50</span><br><span class="line">1000/(100/(10/2)) = 50</span><br><span class="line">1000/100/10/2 = 0.5</span><br><span class="line">1000/100/(10/2) = 2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,3,4]</span><br><span class="line">Output: &quot;2/(3/4)&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2]</span><br><span class="line">Output: &quot;2&quot;</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个数组，让我们确定除法的顺序，从而得到值最大的运算顺序，并且不能加多余的括号。刚开始博主没看清题，以为是要返回最大的值，就直接写了个递归的暴力搜索的方法，结果发现是要返回带括号的字符串，尝试的修改了一下，觉得挺麻烦。于是直接放弃抵抗，上网参考大神们的解法，结果大吃一惊，这题原来还可以这么解，完全是数学上的知识啊，太tricky了。数组中n个数字，如果不加括号就是：</p>
<p>x1 / x2 / x3 / … / xn</p>
<p>那么我们如何加括号使得其值最大呢，那么就是将x2后面的除数都变成乘数，比如只有三个数字的情况 a / b / c，如果我们在后两个数上加上括号 a / (b / c)，实际上就是a / b * c。而且b永远只能当除数，a也永远只能当被除数。同理，x1只能当被除数，x2只能当除数，但是x3之后的数，只要我们都将其变为乘数，那么得到的值肯定是最大的，所以就只有一种加括号的方式，即:</p>
<p>x1 / (x2 / x3 / … / xn)</p>
<p>这样的话就完全不用递归了，这道题就变成了一个道简单的字符串操作的题目了，这思路，博主服了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">optimalDivision</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        res += <span class="built_in">to_string</span>(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">1</span> || len == <span class="number">2</span>)</span><br><span class="line">                res += (<span class="string">&quot;/&quot;</span> + <span class="built_in">to_string</span>(nums[i]));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res += (<span class="string">&quot;/(&quot;</span> + <span class="built_in">to_string</span>(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">2</span>)</span><br><span class="line">            res += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode554-Brick-Wall"><a href="#Leetcode554-Brick-Wall" class="headerlink" title="Leetcode554. Brick Wall"></a>Leetcode554. Brick Wall</h1><p>There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the top to the bottom and cross the leastbricks.</p>
<p>The brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right.</p>
<p>If your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks.</p>
<p>You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[[1,2,2,1],</span><br><span class="line"> [3,1,2],</span><br><span class="line"> [1,3,2],</span><br><span class="line"> [2,4],</span><br><span class="line"> [3,1,2],</span><br><span class="line"> [1,3,1,1]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><br><img src="/img/20210713170200_3.png" alt=""></p>
<p>Note:</p>
<ul>
<li>The width sum of bricks in different rows are the same and won’t exceed INT_MAX.</li>
<li>The number of bricks in each row is in range [1,10,000]. The height of wall is in range [1,10,000]. Total number of bricks of the wall won’t exceed 20,000.</li>
</ul>
<p>这道题给了我们一个砖头墙壁，上面由不同的长度的砖头组成，让选个地方从上往下把墙劈开，使得被劈开的砖头个数最少，前提是不能从墙壁的两边劈，这样没有什么意义。这里使用一个 HashMap 来建立每一个断点的长度和其出现频率之间的映射，这样只要从断点频率出现最多的地方劈墙，损坏的板砖一定最少。遍历砖墙的每一层，新建一个变量 sum，然后从第一块转头遍历到倒数第二块，将当前转头长度累加到 sum 上，这样每次得到的 sum 就是断点的长度，将其在 HashMap 中的映射值自增1，并且每次都更新下最大的映射值到变量 mx，这样最终 mx 就是出现次数最多的断点值，在这里劈开，绝对损伤的转头数量最少，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">leastBricks</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; wall)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; wall.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; wall[i].<span class="built_in">size</span>()<span class="number">-1</span>; j ++) &#123;</span><br><span class="line">                sum += wall[i][j];</span><br><span class="line">                m[sum] ++;</span><br><span class="line">                res = <span class="built_in">max</span>(res, m[sum]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it ++)</span><br><span class="line">            res = <span class="built_in">max</span>(res, it-&gt;second);</span><br><span class="line">        <span class="keyword">return</span> wall.<span class="built_in">size</span>() - res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode556-Next-Greater-Element-III"><a href="#Leetcode556-Next-Greater-Element-III" class="headerlink" title="Leetcode556. Next Greater Element III"></a>Leetcode556. Next Greater Element III</h1><p>Given a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive 32-bit integer exists, you need to return -1.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 12</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 21</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个数字，让我们对各个位数重新排序，求出刚好比给定数字大的一种排序，如果不存在就返回-1。这道题给的例子的数字都比较简单，我们来看一个复杂的，比如12443322，这个数字的重排序结果应该为13222344，如果我们仔细观察的话会发现数字变大的原因是左数第二位的2变成了3，细心的童鞋会更进一步的发现后面的数字由降序变为了升序，这也不难理解，因为我们要求刚好比给定数字大的排序方式。那么我们再观察下原数字，看看2是怎么确定的，我们发现，如果从后往前看的话，2是第一个小于其右边位数的数字，因为如果是个纯降序排列的数字，做任何改变都不会使数字变大，直接返回-1。知道了找出转折点的方法，再来看如何确定2和谁交换，这里2并没有跟4换位，而是跟3换了，那么如何确定的3？其实也是从后往前遍历，找到第一个大于2的数字交换，然后把转折点之后的数字按升序排列就是最终的结果了。最后记得为防止越界要转为长整数型，然后根据结果判断是否要返回-1即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">comp</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nextGreaterElement</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums.<span class="built_in">push_back</span>(n%<span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> j, i = len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i ++)</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i<span class="number">+1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == len<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        i ++;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len<span class="number">-1</span>; j ++)</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[i])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>()+i, comp);</span><br><span class="line">        <span class="type">long</span> <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            res = res * <span class="number">10</span> + nums[i];</span><br><span class="line">            <span class="keyword">if</span> (res &gt; INT_MAX)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode557-Reverse-Words-in-a-String-III"><a href="#Leetcode557-Reverse-Words-in-a-String-III" class="headerlink" title="Leetcode557. Reverse Words in a String III"></a>Leetcode557. Reverse Words in a String III</h1><p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p>
<p>Example 1:<br>Input: “Let’s take LeetCode contest”<br>Output: “s’teL ekat edoCteeL tsetnoc”<br>Note: In the string, each word is separated by single space and there will not be any extra space in the string.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">resverse</span><span class="params">(string s, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        string ss;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=end;i&gt;=begin;i--)</span><br><span class="line">            ss += s[i];</span><br><span class="line">        <span class="keyword">return</span> ss;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个函数没用的哦，之前用了这个函数结果效率相当低</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> begin=<span class="number">0</span>, temp;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                temp=i<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=begin;j&lt;temp;j++,temp--)&#123;</span><br><span class="line">                    c=s[j];</span><br><span class="line">                    s[j]=s[temp];</span><br><span class="line">                    s[temp]=c;</span><br><span class="line">                &#125;</span><br><span class="line">                begin = i<span class="number">+1</span>;</span><br><span class="line">                res += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp=s.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=begin;j&lt;temp;j++,temp--)&#123;</span><br><span class="line">            c=s[j];</span><br><span class="line">            s[j]=s[temp];</span><br><span class="line">            s[temp]=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另一种方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> front = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">length</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s.<span class="built_in">length</span>() || s[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">reverse</span>(&amp;s[front], &amp;s[i]);</span><br><span class="line">            front = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;  </span><br></pre></td></tr></table></figure></p>
<p>用python一行就可以搞定<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join([i[::-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> s.split()])</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode558-Quad-Tree-Intersection"><a href="#Leetcode558-Quad-Tree-Intersection" class="headerlink" title="Leetcode558. Quad Tree Intersection"></a>Leetcode558. Quad Tree Intersection</h1><p>A quadtree is a tree data in which each internal node has exactly four children: topLeft, topRight, bottomLeft and bottomRight. Quad trees are often used to partition a two-dimensional space by recursively subdividing it into four quadrants or regions.</p>
<p>We want to store True/False information in our quad tree. The quad tree is used to represent a N * N boolean grid. For each node, it will be subdivided into four children nodes until the values in the region it represents are all the same. Each node has another two boolean attributes : isLeaf and val. isLeafis true if and only if the node is a leaf node. The val attribute for a leaf node contains the value of the region it represents.</p>
<p>For example, below are two quad trees A and B:</p>
<p>A:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+-------+-------+   T: true</span><br><span class="line">|       |       |   F: false</span><br><span class="line">|   T   |   T   |</span><br><span class="line">|       |       |</span><br><span class="line">+-------+-------+</span><br><span class="line">|       |       |</span><br><span class="line">|   F   |   F   |</span><br><span class="line">|       |       |</span><br><span class="line">+-------+-------+</span><br><span class="line">topLeft: T</span><br><span class="line">topRight: T</span><br><span class="line">bottomLeft: F</span><br><span class="line">bottomRight: F</span><br></pre></td></tr></table></figure></p>
<p>B:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+-------+---+---+</span><br><span class="line">|       | F | F |</span><br><span class="line">|   T   +---+---+</span><br><span class="line">|       | T | T |</span><br><span class="line">+-------+---+---+</span><br><span class="line">|       |       |</span><br><span class="line">|   T   |   F   |</span><br><span class="line">|       |       |</span><br><span class="line">+-------+-------+</span><br><span class="line">topLeft: T</span><br><span class="line">topRight:</span><br><span class="line">     topLeft: F</span><br><span class="line">     topRight: F</span><br><span class="line">     bottomLeft: T</span><br><span class="line">     bottomRight: T</span><br><span class="line">bottomLeft: T</span><br><span class="line">bottomRight: F</span><br></pre></td></tr></table></figure></p>
<p>Your task is to implement a function that will take two quadtrees and return a quadtree that represents the logical OR (or union) of the two trees.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A:                 B:                 C (A or B):</span><br><span class="line">+-------+-------+  +-------+---+---+  +-------+-------+</span><br><span class="line">|       |       |  |       | F | F |  |       |       |</span><br><span class="line">|   T   |   T   |  |   T   +---+---+  |   T   |   T   |</span><br><span class="line">|       |       |  |       | T | T |  |       |       |</span><br><span class="line">+-------+-------+  +-------+---+---+  +-------+-------+</span><br><span class="line">|       |       |  |       |       |  |       |       |</span><br><span class="line">|   F   |   F   |  |   T   |   F   |  |   T   |   F   |</span><br><span class="line">|       |       |  |       |       |  |       |       |</span><br><span class="line">+-------+-------+  +-------+-------+  +-------+-------+</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>Both A and B represent grids of size N * N.</li>
<li>N is guaranteed to be a power of 2.</li>
<li>If you want to know more about the quad tree, you can refer to its wiki.</li>
<li>The logic OR operation is defined as this: “A or B” is true if A is true, or if B is true, or if both A and B are true.</li>
</ul>
<p>这道题又是一道四叉树的题，说是给了我们两个四叉树，然后让我们将二棵树相交形成了一棵四叉树，相交的机制采用的是或，即每个自区域相‘或’，题目中给的例子很好的说明了一些相‘或’的原则，比如我们看A和B中的右上结点，我们发现A树的右上结点已经是一个值为true的叶结点，而B的右上结点还是一个子树，那么此时不论子树里有啥内容，我们相交后的树的右上结点应该跟A树的右上结点保持一致，假如A树的右上结点值是false的话，相‘或’起不到任何作用，那么相交后的树的右上结点应该跟B树的右上结点保持一致。那么我们可以归纳出，只有某一个结点是叶结点了，我们看其值，如果是true，则相交后的结点和此结点保持一致，否则跟另一个结点保持一致。比较麻烦的情况是当两个结点都不是叶结点的情况，此时我们需要对相对应的四个子结点分别调用递归函数，调用之后还需要进行进一步处理，因为一旦四个子结点的值相同，且都是叶结点的话，那么此时应该合并为一个大的叶结点，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">intersect</span><span class="params">(Node* quadTree1, Node* quadTree2)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (quadTree1-&gt;isLeaf) <span class="keyword">return</span> quadTree1-&gt;val ? quadTree1 : quadTree2;</span><br><span class="line">          <span class="keyword">if</span> (quadTree2-&gt;isLeaf) <span class="keyword">return</span> quadTree2-&gt;val ? quadTree2 : quadTree1;</span><br><span class="line">          Node *tl = <span class="built_in">intersect</span>(quadTree1-&gt;topLeft, quadTree2-&gt;topLeft);</span><br><span class="line">          Node *tr = <span class="built_in">intersect</span>(quadTree1-&gt;topRight, quadTree2-&gt;topRight);</span><br><span class="line">          Node *bl = <span class="built_in">intersect</span>(quadTree1-&gt;bottomLeft, quadTree2-&gt;bottomLeft);</span><br><span class="line">          Node *br = <span class="built_in">intersect</span>(quadTree1-&gt;bottomRight, quadTree2-&gt;bottomRight);</span><br><span class="line">          <span class="keyword">if</span> (tl-&gt;val == tr-&gt;val &amp;&amp; tl-&gt;val == bl-&gt;val &amp;&amp; tl-&gt;val == br-&gt;val &amp;&amp; tl-&gt;isLeaf &amp;&amp; tr-&gt;isLeaf &amp;&amp; bl-&gt;isLeaf &amp;&amp; br-&gt;isLeaf) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(tl-&gt;val, <span class="literal">true</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="literal">false</span>, <span class="literal">false</span>, tl, tr, bl, br);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode559-Maximum-Depth-of-N-ary-Tree"><a href="#Leetcode559-Maximum-Depth-of-N-ary-Tree" class="headerlink" title="Leetcode559. Maximum Depth of N-ary Tree"></a>Leetcode559. Maximum Depth of N-ary Tree</h1><p>Given a n-ary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p>For example, given a 3-ary tree:<br><img src="/img/20190825001.png" alt=""></p>
<p>We should return its max depth, which is 3.</p>
<p>Note:</p>
<p>The depth of the tree is at most 1000.<br>The total number of nodes is at most 5000.</p>
<p>多叉树最大深度<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;children.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> maxx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; root-&gt;children.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="type">int</span> temp = <span class="built_in">maxDepth</span>(root-&gt;children[i]);</span><br><span class="line">            <span class="keyword">if</span>(maxx &lt; temp)</span><br><span class="line">                maxx = temp;</span><br><span class="line">	        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxx<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode560-Subarray-Sum-Equals-K"><a href="#Leetcode560-Subarray-Sum-Equals-K" class="headerlink" title="Leetcode560. Subarray Sum Equals K"></a>Leetcode560. Subarray Sum Equals K</h1><p>Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:nums = [1,1,1], k = 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>The length of the array is in range [1, 20,000].</li>
<li>The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].</li>
</ul>
<p>这道题给了我们一个数组，让求和为k的连续子数组的个数，博主最开始看到这道题想着肯定要建立累加和数组啊，然后遍历累加和数组的每个数字，首先看其是否为k，是的话结果 res 自增1，然后再加个往前的循环，这样可以快速求出所有的子数组之和，看是否为k，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; sums = nums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sums[i] = sums[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sums[i] == k) ++res;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sums[i] - sums[j] == k) ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>用一个 HashMap 来建立连续子数组之和跟其出现次数之间的映射，初始化要加入 {0,1} 这对映射，这是为啥呢，因为解题思路是遍历数组中的数字，用 sum 来记录到当前位置的累加和，建立 HashMap 的目的是为了可以快速的查找 sum-k 是否存在，即是否有连续子数组的和为 sum-k，如果存在的话，那么和为k的子数组一定也存在，这样当 sum 刚好为k的时候，那么数组从起始到当前位置的这段子数组的和就是k，满足题意，如果 HashMap 中事先没有 m[0] 项的话，这个符合题意的结果就无法累加到结果 res 中，这就是初始化的用途。上面讲解的内容顺带着也把 for 循环中的内容解释了，这里就不多阐述了，有疑问的童鞋请在评论区留言哈，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, sum = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            res += m[sum - k];</span><br><span class="line">            ++m[sum]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode561-Array-Partition-I"><a href="#Leetcode561-Array-Partition-I" class="headerlink" title="Leetcode561. Array Partition I"></a>Leetcode561. Array Partition I</h1><p>Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,4,3,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><br>Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).<br>Note:<br>n is a positive integer, which is in the range of [1, 10000].<br>All the integers in the array will be in the range of [-10000, 10000].</p>
<p>这道题目给了我们一个数组有2n integers， 需要我们把这个数组分成n对，然后从每一对里面拿小的那个数字，把所有的加起来，返回这个sum。并且要使这个sum 尽量最大。如何让sum 最大化呢，我们想一下，如果是两个数字，一个很小，一个很大，这样的话，取一个小的数字，就浪费了那个大的数字。所以我们要使每一对的两个数字尽可能接近。我们先把nums sort 一下，让它从小到大排列，接着每次把index： 0， 2， 4…偶数位的数字加起来就可以了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">arrayPairSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i+=<span class="number">2</span>)</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode563-Binary-Tree-Tilt"><a href="#Leetcode563-Binary-Tree-Tilt" class="headerlink" title="Leetcode563. Binary Tree Tilt"></a>Leetcode563. Binary Tree Tilt</h1><p>Given a binary tree, return the tilt of the whole tree.</p>
<p>The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.</p>
<p>The tilt of the whole tree is defined as the sum of all nodes’ tilt.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">         1</span><br><span class="line">       /   \</span><br><span class="line">      2     3</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">Tilt of node 2 : 0</span><br><span class="line">Tilt of node 3 : 0</span><br><span class="line">Tilt of node 1 : |2-3| = 1</span><br><span class="line">Tilt of binary tree : 0 + 0 + 1 = 1</span><br></pre></td></tr></table></figure><br>这道题其实是要求 求出各个节点左右子树的差的绝对值，将这些绝对值求和并返回。左右子树的差 = | 左子树所有节点的值的和 - 右子树所有节点的值的和 |。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span>&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left, right;</span><br><span class="line">        left = <span class="built_in">dfs</span>(root-&gt;left, ans);</span><br><span class="line">        right = <span class="built_in">dfs</span>(root-&gt;right, ans);</span><br><span class="line">        <span class="type">int</span> tilt = <span class="built_in">abs</span>(left - right);</span><br><span class="line">        ans += tilt;</span><br><span class="line">        <span class="keyword">return</span> left + right + root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTilt</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode565-Array-Nesting"><a href="#Leetcode565-Array-Nesting" class="headerlink" title="Leetcode565. Array Nesting"></a>Leetcode565. Array Nesting</h1><p>A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], … } subjected to the rule below.</p>
<p>Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [5,4,0,3,1,6,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: </span><br><span class="line">A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.</span><br><span class="line"></span><br><span class="line">One of the longest S[K]:</span><br><span class="line">S[0] = &#123;A[0], A[5], A[6], A[2]&#125; = &#123;5, 6, 2, 0&#125;</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>N is an integer within the range [1, 20,000].</li>
<li>The elements of A are all distinct.</li>
<li>Each element of A is an integer within the range [0, N-1].</li>
</ul>
<p>这道题让我们找嵌套数组的最大个数，给的数组总共有n个数字，范围均在 [0, n-1] 之间，题目中也把嵌套数组的生成解释的很清楚了，其实就是值变成坐标，得到的数值再变坐标。那么实际上当循环出现的时候，嵌套数组的长度也不能再增加了，而出现的这个相同的数一定是嵌套数组的首元素。其实对于遍历过的数字，我们不用再将其当作开头来计算了，而是只对于未遍历过的数字当作嵌套数组的开头数字，不过在进行嵌套运算的时候，并不考虑中间的数字是否已经访问过，而是只要找到和起始位置相同的数字位置，然后更新结果 res，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">arrayNesting</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(len, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">helper</span>(nums, i, visited));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, vector&lt;<span class="type">bool</span>&gt; &amp;visited)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; len &amp;&amp; !visited[start]) &#123;</span><br><span class="line">            visited[start] = <span class="literal">true</span>;</span><br><span class="line">            res ++;</span><br><span class="line">            start = nums[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode566-Reshape-the-Matrix"><a href="#Leetcode566-Reshape-the-Matrix" class="headerlink" title="Leetcode566. Reshape the Matrix"></a>Leetcode566. Reshape the Matrix</h1><p>In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data.</p>
<p>You’re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively.</p>
<p>The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.</p>
<p>If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 1, c = 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2,3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 2, c = 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.</span><br></pre></td></tr></table></figure><br>把矩阵换个样子输出出来，效率还挺高的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrixReshape</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; nums, <span class="type">int</span> r, <span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="type">int</span> m = nums.<span class="built_in">size</span>(), n = nums[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m*n != r*c)</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(r, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> ii = <span class="number">0</span>, jj = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                res[ii][jj] = nums[i][j];</span><br><span class="line">                <span class="keyword">if</span>(jj == c - <span class="number">1</span>) &#123;</span><br><span class="line">                    ii ++;</span><br><span class="line">                    jj = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    jj ++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode567-Permutation-in-String"><a href="#Leetcode567-Permutation-in-String" class="headerlink" title="Leetcode567. Permutation in String"></a>Leetcode567. Permutation in String</h1><p>Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string’s permutations is the substring of the second string.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input:s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">Output:True</span><br><span class="line">Explanation: s2 contains one permutation of s1 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>The input strings only contain lower case letters.</li>
<li>The length of both given strings is in range [1, 10,000].</li>
</ul>
<p>这道题给了两个字符串s1和s2，问我们s1的全排列的字符串任意一个是否为s2的字串。这道题的正确做法应该是使用滑动窗口Sliding Window的思想来做，可以使用两个哈希表来做，或者是使用一个哈希表配上双指针来做。我们先来看使用两个哈希表来做的情况，我们先来分别统计s1和s2中前n1个字符串中各个字符出现的次数，其中n1为字符串s1的长度，这样如果二者字符出现次数的情况完全相同，说明s1和s2中前n1的字符互为全排列关系，那么符合题意了，直接返回true。如果不是的话，那么我们遍历s2之后的字符，对于遍历到的字符，对应的次数加1，由于窗口的大小限定为了n1，所以每在窗口右侧加一个新字符的同时就要在窗口左侧去掉一个字符，每次都比较一下两个哈希表的情况，如果相等，说明存在，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len1 = s<span class="number">1.l</span>ength(), len2 = s<span class="number">2.l</span>ength();</span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;::iterator it;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m1, m2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len1; i ++) &#123;</span><br><span class="line">            m1[s1[i]] ++;</span><br><span class="line">            m2[s2[i]] ++;</span><br><span class="line">        &#125;         </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = len1; i &lt; len2; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (it = m<span class="number">1.</span><span class="built_in">begin</span>(); it != m<span class="number">1.</span><span class="built_in">end</span>(); it ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (it-&gt;second != m2[it-&gt;first])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (it == m<span class="number">1.</span><span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            m2[s2[i-len1]] --;</span><br><span class="line">            m2[s2[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (it = m<span class="number">1.</span><span class="built_in">begin</span>(); it != m<span class="number">1.</span><span class="built_in">end</span>(); it ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;second != m2[it-&gt;first])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (it == m<span class="number">1.</span><span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode572-Subtree-of-Another-Tree"><a href="#Leetcode572-Subtree-of-Another-Tree" class="headerlink" title="Leetcode572. Subtree of Another Tree"></a>Leetcode572. Subtree of Another Tree</h1><p>Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node’s descendants. The tree s could also be considered as a subtree of itself.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Given tree s:</span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \</span><br><span class="line"> 1   2</span><br><span class="line">Given tree t:</span><br><span class="line">   4 </span><br><span class="line">  / \</span><br><span class="line"> 1   2</span><br><span class="line">Return true, because t has the same structure and node values with a subtree of s.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given tree s:</span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \</span><br><span class="line"> 1   2</span><br><span class="line">    /</span><br><span class="line">   0</span><br><span class="line">Given tree t:</span><br><span class="line">   4</span><br><span class="line">  / \</span><br><span class="line"> 1   2</span><br><span class="line">Return false.</span><br></pre></td></tr></table></figure><br>这道题让我们求一个数是否是另一个树的子树，从题目中的第二个例子中可以看出，子树必须是从叶结点开始的，中间某个部分的不能算是子树，那么我们转换一下思路，是不是从s的某个结点开始，跟t的所有结构都一样，那么问题就转换成了判断两棵树是否相同，也就是Same Tree的问题了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">issame</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s &amp;&amp; !t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!s || !t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;val != t-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">issame</span>(s-&gt;left, t-&gt;left) &amp;&amp; <span class="built_in">issame</span>(s-&gt;right, t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">issame</span>(s, t)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSubtree</span>(s-&gt;left, t) || <span class="built_in">isSubtree</span>(s-&gt;right, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode575-Distribute-Candies"><a href="#Leetcode575-Distribute-Candies" class="headerlink" title="Leetcode575. Distribute Candies"></a>Leetcode575. Distribute Candies</h1><p>Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = [1,1,2,2,3,3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">There are three different kinds of candies (1, 2 and 3), and two candies for each kind.</span><br><span class="line">Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. </span><br><span class="line">The sister has three different kinds of candies. </span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = [1,1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. </span><br><span class="line">The sister has two different kinds of candies, the brother has only one kind of candies. </span><br></pre></td></tr></table></figure><br>记录糖果种类，若糖果种类大于数组的一半，妹妹最多得到candies.size()/2种糖果,否则每种糖果都可以得到<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distributeCandies</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candies)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = candies.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> unique = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(candies.<span class="built_in">begin</span>(), candies.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || candies[i] != candies[i<span class="number">-1</span>])</span><br><span class="line">                unique ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(unique, len/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="LeetCode576-Out-of-Boundary-Paths"><a href="#LeetCode576-Out-of-Boundary-Paths" class="headerlink" title="LeetCode576. Out of Boundary Paths"></a>LeetCode576. Out of Boundary Paths</h1><p>There is an m by n grid with a ball. Given the start coordinate (i,j) of the ball, you can move the ball to adjacent cell or cross the grid boundary in four directions (up, down, left, right). However, you can at most move N times. Find out the number of paths to move the ball out of grid boundary. The answer may be very large, return it after mod 109 + 7.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:m = 2, n = 2, N = 2, i = 0, j = 0</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:m = 1, n = 3, N = 3, i = 0, j = 1</span><br><span class="line">Output: 12</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>Once you move the ball out of boundary, you cannot move it back.</li>
<li>The length and height of the grid is in range [1,50].</li>
<li>N is in range [0,50].</li>
</ul>
<p>这道题给了我们一个二维的数组，某个位置放个足球，每次可以在上下左右四个方向中任意移动一步，总共可以移动N步，问我们总共能有多少种移动方法能把足球移除边界，由于结果可能是个巨大的数，所以让我们对一个大数取余。那么我们知道对于这种结果很大的数如果用递归解法很容易爆栈，所以最好考虑使用DP来解。那么我们使用一个三维的DP数组，其中dp[k][i][j]表示总共走k步，从(i,j)位置走出边界的总路径数。那么我们来找递推式，对于dp[k][i][j]，走k步出边界的总路径数等于其周围四个位置的走k-1步出边界的总路径数之和，如果周围某个位置已经出边界了，那么就直接加上1，否则就在dp数组中找出该值，这样整个更新下来，我们就能得出每一个位置走任意步数的出界路径数了，最后只要返回dp[N][i][j]就是所求结果了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> maxMove, <span class="type">int</span> startRow, <span class="type">int</span> startColumn)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(maxMove<span class="number">+1</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= maxMove; k ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> x1 = j == n<span class="number">-1</span> ? <span class="number">1</span> : dp[k<span class="number">-1</span>][i][j<span class="number">+1</span>];</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> x2 = j == <span class="number">0</span> ? <span class="number">1</span> : dp[k<span class="number">-1</span>][i][j<span class="number">-1</span>];</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> x3 = i == m<span class="number">-1</span> ? <span class="number">1</span> : dp[k<span class="number">-1</span>][i<span class="number">+1</span>][j];</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> x4 = i == <span class="number">0</span> ? <span class="number">1</span> : dp[k<span class="number">-1</span>][i<span class="number">-1</span>][j];</span><br><span class="line">                    dp[k][i][j] = (x1+x2+x3+x4) % <span class="number">1000000007</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[maxMove][startRow][startColumn];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode581-Shortest-Unsorted-Continuous-Subarray"><a href="#Leetcode581-Shortest-Unsorted-Continuous-Subarray" class="headerlink" title="Leetcode581. Shortest Unsorted Continuous Subarray"></a>Leetcode581. Shortest Unsorted Continuous Subarray</h1><p>Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.</p>
<p>You need to find the shortest such subarray and output its length.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2, 6, 4, 8, 10, 9, 15]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.</span><br></pre></td></tr></table></figure><br>这道题是要找出最短的子数组，如果此子数组按照升序排列，则整个数组按照升序排列。先用一个数组temp保存nums，然后对temp排序，然后用两个变量start和end去找两个数组出现不同之处的第一个位置和最后一个位置，最后返回end-start+1就是要找的数组长度。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(nums)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> start, end;</span><br><span class="line">        <span class="keyword">for</span>(start = <span class="number">0</span>; start &lt; nums.<span class="built_in">size</span>(); start ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[start] != nums[start]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(end = nums.<span class="built_in">size</span>()<span class="number">-1</span>; end &gt;= start; end --) &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[end] != nums[end]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> end - start + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode583-Delete-Operation-for-Two-Strings"><a href="#Leetcode583-Delete-Operation-for-Two-Strings" class="headerlink" title="Leetcode583. Delete Operation for Two Strings"></a>Leetcode583. Delete Operation for Two Strings</h1><p>Given two words  word1  and  word2 , find the minimum number of steps required to make  word1  and  word2  the same, where in each step you can delete one character in either string.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;sea&quot;, &quot;eat&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You need one step to make &quot;sea&quot; to &quot;ea&quot; and another step to make &quot;eat&quot; to &quot;ea&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>The length of given words won’t exceed 500.</li>
<li>Characters in given words can only be lower-case letters.</li>
</ul>
<p>这道题给了我们两个单词，问最少需要多少步可以让两个单词相等，每一步可以在任意一个单词中删掉一个字符。那么来分析怎么能让步数最少呢，是不是知道两个单词最长的相同子序列的长度，并乘以2，被两个单词的长度之和减，就是最少步数了。</p>
<p>定义一个二维的 dp 数组，其中<code>dp[i][j]</code>表示 word1 的前i个字符和 word2 的前j个字符组成的两个单词的最长公共子序列的长度。下面来看状态转移方程<code>dp[i][j]</code>怎么求，首先来考虑<code>dp[i][j]</code>和<code>dp[i-1][j-1]</code>之间的关系，可以发现，如果当前的两个字符相等，那么<code>dp[i][j] = dp[i-1][j-1] + 1</code>，这不难理解吧，因为最长相同子序列又多了一个相同的字符，所以长度加1。由于 dp 数组的大小定义的是<code>(n1+1) x (n2+1)</code>，所以比较的是<code>word1[i-1]</code>和<code>word2[j-1]</code>。如果这两个字符不相等呢，难道直接将<code>dp[i-1][j-1]</code>赋值给<code>dp[i][j]</code>吗，当然不是，这里还要错位相比嘛，比如就拿题目中的例子来说，”sea” 和 “eat”，当比较第一个字符，发现 ‘s’ 和 ‘e’ 不相等，下一步就要错位比较啊，比较 sea 中第一个 ‘s’ 和 eat 中的 ‘a’，sea 中的 ‘e’ 跟 eat 中的第一个 ‘e’ 相比，这样<code>dp[i][j]</code>就要取<code>dp[i-1][j]</code>跟<code>dp[i][j-1]</code>中的较大值了，最后求出了最大共同子序列的长度，就能直接算出最小步数了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = word<span class="number">1.l</span>ength(), n = word<span class="number">2.l</span>ength();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m<span class="number">+1</span>, <span class="built_in">vector</span>(n<span class="number">+1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) </span><br><span class="line">                <span class="keyword">if</span> (word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">return</span> m + n - <span class="number">2</span> * dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode589-N-ary-Tree-Preorder-Traversal"><a href="#Leetcode589-N-ary-Tree-Preorder-Traversal" class="headerlink" title="Leetcode589. N-ary Tree Preorder Traversal"></a>Leetcode589. N-ary Tree Preorder Traversal</h1><p>Given an n-ary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example, given a 3-ary tree:<br><img src="/img/narytreeexample20190523.png" alt=""></p>
<p>Return its preorder traversal as: [1,3,5,6,2,4].</p>
<p>Note:</p>
<p>Recursive solution is trivial, could you do it iteratively?<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">des</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;root-&gt;children.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="built_in">des</span>(root-&gt;children[i]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">des</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode590-N-ary-Tree-Postorder-Traversal"><a href="#Leetcode590-N-ary-Tree-Postorder-Traversal" class="headerlink" title="Leetcode590. N-ary Tree Postorder Traversal"></a>Leetcode590. N-ary Tree Postorder Traversal</h1><p>Given an n-ary tree, return the postorder traversal of its nodes’ values.</p>
<p>For example, given a 3-ary tree:<br><img src="/img/narytreeexample.png" alt=""></p>
<p>Return its postorder traversal as: [5,6,3,2,4,1].</p>
<p>Note:</p>
<p>Recursive solution is trivial, could you do it iteratively?</p>
<p>遍历一棵n叉树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">des</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;children.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;root-&gt;children.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">des</span>(root-&gt;children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">des</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode592-Fraction-Addition-and-Subtraction"><a href="#Leetcode592-Fraction-Addition-and-Subtraction" class="headerlink" title="Leetcode592. Fraction Addition and Subtraction"></a>Leetcode592. Fraction Addition and Subtraction</h1><p>Given a string expression representing an expression of fraction addition and subtraction, return the calculation result in string format.</p>
<p>The final result should be an irreducible fraction. If your final result is an integer, say 2, you need to change it to the format of a fraction that has a denominator 1. So in this case, 2 should be converted to 2/1.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: expression = &quot;-1/2+1/2&quot;</span><br><span class="line">Output: &quot;0/1&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: expression = &quot;-1/2+1/2+1/3&quot;</span><br><span class="line">Output: &quot;1/3&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: expression = &quot;1/3-1/2&quot;</span><br><span class="line">Output: &quot;-1/6&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: expression = &quot;5/3+1/3&quot;</span><br><span class="line">Output: &quot;2/1&quot;</span><br></pre></td></tr></table></figure></p>
<p>这道题让我们做分数的加减法，给了我们一个分数加减法式子的字符串，然我们算出结果，结果当然还是用分数表示了。那么其实这道题主要就是字符串的拆分处理，再加上一点中学的数学运算的知识就可以了。中学数学告诉我们必须将分母变为同一个数，分子才能相加，为了简便，我们不求最小公倍数，而是直接乘上另一个数的分母，然后相加。不过得到的结果需要化简一下，我们求出分子分母的最大公约数，记得要取绝对值，然后分子分母分别除以这个最大公约数就是最后的结果了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">            m = -m;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">            n = -n;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = m;</span><br><span class="line">            m = n;</span><br><span class="line">            n = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rem;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            rem = m % n;</span><br><span class="line">            m = n;</span><br><span class="line">            n = rem;</span><br><span class="line">        &#125;</span><br><span class="line">	    <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">(string e, <span class="type">int</span> &amp;i, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>, flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (e[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            flag = <span class="number">-1</span>;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e[i] == <span class="string">&#x27;+&#x27;</span> || e[i] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">            i ++;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len &amp;&amp; <span class="string">&#x27;0&#x27;</span> &lt;= e[i] &amp;&amp; e[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            tmp = tmp*<span class="number">10</span> + e[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp*flag;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">fractionAddition</span><span class="params">(string expression)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = expression.<span class="built_in">length</span>(), i = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="built_in">get_num</span>(expression, i, len));</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="built_in">get_num</span>(expression, i, len));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> res0 = <span class="built_in">get_num</span>(expression, i, len);</span><br><span class="line">                <span class="type">int</span> res1 = <span class="built_in">get_num</span>(expression, i, len);</span><br><span class="line">                res0 = res0 * res[<span class="number">1</span>];</span><br><span class="line">                res[<span class="number">0</span>] = res[<span class="number">0</span>] * res1 + res0;</span><br><span class="line">                res[<span class="number">1</span>] = res[<span class="number">1</span>] * res1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0/1&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">fun</span>(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">            res[<span class="number">0</span>] /= t;</span><br><span class="line">            res[<span class="number">1</span>] /= t;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">to_string</span>(res[<span class="number">0</span>]) + <span class="string">&quot;/&quot;</span> + <span class="built_in">to_string</span>(res[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode593-Valid-Square"><a href="#Leetcode593-Valid-Square" class="headerlink" title="Leetcode593. Valid Square"></a>Leetcode593. Valid Square</h1><p>Given the coordinates of four points in 2D space p1, p2, p3 and p4, return true if the four points construct a square.</p>
<p>The coordinate of a point pi is represented as [xi, yi]. The input is not given in any order.</p>
<p>A valid square has four equal sides with positive length and four equal angles (90-degree angles).</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们四个点，让验证这四个点是否能组成一个正方形，刚开始博主考虑的方法是想判断四个角是否是直角，但即便四个角都是直角，也不能说明一定就是正方形，还有可能是矩形。还得判断各边是否相等。其实这里可以仅通过边的关系的来判断是否是正方形，根据初中几何的知识可以知道正方形的四条边相等，两条对角线相等，满足这两个条件的四边形一定是正方形。那么这样就好办了，只需要对四个点，两两之间算距离，如果计算出某两个点之间距离为0，说明两点重合了，直接返回 false，如果不为0，那么就建立距离和其出现次数之间的映射，最后如果我们只得到了两个不同的距离长度，那么就说明是正方形了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validSquare</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; p1, vector&lt;<span class="type">int</span>&gt;&amp; p2, vector&lt;<span class="type">int</span>&gt;&amp; p3, vector&lt;<span class="type">int</span>&gt;&amp; p4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v&#123;p1, p2, p3, p4&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> x1 = v[i][<span class="number">0</span>], y1 = v[i][<span class="number">1</span>], x2 = v[j][<span class="number">0</span>], y2 = v[j][<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> dist = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);</span><br><span class="line">                <span class="keyword">if</span> (dist == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                ++m[dist];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m.<span class="built_in">size</span>() == <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode594-Longest-Harmonious-Subsequence"><a href="#Leetcode594-Longest-Harmonious-Subsequence" class="headerlink" title="Leetcode594. Longest Harmonious Subsequence"></a>Leetcode594. Longest Harmonious Subsequence</h1><p>We define a harmounious array as an array where the difference between its maximum value and its minimum value is exactly 1. Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,2,2,5,2,3,7]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The longest harmonious subsequence is [3,2,2,2,3].</span><br></pre></td></tr></table></figure><br>由于所需子序列有且只有两种元素，且相差为1，所以可以用map将所有数字的个数记录下来，再遍历map，如果对于一个key，如果key+1也存在于map中，则存在以key和key+1两个数字组成的和谐子序列，长度为两个数字的个数之和。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLHS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            mp[nums[i]] ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = mp.<span class="built_in">begin</span>(); i != mp.<span class="built_in">end</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(i-&gt;first<span class="number">+1</span>))</span><br><span class="line">                res = <span class="built_in">max</span>(res, i-&gt;second + mp[i-&gt;first<span class="number">+1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode595-Big-Countries"><a href="#Leetcode595-Big-Countries" class="headerlink" title="Leetcode595. Big Countries"></a>Leetcode595. Big Countries</h1><p>We define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1.</p>
<p>Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,2,2,5,2,3,7]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The longest harmonious subsequence is [3,2,2,2,3].</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个数组，让我们找出最长的和谐子序列，关于和谐子序列就是序列中数组的最大最小差值均为1。由于这里只是让我们求长度，并不需要返回具体的子序列。所以我们可以对数组进行排序，那么实际上我们只要找出来相差为1的两个数的总共出现个数就是一个和谐子序列的长度了。明白了这一点，我们就可以建立一个数字和其出现次数之间的映射，利用 TreeMap 的自动排序的特性，那么我们遍历 TreeMap 的时候就是从小往大开始遍历，我们从第二个映射对开始遍历，每次跟其前面的映射对比较，如果二者的数字刚好差1，那么就把二个数字的出现的次数相加并更新结果 res 即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLHS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) ++m[num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">next</span>(m.<span class="built_in">begin</span>()); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            <span class="keyword">auto</span> pre = <span class="built_in">prev</span>(it);</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;first == pre-&gt;first + <span class="number">1</span>) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, it-&gt;second + pre-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode596-Classes-More-Than-5-Students"><a href="#Leetcode596-Classes-More-Than-5-Students" class="headerlink" title="Leetcode596. Classes More Than 5 Students"></a>Leetcode596. Classes More Than 5 Students</h1><p>There is a table courses with columns: student and class Please list out all classes which have more than or equal to 5 students. For example, the table:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+---------+------------+</span><br><span class="line">| student | class      |</span><br><span class="line">+---------+------------+</span><br><span class="line">| A       | Math       |</span><br><span class="line">| B       | English    |</span><br><span class="line">| C       | Math       |</span><br><span class="line">| D       | Biology    |</span><br><span class="line">| E       | Math       |</span><br><span class="line">| F       | Computer   |</span><br><span class="line">| G       | Math       |</span><br><span class="line">| H       | Math       |</span><br><span class="line">| I       | Math       |</span><br><span class="line">+---------+------------+</span><br></pre></td></tr></table></figure><br>Should output:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------+</span><br><span class="line">| class   |</span><br><span class="line">+---------+</span><br><span class="line">| Math    |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> class <span class="keyword">FROM</span> courses</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> class</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span>(student)) <span class="operator">&gt;=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode598-Range-Addition-II"><a href="#Leetcode598-Range-Addition-II" class="headerlink" title="Leetcode598. Range Addition II"></a>Leetcode598. Range Addition II</h1><p>Given an m * n matrix M initialized with all 0’s and several update operations.</p>
<p>Operations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0 &lt;= i &lt; a and 0 &lt;= j &lt; b.</p>
<p>You need to count and return the number of maximum integers in the matrix after performing all the operations.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">m = 3, n = 3</span><br><span class="line">operations = [[2,2],[3,3]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: </span><br><span class="line">Initially, M = </span><br><span class="line">[[0, 0, 0],</span><br><span class="line"> [0, 0, 0],</span><br><span class="line"> [0, 0, 0]]</span><br><span class="line"></span><br><span class="line">After performing [2,2], M = </span><br><span class="line">[[1, 1, 0],</span><br><span class="line"> [1, 1, 0],</span><br><span class="line"> [0, 0, 0]]</span><br><span class="line"></span><br><span class="line">After performing [3,3], M = </span><br><span class="line">[[2, 2, 1],</span><br><span class="line"> [2, 2, 1],</span><br><span class="line"> [1, 1, 1]]</span><br><span class="line"></span><br><span class="line">So the maximum integer in M is 2, and there are four of it in M. So return 4.</span><br></pre></td></tr></table></figure><br>求ops[0 .. len][0]和ops[0 .. len][1]的最小值，矩阵越靠近左上角的元素值越大，因为要加1的元素 行和列索引是从0开始的。那么只需要找到操作次数最多的元素位置即可。而操作次数最多的元素肯定是偏向于靠近矩阵左上角的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ops)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ops.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> m * n;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> min1 = <span class="number">99999</span>, min2 = <span class="number">99999</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ops.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(min1 &gt; ops[i][<span class="number">0</span>])</span><br><span class="line">                min1 = ops[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(min2 &gt; ops[i][<span class="number">1</span>])</span><br><span class="line">                min2 = ops[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min1 * min2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode599-Minimum-Index-Sum-of-Two-Lists"><a href="#Leetcode599-Minimum-Index-Sum-of-Two-Lists" class="headerlink" title="Leetcode599. Minimum Index Sum of Two Lists"></a>Leetcode599. Minimum Index Sum of Two Lists</h1><p>Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.</p>
<p>You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]</span><br><span class="line">[&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]</span><br><span class="line">Output: [&quot;Shogun&quot;]</span><br><span class="line">Explanation: The only restaurant they both like is &quot;Shogun&quot;.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]</span><br><span class="line">[&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]</span><br><span class="line">Output: [&quot;Shogun&quot;]</span><br><span class="line">Explanation: The restaurant they both like and have the least index sum is &quot;Shogun&quot; with index sum 1 (0+1).</span><br></pre></td></tr></table></figure><br>如果两者只有一个共同喜欢的餐馆，直接将其返回；如果不止一个，则返回下标之和最小的一个。两个列表均没有重复元素，长度均在[1, 1000]范围内，其中的元素长度均在[1, 30]范围内。万一有多个答案的话？如果index之和的最小值大于等于当前这一组index之和，那有两种情况，一个是大于，那么更新结果vector，另一种是等于，那么直接把当前字符串加入结果vector。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRestaurant</span><span class="params">(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">9999999</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; list<span class="number">1.</span><span class="built_in">size</span>(); i ++)</span><br><span class="line">            mp[list1[i]] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; list<span class="number">2.</span><span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = mp.<span class="built_in">find</span>(list2[i]);</span><br><span class="line">            <span class="keyword">if</span>(temp != mp.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">if</span>(res &gt;= i + temp-&gt;second) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(res &gt; i + temp-&gt;second) &#123;</span><br><span class="line">                        ans.<span class="built_in">clear</span>();</span><br><span class="line">                        res = i + temp-&gt;second;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(temp-&gt;first);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode600-Non-negative-Integers-without-Consecutive-Ones"><a href="#Leetcode600-Non-negative-Integers-without-Consecutive-Ones" class="headerlink" title="Leetcode600. Non-negative Integers without Consecutive Ones"></a>Leetcode600. Non-negative Integers without Consecutive Ones</h1><p>Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line">Here are the non-negative integers &lt;= 5 with their corresponding binary representations:</span><br><span class="line">0 : 0</span><br><span class="line">1 : 1</span><br><span class="line">2 : 10</span><br><span class="line">3 : 11</span><br><span class="line">4 : 100</span><br><span class="line">5 : 101</span><br><span class="line">Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. </span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个数字，让我们求不大于这个数字的所有数字中，其二进制的表示形式中没有连续1的个数。根据题目中的例子也不难理解题意。我们首先来考虑二进制的情况，对于1来说，有0和1两种，对于11来说，有00，01，10，三种情况，那么有没有规律可寻呢，其实是有的，我们可以参见这个帖子，这样我们就可以通过DP的方法求出长度为k的二进制数的无连续1的数字个数。由于题目给我们的并不是一个二进制数的长度，而是一个二进制数，比如100，如果我们按长度为3的情况计算无连续1点个数个数，就会多计算101这种情况。所以我们的目标是要将大于num的情况去掉。下面从头来分析代码，首先我们要把十进制数转为二进制数，将二进制数存在一个字符串中，并统计字符串的长度。然后我们利用这个帖子中的方法，计算该字符串长度的二进制数所有无连续1的数字个数，然后我们从倒数第二个字符开始往前遍历这个二进制数字符串，如果当前字符和后面一个位置的字符均为1，说明我们并没有多计算任何情况，不明白的可以带例子来看。</p>
<p>如果当前字符和后面一个位置的字符均为0，说明我们有多计算一些情况，就像之前举的100这个例子，我们就多算了101这种情况。我们怎么确定多了多少种情况呢，假如给我们的数字是8，二进制为1000，我们首先按长度为4算出所有情况，共8种。仔细观察我们十进制转为二进制字符串的写法，发现转换结果跟真实的二进制数翻转了一下，所以我们的t为”0001”，那么我们从倒数第二位开始往前遍历，到i=1时，发现有两个连续的0出现，那么i=1这个位置上能出现1的次数，就到one数组中去找，那么我们减去1，减去的就是0101这种情况，再往前遍历，i=0时，又发现两个连续0，那么i=0这个位置上能出1的次数也到one数组中去找，我们再减去1，减去的是1001这种情况，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findIntegers</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, n = num;</span><br><span class="line">        string t = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            t += (n &amp; <span class="number">1</span>) ? <span class="string">&quot;1&quot;</span> : <span class="string">&quot;0&quot;</span>; </span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">zero</span><span class="params">(cnt)</span>, <span class="title">one</span><span class="params">(cnt)</span></span>;</span><br><span class="line">        zero[<span class="number">0</span>] = <span class="number">1</span>; one[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">            zero[i] = zero[i - <span class="number">1</span>] + one[i - <span class="number">1</span>];</span><br><span class="line">            one[i] = zero[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = zero[cnt - <span class="number">1</span>] + one[cnt - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = cnt - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[i] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; t[i + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (t[i] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; t[i + <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) res -= one[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面这种解法其实蛮有意思的，其实长度为k的二进制数字符串没有连续的1的个数是一个斐波那契数列f(k)。比如当k=5时，二进制数的范围是00000-11111，我们可以将其分为两个部分，00000-01111和10000-10111，因为任何大于11000的数字都是不成立的，因为有开头已经有了两个连续1。而我们发现其实00000-01111就是f(4)，而10000-10111就是f(3)，所以f(5) = f(4) + f(3)，这就是一个斐波那契数列啦。那么我们要做的首先就是建立一个这个数组，方便之后直接查值。我们从给定数字的最高位开始遍历，如果某一位是1，后面有k位，就加上f(k)，因为如果我们把当前位变成0，那么后面k位就可以直接从斐波那契数列中取值了。然后标记pre为1，再往下遍历，如果遇到0位，则pre标记为0。如果当前位是1，pre也是1，那么直接返回结果。最后循环退出后我们要加上数字本身这种情况，参见代码如下： </p>
<p>解法二：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findIntegers(int num) &#123;</span><br><span class="line">        int res = 0, k = 31, pre = 0;</span><br><span class="line">        vector&lt;int&gt; f(32, 0);</span><br><span class="line">        f[0] = 1; f[1] = 2;</span><br><span class="line">        for (int i = 2; i &lt; 31; ++i) &#123;</span><br><span class="line">            f[i] = f[i - 2] + f[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        while (k &gt;= 0) &#123;</span><br><span class="line">            if (num &amp; (1 &lt;&lt; k)) &#123;</span><br><span class="line">                res += f[k];</span><br><span class="line">                if (pre) return res;</span><br><span class="line">                pre = 1;</span><br><span class="line">            &#125; else pre = 0;</span><br><span class="line">            --k;</span><br><span class="line">        &#125;</span><br><span class="line">        return res + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/25/C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E5%92%8C%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/25/C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E5%92%8C%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">C语言编译和指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-25 19:28:00" itemprop="dateCreated datePublished" datetime="2019-05-25T19:28:00+08:00">2019-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-01 11:06:33" itemprop="dateModified" datetime="2022-10-01T11:06:33+08:00">2022-10-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>整型包括字符、短整型、整型和长整型，它们都分为有符号(singed)和无符号（皿sied）两种版本。长整型至少应该和整型一样长，而整型至少应该和短整型一样长。<br><img src="/img/20200826161100.png" alt=""></p>
<p>字符在本质上是小整型值。缺省的char要么是<code>signed char</code>，要么是<code>unsigned char</code>，这取决于编译器，只有当程序所使用的char型变量的值位于<code>signed char</code>和<code>unsigned char</code>的交集中，这个程序才是可移植的。</p>
<p>字符串常量：书写方式是<code>&quot;Hello&quot;</code>、<code>&quot;\aWarning!\a&quot;</code>、<code>&quot;Line1\nLine2&quot;</code>，</p>
<h2 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h2><p>一共有三种，<strong>external</strong>、<strong>internal</strong>、<strong>none</strong>，none被当作单独的个体，该标识符的多个声明被当作独立不同的实体。属于internal链接属性的标识符在同一个源文件内的所有声明中都指向同一个实体。属于external属性的标识符不管位于几个源文件都表示同一个实体。关键字<code>external</code>和<code>static</code>用于在声明中修改标识符的链接属性，external可以访问在其他任何位置定义的这个实体。在C中，static主要<strong>定义全局静态变量、定义局部静态变量、定义静态函数</strong>。</p>
<ul>
<li>定义全局静态变量：在全局变量前面加上关键字static，该全局变量变成了全局静态变量。全局静态变量有以下特点。<ul>
<li>在全局区分配内存。</li>
<li>如果没有初始化，其默认值为0.</li>
<li>该变量在本文件内从定义开始到文件结束可见。</li>
</ul>
</li>
<li>定义局部静态变量：在局部变量前面加上关键字static，其特点如下：<ul>
<li>该变量在全局数据区分配内存。</li>
<li>它始终驻留在全局数据区，直到程序运行结束。</li>
<li>其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。</li>
</ul>
</li>
<li>定义静态函数：在函数返回类型前加上static关键字，函数即被定义为静态函数，其特点如下：<ul>
<li>静态函数只能在本源文件中使用</li>
<li>在文件作用域中声明的inline函数默认为static类型</li>
</ul>
</li>
</ul>
<p>总结：用static定义的全局和局部静态变量的区别是，<strong>全局的静态变量的作用域和可见域都是从文件的定义开始到整个文件结束</strong>；而<strong>局部的静态变量可见域是从文件的定义开始到整个文件结束，作用域是从该语句块的定义开始到该语句块结束</strong>。</p>
<p>extern的用法：</p>
<ul>
<li>声明一个全局（外部）变量。当用extern声明一个全局变量的时候，首先应明确一点：extern的作用范围是整个工程，也就是说当我们在.h文件中写了<code>extern int a;</code>链接的时候链接器会去其他的.c文件中找有没有<code>int a</code>的定义，如果没有，链接报错；当<code>extern int a;</code>写在.c文件中时，链接器会在这个.c文件该声明语句之后找有没有<code>int a</code>的定义，然后去其他的.cpp文件中找，如果都找不到，链接报错。值得注意的一点：当extern语句出现在头文件中时，不要将声明和定义在一条语句中给出，也就是不要在头文件中写类似于这样的语句：<code>extern int a = 1;</code>，这种写法，在gcc编译时会给出一个警告：<code>warning: &#39;a&#39; initialized and declared &#39;extern&#39;</code>， </li>
<li>所有一般（提倡）的做法是：<strong>只在头文件中通过extern给出全局变量的声明（即external int a; 而不要写成external int a = 1;），并在源文件中给出定义（并且只能定义一次）</strong></li>
<li><code>extern “C” &#123; /*用C实现的内容（通常写在另外的.c文件中）*/ &#125;</code>。C++完全兼容C，当extern与“C”连用时，作用是告诉编译器用C的编译规则去解析extern “C”后面的内容。最常见的差别就是C++支持函数重载，而标准C是不支持的。如果不指明<code>extern “C”</code>，C++编译器会根据自己的规则在编译函数时为函数名加上特定的后缀以区别不同的重载版本，而如果是按C的标准来编译的话，则不需要。</li>
</ul>
<p>static和external定义的全局变量区别：</p>
<ul>
<li>static修饰全局变量时，声明和定义是同时给出的；而extern一般是定义和声明分开，且定义只能一次</li>
<li>static的全局作用域只是自身编译单元（即一个.c文件以及这个.c文件所包含的.h文件）；而extern的全局作用域是整个工程（一个工程可以包含很多个.h和.c文件）。即区别就在于“全局”的范围是整个工程，还是自身编译单元。</li>
</ul>
<h2 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h2><p>变量的存储类型(storagecs）是指<strong>存储变量值的内存类型</strong>。变量的存储类型决定变量何时创建、何时销毁以及它的值将保持多久。有三个地方可以用于存储变量：<strong>普通内存</strong>、<strong>运行时堆栈</strong>、<strong>硬件寄存器</strong>。凡是在任何代码块之外声明的变量总是存储于静态内存中，也就是不属于堆栈的内存，这类变量称为<strong>静态（static）变量</strong>。静态变量在程序运行之前创建，在程序的整个执行期间始终存在。它始终保持原先的值，除非给它赋一个不同的值或者程序结束。</p>
<p>在代码块内部声明的变量的缺省存储类型是<strong>自动</strong>(automatic),也就是说它<strong>存储于堆栈中</strong>，称为自动（auto）变量。在程序执行到声明自动变量的代码块时，自动变量才被创建，当程序的执行流离开该代码块时，这些自动变量便自行销毁。如果该代码块被数次执行，这些自动变量每次都将重新创建。对于在代码块内部声明的变量，如果给它加上关键字<code>static</code>，可以使它的存储类型从自动变为静态。<strong>具有静态存储类型的变量在整个程序执行过程中一直存在，而不仅仅在声明它的代码块的执行时存在</strong>。<strong>函数的形式参数不能声明为静态</strong>，因为实参总是在堆栈中传递给函数，用于支持递归。最后，关键字<code>register</code>可以用于自动变量的声明，提示它们应该存储于机器的硬件寄存器而不是内存中，这类变量称为<strong>寄存器变量</strong>。通常，寄存器变量比存储于内存的变量访问起来效率更高。</p>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>当它用于函数定义时，或用于代码块之外的变量声明时，static关键字用于修改标识符的链接属性，从external到internal，但标识符的存储类型和作用域不受影响。当它用于代码块内部的变量声明时，static关键字用于修改变量的存储类型，从自动变量修改为静态变量，但变量的链接属性和作用域不受影响。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>具有external链接属性的实体在其他语言的术语中成为全局实体，所有源文件中的所有函数均可以访问它。只要变量并非声明于代码块或函数定义内部，它在缺省情况下的链接属性即为external。如果一个变量声明于代码块内部，在它前面添加extern关键字将使它所引用的是全局变量而非局部变量。</p>
<p>具有extemal链接属性的实体总是具有静态存储类型。全局变量在程序开始执行前创建，并在程序整个执行过程中始终存在。从属于函数的局部变量在函数开始执行时创建，在函数执行完毕后销毁，但用于执行函数的机器指令在程序的生命期内一直存在。局部变量由函数内部使用，不能被其他函数通过名字引用。它在缺省情况下的存储类型为自动，这是基于两个原因：其一，当这些变量需要时才为它们分配存储，这样可以减少内存的总需求量。其二，在堆栈上为它们分配存储可以有效地实现递归。如果你觉得让变量的值在函数的多次调用中始终保持原先的值非常重要的话，你可以修改它的存储类型，把它从自动变量改为静态变量。<br><img src="/img/1598433687.jpg" alt=""></p>
<h1 id="操作符和表达式"><a href="#操作符和表达式" class="headerlink" title="操作符和表达式"></a>操作符和表达式</h1><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>移位操作简单地把一个值的位向左或向右移动。在左移位中，值最左边的几位被丢弃掉，右边多出来的几个空位则由0补齐。算术左移和逻辑左移是一样的。右移位时，一种是逻辑移位，左边移入的位用0填充，另一种是算术移位，左边移入的位由原先的符号位决定，保证原数的正负形式不变。<br><img src="/img/1598668146.png" alt=""></p>
<p>无符号值的所有移位操作都是逻辑移位，对于有符号值，采用逻辑移位还是算术移位取决于编译器。</p>
<p>第一个把指定的位设置为1：<code>value = value | 1 &lt;&lt; bit_number</code>，第二个把指定的位清0：<code>value = value &amp; ~ (1 &lt;&lt; bit_number)</code>。</p>
<p>前缀和后缀形式的增值操作符都是复制一份变量值的拷贝，用于递增表达式的值正是这份拷贝，前缀操作符在进行复制之前增加变量的值，后缀操作符在进行复制之后才增加变量的值。这些操作符的结果是<strong>变量值的拷贝</strong>。</p>
<p>逻辑操作符（&amp;&amp;和||）具有短路性质，如果表达式的值根据左操作数即可决定，它就不再对右操作数进行求值。</p>
<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>零是假，任何非零值皆为真。</p>
<h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><p>左值就是能够出现在赋值符号左边的东西，右值就是能够出现在赋值符号右边的东西。如<code>a = b + 25</code>，a是个左值，因为它表示了一个可以存储结果值的地点，b + 25是个右值，因为它指定了一个值。</p>
<h2 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h2><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>C的整形算术运算至少以缺省整型类型的精度来进行，为了达到这个精度，表达式中的字符型和短整型操作数在使用之前需要被转换成普通整型。如果某个操作符的各个操作数属于不同类型，那么一个操作数转换为另一个操作数的类型。</p>
<h3 id="操作符的属性"><a href="#操作符的属性" class="headerlink" title="操作符的属性"></a>操作符的属性</h3><p>两个相邻的操作符哪个先执行取决于它们的优先级，如果优先级相同，则执行顺序由结合性决定。每个操作符的所有属性都在优先级表中。<br><img src="/img/1598684046.png" alt=""><br><img src="/img/1598684046.jpg" alt=""></p>
<h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><p>有操作符的右移位操作是不可移植的。移位操作的位数不可以是个负值。连续赋值中各个变量的长度需要一致。</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="内存和地址"><a href="#内存和地址" class="headerlink" title="内存和地址"></a>内存和地址</h2><p>尽管一个字包含了4个字节，但是它仍然只有一个地址，至于它的地址是最左边的字节的位置还是最右边的字节的位置，取决于机器。另一个需要注意的是<strong>边界对齐</strong>，整型值存储的起始位置只能是某些特定的字节，通常是2或4的倍数。硬件仍然通过地址访问内存位置。</p>
<h2 id="值和类型"><a href="#值和类型" class="headerlink" title="值和类型"></a>值和类型</h2><p>不能简单地通过检查一个值的位来判断它的类型，必须观察这个值的使用方式。比如<code>01100111011011000110111101100010</code>这个值，可能被解释成多种：<br><img src="/img/1598685148.jpg" alt=""></p>
<h2 id="间接访问操作符"><a href="#间接访问操作符" class="headerlink" title="间接访问操作符"></a>间接访问操作符</h2><p>通过指针访问所指向的地址的过程称为<strong>间接访问</strong>或<strong>解引用指针</strong>，这个用于执行间接访问的操作符是<code>*</code>。</p>
<h2 id="未初始化和非法的指针"><a href="#未初始化和非法的指针" class="headerlink" title="未初始化和非法的指针"></a>未初始化和非法的指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a;</span><br><span class="line">*a = <span class="number">12</span>;</span><br></pre></td></tr></table></figure>
<p>这个声明创建了一个名叫a的指针变量，后边那条赋值语句把12存储在a所指的内存位置，但是不知道a具体指向的位置，声明一个指向int的指针也不会创建用于存储整型值的空间。在UNIX中，这个错误被称为<strong>段违例（segmentation violation）</strong>，它提示程序试图访问一个并未分配给程序的内存位置。</p>
<h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><p>NULL表示指针未指向任何东西。</p>
<p><code>*100 = 25</code>是错误的，间接访问操作只能作用于指针类型表达式，如果确实想把25存于位置100，需要使用强制类型转换<code>*(int*)100 = 25</code>。</p>
<h2 id="指针表达式"><a href="#指针表达式" class="headerlink" title="指针表达式"></a>指针表达式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> *cp = &amp;ch;</span><br></pre></td></tr></table></figure>
<p>如<code>ch</code>表达式，当它作为右值使用时，表达式的值为<code>&#39;a&#39;</code>，当这个表达式作为左值使用时，它是这个内存的地址而不是该地址所包含的值。</p>
<p>作为右值，这个表达式的值是变量ch的地址。<br><img src="/img/1598686875.jpg" alt=""></p>
<p>*的优先级高于+，所以首先执行间接访问操作，可以得到它的值，取这个值的一份拷贝并把它与1相加，最终结果是’b’，<br><img src="/img/1598686941.jpg" alt=""></p>
<p><img src="/img/1598687123.jpg" alt=""><br><img src="/img/1598687150.jpg" alt=""></p>
<p>使用后缀++操作符产生的结果不同，它的右值和左值分别是变量ch的值和ch的内存位置，也就是cp原先所指。间接访问操作符和后缀++的组合令人费解，这里涉及三个步骤：</p>
<ul>
<li>++操作符产生cp的一份拷贝</li>
<li>++操作符增加cp的值</li>
<li>在cp的拷贝上执行间接访问</li>
</ul>
<p>当一个指针和一个整数量执行算术运算时，整数在执行加法运算前始终会根据<strong>指针所指向类型的大小</strong>进行调整，“调整”就是把整数值和“合适的大小”相乘。如果两个指针所指向的不是同一个数组的元素，那么他们之间相减的结果是未定义的，如果是，则结果为两个指针之间的距离。<br><img src="/img/1598690605.jpg" alt=""></p>
<p>对指针执行关系运算也是有限制的，用关系操作符对两个指针值进行比较是可能的，不过前提是他们指向同一个数组的元素。下边的循环使数组以相反的次序清除，让vp指向数组最后那个元素后边的内存位置，但在对它进行间接访问之前先执行自减操作，当vp指向数组第一个元素时，循环便告终止，不过这发生在第一个数组元素被清除之后。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(vp = &amp;value[N_VALUE]; vp &gt; &amp;value[<span class="number">0</span>];)</span><br><span class="line">    *--vp = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>如果对其简化，现在vp指向数组最后一个元素，它的自减操作放在for的调整部分执行，在第一个元素被清除之后，vp的值还将减去1，而接下去的一次比较是用于结束循环的，比较表达式<code>vp &gt;= &amp;value[0]</code>的值未定义，因为vp移动到了数组边界之外。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(vp = &amp;value[N_VALUE<span class="number">-1</span>]; vp &gt;= &amp;value[<span class="number">0</span>]; vp --)</span><br><span class="line">    *vp = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>C函数的所有参数均以<strong>传值调用</strong>方式进行传递，这意味着函数将<strong>获得参数值的一份拷贝</strong>。如果被传递的参数是一个数组名，函数将访问调用程序的数组元素，数组并不会被复制。这个行为被称为<strong>传址调用</strong>。数组名的值实际上是一个指针，<strong>传递给函数的就是这个指针的一份拷贝</strong>。下标引用实际上是间接访问的另一种形式，它可以对指针执行间接访问操作，访问指针指向的内存位置。只要记住两个规则：</p>
<ol>
<li>传递给函数的标量参数是传值调用的。</li>
<li>传递给函数的数组参数在行为上就像它们是通过传址调用的那样。</li>
</ol>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="指针的效率"><a href="#指针的效率" class="headerlink" title="指针的效率"></a>指针的效率</h2><ol>
<li>当你根据某个固定数目的增量在一个数组中移动时，<strong>使用指针变量将比使用下标产生效率更高的代码</strong>。当这个增量是1并且机器具有地址自动增量模型时，这点表现得更为突出。</li>
<li>声明为寄存器变量的指针通常比位于静态内存和堆栈中的指针效率更高（具体提高的幅度取决于你所使用的机器）。</li>
<li>如果你可以通过测试一些己经初始化并经过调整的内容来判断循环是否应该终止，那么你就不需要使用一个单独的计数器。</li>
<li>那些必须在运行时求值的表达式较之诸如<code>&amp;array[SIZE]</code>或<code>array+SIZE</code>这样的常量表达式往往代价更高。</li>
</ol>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="静态和自动初始化"><a href="#静态和自动初始化" class="headerlink" title="静态和自动初始化"></a>静态和自动初始化</h3><p>数组初始化的方式取决于它们的存储类型。<strong>存储于静态内存的数组只初始化一次</strong>，也就是在程序开始执行之前。程序并不需要执行指令把这些值放到合适的位置，这由链接器完成的，它用包含可执行程序的文件中合适的值对数组元素进行初始化。如果数组未被初始化，数组元素的初始值将会自动设置为零。当这个文件载入到内存中准备执行时，初始化后的数组值和程序指令一样也被载入到内存中。自动变量在缺省情况下是未初始化的。如果自动变量的声明中给出了初始值，则每次执行流执行到这里时都会初始化。</p>
<p>如果初始化不完整，如<code>int vector[5] = &#123;1, 2, 3&#125;</code>，则之后的元素都会被初始化为0。如果声明中没有给出长度，编译器就把数组的长度设置为刚好容纳所有的初始值的长度。</p>
<p><code>char message1[] = &quot;hello&quot;</code>和<code>char *message2 = &quot;hello&quot;</code>具有不同的含义，前者初始化一个字符数组的元素，后者则是一个真正的字符串常量。</p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>C中，多维数组的元素存储按照最右边的下标率先变化的原则，称为<strong>行主序</strong>。作为函数参数的多维数组的实际传递的是个指向数组第一个元素的指针，但是编译器需要知道维数。如<code>void func(int matrix[][10])</code>，</p>
<h1 id="字符串、字符和字节"><a href="#字符串、字符和字节" class="headerlink" title="字符串、字符和字节"></a>字符串、字符和字节</h1><h2 id="不受限制的字符串函数"><a href="#不受限制的字符串函数" class="headerlink" title="不受限制的字符串函数"></a>不受限制的字符串函数</h2><p>常用的字符串函数都是“不受限制”的，只是通过寻找字符串参数结尾的NULL字节来判断长度。必须保证字符串不会溢出。如<code>strcmp</code>，<code>strcpy</code>，<code>strcat</code>。标准库还包含了一类函数，接收一个显式的长度参数用于限定进行复制或比较的字符数，如<code>strncmp</code>，<code>strncpy</code>，<code>strncat</code>。</p>
<p>和<code>strcpy</code>一样，<code>strncpy</code>把源字符串的字符复制到目标数组。然而，它总是正好向dst写入len个字符。如果<code>strlen(src0)</code>的值小于len，dst数组就用额外的NUL字节填充到len长度。如果<code>strlen(src)</code>的值大于或等于len，那么只有len个字符被复制到dst中。<strong>注意！它的结果将不会以NUL字节结尾</strong>。</p>
<h2 id="字符串查找基础"><a href="#字符串查找基础" class="headerlink" title="字符串查找基础"></a>字符串查找基础</h2><p>在字符串中查找字符最简单的方法是<code>char *strchr(char const *str, int ch)</code>或<code>char *strrchr(char const *str, int ch)</code>，在str中查找ch第一次出现的位置。<code>strrchr</code>返回最后一次出现的位置。</p>
<p><code>strpbrk</code>查找任何一组字符第一次在字符串中出现的位置，<code>char *strpbrk(char const *str, char const *group)</code>，返回一个指向str中第一个匹配group中任何一个字符的字符位置。<code>strstr</code>查找s1在整个s2中第一次出现的位置。</p>
<h2 id="高级字符串查找"><a href="#高级字符串查找" class="headerlink" title="高级字符串查找"></a>高级字符串查找</h2><p><code>strspn</code>和<code>strcspn</code>用于在字符串的起始位置对字符计数，计算字符串str中连续有几个字符都属于字符串accept，原型为<code>size_t strspn(const char *str, const char * accept);</code>。</p>
<ul>
<li>【函数说明】strspn() 从参数 str 字符串的开头计算连续的字符，而这些字符都完全是 accept 所指字符串中的字符。简单的说，若 strspn() 返回的数值为n，则代表字符串 str 开头连续有 n 个字符都是属于字符串 accept 内的字符。</li>
<li><p>【返回值】返回字符串 str 开头连续包含字符串 accept 内的字符数目。所以，如果 str 所包含的字符都属于 accept，那么返回 str 的长度；如果 str 的第一个字符不属于 accept，那么返回 0。</p>
</li>
<li><p>注意：检索的字符是区分大小写的。</p>
</li>
<li>提示：函数 strcspn() 的含义与 strspn() 相反，可以对比学习。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> str[] = <span class="string">&quot;129th&quot;</span>;</span><br><span class="line">  <span class="type">char</span> accept[] = <span class="string">&quot;1234567890&quot;</span>;</span><br><span class="line">  i = <span class="built_in">strspn</span>(str, accept);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str 前 %d 个字符都属于 accept\n&quot;</span>,i);</span><br><span class="line">  system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：<code>str 前 3 个字符都属于 accept</code></p>
<p>C语言<code>strcspn()</code>函数：计算字符串str中连续有几个字符都不属于字符串accept，头文件：<code>#inclued&lt;string.h&gt;</code>。strcspn() 用来计算字符串 str 中连续有几个字符都不属于字符串 accept，其原型为：<code>int strcspn(char *str, char *accept);</code></p>
<ul>
<li>【参数说明】str、accept为要进行查找的两个字符串。strcspn() 从字符串 str 的开头计算连续的字符，而这些字符都完全不在字符串 accept 中。简单地说，若 strcspn() 返回的数值为 n，则代表字符串 str 开头连续有 n 个字符都不含字符串 accept 中的字符。</li>
<li>【返回值】返回字符串 str 开头连续不含字符串 accept 内的字符数目。</li>
<li>注意：如果 str 中的字符都没有在 accept 中出现，那么将返回 atr 的长度；检索的字符是区分大小写的。</li>
<li>提示：函数 strspn() 的含义与 strcspn() 相反，可以对比学习。</li>
</ul>
<p>【示例】返回s1、s2包含的相同字符串的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span>* s1 = <span class="string">&quot;http://c.biancheng.net/cpp/u/biaozhunku/&quot;</span>;</span><br><span class="line">  <span class="type">char</span>* s2 = <span class="string">&quot;c is good&quot;</span>;</span><br><span class="line">  <span class="type">int</span> n = <span class="built_in">strcspn</span>(s1,s2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The first char both in s1 and s2 is :%c\n&quot;</span>,s1[n]); </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The position in s1 is: %d\n&quot;</span>,n);</span><br><span class="line">  system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>strtok</code>从字符串中隔离各个单独的称为标记的部分，并丢弃分隔符。<code>char * strtok(char *s, const char *delim);</code>strtok()用来将字符串分割成一个个片段。参数s 指向欲分割的字符串，参数delim 则为分割字符串，当strtok()在参数s 的字符串中发现到参数delim 的分割字符时则会将该字符改为\0 字符。在第一次调用时，strtok()必需给予参数s 字符串，往后的调用则将参数s 设置成NULL。每次调用成功则返回下一个分割后的字符串指针。</p>
<p>返回值：返回下一个分割后的字符串指针，如果已无从分割则返回NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;ab-cd : ef;gh :i-jkl;mnop;qrs-tu: vwx-y;z&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *delim = <span class="string">&quot;-: &quot;</span>;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, strtok(s, delim));</span><br><span class="line">    <span class="keyword">while</span>((p = strtok(<span class="literal">NULL</span>, delim)))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符操作"><a href="#字符操作" class="headerlink" title="字符操作"></a>字符操作</h2><p>以下函数位于<code>ctype.h</code>中。<br><img src="/img/1598953892.jpg" alt=""></p>
<p>转换函数用于把大写字符转化为小写，<code>tolower</code>和<code>toupper</code>。</p>
<h2 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h2><p>非字符串数据内部包含0值时，无法用字符串函数来处理。不过可以使用另一组相关的函数，他们的操作与字符串函数类似。</p>
<ul>
<li><code>void *memcpy(void *dst, void const *src, size_t length)</code>从src的起始位置复制length个字节到dst的内存起始位置。</li>
<li><code>void *memmove(void *dst, void const *src, size_t length)</code>和memcpy的行为差不多，不过它的源和目标操作数可以重叠。</li>
<li><code>void *memcmp(void const *a, void const *b, size_t length)</code>对两端内存的内容进行比较，这些值按照无符号字符逐字节比较。</li>
<li><code>void *memchr(void const *a, int ch, size_t length)</code>从a的起始位置开始查找字符ch第一次出现的位置，并返回一个指向该位置的指针。</li>
<li><code>void *memset(void *a, int ch, size_t length)</code>把从a开始的length个字节都设置为字符值ch。</li>
</ul>
<h1 id="结构和联合"><a href="#结构和联合" class="headerlink" title="结构和联合"></a>结构和联合</h1><h2 id="结构的存储分配"><a href="#结构的存储分配" class="headerlink" title="结构的存储分配"></a>结构的存储分配</h2><p>考虑这个结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ALIGN</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果某机器的整型值长度为4个字节，并且它的起始存储位置必须被4整除，那么这个结构在内存中将如下：<br><img src="/img/1598960562.jpg" alt=""></p>
<p>所有结构起始存储位置必须是结构中边界要求最严格的数据类型所要求的。成员a必须存储于一个能被4整除的地址。下一个成员是整型值，所以必须跳过3个字节到达合适的边界。可以在声明中对结构的成员列表重新排列，让那些<strong>对边界要求最严格的成员首先出现</strong>。</p>
<p><code>sizeof</code>操作符能够得出一个结构的整体长度，包括因边界对齐而跳过的那些字节。如果你必须确定结构某个成员的实际位置，应该考虑边界对齐因素，可以使用<code>offsetof</code>宏（定义于stddef.h)。<code>offsetof(type,member)</code>，type就是结构的类型，member就是你需要的那个成员名。表达式的结果是一个size_t值，表示这个指定成员开始存储的位置距离结构开始存储的位置偏移几个字节。例如，对前面那个声明而言<code>offsetof(struct ALIGN, b)</code>的返回值是4。</p>
<h2 id="位段"><a href="#位段" class="headerlink" title="位段"></a>位段</h2><p>位段的成员是一个或多个位的字段，让这些不同长度的字段其实存在于一个或多个整型变量中。位段成员必须声明为<code>int</code>，<code>signed int</code>，<code>unsigned int</code>三种，其次，在成员名后边是一个冒号和一整数，整数指定为该位段所占用的位的数目。</p>
<p>注重可移植性的程序应该避免使用位段。由于下面这些与实现有关的依赖性，位段在不同的系统中可能有不同的结果。</p>
<ol>
<li>int位段被当作有符号数还是无符号数。</li>
<li>位段中位的最大数目。许多编译器把位段成员的长度限制在一个整型值的长度之内，所以一个能够运行于32位整数的机器上的位段声明可能在16位整数的机器上无法运行。</li>
<li>位段中的成员在内存中是从左向右分配的还是从右向左分配的。</li>
<li>当一个声明指定了两个位段，第2个位段比较大，无法容纳于第1个位段剩余的位时，编译器有可能把第2个位段放在内存的下一个字，也可能直接放在第1个位段后面，从而在两个内存位置的边界上形成重叠。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CHAR</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> ch : <span class="number">7</span>;</span><br><span class="line">    <span class="type">unsigned</span> font : <span class="number">6</span>;</span><br><span class="line">    <span class="type">unsigned</span> size : <span class="number">19</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>位段能够利用存储ch和font所剩余的位来增加size的位数，这样避免了声名一个32位的整数来存储size位段。它也可以很方便的访问一个整型值的部分内容。假定磁盘控制器其中一个寄存器是如下定义的：<br><img src="/img/1598964423.jpg" alt=""></p>
<p>前五个位段每个都占1位，其余几个位段长些，在一个从右向左分配位段的机器上，下面这个声明允许方便地对寄存器的不同位段进行访问：<br><img src="/img/1598964923.jpg" alt=""></p>
<h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h1><h2 id="malloc和free"><a href="#malloc和free" class="headerlink" title="malloc和free"></a>malloc和free</h2><p>C函数库提供了两个函数，<code>malloc</code>和<code>free</code>，分别用于<strong>执行动态内存分配和释放</strong>。这些函数维护一个可用内存池。malloc从内存池中提取一块合适的内存，并向该程序返回一个指向这块内存的指针。当一块以前分配的内存不再使用时，程序调用free函数把它归还给内存池供以后之需。<br><code>void* malloc(size_t size)</code>的参数就是需要分配的内存字节（字符）数。如果内存池中的可用内存可以满足这个需求，malloc就返回一个指向被分配的内存块起始位置的指针。<strong>maloc所分配的是一块连续的内存</strong>。如果内存池的可用内存无法满足你的请求，malloc函数向操作系统请求，要求得到更多的内存，并在这块新内存上执行分配任务。如果操作系统无法向malloc提供更多的内存，maloc就返回一个NULL指针。因此，<strong>对每个从malloc返回的指针都进行检查，确保它并非NULL是非常重要的</strong>。</p>
<p><code>void free(void *pointer)</code>的参数必须要么是NULL，要么是一个先前从malloc、calloc或realloc（稍后描述）返回的值。向free传递一个NULL参数不会产生任何效果。</p>
<p>对于要求边界对齐的机器，malloc所返回的内存的起始位置将始终能够满足对边界对齐要求最严格的类型的要求。</p>
<h2 id="calloc和realloc"><a href="#calloc和realloc" class="headerlink" title="calloc和realloc"></a>calloc和realloc</h2><p>另外还有两个内存分配函数，calloc和realloco它们的原型如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> num_elements, <span class="type">size_t</span> element_size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">realloc</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> new_size)</span>;</span><br></pre></td></tr></table></figure>
<p>calloc也用于分配内存，在返回指向内存的指针之前把它初始化为0。realloc用于修改一个原先已经分配的内存块的大小，如果它用于扩大一个内润康，那么这块内存原先的内容依然保留，新添加的内存块在原先内存块后边，如果原先内存块无法改变大小，realloc会分配另一块正确大小的内存。</p>
<p>动态内存分配最常见的错误就是忘记检查所请求的内存是否成功分配。动态内存分配的第二大错误来源是操作内存时超出了分配内存的边界。例如，如果你得到一个25个整型的数组，进行下标引用作时如果下标值小于0或大于24将引起两种类型的问题。</p>
<ul>
<li>第1种问题显而易见：被访问的内存可能保存了其他变量的值。对它进行修改将破坏那个变量，修改那个变量将破坏你存储在那里的值。这种类型的bug非常难以发现。</li>
<li>第2种问题不是那么明显。在malloc和free的有些实现中，它们以链表的形式维护可用的内存池。对分配的内存之外的区域进行访问可能破坏这个链表，这有可能产生异常，从而终止程序。</li>
</ul>
<p>动态分配的内存不再需要时，它应该被释放，分配内存但在使用完毕后不释放将引起内存泄漏。</p>
<h1 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h1><h2 id="预定义符号"><a href="#预定义符号" class="headerlink" title="预定义符号"></a>预定义符号</h2><p>预处理器定义了一些符号：<br><img src="/img/1599132186.png" alt=""></p>
<h2 id="define"><a href="#define" class="headerlink" title="#define"></a><code>#define</code></h2><p><code>#define</code>的正式描述为<code>#define name stuff</code>，每当有符号name出现在这条指令之后时，预处理器就会把它替换为stuff。如果定义中的stuff很长，可以加上<code>\</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_PRINT printf(<span class="string">&quot;File %s line %d&quot;</span> \</span></span><br><span class="line"><span class="meta">                            <span class="string">&quot;x = %d, y = %d, z = %d&quot;</span>, \</span></span><br><span class="line"><span class="meta">                            __FILE__, __LINE__, \</span></span><br><span class="line"><span class="meta">                            x, y, z)</span></span><br></pre></td></tr></table></figure>
<p><code>#define</code>机制包括了一个规定，允许把参数替换到文本中，这种方法叫做<strong>宏</strong>，所有用于对数值表达式进行求值的宏定义都应该加上括号，避免使用宏时参数中的操作符或邻近的操作符之间的相互作用。</p>
<p><strong>**</strong> 识别结果 1<strong>**</strong></p>
<p>在程序中扩展<code>#define</code>定义符号和宏时，需要涉及儿个步骤。</p>
<ol>
<li>在调用宏时，首先对参数进行检查，看看是否包含了任何由<code>#define</code>定义的符号。如果是，它们首先被替换。</li>
<li>替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被它们的值所替代。</li>
<li>最后，再次对结果文本进行扫描，看看它是否包含了任何由<code>#define</code>定义的符号。如果是，就重复上述处理过程。</li>
</ol>
<p>这样，宏参数和<code>#define</code>定义可以包含其他<code>#define</code>定义的符号。但是，宏不可以出现递归。当预处理器搜索<code>#define</code>定义的符号时，字符串常量的内容并不进行检查。你如果想把宏参数插入到字符串常量中，可以使用两种技巧。</p>
<ul>
<li>首先，邻近字符串自动连接的特性使我们很容易把一个字符串分成几段，每段实际上都是一个宏参数。</li>
<li>使用预处理器把一个宏参数转换为一个字符串，<code>#argument</code>这种结构会被预处理器翻译为<code>argument</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT(FORMAT, VALUE)   \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;The value of #VALUE  \</span></span></span><br><span class="line"><span class="string"><span class="meta">        &quot;</span> is <span class="string">&quot; FORMAT &quot;</span>\n<span class="string">&quot;, VALUE)</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">PRINT(&quot;</span>%d<span class="string">&quot;, x + 3);</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">生成：</span></span></span><br><span class="line"><span class="string"><span class="meta">The value of x + 3 is 25</span></span></span><br></pre></td></tr></table></figure>
<p><code>##</code>结构把位于两边的符号连接成一个符号，允许宏定义从分离的文本片段创建标识符。</p>
<p><img src="/img/1599134018.jpg" alt=""></p>
<p>许多C编译器允许在命令行中定义符号，用于启动编译过程，在UNIX编译器中，<code>-D</code>可以完成，如<code>-Dname</code>和<code>-Dname=stuff</code>。</p>
<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>条件编译可以选择代码的一部分是被正常编译还是完全忽略。用于支持条件编译的基本结构是<code>#if</code>指令和与其匹配的<code>#endif</code>指令。下面显示了它最简单的语法形式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> constant-expression</span></span><br><span class="line">    statements</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>其中，constant-expression（常量表达式）由预处理器进行求值。如果它的值是非零值（真），那么statements部分就被正常编译，否则预处理器就安静地删除它们。所谓常量表达式，就是说它或者是字面值常量，或者是一个由<code>#define</code>定义的符号。如果变量在执行期之前无法获得它们的值，那么它们如果出现在常量表达式中就是非法的，因为它们的值在编译时是不可预测的。</p>
<p><code>#include</code>指令用于实现文件包含。它具有两种形式。</p>
<ul>
<li>如果文件名位于一对尖括号中，编译器将在由编译器定义的标准位置查找这个文件。这种形式通常用于包含函数库头文件时。</li>
<li>另一种形式，文件名出现在一对双引号内。不同的编译器可以用不同的方式处理这种形式。</li>
<li>但是，如果用于处理本地头文件的任何特殊处理方法无法找到这个头文件，那么编译器接下来就使用标准查找过程来寻找它。</li>
</ul>
<p><code>#error</code>指令在编译时产生一条错误信息，信息中包含的是你所选择的文本。<code>#line</code>指令允许你告诉编译器下一行输入的行号，如果它加上了可选内容，它还将告诉编译器输入源文件的名字。因编译器而异的<code>#progma</code>指令允许编译器提供不标准的处理过程，比如向一个函数插入内联的汇编代码。</p>
<h1 id="输入输出函数"><a href="#输入输出函数" class="headerlink" title="输入输出函数"></a>输入输出函数</h1><h2 id="错误报告"><a href="#错误报告" class="headerlink" title="错误报告"></a>错误报告</h2><p>perror函数可以报告错误。原型是<code>void perror(char const * msg)</code>，如果msg不是NULL并且指向一个非空的字符串，perror会打印出这个字符串，并打印当前错误代码的信息。</p>
<p>另一个有用的函数是exit，它用于终止一个程序的执行。它的原型定义于<code>stdlib.h</code>，如下所示：<code>void exit(int status)</code>，status参数返回给操作系统，用于提示程序是否正常完成。这个值和main函数返回的整型状态值相同。预定义符号<code>EXIT_SUCCESS</code>和<code>EXIT_FAILURE</code>分别提示程序的终止是成功还是失败。这个函数没有返回值。当exit函数结束时，程序己经消失，所以它无处可返。</p>
<h2 id="标准IO函数库"><a href="#标准IO函数库" class="headerlink" title="标准IO函数库"></a>标准IO函数库</h2><p>K&amp;R C最早的编译器的函数库在支持输入和输出方面功能甚弱。其结果是，程序员如果需要使用比函数库所提供的I/O更为复杂的功能时，他不得不自己实现。<br>有了标准I/O函数之后，这种情况得到了极大的改观。标准IO函数库具有一组IO函数，实现了在原先的IO库基础上许多程序员自行添加实现的额外功能。这个函数库对现存的函数进行了扩展，例如为printf创建了不同的版本，可以用于各种不同的场合。</p>
<p>头文件<code>stdio.h</code>包含了与ANSI函数库的I/O部分有关的声明。ANSI进一步对IO的概念进行了抽象。就C程序而言，所有的1/0操作只是简单地从程序移进或移出字节的事情。因此，毫不惊奇的是，这种字节流便被称为流（stream）。</p>
<p>绝大多数流是完全缓冲的(fully buffered)，这意味着“读取”和“写入”实际上是从一块被称为<strong>缓冲区</strong>的内存区域来回复制数据。从内存中来回复制数据是非常快速的。用于输出流的缓冲区只有当它写满时才会被刷新（flush，物理写入）到设备或文件中。一次性把写满的缓冲区写入和逐片把程序产生的输出分别写入相比效率更高。类似，输入缓冲区当它为空时通过从设备或文件读取下一块较大的输入，重新填充缓冲区。</p>
<p>如果程序失攸，缓冲输出可能不会被实际写入，这就可能使程序员得到关于错误出现位置的不正确结论。这个问题的解决方法就是在每个用于调试的printf函数之后立即调用fflush，如下所示：<code>printf(&quot;something or other&quot;); fflush(stdout)</code></p>
<h2 id="流IO总览"><a href="#流IO总览" class="headerlink" title="流IO总览"></a>流IO总览</h2><p>标准库函数使我们在C程序中执行与文件相关的IO任务非常方便。</p>
<ol>
<li>程序为必须同时处于活动状态的每个文件声明一个指针变量，其类型为<code>FILE*</code>。这个指针指向这个FILE结构，当它处于活动状态时由流使用。</li>
<li>流通过调用fopen函数打开。为了打开一个流，你必须指定需要访问的文件或设备以及它们的访问方式（例如，读、写或者既读又写）。fopen和操作系统验证文件或设备确实存在并初始化FILE结构。</li>
<li>然后，根据需要对该文件进行读取或写入。</li>
<li>最后，调用fclose函数关闭流。关闭一个流可以防止与它相关联的文件被再次访问，保证任何存储于缓冲区的数据被正确地写到文件中，并且释放FILE结构使它可以用于另外的文件。</li>
</ol>
<p>I/O函数以三种基本的形式处理数据：<strong>单个字符</strong>、<strong>文本行</strong>和<strong>二进制数据</strong>。对于每种形式，都有一组特定的函数对它们进行处理。<br><img src="/img/1599140980.jpg" alt=""></p>
<p>这些函数的区别在于获得输入的来源或输出写入的地方不同。这些变种用于执行下面的任务：</p>
<ol>
<li>只用于stdin或stdout</li>
<li>随作为参数的流使用。</li>
<li>使用内存中的字符串而不是流。</li>
</ol>
<p><img src="/img/1599141020.jpg" alt=""></p>
<h2 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h2><p><code>fopen</code>函数打开一个特定的文件，并把一个流和这个文件相关联。它的原型下所示：<code>FILE *fopen(char ccnst *name, char const *mode);</code>。两个参数都是字符串。name是你希望打开的文件或设备的名字。创建文件名的规则在不同的系统中可能各不相同，所以fopen把文件名作为一个字符串而不是作为路径名、驱动器字母、文件扩展名等各准备一个参数。mode（模式）参数提示流是用于只读、只写还是既读又写，以及它是文本流还是二进制流。下面的表格列出了一些常用的模式。<br><img src="/img/1599141290.jpg" alt=""></p>
<p>mode以r、w或a开头，分别表示打开的流用于读取、写入还是添加。如果一个文件打开是用于读取的，那么它必须是原先已经存在的。但是，如果一个文件打开是用于写入的，如果它原先己经存在，那么它原来的内容就会被删除。如果它原先不存在，那么就创建一个新文件。如果一个打开用于添加的文件原先并不存在，那么它将被创建。如果它原先己经存在，它原先的内容并不会被删除。</p>
<p>如果fopen函数执行成功，它返回一个指向FILE结构的指针，该结构代表这个新创建的流。如果函数执行失败，它就返回一个NULL指针，errno会提示问题的性质。</p>
<p>流使用函数<code>fclose</code>关闭的，<code>int fclose(FILE* f)</code>，fclose在文件关闭之前刷新缓冲区，如果它执行成功则返回0，否则返回EOF。</p>
<h2 id="字符IO"><a href="#字符IO" class="headerlink" title="字符IO"></a>字符IO</h2><p>字符输入是由<code>getchar</code>函数家族执行的，它们的原型如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getc</span><span class="params">(FILE *strearn)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>需要操作的流作为参数传递给getc和fgetc，但getchar始终从标准输入读取。每个函数从流中读取下一个字符，并把它作为函数的返回值返回。如果流中不存在更多的字符，函数就返回常量值EOF。返回int型值的真正原因是为了允许报告文件的末尾(EOF)。如果返回值是char型，那么在256个字符中必须有一个被指定用于表示EOF。如果这个字符出现在文件内部，那么这个字符以后的内容将不会被读取，因为它被解释为EOF标志。</p>
<p>EOF被定义为一个整型，它的值在任何可能出现的字符范围之外。这种解决方法允许我们使用这些函数来读取二进制文件。</p>
<p>为了把单个字符写入到流中，你可以使用putchar函数家族。它们的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> character, FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putc</span><span class="params">(<span class="type">int</span> character, FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">int</span> character)</span>;</span><br></pre></td></tr></table></figure>
<p>第1个参数是要被打印的字符。在打印之前，函数把这个整型参数裁剪为一个无符号字符型值，所以<code>putchar(&#39;abc&#39;）</code>仅仅打印一个字符。</p>
<p><code>fgetc</code>和<code>fputc</code>都是真正的函数，但<code>getc</code>、<code>putc</code>、<code>getchar</code>和<code>putchar</code>都是通过<code>#define</code>指令定义的宏。之所以提供两种类型的方法，是为了允许你根据程序的长度和执行速度哪个更重要选择正确的方法。</p>
<h2 id="未格式化的行IO"><a href="#未格式化的行IO" class="headerlink" title="未格式化的行IO"></a>未格式化的行IO</h2><p>未格式化的IO（unformatted line IO）简单读取或写入字符串，而格式化的IO则执行数字和其他变量的内部和外部表示形式之间的转换。gets和puts函数家族是用于操作字符串而不是单个字符。这个特征使它们在那些处理一行行文本输入的程序中非常有用。这些函数的原型如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char *fgets(char *buffer, int buffer_size, FILE *stream);</span><br><span class="line">char *gets(char *buffer);</span><br><span class="line">int fputs(char const *buffer, FILE *stream);</span><br><span class="line">int puts(char const *buffer);</span><br></pre></td></tr></table></figure>
<p>fgets从指定的stream读取字符并把它们复制到buffer中。当它读取一个换行符并存储到缓冲区之后就不再读取。如果缓冲区内存储的字符数达到buffer_size-1个时它也停止读取。在这种情况下，并不会出现数据丢失的情况，因为下一次调用fgets将从流的下一个字符开始读取。在任何一种情况<br>下，一个NULL字节将被添加到缓冲区所存储数据的末尾，使它成为一个字符串。如果在任何字符读取前就到达了文件尾，缓冲区就未进行修改，fgets函数返回一个NULL指针。否则，fgets返回它的第1个参数（指向缓冲区的指针）。这个返回值通常只用于检查是否到达了文件尾。</p>
<h2 id="二进制IO"><a href="#二进制IO" class="headerlink" title="二进制IO"></a>二进制IO</h2><p>fread用于读取二进制数据，fwrite用于写入二进制数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *buffer, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *stream)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">void</span> *buffer, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<p>buffer是一个指向用于保存数据的内存位置的指针，size是缓冲区中每个元素的字节数，count是读取或写入的元素数，当然stream是数据读取或写入的流。buffer参数被解释为一个或多个值的数组。count参数指定数组中有多少个值，所以读取或写入一个标量时，count的值应为函数的返回值是实际读取或写入的元素（并非字节）数目。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VALUE</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">    <span class="type">char</span> c[SIZE];</span><br><span class="line">&#125; values[ARRAY_SIZE]；</span><br><span class="line">n_value = fread(values, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> VALUE), ARRAY_SIZE, input_stream);</span><br><span class="line">（处理数组中的数据）</span><br><span class="line">fwrite(values, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> VALUE), n_value, output_stream);</span><br></pre></td></tr></table></figure>
<p>这个程序从一个输入文件读取二进制数据，对它执行某种类型的处理，把结果写入到一个输出文件。这种类型的IO效率很高，因为每个值中的位直接从流读取或向流写入，不需要任何转换。</p>
<h2 id="刷新和定位函数"><a href="#刷新和定位函数" class="headerlink" title="刷新和定位函数"></a>刷新和定位函数</h2><p>fflush迫使一个输出流的缓冲区内的数据进行物理写入，不管它是不是已经写满。<code>int fllush(FILE *stream)</code>。</p>
<p>C同时支持随机访问I/O，也就是以任意顺序访问文件的不同位置。随机访问是通过在读取或写入先前定位到文件中需要的位置来实现的。有两个函数用于执行这项操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> from)</span>;</span><br></pre></td></tr></table></figure>
<p>ftell函数返回流的当前位置，也就是说，下一个读取或写入将要开始的位置距离文件起始位置的偏移量。这个函数允许你保存一个文件的当前位置，这样你可能在将来会返回到这个位置。在二进制流中，这个值就是当前位置距离文件起始位置之间的字节数。在文本流中，这个值表示一个位置，但它并不一定准确地表示当前位置和文件起始位置之间的字符数，因为有些系统将对行末字符进行翻译转换。</p>
<p>fseek函数允许你在一个流中定位。这个操作将改变下一个读取或写入操作的位置。它的第1个参数是需要改变的流。它的第2和第3个参数标识文件中需要定位的位置。<br><img src="/img/1599210301.jpg" alt=""></p>
<p>试图定位到一个文件的起始位置之前是一个错误。定位到文件尾之后并进行写入将扩展这个文件。定位到文件尾之后并进行读取将导致返回一条“到达文件尾”的信息。在二进制流中，从SEEK_END进行定位可能不被支持，所以应该避免。在文本流中，如果from是SEEK_CUR或SEEK_END，offset必须是零。如果from是SEEK_SET，offset必须是一个从同一个流中以前调用ftell所返回的值。</p>
<p>用fseek改变一个流的位置会带来三个副作用。</p>
<ul>
<li>首先，行末指示字符被清除。</li>
<li>其次，如果在fseek之前使用ungetc把一个字符返回到流中，那么这个被退回的字符会被丢弃，因为在定位操作以后，它不再是“下一个字符”。</li>
<li>最后，定位允许你从写入模式切换到读取模式，或者回到打开的流以便更新。</li>
</ul>
<p>另外还有三个额外的函数，用一些限制更严的方式执行相同的任务。它们的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetpos</span><span class="params">(FILE *stream, <span class="type">fpos_t</span> *positicn)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fsetpos</span><span class="params">(FILE *streamr, <span class="type">fpos_t</span> <span class="type">const</span> *possiton)</span>;</span><br></pre></td></tr></table></figure>
<p>rewind函数将读/写指针设置回指定流的起始位置。它同时清除流的错误提示标志。fgetpos和fsetpos函数分别是ftell和fseek函数的替代方案。它们的主要区别在于这对函数接受一个指向fpos_t的指针作为参数。fgetpos在这个位置存储文件的当前位置，fsetpos把文件位置设置为存储在这个位置的值。</p>
<h2 id="改变缓冲方式"><a href="#改变缓冲方式" class="headerlink" title="改变缓冲方式"></a>改变缓冲方式</h2><p>下面两个函数可以用于对缓冲方式进行修改。这两个函数只有当指定的流被打开但还没有在它上面执行任何其他操作前才能被调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setvbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf)</span>;</span><br></pre></td></tr></table></figure>
<p>setbuf设置了另一个数组，用于对流进行缓冲。这个数组的字符长度必须为BUFSIZ（它在stdio.h中定义）。为一个流自行指定缓冲区可以防止IO函数库为它动态分配一个缓冲区。如果用一个NULL参数调用这个函数，setbuf函数将关闭流的所有缓冲方式。字符准确地将程序所规引的方式进行读取和写入。</p>
<p>为流缓冲区使用一个自动数组是很危险的。如果在流关闭之前，程序的执行流离开了数组声明所在的代码块，流就会继续使用这块内存，但此时它可能已经分配给了其他函数另作它用。</p>
<p>setvbuf函数更为通用。mode参数用于指定缓冲的类型。_IOFBF指定一个完全缓冲的流，_IONBF指定一个不缓冲的流，_IOLBF指定一个行缓冲流。所谓行缓冲，就是每当一个换行符写入到缓冲区时，缓冲区便进行刷新。buf和size参数用于指定需要使用的缓冲区。如果buf为NULL，那么size的值必须是0。一般<br>而言，最好用一个长度为BUFSIZ的字符数组作为缓冲区。尽管使用一个非常大的缓冲区可能可以稍稍提高程序的效率，但如果使用不当，它也有可能降低程序的效率。</p>
<h2 id="流错误函数"><a href="#流错误函数" class="headerlink" title="流错误函数"></a>流错误函数</h2><p>下面的函数用于判断流的状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">clearerr</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<p>如果流当前处于文件尾，feof函数返回真。这个状态可以通过对流执行fseek、rewind或fsetpos函数来清除。ferror函数报告流的错误状态，如果出现任何读／写错误函数就返回真。最后，clearerr函数对指定流的错误标志进行重置。</p>
<h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><p>tmpfile函数用于创建临时文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">tmpfile</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数创建了一个文件，当文件被关闭或程序终止时这个文件便自动删除。该文件以<code>wb+</code>模式打开，这使它可用于二进制和文本数据。如果临时文件必须以其他模式打开或者由一个程序打开但由另一个程序读取，就不适合用tmpfile函数创建。</p>
<h2 id="文件操纵函数"><a href="#文件操纵函数" class="headerlink" title="文件操纵函数"></a>文件操纵函数</h2><p>有两个函数用于操纵文件但不执行任何输入/输出操作。它们的原型如下所示。如果执行成功，这两个函数都返回零值。如果失败，它们都返回非零值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *filename)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *oldname, <span class="type">char</span> <span class="type">const</span> *newname)</span>;</span><br></pre></td></tr></table></figure>
<p>remove函数删除一个指定文件，如果当remove被调用时文件处于打开状态，其结果将取决于编译器。rename用于改变一个文件的名字。</p>
<h1 id="标准函数库"><a href="#标准函数库" class="headerlink" title="标准函数库"></a>标准函数库</h1><h2 id="整型函数"><a href="#整型函数" class="headerlink" title="整型函数"></a>整型函数</h2><h3 id="算数"><a href="#算数" class="headerlink" title="算数"></a>算数<stdlib.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">labs</span><span class="params">(<span class="type">long</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">div_t</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> numerator,<span class="type">int</span> denominator)</span>;</span><br><span class="line"><span class="type">ldiv_t</span> <span class="title function_">ldiv</span><span class="params">(<span class="type">long</span> <span class="type">int</span> number,<span class="type">long</span> <span class="type">int</span> denom)</span>;</span><br></pre></td></tr></table></figure>
<p>abs函数返回绝对值。labs用于长整数。div函数把第二个参数除以第1个参数，产生商和余数，用一个div_t结构返回。这个结构包含</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> quot;     <span class="comment">//商</span></span><br><span class="line"><span class="type">int</span> rem;      <span class="comment">//余数</span></span><br></pre></td></tr></table></figure>
<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数<stdlib.h></h3><p>下面两个函数合在一起使用能够产生伪随机数pseudo-random number。他们通过计算差生随机数，因此有可能重复出现，并不是真正的随机数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int rand(void);</span><br><span class="line">void srand(unsigned int seed);</span><br></pre></td></tr></table></figure>
<p>rand返回一个范围在0和RAND_MAX（至少为32767）之间的伪随机数。当它重复调用时，函数返回这个范围内的其他数。为了得到一个更小范围的伪随机数，首先把这个函数的返回值根据所需范围的大小进行取模，然后通过加上或减去一个偏移量对它进行调整。</p>
<p>为了避免程序每次运行时获得相同的随机数序列，可以调用srand函数。它用它的参数值对随机数发生器进行初始化。一个常用的技巧是使用每天的时间作为随机数产生器的种子seed。<code>srand((unsigned int)time(0))</code></p>
<h3 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换<stdlib.h></h3><p>把字符串转换为数值。atoi和atol执行基数为10的转换。strtol和strtoul允许在转换时指定基数，同时还允许访问字符串的剩余部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *<span class="built_in">string</span>)</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">atol</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *<span class="built_in">string</span>)</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">strtol</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *<span class="built_in">string</span>,<span class="type">char</span> **unused,<span class="type">int</span> base)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">strtoul</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *<span class="built_in">string</span>,<span class="type">char</span> **unused,<span class="type">int</span> base)</span>;</span><br></pre></td></tr></table></figure>
<p>如果任何一个上述函数的的第一个参数包含了前导空白字符，他们将被跳过。然后函数把合法的字符转换为指定类型的值。如果存在任何非法缀尾字符，他们也将被忽略。</p>
<p>atoi和atol分别把字符转换为整数和长整数值。strtol和atol同样把参数字符串转换为long。但是strtol保存一个指向转换至后面第1个字符的指针。如果函数的第二个参数并非NULL，这个指针便保存在第二个参数所指向的位置。这个指针允许字符串的剩余部分进行处理而无需推测转换在字符串的哪个位置终止。strtoul和strtol的执行方式仙童，但它产生一个无符号长整数。</p>
<p>这两个函数的第3个参数是转换所执行的基数。如果基数为0，任何在程序中用于书写整数字面值的形式都将被接受，包括指定数字基数的形式。否则基数值应该在2到36的范围内——然后转换根据这个给定的基数进行。对于基数11到36，字母A到Z分别被解释为10到35.在这个上下文环境中，小写字母a-z被解释为与对应的大写字母相同的意思。</p>
<p>如果这些函数的string参数中并不包含一个合法的值，函数就返回0。如果被转换的值无法表示，函数便在errno中存储ERANGE这个值，并返回以下一个值。</p>
<ul>
<li>strtol 返回值如果太大且为负返回LONG_MIN。如果值太大且为正返回LONG_MAX</li>
<li>strtoul如果值太大返回ULONG_MAX</li>
</ul>
<h2 id="浮点型函数"><a href="#浮点型函数" class="headerlink" title="浮点型函数"></a>浮点型函数</h2><p>math.h包含了函数库中剩余的数学函数的声明。</p>
<h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数<math.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">sin</span><span class="params">(<span class="type">double</span> angle)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">cos</span><span class="params">(<span class="type">double</span> angle)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">tan</span><span class="params">(<span class="type">double</span> angle)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">asin</span><span class="params">(<span class="type">double</span> value)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">acos</span><span class="params">(<span class="type">double</span> value)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">atan</span><span class="params">(<span class="type">double</span> value)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">atan2</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>;</span><br></pre></td></tr></table></figure>
<p>sin、cos、tan参数是一个用弧度表示的角度，返回正弦余弦正切。asin、acos、atan返回反正弦、反余弦、反正切。如果asin和acos的参数不位于-1和1之间，就出现一个定义域错误。asin和atan的返回值是在-π/2和π/2之间的一个弧度，acos的返回值是一个返回在0和π之间的弧度。</p>
<h3 id="双曲函数"><a href="#双曲函数" class="headerlink" title="双曲函数"></a>双曲函数<math.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">sinh</span><span class="params">(<span class="type">double</span> angle)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">cosh</span><span class="params">(<span class="type">double</span> angle)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">tanh</span><span class="params">(<span class="type">double</span> angle)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="对数和指数函数"><a href="#对数和指数函数" class="headerlink" title="对数和指数函数"></a>对数和指数函数<math.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">exp</span><span class="params">(<span class="type">double</span> x)</span>;     <span class="comment">//e的x次幂     </span></span><br><span class="line"><span class="type">double</span> <span class="title function_">log</span><span class="params">(<span class="type">double</span> x)</span>;      <span class="comment">//x的自然对数</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">log10</span><span class="params">(<span class="type">double</span> x)</span>;   <span class="comment">//x以10为低的对数</span></span><br></pre></td></tr></table></figure>
<h3 id="浮点表示形式"><a href="#浮点表示形式" class="headerlink" title="浮点表示形式"></a>浮点表示形式<math.h></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double frexp(double value,int *exponet);</span><br><span class="line">double ledexp(doub fraction,int exponet);</span><br><span class="line">double modf(double value,double *ipart);</span><br></pre></td></tr></table></figure>
<p>frexp函数计算一个指数exponent和小数fraction，这样fraction × 2^exponent = value，函数返回fraction。ledexp返回值是fraction × 2^exponent。modf把一个浮点值分成整数和小数两个部分，整数部分以double类型存储在第二个参数所指向的内存位置，小数部分作为函数的返回值返回。</p>
<h3 id="幂"><a href="#幂" class="headerlink" title="幂"></a>幂<math.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">pow</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">sqrt</span><span class="params">(<span class="type">double</span> x)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="底数、顶数、绝对值和余数"><a href="#底数、顶数、绝对值和余数" class="headerlink" title="底数、顶数、绝对值和余数"></a>底数、顶数、绝对值和余数<math.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">floor</span><span class="params">(<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">ceil</span><span class="params">(<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">fabs</span><span class="params">(<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">fmod</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>;</span><br></pre></td></tr></table></figure>
<p>floor函数返回不大于其参数的最大整数值，这个值以double返回，ceil函数返回不小于其参数的最小整数值。fabs返回其参数的绝对值。fmod返回x除以y所产生的余数。</p>
<h3 id="字符串转换-1"><a href="#字符串转换-1" class="headerlink" title="字符串转换"></a>字符串转换<stdlib.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">atof</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *<span class="built_in">string</span>)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">strtod</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *<span class="built_in">string</span>,<span class="type">char</span> **unused)</span>;</span><br></pre></td></tr></table></figure>
<p>如果任一函数的参数包含了前导的空白字符，这些字符将被忽略。函数随后把合法的字符转换为一个double值，忽略任何缀尾的非法字符。这两个函数都接受程序中所有浮点数字面值的书写形式。strtod函数把参数字符串转换为一个double值，其方法和atof类似，但它保存一个指向字符串中被转换的值后面的第1个字符的指针。如果函数的第2个参数不是NULL，那么这个被保存的指针就存储于第2个参数所指向的内存位置。这个指针允许对字符串的剩余部分进行处理，而不用猜测转换会在字符串中的什么位置结束。</p>
<p>如果这两个函数的字符串参数并不包含任何合法的数值字符，函数就返回零。如果转换值太大或太小，无法用double表示，那么函数就在errno中存储ERANGE这个值，如果值太大（无论是正数还是负数），函数返回HUGE_VALO如果值太小，函数返回零。</p>
<h2 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h2><h3 id="处理器时间"><a href="#处理器时间" class="headerlink" title="处理器时间"></a>处理器时间<time.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">clock_t</span> <span class="title function_">clock</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>返回从程序开始执行器处理器所消耗的时间，应该把它除以常量CLOCKS_PER_SEC。</p>
<h3 id="当天时间"><a href="#当天时间" class="headerlink" title="当天时间"></a>当天时间<time.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> <span class="title function_">time</span><span class="params">(<span class="type">time_t</span> *returned_value)</span>;</span><br></pre></td></tr></table></figure>
<p>返回当前的日期和时间</p>
<h3 id="日期和时间的转换"><a href="#日期和时间的转换" class="headerlink" title="日期和时间的转换"></a>日期和时间的转换<time.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctime</span><span class="params">(<span class="type">time_t</span> <span class="type">const</span> *time_value)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">difftime</span><span class="params">(<span class="type">time_t</span> time1,<span class="type">time_t</span> time2)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">gmtime</span>（<span class="title">time_t</span> <span class="title">const</span> *<span class="title">time</span>)<span class="title">value</span>);</span></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime</span><span class="params">(<span class="type">time_t</span> <span class="type">const</span> *time_value)</span>;</span><br></pre></td></tr></table></figure>
<p>ctime的参数是一个指向time_t的指针，并返回一个指向字符串的指针：<code>Sun Jul 4 04:02:28 1976\n\0</code>。difftime计算两个时间之差，并把结果转换成秒。gmtime把时间值转换为世界协调时间Coordinated Universal Time，UTC。以前被称为格林尼治标准时间Greenwich Mean Time，返回值为tm结构：<br><img src="/img/1599212143.jpg" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">asctime</span><span class="params">(<span class="keyword">struct</span> tm <span class="type">const</span> *tm_ptr)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strftime</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span> ,<span class="type">size_t</span> maxsize,<span class="type">char</span> <span class="type">const</span> *format, <span class="keyword">struct</span> tm <span class="type">const</span> *tm_ptr)</span>;</span><br></pre></td></tr></table></figure>
<p>asctime将tm表示的时间值转换成ctime函数所用的一样的格式。</p>
<p>strftime函数把一个tm结构体转换为一个根据某个格式字符串而定的字符串。如果转换结果字符串的长度小于maxsize参数，返回字符串长度，否则返回-1且数组内容未定义。格式字符串包含了普通字符和格式代码。普通字符被复制到它们原先在字符串中出现的位置。格式代码则被一个日期或时间值代替。格式代码包括一个%字符，后面跟一个表示所需值的字符。<br><img src="/img/1599212244.jpg" alt=""></p>
<p>最后，mktime函数用于把tm结构转换为一个time_t的值。tm结构中的tm_wday和tm_yday值被忽略，其他字段的值也无需限制在它们的通常范围内。转换之后，该tm结构会进行规格化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">( <span class="keyword">struct</span> tm *tm_ptr )</span>;</span><br></pre></td></tr></table></figure>
<h3 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转<setjmp.h></h3><p>setjmp和longjmp函数提供一种类似goto语句的机制，但它并不局限于一个函数的作用域之内。这些函数常用于深层嵌套的函数调用链。如果在某个底层的函数中检测到一个错误，可以立即返回顶层的函数，不必向调用链中的每个中间层函数返回一个错误标志。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">( jmp_buf state )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">( jmp_buf state, <span class="type">int</span> value )</span>;</span><br></pre></td></tr></table></figure>
<p>声明一个jmp_buf变量，并调用setjmp函数初始化，返回值为0。setjmp把程序的状态信息（例如，堆栈指针的当前位置和程序的计数器）保存到跳转缓冲区。调用该函数的函数成为“顶层”函数。以后，在顶层函数或者其他任何它所调用的函数（无论是直接调用还是间接调用）内调用longjmp函数，将会导致这个被保存的状态重新恢复。longjmp的效果是使执行流通过再次从setjmp返回，从而立即跳转回顶层函数中，此时，setjmp返回的值是longjmp的第2个参数。</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号（signal）表示一种事件，它可能异步的发生，也就是并不与程序执行过程的任何事件同步。</p>
<h3 id="信号名"><a href="#信号名" class="headerlink" title="信号名"></a>信号名<signal.h></h3><div class="table-container">
<table>
<thead>
<tr>
<th>信号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGABRT</td>
<td>程序请求异常终止，由abort函数引发。</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>具体错误由编译器确定，常见有算术上溢、下溢以及除零错误</td>
</tr>
<tr>
<td>SIGILL</td>
<td>检测到非法指令，可能由不正确的编译器设置导致</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>检测到内存的非法访问，程序访问未分配内存或者访问超过内存访问的边界（segmentation violation）</td>
</tr>
<tr>
<td>SIGINT</td>
<td>程序外部产生，通常是用户尝试中断程序时发生，一般定义处理函数来执行日常维护和退出前保存数据（interrupt）</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>程序外部产生，请求终止程序的信号（terminate）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="处理信号"><a href="#处理信号" class="headerlink" title="处理信号"></a>处理信号<signal.h></h3><p>raise函数用于显示的引发参数所指定的信号。当一个信号发生时，程序可以使用三种方式对其作出反应。默认的反应由编译器定义，一般是终止程序。程序也可以指定其他对信号的反应行为：忽略或者信号处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">( <span class="type">int</span> sig )</span>;</span><br></pre></td></tr></table></figure>
<p>调用这个函数将引发它的参数所指定的信号。</p>
<p>signal函数将用于指定程序希望采取的反应。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> ( *signal( <span class="type">int</span> sig, <span class="type">void</span> ( *handler )( <span class="type">int</span> ) ) )( <span class="type">int</span> );</span><br></pre></td></tr></table></figure>
<p>signal接收2个参数，第1个参数是信号，第2个参数是希望为这个信号设置的信号处理函数的指针。返回值是一个接收1个整型参数返回值是空的函数指针。事实上，signal函数返回一个指向该信号以前的处理函数的指针。如果因为非法信号导致调用失败，signal返回SIG_ERR。SIG_DEF和SIG_IGN可以用作signal函数的第2个参数。</p>
<h3 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a>信号处理函数</h3><p>当一个已经设置了信号处理函数的信号发生时，系统为了防止如果信号处理函数内部也产生这个信号可能导致的无限循环，将首先恢复对该信号的默认行为，然后调用信号处理函数。</p>
<p>信号处理函数可能执行的工作类型是很有限的。如果信号是异步的，也就是说不是由于调用abort或raise函数引起的，信号处理函数就不应调用除signal之外的任何的库函数，因为在这种情况下其结果是未定义的。而且，信号处理函数除了能向一个类型为volatile sig_atomic_t的静态变量赋一个值以外，可能无法访问其他静态数据。（信号处理函数修改的变量值可能会在任何时候发生改变，因此可能在两条相邻的程序语句语句中变量的值不同，volatile关键字将告诉编译器这个事实。即当要求使用volatile声明变量值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问）</p>
<p>从一个信号处理函数返回导致程序的执行流从信号发生的地点恢复执行（SIGFPE例外）。如果希望捕捉将来同种信号，从当前这个信号的处理函数返回之前注意要调用signal函数重新设置信号处理函数。否则，只有第1个信号才会被捕捉，接下来的同种信号将按默认处理。</p>
<h2 id="打印可变参数列表"><a href="#打印可变参数列表" class="headerlink" title="打印可变参数列表"></a>打印可变参数列表<stdarg.h></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vprintf</span><span class="params">( <span class="type">char</span> <span class="type">const</span> *format, va_list arg )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfprintf</span><span class="params">( FILE *stream, <span class="type">char</span> <span class="type">const</span> *format, va_list arg )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">( <span class="type">char</span> *buffer, <span class="type">char</span> <span class="type">const</span> *format, va_list arg )</span>;</span><br></pre></td></tr></table></figure>
<p>这组函数用于可变参数列表必须被打印的场合。必须包含<code>&lt;stdio.h&gt;</code>和<code>&lt;stdarg.h&gt;</code>。在调用这些函数之前，arg参数必须使用va_start进行初始化，这些函数不需要调用va_end。</p>
<h2 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h2><p>这些函数与程序的执行环境进行通信或者对程序的执行环境施加影响。</p>
<h3 id="终止执行"><a href="#终止执行" class="headerlink" title="终止执行"></a>终止执行<stdlib.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">atexit</span><span class="params">( <span class="type">void</span> (func)( <span class="type">void</span> ) )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">( <span class="type">int</span> status )</span>;</span><br></pre></td></tr></table></figure>
<p>abort函数用于不正常地终止一个正在执行的程序，将触发SIGABRT信号，若设置了信号处理函数，在程序终止前可以采取任何措施，哪怕不终止程序。atexit函数可以把一些函数注册为退出函数（exit function）。当程序将要正常终止（或者由于调用exit，或者由于main函数返回），退出函数将被调用。当exit函数被调用时，所有被atexit函数注册为退出函数的函数将按照它们所注册的顺序被反序调用。然后，所有用于流的缓冲区被刷新，所有打开文件被关闭。用tmpfile函数创建的文件被删除。然后退出状态返回给宿主环境，程序停止执行。</p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言<assert.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">assert</span><span class="params">( <span class="type">int</span> expression )</span>;</span><br></pre></td></tr></table></figure>
<p>assert宏由ANSIC实现，常用于调试程序。当assert被执行时，这个宏对表达式参数进行测试。如果参数表达式值为0，它就向标准错误打印一条诊断信息并终止程序，这个消息格式由编译器定义，但会包含这个表达式和源文件的名字以及这个断言所在行号。</p>
<p>该宏提供了一个对应该为真的东西进行检查的方便方法，例如函数在对一个不能为NULL的指针参数进行调用前用assert进行验证。当程序被完整地测试完毕之后，可以在编译时通过定义NDEBUG消除所有断言（使用-DNDEBUG编译器命令行选项或在源文件assert.h被包含之前增加<code>#define NDEBUG</code>语句）。</p>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境<stdlib.h></h3><p>环境是一个由编译器定义的名字/值对的列表，由操作系统进行维护。getenv函数在这个列表中查找一个特定的名字，如果找到，返回一个指向其对应值的指针，程序不能修改返回的字符串。如果名字未找到，函数就返回NULL指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">( <span class="type">char</span> <span class="type">const</span> *name )</span>;</span><br></pre></td></tr></table></figure>
<h3 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a>执行系统命令<stdlib.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">system</span><span class="params">( <span class="type">char</span> <span class="type">const</span> *command )</span>;</span><br></pre></td></tr></table></figure>
<p>system函数把它的字符串参数传递给宿主操作系统，由系统的命令处理器执行。如果参数是NULL，则system用于询问命令处理器是否实际存在。在这种情况下，如果存在一个可用的命令处理器，system返回非0值，否则返回0。</p>
<h3 id="排序和查找"><a href="#排序和查找" class="headerlink" title="排序和查找"></a>排序和查找<stdlib.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">( <span class="type">void</span> *base, <span class="type">size_t</span> n_elements, <span class="type">size_t</span> el_size, <span class="type">int</span> (*compare)(<span class="type">void</span> <span class="type">const</span> *, <span class="type">void</span> <span class="type">const</span> *) )</span>;</span><br></pre></td></tr></table></figure>
<p>qsort函数在一个数组中以升序的方式对数据进行排序，与类型无关，只是数组内元素的长度需固定。第1个参数指向需要排序的数组，第2个参数指定数组中元素的数目，第3个参数指定每个元素的长度（以字节为单位）。第4个参数是一个函数指针，用于对需要排序的元素类型进行比较。比较函数应该返回一个整数，大于0、等于0和小于0表示第1个参数大于、等于和小于第2个参数。</p>
<p>bsearch函数在一个己经排好序的数组中用二分法查找一个特定的元素。如果数组尚未排序，其结果是未定义的。第1个参数指向你需要查找的值，第2个参数指向查找所在的数组，第3个参数指定数组中元素的数目，第4个参数是每个元素的长度（以字符为单位）。最后一个参数是和qsort中相同的指向比较函数的指针。bsech函数返回一个指向查找到的数组元素的指针。如果需要查找的值不存在，函数返回一个NULL指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">bsearch</span><span class="params">( <span class="type">void</span> <span class="type">const</span> *key, coid <span class="type">const</span> *base, <span class="type">size_t</span> n_elements, <span class="type">size_t</span> el_size, <span class="type">int</span> (*compare)(<span class="type">void</span> <span class="type">const</span> *, <span class="type">void</span> <span class="type">const</span> *) )</span>;</span><br></pre></td></tr></table></figure>
<h2 id="locale"><a href="#locale" class="headerlink" title="locale"></a>locale</h2><p>为了使C语言在全世界的范围内更为通用，标准定义了locale，这是一组特定的参数，每个国家可能各不相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">setlocale</span><span class="params">( <span class="type">int</span> category, <span class="type">char</span> <span class="type">const</span> *locale )</span>;</span><br></pre></td></tr></table></figure>
<p>setlocale常用于修改整个或部分locale，可能影响库函数的运行方式。category参数指定locale的哪个部分需要进行修改，允许出现的值列于下表。如果第2个参数locale为NULL，函数将返回一个指向给定类型的当前locale的名字的指针。这个值可能被保存并继续在后续的setlocale中使用用以恢复。如果第2个参数不是NULL，它指定需要使用的新locale。如果函数调用成功，它将返回新locale的值，否则返回一个NULL指针，原来的locale不受影响。</p>
<h3 id="数值和货币格式"><a href="#数值和货币格式" class="headerlink" title="数值和货币格式"></a>数值和货币格式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> lconv *<span class="title function_">localeconv</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>
<p>localeconv函数用于获得根据当前的locale对非货币值和货币值进行合适的格式化所需要的信息。该函数不实际执行格式化任务，只是提供一些如何进行格式化的信息。lconv结构包含两种类型的参数：字符和字符指针。字符参数为非负值，如果一个字符参数为CHAR_MAX，那么这个值就在当前的locale中不可用（不使用）。对于字符指针，如果指向一个空字符串，与前者同意。</p>
<p>格式化非货币数值的参数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段和类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>char *decimal_point</td>
<td>用作小数点的字符。这个值绝不能是个空字符串。例如：”.”</td>
</tr>
<tr>
<td>char *thousands_sep</td>
<td>用作分隔小数点左边各组数字的符号。例如：”,”</td>
</tr>
<tr>
<td>char *grouping</td>
<td>指定小数点左边多少数字组成。例如：”\3”</td>
</tr>
</tbody>
</table>
</div>
<p>格式化本地货币值的参数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段和类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>char *currency_symbol</td>
<td>本地货币符号</td>
</tr>
<tr>
<td>char *mon_decimal_point</td>
<td>小数点字符</td>
</tr>
<tr>
<td>char *mon_thousands_sep</td>
<td>用于分隔小数点左边各组数字的字符</td>
</tr>
<tr>
<td>char *mon_group</td>
<td>指定出现在小数点左边各组数字的数字个数</td>
</tr>
<tr>
<td>char *postive_sign</td>
<td>用于提示非负值的字符串</td>
</tr>
<tr>
<td>char *negative_sign</td>
<td>用于提示负值的字符串</td>
</tr>
<tr>
<td>char frac_digits</td>
<td>出现在小数点右边的数字个数</td>
</tr>
<tr>
<td>char p_cs_precedes</td>
<td>如果currency_symbol出现在一个非负值之前，其值为’\1’；如果出现在后面，其值为’\0’</td>
</tr>
<tr>
<td>char n_cs_precedes</td>
<td>如果currency_symbol出现在一个负值之前，其值为’\1’；如果出现在后面，其值为’\0’</td>
</tr>
<tr>
<td>char p_sep_by_space</td>
<td>如果currency_symbol和非负值之间用一个空格字符分隔，其值为’\1’；否则其值为’\0’</td>
</tr>
<tr>
<td>char n_sep_by_space</td>
<td>如果currency_symbol和负值之间用一个空格字符分隔，其值为’\1’；否则其值为’\0’</td>
</tr>
<tr>
<td>char n_sign_posn</td>
<td>提示negative_sign出现在一个负值中的位置。用于p_sign_posn的值也可用于此处</td>
</tr>
<tr>
<td>char p_sign_posn</td>
<td>提示positive_sign出现在一个非负值的位置</td>
</tr>
</tbody>
</table>
</div>
<h3 id="符号串和locale"><a href="#符号串和locale" class="headerlink" title="符号串和locale"></a>符号串和locale<string.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcoll</span><span class="params">( <span class="type">char</span> <span class="type">const</span> *s1, <span class="type">char</span> <span class="type">const</span> *s2 )</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strcfrm</span><span class="params">( <span class="type">char</span> *s1, <span class="type">char</span> <span class="type">const</span> *s2, <span class="type">size_t</span> size )</span>;</span><br></pre></td></tr></table></figure>
<p>一个机器的字符集的对照序列是固定的。但setlocale提供了一种方法指定不同的序列,当使用一个并非默认的对照列表时，可以采用上面两个函数。strcoll函数对两个根据当前locale的LC_COLLATE类型参数指定的字符串进行比较，比较可能比strcmp需要多得多的计算了，因为其需要遵循一个并非本地机器的对照序列。当字符串必须以这种方式反复进行比较时，使用strcfrm函数可以减少计算量。strcfrm把根据当前locale解释的第2个参数转换成一个不依赖于locale的字符串，尽管转换后的字符串内容不确定，但比较结果和strcoll相同。</p>
<h3 id="改变locale的效果"><a href="#改变locale的效果" class="headerlink" title="改变locale的效果"></a>改变locale的效果</h3><p>locale可能向正在执行的程序所使用的字符集增加字符（但可能不会改变现存字符的含义）。例如，许多欧洲语言使用了能够提示重音、货币符号和其他特殊符号的扩展字符集。</p>
<p>打印的方向可能会改变。尤其，locale决定一个字符应该根据前面一个被打印的字符的哪个方向进行打印。printf和scanf函数机组使用当前locale定义的小数点符号。如果locale扩展了正在使用的字符集，isalpha、islower、isspace和isupper函数可能比以前包含更多的字符。正在使用的字符集的对照序列可能会改变。这个序列有strcoll函数使用，用于字符串之间的相互比较。strftime函数产生的日期和时间格式的很多方面都是特定于locale的。</p>
<h1 id="运行时环境"><a href="#运行时环境" class="headerlink" title="运行时环境"></a>运行时环境</h1><h2 id="判断运行时环境"><a href="#判断运行时环境" class="headerlink" title="判断运行时环境"></a>判断运行时环境</h2><p>第一步骤是从你的编译器获得一个汇编语言代码列表。</p>
<ul>
<li>测试程序</li>
<li>静态变量和初始化</li>
<li>堆栈帧<ul>
<li>一个函数分成三个部分：函数序、函数体、函数跋。</li>
</ul>
</li>
<li>寄存器变量</li>
<li>外部标识符的长度</li>
<li>判断堆栈帧布局<ul>
<li>运行时堆栈保存了每个函数运行时所需要的数据，包括它的自动变量和返回地址。<ul>
<li>传递函数参数</li>
<li>函数序</li>
<li>堆栈中的参数次序</li>
<li>最终的堆栈帧布局</li>
<li>函数跋</li>
<li>返回值</li>
<li>表达式的副作用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="C和汇编语言的接口"><a href="#C和汇编语言的接口" class="headerlink" title="C和汇编语言的接口"></a>C和汇编语言的接口</h2><p>编写能够调用C程序或者被C程序调用的汇编语言程序所需的内容。与这个环境相关的结果总结如下—你的环境肯定在某些方面与它不同！</p>
<ul>
<li>首先，汇编程序中的名字必须遵循外部标识符的规则。</li>
<li>其次，汇编程序必须遵循正确的函数调用/返回协议。有两种情况：从一个汇编语言程序调用一个C程序和从一个程序调用一个汇编程序。为了从汇编程序调用C程序：</li>
<li>如果寄存器d0、d1、a0或a1保存了重要的值，它们必须在调用C程序之前进行保存，因为C函数不会保存它们的值。</li>
<li>任何函数的参数必须以参数列表相反的顺序压入到堆栈中。</li>
<li>函数必须由一条“跳转子程序”类型的指令调用，它会把返回地址压入到堆栈中。</li>
<li>当C函数返回时，汇编程序必须清除堆栈中的任何参数。</li>
<li>如果汇编程序期望接受一个返回值，它将保持在d0(如果返回值的类型为double，它的另一半将位于d1)。</li>
<li>任何在调用之前进行过保存的寄存器此时可以恢复。</li>
<li>为了编写一个由C程序调用的汇编程序：<ul>
<li>保存任何你希望修改的寄存器(除d0、d1、a0或a1之外)。</li>
<li>参数值从堆栈中获得，因为调用它的C函数把参数压入到堆栈中。</li>
<li>如果函数应该返回一个值，它的值应该保存在d0中(在这种情况下，d0不能进行保存和恢复)。</li>
<li>在返回之前，函数必须清除任何它压入到堆栈中的内容。</li>
</ul>
</li>
</ul>
<h2 id="运行时效率"><a href="#运行时效率" class="headerlink" title="运行时效率"></a>运行时效率</h2><p>即使在一些现代的机器上，一个必须存储于ROM的程序必须相当小才有可能装入到有限的内存空间中。但许多现代计算机系统在这方面的限制大不如前，这是因为它们提供了<strong>虚拟内存。虚拟内存是由操作系统实现的，它在需要时把程序活动部分放入内存并把不活动的部分复制到磁盘中</strong>，这样就允许系统运行大型的程序。但程序越大，需要进行的复制就越多。所以大型程序不是想以前那样根本无法运行，而是随着程序的增大，它的执行效率逐渐降低。</p>
<p>如果一个程序太大或太慢，较之专研每个变量，看看把它们声明为register能不能提高效率，选一种效率更高的算法或数据结构往往效果要满意得多。然而这并不是说你可以在代码中胡作非为，因为风格恶劣的代码总是会把事情弄得更糟。</p>
<p>如果一个程序太大，很容易想到的着手方向：最大的函数和数据结构。如果程序太慢，着手方向：对程序进行性能测评，花费时间最多的部分程序和使用最频繁的那部分代码显然是需要优化的目标。如果这方面能够提升，将能大大提高程序的整体运行速度。<br>三个努力方向：</p>
<ul>
<li>在耗时最多的函数中，有些是库函数。如果能减少或不用可帮助大大提升性能。</li>
<li>有效函数之所以耗费了大量的时间是因为它们被调用的<strong>次数非常多</strong>。</li>
<li>有些函数调用次数不多，但每次调用耗费时间却很长。寻找更优质的算法重构是努力的方向。</li>
<li>可以对单个函数进行汇编语言重新编码，函数越小，重新编码越容易。</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>绝大多数环境都创建某种类型的堆栈帧，函数用它来保存它们的数据，堆栈帧的细节可能各不相同，但它们的基本思路是相当一致的。</p>
<p>提高效率的最好方法是为它选择一种更好的算法，接下来的一种提高程序执行速度的最佳手段是对程序进行性能测评，看看程序在哪个地方花费的时间最多，把优化措施集中在程序的这部分将产生最好的结果。</p>
<h2 id="警告总结"><a href="#警告总结" class="headerlink" title="警告总结"></a>警告总结</h2><ul>
<li>是链接器而不是编译器决定外部标识符的最大长度；</li>
<li>你无法链接由不同编译器产生的程序；</li>
</ul>
<h1 id="指针详解"><a href="#指针详解" class="headerlink" title="指针详解"></a>指针详解</h1><h2 id="前言-复杂类型说明"><a href="#前言-复杂类型说明" class="headerlink" title="前言:复杂类型说明"></a>前言:复杂类型说明</h2><p>要了解指针，多多少少会出现一些比较复杂的类型，所以我先介绍一下如何完全理解一个复杂类型，要理解复杂类型其实很简单，一个类型里会出现很多运算符，他们也像普通的表达式一样，有优先级，其优先级和运算优先级一样，所以我总结了一下其原则:从变量名处起，根据运算符优先级结合，一步一步分析.下面让我们先从简单的类型开始慢慢分析吧:</p>
<ul>
<li><code>int p;</code>：这是一个普通的整型变量</li>
<li><code>int *p;</code>：首先从P处开始，先与<code>*</code>结合，所以说明P是一个指针，然后再与int 结合，说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针</li>
<li><code>int p[3];</code>：首先从P处开始，先与[]结合，说明P是一个数组，然后与int 结合，说明数组里的元素是整型的，所以P是一个由整型数据组成的数组</li>
<li><code>int *p[3];</code>：首先从P处开始，先与[]结合，因为其优先级比*高，所以P是一个数组，然后再与*结合，说明数组里的元素是指针类型，然后再与int 结合，说明指针所指向的内容的类型是整型的，所以P是一个由返回整型数据的指针所组成的数组</li>
<li><code>int (*p)[3];</code>：首先从P处开始，先与*结合，说明P是一个指针，然后再与[]结合(与”()”这步可以忽略，只是为了改变优先级)，说明指针所指向的内容是一个数组，然后再与int 结合，说明数组里的元素是整型的.所以P是一个指向由整型数据组成的数组的指针</li>
<li><code>int **p;</code>：首先从P开始，先与*结合，说是P是一个指针，然后再与*结合，说明指针所指向的元素是指针，然后再与int 结合，说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中，所以后面更复杂的类型我们就不考虑多级指针了，最多只考虑一级指针</li>
<li><code>int p(int);</code>：从P处起，先与()结合，说明P是一个函数，然后进入()里分析，说明该函数有一个整型变量的参数，然后再与外面的int 结合，说明函数的返回值是一个整型数据</li>
<li><code>int (*p)(int);</code>：从P处开始，先与指针结合，说明P是一个指针，然后与()结合，说明指针指向的是一个函数，然后再与()里的int 结合，说明函数有一个int 型的参数，再与最外层的int 结合，说明函数的返回类型是整型，所以P是一个指向有一个整型参数且返回类型为整型的函数的指针</li>
<li><code>int *(*p(int))[3];</code>：可以先跳过，不看这个类型，过于复杂从P开始，先与()结合，说明P是一个函数，然后进入()里面，与int 结合，说明函数有一个整型变量参数，然后再与外面的*结合，说明函数返回的是一个指针，，然后到最外面一层，先与[]结合，说明返回的指针指向的是一个数组，然后再与*结合，说明数组里的元素是指针，然后再与int 结合，说明指针指向的内容是整型数据.所以P是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.</li>
</ul>
<p>说到这里也就差不多了，我们的任务也就这么多，理解了这几个类型，其它的类型对我们来说也是小菜了，不过我们一般不会用太复杂的类型，那样会大大减小程序的可读性，请慎用，这上面的几种类型已经足够我们用了。</p>
<h2 id="细说指针"><a href="#细说指针" class="headerlink" title="细说指针"></a>细说指针</h2><p>指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型、指针所指向的类型、指针的值或者叫指针所指向的内存区、指针本身所占据的内存区。让我们分别说明。先声明几个指针放着做例子：<br>例一：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>*ptr;</span><br><span class="line"><span class="type">char</span>*ptr;</span><br><span class="line"><span class="type">int</span>**ptr;</span><br><span class="line"><span class="type">int</span>(*ptr)[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span>*(*ptr)[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<h2 id="指针的类型"><a href="#指针的类型" class="headerlink" title="指针的类型"></a>指针的类型</h2><p>从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1)int*ptr;//指针的类型是int*</span><br><span class="line">(2)char*ptr;//指针的类型是char*</span><br><span class="line">(3)int**ptr;//指针的类型是int**</span><br><span class="line">(4)int(*ptr)[3];//指针的类型是int(*)[3]</span><br><span class="line">(5)int*(*ptr)[4];//指针的类型是int*(*)[4]</span><br></pre></td></tr></table></figure>
<p>怎么样？找出指针的类型的方法是不是很简单呢？</p>
<h2 id="指针所指向的类型"><a href="#指针所指向的类型" class="headerlink" title="指针所指向的类型"></a>指针所指向的类型</h2><p>当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1)int*ptr; //指针所指向的类型是int</span><br><span class="line">(2)char*ptr; //指针所指向的的类型是char</span><br><span class="line">(3)int**ptr; //指针所指向的的类型是int*</span><br><span class="line">(4)int(*ptr)[3]; //指针所指向的的类型是int()[3]</span><br><span class="line">(5)int*(*ptr)[4]; //指针所指向的的类型是int*()[4]</span><br></pre></td></tr></table></figure>
<p>在指针的算术运算中，指针所指向的类型有很大的作用。指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C 越来越熟悉时，你会发现，把与指针搅和在一起的”类型”这个概念分成”指针的类型”和”指针所指向的类型”两个概念，是精通指针的关键点之一。我看了不少书，发现有些写得差的书中，就把指针的这两个概念搅在一起了，所以看起书来前后矛盾，越看越糊涂。</p>
<h2 id="指针的值"><a href="#指针的值" class="headerlink" title="指针的值"></a>指针的值</h2><p>指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32 位程序里，所有类型的指针的值都是一个32 位整数，因为32 位程序里内存地址全都是32 位长。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？（重点注意）</p>
<h2 id="指针本身所占据的内存区"><a href="#指针本身所占据的内存区" class="headerlink" title="指针本身所占据的内存区"></a>指针本身所占据的内存区</h2><p>指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32 位平台里，指针本身占据了4 个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式（后面会解释）是否是左值时很有用。</p>
<h2 id="指针的算术运算"><a href="#指针的算术运算" class="headerlink" title="指针的算术运算"></a>指针的算术运算</h2><p>指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的，以单元为单位。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char a[20];</span><br><span class="line">int *ptr=(int *)a; //强制类型转换并不会改变a 的类型</span><br><span class="line">ptr++;</span><br></pre></td></tr></table></figure>
<p>在上例中，指针ptr 的类型是<code>int*</code>，它指向的类型是int，它被初始化为指向整型变量a。接下来的第3句中，指针ptr被加了1，编译器是这样处理的：它把指针ptr 的值加上了sizeof(int)，在32 位程序中，是被加上了4，因为在32 位程序中，int 占4 个字节。由于地址是用字节做单位的，故ptr 所指向的地址由原来的变量a 的地址向高地址方向增加了4 个字节。由于char 类型的长度是一个字节，所以，原来ptr 是指向数组a 的第0 号单元开始的四个字节，此时指向了数组a 中从第4 号单元开始的四个字节。我们可以用一个指针和一个循环来遍历一个数组，看例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = <span class="built_in">array</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line">	(*ptr) ++;</span><br><span class="line">	ptr ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子将整型数组中各个单元的值加1。由于每次循环都将指针ptr加1 个单元，所以每次循环都能访问数组的下一个单元。再看例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">20</span>] = <span class="string">&quot;You_are_a_girl&quot;</span>;</span><br><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span>*)a;</span><br><span class="line">ptr += <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，ptr 被加上了5，编译器是这样处理的：将指针ptr 的值加上5 乘sizeof(int)，在32 位程序中就是加上了5 乘4=20。由于地址的单位是字节，故现在的ptr 所指向的地址比起加5 后的ptr 所指向的地址来说，向高地址方向移动了20个字节。在这个例子中，没加5前的ptr指向数组a的第0号单元开始的四个字节，加5后，ptr已经指向了数组a的合法范围之外了。虽然这种情况在应用上会出问题，但在语法上却是可以的。这也体现出了指针的灵活性。</p>
<p>如果上例中，ptr 是被减去5，那么处理过程大同小异，只不过ptr 的值是被减去5 乘sizeof(int)，新的ptr 指向的地址将比原来的ptr 所指向的地址向低地址方向移动了20 个字节。下面请允许我再举一个例子:(一个误区)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char a[20]=&quot; You_are_a_girl&quot;;</span><br><span class="line">	char *p=a;</span><br><span class="line">	char **ptr=&amp;p;</span><br><span class="line">	//printf(&quot;p=%d\n&quot;，p);</span><br><span class="line">	//printf(&quot;ptr=%d\n&quot;，ptr);</span><br><span class="line">	//printf(&quot;*ptr=%d\n&quot;，*ptr);</span><br><span class="line">	printf(&quot;**ptr=%c\n&quot;，**ptr);</span><br><span class="line">	ptr++;</span><br><span class="line">	//printf(&quot;ptr=%d\n&quot;，ptr);</span><br><span class="line">	//printf(&quot;*ptr=%d\n&quot;，*ptr);</span><br><span class="line">	printf(&quot;**ptr=%c\n&quot;，**ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>误区一：输出答案为Y 和o</p>
<p>误解：ptr 是一个char 的二级指针，当执行<code>ptr++;</code>时，会使指针加一个<code>sizeof(char)</code>，所以输出如上结果，这个可能只是少部分人的结果.</p>
<p>误区二：输出答案为Y 和a</p>
<p>误解：ptr 指向的是一个<code>char *</code>类型，当执行<code>ptr++;</code>时，会使指针加一个<code>sizeof(char *)</code>(有可能会有人认为这个值为1，那就会得到误区一的答案，这个值应该是4，参考前面内容)， 即&amp;p+4; 那进行一次取值运算不就指向数组中的第五个元素了吗?那输出的结果不就是数组中第五个元素了吗?答案是否定的。</p>
<p>正解: ptr 的类型是<code>char **</code>，指向的类型是一个<code>char *</code>类型，该指向的地址就是p的地址(&amp;p)，当执行<code>ptr++;</code>时，会使指针加一个<code>sizeof(char*)</code>，即<code>&amp;p+4;</code>那<code>*(&amp;p+4)</code>指向哪呢，这个你去问上帝吧，或者他会告诉你在哪?所以最后的输出会是一个随机的值，或许是一个非法操作.</p>
<p>总结一下:一个指针<code>ptrold</code>加(减)一个整数n 后，结果是一个新的指针<code>ptrnew</code>，<code>ptrnew</code> 的类型和<code>ptrold</code> 的类型相同，<code>ptrnew</code> 所指向的类型和<code>ptrold</code>所指向的类型也相同。<code>ptrnew</code> 的值将比<code>ptrold</code> 的值增加(减少)了<code>n乘sizeof(ptrold 所指向的类型)</code>个字节。就是说，<code>ptrnew</code>所指向的内存区将比<code>ptrold</code> 所指向的内存区向高(低)地址方向移动了<code>n乘sizeof(ptrold 所指向的类型)</code>个字节。</p>
<p>指针和指针进行加减：两个指针不能进行加法运算，这是非法操作，因为进行加法后，得到的结果指向一个不知所向的地方，而且毫无意义。两个指针可以进行减法操作，但必须类型相同，一般用在数组方面，不多说了。</p>
<h2 id="运算符-amp-和"><a href="#运算符-amp-和" class="headerlink" title="运算符&amp;和*"></a>运算符<code>&amp;</code>和<code>*</code></h2><p>这里<code>&amp;</code>是取地址运算符，<code>*</code>是间接运算符。<code>&amp;a</code>的运算结果是一个指针，指针的类型是a的类型加个<code>*</code>，指针所指向的类型是a 的类型，指针所指向的地址嘛，那就是a 的地址。<code>*P</code>的运算结果就五花八门了。总之<code>*P</code>的结果是P所指向的东西，这个东西有这些特点：它的类型是P指向的类型，它所占用的地址是p所指向的地址。</p>
<p>例六：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int a=12; </span><br><span class="line">int b; </span><br><span class="line">int *p; </span><br><span class="line">int **ptr;</span><br><span class="line"></span><br><span class="line">p=&amp;a; //&amp;a 的结果是一个指针，类型是int*，指向的类型是</span><br><span class="line">//int，指向的地址是a 的地址。</span><br><span class="line"></span><br><span class="line">*p=24; //*P的结果，在这里它的类型是int，它所占用的地址是</span><br><span class="line">//P所指向的地址，显然，*P就是变量a。</span><br><span class="line"></span><br><span class="line">ptr=&amp;p; //&amp;P的结果是个指针，该指针的类型是P的类型加个*，</span><br><span class="line">//在这里是int **。该指针所指向的类型是P的类型，这</span><br><span class="line">//里是int*。该指针所指向的地址就是指针P自己的地址。</span><br><span class="line"></span><br><span class="line">*ptr=&amp;b; //*ptr 是个指针，&amp;b 的结果也是个指针，且这两个指针</span><br><span class="line">//的类型和所指向的类型是一样的，所以用&amp;b 来给*ptr 赋</span><br><span class="line">//值就是毫无问题的了。</span><br><span class="line"></span><br><span class="line">**ptr=34; //*ptr 的结果是ptr 所指向的东西，在这里是一个指针，</span><br><span class="line">//对这个指针再做一次*运算，结果是一个int 类型的变量。</span><br></pre></td></tr></table></figure>
<h2 id="指针表达式-1"><a href="#指针表达式-1" class="headerlink" title="指针表达式"></a>指针表达式</h2><p>一个表达式的结果如果是一个指针，那么这个表达式就叫指针表式。下面是一些指针表达式的例子：</p>
<p>例七：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int a，b;</span><br><span class="line">int array[10];</span><br><span class="line">int *pa;</span><br><span class="line">pa=&amp;a; //&amp;a 是一个指针表达式。</span><br><span class="line">int **ptr=&amp;pa; //&amp;pa 也是一个指针表达式。</span><br><span class="line">*ptr=&amp;b; //*ptr 和&amp;b 都是指针表达式。</span><br><span class="line">pa=array;</span><br><span class="line">pa++; //这也是指针表达式。</span><br></pre></td></tr></table></figure>
<p>例八：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char *arr[20];</span><br><span class="line">char **parr=arr; //如果把arr 看作指针的话，arr 也是指针表达式</span><br><span class="line">char *str;</span><br><span class="line">str=*parr; //*parr 是指针表达式</span><br><span class="line">str=*(parr+1); //*(parr+1)是指针表达式</span><br><span class="line">str=*(parr+2); //*(parr+2)是指针表达式</span><br></pre></td></tr></table></figure>
<p>由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。在例七中，<code>&amp;a</code>不是一个左值，因为它还没有占据明确的内存。<code>*ptr</code>是一个左值，因为<code>*ptr</code>这个指针已经占据了内存，其实<code>*ptr</code>就是指针pa，既然pa 已经在内存中有了自己的位置，那么<code>*ptr</code>当然也有了自己的位置。</p>
<h2 id="数组和指针的关系"><a href="#数组和指针的关系" class="headerlink" title="数组和指针的关系"></a>数组和指针的关系</h2><p>数组的数组名其实可以看作一个指针。看下例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int array[10]=&#123;0，1，2，3，4，5，6，7，8，9&#125;，value;</span><br><span class="line">value=array[0]; //也可写成：value=*array;</span><br><span class="line">value=array[3]; //也可写成：value=*(array+3);</span><br><span class="line">value=array[4]; //也可写成：value=*(array+4);</span><br></pre></td></tr></table></figure>
<p>上例中，一般而言数组名array 代表数组本身，类型是int[10]，但如果把array 看做指针的话，它指向数组的第0 个单元，类型是<code>int*</code>所指向的类型是数组单元的类型即int。因此<code>*array</code> 等于0 就一点也不奇怪了。同理，array+3 是一个指向数组第3 个单元的指针，所以<code>*(array+3)</code>等于3。其它依此类推。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">char *str[3]=&#123;</span><br><span class="line"> &quot;Hello，thisisasample!&quot;，</span><br><span class="line"> &quot;Hi，goodmorning.&quot;，</span><br><span class="line"> &quot;Helloworld&quot;</span><br><span class="line">&#125;;</span><br><span class="line">char s[80]；</span><br><span class="line">strcpy(s，str[0]); //也可写成strcpy(s，*str);</span><br><span class="line">strcpy(s，str[1]); //也可写成strcpy(s，*(str+1));</span><br><span class="line">strcpy(s，str[2]); //也可写成strcpy(s，*(str+2));</span><br></pre></td></tr></table></figure>
<p>上例中，str 是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名str 当作一个指针的话，它指向数组的第0 号单元，它的类型是<code>char **</code>，它指向的类型是<code>char *</code>。<code>*str</code>也是一个指针，它的类型是<code>char *</code>，它所指向的类型是char，它指向的地址是字符串”Hello，thisisasample!”的第一个字符的地址，即’H’的地址。</p>
<p>注意:字符串相当于是一个数组，在内存中以数组的形式储存，只不过字符串是一个数组常量，内容不可改变，且只能是右值.如果看成指针的话，他即是常量指针，也是指针常量。str+1 也是一个指针，它指向数组的第1 号单元，它的类型是<code>char**</code>，它指向的类型是<code>char*</code>。<code>*(str+1)</code>也是一个指针，它的类型是<code>char*</code>，它所指向的类型是char，它指向”Hi，goodmorning.”的第一个字符’H’</p>
<p>下面总结一下数组的数组名(数组中储存的也是数组)的问题：<br>声明了一个数组TYPE array[n]，则数组名称array 就有了两重含义：</p>
<ul>
<li>第一，它代表整个数组，它的类型是TYPE[n]；</li>
<li>第二，它是一个常量指针，该指针的类型是<code>TYPE*</code>，该指针指向的类型是TYPE，也就是数组单元的类型，该指针指向的内存区就是数组第0 号单元，该指针自己占有单独的内存区，注意它和数组第0 号单元占据的内存区是不同的。该指针的值是不能修改的，即类似array++的表达式是错误的。在不同的表达式中数组名array 可以扮演不同的角色。在表达式sizeof(array)中，数组名array 代表数组本身，故这时sizeof 函数测出的是整个数组的大小。在表达式<code>*array</code> 中，array 扮演的是指针，因此这个表达式的结果就是数组第0 号单元的值。<code>sizeof(*array)</code>测出的是数组单元的大小。表达式array+n（其中n=0，1，2，…..）中，array 扮演的是指针，故array+n 的结果是一个指针，它的类型是<code>TYPE *</code>，它指向的类型是TYPE，它指向数组第n号单元。故s<code>izeof(array+n)</code>测出的是指针类型的大小。在32 位程序中结果是4。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int array[10];</span><br><span class="line">int (*ptr)[10];</span><br><span class="line">ptr = &amp;array;</span><br></pre></td></tr></table></figure>
<p>上例中ptr 是一个指针，它的类型是<code>int(*)[10]</code>，他指向的类型是<code>int[10]</code> ，我们用整个数组的首地址来初始化它。在语句<code>ptr = &amp;array</code>中，array 代表数组本身。本节中提到了函数<code>sizeof()</code>，那么我来问一问，sizeof(指针名称)测出的究竟是指针自身类型的大小呢还是指针所指向的类型的大小？</p>
<p>答案是前者。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int(*ptr)[10];</span><br></pre></td></tr></table></figure>
<p>则在32 位程序中，有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sizeof(int(*)[10])==4</span><br><span class="line">sizeof(int[10])==40</span><br><span class="line">sizeof(ptr)==4</span><br></pre></td></tr></table></figure>
<p>实际上，sizeof(对象)测出的都是对象自身的类型的大小，而不是别的什么类型的大小。</p>
<h2 id="指针和结构类型的关系"><a href="#指针和结构类型的关系" class="headerlink" title="指针和结构类型的关系"></a>指针和结构类型的关系</h2><p>可以声明一个指向结构类型对象的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct MyStruct</span><br><span class="line">&#123;</span><br><span class="line">	int a;</span><br><span class="line">	int b;</span><br><span class="line">	int c;</span><br><span class="line">&#125;;</span><br><span class="line">struct MyStruct ss=&#123;20，30，40&#125;;</span><br><span class="line">//声明了结构对象ss，并把ss 的成员初始化为20，30 和40。</span><br><span class="line"></span><br><span class="line">struct MyStruct *ptr=&amp;ss;</span><br><span class="line">//声明了一个指向结构对象ss 的指针。它的类型是</span><br><span class="line">//MyStruct *，它指向的类型是MyStruct。</span><br><span class="line"></span><br><span class="line">int *pstr=(int*)&amp;ss;</span><br><span class="line">//声明了一个指向结构对象ss 的指针。但是pstr 和</span><br><span class="line">//它被指向的类型ptr 是不同的。</span><br></pre></td></tr></table></figure>
<p>请问怎样通过指针ptr 来访问ss 的三个成员变量？<br>答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;a; //指向运算符，或者可以这们(*ptr).a，建议使用前者</span><br><span class="line">ptr-&gt;b;</span><br><span class="line">ptr-&gt;c;</span><br></pre></td></tr></table></figure>
<p>又请问怎样通过指针pstr 来访问ss 的三个成员变量？<br>答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*pstr； //访问了ss 的成员a。</span><br><span class="line">*(pstr+1); //访问了ss 的成员b。</span><br><span class="line">*(pstr+2) //访问了ss 的成员c。</span><br></pre></td></tr></table></figure>
<p>虽然我在我的MSVC++6.0 上调式过上述代码，但是要知道，这样使用pstr 来访问结构成员是不正规的，为了说明为什么不正规，让我们看看怎样通过指针来访问数组的各个单元: (将结构体换成数组)</p>
<p>例十三：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int array[3]=&#123;35，56，37&#125;;</span><br><span class="line">int *pa=array;</span><br><span class="line">//通过指针pa 访问数组array 的三个单元的方法是：</span><br><span class="line">*pa; //访问了第0 号单元</span><br><span class="line">*(pa+1); //访问了第1 号单元</span><br><span class="line">*(pa+2); //访问了第2 号单元</span><br></pre></td></tr></table></figure>
<p>从格式上看倒是与通过指针访问结构成员的不正规方法的格式一样。所有的C/C++编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个”填充字节”，这就导致各个成员之间可能会有若干个字节的空隙。所以，在例十二中，即使<code>*pstr</code>访问到了结构对象ss 的第一个成员变量a，也不能保证<code>*(pstr+1)</code>就一定能访问到结构成员b。因为成员a 和成员b 之间可能会有若干填充字节，说不定<code>*(pstr+1)</code>就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，嘿，这倒是个不错的方法。不过指针访问结构成员的正确方法应该是象例十二中使用指针ptr 的方法。</p>
<h2 id="指针和函数的关系"><a href="#指针和函数的关系" class="headerlink" title="指针和函数的关系"></a>指针和函数的关系</h2><p>可以把一个指针声明成为一个指向函数的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int fun1(char *，int);</span><br><span class="line">int (*pfun1)(char *，int);</span><br><span class="line">pfun1=fun1;</span><br><span class="line">int a=(*pfun1)(&quot;abcdefg&quot;，7); //通过函数指针调用函数。</span><br></pre></td></tr></table></figure>
<p>可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。</p>
<p>例十四：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int fun(char *);</span><br><span class="line">int a;</span><br><span class="line">char str[] = &quot;abcdefghijklmn&quot;;</span><br><span class="line">a = fun(str);</span><br><span class="line"></span><br><span class="line">int fun(char *s)</span><br><span class="line">&#123;</span><br><span class="line">	int num = 0;</span><br><span class="line">	for(int i = 0; ; )</span><br><span class="line">	&#123;</span><br><span class="line">		num += *s;</span><br><span class="line">		s ++;</span><br><span class="line">	&#125;</span><br><span class="line">	return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中的函数fun 统计一个字符串中各个字符的ASCII 码值之和。前面说了，数组的名字也是一个指针。在函数调用中，当把str作为实参传递给形参s 后，实际是把str 的值传递给了s，s 所指向的地址就和str 所指向的地址一致，但是str 和s 各自占用各自的存储空间。在函数体内对s 进行自加1 运算，并不意味着同时对str 进行了自加1 运算。</p>
<h2 id="指针类型转换"><a href="#指针类型转换" class="headerlink" title="指针类型转换"></a>指针类型转换</h2><p>当我们初始化一个指针或给一个指针赋值时，赋值号的左边是一个指针，赋值号的右边是一个指针表达式。在我们前面所举的例子中，绝大多数情况下，指针的类型和指针表达式的类型是一样的，指针所指向的类型和指针表达式所指向的类型是一样的。</p>
<p>例十五：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float f = 12.3;</span><br><span class="line">float *fptr = &amp;f;</span><br><span class="line">int *p;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，假如我们想让指针P指向实数f，应该怎么办？是用下面的语句吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;f;</span><br></pre></td></tr></table></figure>
<p>不对。因为指针P的类型是<code>int *</code>，它指向的类型是int。表达式<code>&amp;f</code>的结果是一个指针，指针的类型是<code>float *</code>，它指向的类型是float。两者不一致，直接赋值的方法是不行的。至少在我的MSVC++6.0 上，对指针的赋值语句要求赋值号两边的类型一致，所指向的类型也一致，其它的编译器上我没试过，大家可以试试。</p>
<p>为了实现我们的目的，需要进行”强制类型转换”：<code>p=(int*)&amp;f;</code><br>如果有一个指针p，我们需要把它的类型和所指向的类型改为<code>TYEP *TYPE</code>， 那么语法格式是： <code>(TYPE *)p</code>；</p>
<p>这样强制类型转换的结果是一个新指针，该新指针的类型是<code>TYPE *</code>，它指向的类型是TYPE，它指向的地址就是原指针指向的地址。而原来的指针P的一切属性都没有被修改。（切记）</p>
<p>一个函数如果使用了指针作为形参，那么在函数调用语句的实参和形参的结合过程中，必须保证类型一致，否则需要强制转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void fun(char*);</span><br><span class="line">int a = 125，b;</span><br><span class="line">fun((char*)&amp;a);</span><br><span class="line">void fun(char*s)</span><br><span class="line">&#123;</span><br><span class="line">	char c;</span><br><span class="line">	c = *(s+3);*(s+3)=*(s+0);*(s+0)=c;</span><br><span class="line">	c = *(s+2);*(s+2)=*(s+1);*(s+1)=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这是一个32 位程序，故int 类型占了四个字节，char 类型占一个字节。函数fun 的作用是把一个整数的四个字节的顺序来个颠倒。注意到了吗？在函数调用语句中，实参<code>&amp;a</code>的结果是一个指针，它的类型是<code>int *</code>，它指向的类型是int。形参这个指针的类型是<code>char *</code>，它指向的类型是char。这样，在实参和形参的结合过程中，我们必须进行一次从<code>int *</code>类型到<code>char *</code>类型的转换。</p>
<p>结合这个例子，我们可以这样来想象编译器进行转换的过程：编译器先构造一个临时指针<code>char *temp</code>，然后执行<code>temp=(char *)&amp;a</code>，最后再把temp的值传递给s。</p>
<p>所以最后的结果是：s 的类型是<code>char *</code>，它指向的类型是char，它指向的地址就是a 的首地址。我们已经知道，指针的值就是指针指向的地址，在32 位程序中，指针的值其实是一个32 位整数。那可不可以把一个整数当作指针的值直接赋给指针呢？就象下面的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned int a;</span><br><span class="line">TYPE *ptr; //TYPE 是int，char 或结构类型等等类型。</span><br><span class="line">a=20345686;</span><br><span class="line">ptr=20345686; //我们的目的是要使指针ptr 指向地址20345686</span><br><span class="line">  </span><br><span class="line">ptr=a; //我们的目的是要使指针ptr 指向地址20345686</span><br></pre></td></tr></table></figure>
<p>编译一下吧。结果发现后面两条语句全是错的。那么我们的目的就不能达到了吗？不，还有办法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unsigned int a;</span><br><span class="line">TYPE *ptr; //TYPE 是int，char 或结构类型等等类型。</span><br><span class="line">a=N //N 必须代表一个合法的地址；</span><br><span class="line">ptr=(TYPE*)a； //呵呵，这就可以了。</span><br></pre></td></tr></table></figure>
<p>严格说来这里的<code>(TYPE *)</code>和指针类型转换中的<code>(TYPE *)</code>还不一样。这里的<code>(TYPE*)</code>的意思是把无符号整数a 的值当作一个地址来看待。上面强调了a 的值必须代表一个合法的地址，否则的话，在你使用ptr 的时候，就会出现非法操作错误。想想能不能反过来，把指针指向的地址即指针的值当作一个整数取出来。完全可以。下面的例子演示了把一个指针的值当作一个整数取出来，然后再把这个整数当作一个地址赋给一个指针：</p>
<p>例十七：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 123, b;</span><br><span class="line">int *ptr = &amp;a;</span><br><span class="line">char *str;</span><br><span class="line">b = (int)ptr; //把指针ptr 的值当作一个整数取出来。</span><br><span class="line">str = (char*)b; //把这个整数的值当作一个地址赋给指针str。</span><br></pre></td></tr></table></figure>
<p>现在我们已经知道了，可以把指针的值当作一个整数取出来，也可以把一个整数值当作地址赋给一个指针。</p>
<h2 id="指针的安全问题"><a href="#指针的安全问题" class="headerlink" title="指针的安全问题"></a>指针的安全问题</h2><p>看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char s = &#x27;a&#x27;;</span><br><span class="line">int *ptr;</span><br><span class="line">ptr = (int *)&amp;s;</span><br><span class="line">*ptr = 1298;</span><br></pre></td></tr></table></figure>
<p>指针ptr 是一个<code>int *</code>类型的指针，它指向的类型是int。它指向的地址就是s 的首地址。在32 位程序中，s 占一个字节，int 类型占四个字节。最后一条语句不但改变了s 所占的一个字节，还把和s 相临的高地址方向的三个字节也改变了。这三个字节是干什么的？只有编译程序知道，而写程序的人是不太可能知道的。也许这三个字节里存储了非常重要的数据，也许这三个字节里正好是程序的一条代码，而由于你对指针的马虎应用，这三个字节的值被改变了！这会造成崩溃性的错误。让我们再来看一例：</p>
<p>例十九：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char a;</span><br><span class="line">int *ptr = &amp;a;</span><br><span class="line">ptr++;</span><br><span class="line">*ptr = 115;</span><br></pre></td></tr></table></figure>
<p>该例子完全可以通过编译，并能执行。但是看到没有？第3句对指针ptr 进行自加1 运算后，ptr 指向了和整形变量a 相邻的高地址方向的一块存储区。这块存储区里是什么？我们不知道。有可能它是一个非常重要的数据，甚至可能是一条代码。而第4 句竟然往这片存储区里写入一个数据！这是严重的错误。</p>
<p>所以在使用指针时，程序员心里必须非常清楚：我的指针究竟指向了哪里。在用指针访问数组的时候，也要注意不要超出数组的低端和高端界限，否则也会造成类似的错误。在指针的强制类型转换：<code>ptr1=(TYPE *)ptr2</code>中，如果<code>sizeof(ptr2的类型)</code>大于<code>sizeof(ptr1 的类型)</code>，那么在使用指针ptr1 来访问ptr2所指向的存储区时是安全的。如果<code>sizeof(ptr2 的类型)</code>小于<code>sizeof(ptr1 的类型)</code>，那么在使用指针ptr1 来访问ptr2 所指向的存储区时是不安全的。</p>
<h1 id="预处理的工作方式"><a href="#预处理的工作方式" class="headerlink" title="预处理的工作方式"></a>预处理的工作方式</h1><p>在C语言的程序中可包括各种以符号#开头的编译指令，这些指令称为预处理命令。预处理命令属于C语言编译器，而不是C语言的组成部分。通过预处理命令可扩展C语言程序设计的环境。</p>
<h2 id="预处理的功能"><a href="#预处理的功能" class="headerlink" title="预处理的功能"></a>预处理的功能</h2><p>在集成开发环境中，编译，链接是同时完成的。其实，C语言编译器在对源代码编译之前，还需要进一步的处理：预编译。<br>所以，完整的步骤是：预编译 -&gt; 编译 -&gt; 链接<br>预编译的主要作用如下：</p>
<ol>
<li>将源文件中以”include”格式包含的文件复制到编译的源文件中。</li>
<li>用实际值替换用“#define”定义的字符串。</li>
<li>根据“#if”后面的条件决定需要编译的代码。</li>
</ol>
<h2 id="预处理的工作方式-1"><a href="#预处理的工作方式-1" class="headerlink" title="预处理的工作方式"></a>预处理的工作方式</h2><p>预处理的行为是由指令控制的。这些指令是由#字符开头的一些命令。</p>
<p><code>#define</code>指令定义了一个宏—-用来代表其他东西的一个命令，通常是某一个类型的常量。预处理会通过将宏的名字和它的定义存储在一起来响应#define指令。当这个宏在后面的程序中使用到时，预处理器”扩展”了宏，将宏替换为它所定义的值。例如：下面这行命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PI 3.141592654</span><br></pre></td></tr></table></figure><br><code>#include</code>指令告诉预处理器打开一个特定的文件，将它的内容作为正在编译的文件的一部分“包含”进来。例如：下面这行命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br></pre></td></tr></table></figure><br>指示预处理器打开一个名字为stdio.h的文件，并将它的内容加到当前的程序中。</p>
<p>预处理器的输入是一个C语言程序，程序可能包含指令。预处理器会执行这些指令，并在处理过程中删除这些指令。预处理器的输出是另外一个程序：原程序的一个编辑后的版本，不再包含指令。预处理器的输出被直接交给编译器，编译器检查程序是否有错误，并经程序翻译为目标代码。</p>
<h1 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h1><h2 id="预处理指令-1"><a href="#预处理指令-1" class="headerlink" title="预处理指令"></a>预处理指令</h2><p>大多数预处理器指令属于下面3种类型：</p>
<ol>
<li>宏定义：#define 指令定义一个宏，#undef指令删除一个宏定义。</li>
<li>文件包含：#include指令导致一个指定文件的内容被包含到程序中。</li>
<li>条件编译：#if,#ifdef,#ifndef,#elif,#else和#endif指令可以根据编译器可以测试的条件来将一段文本包含到程序中或排除在程序之外。</li>
</ol>
<p>剩下的#error,#line和#pragma指令更特殊的指令，较少用到。 </p>
<h2 id="指令规则"><a href="#指令规则" class="headerlink" title="指令规则"></a>指令规则</h2><p>指令都是以#开始。#符号不需要在一行的行首，只要她之前有空白字符就行。在#后是指令名，接着是指令所需要的其他信息。<br>在指令的符号之间可以插入任意数量的空格或横向制表符。<br>指令总是第一个换行符处结束，除非明确地指明要继续。<br>指令可以出现在程序中任何地方。我们通常将#define和#include指令放在文件的开始，其他指令则放在后面，甚至在函数定义的中间。<br>注释可以与指令放在同一行。</p>
<h1 id="宏定义命令——-define"><a href="#宏定义命令——-define" class="headerlink" title="宏定义命令——#define"></a>宏定义命令——#define</h1><p>使用#define命令并不是真正的定义符号常量，而是定义一个可以替换的宏。被定义为宏的标示符称为“宏名”。在编译预处理过程时，对程序中所有出现的“宏名”，都用宏定义中的字符串去代换，这称为“宏代换”或“宏展开”。</p>
<p>在C语言中，宏分为有参数和无参数两种。</p>
<h2 id="无参数的宏"><a href="#无参数的宏" class="headerlink" title="无参数的宏"></a>无参数的宏</h2><p>其定义格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define 宏名  字符串</span><br></pre></td></tr></table></figure><br>在以上宏定义语句中，各部分的含义如下：</p>
<ul>
<li><h1 id="：表示这是一条预处理命令-凡是以“-”开始的均为预处理命令-。"><a href="#：表示这是一条预处理命令-凡是以“-”开始的均为预处理命令-。" class="headerlink" title="：表示这是一条预处理命令(凡是以“#”开始的均为预处理命令)。"></a>：表示这是一条预处理命令(凡是以“#”开始的均为预处理命令)。</h1></li>
<li>define:关键字“define”为宏定义命令。</li>
<li>宏名：是一个标示符，必须符合C语言标示符的规定，一般以大写字母标示宏名。</li>
<li>字符串：可以是常数，表达式，格式串等。在前面使用的符号常量的定义就是一个无参数宏定义。</li>
</ul>
<p>Notice:预处理命令语句后面一般不会添加分号，如果在#define最后有分号，在宏替换时分号也将替换到源代码中去。在宏名和字符串之间可以有任意个空格。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PI 3.14</span><br></pre></td></tr></table></figure></p>
<p>在使用宏定义时，还需要注意以下几点：</p>
<ul>
<li>宏定义是宏名来表示一个字符串，在宏展开时又以该字符串取代宏名。这只是一种简单的代换，字符串中可以含任何字符，可以是常数，也可以是表达式，预处理程序对它不作任何检查。如有错误，只能在编译已被宏展开后的源程序时发现。</li>
<li>宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。</li>
<li>宏名在源程序中若用引号括起来，则预处理程序不对其作宏替换。</li>
<li>宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名。在宏展开时由预处理程序层层替换。</li>
<li>习惯上宏名可用大写字母表示，以方便与变量区别。但也允许用小写字母。</li>
</ul>
<h2 id="带参数的宏"><a href="#带参数的宏" class="headerlink" title="带参数的宏"></a>带参数的宏</h2><p><code>#define</code>命令定义宏时，还可以为宏设置参数。与函数中的参数类似，在宏定于中的参数为形式参数，在宏调用中的参数称为实际参数。对带参数的宏，在调用中，不仅要宏展开，还要用实参去代换形参。<br>带参宏定义的一般形式为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define 宏名(形参表) 字符串　　</span><br></pre></td></tr></table></figure><br>在定义带参数的宏时，宏名和形参表之间不能有空格出现，否则，就将宏定义成为无参数形式，而导致程序出错。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ABS(x)  (x)&lt;0?-(x):(x)</span><br></pre></td></tr></table></figure><br>以上的宏定义中，如果x的值小于0，则使用一元运算符(-)对其取负，得到正数。</p>
<p>带参的宏和带参的函数相似，但其本质是不同的。使用带参宏时，在预处理时将程序源代码替换到相应的位置，编译时得到完整的目标代码，而不进行函数调用，因此程序执行效率要高些。而函数调用只需要编译一次函数，代码量较少，一般情况下，对于简单的功能，可使用宏替换的形式来使用。</p>
<h2 id="预处理操作符-和"><a href="#预处理操作符-和" class="headerlink" title="预处理操作符#和"></a>预处理操作符#和</h2><h3 id="操作符-1"><a href="#操作符-1" class="headerlink" title="操作符"></a>操作符</h3><p>在使用#define定义宏时，可使用操作符#在字符串中输出实参。Eg:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define AREA(x,y) printf(“长为“#x”,宽为“#y”的长方形的面积：%d\n”,(x)*(y));</span><br></pre></td></tr></table></figure></p>
<h2 id="操作符-2"><a href="#操作符-2" class="headerlink" title="操作符"></a>操作符</h2><p>与操作符#类似，操作符##也可用在带参宏中替换部分内容。该操作符将宏中的两个部分连接成一个内容。例如，定义如下宏：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define VAR(n)   v##n　</span><br></pre></td></tr></table></figure></p>
<p>当使用一下方式引用宏：<code>VAR(1)</code><br>预处理时，将得到以下形式：<code>v1</code></p>
<p>如果使用以下宏定义：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define FUNC(n)  oper##n　　</span><br></pre></td></tr></table></figure><br>当实参为1时，预处理后得到一下形式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oper1</span><br></pre></td></tr></table></figure></p>
<h1 id="文件包含———include"><a href="#文件包含———include" class="headerlink" title="文件包含———include"></a>文件包含———include</h1><p>当一个C语言程序由多个文件模块组成时，主模块中一般包含main函数和一些当前程序专用的函数。程序从main函数开始执行，在执行过程中，可调用当前文件中的函数，也可调用其他文件模块中的函数。</p>
<p>如果在模块中要调用其他文件模块中的函数，首先必须在主模块中声明该函数原型。一般都是采用文件包含的方法，包含其他文件模块的头文件。</p>
<p>文件包含中指定的文件名即可以用引号括起来，也可以用尖括号括起来，格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&lt; 文件名&gt;</span><br></pre></td></tr></table></figure><br>或<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include“文件名”</span><br></pre></td></tr></table></figure><br>如果使用尖括号&lt;&gt;括起文件名，则编译程序将到C语言开发环境中设置好的 include文件中去找指定的文件。</p>
<p>因为C语言的标准头文件都存放在include文件夹中，所以一般对标准头文件采用尖括号；对编程自己编写的文件，则使用双引号。</p>
<p>如果自己编写的文件不是存放在当前工作文件夹，可以在#include命令后面加在路径。</p>
<p><code>#include</code>命令的作用是把指定的文件模块内容插入到#include所在的位置，当程序编译链接时，系统会把所有#include指定的文件链接生成可执行代码。文件包含必须以#开头，表示这是编译预处理命令，行尾不能用分号结束。<br>　　<br><code>#include</code>所包含的文件，其扩展名可以是“.c”,表示包含普通C语言源程序。也可以是 “.h”,表示C语言程序的头文件。C语言系统中大量的定义与声明是以头文件形式提供的。 “.h”是接口文件，如果想理解C语言接口的写法，有必要琢磨一下 “.h”。</p>
<p>通过#define包含进来的文件模块中还可以再包含其他文件，这种用法称为嵌套包含。嵌套的层数与具体C语言系统有关，但是一般可以嵌套8层以上。</p>
<h1 id="条件编译-1"><a href="#条件编译-1" class="headerlink" title="条件编译"></a>条件编译</h1><p>预处理器还提供了条件编译功能。在预处理时，按照不同的条件去编译程序的不同部分，从而得到不同的目标代码。</p>
<p>使用条件编译，可方便地处理程序的调试版本和正式版本，也可使用条件编译使程序的移植更方便。</p>
<h2 id="使用-if"><a href="#使用-if" class="headerlink" title="使用#if"></a>使用#if</h2><p>与C语言的条件分支语句类似，在预处理时，也可以使用分支，根据不同的情况编译不同的源代码段。</p>
<p><code>#if</code>的使用格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if 常量表达式</span><br><span class="line">   程序段</span><br><span class="line">#else</span><br><span class="line">  程序段</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>该条件编译命令的执行过程为：若常量表达式的值为真(非0),则对程序段1进行编译，否则对程序段2进行编译。因此可以使程序在不同条件下完成不同的功能。</p>
<p>举个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define DEBUG 1</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int i,j;</span><br><span class="line">   char ch[26];</span><br><span class="line">   for(i=&#x27;a&#x27;;j=0;i&lt;=&#x27;z&#x27;;i++,j++)</span><br><span class="line">   &#123;</span><br><span class="line">       ch[j]=i;</span><br><span class="line">       #if DEBUG</span><br><span class="line">          printf(&quot;ch[%d]=%c\n&quot;,j,ch[j]);</span><br><span class="line">       #endif</span><br><span class="line">   &#125;</span><br><span class="line">   for(j=0;j&lt;26;j++)</span><br><span class="line">   &#123;</span><br><span class="line">       printf(&quot;%c&quot;,ch[j]);</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>#if</code>预编译命令还可使用多分支语句格式，具体格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#if 常量表达式 1</span><br><span class="line"> </span><br><span class="line">    程序段 1</span><br><span class="line"> </span><br><span class="line">#elif 常量表达式 2</span><br><span class="line"> </span><br><span class="line">    程序段 2</span><br><span class="line"> </span><br><span class="line">… …</span><br><span class="line"> </span><br><span class="line">#elif 常量表达式 n</span><br><span class="line"> </span><br><span class="line">    程序段 n</span><br><span class="line"> </span><br><span class="line">#else</span><br><span class="line"> </span><br><span class="line">    程序段 m</span><br><span class="line"> </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>关键字#elif与多分支if语句中的else if类似。<br>举个例子<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#define os win</span><br><span class="line"> </span><br><span class="line">#if os=win</span><br><span class="line"> </span><br><span class="line">    #include&quot;win.h&quot;</span><br><span class="line"> </span><br><span class="line">#elif os=linux</span><br><span class="line"> </span><br><span class="line">    #include&quot;linux.h&quot;</span><br><span class="line"> </span><br><span class="line">#elif os=mac</span><br><span class="line"> </span><br><span class="line">    #include&quot;mac.h&quot;</span><br><span class="line"> </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p><code>#if</code>和<code>#elif</code>还可以进行嵌套，C89标准中，嵌套深度可以到达8层，而C99允许嵌套达到63层。在嵌套时，每个#endif，#else或#elif与最近的#if或#elif配对。<br>Eg:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#define MAX 100</span><br><span class="line">#define OLD -1</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">#if MAX&gt;50</span><br><span class="line">&#123; </span><br><span class="line">    #if OLD&gt;3</span><br><span class="line">    &#123;</span><br><span class="line">        i=1;</span><br><span class="line">    &#123;</span><br><span class="line">    #elif OLD&gt;0</span><br><span class="line">    &#123;</span><br><span class="line">        i=2;</span><br><span class="line">    &#125;</span><br><span class="line">    #else</span><br><span class="line">    &#123;</span><br><span class="line">        i=3;</span><br><span class="line">    &#125;</span><br><span class="line">    #endif</span><br><span class="line">&#125;</span><br><span class="line">#else</span><br><span class="line">&#123;</span><br><span class="line">    #if OLD&gt;3</span><br><span class="line">    &#123;</span><br><span class="line">        i=4;</span><br><span class="line">    &#125;</span><br><span class="line">    #elif OLD&gt;4</span><br><span class="line">    &#123;</span><br><span class="line">        i=5;</span><br><span class="line">    &#125;</span><br><span class="line">    #else</span><br><span class="line">    &#123;</span><br><span class="line">        i=6;</span><br><span class="line">    &#125;</span><br><span class="line">    #endif</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用-ifdef和-ifndef"><a href="#使用-ifdef和-ifndef" class="headerlink" title="使用#ifdef和#ifndef"></a>使用#ifdef和#ifndef</h2><p>在上面的#if条件编译命令中，需要判断符号常量定义的具体值。在很多情况下，其实不需要判断符号常量的值，只需要判断是否定义了该符号常量。这时，可不使用#if命令，而使用另外一个预编译命令———#ifdef.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#ifdef命令的使用格式如下：</span><br><span class="line">#ifdef 标识符</span><br><span class="line">程序段 1</span><br><span class="line"> </span><br><span class="line">#else</span><br><span class="line"> </span><br><span class="line">程序段 2</span><br><span class="line"> </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><br>其意义是，如果#ifdef后面的标识符已被定义过，则对“程序段1”进行编译；如果没有定义标识符，则编译“程序段2”。一般不使用#else及后面的“程序2”。</p>
<p>而#ifndef的意义与#ifdef相反，其格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#ifndef 标识符</span><br><span class="line">    程序段 1</span><br><span class="line"> </span><br><span class="line">#else</span><br><span class="line"> </span><br><span class="line">    程序段 2</span><br><span class="line"> </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><br>其意义是：如果未定义标识符，则编译“程序段1”；否则编译“程序段2”。</p>
<h2 id="使用-defined和-undef"><a href="#使用-defined和-undef" class="headerlink" title="使用#defined和#undef"></a>使用#defined和#undef</h2><p>与#ifdef类似的，可以在#if命令中使用define来判断是否已定义指定的标识符。例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#if defined 标识符</span><br><span class="line">程序段 1 </span><br><span class="line"> </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>与下面的标示方式意义相同。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifdef 标识符</span><br><span class="line">    程序段 1</span><br><span class="line"> </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>也可使用逻辑运算符，对defined取反。例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#if ! define 标识符</span><br><span class="line">    程序段 1</span><br><span class="line"> </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>与下面的标示方式意义相同。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef 标识符</span><br><span class="line">    程序段 1</span><br><span class="line"> </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>在#ifdef和#ifndef命令后面的标识符是使用#define进行定义的。在程序中，还可以使用#undef取消对标识符的定义，其形式为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#undef 标识符　　</span><br></pre></td></tr></table></figure><br>举个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define MAX 100 </span><br><span class="line">……</span><br><span class="line">#undef MAX</span><br></pre></td></tr></table></figure></p>
<p>在以上代码中，首先使用#define定义标识符MAX,经过一段程序代码后，又可以使用#undef取消已定义的标识符。使用#undef命令后，再使用#ifdef max，将不会编译后的源代码，因为此时标识符MAX已经被取消定义了。</p>
<h1 id="其他预处理命令"><a href="#其他预处理命令" class="headerlink" title="其他预处理命令"></a>其他预处理命令</h1><h2 id="预定义的宏名"><a href="#预定义的宏名" class="headerlink" title="预定义的宏名"></a>预定义的宏名</h2><p>ANSI C标准预定义了五个宏名，每个宏名的前后均有两个下画线，避免与程序员定义相同的宏名(一般都不会定义前后有两个下划线的宏)。这5个宏名如下：</p>
<ul>
<li><code>__DATE__</code>:当前源程序的创建日期。</li>
<li><code>__FILE__</code>:当前源程序的文件名称(包括盘符和路径)。</li>
<li><code>__LINE__</code>:当前被编译代码的行号。</li>
<li><code>__STDC__</code>:返回编译器是否位标准C,若其值为1表示符合标准C，否则不是标准C.</li>
<li><code>__TIME__</code>:当前源程序的创建时间。</li>
</ul>
<p>举个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int j;</span><br><span class="line">   printf(&quot;日期：%s\n&quot;,__DATE__);</span><br><span class="line">   printf(&quot;时间：%s\n&quot;,__TIME__&#125;;</span><br><span class="line">   printf(&quot;文件名：%s\n&quot;,__FILE__);</span><br><span class="line">   printf(&quot;这是第%d行代码\n&quot;,__LINE__);</span><br><span class="line">   printf(&quot;本编译器%s标准C\n&quot;,(__STD__)?&quot;符合&quot;:&quot;不符合&quot;)；</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="重置行号和文件名命令——————-line"><a href="#重置行号和文件名命令——————-line" class="headerlink" title="重置行号和文件名命令——————#line"></a>重置行号和文件名命令——————#line</h2><p>使用<code>__LINE__</code>预定义宏名赈灾编译的程序行号。使用#line命令可改变预定义宏<code>__LINE__</code>与<code>__FILE__</code>的内容，该命令的基本形如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#line number[“filename”]</span><br></pre></td></tr></table></figure><br>其中的数字为一个正整数，可选的文件名为有效文件标识符。行号为源代码中当前行号，文件名为源文件的名字。命令为#line主要用于调试以及其他特殊应用。<br>举个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#line 1000</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;当前行号：%d\n&quot;,__LINE__);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在以上程序中，在第4行中使用#line定义的行号为从1000开始(不包括#line这行)。所以第5行的编号将为1000，第6行为1001，第7行为1002，第8行为1003.</p>
<h2 id="修改编译器设置命令-pragma"><a href="#修改编译器设置命令-pragma" class="headerlink" title="修改编译器设置命令 pragma"></a>修改编译器设置命令 pragma</h2><p><code>#pragma</code>命令的作用是设定编译器的状态，或者指示编译器完全一些特定的动作。#pragma命令对每个编译器给出了一个方法，在保持与C语言完全兼容的情况下，给出主机或者操作系统专有的特征。其格式一般为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma Para</span><br></pre></td></tr></table></figure><br>其中，Para为参数，可使用的参数很多，下面列出常用的参数：</p>
<ul>
<li>Message参数，该参数能够在编译信息输出窗口中输出对应的信息，这对于源代码信息的控制是非常重要的，其使用方法是：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma message(消息文本)</span><br></pre></td></tr></table></figure>
当编译器遇到这条指令时，就在编译输出窗口中将消息文本显示出来。</li>
<li>另外一个使用比较多得pragma参数是code_seg.格式如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma code_seg([“section_name”[,section_class]])</span><br></pre></td></tr></table></figure>
它能够设置程序中函数代码存放的代码段，在开发驱动程序的时候就会使用到它。</li>
</ul>
<p>参数once，可保证头文件被编译一次，其格式为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br></pre></td></tr></table></figure><br>只要在头文件的最开始加入这条指令就能够保证头文件被编译一次。</p>
<h2 id="产生错误信息命令-——————-error"><a href="#产生错误信息命令-——————-error" class="headerlink" title="产生错误信息命令 ——————#error"></a>产生错误信息命令 ——————#error</h2><p><code>#error</code>命令强制编译器停止编译，并输出一个错误信息，主要用于程序调试。其使用如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#error 信息错误　　</span><br></pre></td></tr></table></figure><br>注意，错误信息不用双括号括起来。当遇到#error命令时，错误信息将显示出来。</p>
<p>例如，以下编译预处理器命令判断预定义宏<code>__STDC__</code>,如果其值不为1，则显示一个错误信息，提示程序员该编译器不支持ANSI C标准。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#if __STDC__!=1</span><br><span class="line"> </span><br><span class="line">   #error NOT ANSI C</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>在使用#define定义带参数宏时，在调用函数时，一般需要增加系统的开销，如参数传递，跳转控制，返回结果等额外操作需要系统内存和执行时间。而使用带参数宏时，通过宏替换可再编译前将函数代码展开导源代码中，使编译后的目标文件含有多段重复的代码。这样做，会增加程序的代码量，都可以减少执行时间。<br>　　<br>在C99标准钟，还提供另外一种解决方法：使用内联函数。</p>
<p>在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来进行替代。显然，这种做法不会产生转去转回得问题。都是由于在编译时将函数体中的代码被替代到程序中，因此会增加目标代码量，进而增加空间的开销，而在时间开销上不像函数调用时那么大，可见它是以增加目标代码为代码来换取时间的节省。<br>定义内联函数的方法很简单，只要在定义函数头的前面加上关键字inline即可。内联函数的定义与一般函数一样。例如，定于一个两个整数相加的函数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">inline int add(int x,int y); </span><br><span class="line">inline int add(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">   return x+y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int i,j,k;</span><br><span class="line">   printf(&quot;请输入两个整数的值：\n&quot;);</span><br><span class="line">   scanf(&quot;%d %d&quot;,&amp;i,&amp;j);</span><br><span class="line">   k=add(i,j);</span><br><span class="line">   printf(&quot;k=%d\n&quot;,k);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在程序中，调用函数add时，该函数在编译时会将以上代码复制过来，而不是像一般函数那样是运行时被调用。</p>
<p>内联函数具有一般函数的特性，它与一般函数所不同之处在于函数调用的处理。一般函数进行调用时，要讲程序执行权转导被调函数中，然后再返回到调用到它的函数中；而内联函数在调用时，是将调用表达式用内联函数体来替换。在使用内联函数时，应该注意如下几点：</p>
<ul>
<li>在内联函数内部允许用循环语句和开关语句。但是，程序在经过编译之后，这个函数是不会作为内联函数进行调用的。<br>内联函数的定义必须出现在内联函数第一次被调用之前。</li>
<li>其实，在程序中声明一个函数为内联时，编译以后这个函数不一定是内联的，</li>
</ul>
<p>即程序只是建议编译器使用内联函数，但是编译器会根据函数情况决定是否使用内联，所以如果编写的内联函数中出现循环或者开关语句，程序也不会提示出错，但那个函数已经不是内联函数了。</p>
<p>一般都是将一个小型函数作为内联函数。</p>
<h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>顾名思义，函数指针就是函数的指针。它是一个指针，指向一个函数。看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A) char * (*fun1)(char * p1,char * p2);</span><br><span class="line">B) char * *fun2(char * p1,char * p2);</span><br><span class="line">C) char * fun3(char * p1,char * p2);</span><br></pre></td></tr></table></figure>
<p>看看上面三个表达式分别是什么意思？</p>
<ul>
<li>C）这很容易，fun3是函数名，p1，p2是参数，其类型为char <em>型，函数的返回值为char </em>类型。</li>
<li>B) 也很简单，与C）表达式相比，唯一不同的就是函数的返回值类型为char**，是个二级指针。</li>
<li>A) fun1是函数名吗？回忆一下前面讲解数组指针时的情形。我们说数组指针这么定义或许更清晰：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*)[10] p;</span><br></pre></td></tr></table></figure>
<p>再看看A）表达式与这里何其相似！明白了吧。这里fun1不是什么函数名，而是一个指针变量，它指向一个函数。这个函数有两个指针类型的参数，函数的返回值也是一个指针。同样，我们把这个表达式改写一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * (*)(char * p1,char * p2) fun1;</span><br></pre></td></tr></table></figure>
<p>这样子是不是好看一些呢？只可惜编译器不这么想。^_^。</p>
<h2 id="使用的例子"><a href="#使用的例子" class="headerlink" title="使用的例子"></a>使用的例子</h2><p>上面我们定义了一个函数指针，但如何来使用它呢？先看如下例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">char * fun(char * p1,char * p2)</span><br><span class="line">&#123;</span><br><span class="line">　　int i = 0;</span><br><span class="line">　　i = strcmp(p1,p2);</span><br><span class="line">　　if (0 == i)</span><br><span class="line">　　&#123;</span><br><span class="line">　　　　return p1;</span><br><span class="line">　　&#125;</span><br><span class="line">　　else</span><br><span class="line">　　&#123;</span><br><span class="line">　　　　return p2;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">　　char * (*pf)(char * p1,char * p2);</span><br><span class="line">　　pf = &amp;fun;</span><br><span class="line">　　(*pf) (&quot;aa&quot;,&quot;bb&quot;);</span><br><span class="line">　　return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用指针的时候，需要通过钥匙（“*”）来取其指向的内存里面的值，函数指针使用也如此。通过用(*pf)取出存在这个地址上的函数，然后调用它。</p>
<p>这里需要注意到是，在Visual C++6.0里，给函数指针赋值时，可以用&amp;fun或直接用函数名fun。这是因为函数名被编译之后其实就是一个地址，所以这里两种用法没有本质的差别。这个例子很简单，就不再详细讨论了。</p>
<h2 id="复杂的例子"><a href="#复杂的例子" class="headerlink" title="复杂的例子"></a>复杂的例子</h2><p>也许上面的例子过于简单，我们看看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void Function()</span><br><span class="line">&#123;</span><br><span class="line">　　printf(&quot;Call Function!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">　　void (*p)();</span><br><span class="line">　　*(int*)&amp;p=(int)Function;</span><br><span class="line">　　(*p)();</span><br><span class="line">　　return 0;</span><br><span class="line">&#125;　</span><br></pre></td></tr></table></figure>
<p>这是在干什么？<code>*(int*)&amp;p=(int)Function;</code>表示什么意思？<br>别急，先看这行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void (*p)();</span><br></pre></td></tr></table></figure>
<p>这行代码定义了一个指针变量p，p指向一个函数，这个函数的参数和返回值都是void。&amp;p是求指针变量p本身的地址，这是一个32位的二进制常数（32位系统）。</p>
<p><code>(int*)&amp;p</code>表示将地址强制转换成指向int类型数据的指针。<code>(int)Function</code>表示将函数的入口地址强制转换成int类型的数据。分析到这里，相信你已经明白<code>*(int*)&amp;p=(int)Function;</code>表示将函数的入口地址赋值给指针变量p。</p>
<p>那么<code>(*p) ();</code>就是表示对函数的调用。</p>
<p>讲解到这里，相信你已经明白了。其实函数指针与普通指针没什么差别，只是指向的内容不同而已。<br>使用函数指针的好处在于，可以将实现同一功能的多个模块统一起来标识，这样一来更容易后期的维护，系统结构更加清晰。或者归纳为：便于分层设计、利于系统抽象、降低耦合度以及使接口与实现分开。</p>
<h2 id="另一个复杂的例子"><a href="#另一个复杂的例子" class="headerlink" title="另一个复杂的例子"></a>另一个复杂的例子</h2><p>是不是感觉上面的例子太简单，不够刺激？好，那就来点刺激的，看下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*(void(*) ())0)();</span><br></pre></td></tr></table></figure>
<p>这是《C Traps and Pitfalls》这本经典的书中的一个例子。没有发狂吧？下面我们就来分析分析：</p>
<ul>
<li>第一步：<code>void(*) ()</code>，可以明白这是一个函数指针类型。这个函数没有参数，没有返回值。</li>
<li>第二步：<code>(void(*) ())0</code>，这是将0强制转换为函数指针类型，0是一个地址，也就是说一个函数存在首地址为0的一段区域内。</li>
<li>第三步：<code>(*(void(*) ())0)</code>，这是取0地址开始的一段内存里面的内容，其内容就是保存在首地址为0的一段区域内的函数。</li>
<li>第四步：<code>(*(void(*) ())0)()</code>，这是函数调用。</li>
</ul>
<p>好像还是很简单是吧，上面的例子再改写改写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*(char**(*) (char **,char **))0) ( char **,char **);</span><br></pre></td></tr></table></figure>
<p>如果没有上面的分析，肯怕不容易把这个表达式看明白吧。不过现在应该是很简单的一件事了。读者以为呢？</p>
<h1 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h1><p>现在我们清楚表达式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * (*pf)(char * p);</span><br></pre></td></tr></table></figure>
<p>定义的是一个函数指针pf。既然pf是一个指针，那就可以储存在一个数组里。把上式修改一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * (*pf[3])(char * p);</span><br></pre></td></tr></table></figure>
<p>这是定义一个函数指针数组。</p>
<p>它是一个数组，数组名为pf，数组内存储了3个指向函数的指针。这些指针指向一些返回值类型为指向字符的指针、参数为一个指向字符的指针的函数。</p>
<p>这念起来似乎有点拗口。不过不要紧，关键是你明白这是一个指针数组，是数组。函数指针数组怎么使用呢？这里也给出一个非常简单的例子，只要真正掌握了使用方法，再复杂的问题都可以应对。</p>
<p>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">char * fun1(char * p)</span><br><span class="line">&#123;</span><br><span class="line">　　printf(&quot;%s\n&quot;,p);</span><br><span class="line">　　return p;</span><br><span class="line">&#125; </span><br><span class="line">char * fun2(char * p)</span><br><span class="line">&#123;</span><br><span class="line">　　printf(&quot;%s\n&quot;,p);</span><br><span class="line">　　return p;</span><br><span class="line">&#125;</span><br><span class="line">char * fun3(char * p)</span><br><span class="line">&#123;</span><br><span class="line">　　printf(&quot;%s\n&quot;,p);</span><br><span class="line">　　return p;</span><br><span class="line">&#125;</span><br><span class="line">&lt;br&gt;int main()</span><br><span class="line">&#123;</span><br><span class="line">　　char * (*pf[3])(char * p);</span><br><span class="line">　　pf[0] = fun1; //可以直接用函数名</span><br><span class="line">　　pf[1] = &amp;fun2; //可以用函数名加上取地址符</span><br><span class="line">　　pf[2] = &amp;fun3;&lt;br&gt;</span><br><span class="line">　　pf[0](&quot;fun1&quot;);</span><br><span class="line">　　pf[0](&quot;fun2&quot;);</span><br><span class="line">　　pf[0](&quot;fun3&quot;);</span><br><span class="line">　　return 0;</span><br><span class="line">&#125;　</span><br></pre></td></tr></table></figure>
<h1 id="函数指针数组的指针"><a href="#函数指针数组的指针" class="headerlink" title="函数指针数组的指针"></a>函数指针数组的指针</h1><p>看着这个标题没发狂吧？函数指针就够一般初学者折腾了，函数指针数组就更加麻烦，现在的函数指针数组指针就更难理解了。<br>其实，没这么复杂。前面详细讨论过数组指针的问题，这里的函数指针数组指针不就是一个指针嘛。只不过这个指针指向一个数组，这个数组里面存的都是指向函数的指针。仅此而已。</p>
<p>下面就定义一个简单的函数指针数组指针：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * (*(*pf)[3])(char * p);</span><br></pre></td></tr></table></figure>
<p>注意，这里的pf和上一节的pf就完全是两码事了。上一节的pf并非指针，而是一个数组名；这里的pf确实是实实在在的指针。这个指针指向一个包含了3个元素的数组；这个数字里面存的是指向函数的指针；这些指针指向一些返回值类型为指向字符的指针、参数为一个指向字符的指针的函数。</p>
<p>这比上一节的函数指针数组更拗口。其实你不用管这么多，明白这是一个指针就ok了。其用法与前面讲的数组指针没有差别。下面列一个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">char * fun1(char * p)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%s\n&quot;,p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">char * fun2(char * p)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%s\n&quot;,p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">char * fun3(char * p)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%s\n&quot;,p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char * (*a[3])(char * p);</span><br><span class="line">    char * (*(*pf)[3])(char * p);</span><br><span class="line">    pf = &amp;a;</span><br><span class="line"> </span><br><span class="line">    a[0] = fun1;</span><br><span class="line">    a[1] = &amp;fun2;</span><br><span class="line">    a[2] = &amp;fun3;</span><br><span class="line"> </span><br><span class="line">    pf[0][0](&quot;fun1&quot;);</span><br><span class="line">    pf[0][1](&quot;fun2&quot;);</span><br><span class="line">    pf[0][2](&quot;fun3&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="内存泄漏问题原理"><a href="#内存泄漏问题原理" class="headerlink" title="内存泄漏问题原理"></a>内存泄漏问题原理</h1><h2 id="堆内存在C代码中的存储方式"><a href="#堆内存在C代码中的存储方式" class="headerlink" title="堆内存在C代码中的存储方式"></a>堆内存在C代码中的存储方式</h2><p>内存泄漏问题只有在使用堆内存的时候才会出现，栈内存不存在内存泄漏问题，因为栈内存会自动分配和释放。C代码中堆内存的申请函数是malloc，常见的内存申请代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *info = <span class="literal">NULL</span>;    <span class="comment">/**转换后的字符串**/</span></span><br><span class="line"> </span><br><span class="line">info = (<span class="type">char</span>*)<span class="built_in">malloc</span>(NB_MEM_SPD_INFO_MAX_SIZE);</span><br><span class="line"><span class="keyword">if</span> ( <span class="literal">NULL</span> == info)</span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)tdm_error(<span class="string">&quot;malloc error!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> NB_SA_ERR_HPI_OUT_OF_MEMORY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于malloc函数返回的实际上是一个内存地址，所以保存堆内存的变量一定是一个指针（除非代码编写极其不规范）。再重复一遍，保存堆内存的变量一定是一个指针，这对本文主旨的理解很重要。当然，这个指针可以是单指针，也可以是多重指针。</p>
<p>malloc函数有很多变种或封装，如g_malloc、g_malloc0、VOS_Malloc等，这些函数最终都会调用malloc函数。</p>
<h2 id="堆内存的获取方法"><a href="#堆内存的获取方法" class="headerlink" title="堆内存的获取方法"></a>堆内存的获取方法</h2><p>看到本小节标题，可能有些同学有疑惑，上一小节中的malloc函数，不就是堆内存的获取方法吗？的确是，通过malloc函数申请是最直接的获取方法，如果只知道这种堆内存获取方法，就容易掉到坑里了。一般的来讲，堆内存有如下两种获取方法：</p>
<p>方法一：将函数返回值直接赋给指针，一般表现形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *local_pointer_xx = <span class="literal">NULL</span>;</span><br><span class="line">local_pointer_xx = (<span class="type">char</span>*)function_xx(para_xx, …);</span><br></pre></td></tr></table></figure>
<p>该类涉及到内存申请的函数，返回值一般都指针类型，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GSList* g_slist_append (GSList   *list, gpointer  data)</span><br></pre></td></tr></table></figure>
<p>方法二：将指针地址作为函数返回参数，通过返回参数保存堆内存地址，一般表现形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ret;</span><br><span class="line">char *local_pointer_xx = NULL;    /**转换后的字符串**/</span><br><span class="line">ret = (char*)function_xx(..., &amp;local_pointer_xx, ...);</span><br></pre></td></tr></table></figure>
<p>该类涉及到内存申请的函数，一般都有一个入参是双重指针，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__STDIO_INLINE _IO_ssize_t</span><br><span class="line">getline (char **__lineptr, size_t *__n, FILE *__stream)</span><br></pre></td></tr></table></figure>
<p>前面说通过malloc申请内存，就属于方法一的一个具体表现形式。其实这两类方法的本质是一样的，都是函数内部间接申请了内存，只是传递内存的方法不一样，方法一通过返回值传递内存指针，方法二通过参数传递内存指针。</p>
<h2 id="内存泄漏三要素"><a href="#内存泄漏三要素" class="headerlink" title="内存泄漏三要素"></a>内存泄漏三要素</h2><p>最常见的内存泄漏问题，包含以下三个要素：</p>
<ul>
<li>要素一：函数内有局部指针变量定义；</li>
<li>要素二：对该局部指针有通过上一小节中“两种堆内存获取方法”之一获取内存；</li>
<li>要素三：在函数返回前（含正常分支和异常分支）未释放该内存，也未保存到其它全局变量或返回给上一级函数。</li>
</ul>
<h2 id="内存释放误区"><a href="#内存释放误区" class="headerlink" title="内存释放误区"></a>内存释放误区</h2><p>稍微使用过C语言编写代码的人，都应该知道堆内存申请之后是需要释放的。但为何还这么容易出现内存泄漏问题呢？一方面，是开发人员经验不足、意识不到位或一时疏忽导致；另一方面，是内存释放误区导致。很多开发人员，认为要释放的内存应该局限于以下两种：</p>
<ol>
<li>直接使用内存申请函数申请出来的内存，如malloc、g_malloc等；</li>
<li>该开发人员熟悉的接口中，存在内存申请的情况，如iBMC的兄弟，都应该知道调用如下接口需要释放list指向的内存：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfl_get_object_list(<span class="type">const</span> <span class="type">char</span>* class_name, GSList **<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<p>按照以上思维编写代码，一旦遇到不熟悉的接口中需要释放内存的问题，就完全没有释放内存的意识，内存泄漏问题就自然产生了。</p>
<h1 id="内存泄漏问题检视方法"><a href="#内存泄漏问题检视方法" class="headerlink" title="内存泄漏问题检视方法"></a>内存泄漏问题检视方法</h1><p>检视内存泄漏问题，关键还是要养成良好的编码检视习惯。与内存泄漏三要素对应，需</p>
<p>要做到如下三点：</p>
<ol>
<li>在函数中看到有局部指针，就要警惕内存泄漏问题，养成进一步排查的习惯</li>
<li>分析对局部指针的赋值操作，是否属于前面所说的“两种堆内存获取方法”之一，如果是，就要分析函数返回的指针到底指向啥？是全局数据、静态数据还是堆内存？对于不熟悉的接口，要找到对应的接口文档或源代码分析；又或者看看代码中其它地方对该接口的引用，是否进行了内存释放；</li>
<li>如果确认对局部指针存在内存申请操作，就需要分析该内存的去向，是会被保存在全局变量吗？又或者会被作为函数返回值吗？如果都不是，就需要排查函数所有有”return“的地方，保证内存被正确释放。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%E4%B8%8EBCNF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%E4%B8%8EBCNF/" class="post-title-link" itemprop="url">数据库设计三大范式与BCNF</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-05-21 17:41:39 / Modified: 17:48:31" itemprop="dateCreated datePublished" datetime="2019-05-21T17:41:39+08:00">2019-05-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ol>
<li>实体（entity）：就是实际应用中要用数据描述的事物，一般是名词。</li>
<li>字段（fields）：就是一项数据，也就是我们平常所说的“列”。</li>
<li>记录（record）：一个实体的一个实例所特有的相关数据项的集合，也就是我们平常所说的“行”。</li>
<li>键（key）：可唯一标识一条记录的一个字段或字段集，有时翻译为“码”。</li>
<li><p>主键（primary key）：用于唯一标识一个表中的一条记录的键。每个主键应该具有下列特征：</p>
<ul>
<li>唯一的。</li>
<li>最小 的（尽量选择最少键的组合）。</li>
<li>非空。</li>
<li>不可更新的（不能随时更改）</li>
</ul>
</li>
<li><p>外键（foreign keys）：对连接父表和子表的相关记录的主键字段的复制。</p>
</li>
<li>依赖表（dependent table）：也称为弱实体（weak entity）是需要用父表标识的子表。</li>
<li>关联表（associative table）：是多对多关系中两个父表的子表。</li>
<li>实体完整性：每个表必须有一个有效的主 键。</li>
<li>参照完整性：没有不相匹配的外键值。</li>
</ol>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>函数依赖：<br>通俗描述：描述一个学生的关系，可以有学号(SNO),姓名(SNAME),系名(SDEPT)等几个属性。由于一个学号只对应一个学生，一个学生只在一个系学习。因此当学号确定之后，姓名和该学生所在系的值也就唯一被确定了，就像自变量x确定之后，相应的函数值f(x)也就唯一地被确定了一样，称SNO函数决定SNAME和SDEPT，或者说SNAME，SDEPT函数依赖于SNO，记为：SNO -&gt; SNAME， SNO -&gt; SDEPT.</p>
<p>严格定义：设R(U)是属性集U上的关系模式。X，Y是U的子集。若对于R(U)的任意一个可能的关系r,r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不相等，则称X函数确定Y或者Y函数依赖于X。记为X-&gt;Y。</p>
<p>（如果不知道“关系”、“属性集”等定义，自己看大学教材去。这里的定义摘自萨师煊&amp;王珊《数据库系统概论》第三版）</p>
<p>完全函数依赖：<br>在R(U)中，如果Y函数依赖于X,并且对于X的任何一个真子集X’，都有Y不函数依赖于X’， 则称Y对X完全函数依赖。否则称Y对X部分函数依赖。</p>
<p>举个例子就明白了。假设一个学生有几个属性</p>
<p>SNO 学号<br>SNAME 姓名<br>SDEPT 系<br>SAGE 年龄<br>CNO 班级号<br>G 成绩</p>
<p>对于(SNO,SNAME,SDEPT,SAGE,CNO,G)来说，G完全依赖于(SNO, CNO), 因为(SNO,CNO)可以决定G，而SNO和CNO都不能单独决定G。</p>
<p>而SAGE部分函数依赖于(SNO,CNO),因为(SNO,CNO)可以决定SAGE，而单独的SNO也可以决定SAGE。</p>
<p>传递函数依赖：<br>在R(U)中，如果X-&gt;Y, Y-&gt;Z, 则称Z对X传递函数依赖。</p>
<p>候选键：<br>(又称候选码，候选关键字,码 ，candidate key)：</p>
<p>设K是一个R(U)中的属性或属性集合(注意可以是属性集合，也即多个属性的组合)，若K完全函数确定U，则K为R的候选键(Candidate key);</p>
<p>通俗地说就是，能够确定全部属性的某个属性或某组属性，称为候选键。若候选键多于一个，则选定其中一个作为主键。</p>
<p>主属性：<br>包含在任何一个候选键中的属性，叫做主属性(Prime attribute),不包含在任何候选键中的属性称为非主属性或非键属性或非关键字段。</p>
<p>例子：<br>在(SNO, CNO, G)中，SNO和CNO这俩合起来就是一个候选键，因为每个元组只要确定了SNO和CNO，则其它所有属性都可以根据SNO和CNO来确定。而SNO和CNO就都是“主属性”，G是“非主属性”。由于此例中只有一个候选键，于是只能选择(SNO, CNO)作为主键。</p>
<p>在(SNO,SDEPT, SNAME)中，SNO是一个候选键，因为只要SNO确定了，其它所有属性也都确定了，如果保证没有重名的话，则SNAME也是一个候选键，于是可以选SNO或者SNAME之一作为候选键。如果不能保证没有重名，就不能把SNAME当成候选键，于是就只有SNO能够做主键。</p>
<p>范式：<br>第一范式：<br>指数据库表的每一列都是不可分割的基本数据项<br>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。</p>
<p>第二范式：<br>数据库表中不存在非关键字段对任一候选键的部分函数依赖，也即所有非关键字 段都完全依赖于任意一组候选关键字。</p>
<p>2NF的违例只会出现在候选键由超过一个字段构成的表中，因为对单关键字字段不存在部分依赖问题。</p>
<p>例子：(学号, 姓名, 年龄, 课程名称, 成绩, 学分)</p>
<p>候选键只有一个，就是(姓名，课程名称)，则主键就是(姓名，课程名称)</p>
<p>存在如下决定关系：</p>
<p>1：(学号, 课程名称) → (姓名, 年龄, 成绩, 学分)<br>2：(课程名称) → (学分)<br>3：(学号) → (姓名, 年龄)</p>
<p>其中，姓名、年龄、学分是部分依赖于主键的，而成绩是完全依赖于主键的，存在部分依赖关系，所以不满足第二范式。</p>
<p>这会造成如下问题</p>
<ol>
<li>数据冗余：<br>同一门课程由n个学生选修，”学分”就重复n-1次；同一个学生选修了m门课程，姓名和年龄就重复了m-1次。</li>
<li>更新异常：<br>若调整了某门课程的学分，数据表中所有行的”学分”值都要更新，否则会出现同一门课程学分不同的情况。</li>
<li>插入异常：<br>假设要开设一门新的课程，暂时还没有人选修。这样，由于还没有”学号”关键字，课程名称和学分也无法记录入数据 库。</li>
<li>删除异常：<br>假设一批学生已经完成课程的选修，这些选修记录就应该从数据库表中删除。但是，与此同 时，课程名称和学分信息也被删除了。很显然，这也会导致插入异常。</li>
</ol>
<p>问题就在于存在非主属性对主键的部分依赖</p>
<p>解决办法：把原表(学号, 姓名, 年龄, 课程名称, 成绩, 学分)分成三个表：</p>
<p>学生：Student(学号, 姓名, 年龄)；</p>
<p>课程：Course(课程名称, 学分)；</p>
<p>选课关 系：SelectCourse(学号, 课程名称, 成绩)。</p>
<p>第三范式:<br>在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式</p>
<p>出现传递依赖A-&gt;B-&gt;C，即主键A可以确定出某一非关键字段B，而B又可以确定出C，这意味着C依赖于一个非关键字段B。因此第三范式又可描述为：表中不存在可以确定其他非关键字的非键字段</p>
<p>例子：表：(学号, 姓名, 年龄, 所在学院, 学院地点, 学院电话)</p>
<p>该表中候选字段只有“学号”，于是“学号”做主键。由于主键是单一属性，所以不存在非主属性对主键的部分函数依赖的问题，所以必然满足第二范式。但是存在如下传递依赖</p>
<p>(学号) → (所在学院) → (学院地点, 学院电话)</p>
<p>学院地点和学院电话传递依赖于学号，而学院地点和学院电话都是非关键字段，即表中出现了“某一非关键字段可以确定出其它非关键字段”的情况，于是违反了第三范式。</p>
<p>解决办法：</p>
<p>把原表分成两个表：</p>
<p>学生：(学号, 姓名, 年龄, 所在学院)；</p>
<p>学院：(学院, 地点, 电话)。</p>
<p>BCNF：<br>BCNF意味着在关系模式中每一个决定因素都包含候选键，也就是说，只要属性或属性组A能够决定任何一个属性B，则A的子集中必须有候选键。BCNF范式排除了任何属性(不光是非主属性，2NF和3NF所限制的都是非主属性)对候选键的传递依赖与部分依赖。</p>
<p>例子：<br><img src="/img/Untitled picture_thumb_1.png" alt=""></p>
<p>例子二：</p>
<p>假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：</p>
<p>(仓库ID, 存储物品ID) →(管理员ID, 数量)</p>
<p>(管理员ID, 存储物品ID) → (仓库ID, 数量)</p>
<p>所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：</p>
<p>(仓库ID) → (管理员ID)</p>
<p>(管理员ID) → (仓库ID)</p>
<p>仓库I是决定因素，但仓库ID不包含候选键(candidate key,也就是候选码，简称码)。</p>
<p>同样的，管理员ID也是决定因素，但不包含候选键。</p>
<p>所以该表不满足BCNF。</p>
<p>3NF和BCNF是在函数依赖的条件下对模式分解所能达到的最大程度。一个模式中的关系模式如果都属于BCNF，那么在函数依赖范围内，它已经实现了彻底的分离，已消除了插入和删除的异常。3NF的“不彻底”性表现在可能存在主属性对键的部分依赖和传递依赖。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/14/%E6%8A%8A%E6%8F%A1linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/14/%E6%8A%8A%E6%8F%A1linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/" class="post-title-link" itemprop="url">把握Linux内核设计思想</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-14 10:46:53" itemprop="dateCreated datePublished" datetime="2019-05-14T10:46:53+08:00">2019-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-02 11:06:13" itemprop="dateModified" datetime="2022-01-02T11:06:13+08:00">2022-01-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>一般情况下进程不能访问内核所占内存空间也不能调用内核函数。为了和用户空间上运行的进程进行交互，内核提供了一组接口。透过该接口，应用程序可以访问硬件设备和其他操作系统资源。这组接口在应用程序和内核之间扮演了使者的角色，应用程序发送各种请求，而内核负责满足这些请求(或者让应用程序暂时搁置)。系统调用就是用户空间应用程序和内核提供的服务之间的一个接口。</p>
<p>系统调用在用户空间进程和硬件设备之间添加了一个中间层，其为用户空间提供了一种统一的硬件的抽象接口，保证了系统的稳定和安全，使用户程序具有可移植性。例如<code>fork()</code>，<code>read()</code>，<code>write()</code>等用户程序可以使用的函数都是系统调用。</p>
<p>用户空间的程序无法直接执行内核代码。它们不能直接调用内核空间中的函数，因为内核驻留在受保护的地址空间上。所以，应用程序应该以某种方式通知系统，告诉内核自己需要执行一个系统调用，希望系统切换到内核态，这样内核就可以代表应用程序来执行该系统调用了。那么应用程序应该以何种方式通知系统，系统如何切换到内核态？</p>
<p>其实这种改变是通过软中断来实现。首先，用户程序为系统调用设置参数。其中一个参数是系统调用编号。参数设置完成后，程序执行“系统调用”指令。x86系统上的软中断由<code>int</code>产生。这个指令会导致一个异常：产生一个事件，这个事件会致使处理器切换到内核态并执行0x80号异常处理程序。此时的异常处理程序实际上就是系统调用处理程序，该处理程序的名字为<code>system_call</code>，它与硬件体系结构紧密相关。对于x86-32<code>系统来说，该处理程序位于</code>arch/x86/kernel/entry_32.S`文件中，代码为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"> <span class="meta"># system call handler stub</span></span><br><span class="line">ENTRY(system_call)</span><br><span class="line"> RING0_INT_FRAME <span class="meta"># can<span class="string">&#x27;t unwind into user space anyway</span></span></span><br><span class="line"><span class="string"><span class="meta"> pushl %eax # save orig_eax</span></span></span><br><span class="line"><span class="string"><span class="meta"> CFI_ADJUST_CFA_OFFSET 4</span></span></span><br><span class="line"><span class="string"><span class="meta"> SAVE_ALL</span></span></span><br><span class="line"><span class="string"><span class="meta"> GET_THREAD_INFO(%ebp)</span></span></span><br><span class="line"><span class="string"><span class="meta">     # system call tracing in operation / emulation</span></span></span><br><span class="line"><span class="string"><span class="meta"> testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%ebp)</span></span></span><br><span class="line"><span class="string"><span class="meta"> jnz syscall_trace_entry</span></span></span><br><span class="line"><span class="string"><span class="meta"> cmpl $(nr_syscalls), %eax</span></span></span><br><span class="line"><span class="string"><span class="meta"> jae syscall_badsys</span></span></span><br><span class="line"><span class="string"><span class="meta">syscall_call:</span></span></span><br><span class="line"><span class="string"><span class="meta"> call *sys_call_table(,%eax,4) //此处执行相应的系统调用</span></span></span><br><span class="line"><span class="string"><span class="meta"> movl %eax,PT_EAX(%esp) # store the return value</span></span></span><br><span class="line"><span class="string"><span class="meta">syscall_exit:</span></span></span><br><span class="line"><span class="string"><span class="meta"> LOCKDEP_SYS_EXIT</span></span></span><br><span class="line"><span class="string"><span class="meta"> DISABLE_INTERRUPTS(CLBR_ANY) # make sure we don&#x27;</span>t miss an interrupt</span></span><br><span class="line">     <span class="meta"># setting need_resched or sigpending</span></span><br><span class="line">     <span class="meta"># between sampling and the iret</span></span><br><span class="line"> TRACE_IRQS_OFF</span><br><span class="line"> movl <span class="title function_">TI_flags</span><span class="params">(%ebp)</span>, %ecx</span><br><span class="line"> testl $_TIF_ALLWORK_MASK, %ecx <span class="meta"># current-&gt;work</span></span><br><span class="line"> jne syscall_exit_work</span><br><span class="line"> ......</span><br></pre></td></tr></table></figure><br>在Linux中，每个系统调用被赋予一个系统调用号。这样，通过这个独一无二的号就可以关联系统调用。当用户空间的进程执行一个系统调用的时候，这个系统调用号就被用来指明到底是要执行哪个系统调用。进程不会提及系统调用的名称。系统调用号定义文件以及形式如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cat ./arch/x86/include/<span class="keyword">asm</span>/unistd.h</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __KERNEL__                                                                                                                      </span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> <span class="string">&quot;unistd_32.h&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> <span class="string">&quot;unistd_64.h&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __i386__</span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> <span class="string">&quot;unistd_32.h&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> <span class="string">&quot;unistd_64.h&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat arch/x86/include/asm/unistd_32.h</span></span><br><span class="line"><span class="comment">#ifndef _ASM_X86_UNISTD_32_H</span></span><br><span class="line"><span class="comment">#define _ASM_X86_UNISTD_32_H</span></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * This file contains the system call numbers.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="comment">#define __NR_restart_syscall      0</span></span><br><span class="line"><span class="comment">#define __NR_exit                 1</span></span><br><span class="line"><span class="comment">#define __NR_fork                 2</span></span><br><span class="line"><span class="comment">#define __NR_read                 3</span></span><br><span class="line"><span class="comment">#define __NR_write                4</span></span><br><span class="line"><span class="comment">#define __NR_open                 5</span></span><br><span class="line"><span class="comment">#define __NR_close                6</span></span><br><span class="line"><span class="comment">#define __NR_waitpid              7</span></span><br><span class="line"><span class="comment">#define __NR_creat                8</span></span><br><span class="line"><span class="comment">#define __NR_link                 9</span></span><br><span class="line"><span class="comment">#define __NR_unlink              10</span></span><br><span class="line"><span class="comment">#define __NR_execve              11</span></span><br><span class="line"><span class="comment">#define __NR_chdir               12</span></span><br><span class="line"><span class="comment">#define __NR_time                13</span></span><br><span class="line"><span class="comment">#define __NR_mknod               14</span></span><br><span class="line"><span class="comment">#define __NR_chmod               15</span></span><br><span class="line"><span class="comment">#define __NR_lchown              16</span></span><br><span class="line"><span class="comment">#define __NR_break               17</span></span><br><span class="line"><span class="comment">#define __NR_oldstat             18</span></span><br><span class="line"><span class="comment">#define __NR_lseek               19</span></span><br><span class="line"><span class="comment">#define __NR_getpid              20</span></span><br><span class="line"><span class="comment">#define __NR_mount               21</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>系统调用号相当关键，一旦分配就不能再有任何变更，否则编译好的应用程序就会崩溃。Linux有一个“未实现”系统调用<code>sys_ni_syscall()</code>，它除了返回一<code>ENOSYS</code>外不做任何其他工作，这个错误号就是专门针对无效的系统调用而设的。</p>
<p>因为所有的系统调用陷入内核的方式都一样，所以仅仅是陷入内核空间是不够的。因此必须把系统调用号一并传给内核。在x86上，系统调用号是通过<code>eax</code>寄存器传递给内核的。在陷人内核之前，用户空间就把相应系统调用所对应的号放入<code>eax</code>中了。这样系统调用处理程序一旦运行，就可以从<code>eax</code>中得到数据。其他体系结构上的实现也都类似。</p>
<p>内核记录了系统调用表中的所有已注册过的系统调用的列表，存储在<code>sys_call_table</code>中。它与体系结构有关，32位x86一般定义在<code>arch/x86/kernel/syscall_table_32.s</code>文件中。这个表中为每一个有效的系统调用指定了惟一的系统调用号。<code>sys_call_table</code>是一张由指向实现各种系统调用的内核函数的函数指针组成的表。<code>syscall_table_32.s</code>文件如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(sys_call_table)</span><br><span class="line"> .<span class="type">long</span> sys_restart_syscall <span class="comment">/* 0 - old &quot;setup()&quot; system call, used for restarting */</span></span><br><span class="line"> .<span class="type">long</span> sys_exit</span><br><span class="line"> .<span class="type">long</span> ptregs_fork</span><br><span class="line"> .<span class="type">long</span> sys_read</span><br><span class="line"> .<span class="type">long</span> sys_write</span><br><span class="line"> .<span class="type">long</span> sys_open <span class="comment">/* 5 */</span></span><br><span class="line"> .<span class="type">long</span> sys_close</span><br><span class="line"> .<span class="type">long</span> sys_waitpid</span><br><span class="line"> .<span class="type">long</span> sys_creat</span><br><span class="line"> .<span class="type">long</span> sys_link</span><br><span class="line"> .<span class="type">long</span> sys_unlink <span class="comment">/* 10 */</span></span><br><span class="line"> .<span class="type">long</span> ptregs_execve</span><br><span class="line"> ......</span><br><span class="line"> .<span class="type">long</span> sys_timerfd_settime <span class="comment">/* 325 */</span></span><br><span class="line"> .<span class="type">long</span> sys_timerfd_gettime</span><br><span class="line"> .<span class="type">long</span> sys_signalfd4</span><br><span class="line"> .<span class="type">long</span> sys_eventfd2</span><br><span class="line"> .<span class="type">long</span> sys_epoll_create1</span><br><span class="line"> .<span class="type">long</span> sys_dup3 <span class="comment">/* 330 */</span></span><br><span class="line"> .<span class="type">long</span> sys_pipe2</span><br><span class="line"> .<span class="type">long</span> sys_inotify_init1</span><br><span class="line"> .<span class="type">long</span> sys_preadv</span><br><span class="line"> .<span class="type">long</span> sys_pwritev</span><br><span class="line"> .<span class="type">long</span> sys_rt_tgsigqueueinfo <span class="comment">/* 335 */</span></span><br><span class="line"> .<span class="type">long</span> sys_perf_event_open</span><br></pre></td></tr></table></figure></p>
<p><code>system_call()</code>函数通过将给定的系统调用号与<code>NR_syscalls</code>做比较来检查其有效性。如果它大于或者等于<code>NR syscalls</code>，该函数就返回一<code>ENOSYS</code>。否则，就执行相应的系统调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call *<span class="title function_">sys_call_table</span><span class="params">(，%eax, <span class="number">4</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>由于系统调用表中的表项是以32位(4字节)类型存放的，所以内核需要将给定的系统调用号乘以4，然后用所得的结果在该表中查询其位置。</p>
<p>除了系统调用号以外，大部分系统调用都还需要一些外部的参数输入。所以，在发生异常的时候，应该把这些参数从用户空间传给内核。最简单的办法就是像传递系统调用号一样把这些参数也存放在寄存器里。在x86系统上，<code>ebx</code>，<code>ecx</code>，<code>edx</code>，<code>esi</code>和<code>edi</code>按照顺序存放前五个参数。需要六个或六个以上参数的情况不多见，此时，应该用一个单独的寄存器存放指向所有这些参数在用户空间地址的指针。给用户空间的返回值也通过寄存器传递。在x86系统上，它存放在<code>eax</code>寄存器中。</p>
<p>下面我们看看用中断的方式如何完成系统调用功能：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span>   pid;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">            <span class="string">&quot;mov $0, %%ebx\n\t&quot;</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;mov $20, %%eax\n\t&quot;</span>    <span class="comment">//把系统调用号20放入`eax`寄存器中，20对应于`SYS_getpid()系统调用</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;int $0x80\n\t&quot;</span>    <span class="comment">//0x80中断</span></span></span><br><span class="line"><span class="params">            <span class="string">&quot;mov %%eax, %0\n\t&quot;</span>    <span class="comment">//将执行结果存放在`pid`变量中</span></span></span><br><span class="line"><span class="params">            :<span class="string">&quot;=m&quot;</span>(pid)</span></span><br><span class="line"><span class="params">            )</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int PID: %d\n&quot;</span>, pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;api PID: %d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>此处没有传递参数，因为<code>getpid</code>不需要参数。本实例执行结果为：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./target_bin</span><br><span class="line">int PID: 4911</span><br><span class="line">api PID: 4911</span><br></pre></td></tr></table></figure></p>
<p>一般情况下，应用程序通过在用户空间实现的应用编程接口（API）而不是系统调用来编程。API是一个函数定义，说明了如何获得一个给定的服务，比如<code>read()</code>、<code>malloc()</code>、<code>free()</code>、<code>abs()</code>等。它有可能和系统调用形式上一致，比如<code>read()</code>接口就和<code>read</code>系统调用对应，但这种对应并非一一对应，往往会出现几种不同的API内部用到统一个系统调用，比如<code>malloc()</code>、<code>free()</code>内部利用<code>brk()</code>系统调用来扩大或缩小进程的堆；或一个API利用了好几个系统调用组合完成服务。更有些API甚至不需要任何系统调用——因为它不必需要内核服务，如计算整数绝对值的<code>abs()</code>接口。</p>
<p>Linux的用户编程接口遵循了在Unix世界中最流行的应用编程界面标准——POSIX标准，这套标准定义了一系列API。在Linux中（Unix也如此）这些API主要是通过C库（libc）实现的，它除了定义的一些标准的C函数外，一个很重要的任务就是提供了一套封装例程将系统调用在用户空间包装后供用户编程使用。不过封装并非必须的，如果你愿意直接调用，内核也提供了一个<code>syscall()</code>函数来实现调用。如下示例为使用C库调用和直接调用分别来获取当前进程ID：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span>     pid, pidt;</span><br><span class="line">    pid = getpid();</span><br><span class="line">    pidt = syscall(SYS_getpid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getpid: %d\n&quot;</span>, pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SYS_getpid: %d\n&quot;</span>, pidt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>系统调用在内核有一个实现函数，以<code>getpid</code>为例，其在内核实现为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_getpid - return the thread group id of the current process</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note, despite the name, this returns the tgid not the pid.  The tgid and</span></span><br><span class="line"><span class="comment"> * the pid are identical unless CLONE_THREAD was specified on clone() in</span></span><br><span class="line"><span class="comment"> * which case the tgid is the same in all threads of the same group.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is SMP safe as current-&gt;tgid does not change.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE0(getpid)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> task_tgid_vnr(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中<code>SYSCALL_DEFINE0</code>为一个宏，它定义一个无参数（尾部数字代表参数个数）的系统调用，展开后代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> current-&gt;tpid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中<code>asmlinkage</code>是一个编译指令，通知编译器仅从栈中提取该函数参数，所有系统调用都需要这个限定词。系统调用<code>getpid()</code>在内核中被定义成<code>sys_getpid()</code>，这是Linux所有系统调用都应该遵守的命名规则。</p>
<p>Linux中实现系统调用利用了0x86体系结构中的软件中断，也就是调用<code>int $0x80</code>汇编指令，这条汇编指令将产生向量为128的编程异常，此时处理器切换到内核态并执行0x80号异常处理程序。此时的异常处理程序实际上就是系统调用处理程序，该处理程序的名字为<code>system_call()</code>，对于x86-32系统来说，该处理程序位于<code>arch/x86/kernel/entry_32.S</code>文件中，使用汇编语言编写。那么所有的系统调用都会转到这里。在执行<code>int 0x80</code>前，系统调用号被装入<code>eax</code>寄存器（相应参数也会传递到其它寄存器中），这个系统调用号被用来指明到底是要执行哪个系统调用，这样系统调用处理程序一旦运行，就从<code>eax</code>中得到系统调用号，然后根据系统调用号在系统调用表中寻找相应服务例程（例如<code>sys_getpid()</code>函数）。当服务例程结束时，<code>system_call()</code>从<code>eax</code>获得系统调用的返回值，并把这个返回值存放在曾保存用户态<code>eax</code>寄存器栈单元的那个位置上，最后该函数再负责切换到用户空间，使用户进程继续执行。</p>
<h1 id="硬中断及中断处理"><a href="#硬中断及中断处理" class="headerlink" title="硬中断及中断处理"></a>硬中断及中断处理</h1><p>操作系统负责管理硬件设备，为了使系统和硬件设备的协同工作不降低机器性能，系统和硬件的通信使用中断的机制，也就是让硬件在需要的时候向内核发出信号，这样使得内核不用去轮询设备而导致做很多无用功。</p>
<p>中断使得硬件可以发出通知给处理器，硬件设备生成中断的时候并不考虑与处理器的时钟同步，中断可以随时产生。也就是说，内核随时可能因为新到来的中断而被打断。当接收到一个中断后，中断控制器会给处理器发送一个电信号，处理器检测到该信号便中断自己当前工作而处理中断。</p>
<p>在响应一个中断时，内核会执行一个函数，该函数叫做中断处理程序或中断服务例程（ISR）。中断处理程序运行与中断上下文，中断上下文中执行的代码不可阻塞，应该快速执行，这样才能保证尽快恢复被中断的代码的执行。中断处理程序是管理硬件驱动的驱动程序的组成部分，如果设备使用中断，那么相应的驱动程序就注册一个中断处理程序。</p>
<p>在驱动程序中，通常使用<code>request_irq()</code>来注册中断处理程序。该函数在文件<code>&lt;include/linux/interrupt.h&gt;</code>中声明：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span>;</span><br></pre></td></tr></table></figure><br>第一个参数为要分配的中断号；第二个参数为指向中断处理程序的指针；第三个参数为中断处理标志。该函数实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">                         <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">                         <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * handle_IRQ_event() always ignores IRQF_DISABLED except for</span></span><br><span class="line"><span class="comment">     * the _first_ irqaction (sigh).  That can cause oopsing, but</span></span><br><span class="line"><span class="comment">     * the behavior is classified as &quot;will not fix&quot; so we need to</span></span><br><span class="line"><span class="comment">     * start nudging drivers away from using that idiom.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((irqflags &amp; (IRQF_SHARED|IRQF_DISABLED)) == (IRQF_SHARED|IRQF_DISABLED)) &#123;</span><br><span class="line">        pr_warning(<span class="string">&quot;IRQ %d/%s: IRQF_DISABLED is not guaranteed on shared IRQs\n&quot;</span>,</span><br><span class="line">                irq, devname);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Lockdep wants atomic interrupt handlers:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    irqflags |= IRQF_DISABLED;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Sanity-check: shared interrupts must pass in a real dev-ID,</span></span><br><span class="line"><span class="comment">     * otherwise we&#x27;ll have trouble later trying to figure out</span></span><br><span class="line"><span class="comment">     * which interrupt is which (messes up the interrupt freeing</span></span><br><span class="line"><span class="comment">     * logic etc).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    desc = irq_to_desc(irq);</span><br><span class="line">    <span class="keyword">if</span> (!desc)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (desc-&gt;status &amp; IRQ_NOREQUEST)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!thread_fn)</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        handler = irq_default_primary_handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分配一个irqaction</span></span><br><span class="line">    action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!action)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    action-&gt;handler = handler;</span><br><span class="line">    action-&gt;thread_fn = thread_fn;</span><br><span class="line">    action-&gt;flags = irqflags;</span><br><span class="line">    action-&gt;name = devname;</span><br><span class="line">    action-&gt;dev_id = dev_id;</span><br><span class="line">    chip_bus_lock(irq, desc);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将创建并初始化完在的action加入desc</span></span><br><span class="line">    retval = __setup_irq(irq, desc, action);</span><br><span class="line">    chip_bus_sync_unlock(irq, desc);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        kfree(action);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SHIRQ</span></span><br><span class="line">    <span class="keyword">if</span> (irqflags &amp; IRQF_SHARED) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * It&#x27;s a shared IRQ -- the driver ought to be prepared for it</span></span><br><span class="line"><span class="comment">         * to happen immediately, so let&#x27;s make sure....</span></span><br><span class="line"><span class="comment">         * We disable the irq to make sure that a &#x27;real&#x27; IRQ doesn&#x27;t</span></span><br><span class="line"><span class="comment">         * run in parallel with our fake.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">        disable_irq(irq);</span><br><span class="line">        local_irq_save(flags);</span><br><span class="line">        handler(irq, dev_id);</span><br><span class="line">        local_irq_restore(flags);</span><br><span class="line">        enable_irq(irq);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面看一下中断处理程序的实例，以<code>rtc</code>驱动程序为例，代码位于<code>&lt;drivers/char/rtc.c&gt;</code>中。当<code>RTC</code>驱动装载时，<code>rtc_init()</code>函数会被调用来初始化驱动程序，包括注册中断处理函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * XXX Interrupt pin #7 in Espresso is shared between RTC and</span></span><br><span class="line"><span class="comment"> * PCI Slot 2 INTA# (and some INTx# in Slot 1).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (request_irq(rtc_irq, rtc_interrupt, IRQF_SHARED, <span class="string">&quot;rtc&quot;</span>,</span><br><span class="line">        (<span class="type">void</span> *)&amp;rtc_port)) &#123;</span><br><span class="line">    rtc_has_irq = <span class="number">0</span>;</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;rtc: cannot register IRQ %d\n&quot;</span>, rtc_irq);</span><br><span class="line">    <span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>处理程序函数<code>rtc_interrupt()</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  A very tiny interrupt handler. It runs with IRQF_DISABLED set,</span></span><br><span class="line"><span class="comment"> *  but there is possibility of conflicting with the set_rtc_mmss()</span></span><br><span class="line"><span class="comment"> *  call (the rtc irq and the timer irq can easily run at the same</span></span><br><span class="line"><span class="comment"> *  time in two different CPUs). So we need to serialize</span></span><br><span class="line"><span class="comment"> *  accesses to the chip with the rtc_lock spinlock that each</span></span><br><span class="line"><span class="comment"> *  architecture should implement in the timer code.</span></span><br><span class="line"><span class="comment"> *  (See ./arch/XXXX/kernel/time.c for the set_rtc_mmss() function.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">rtc_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  Can be an alarm interrupt, update complete interrupt,</span></span><br><span class="line"><span class="comment">     *  or a periodic interrupt. We store the status in the</span></span><br><span class="line"><span class="comment">     *  low byte and the number of interrupts received since</span></span><br><span class="line"><span class="comment">     *  the last read in the remainder of rtc_irq_data.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    spin_lock(&amp;rtc_lock);    <span class="comment">//保证`rtc_irq_data`不被`SMP`机器上其他处理器同时访问</span></span><br><span class="line">    rtc_irq_data += <span class="number">0x100</span>;</span><br><span class="line">    rtc_irq_data &amp;= ~<span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">if</span> (is_hpet_enabled()) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * In this case it is HPET RTC interrupt handler</span></span><br><span class="line"><span class="comment">         * calling us, with the interrupt information</span></span><br><span class="line"><span class="comment">         * passed as arg1, instead of irq.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rtc_irq_data |= (<span class="type">unsigned</span> <span class="type">long</span>)irq &amp; <span class="number">0xF0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rtc_irq_data |= (CMOS_READ(RTC_INTR_FLAGS) &amp; <span class="number">0xF0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rtc_status &amp; RTC_TIMER_ON)</span><br><span class="line">        mod_timer(&amp;rtc_irq_timer, jiffies + HZ/rtc_freq + <span class="number">2</span>*HZ/<span class="number">100</span>);</span><br><span class="line">    spin_unlock(&amp;rtc_lock);</span><br><span class="line">    <span class="comment">/* Now do the rest of the actions */</span></span><br><span class="line">    spin_lock(&amp;rtc_task_lock);    <span class="comment">//避免`rtc_callback`出现系统情况，RTC`驱动允许注册一个回调函数在每个`RTC`中断到来时执行。</span></span><br><span class="line">    <span class="keyword">if</span> (rtc_callback)</span><br><span class="line">        rtc_callback-&gt;func(rtc_callback-&gt;private_data);</span><br><span class="line">    spin_unlock(&amp;rtc_task_lock);</span><br><span class="line">    wake_up_interruptible(&amp;rtc_wait);</span><br><span class="line">    kill_fasync(&amp;rtc_async_queue, SIGIO, POLL_IN);</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在内核中，中断的旅程开始于预定义入口点，这类似于系统调用。对于每条中断线，处理器都会跳到对应的一个唯一的位置。这样，内核就可以知道所接收中断的<code>IRQ</code>号了。初始入口点只是在栈中保存这个号，并存放当前寄存器的值(这些值属于被中断的任务)；然后，内核调用函数<code>do_IRQ()</code>。从这里开始，大多数中断处理代码是用C写的。<code>do_IRQ()</code>的声明如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">do_IRQ</span><span class="params">(<span class="keyword">struct</span> pt_regs regs)</span></span><br></pre></td></tr></table></figure><br>因为C的调用惯例是要把函数参数放在栈的顶部，因此<code>pt_regs</code>结构包含原始寄存器的值，这些值是以前在汇编入口例程中保存在栈上的。中断的值也会得以保存，所以，<code>do_IRQ()</code>可以将它提取出来，X86的代码为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int irq = regs.orig_eax &amp; 0xff</span><br></pre></td></tr></table></figure></p>
<p>计算出中断号后，<code>do_IRQ()</code>对所接收的中断进行应答，禁止这条线上的中断传递。在普通的PC机器上，这些操作是由<code>mask_and_ack_8259A()</code>来完成的，该函数由<code>do_IRQ()</code>调用。接下来，<code>do_IRQ()</code>需要确保在这条中断线上有一个有效的处理程序，而且这个程序已经启动但是当前没有执行。如果这样的话，<code>do_IRQ()</code>就调用<code>handle_IRQ_event()</code>来运行为这条中断线所安装的中断处理程序，函数位于<code>&lt;kernel/irq/handle.c&gt;</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * handle_IRQ_event - irq action chain handler</span></span><br><span class="line"><span class="comment"> * @irq:    the interrupt number</span></span><br><span class="line"><span class="comment"> * @action: the interrupt action chain for this irq</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> * Handles the action chain of an irq event</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">handle_IRQ_event</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="keyword">struct</span> irqaction *action)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">irqreturn_t</span> ret, retval = IRQ_NONE;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//如果没有设置`IRQF_DISABLED，将CPU中断打开，应该尽量避免中断关闭情况，本地中断关闭情况下会导致中断丢失。</span></span><br><span class="line">    <span class="keyword">if</span> (!(action-&gt;flags &amp; IRQF_DISABLED))</span><br><span class="line">        local_irq_enable_in_hardirq();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">do</span> &#123;    <span class="comment">//遍历运行中断处理程序</span></span><br><span class="line">        trace_irq_handler_entry(irq, action);</span><br><span class="line">        ret = action-&gt;handler(irq, action-&gt;dev_id);</span><br><span class="line">        trace_irq_handler_exit(irq, action, ret);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">        <span class="keyword">case</span> IRQ_WAKE_THREAD:</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Set result to handled so the spurious check</span></span><br><span class="line"><span class="comment">             * does not trigger.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ret = IRQ_HANDLED;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Catch drivers which return WAKE_THREAD but</span></span><br><span class="line"><span class="comment">             * did not set up a thread function</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (unlikely(!action-&gt;thread_fn)) &#123;</span><br><span class="line">                warn_no_thread(irq, action);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Wake up the handler thread for this</span></span><br><span class="line"><span class="comment">             * action. In case the thread crashed and was</span></span><br><span class="line"><span class="comment">             * killed we just pretend that we handled the</span></span><br><span class="line"><span class="comment">             * interrupt. The hardirq handler above has</span></span><br><span class="line"><span class="comment">             * disabled the device interrupt, so no irq</span></span><br><span class="line"><span class="comment">             * storm is lurking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (likely(!test_bit(IRQTF_DIED,</span><br><span class="line">                         &amp;action-&gt;thread_flags))) &#123;</span><br><span class="line">                set_bit(IRQTF_RUNTHREAD, &amp;action-&gt;thread_flags);</span><br><span class="line">                wake_up_process(action-&gt;thread);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Fall through to add to randomness */</span></span><br><span class="line">        <span class="keyword">case</span> IRQ_HANDLED:</span><br><span class="line">            status |= action-&gt;flags;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        retval |= ret;</span><br><span class="line">        action = action-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (action);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (status &amp; IRQF_SAMPLE_RANDOM)</span><br><span class="line">        add_interrupt_randomness(irq);</span><br><span class="line">    local_irq_disable();<span class="comment">//关中断</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>前面说到中断应该尽快执行完，以保证被中断代码可以尽快的恢复执行。但事实上中断通常有很多工作要做，包括应答、重设硬件、数据拷贝、处理请求、发送请求等。为了求得平衡，内核把中断处理工作分成两半，中断处理程序是上半部——接收到中断就开始执行。能够稍后完成的工作推迟到下半部操作，下半部在合适的时机被开中段执行。例如网卡收到数据包时立即发出中断，内核执行网卡已注册的中断处理程序，此处工作就是通知硬件拷贝最新的网络数据包到内存，然后将控制权交换给系统之前被中断的任务，其他的如处理和操作数据包等任务被放到随后的下半部中去执行。下一节我们将了解中断处理的下半部。</p>
<h1 id="下半部机制之软中断"><a href="#下半部机制之软中断" class="headerlink" title="下半部机制之软中断"></a>下半部机制之软中断</h1><p>中断处理程序以异步方式执行，其会打断其他重要代码，其运行时该中断同级的其他中断会被屏蔽，并且当前处理器上所有其他中断都有可能会被屏蔽掉，还有中断处理程序不能阻塞，所以中断处理需要尽快结束。由于中断处理程序的这些缺陷，导致了中断处理程序只是整个硬件中断处理流程的一部分，对于那些对时间要求不高的任务，留给中断处理流程的另外一部分，也就是本节要讲的中断处理流程的下半部。</p>
<p>那哪些工作由中断处理程序完成，哪些工作留给下半部来执行呢？其实上半部和下半部的工作划分不存在某种严格限制，这主要取决于驱动程序开发者自己的判断，一般最好能将中断处理程序执行时间缩短到最小。中断处理程序几乎都需要通过操作硬件对中断的到达进行确认，有时还会做对时间非常敏感的工作（如拷贝数据），其余的工作基本上留给下半部来处理，下半部就是执行与中断处理密切相关但中断处理程序本身不执行的工作。一般对时间非常敏感、和硬件相关、要保证不被其它中断(特别是相同的中断)打断的这些任务放在中断处理程序中执行，其他任务考虑放在下半部执行。</p>
<p>那下半部什么时候执行呢？下半部不需要指定明确执行时间，只要把任务推迟一点，让它们在系统不太忙且中断恢复后执行就可以了，而且执行期间可以相应所有中断。</p>
<p>上半部只能通过中断处理程序实现，而下半部可以有多种机制来实现，在2.6.32版本中，有三种不同形式的下半部实现机制：软中断、tasklet、工作队列。下面来看一下这三种下半部的实现。</p>
<p>软中断<br>在<code>start_kernerl()</code>函数中，系统初始化软中断。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> __init <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> * command_line;</span><br><span class="line">    <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">kernel_param</span> __<span class="title">start___param</span>[], __<span class="title">stop___param</span>[];</span></span><br><span class="line"> </span><br><span class="line">    smp_setup_processor_id();</span><br><span class="line">......</span><br><span class="line">    softirq_init();<span class="comment">//初始化软中断</span></span><br><span class="line">......</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Do the rest non-__init&#x27;ed, we&#x27;re now alive */</span></span><br><span class="line">    rest_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在<code>softirq_init()</code>中会注册两个常用类型的软中断，具体代码如下（位于<code>kernel/softirq.c</code>）:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">softirq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cpu;</span><br><span class="line"> </span><br><span class="line">    for_each_possible_cpu(cpu) &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">        per_cpu(tasklet_vec, cpu).tail =</span><br><span class="line">            &amp;per_cpu(tasklet_vec, cpu).head;</span><br><span class="line">        per_cpu(tasklet_hi_vec, cpu).tail =</span><br><span class="line">            &amp;per_cpu(tasklet_hi_vec, cpu).head;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_SOFTIRQS; i++)</span><br><span class="line">            INIT_LIST_HEAD(&amp;per_cpu(softirq_work_list[i], cpu));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    register_hotcpu_notifier(&amp;remote_softirq_cpu_notifier);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//此处注册两个软中断</span></span><br><span class="line">    open_softirq(TASKLET_SOFTIRQ, tasklet_action);     </span><br><span class="line">    open_softirq(HI_SOFTIRQ, tasklet_hi_action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注册函数<code>open_softirq()</code>参数含义:</p>
<ul>
<li><code>nr</code>：软中断类型</li>
<li><code>action</code>：软中断处理函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span></span><br><span class="line">&#123;</span><br><span class="line">    softirq_vec[nr].action = action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>softirq_action</code>结构表示软中断，定义在<code>&lt;include/linux/interrupt.h&gt;</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span>    (*action)(<span class="keyword">struct</span> softirq_action *);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>文件<code>&lt;kernel/softirq.c&gt;</code>中定义了32个该结构体的数组：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> <span class="title">softirq_vec</span>[<span class="title">NR_SOFTIRQS</span>] __<span class="title">cacheline_aligned_in_smp</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>每注册一个软中断都会占该数组一个位置，因此系统中最多有32个软中断。从上面的代码中，我们可以看到<code>open_softirq()</code>中。其实就是对<code>softirq_vec</code>数组的<code>nr</code>项赋值。<code>softirq_vec</code>是一个32元素的数组，实际上Linux内核只使用了几项：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* PLEASE, avoid to allocate new softirqs, if you need not _really_ high</span></span><br><span class="line"><span class="comment">   frequency threaded job scheduling. For almost all the purposes</span></span><br><span class="line"><span class="comment">   tasklets are more than enough. F.e. all serial device BHs et</span></span><br><span class="line"><span class="comment">   al. should be converted to tasklets, not to softirqs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">    TIMER_SOFTIRQ,</span><br><span class="line">    NET_TX_SOFTIRQ,</span><br><span class="line">    NET_RX_SOFTIRQ,</span><br><span class="line">    BLOCK_SOFTIRQ,</span><br><span class="line">    BLOCK_IOPOLL_SOFTIRQ,</span><br><span class="line">    TASKLET_SOFTIRQ,</span><br><span class="line">    SCHED_SOFTIRQ,</span><br><span class="line">    HRTIMER_SOFTIRQ,</span><br><span class="line">    RCU_SOFTIRQ,    <span class="comment">/* Preferable RCU should always be the last softirq */</span></span><br><span class="line"> </span><br><span class="line">    NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>那么软中断注册完成之后，什么时候触发软中断处理函数执行呢？通常情况下，软中断会在中断处理程序返回前标记它，使其在稍后合适的时候被执行。在下列地方，待处理的软中断会被检查和执行：</p>
<ol>
<li>处理完一个硬件中断以后；</li>
<li>在<code>ksoftirqd</code>内核线程中；</li>
<li>在那些显示检查和执行待处理的软中断的代码中，如网络子系统中。</li>
</ol>
<p>无论如何，软中断会在<code>do_softirq()</code>（位于<code>&lt;kernel/softirq.c&gt;</code>中）中执行，如果有待处理的软中断，<code>do_softirq</code>会循环遍历每一个，调用他们的软中断处理程序。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> <span class="title function_">do_softirq</span><span class="params">(<span class="type">void</span>)</span> &#123;     </span><br><span class="line">	__u32 pending;     </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;     </span><br><span class="line">	<span class="comment">//如果在硬件中断环境中就退出，软中断不可以在硬件中断上下文或者是在软中断环境中使用，使用`in_interrupt()来防止软中断嵌套，和抢占硬中断环境。     </span></span><br><span class="line">	<span class="keyword">if</span> (in_interrupt())         </span><br><span class="line">		<span class="keyword">return</span>;     <span class="comment">//禁止本地中断     </span></span><br><span class="line">	local_irq_save(flags);     </span><br><span class="line">	pending = local_softirq_pending();</span><br><span class="line">    <span class="comment">//如果有软中断要处理，则进入__do_softirq()</span></span><br><span class="line">    <span class="keyword">if</span> (pending)         </span><br><span class="line">    	__do_softirq();     </span><br><span class="line">    local_irq_restore(flags);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面看一下<code>__do_softirq()</code>的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> __do_softirq(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> *<span class="title">h</span>;</span></span><br><span class="line">    __u32 pending;   </span><br><span class="line">    <span class="type">int</span> max_restart = MAX_SOFTIRQ_RESTART;</span><br><span class="line">    <span class="type">int</span> cpu;</span><br><span class="line"> </span><br><span class="line">    pending = local_softirq_pending();    <span class="comment">//pending`用于保留待处理软中断32位位图</span></span><br><span class="line">    account_system_vtime(current);</span><br><span class="line"> </span><br><span class="line">    __local_bh_disable((<span class="type">unsigned</span> <span class="type">long</span>)__builtin_return_address(<span class="number">0</span>));</span><br><span class="line">    lockdep_softirq_enter();</span><br><span class="line"> </span><br><span class="line">    cpu = smp_processor_id();</span><br><span class="line">restart:</span><br><span class="line">    <span class="comment">/* Reset the pending bitmask before enabling irqs */</span></span><br><span class="line">    set_softirq_pending(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    local_irq_enable();</span><br><span class="line"> </span><br><span class="line">    h = softirq_vec;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pending &amp; <span class="number">1</span>) &#123;    <span class="comment">//如果`pending`第`n`位被设置为1，那么处理第`n`位对应类型的软中断</span></span><br><span class="line">            <span class="type">int</span> prev_count = preempt_count();</span><br><span class="line">            kstat_incr_softirqs_this_cpu(h - softirq_vec);</span><br><span class="line"> </span><br><span class="line">            trace_softirq_entry(h, softirq_vec);</span><br><span class="line">            h-&gt;action(h);    <span class="comment">//执行软中断处理函数</span></span><br><span class="line">            trace_softirq_exit(h, softirq_vec);</span><br><span class="line">            <span class="keyword">if</span> (unlikely(prev_count != preempt_count())) &#123;</span><br><span class="line">                printk(KERN_ERR <span class="string">&quot;huh, entered softirq %td %s %p&quot;</span></span><br><span class="line">                       <span class="string">&quot;with preempt_count %08x,&quot;</span></span><br><span class="line">                       <span class="string">&quot; exited with %08x?\n&quot;</span>, h - softirq_vec,</span><br><span class="line">                       softirq_to_name[h - softirq_vec],</span><br><span class="line">                       h-&gt;action, prev_count, preempt_count());</span><br><span class="line">                preempt_count() = prev_count;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            rcu_bh_qs(cpu);</span><br><span class="line">        &#125;</span><br><span class="line">        h++;</span><br><span class="line">        pending &gt;&gt;= <span class="number">1</span>;    <span class="comment">//pending`右移一位，循环检查其每一位</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (pending);    <span class="comment">//直到`pending`变为0，pending`最多32位，所以循环最多执行32次。</span></span><br><span class="line"> </span><br><span class="line">    local_irq_disable();</span><br><span class="line"> </span><br><span class="line">    pending = local_softirq_pending();</span><br><span class="line">    <span class="keyword">if</span> (pending &amp;&amp; --max_restart)</span><br><span class="line">        <span class="keyword">goto</span> restart;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (pending)</span><br><span class="line">        wakeup_softirqd();</span><br><span class="line"> </span><br><span class="line">    lockdep_softirq_exit();</span><br><span class="line"> </span><br><span class="line">    account_system_vtime(current);</span><br><span class="line">    _local_bh_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用软中断必须要在编译期间静态注册，一般只有像网络这样对性能要求高的情况才使用软中断，文章前面我们也看到，系统中注册的软中断就那么几个。大部分时候，使用下半部另外一种机制<code>tasklet</code>的情况更多一些，<code>tasklet</code>可以动态的注册，可以被看作是一种性能和易用性之间寻求平衡的一种产物。事实上，大部分驱动程序都是用<code>tasklet</code>来实现他们的下半部。</p>
<h1 id="下半部机制之tasklet"><a href="#下半部机制之tasklet" class="headerlink" title="下半部机制之tasklet"></a>下半部机制之tasklet</h1><p><code>tasklet</code>是利用软中断实现的一种下半部机制。<code>tasklet</code>相比于软中断，其接口更加简单方便，锁保护要求较低。<code>tasklet</code>由<code>tasklet_struct</code>结构体表示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span>    <span class="comment">//链表中下一个tasklet</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> state;        <span class="comment">//tasklet状态</span></span><br><span class="line">    <span class="type">atomic_t</span> count;        <span class="comment">//引用计数</span></span><br><span class="line">    <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>);    <span class="comment">//tasklet处理函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data;    <span class="comment">//给tasklet处理函数的参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>tasklet</code>还分为了高优先级<code>tasklet</code>与一般<code>tasklet</code>，前面分析软中断时<code>softirq_init()</code>注册的两个<code>tasklet</code>软中断。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">softirq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//此处注册两个软中断</span></span><br><span class="line">    open_softirq(TASKLET_SOFTIRQ, tasklet_action);</span><br><span class="line">    open_softirq(HI_SOFTIRQ, tasklet_hi_action);    </span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其处理函数分别为<code>tasklet_action()</code>和<code>tasklet_hi_action()</code>。</p>
<p><code>tasklet_action()</code>函数实现为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tasklet_action</span><span class="params">(<span class="keyword">struct</span> softirq_action *a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">list</span>;</span></span><br><span class="line"> </span><br><span class="line">    local_irq_disable();</span><br><span class="line">    <span class="built_in">list</span> = __get_cpu_var(tasklet_vec).head;</span><br><span class="line">    __get_cpu_var(tasklet_vec).head = <span class="literal">NULL</span>;</span><br><span class="line">    __get_cpu_var(tasklet_vec).tail = &amp;__get_cpu_var(tasklet_vec).head;</span><br><span class="line">    local_irq_enable();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">t</span> =</span> <span class="built_in">list</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (tasklet_trylock(t)) &#123;    </span><br><span class="line">            <span class="keyword">if</span> (!<span class="type">atomic_read</span>(&amp;t-&gt;count)) &#123;        <span class="comment">//t-&gt;count`为零才会调用`task_struct`里的函数</span></span><br><span class="line">                <span class="keyword">if</span> (!test_and_clear_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state))</span><br><span class="line">                    BUG();</span><br><span class="line"> </span><br><span class="line">                 t-&gt;func(t-&gt;data);    <span class="comment">//设置了`TASKLET_STATE_SCHED`标志才会被遍历到链表上对应的函数</span></span><br><span class="line">                tasklet_unlock(t);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tasklet_unlock(t);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        local_irq_disable();</span><br><span class="line">        t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        *__get_cpu_var(tasklet_vec).tail = t;</span><br><span class="line">        __get_cpu_var(tasklet_vec).tail = &amp;(t-&gt;next);</span><br><span class="line">        __raise_softirq_irqoff(TASKLET_SOFTIRQ);</span><br><span class="line">        local_irq_enable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>tasklet_hi_action</code>函数实现类似<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tasklet_hi_action</span><span class="params">(<span class="keyword">struct</span> softirq_action *a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">list</span>;</span></span><br><span class="line"> </span><br><span class="line">    local_irq_disable();</span><br><span class="line">    <span class="built_in">list</span> = __get_cpu_var(tasklet_hi_vec).head;</span><br><span class="line">    __get_cpu_var(tasklet_hi_vec).head = <span class="literal">NULL</span>;</span><br><span class="line">    __get_cpu_var(tasklet_hi_vec).tail = &amp;__get_cpu_var(tasklet_hi_vec).head;</span><br><span class="line">    local_irq_enable();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">t</span> =</span> <span class="built_in">list</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (tasklet_trylock(t)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="type">atomic_read</span>(&amp;t-&gt;count)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!test_and_clear_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state))</span><br><span class="line">                    BUG();</span><br><span class="line">                t-&gt;func(t-&gt;data);</span><br><span class="line">                tasklet_unlock(t);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tasklet_unlock(t);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        local_irq_disable();</span><br><span class="line">        t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        *__get_cpu_var(tasklet_hi_vec).tail = t;</span><br><span class="line">        __get_cpu_var(tasklet_hi_vec).tail = &amp;(t-&gt;next);</span><br><span class="line">        __raise_softirq_irqoff(HI_SOFTIRQ);</span><br><span class="line">        local_irq_enable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个函数主要是做了如下动作：</p>
<ol>
<li>禁止中断，并为当前处理器检索<code>tasklet_vec</code>或<code>tasklet_hi_vec</code>链表。</li>
<li>将当前处理器上的该链表设置为`NULL,达到清空的效果。</li>
<li>运行相应中断。</li>
<li>循环遍历获得链表上的每一个待处理的`tasklet。</li>
<li>如果是多处理器系统，通过检查<code>TASKLET_STATE_RUN</code>来判断这个<code>tasklet</code>是否正在其他处理器上运行。如果它正在运行，那么现在就不要执行，跳到下一个待处理的<code>tasklet</code>去。</li>
<li>如果当前这个<code>tasklet</code>没有执行，将其状态设置为<code>TASKLETLET_STATE_RUN</code>，这样别的处理器就不会再去执行它了。</li>
<li>检查<code>count</code>值是否为0，确保<code>tasklet</code>没有被禁止。如果<code>tasklet</code>被禁止，则跳到下一个挂起的<code>tasklet</code>去。</li>
<li>现在可以确定这个<code>tasklet</code>没有在其他地方执行，并且被我们设置为执行状态，这样它在其他部分就不会被执行，并且引用计数器为0，现在可以执行<code>tasklet</code>的处理程序了。</li>
<li>重复执行下一个<code>tasklet</code>，直至没有剩余的等待处理的<code>tasklets</code>。</li>
</ol>
<p>一般情况下，都是用<code>tasklet</code>来实现下半部，<code>tasklet</code>可以动态创建、使用方便、执行速度快。下面来看一下如何创建自己的<code>tasklet</code>呢？</p>
<p>第一步，声明自己的<code>tasklet</code>。既可以静态也可以动态创建，这取决于选择是想有一个对<code>tasklet</code>的直接引用还是间接引用。静态创建方法(直接引用)，可以使用下列两个宏的一个(在<code>Linux/interrupt.h</code>中定义)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_TASKLET(name,func,data)</span><br><span class="line">DECLARE_TASKLET_DISABLED(name,func,data)</span><br></pre></td></tr></table></figure><br>这两个宏的实现为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_TASKLET(name, func, data) \</span></span><br><span class="line"><span class="meta">struct tasklet_struct name = &#123; NULL, 0, ATOMIC_INIT(0), func, data &#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_TASKLET_DISABLED(name, func, data) \</span></span><br><span class="line"><span class="meta">struct tasklet_struct name = &#123; NULL, 0, ATOMIC_INIT(1), func, data &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这两个宏之间的区别在于引用计数器的初始值不同，前面一个把创建的<code>tasklet</code>的引用计数器设置为0，使其处于激活状态，另外一个将其设置为1，处于禁止状态。而动态创建(间接引用)的方式如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklet_init(t,tasklet_handler,dev);</span><br></pre></td></tr></table></figure><br>其实现代码为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tasklet_init</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t,</span></span><br><span class="line"><span class="params">          <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>), <span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;state = <span class="number">0</span>;</span><br><span class="line">    <span class="type">atomic_set</span>(&amp;t-&gt;count, <span class="number">0</span>);</span><br><span class="line">    t-&gt;func = func;</span><br><span class="line">    t-&gt;data = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二步，编写<code>tasklet</code>处理程序。<code>tasklet</code>处理函数类型是<code>void tasklet_handler(unsigned long data)</code>。因为是靠软中断实现，所以<code>tasklet</code>不能休眠，也就是说不能在<code>tasklet</code>中使用信号量或者其他什么阻塞式的函数。由于<code>tasklet</code>运行时允许响应中断，所以必须做好预防工作，如果新加入的<code>tasklet</code>和中断处理程序之间共享了某些数据额的话。两个相同的<code>tasklet</code>绝不能同时执行，如果新加入的<code>tasklet</code>和其他的<code>tasklet</code>或者软中断共享了数据，就必须要进行适当地锁保护。</p>
<p>第三步，调度自己的<code>tasklet</code>。调用<code>tasklet_schedule()</code>（或<code>tasklet_hi_schedule()</code>）函数，<code>tasklet</code>就会进入挂起状态以便执行。如果在还没有得到运行机会之前，如果有一个相同的<code>tasklet</code>又被调度了，那么它仍然只会运行一次。如果这时已经开始运行，那么这个新的<code>tasklet</code>会被重新调度并再次运行。一种优化策略是一个<code>tasklet</code>总在调度它的处理器上执行。</p>
<p>调用<code>tasklet_disable()</code>来禁止某个指定的<code>tasklet</code>，如果该<code>tasklet</code>当前正在执行，这个函数会等到它执行完毕再返回。调用<code>tasklet_disable_nosync()</code>也是来禁止的，只是不用在返回前等待<code>tasklet</code>执行完毕，这么做不太安全，因为没法估计该<code>tasklet</code>是否仍在执行。<code>tasklet_enable()</code>激活一个<code>tasklet</code>。可以使用<code>tasklet_kill()</code>函数从挂起的对列中去掉一个<code>tasklet</code>。这个函数会首先等待该<code>tasklet</code>执行完毕，然后再将其移去。当然，没有什么可以阻止其他地方的代码重新调度该<code>tasklet</code>。由于该函数可能会引起休眠，所以禁止在中断上下文中使用它。</p>
<p>下面来看一下函数<code>tasklet_schedule</code>的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_schedule</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检查tasklet的状态是否为TASKLET_STATE_SCHED.如果是，说明tasklet已经被调度过了，函数返回。</span></span><br><span class="line">    <span class="keyword">if</span> (!test_and_set_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state))</span><br><span class="line">		__tasklet_schedule(t);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> __tasklet_schedule(<span class="keyword">struct</span> tasklet_struct *t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//保存中断状态，然后禁止本地中断。在执行tasklet代码时，这么做能够保证处理器上的数据不会弄乱。</span></span><br><span class="line">    local_irq_save(flags);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//把需要调度的tasklet加到每个处理器一个的tasklet_vec链表或task_hi_vec链表的表头上去。</span></span><br><span class="line">    t-&gt;next = <span class="literal">NULL</span>;    *__get_cpu_var(tasklet_vec).tail = t;</span><br><span class="line">    __get_cpu_var(tasklet_vec).tail = &amp;(t-&gt;next);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//唤起TASKLET_SOFTIRQ或HI_SOFTIRQ软中断，这样在下一次调用do_softirq()时就会执行该tasklet。</span></span><br><span class="line">    raise_softirq_irqoff(TASKLET_SOFTIRQ);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//恢复中断到原状态并返回。</span></span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>tasklet_hi_schedule()</code>函数的实现细节类似。</p>
<p>对于软中断，内核会选择几个特殊的实际进行处理(常见的是中 断处理程序返回时)。软中断被触发的频率有时会很好，而且还可能会自行重复触发，这带来的结果就是用户空间的进程无法获得足够的处理器时间，因为处于饥饿 状态。同时，如果单纯的对重复触发的软中断采取不立即处理的策略也是无法接受的。</p>
<p>内核选中的方案是不会立即处理重新触发的软中断，作为改进，当大量软中断出现的时候，内核会唤醒一组内核线程来处理这些负载。这些线程在最低优先级上运行(nice值为19)。这种这种方案能够保证在软中断负担很 重的时候用户程序不会因为得不到处理时间而处理饥饿状态。相应的，也能保证“过量”的软中断终究会得到处理。最后，在空闲系统上，这个方案同样表现良好，软中断处理得非常迅速(因为仅存的内存线程肯定会马上调度)。为了保证只要有空闲的处理器，它们就会处理软中断，所以给每个处理器都分配一个这样的线程。 所有线程的名字都叫做<code>ksoftirad/n</code>，区别在于<code>n</code>，它对应的是处理器的编号。一旦该线程被初始化，它就会执行类似下面这样的死循环：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!softirq_pending(cpu))<span class="comment">//softirq_pending()负责发现是否有待处理的软中断</span></span><br><span class="line">        schedule();    <span class="comment">//没有待处理软中断就唤起调度程序选择其他可执行进程投入运行</span></span><br><span class="line">    set_current_state(TASK_RUNNING);</span><br><span class="line">    <span class="keyword">while</span>(softirq_pending(cpu))&#123;</span><br><span class="line">        do_softirq();<span class="comment">//有待处理的软中断，ksoftirq调用do_softirq()去处理他。</span></span><br><span class="line">        <span class="keyword">if</span>(need_resched())    <span class="comment">//如果有必要的话，每次软中断完成之后调用schedule函数让其他重要进程得到处理机会</span></span><br><span class="line">            schedule();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//当所有需要执行的操作都完成以后，该内核线程将自己设置为 TASK_INTERRUPTIBLE状态</span></span><br><span class="line">    set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="下半部机制之工作队列及几种机制的选择"><a href="#下半部机制之工作队列及几种机制的选择" class="headerlink" title="下半部机制之工作队列及几种机制的选择"></a>下半部机制之工作队列及几种机制的选择</h1><p>工作队列是下半部的另外一种将工作推后执行形式。和软中断、<code>tasklet</code>不同，工作队列将工作推后交由一个内核线程去执行，并且该下半部总会在进程上下文中执行。这样，工作队列允许重新调度甚至是睡眠。</p>
<p>所以，如果推后执行的任务需要睡眠，就选择工作队列。如果不需要睡眠，那就选择软中断或`tasklet。工作队列是唯一能在进程上下文中运行的下半部实现机制，也只有它才可以睡眠。</p>
<p>工作队列子系统是一个用于创建内核线程的接口，通过它创建的进程负责执行由内核其他部分排到队列里的任务。它创建的这些内核线程称作工作者线程。工作队列可以让你的驱动程序创建一个专门的工作者线程来处理需要推后的工作。不过，工作队列子系统提供了一个缺省的工作者线程来处理这些工作。因此，工作队列最基本的表现形式就转变成一个把需要推后执行的任务交给特定的通用线程这样一种接口。缺省的工作线程叫做<code>event/n</code>。每个处理器对应一个线程，这里的<code>n</code>代表了处理器编号。除非一个驱动程序或者子系统必须建立一个属于自己的内核线程，否则最好还是使用缺省线程。</p>
<p>使用下面命令可以看到默认<code>event</code>工作者线程，每个处理器对应一个线程：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ps x | grep event | grep -v grep</span><br><span class="line">    9 ?        S      0:00 [events/0]</span><br><span class="line">   10 ?        S      0:00 [events/1]</span><br></pre></td></tr></table></figure></p>
<p>工作者线程使用<code>workqueue_struct</code>结构表示（位于<code>&lt;kernel/workqueue.c&gt;</code>中）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> *<span class="title">cpu_wq</span>;</span>    <span class="comment">//该数组每一项对应系统中的一个处理器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> singlethread;</span><br><span class="line">    <span class="type">int</span> freezeable;     <span class="comment">/* Freeze threads during suspend */</span></span><br><span class="line">    <span class="type">int</span> rt;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个处理器，每个工作者线程对应对应一个<code>cpu_workqueue_struct</code>结构体（位于<code>&lt;kernel/workqueue.c&gt;</code>中）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span> lock;    <span class="comment">//保护该结构</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">worklist</span>;</span>    <span class="comment">//工作列表</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> more_work;    <span class="comment">//等待队列，其中的工作者线程因等待而处于睡眠状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">current_work</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span>    <span class="comment">//关联工作队列结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">thread</span>;</span>    <span class="comment">// 关联线程，指向结构中工作者线程的进程描述符指针</span></span><br><span class="line">&#125; ____cacheline_aligned;</span><br></pre></td></tr></table></figure></p>
<p>每个工作者线程类型关联一个自己的<code>workqueue_struct</code>，在该结构体里面，给每个线程分配一个<code>cpu_workqueue_struct</code>，因而也就是给每个处理器分配一个，因为每个处理器都有一个该类型的工作者线程。</p>
<p>所有的工作者线程都是使用普通的内核线程实现的，他们都要执行<code>worker_thread()</code>函数。在它初始化完以后，这个函数执行一个死循环执行一个循环并开始休眠，当有操作被插入到队列的时候，线程就会被唤醒，以便执行这些操作。当没有剩余的时候，它又会继续休眠。工作由<code>work_struct</code>（位于<code>&lt;kernel/workqueue.c&gt;</code>中）结构表示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_long_t</span> data;</span><br><span class="line">......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span><span class="comment">//连接所有链表</span></span><br><span class="line">    <span class="type">work_func_t</span> func;</span><br><span class="line">.....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当一个工作线程被唤醒时，它会执行它的链表上的所有工作。工作一旦执行完毕，它就将相应的<code>work_struct</code>对象从链表上移去，当链表不再有对象时，它就继续休眠。<code>woker_thread()</code>函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">worker_thread</span><span class="params">(<span class="type">void</span> *__cwq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> *<span class="title">cwq</span> =</span> __cwq;</span><br><span class="line">    DEFINE_WAIT(wait);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (cwq-&gt;wq-&gt;freezeable)</span><br><span class="line">        set_freezable();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">//线程将自己设置为休眠状态并把自己加入等待队列</span></span><br><span class="line">        prepare_to_wait(&amp;cwq-&gt;more_work, &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line">        <span class="keyword">if</span> (!freezing(current) &amp;&amp;</span><br><span class="line">            !kthread_should_stop() &amp;&amp;</span><br><span class="line">            list_empty(&amp;cwq-&gt;worklist))</span><br><span class="line">            schedule();<span class="comment">//如果工作对列是空的，线程调用`schedule()函数进入睡眠状态</span></span><br><span class="line">        finish_wait(&amp;cwq-&gt;more_work, &amp;wait);</span><br><span class="line"> </span><br><span class="line">        try_to_freeze();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//如果链表有对象，线程就将自己设为运行态，脱离等待队列</span></span><br><span class="line">        <span class="keyword">if</span> (kthread_should_stop())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//再次调用`run_workqueue()执行推后的工作</span></span><br><span class="line">        run_workqueue(cwq);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后由<code>run_workqueue()</code>函数来完成实际推后到此的工作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">run_workqueue</span><span class="params">(<span class="keyword">struct</span> cpu_workqueue_struct *cwq)</span> </span><br><span class="line">&#123;</span><br><span class="line">    spin_lock_irq(&amp;cwq-&gt;lock);</span><br><span class="line">    <span class="keyword">while</span> (!list_empty(&amp;cwq-&gt;worklist)) &#123;</span><br><span class="line">        <span class="comment">//链表不为空时，选取下一个节点对象</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> =</span> list_entry(cwq-&gt;worklist.next,</span><br><span class="line">                        <span class="keyword">struct</span> work_struct, entry);</span><br><span class="line">        <span class="comment">//获取希望执行的函数`func`及其参数`data</span></span><br><span class="line">        <span class="type">work_func_t</span> f = work-&gt;func;</span><br><span class="line">......</span><br><span class="line">        trace_workqueue_execution(cwq-&gt;thread, work);</span><br><span class="line">        cwq-&gt;current_work = work;</span><br><span class="line">        <span class="comment">//把该结点从链表上解下来</span></span><br><span class="line">        list_del_init(cwq-&gt;worklist.next);</span><br><span class="line">        spin_unlock_irq(&amp;cwq-&gt;lock);</span><br><span class="line"> </span><br><span class="line">        BUG_ON(get_wq_data(work) != cwq);</span><br><span class="line">        <span class="comment">//将待处理标志位`pending`清0</span></span><br><span class="line">        work_clear_pending(work);</span><br><span class="line">        lock_map_acquire(&amp;cwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line">        lock_map_acquire(&amp;lockdep_map);</span><br><span class="line">        <span class="comment">//执行函数</span></span><br><span class="line">        f(work);</span><br><span class="line">        lock_map_release(&amp;lockdep_map);</span><br><span class="line">        lock_map_release(&amp;cwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line"> </span><br><span class="line">......</span><br><span class="line">        spin_lock_irq(&amp;cwq-&gt;lock);</span><br><span class="line">        cwq-&gt;current_work = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irq(&amp;cwq-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>系统允许有多种类型工作者线程存在，默认情况下内核只有<code>event</code>这一种类型的工作者线程，每个工作者线程都由一个<code>cpu_workqueue_struct</code>结构体表示，大部分情况下，驱动程序都使用现存的默认工作者线程。</p>
<p>工作队列的使用很简单。可以使用缺省的<code>events</code>任务队列，也可以创建新的工作者线程。<br>第一步、创建需要推后完成的工作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_WORK(name,<span class="type">void</span> (*func)(<span class="type">void</span> *),<span class="type">void</span> *data);        <span class="comment">//编译时静态创建</span></span><br><span class="line">INIT_WORK(<span class="keyword">struct</span> work_struct *work, <span class="type">void</span> (*func)(<span class="type">void</span> *));    <span class="comment">//运行时动态创建</span></span><br></pre></td></tr></table></figure></p>
<p>第二步、编写队列处理函数，处理函数会由工作者线程执行，因此，函数会运行在进程上下文中，默认情况下，允许相应中断，并且不持有锁。如果需要，函数可以睡眠。需要注意的是，尽管处理函数运行在进程上下文中，但它不能访问用户空间，因为内核线程在用户空间没有相应的内存映射。函数原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">work_hander</span><span class="params">(<span class="type">void</span> *data)</span>;</span><br></pre></td></tr></table></figure></p>
<p>第三步、调度工作队列。调用<code>schedule_work(&amp;work)</code>；<code>work</code>马上就会被调度，一旦其所在的处理器上的工作者线程被唤醒，它就会被执行。当然如果不想快速执行，而是想延迟一段时间执行，调用<code>schedule_delay_work(&amp;work,delay)</code>，<code>delay</code>是要延迟的时间节拍。</p>
<p>默认工作者线程的调度函数其实就是做了一层封装，减少了 默认工作者线程的参数输入，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">schedule_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> queue_work(keventd_wq, work);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">schedule_delayed_work</span><span class="params">(<span class="keyword">struct</span> delayed_work *dwork, <span class="type">unsigned</span> <span class="type">long</span> delay)</span>                                             </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> queue_delayed_work(keventd_wq, dwork, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第四步、刷新操作，插入队列的工作会在工作者线程下一次被唤醒的时候执行。有时，在继续下一步工作之前，你必须保证一些操作已经执行完毕等等。由于这些原因，内核提供了一个用于刷新指定工作队列的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">flush_scheduled_work</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><br>这个函数会一直等待，直到队列中所有的对象都被执行后才返回。在等待所有待处理的工作执行的时候，该函数会进入休眠状态，所以只能在进程上下文中使用它。需要说明的是，该函数并不取消任何延迟执行的工作。取消延迟执行的工作应该调用：<code>int cancel_delayed_work(struct work_struct *work)</code>;这个函数可以取消任何与<code>work_struct</code>相关挂起的工作。<br>下面为一个示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span> <span class="comment">//work_strcut</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//struct work_struct      ws;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span>     <span class="title">dw</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">workqueue_func</span><span class="params">(<span class="keyword">struct</span> work_struct *ws)</span>    <span class="comment">//处理函数</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;Hello, this is shallnet!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">kwq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//INIT_WORK(&amp;ws, workqueue_func);    //建需要推后完成的工作</span></span><br><span class="line">    <span class="comment">//schedule_work(&amp;ws);    //调度工作</span></span><br><span class="line"> </span><br><span class="line">    INIT_DELAYED_WORK(&amp;dw, workqueue_func);</span><br><span class="line">    schedule_delayed_work(&amp;dw, <span class="number">10000</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">kwq_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line"> </span><br><span class="line">    flush_scheduled_work();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(kwq_init);</span><br><span class="line">module_exit(kwq_exit);</span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;shallnet&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;blog.csdn.net/shallnet&quot;</span>);</span><br></pre></td></tr></table></figure><br>上面的操作是使用缺省的工作队列，下面来看一下创建一个新的工作队列是如何操作的？</p>
<p>创建一个新的工作队列和与之相应的工作者线程，方法很简单，使用如下函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> workqueue_struct *<span class="title function_">create_workqueue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>name</code>是新内核线程的名字。比如缺省<code>events</code>队列的创建是这样使用的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span>    *<span class="title">keventd_wq</span>；</span></span><br><span class="line"><span class="class"><span class="title">kevent_wq</span> =</span> create_workqueue(<span class="string">&quot;event&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>这样就创建了所有的工作者线程，每个处理器都有一个。然后调用如下函数进行调度：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">queue_work</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq, <span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">queue_delayed_work</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq,<span class="keyword">struct</span> delayed_work *work,<span class="type">unsigned</span> <span class="type">long</span> delay)</span>;</span><br></pre></td></tr></table></figure></p>
<p>最后可以调用<code>flush_workqueue(struct workqueue_struct *wq);</code>刷新指定工作队列。</p>
<p>下面为自定义新的工作队列的示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span> <span class="comment">//work_strcut</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">sln_wq</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//struct work_struct      ws;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span>     <span class="title">dw</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">workqueue_func</span><span class="params">(<span class="keyword">struct</span> work_struct *ws)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;Hello, this is shallnet!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">kwq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line"> </span><br><span class="line">    sln_wq = create_workqueue(<span class="string">&quot;sln_wq&quot;</span>);    <span class="comment">//创建名为`sln_wq`的工作队列</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//INIT_WORK(&amp;ws, workqueue_func);</span></span><br><span class="line">    <span class="comment">//queue_work(sln_wq, &amp;ws);</span></span><br><span class="line"> </span><br><span class="line">    INIT_DELAYED_WORK(&amp;dw, workqueue_func);    <span class="comment">//</span></span><br><span class="line">    queue_delayed_work(sln_wq, &amp;dw, <span class="number">10000</span>);    <span class="comment">//</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">kwq_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line"> </span><br><span class="line">    flush_workqueue(sln_wq);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(kwq_init);</span><br><span class="line">module_exit(kwq_exit);</span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;shallnet&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;blog.csdn.net/shallnet&quot;</span>);</span><br></pre></td></tr></table></figure><br>使用<code>ps</code>可以查看到名为<code>sln_wq</code>的工作者线程。</p>
<p>在当前2.6.32版本中，我们讲了三种下半部机制：软中断、tasklet、工作队列。其中<code>tasklet</code>基于软中断，而工作队列靠内核线程实现。</p>
<p>使用软中断必须要确保共享数据的安全，因为相同类别的软中断可能在不同处理器上同时执行。在对于时间要求是否严格和执行频率很高的应用，或准备利用每一处理器上的变量或类型情形，可以考虑使用软中断，如网络子系统。</p>
<p><code>tasklet</code>接口简单，可以动态创建，且两个通知类型的<code>tasklet</code>不能同时执行，所以实现起来较简单。驱动程序应该尽量选择<code>tasklet</code>而不是软中断。</p>
<p>工作队列工作于进程上下文，易于使用。由于牵扯到内核线程或上下文的切换，可能开销较大。如果你需要把任务推后到进程上下文中，或你需要休眠，那就只有使用工作队列了。</p>
<h1 id="内核时钟中断"><a href="#内核时钟中断" class="headerlink" title="内核时钟中断"></a>内核时钟中断</h1><p>内核中很多函数是基于时间驱动的，其中有些函数需要周期或定期执行。比如有的每秒执行100次，有的在等待一个相对时间之后执行。除此之外，内核还必须管理系统运行的时间日期。 </p>
<p>周期性产生的时间都是有系统定时器驱动的，系统定时器是一种可编程硬件芯片，它可以以固定频率产生中断，该中断就是所谓的定时器中断，其所对应的中断处理程序负责更新系统时间，也负责执行需要周期性运行的任务。</p>
<p>系统定时器以某种频率自行触发时钟中断，该频率可以通过编程预定，称作节拍率。当时钟中断发生时，内核就通过一种特殊的中断处理器对其进行处理。内核知道连续两次时钟中断的间隔时间，该间隔时间就称为节拍。内核就是靠这种已知的时钟中断间隔来计算实际时间和系统运行时间的。内核通过控制时钟中断维护实际时间，另外内核也为用户提供一组系统调用获取实际日期和实际时间。时钟中断对才操作系统的管理来说十分重要，系统更新运行时间、更新实际时间、均衡调度程序中个处理器上运行队列、检查进程是否用尽时间片等工作都利用时钟中断来周期执行。</p>
<p>内核有一个全局变量<code>jiffies</code>，该变量用来记录系统起来以后产生的节拍总数。系统启动是，该变量被设置为0，此后每产生一次时钟中断就增加该变量的值。<code>jiffies</code>每一秒增加的值就是<code>HZ</code>。<code>jiffies</code>定义于头文件<code>&lt;include/linux/jiffies.h&gt;</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="keyword">volatile</span> __jiffy_data jiffies;</span><br></pre></td></tr></table></figure></p>
<p>对于32位<code>unsigned long</code>，可以存放最大值为4294967295，所以当节拍数达到最大值后还要继续增加的话，它的值就会回到0值。内核提供了四个宏（位于文件<code>&lt;include/linux/jiffies.h&gt;</code>中）来比较节拍数，这些宏可以正确处理节拍计数回绕情况。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> time_after(a,b)         \</span></span><br><span class="line"><span class="meta">        (typecheck(unsigned long, a) &amp;&amp; \</span></span><br><span class="line"><span class="meta">         typecheck(unsigned long, b) &amp;&amp; \</span></span><br><span class="line"><span class="meta">         ((long)(b) - (long)(a) &lt; 0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> time_before(a,b)        time_after(b,a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> time_after_eq(a,b)      \</span></span><br><span class="line"><span class="meta">        (typecheck(unsigned long, a) &amp;&amp; \</span></span><br><span class="line"><span class="meta">         typecheck(unsigned long, b) &amp;&amp; \</span></span><br><span class="line"><span class="meta">         ((long)(a) - (long)(b) &gt;= 0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> time_before_eq(a,b)     time_after_eq(b,a) </span></span><br></pre></td></tr></table></figure></p>
<p>下面示例来打印出当前系统启动后经过的<code>jiffies</code>以及秒数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/jiffies.h&gt;</span> <span class="comment">//jiffies</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/param.h&gt;</span> <span class="comment">//HZ</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">jiffies_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;Current ticks is: %lu, seconds: %lu\n&quot;</span>, jiffies, jiffies/HZ);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">jiffies_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line">module_init(jiffies_init);</span><br><span class="line">module_exit(jiffies_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;shallnet&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;blog.csdn.net/shallnet&quot;</span>); </span><br></pre></td></tr></table></figure></p>
<p>执行输出结果为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># insmod jfs.ko</span><br><span class="line">===jiffies_init===</span><br><span class="line">Current ticks is: 10106703, seconds: 10106</span><br></pre></td></tr></table></figure></p>
<p>时钟中断发生时，会触发时钟中断处理程序，始终中断处理程序部分和体系结构相关，下面简单分析一下x86体系的处理：</p>
<p>时钟的初始化在<code>time_init()</code>中，在<code>start_kernel()</code>中调用<code>time_init()</code>，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> __init <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    time_init();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面分析一下<code>time_init()</code>的实现，该函数位于文件<code>&lt;arch/x86/kernel/time.c&gt;</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">time_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    late_time_init = x86_late_time_init;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> __init <span class="type">void</span> <span class="title function_">x86_late_time_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    x86_init.timers.timer_init();        <span class="comment">//</span></span><br><span class="line">    tsc_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结构体<code>x86_init</code>位于<code>arch/x86/kernel/x86_init.c</code>中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">x86_init_ops</span> <span class="title">x86_init</span> __<span class="title">initdata</span> =</span> &#123; </span><br><span class="line">......</span><br><span class="line">    .timers = &#123;</span><br><span class="line">        .setup_percpu_clockev&gt;--= setup_boot_APIC_clock,</span><br><span class="line">        .tsc_pre_init       = x86_init_noop,</span><br><span class="line">        .timer_init     = hpet_time_init,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>默认<code>timer</code>初始化函数为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">hpet_time_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hpet_enable())</span><br><span class="line">        setup_pit_timer();</span><br><span class="line">    setup_default_timer_irq();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数<code>setup_default_timer_irq();</code>注册中断处理函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">setup_default_timer_irq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    setup_irq(<span class="number">0</span>, &amp;irq0);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> <span class="title">irq0</span>  =</span> &#123;</span><br><span class="line">    .handler = timer_interrupt,</span><br><span class="line">    .flags = IRQF_DISABLED | IRQF_NOBALANCING | IRQF_IRQPOLL | IRQF_TIMER,</span><br><span class="line">    .name = <span class="string">&quot;timer&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对应的中断处理函数为:<code>timer_interrupt()</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">timer_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Keep nmi watchdog up to date */</span></span><br><span class="line">    inc_irq_stat(irq0_irqs);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Optimized out for !IO_APIC and x86_64 */</span></span><br><span class="line">    <span class="keyword">if</span> (timer_ack) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Subtle, when I/O APICs are used we have to ack timer IRQ</span></span><br><span class="line"><span class="comment">         * manually to deassert NMI lines for the watchdog if run</span></span><br><span class="line"><span class="comment">         * on an 82489DX-based system.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        spin_lock(&amp;i8259A_lock);</span><br><span class="line">        outb(<span class="number">0x0c</span>, PIC_MASTER_OCW3);</span><br><span class="line">        <span class="comment">/* Ack the IRQ; AEOI will end it automatically. */</span></span><br><span class="line">        inb(PIC_MASTER_POLL);</span><br><span class="line">        spin_unlock(&amp;i8259A_lock);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在此处调用体系无关的时钟处理例程</span></span><br><span class="line">    global_clock_event-&gt;event_handler(global_clock_event);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* MCA bus quirk: Acknowledge irq0 by setting bit 7 in port 0x61 */</span></span><br><span class="line">    <span class="keyword">if</span> (MCA_bus)</span><br><span class="line">        outb_p(inb_p(<span class="number">0x61</span>)| <span class="number">0x80</span>, <span class="number">0x61</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>时钟例程在系统启动时<code>start_kernel()</code>函数中调用<code>tick_init()</code>初始化：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">tick_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    clockevents_register_notifier(&amp;tick_notifier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>tick_notifier</code>定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">tick_notifier</span> =</span> &#123;</span><br><span class="line">    .notifier_call = tick_notify,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tick_notify</span><span class="params">(<span class="keyword">struct</span> notifier_block *nb, <span class="type">unsigned</span> <span class="type">long</span> reason, <span class="type">void</span> *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (reason) &#123;</span><br><span class="line">    <span class="keyword">case</span> CLOCK_EVT_NOTIFY_RESUME:</span><br><span class="line">        tick_resume();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NOTIFY_OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tick_resume</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tick_device</span> *<span class="title">td</span> =</span> &amp;__get_cpu_var(tick_cpu_device);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> broadcast = tick_resume_broadcast();</span><br><span class="line"> </span><br><span class="line">    spin_lock_irqsave(&amp;tick_device_lock, flags);</span><br><span class="line">    clockevents_set_mode(td-&gt;evtdev, CLOCK_EVT_MODE_RESUME);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!broadcast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (td-&gt;mode == TICKDEV_MODE_PERIODIC)</span><br><span class="line">            tick_setup_periodic(td-&gt;evtdev, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tick_resume_oneshot();</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irqrestore(&amp;tick_device_lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Setup the device for a periodic tick</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tick_setup_periodic</span><span class="params">(<span class="keyword">struct</span> clock_event_device *dev, <span class="type">int</span> broadcast)</span></span><br><span class="line">&#123;</span><br><span class="line">    tick_set_periodic_handler(dev, broadcast);</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 根据broadcast设置周期性的处理函数（kernel/time/tick-broadcast.c）,这里就设置了始终中断函数timer_interrupt中调用的时钟处理例程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tick_set_periodic_handler</span><span class="params">(<span class="keyword">struct</span> clock_event_device *dev, <span class="type">int</span> broadcast)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!broadcast)</span><br><span class="line">        dev-&gt;event_handler = tick_handle_periodic;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dev-&gt;event_handler = tick_handle_periodic_broadcast;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ，以tick_handle_periodic为例，每一个始终节拍都调用该处理函数，而该处理过程中，主要处理工作处于tick_periodic()函数中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tick_handle_periodic</span><span class="params">(<span class="keyword">struct</span> clock_event_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cpu = smp_processor_id();</span><br><span class="line">    <span class="type">ktime_t</span> next;</span><br><span class="line"> </span><br><span class="line">    tick_periodic(cpu);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;mode != CLOCK_EVT_MODE_ONESHOT)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    next = ktime_add(dev-&gt;next_event, tick_period);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!clockevents_program_event(dev, next, ktime_get()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (timekeeping_valid_for_hres())</span><br><span class="line">            tick_periodic(cpu);</span><br><span class="line">        next = ktime_add(next, tick_period);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>tick_periodic()</code>函数主要有以下工作：<br>下面来看分析一下该函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Periodic tick</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tick_periodic</span><span class="params">(<span class="type">int</span> cpu)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tick_do_timer_cpu == cpu) &#123;</span><br><span class="line">        write_seqlock(&amp;xtime_lock);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 记录下一个节拍事件 */</span></span><br><span class="line">        tick_next_period = ktime_add(tick_next_period, tick_period);</span><br><span class="line"> </span><br><span class="line">        do_timer(<span class="number">1</span>);</span><br><span class="line">        write_sequnlock(&amp;xtime_lock);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    update_process_times(user_mode(get_irq_regs()));<span class="comment">//更新所耗费的各种节拍数</span></span><br><span class="line">    profile_tick(CPU_PROFILING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中函数<code>do_timer()</code>（位于<code>kernel/timer.c</code>中）对<code>jiffies_64</code>做增加操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_timer</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> ticks)</span></span><br><span class="line">&#123;</span><br><span class="line">    jiffies_64 += ticks;</span><br><span class="line">    update_wall_time();    <span class="comment">//更新墙上时钟</span></span><br><span class="line">    calc_global_load();    <span class="comment">//更新系统平均负载统计值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>update_process_times</code>更新所耗费的各种节拍数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">update_process_times</span><span class="params">(<span class="type">int</span> user_tick)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span> =</span> current;</span><br><span class="line">    <span class="type">int</span> cpu = smp_processor_id();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Note: this timer irq context must be accounted for as well. */</span></span><br><span class="line">    account_process_tick(p, user_tick);</span><br><span class="line">    run_local_timers();</span><br><span class="line">    rcu_check_callbacks(cpu, user_tick);</span><br><span class="line">    printk_tick();</span><br><span class="line">    scheduler_tick();</span><br><span class="line">    run_posix_cpu_timers(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数<code>run_local_timers()</code>会标记一个软中断去处理所有到期的定时器。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">run_local_timers</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    hrtimer_run_queues();</span><br><span class="line">    raise_softirq(TIMER_SOFTIRQ);</span><br><span class="line">    softlockup_tick();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在时钟中断处理函数<code>time_interrupt()</code>函数调用体系结构无关的时钟处理例程完成之后，返回到与体系结构的相关的中断处理函数中。以上所有的工作每一次时钟中断都会运行，也就是说如果HZ=100，那么时钟中断处理程序每一秒就会运行100次。</p>
<h1 id="内核定时器和定时执行"><a href="#内核定时器和定时执行" class="headerlink" title="内核定时器和定时执行"></a>内核定时器和定时执行</h1><p>前面章节说到了把工作推后到除现在以外的时间执行的机制是下半部机制，但是当你需要将工作推后到某个确定的时间段之后执行，使用定时器是很好的选择。</p>
<p>上一节内核时间管理中讲到内核在始终中断发生执行定时器，定时器作为软中断在下半部上下文中执行。时钟中断处理程序会执行<code>update_process_times</code>函数，在该函数中运行<code>run_local_timers()</code>函数来标记一个软中断去处理所有到期的定时器。如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">update_process_times</span><span class="params">(<span class="type">int</span> user_tick)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span> =</span> current;</span><br><span class="line">    <span class="type">int</span> cpu = smp_processor_id();</span><br><span class="line">    <span class="comment">/* Note: this timer irq context must be accounted for as well. */</span></span><br><span class="line">    account_process_tick(p, user_tick);</span><br><span class="line">    run_local_timers();</span><br><span class="line">    rcu_check_callbacks(cpu, user_tick);</span><br><span class="line">    printk_tick();</span><br><span class="line">    scheduler_tick();</span><br><span class="line">    run_posix_cpu_timers(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">run_local_timers</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    hrtimer_run_queues();</span><br><span class="line">    raise_softirq(TIMER_SOFTIRQ);</span><br><span class="line">    softlockup_tick();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在分析定时器的实现之前我们先来看一看使用内核定时器的一个实例，示例如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span>   <span class="title">sln_timer</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sln_timer_do</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> l)</span></span><br><span class="line">&#123;</span><br><span class="line">    mod_timer(&amp;sln_timer, jiffies + HZ);</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;param: %ld, jiffies: %ld\n&quot;</span>, l, jiffies);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sln_timer_set</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    init_timer(&amp;sln_timer);</span><br><span class="line">    sln_timer.expires = jiffies + HZ;   <span class="comment">//1s</span></span><br><span class="line">    sln_timer.function = sln_timer_do;</span><br><span class="line">    sln_timer.data = <span class="number">9527</span>;</span><br><span class="line">    add_timer(&amp;sln_timer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">sln_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line">    sln_timer_set();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">sln_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line">    del_timer(&amp;sln_timer);</span><br><span class="line">&#125;</span><br><span class="line">module_init(sln_init);</span><br><span class="line">module_exit(sln_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;allen&quot;</span>);</span><br></pre></td></tr></table></figure><br>该示例作用是每秒钟打印出当前系统<code>jiffies</code>的值。</p>
<p>内核定时器由结构<code>timer_list</code>表示，定义在文件<code>&lt;include/linux/timer.h&gt;</code>中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expires;</span><br><span class="line">    <span class="type">void</span> (*function)(<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tvec_base</span> *<span class="title">base</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TIMER_STATS</span></span><br><span class="line">    <span class="type">void</span> *start_site;</span><br><span class="line">    <span class="type">char</span> start_comm[<span class="number">16</span>];</span><br><span class="line">    <span class="type">int</span> start_pid;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如示例，内核提供部分操作接口来简化管理定时器，<br>第一步、定义一个定时器：<code>struct timer_list   sln_timer;</code></p>
<p>第二步、初始化定时器数据结构的内部值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_timer(&amp;sln_timer);<span class="comment">//初始化定时器</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> init_timer(timer)\</span></span><br><span class="line"><span class="meta">    init_timer_key((timer), NULL, NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_timer_key</span><span class="params">(<span class="keyword">struct</span> timer_list *timer,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> lock_class_key *key)</span></span><br><span class="line">&#123;</span><br><span class="line">    debug_init(timer);</span><br><span class="line">    __init_timer(timer, name, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init_timer(<span class="keyword">struct</span> timer_list *timer,</span><br><span class="line">             <span class="type">const</span> <span class="type">char</span> *name,</span><br><span class="line">             <span class="keyword">struct</span> lock_class_key *key)</span><br><span class="line">&#123;</span><br><span class="line">    timer-&gt;entry.next = <span class="literal">NULL</span>;</span><br><span class="line">    timer-&gt;base = __raw_get_cpu_var(tvec_bases);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TIMER_STATS</span></span><br><span class="line">    timer-&gt;start_site = <span class="literal">NULL</span>;</span><br><span class="line">    timer-&gt;start_pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(timer-&gt;start_comm, <span class="number">0</span>, TASK_COMM_LEN);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    lockdep_init_map(&amp;timer-&gt;lockdep_map, name, key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步、填充<code>timer_list</code>结构中需要的值：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sln_timer.expires = jiffies + HZ;   <span class="comment">//1s`后执行  </span></span><br><span class="line">sln_timer.function = sln_timer_do;    <span class="comment">//执行函数</span></span><br><span class="line">sln_timer.data = <span class="number">9527</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>sln_timer.expires</code>表示超时时间，它以节拍为单位的绝对计数值。如果当前<code>jiffies</code>计数等于或大于<code>sln_timer.expires</code>的值，那么<code>sln_timer.function</code>所指向的处理函数<code>sln_timer_do</code>就会执行，并且该函数还要使用长整型参数<code>sln_timer.dat</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sln_timer_do</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> l)</span>；</span><br></pre></td></tr></table></figure></p>
<p>第四步、激活定时器：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_timer(&amp;sln_timer);    <span class="comment">//向内核注册定时器</span></span><br></pre></td></tr></table></figure><br>这样定时器就可以运行了。</p>
<p><code>add_timer()</code>的实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span></span><br><span class="line">&#123;</span><br><span class="line">    BUG_ON(timer_pending(timer));</span><br><span class="line">    mod_timer(timer, timer-&gt;expires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>add_timer()</code>调用了<code>mod_timer()</code>。<code>mod_timer()</code>用于修改定时器超时时间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mod_timer(&amp;sln_timer, jiffies + HZ);</span><br></pre></td></tr></table></figure><br>由于<code>add_timer()</code>是通过调用<code>mod_timer()</code>来激活定时器，所以也可以直接使用<code>mod_timer()</code>来激活定时器，如果定时器已经初始化但没有激活，<code>mod_timer()</code>也会激活它。</p>
<p>如果需要在定时器超时前停止定时器，使用<code>del_timer()</code>函数来完成。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del_timer(&amp;sln_timer);</span><br></pre></td></tr></table></figure></p>
<p>该函数实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">del_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tvec_base</span> *<span class="title">base</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    timer_stats_timer_clear_start_info(timer);</span><br><span class="line">    <span class="keyword">if</span> (timer_pending(timer)) &#123;</span><br><span class="line">        base = lock_timer_base(timer, &amp;flags);</span><br><span class="line">        <span class="keyword">if</span> (timer_pending(timer)) &#123;</span><br><span class="line">            detach_timer(timer, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (timer-&gt;expires == base-&gt;next_timer &amp;&amp;</span><br><span class="line">                !tbase_get_deferrable(timer-&gt;base))</span><br><span class="line">                base-&gt;next_timer = base-&gt;timer_jiffies;</span><br><span class="line">            ret = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        spin_unlock_irqrestore(&amp;base-&gt;lock, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">detach_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer,</span></span><br><span class="line"><span class="params">                <span class="type">int</span> clear_pending)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">entry</span> =</span> &amp;timer-&gt;entry;</span><br><span class="line">    debug_deactivate(timer);</span><br><span class="line">    __list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">    <span class="keyword">if</span> (clear_pending)</span><br><span class="line">        entry-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    entry-&gt;prev = LIST_POISON2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当使用<code>del_timer()</code>返回后，定时器就不会再被激活，但在多处理器机器上定时器上定时器中断可能已经在其他处理器上运行了，所以删除定时器时需要等待可能在其他处理器上运行的定时器处理<code>I</code>程序都退出，这时就要使用<code>del_timer_sync()</code>函数执行删除工作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del_timer_sync(&amp;sln_timer);</span><br></pre></td></tr></table></figure><br>该函数不能在中断上下文中使用。</p>
<p>该函数详细实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">del_timer_sync</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    local_irq_save(flags);</span><br><span class="line">    lock_map_acquire(&amp;timer-&gt;lockdep_map);</span><br><span class="line">    lock_map_release(&amp;timer-&gt;lockdep_map);</span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;    <span class="comment">//一直循环，直到删除`timer`成功再退出</span></span><br><span class="line">        <span class="type">int</span> ret = try_to_del_timer_sync(timer);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        cpu_relax();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">try_to_del_timer_sync</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tvec_base</span> *<span class="title">base</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    base = lock_timer_base(timer, &amp;flags);</span><br><span class="line">    <span class="keyword">if</span> (base-&gt;running_timer == timer)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (timer_pending(timer)) &#123;</span><br><span class="line">        detach_timer(timer, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (timer-&gt;expires == base-&gt;next_timer &amp;&amp;</span><br><span class="line">            !tbase_get_deferrable(timer-&gt;base))</span><br><span class="line">            base-&gt;next_timer = base-&gt;timer_jiffies;</span><br><span class="line">        ret = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    spin_unlock_irqrestore(&amp;base-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般情况下应该使用<code>del_timer_sync()</code>函数代替<code>del_timer()</code>函数，因为无法确定在删除定时器时，他是否在其他处理器上运行。为了防止这种情况的发生，应该调用<code>del_timer_sync()</code>函数而不是<code>del_timer()</code>函数。否则，对定时器执行删除操作后，代码会继续执行，但它有可能会去操作在其它处理器上运行的定时器正在使用的资源，因而造成并发访问，所有优先使用删除定时器的同步方法。</p>
<p>除了使用定时器来推迟任务到指定时间段运行之外，还有其他的方法处理延时请求。有的方法会在延迟任务时挂起处理器，有的却不会。实际上也没有方法能够保证实际的延迟时间刚好等于指定的延迟时间。</p>
<ol>
<li>最简单的 延迟方法是忙等待，该方法实现起来很简单，只需要在循环中不断旋转直到希望的时钟节拍数耗尽。比如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> delay = jiffies+<span class="number">10</span>;   <span class="comment">//延迟10个节拍</span></span><br><span class="line"><span class="keyword">while</span>(time_before(jiffies,delay))</span><br><span class="line">        ；</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这种方法当代码等待时，处理器只能在原地旋转等待，它不会去处理其他任何任务。最好在任务等待时，允许内核重新调度其它任务执行。将上面代码修改如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> delay = jiffies+<span class="number">10</span>;   <span class="comment">//10个节拍</span></span><br><span class="line"><span class="keyword">while</span>(time_before(jiffies,delay))</span><br><span class="line">    cond_resched();</span><br></pre></td></tr></table></figure></p>
<p>看一下<code>cond_resched()</code>函数具体实现代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> cond_resched() (&#123;           \</span></span><br><span class="line"><span class="meta">    __might_sleep(__FILE__, __LINE__, 0);   \</span></span><br><span class="line"><span class="meta">    _cond_resched();            \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> __sched _cond_resched(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (should_resched()) &#123;</span><br><span class="line">        __cond_resched();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __cond_resched(<span class="type">void</span>)                                                                 </span><br><span class="line">&#123;</span><br><span class="line">    add_preempt_count(PREEMPT_ACTIVE);</span><br><span class="line">    schedule(); <span class="comment">//最终还是调用`schedule()函数来重新调度其它程序运行</span></span><br><span class="line">    sub_preempt_count(PREEMPT_ACTIVE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数<code>cond_resched()</code>将重新调度一个新程序投入运行，但它只有在设置完<code>need_resched</code>标志后才能生效。换句话说，就是系统中存在更重要的任务需要运行。再由于该方法需要调用调度程序，所以它不能在中断上下文中使用——只能在进程上下文中使用。事实上，所有延迟方法在进程上下文中使用，因为中断处理程序都应该尽可能快的执行。另外，延迟执行不管在哪种情况下都不应该在持有锁时或者禁止中断时发生。</p>
<ol>
<li><p>有时内核需要更短的延迟，甚至比节拍间隔还要短。这时可以使用内核提供的<code>ms、ns、us</code>级别的延迟函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">udelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> usecs)</span>;    <span class="comment">//arch/x86/include/asm/delay.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ndelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nsecs)</span>;    <span class="comment">//arch/x86/include/asm/delay.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mdelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> msecs)</span>;    </span><br></pre></td></tr></table></figure>
<p><code>udelay()</code>使用忙循环将任务延迟指定的<code>ms</code>后执行，其依靠执行数次循环达到延迟效果，<code>mdelay()</code>函数是通过<code>udelay()</code>函数实现，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> mdelay(n) (\ </span></span><br><span class="line">    (__builtin_constant_p(n) &amp;&amp; (n)&lt;=MAX_UDELAY_MS) ? udelay((n)*<span class="number">1000</span>) : \</span><br><span class="line">    (&#123;<span class="type">unsigned</span> <span class="type">long</span> __ms=(n); <span class="keyword">while</span> (__ms--) udelay(<span class="number">1000</span>);&#125;))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>udelay()</code>函数仅能在要求的延迟时间很短的情况下执行，而在高速机器中时间很长的延迟会造成溢出。对于较长的延迟，mdelay()工作良好。</p>
</li>
<li><p><code>schedule_timeout()</code>函数是更理想的延迟执行方法。该方法会让需要延迟执行的任务睡眠到指定的延迟时间耗尽后再重新运行。但该方法也不能保证睡眠时间正好等于指定的延迟时间，只能尽量是睡眠时间接近指定的延迟时间。当指定的时间到期后，内核唤醒被延迟的任务并将其重新放回运行队列。用法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_current_state(TASK_INTERRUPTIBLE);    <span class="comment">//将任务设置为可中断睡眠状态</span></span><br><span class="line">schedule_timeout(s*HZ);    <span class="comment">//小睡一会儿，“s”秒后唤醒</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>唯一的参数是延迟的相对时间，单位是<code>jiffies</code>，上例中将相应的任务推入可中断睡眠队列，睡眠<code>s</code>秒。在调用函数<code>schedule_timeout</code>之前，不要要将任务设置成可中断或不和中断的一种，否则任务不会休眠。这个函数需要调用调度程序，所以调用它的代码必须保证能够睡眠，简而言之，调用代码必须处于进程上下文中，并且不能持有锁。</p>
<p>事实上<code>schedule_timeout()</code>函数的实现就是内核定时器的一个简单应用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">long</span> __sched <span class="title function_">schedule_timeout</span><span class="params">(<span class="type">signed</span> <span class="type">long</span> timeout)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expire;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> (timeout)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> MAX_SCHEDULE_TIMEOUT:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * These two special cases are useful to be comfortable</span></span><br><span class="line"><span class="comment">         * in the caller. Nothing more. We could take</span></span><br><span class="line"><span class="comment">         * MAX_SCHEDULE_TIMEOUT from one of the negative value</span></span><br><span class="line"><span class="comment">         * but I&#x27; d like to return a valid offset (&gt;=0) to allow</span></span><br><span class="line"><span class="comment">         * the caller to do everything it want with the retval.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        schedule();</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Another bit of PARANOID. Note that the retval will be</span></span><br><span class="line"><span class="comment">         * 0 since no piece of kernel is supposed to do a check</span></span><br><span class="line"><span class="comment">         * for a negative retval of schedule_timeout() (since it</span></span><br><span class="line"><span class="comment">         * should never happens anyway). You just have the printk()</span></span><br><span class="line"><span class="comment">         * that will tell you if something is gone wrong and where.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            printk(KERN_ERR <span class="string">&quot;schedule_timeout: wrong timeout &quot;</span></span><br><span class="line">                <span class="string">&quot;value %lx\n&quot;</span>, timeout);</span><br><span class="line">            dump_stack();</span><br><span class="line">            current-&gt;state = TASK_RUNNING;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    expire = timeout + jiffies;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//下一行代码设置了超时执行函数`process_timeout()。</span></span><br><span class="line">    setup_timer_on_stack(&amp;timer, process_timeout, (<span class="type">unsigned</span> <span class="type">long</span>)current);</span><br><span class="line">    __mod_timer(&amp;timer, expire, <span class="literal">false</span>, TIMER_NOT_PINNED);    <span class="comment">//激活定时器</span></span><br><span class="line">    schedule();    <span class="comment">//调度其他新任务</span></span><br><span class="line">    del_singleshot_timer_sync(&amp;timer);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Remove the timer from the object tracker */</span></span><br><span class="line">    destroy_timer_on_stack(&amp;timer);</span><br><span class="line"> </span><br><span class="line">    timeout = expire - jiffies;</span><br><span class="line"> </span><br><span class="line"> out:</span><br><span class="line">    <span class="keyword">return</span> timeout &lt; <span class="number">0</span> ? <span class="number">0</span> : timeout;</span><br><span class="line">&#125;</span><br><span class="line">当定时器超时时，process_timeout()函数被调用：</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">process_timeout</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> __data)</span> </span><br><span class="line">&#123;</span><br><span class="line">    wake_up_process((<span class="keyword">struct</span> task_struct *)__data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当任务被重新调度时，将返回代码进入睡眠前的位置继续执行，位置正好在<code>schedule()</code>处。</p>
<p>进程上下文的代码为了等待特定时间发生，可以将自己放入等待队列。但是，等待队列上的某个任务可能既在等待一个特定事件到来，又在等待一个特定时间到期，就看谁来得更快。这种情况下，代码可以简单的使用<code>scedule_timeout()</code>函数代替<code>schedule()</code>函数，这样一来，当希望指定时间到期后，任务都会被唤醒，当然，代码需要检查被唤醒的原因，有可能是被事件唤醒，也有可能是因为延迟的时间到期，还可能是因为接收到了信号，然后执行相应的操作。</p>
<h1 id="进程管理分析"><a href="#进程管理分析" class="headerlink" title="进程管理分析"></a>进程管理分析</h1><p>进程其实就是程序的执行时的实例，是处于执行期的程序。在Linux内核中，进程列表被存放在一个双向循环链表中，链表中每一项都是类型为<code>task_struct</code>的结构，该结构称作进程描述符，进程描述符包含一个具体进程的所有信息，这个结构就是我们在操作系统中所说的PCB（Process Control Block）。该结构定义于<code>&lt;include/linux/sched.h&gt;</code>文件中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> state;    <span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">    <span class="type">void</span> *<span class="built_in">stack</span>;</span><br><span class="line">    <span class="type">atomic_t</span> usage;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags; <span class="comment">/* per process flags, defined below */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ptrace;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> lock_depth;     <span class="comment">/* BKL lock depth */</span></span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> prio, static_prio, normal_prio;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> rt_priority;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> <span class="title">se</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> <span class="title">rt</span>;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>;</span> <span class="comment">/* recipient of SIGCHLD, wait4() reports */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span>  <span class="comment">/* list of my children */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span>   <span class="comment">/* linkage in my parent&#x27;s children list */</span></span><br><span class="line">    ......</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></p>
<p>该结构体中包含的数据可以完整的描述一个正在执行的程序：打开的文件、进程的地址空间、挂起的信号、进程的状态、以及其他很多信息。</p>
<p>在系统运行过程中，进程频繁切换，所以我们需要一种方式能够快速获得当前进程的<code>task_struct</code>，于是进程内核堆栈底部存放着<code>struct thread_info</code>。该结构中有一个成员指向当前进程的<code>task_struct</code>。在x86上，<code>struct thread_info</code>在文件<code>&lt;arch/x86/include/asm/thread_info.h&gt;</code>中定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>  *<span class="title">task</span>;</span>      <span class="comment">/* 该指针存放的是指向该任务实际`task_struct`的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span>  *<span class="title">exec_domain</span>;</span>   <span class="comment">/* execution domain */</span></span><br><span class="line">    __u32           flags;      <span class="comment">/* low level flags */</span></span><br><span class="line">    __u32           status;     <span class="comment">/* thread synchronous flags */</span></span><br><span class="line">    __u32           cpu;        <span class="comment">/* current CPU */</span></span><br><span class="line">    <span class="type">int</span>         preempt_count;  <span class="comment">/* 0 =&gt; preemptable, &lt;0 =&gt; BUG */</span></span><br><span class="line">    <span class="type">mm_segment_t</span>        addr_limit;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span>    <span class="title">restart_block</span>;</span></span><br><span class="line">    <span class="type">void</span> __user     *sysenter_return;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>           previous_esp;   <span class="comment">/* ESP of the previous stack in</span></span><br><span class="line"><span class="comment">                           case of nested (IRQ) stacks</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">    __u8            supervisor_stack[<span class="number">0</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span>         uaccess_err;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><br>使用<code>current</code>宏就可以获得当前进程的进程描述符。</p>
<p>每一个进程都有一个父进程，每个进程管理自己的子进程。每个进程都是<code>init</code>进程的子进程，<code>init</code>进程在内 核系统启动的最后阶段启动<code>init</code>进程，该进程读取系统的初始化脚本并执行其他相关程序，最终完成系统启动的整个过程。每个进程有0个或多个子进程，进程间的关系存放在进程描述符中。<code>task_struct</code>中有一个<code>parent</code>的指针，指向其父进程；还有个<code>children</code>的指针指向其子进程的链表。所以，对于当前进程，可以通过<code>current</code>宏来获得父进程和子进程的进程描述符。</p>
<p>下面程序打印当前进程、父进程信息和所有子进程信息：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">sln_taskstruct_do</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>  *<span class="title">cur</span>,</span></span><br><span class="line"><span class="class">                        *<span class="title">parent</span>,</span></span><br><span class="line"><span class="class">                        *<span class="title">task</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    *<span class="title">first_child</span>,</span></span><br><span class="line"><span class="class">                        *<span class="title">child_list</span>,</span></span><br><span class="line"><span class="class">                        *<span class="title">cur_chd</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取当前进程信息</span></span><br><span class="line">    cur = current;</span><br><span class="line"> </span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;Current: %s[%d]\n&quot;</span>,</span><br><span class="line">            cur-&gt;comm, cur-&gt;pid);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取父进程信息</span></span><br><span class="line">    parent = current-&gt;parent;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;Parent: %s[%d]\n&quot;</span>,</span><br><span class="line">            parent-&gt;comm, parent-&gt;pid);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取所有祖先进程信息</span></span><br><span class="line">    <span class="keyword">for</span> (task = cur; task != &amp;init_task; task = task-&gt;parent) &#123;</span><br><span class="line">        printk(KERN_ALERT<span class="string">&quot;ancestor: %s[%d]\n&quot;</span>,                                          </span><br><span class="line">            task-&gt;comm, task-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取所有子进程信息</span></span><br><span class="line">    child_list = &amp;cur-&gt;children;</span><br><span class="line">    first_child = &amp;cur-&gt;children;</span><br><span class="line">    <span class="keyword">for</span> (cur_chd = child_list-&gt;next;</span><br><span class="line">            cur_chd != first_child;</span><br><span class="line">            cur_chd = cur_chd-&gt;next) &#123;</span><br><span class="line">        task = list_entry(child_list, <span class="keyword">struct</span> task_struct, sibling);</span><br><span class="line"> </span><br><span class="line">        printk(KERN_ALERT<span class="string">&quot;Children: %s[%d]\n&quot;</span>,</span><br><span class="line">            task-&gt;comm, task-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">sln_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line"> </span><br><span class="line">    sln_taskstruct_do();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">sln_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(sln_init);</span><br><span class="line">module_exit(sln_exit);</span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;shallnet&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;blog.csdn.net/shallnet&quot;</span>);</span><br></pre></td></tr></table></figure><br>执行结果如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># insmod task.ko</span></span><br><span class="line">===sln_init===</span><br><span class="line">Current: insmod[4315]</span><br><span class="line">Parent: bash[4032]</span><br><span class="line">ancestor: insmod[4315]</span><br><span class="line">ancestor: bash[4032]</span><br><span class="line">ancestor: login[2563]</span><br><span class="line">ancestor: init[1]</span><br></pre></td></tr></table></figure></p>
<p>Linux操作系统提供产生进程的机制，在Linux下的<code>fork()</code>使用<strong>写时拷贝(copy-on-write)</strong>页实现。这种技术原理是：内存并不复制整个进程地址空间，而是让父进程和子进程共享同一拷贝，只有在需要写入的时候，数据才会被复制。也就是资源的复制只是发生在需要写入的时候才进行，在此之前都是以只读的方式共享。</p>
<p>Linux通过<code>clone()</code>系统调用实现<code>fork()</code>，然后<code>clone()</code>去调用<code>do_fork()</code>，<code>do_fork()</code>完成创建中大部分工作。库函数<code>vfork()</code>、<code>__clone()</code>都根据各自需要的参数标志去调用<code>clone()</code>。<code>fork()</code>的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。<br>用户空间的<code>fork()</code>经过系统调用进入内核，在内核中对应的处理函数为<code>sys_fork()</code>，定义于<code>&lt;arch/x86/kernel/process.c&gt;</code>文件中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sys_fork</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">do_fork</span>(SIGCHLD, regs-&gt;sp, regs, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">do_fork</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">unsigned</span> <span class="type">long</span> stack_start,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> pt_regs *regs,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">unsigned</span> <span class="type">long</span> stack_size,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> __user *parent_tidptr,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> __user *child_tidptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *p;</span><br><span class="line">    <span class="type">int</span> trace = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> nr;</span><br><span class="line">    ......</span><br><span class="line">    p = <span class="built_in">copy_process</span>(clone_flags, stack_start, regs, stack_size,</span><br><span class="line">       child_tidptr, <span class="literal">NULL</span>, trace);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">task_struct</span> *<span class="built_in">copy_process</span>(<span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span><br><span class="line">                    <span class="type">unsigned</span> <span class="type">long</span> stack_start,</span><br><span class="line">                    <span class="keyword">struct</span> pt_regs *regs,</span><br><span class="line">                    <span class="type">unsigned</span> <span class="type">long</span> stack_size,</span><br><span class="line">                    <span class="type">int</span> __user *child_tidptr,</span><br><span class="line">                    <span class="keyword">struct</span> pid *pid,</span><br><span class="line">                    <span class="type">int</span> trace)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *p;</span><br><span class="line">    <span class="type">int</span> cgroup_callbacks_done = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((clone_flags &amp; (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(-EINVAL);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread groups must share signals as well, and detached threads</span></span><br><span class="line"><span class="comment">     * can only be started up within the thread group.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((clone_flags &amp; CLONE_THREAD) &amp;&amp; !(clone_flags &amp; CLONE_SIGHAND))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(-EINVAL);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Shared signal handlers imply shared VM. By way of the above,</span></span><br><span class="line"><span class="comment">     * thread groups also imply shared VM. Blocking this case allows</span></span><br><span class="line"><span class="comment">     * for various simplifications in other code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((clone_flags &amp; CLONE_SIGHAND) &amp;&amp; !(clone_flags &amp; CLONE_VM))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(-EINVAL);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Siblings of global init remain as zombies on exit since they are</span></span><br><span class="line"><span class="comment">     * not reaped by their parent (swapper). To solve this and to avoid</span></span><br><span class="line"><span class="comment">     * multi-rooted process trees, prevent global and container-inits</span></span><br><span class="line"><span class="comment">     * from creating siblings.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((clone_flags &amp; CLONE_PARENT) &amp;&amp;</span><br><span class="line">                current-&gt;signal-&gt;flags &amp; SIGNAL_UNKILLABLE)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(-EINVAL);</span><br><span class="line">    retval = <span class="built_in">security_task_create</span>(clone_flags);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    retval = -ENOMEM;</span><br><span class="line">    p = <span class="built_in">dup_task_struct</span>(current);</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    <span class="built_in">ftrace_graph_init_task</span>(p);</span><br><span class="line">    <span class="built_in">rt_mutex_init_task</span>(p);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROVE_LOCKING</span></span><br><span class="line">    <span class="built_in">DEBUG_LOCKS_WARN_ON</span>(!p-&gt;hardirqs_enabled);</span><br><span class="line">    <span class="built_in">DEBUG_LOCKS_WARN_ON</span>(!p-&gt;softirqs_enabled);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    retval = -EAGAIN;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">atomic_read</span>(&amp;p-&gt;real_cred-&gt;user-&gt;processes) &gt;=</span><br><span class="line">            p-&gt;signal-&gt;rlim[RLIMIT_NPROC].rlim_cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">capable</span>(CAP_SYS_ADMIN) &amp;&amp; !<span class="built_in">capable</span>(CAP_SYS_RESOURCE) &amp;&amp;</span><br><span class="line">            p-&gt;real_cred-&gt;user != INIT_USER)</span><br><span class="line">            <span class="keyword">goto</span> bad_fork_free;</span><br><span class="line">    &#125;</span><br><span class="line">    retval = <span class="built_in">copy_creds</span>(p, clone_flags);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_free;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If multiple threads are within copy_process(), then this check</span></span><br><span class="line"><span class="comment">     * triggers too late. This doesn&#x27;t hurt, the check is only there</span></span><br><span class="line"><span class="comment">     * to stop root fork bombs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    retval = -EAGAIN;</span><br><span class="line">    <span class="keyword">if</span> (nr_threads &gt;= max_threads)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_count;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">try_module_get</span>(<span class="built_in">task_thread_info</span>(p)-&gt;exec_domain-&gt;<span class="keyword">module</span>))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_count;</span><br><span class="line">    p-&gt;did_exec = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">delayacct_tsk_init</span>(p);  <span class="comment">/* Must remain after dup_task_struct() */</span></span><br><span class="line">    <span class="built_in">copy_flags</span>(clone_flags, p);</span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;p-&gt;children);</span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;p-&gt;sibling);</span><br><span class="line">    <span class="built_in">rcu_copy_process</span>(p);</span><br><span class="line">    p-&gt;vfork_done = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">spin_lock_init</span>(&amp;p-&gt;alloc_lock);</span><br><span class="line">    <span class="built_in">init_sigpending</span>(&amp;p-&gt;pending);</span><br><span class="line">    p-&gt;utime = cputime_zero;</span><br><span class="line">    p-&gt;stime = cputime_zero;</span><br><span class="line">    p-&gt;gtime = cputime_zero;</span><br><span class="line">    p-&gt;utimescaled = cputime_zero;</span><br><span class="line">    p-&gt;stimescaled = cputime_zero;</span><br><span class="line">    p-&gt;prev_utime = cputime_zero;</span><br><span class="line">    p-&gt;prev_stime = cputime_zero;</span><br><span class="line">    p-&gt;default_timer_slack_ns = current-&gt;timer_slack_ns;</span><br><span class="line">    <span class="built_in">task_io_accounting_init</span>(&amp;p-&gt;ioac);</span><br><span class="line">    <span class="built_in">acct_clear_integrals</span>(p);</span><br><span class="line">    <span class="built_in">posix_cpu_timers_init</span>(p);</span><br><span class="line">    p-&gt;lock_depth = <span class="number">-1</span>;     <span class="comment">/* -1 = no lock */</span></span><br><span class="line">    <span class="built_in">do_posix_clock_monotonic_gettime</span>(&amp;p-&gt;start_time);</span><br><span class="line">    p-&gt;real_start_time = p-&gt;start_time;</span><br><span class="line">    <span class="built_in">monotonic_to_bootbased</span>(&amp;p-&gt;real_start_time);</span><br><span class="line">    p-&gt;io_context = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;audit_context = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">cgroup_fork</span>(p);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    p-&gt;mempolicy = <span class="built_in">mpol_dup</span>(p-&gt;mempolicy);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(p-&gt;mempolicy)) &#123;</span><br><span class="line">        retval = <span class="built_in">PTR_ERR</span>(p-&gt;mempolicy);</span><br><span class="line">        p-&gt;mempolicy = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_cgroup;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mpol_fix_fork_child_flag</span>(p);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">    p-&gt;irq_events = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ARCH_WANT_INTERRUPTS_ON_CTXSW</span></span><br><span class="line">    p-&gt;hardirqs_enabled = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    p-&gt;hardirqs_enabled = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    p-&gt;hardirq_enable_ip = <span class="number">0</span>;</span><br><span class="line">    p-&gt;hardirq_enable_event = <span class="number">0</span>;</span><br><span class="line">    p-&gt;hardirq_disable_ip = _THIS_IP_;</span><br><span class="line">    p-&gt;hardirq_disable_event = <span class="number">0</span>;</span><br><span class="line">    p-&gt;softirqs_enabled = <span class="number">1</span>;</span><br><span class="line">    p-&gt;softirq_enable_ip = _THIS_IP_;</span><br><span class="line">    p-&gt;softirq_enable_event = <span class="number">0</span>;</span><br><span class="line">    p-&gt;softirq_disable_ip = <span class="number">0</span>;</span><br><span class="line">    p-&gt;softirq_disable_event = <span class="number">0</span>;</span><br><span class="line">    p-&gt;hardirq_context = <span class="number">0</span>;</span><br><span class="line">    p-&gt;softirq_context = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    p-&gt;lockdep_depth = <span class="number">0</span>; <span class="comment">/* no locks held yet */</span></span><br><span class="line">    p-&gt;curr_chain_key = <span class="number">0</span>;</span><br><span class="line">    p-&gt;lockdep_recursion = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">    p-&gt;blocked_on = <span class="literal">NULL</span>; <span class="comment">/* not blocked yet */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    p-&gt;bts = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;stack_start = stack_start;</span><br><span class="line">    <span class="comment">/* Perform scheduler related setup. Assign this task to a CPU. */</span></span><br><span class="line">    <span class="built_in">sched_fork</span>(p, clone_flags);</span><br><span class="line">    retval = <span class="built_in">perf_event_init_task</span>(p);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_policy;</span><br><span class="line">    <span class="keyword">if</span> ((retval = <span class="built_in">audit_alloc</span>(p)))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_policy;</span><br><span class="line">    <span class="comment">/* copy all the process information */</span></span><br><span class="line">    <span class="keyword">if</span> ((retval = <span class="built_in">copy_semundo</span>(clone_flags, p)))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_audit;</span><br><span class="line">    <span class="keyword">if</span> ((retval = <span class="built_in">copy_files</span>(clone_flags, p)))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_semundo;</span><br><span class="line">    <span class="keyword">if</span> ((retval = <span class="built_in">copy_fs</span>(clone_flags, p)))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_files;</span><br><span class="line">    <span class="keyword">if</span> ((retval = <span class="built_in">copy_sighand</span>(clone_flags, p)))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_fs;</span><br><span class="line">    <span class="keyword">if</span> ((retval = <span class="built_in">copy_signal</span>(clone_flags, p)))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_sighand;</span><br><span class="line">    <span class="keyword">if</span> ((retval = <span class="built_in">copy_mm</span>(clone_flags, p)))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_signal;</span><br><span class="line">    <span class="keyword">if</span> ((retval = <span class="built_in">copy_namespaces</span>(clone_flags, p)))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_mm;</span><br><span class="line">    <span class="keyword">if</span> ((retval = <span class="built_in">copy_io</span>(clone_flags, p)))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_namespaces;</span><br><span class="line">    retval = <span class="built_in">copy_thread</span>(clone_flags, stack_start, stack_size, p, regs);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_io;</span><br><span class="line">    <span class="keyword">if</span> (pid != &amp;init_struct_pid) &#123;</span><br><span class="line">        retval = -ENOMEM;</span><br><span class="line">        pid = <span class="built_in">alloc_pid</span>(p-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line">        <span class="keyword">if</span> (!pid)</span><br><span class="line">            <span class="keyword">goto</span> bad_fork_cleanup_io;</span><br><span class="line">        <span class="keyword">if</span> (clone_flags &amp; CLONE_NEWPID) &#123;</span><br><span class="line">            retval = <span class="built_in">pid_ns_prepare_proc</span>(p-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line">            <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> bad_fork_free_pid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;pid = <span class="built_in">pid_nr</span>(pid);</span><br><span class="line">    p-&gt;tgid = p-&gt;pid;</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD)</span><br><span class="line">        p-&gt;tgid = current-&gt;tgid;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;nsproxy != p-&gt;nsproxy) &#123;</span><br><span class="line">        retval = <span class="built_in">ns_cgroup_clone</span>(p, pid);</span><br><span class="line">        <span class="keyword">if</span> (retval)</span><br><span class="line">            <span class="keyword">goto</span> bad_fork_free_pid;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;set_child_tid = (clone_flags &amp; CLONE_CHILD_SETTID) ? child_tidptr : <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Clear TID on mm_release()?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    p-&gt;clear_child_tid = (clone_flags &amp; CLONE_CHILD_CLEARTID) ? child_tidptr: <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FUTEX</span></span><br><span class="line">    p-&gt;robust_list = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">    p-&gt;compat_robust_list = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;p-&gt;pi_state_list);</span><br><span class="line">    p-&gt;pi_state_cache = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * sigaltstack should be cleared when sharing the same VM</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((clone_flags &amp; (CLONE_VM|CLONE_VFORK)) == CLONE_VM)</span><br><span class="line">        p-&gt;sas_ss_sp = p-&gt;sas_ss_size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Syscall tracing should be turned off in the child regardless</span></span><br><span class="line"><span class="comment">     * of CLONE_PTRACE.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">clear_tsk_thread_flag</span>(p, TIF_SYSCALL_TRACE);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TIF_SYSCALL_EMU</span></span><br><span class="line">    <span class="built_in">clear_tsk_thread_flag</span>(p, TIF_SYSCALL_EMU);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">clear_all_latency_tracing</span>(p);</span><br><span class="line">    <span class="comment">/* ok, now we should be set up.. */</span></span><br><span class="line">    p-&gt;exit_signal = (clone_flags &amp; CLONE_THREAD) ? <span class="number">-1</span> : (clone_flags &amp; CSIGNAL);</span><br><span class="line">    p-&gt;pdeath_signal = <span class="number">0</span>;</span><br><span class="line">    p-&gt;exit_state = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ok, make it visible to the rest of the system.</span></span><br><span class="line"><span class="comment">     * We dont wake it up yet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    p-&gt;group_leader = p;</span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;p-&gt;thread_group);</span><br><span class="line">    <span class="comment">/* Now that the task is set up, run cgroup callbacks if</span></span><br><span class="line"><span class="comment">     * necessary. We need to run them before the task is visible</span></span><br><span class="line"><span class="comment">     * on the tasklist. */</span></span><br><span class="line">    <span class="built_in">cgroup_fork_callbacks</span>(p);</span><br><span class="line">    cgroup_callbacks_done = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Need tasklist lock for parent etc handling! */</span></span><br><span class="line">    <span class="built_in">write_lock_irq</span>(&amp;tasklist_lock);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The task hasn&#x27;t been attached yet, so its cpus_allowed mask will</span></span><br><span class="line"><span class="comment">     * not be changed, nor will its assigned CPU.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The cpus_allowed mask of the parent may have changed after it was</span></span><br><span class="line"><span class="comment">     * copied first time - so re-copy it here, then check the child&#x27;s CPU</span></span><br><span class="line"><span class="comment">     * to ensure it is on a valid CPU (and if not, just force it back to</span></span><br><span class="line"><span class="comment">     * parent&#x27;s CPU). This avoids alot of nasty races.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    p-&gt;cpus_allowed = current-&gt;cpus_allowed;</span><br><span class="line">    p-&gt;rt.nr_cpus_allowed = current-&gt;rt.nr_cpus_allowed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlikely</span>(!<span class="built_in">cpu_isset</span>(<span class="built_in">task_cpu</span>(p), p-&gt;cpus_allowed) ||</span><br><span class="line">            !<span class="built_in">cpu_online</span>(<span class="built_in">task_cpu</span>(p))))</span><br><span class="line">        <span class="built_in">set_task_cpu</span>(p, <span class="built_in">smp_processor_id</span>());</span><br><span class="line">    <span class="comment">/* CLONE_PARENT re-uses the old parent */</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; (CLONE_PARENT|CLONE_THREAD)) &#123;</span><br><span class="line">        p-&gt;real_parent = current-&gt;real_parent;</span><br><span class="line">        p-&gt;parent_exec_id = current-&gt;parent_exec_id;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;real_parent = current;</span><br><span class="line">        p-&gt;parent_exec_id = current-&gt;self_exec_id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spin_lock</span>(¤t-&gt;sighand-&gt;siglock);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Process group and session signals need to be delivered to just the</span></span><br><span class="line"><span class="comment">     * parent before the fork or both the parent and the child after the</span></span><br><span class="line"><span class="comment">     * fork. Restart if a signal comes in before we add the new process to</span></span><br><span class="line"><span class="comment">     * it&#x27;s process group.</span></span><br><span class="line"><span class="comment">     * A fatal signal pending means that current will exit, so the new</span></span><br><span class="line"><span class="comment">     * thread can&#x27;t slip out of an OOM kill (or normal SIGKILL).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">recalc_sigpending</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal_pending</span>(current)) &#123;</span><br><span class="line">        <span class="built_in">spin_unlock</span>(¤t-&gt;sighand-&gt;siglock);</span><br><span class="line">        <span class="built_in">write_unlock_irq</span>(&amp;tasklist_lock);</span><br><span class="line">        retval = -ERESTARTNOINTR;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_free_pid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD) &#123;</span><br><span class="line">        <span class="built_in">atomic_inc</span>(¤t-&gt;signal-&gt;count);</span><br><span class="line">        <span class="built_in">atomic_inc</span>(¤t-&gt;signal-&gt;live);</span><br><span class="line">        p-&gt;group_leader = current-&gt;group_leader;</span><br><span class="line">        <span class="built_in">list_add_tail_rcu</span>(&amp;p-&gt;thread_group, &amp;p-&gt;group_leader-&gt;thread_group);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">likely</span>(p-&gt;pid)) &#123;</span><br><span class="line">        <span class="built_in">list_add_tail</span>(&amp;p-&gt;sibling, &amp;p-&gt;real_parent-&gt;children);</span><br><span class="line">        <span class="built_in">tracehook_finish_clone</span>(p, clone_flags, trace);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">thread_group_leader</span>(p)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clone_flags &amp; CLONE_NEWPID)</span><br><span class="line">                p-&gt;nsproxy-&gt;pid_ns-&gt;child_reaper = p;</span><br><span class="line">            p-&gt;signal-&gt;leader_pid = pid;</span><br><span class="line">            <span class="built_in">tty_kref_put</span>(p-&gt;signal-&gt;tty);</span><br><span class="line">            p-&gt;signal-&gt;tty = <span class="built_in">tty_kref_get</span>(current-&gt;signal-&gt;tty);</span><br><span class="line">            <span class="built_in">attach_pid</span>(p, PIDTYPE_PGID, <span class="built_in">task_pgrp</span>(current));</span><br><span class="line">            <span class="built_in">attach_pid</span>(p, PIDTYPE_SID, <span class="built_in">task_session</span>(current));</span><br><span class="line">            <span class="built_in">list_add_tail_rcu</span>(&amp;p-&gt;tasks, &amp;init_task.tasks);</span><br><span class="line">            __get_cpu_var(process_counts)++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">attach_pid</span>(p, PIDTYPE_PID, pid);</span><br><span class="line">        nr_threads++;</span><br><span class="line">    &#125;</span><br><span class="line">    total_forks++;</span><br><span class="line">    <span class="built_in">spin_unlock</span>(¤t-&gt;sighand-&gt;siglock);</span><br><span class="line">    <span class="built_in">write_unlock_irq</span>(&amp;tasklist_lock);</span><br><span class="line">    <span class="built_in">proc_fork_connector</span>(p);</span><br><span class="line">    <span class="built_in">cgroup_post_fork</span>(p);</span><br><span class="line">    <span class="built_in">perf_event_fork</span>(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">bad_fork_free_pid:</span><br><span class="line">    <span class="keyword">if</span> (pid != &amp;init_struct_pid)</span><br><span class="line">        <span class="built_in">free_pid</span>(pid);</span><br><span class="line">bad_fork_cleanup_io:</span><br><span class="line">    <span class="built_in">put_io_context</span>(p-&gt;io_context);</span><br><span class="line">bad_fork_cleanup_namespaces:</span><br><span class="line">    <span class="built_in">exit_task_namespaces</span>(p);</span><br><span class="line">bad_fork_cleanup_mm:</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;mm)</span><br><span class="line">        <span class="built_in">mmput</span>(p-&gt;mm);</span><br><span class="line">bad_fork_cleanup_signal:</span><br><span class="line">    <span class="keyword">if</span> (!(clone_flags &amp; CLONE_THREAD))</span><br><span class="line">        __cleanup_signal(p-&gt;signal);</span><br><span class="line">bad_fork_cleanup_sighand:</span><br><span class="line">    __cleanup_sighand(p-&gt;sighand);</span><br><span class="line">bad_fork_cleanup_fs:</span><br><span class="line">    <span class="built_in">exit_fs</span>(p); <span class="comment">/* blocking */</span></span><br><span class="line">bad_fork_cleanup_files:</span><br><span class="line">    <span class="built_in">exit_files</span>(p); <span class="comment">/* blocking */</span></span><br><span class="line">bad_fork_cleanup_semundo:</span><br><span class="line">    <span class="built_in">exit_sem</span>(p);</span><br><span class="line">bad_fork_cleanup_audit:</span><br><span class="line">    <span class="built_in">audit_free</span>(p);</span><br><span class="line">bad_fork_cleanup_policy:</span><br><span class="line">    <span class="built_in">perf_event_free_task</span>(p);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="built_in">mpol_put</span>(p-&gt;mempolicy);</span><br><span class="line">bad_fork_cleanup_cgroup:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">cgroup_exit</span>(p, cgroup_callbacks_done);</span><br><span class="line">    <span class="built_in">delayacct_tsk_free</span>(p);</span><br><span class="line">    <span class="built_in">module_put</span>(<span class="built_in">task_thread_info</span>(p)-&gt;exec_domain-&gt;<span class="keyword">module</span>);</span><br><span class="line">bad_fork_cleanup_count:</span><br><span class="line">    <span class="built_in">atomic_dec</span>(&amp;p-&gt;cred-&gt;user-&gt;processes);</span><br><span class="line">    <span class="built_in">exit_creds</span>(p);</span><br><span class="line">bad_fork_free:</span><br><span class="line">    <span class="built_in">free_task</span>(p);</span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面执行完以后，回到<code>do_fork()</code>函数，如果<code>copy_process()</code>函数成功返回。新创建的子进程被唤醒并让其投入运行。内核有意选择子进程先运行。因为一般子进程都会马上调用<code>exec()</code>函数，这样可以避免写时拷贝的额外开销。如果父进程首先执行的话，有可能会开始向地址空间写入。</p>
<p>线程机制提供了在同一程序内共享内存地址空间运行的一组线程。线程机制支持并发程序设计技术，可以共享打开的文件和其他资源。如果你的系统是多核心的，那多线程技术可保证系统的真正并行。在Linux中，并没有线程这个概念，Linux中所有的线程都当作进程来处理，换句话说就是在内核中并没有什么特殊的结构和算法来表示线程。在Linux中，线程仅仅是一个使用共享资源的进程。每个线程都拥有一个隶属于自己的<code>task_struct</code>。所以说线程本质上还是进程，只不过该进程可以和其他一些进程共享某些资源信息。</p>
<p>内核有时需要在后台执行一些操作，这种任务可以通过内核线程完成，内核线程独立运行在内核空间的标准进程。内核线程和普通的进程间的区别在于内核线程没有独立的地址空间。它们只在讷河空间运行，从来不切换到用户空间去。内核进程和普通进程一样，可以被调度，也可以被抢占。内核线程也只能由其它内核线程创建，内核是通过从<code>kthreadd</code>内核进程中衍生出所有新的内核线程来自动处理这一点的。在内核中创建一个的内核线程方法如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">kthread_create</span><span class="params">(<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data),</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">char</span> namefmt[], ...)</span></span><br></pre></td></tr></table></figure><br>该函数实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">kthread_create</span><span class="params">(<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data),</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">char</span> namefmt[],</span></span><br><span class="line"><span class="params">                   ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kthread_create_info</span> <span class="title">create</span>;</span></span><br><span class="line">    create.threadfn = threadfn;</span><br><span class="line">    create.data = data;</span><br><span class="line">    init_completion(&amp;create.done);</span><br><span class="line">    spin_lock(&amp;kthread_create_lock);</span><br><span class="line">    list_add_tail(&amp;create.<span class="built_in">list</span>, &amp;kthread_create_list);</span><br><span class="line">    spin_unlock(&amp;kthread_create_lock);</span><br><span class="line">    wake_up_process(kthreadd_task);</span><br><span class="line">    wait_for_completion(&amp;create.done);</span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(create.result)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> =</span> &#123; .sched_priority = <span class="number">0</span> &#125;;</span><br><span class="line">        va_list args;</span><br><span class="line">        va_start(args, namefmt);</span><br><span class="line">        vsnprintf(create.result-&gt;comm, <span class="keyword">sizeof</span>(create.result-&gt;comm),</span><br><span class="line">              namefmt, args);</span><br><span class="line">        va_end(args);</span><br><span class="line">        <span class="comment">/*  </span></span><br><span class="line"><span class="comment">         * root may have changed our (kthreadd&#x27;s) priority or CPU mask.</span></span><br><span class="line"><span class="comment">         * The kernel thread should not inherit these properties.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        sched_setscheduler_nocheck(create.result, SCHED_NORMAL, ¶m);</span><br><span class="line">        set_cpus_allowed_ptr(create.result, cpu_all_mask);</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure></p>
<p>新的任务是由<code>kthread</code>内核进程通过<code>clone()</code>系统调用而创建的。新的进程将运行<code>threadfn</code>函数，给其传递参数<code>data</code>，新的进程名称为<code>namefmt</code>，新创建的进程处于不可运行状态，需要调用<code>wake_up_process()</code>明确的唤醒它，否则它不会主动运行。也可以通过调用<code>kthread_run()</code>来创建一个进程并让它运行起来。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> kthread_run(threadfn, data, namefmt, ...)              \                        </span></span><br><span class="line">(&#123;                                     \</span><br><span class="line">    <span class="keyword">struct</span> task_struct *__k                        \</span><br><span class="line">        = kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \</span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(__k))                          \</span><br><span class="line">        wake_up_process(__k);                      \</span><br><span class="line">    __k;                                   \</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure></p>
<p><code>kthread_run</code>其实就是创建了一个内核线程并且唤醒了。内核线程启动后就一直运行直到调用<code>do_exit()</code>退出或者内核的其他部分调用<code>kthread_stop()</code>退出。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kthread_stop</span><span class="params">(<span class="keyword">struct</span> task_struct *k)</span>; </span><br></pre></td></tr></table></figure><br>下面为一个使用内核线程的示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span>  <span class="comment">//schdule_timeout()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kthread.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>  *<span class="title">sln_task</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sln_kthread_func</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (!kthread_should_stop()) &#123;</span><br><span class="line">        printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line">        set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">        schedule_timeout(<span class="number">2</span>*HZ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sln_init_do</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">9527</span>;</span><br><span class="line">    sln_task = kthread_create(sln_kthread_func,</span><br><span class="line">            &amp;data,</span><br><span class="line">            <span class="string">&quot;sln_kthread_task&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(sln_task)) &#123;</span><br><span class="line">        printk(KERN_ALERT<span class="string">&quot;kthread_create() failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    wake_up_process(sln_task);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sln_exit_do</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != sln_task) &#123;</span><br><span class="line">        kthread_stop(sln_task);</span><br><span class="line">        sln_task = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">sln_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line">    sln_init_do();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">sln_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;===%s===\n&quot;</span>, __func__);</span><br><span class="line">    sln_exit_do();</span><br><span class="line">&#125;</span><br><span class="line">module_init(sln_init);</span><br><span class="line">module_exit(sln_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;shallnet&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;blog.csdn.net/shallnet&quot;</span>); </span><br></pre></td></tr></table></figure></p>
<p>既然有进程的创建，那就有进程的终结，终结时内核必须释放它所占有的资源。内核终结时，大部分任务都是靠<code>do_exit()</code>来完成。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">NORET_TYPE <span class="type">void</span> <span class="title function_">do_exit</span><span class="params">(<span class="type">long</span> code)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> current;</span><br><span class="line">    <span class="type">int</span> group_dead;</span><br><span class="line">    profile_task_exit(tsk);</span><br><span class="line">    WARN_ON(<span class="type">atomic_read</span>(&amp;tsk-&gt;fs_excl));</span><br><span class="line">   <span class="comment">//不可在中断上下文中使用该函数</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(in_interrupt()))</span><br><span class="line">        panic(<span class="string">&quot;Aiee, killing interrupt handler!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!tsk-&gt;pid))</span><br><span class="line">        panic(<span class="string">&quot;Attempted to kill the idle task!&quot;</span>);</span><br><span class="line">    tracehook_report_exit(&amp;code);</span><br><span class="line">    validate_creds_for_do_exit(tsk);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We&#x27;re taking recursive faults here in do_exit. Safest is to just</span></span><br><span class="line"><span class="comment">     * leave this task alone and wait for reboot.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(tsk-&gt;flags &amp; PF_EXITING)) &#123;</span><br><span class="line">        printk(KERN_ALERT</span><br><span class="line">            <span class="string">&quot;Fixing recursive fault but reboot is needed!\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//设置PF_EXITING:表示进程正在退出</span></span><br><span class="line">        tsk-&gt;flags |= PF_EXITPIDONE;</span><br><span class="line">        set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    exit_irq_thread();</span><br><span class="line">    exit_signals(tsk);  <span class="comment">/* sets PF_EXITING */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * tsk-&gt;flags are checked in the futex code to protect against</span></span><br><span class="line"><span class="comment">     * an exiting task cleaning up the robust pi futexes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    smp_mb();</span><br><span class="line">    spin_unlock_wait(&amp;tsk-&gt;pi_lock);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(in_atomic()))</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;note: %s[%d] exited with preempt_count %d\n&quot;</span>,</span><br><span class="line">                current-&gt;comm, task_pid_nr(current),</span><br><span class="line">                preempt_count());</span><br><span class="line">    acct_update_integrals(tsk);</span><br><span class="line">    group_dead = atomic_dec_and_test(&amp;tsk-&gt;signal-&gt;live);</span><br><span class="line">    <span class="keyword">if</span> (group_dead) &#123;</span><br><span class="line">        hrtimer_cancel(&amp;tsk-&gt;signal-&gt;real_timer);</span><br><span class="line">        exit_itimers(tsk-&gt;signal);</span><br><span class="line">        <span class="keyword">if</span> (tsk-&gt;mm)</span><br><span class="line">            setmax_mm_hiwater_rss(&amp;tsk-&gt;signal-&gt;maxrss, tsk-&gt;mm);</span><br><span class="line">    &#125;</span><br><span class="line">    acct_collect(code, group_dead);</span><br><span class="line">    <span class="keyword">if</span> (group_dead)</span><br><span class="line">        tty_audit_exit();</span><br><span class="line">    <span class="keyword">if</span> (unlikely(tsk-&gt;audit_context))</span><br><span class="line">        audit_free(tsk);</span><br><span class="line">    tsk-&gt;exit_code = code;</span><br><span class="line">    taskstats_exit(tsk, group_dead);</span><br><span class="line">       <span class="comment">//调用__exit_mm()函数放弃进程占用的mm_struct,如果没有别的进程使用它们即没被共享，就彻底释放它们</span></span><br><span class="line">    exit_mm(tsk);</span><br><span class="line">    <span class="keyword">if</span> (group_dead)</span><br><span class="line">        acct_process();</span><br><span class="line">    trace_sched_process_exit(tsk);</span><br><span class="line">    exit_sem(tsk);    <span class="comment">//调用sem_exit()函数。如果进程排队等候IPC信号，它则离开队列</span></span><br><span class="line">     <span class="comment">//分别递减文件描述符，文件系统数据等的引用计数。当引用计数的值为0时，就代表没有进程在使用这些资源，此时就释放</span></span><br><span class="line">    exit_files(tsk);</span><br><span class="line">    exit_fs(tsk);</span><br><span class="line">    check_stack_usage();</span><br><span class="line">    exit_thread();</span><br><span class="line">    cgroup_exit(tsk, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (group_dead &amp;&amp; tsk-&gt;signal-&gt;leader)</span><br><span class="line">        disassociate_ctty(<span class="number">1</span>);</span><br><span class="line">    module_put(task_thread_info(tsk)-&gt;exec_domain-&gt;module);</span><br><span class="line">    proc_exit_connector(tsk);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Flush inherited counters to the parent - before the parent</span></span><br><span class="line"><span class="comment">     * gets woken up by child-exit notifications.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    perf_event_exit_task(tsk);</span><br><span class="line"><span class="comment">//调用exit_notify()向父进程发送信号，将子进程的父进程重新设置为线程组中的其他线程或init进程，并把进程状态设为TASK_ZOMBIE.</span></span><br><span class="line">    exit_notify(tsk, group_dead);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    mpol_put(tsk-&gt;mempolicy);</span><br><span class="line">    tsk-&gt;mempolicy = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FUTEX</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(current-&gt;pi_state_cache))</span><br><span class="line">        kfree(current-&gt;pi_state_cache);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Make sure we are holding no locks:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    debug_check_no_locks_held(tsk);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We can do this unlocked here. The futex code uses this flag</span></span><br><span class="line"><span class="comment">     * just to verify whether the pi state cleanup has been done</span></span><br><span class="line"><span class="comment">     * or not. In the worst case it loops once more.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tsk-&gt;flags |= PF_EXITPIDONE;</span><br><span class="line">    <span class="keyword">if</span> (tsk-&gt;io_context)</span><br><span class="line">        exit_io_context();</span><br><span class="line">    <span class="keyword">if</span> (tsk-&gt;splice_pipe)</span><br><span class="line">        __free_pipe_info(tsk-&gt;splice_pipe);</span><br><span class="line">    validate_creds_for_do_exit(tsk);</span><br><span class="line">    preempt_disable();</span><br><span class="line">    exit_rcu();</span><br><span class="line">    <span class="comment">/* causes final put_task_struct in finish_task_switch(). */</span></span><br><span class="line">    tsk-&gt;state = TASK_DEAD;</span><br><span class="line">    schedule();    <span class="comment">//调用`schedule()切换到其他进程</span></span><br><span class="line">    BUG();</span><br><span class="line">    <span class="comment">/* Avoid &quot;noreturn function does return&quot;.  */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">        cpu_relax();    <span class="comment">/* For when BUG is null */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>进程终结时所需的清理工作和进程描述符的删除被分开执行，这样尽管在调用了<code>do_exit()</code>之后，线程已经僵死不能允许情况下，系统还是保留了它的进程描述符。在父进程获得已经终结的子进程信息后，子进程的<code>task_struct</code>结构才被释放。Linux中有一系列<code>wait()</code>函数，这些函数都是基于系统调用<code>wait4()</code>实现的。它的动作就是挂起调用它的进程直到其中的一个子进程退出，此时函数会返回该退出子进程的PID。 最终释放进程描述符时，会调用<code>release_task()</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">release_task</span><span class="params">(<span class="keyword">struct</span> task_struct * p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">leader</span>;</span></span><br><span class="line">    <span class="type">int</span> zap_leader;</span><br><span class="line">repeat:</span><br><span class="line">    tracehook_prepare_release_task(p);</span><br><span class="line">    <span class="comment">/* don&#x27;t need to get the RCU readlock here - the process is dead and</span></span><br><span class="line"><span class="comment">     * can&#x27;t be modifying its own credentials */</span></span><br><span class="line">    <span class="type">atomic_dec</span>(&amp;__task_cred(p)-&gt;user-&gt;processes);</span><br><span class="line">    proc_flush_task(p);</span><br><span class="line">    write_lock_irq(&amp;tasklist_lock);</span><br><span class="line">    tracehook_finish_release_task(p);</span><br><span class="line">    __exit_signal(p);    <span class="comment">//释放目前僵死进程所使用的所有剩余资源，并进行统计记录</span></span><br><span class="line">    </span><br><span class="line">    zap_leader = <span class="number">0</span>;</span><br><span class="line">    leader = p-&gt;group_leader;</span><br><span class="line">    <span class="comment">//如果进程是线程组最后一个进程，并且领头进程已经死掉，那么就通知僵死的领头进程的父进程</span></span><br><span class="line">    <span class="keyword">if</span> (leader != p &amp;&amp; thread_group_empty(leader) &amp;&amp; leader-&gt;exit_state == EXIT_ZOMBIE)</span><br><span class="line">&#123;</span><br><span class="line">        BUG_ON(task_detached(leader));</span><br><span class="line">        do_notify_parent(leader, leader-&gt;exit_signal);</span><br><span class="line">        zap_leader = task_detached(leader);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (zap_leader)</span><br><span class="line">            leader-&gt;exit_state = EXIT_DEAD;</span><br><span class="line">    &#125;</span><br><span class="line">    write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line">    release_thread(p);</span><br><span class="line">    call_rcu(&amp;p-&gt;rcu, delayed_put_task_struct);</span><br><span class="line">    p = leader;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(zap_leader))</span><br><span class="line">        <span class="keyword">goto</span> repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>子进程不一定能保证在父进程前边退出，所以必须要有机制来保证子进程在这种情况下能找到一个新的父进程。否则的话，这些成为孤儿的进程就会在退出时永远处于僵死状态，白白的耗费内存。解决这个问题的办法，就是给子进程在当前线程组内找一个线程作为父亲。一旦系统给进程成功地找到和设置了新的父进程，就不会再有出现驻留僵死进程的危险了，<code>init</code>进程会例行调用<code>wait()</code>来等待子进程，清除所有与其相关的僵死进程。</p>
<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><p>Linux为多任务系统，正常情况下都存在成百上千个任务。由于Linux提供抢占式的多任务模式，所以Linux能同时并发地交互执行多个进程，而调度程序将决定哪一个进程投入运行、何时运行、以及运行多长时间。调度程序是像Linux这样的多任务操作系统的基础，只有通过调度程序的合理调度，系统资源才能最大限度地发挥作用，多进程才会有并发执行的效果。当系统中可运行的进程数目比处理器的个数多，就注定在某一时刻有一些进程不能执行，这些不能执行的进程在等待执行。调度程序的基本工作就是停止一个进程的运行，再在这些等待执行的进程中选择一个来执行。</p>
<p>调度程序停止一个进程的运行，再选择一个另外进程的动作开始运行的动作被称作抢占（preemption）。一个进程在被抢占之前能够运行的时间是预先设置好的，这个预先设置好的时间就是进程的的时间片（timeslice）。时间片就是分配给每个可运行进程的处理器时间段，它表明进程在被抢占前所能持续运行时间。</p>
<p>处理器的调度策略决定调度程序在何时让什么进程投入运行。调度策略通常需要在进程响应迅速(相应时间短)和进程吞吐量高之间寻找平衡。所以调度程序通常采用一套非常复杂的算法来决定最值得运行的进程投入运行。调度算法中最基本的一类当然就是基于优先级的调度，也就是说优先级高的先运行，相同优先级的按轮转式进行调度。优先级高 的进程使用的时间片也长。调度程序总是选择时间片未用尽且优先级最高的进程运行。这句话就是说用户和系统可以通过设置进程的优先级来响应系统的调度。基于此，Linux设计上一套动态优先级的调度方法。一开始，先为进程设置一个基本的优先级，然而它允许调度程序根据需要来加减优先级。Linux内核提供了两组独立的优先级范围。第一种是<code>nice</code>值，范围从-20到19，默认为0。<code>nice</code>值越大优先级越小。另外<code>nice</code>值也用来决定分配给进程时间片的长短。Linux下通过命令可以查看进程对应<code>nice</code>值，如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ ps -el</span><br><span class="line"></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD </span><br><span class="line">4 S     0     1     0  0  80   0 -   725 ?      ?        00:00:01 init </span><br><span class="line">1 S     0     2     0  0  80   0 -     0 ?      ?        00:00:00 kthreadd </span><br><span class="line">1 S     0     3     2  0 -40   - -     0 ?      ?        00:00:01 migration/0 </span><br><span class="line">1 S     0     4     2  0  80   0 -     0 ?      ?        00:00:00 ksoftirqd/0 </span><br><span class="line">1 S     0     9     2  0  80   0 -     0 ?      ?        00:00:00 ksoftirqd/1</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">1 S     0    39     2  0  85   5 -     0 ?      ?        00:00:00 ksmd </span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">1 S     0   156     2  0  75  -5 -     0 ?      ?        00:00:00 kslowd000 </span><br><span class="line">1 S     0   157     2  0  75  -5 -     0 ?      ?        00:00:00 kslowd001 </span><br><span class="line">...... </span><br><span class="line">4 S   499  2951     1  0  81   1 -  6276 ?      ?        00:00:00 rtkit-daemon </span><br><span class="line">...... </span><br></pre></td></tr></table></figure><br>第二种范围是实时优先级，默认范围是从0到99。任何实时的优先级都高于普通优先级。</p>
<p>进程执行时，它会根据具体情况改变状态，进程状态是调度和对换的依据。Linux 将进程状态分为五种： <code>TASK_RUNNING</code> 、<code>TASK_INTERRUPTIBLE</code> 、<code>TASK_UNINTERRUPTIBLE</code>、<code>TASK_STOPPED</code>和<code>TASK_ZOMBILE</code>。进程的状态随着进程的调度发生改变 。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>状态</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>TASK_RUNNING</td>
<td>可运行</td>
</tr>
<tr>
<td>TASK_INTERRUPTIBLE</td>
<td>可中断的等待状态</td>
</tr>
<tr>
<td>TASK_UNINTERRUPTIBLE</td>
<td>不可中断的等待状态</td>
</tr>
<tr>
<td>TASK_STOPPED</td>
<td>停止状态</td>
</tr>
<tr>
<td>TASK_TRACED</td>
<td>被跟踪状态</td>
</tr>
</tbody>
</table>
</div>
<p>TASK_RUNNING （运行）：无论进程是否正在占用 CPU ，只要具备运行条件，都处于该状态。 Linux 把处于该状态的所有 PCB 组织成一个可运行队列 run_queue ，调度程序从这个队列中选择进程运行。事实上，Linux 是将就绪态和运行态合并为了一种状态。</p>
<p>TASK_INTERRUPTIBLE （可中断阻塞）： Linux 将阻塞态划分成 TASK_INTERRUPTIBLE 、 TASK_UNINTERRUPTIBLE 、 TASK_STOPPED 三种不同的状态。处于 TASK_INTERRUPTIBLE 状态的进程在资源有效时被唤醒，也可以通过信号或定时中断唤醒。</p>
<p>TASK_UNINTERRUPTIBLE （不可中断阻塞）：另一种阻塞状态，处于该状态的进程只有当资源有效时被唤醒，不能通过信号或定时中断唤醒。在执行<code>ps</code>命令时，进程状态为<code>D</code>且不能被杀死。</p>
<p>TASK_STOPPED （停止）：第三种阻塞状态，处于该状态的进程只能通过其他进程的信号才能唤醒。</p>
<p>TASK_TRACED （被跟踪）：进程正在被另一个进程监视，比如在调试的时候。</p>
<p>我们在设置这些状态的时候是可以直接用语句进行的比如：<code>p—&gt;state = TASK_RUNNING</code>。同时内核也会使用<code>set_task_state()</code>和<code>set_current_state()</code>函数来进行。</p>
<p>Linux调度器是以模块方式提供的，这样允许不同类型的进程可以有针对性地选择调度算法。完全公平调度（CFS）是针对普通进程的调度类，CFS采用的方法是对时间片分配方式进行根本性的重新设计，完全摒弃时间片而是分配给进程一个处理器使用比重。通过这种方式，CFS确保了进程调度中能有恒定的公平性，而将切换频率置于不断变动之中。</p>
<p>与Linux 2.6之前调度器不同，2.6版本内核的CFS没有将任务维护在链表式的运行队列中，它抛弃了<code>active/expire</code>数组，而是对每个CPU维护一个以时间为顺序的红黑树。该树方法能够良好运行的原因在于：</p>
<ul>
<li>红黑树可以始终保持平衡，这意味着树上没有路径比任何其他路径长两倍以上。</li>
<li>由于红黑树是二叉树，查找操作的时间复杂度为`O(log n)。但是除了最左侧查找以外，很难执行其他查找，并且最左侧的节点指针始终被缓存。</li>
<li>对于大多数操作（插入、删除、查找等），红黑树的执行时间为<code>O(log n)</code>，而以前的调度程序通过具有固定优先级的优先级数组使用<code>O(1)</code>。<code>O(log n)</code>行为具有可测量的延迟，但是对于较大的任务数无关紧要。</li>
<li>红黑树可通过内部存储实现，即不需要使用外部分配即可对数据结构进行维护。</li>
</ul>
<p>要实现平衡，CFS使用“虚拟运行时”表示某个任务的时间量。任务的虚拟运行时越小，意味着任务被允许访问服务器的时间越短，其对处理器的需求越高。CFS还包含睡眠公平概念以便确保那些目前没有运行的任务（例如，等待 I/O）在其最终需要时获得相当份额的处理器。</p>
<p>对于实时进程，Linux 采用了两种调度策略，即先来先服务调度（ First-In, First-Out ， FIFO ）和时间片轮转调度（ Round Robin ， RR ）。因为实时进程具有一定程度的紧迫性，所以衡量一个实时进程是否应该运行，Linux 采用了一个比较固定的标准。</p>
<p>下面是调度相关的一些数据结构：调度实体：<code>struct sched_entity</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span>  <span class="title">load</span>;</span>       <span class="comment">/* for load-balancing */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>      <span class="title">run_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">group_node</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        on_rq;</span><br><span class="line"> </span><br><span class="line">    u64         exec_start;</span><br><span class="line">    u64         sum_exec_runtime;</span><br><span class="line">    u64         vruntime;</span><br><span class="line">    u64         prev_sum_exec_runtime;</span><br><span class="line"> </span><br><span class="line">    u64         last_wakeup;</span><br><span class="line">    u64         avg_overlap;</span><br><span class="line"> </span><br><span class="line">    u64         nr_migrations;</span><br><span class="line"> </span><br><span class="line">    u64         start_runtime;</span><br><span class="line">    u64         avg_wakeup;</span><br><span class="line"> </span><br><span class="line">    u64         avg_running;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SCHEDSTATS</span></span><br><span class="line">    u64         wait_start;</span><br><span class="line">    u64         wait_max;</span><br><span class="line">    u64         wait_count;</span><br><span class="line">    u64         wait_sum;</span><br><span class="line">    u64         iowait_count;</span><br><span class="line">    u64         iowait_sum;</span><br><span class="line"> </span><br><span class="line">    u64         sleep_start;</span><br><span class="line">    u64         sleep_max;</span><br><span class="line">    s64         sum_sleep_runtime;</span><br><span class="line"> </span><br><span class="line">    u64         block_start;</span><br><span class="line">    u64         block_max;</span><br><span class="line">    u64         exec_max;</span><br><span class="line">    u64         slice_max;</span><br><span class="line"> </span><br><span class="line">    u64         nr_migrations_cold;</span><br><span class="line">    u64         nr_failed_migrations_affine;</span><br><span class="line">    u64         nr_failed_migrations_running;</span><br><span class="line">    u64         nr_failed_migrations_hot;</span><br><span class="line">    u64         nr_forced_migrations;</span><br><span class="line">    u64         nr_forced2_migrations;</span><br><span class="line"> </span><br><span class="line">    u64         nr_wakeups;</span><br><span class="line">    u64         nr_wakeups_sync;</span><br><span class="line">    u64         nr_wakeups_migrate;</span><br><span class="line">    u64         nr_wakeups_local;</span><br><span class="line">    u64         nr_wakeups_remote;</span><br><span class="line">    u64         nr_wakeups_affine;</span><br><span class="line">    u64         nr_wakeups_affine_attempts;</span><br><span class="line">    u64         nr_wakeups_passive;</span><br><span class="line">    u64         nr_wakeups_idle;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="comment">/* rq on which this entity is (to be) queued: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span>       *<span class="title">cfs_rq</span>;</span></span><br><span class="line">    <span class="comment">/* rq &quot;owned&quot; by this entity/group: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span>       *<span class="title">my_q</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>该结构在<code>./linux/include/linux/sched.h</code>中，表示一个可调度实体（进程，进程组，等等）。它包含了完整的调度信息，用于实现对单个任务或任务组的调度。调度实体可能与进程没有关联。这里包括负载权重<code>load</code>、对应的红黑树结点<code>run_node</code>、虚拟运行时<code>vruntime</code>（表示进程的运行时间，并作为红黑树的索引）、开始执行时间、最后唤醒时间、各种统计数据、用于组调度的CFS运行队列信息<code>cfs_rq</code>，等等。</p>
<p>调度类：<code>struct sched_class</code>。该调度类也在<code>sched.h</code>中，是对调度器操作的面向对象抽象，协助内核调度程序的各种工作。调度类是调度器管理器的核心，每种调度算法模块需要实现<code>struct sched_class</code>建议的一组函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">next</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">void</span> (*enqueue_task) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> wakeup);</span><br><span class="line">    <span class="type">void</span> (*dequeue_task) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> sleep);</span><br><span class="line">    <span class="type">void</span> (*yield_task) (<span class="keyword">struct</span> rq *rq);</span><br><span class="line"> </span><br><span class="line">    <span class="type">void</span> (*check_preempt_curr) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags);</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * (*<span class="title">pick_next_task</span>) (<span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>);</span></span><br><span class="line">    <span class="type">void</span> (*put_prev_task) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="type">int</span>  (*select_task_rq)(<span class="keyword">struct</span> task_struct *p, <span class="type">int</span> sd_flag, <span class="type">int</span> flags);</span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*load_balance)</span> <span class="params">(<span class="keyword">struct</span> rq *this_rq, <span class="type">int</span> this_cpu,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> rq *busiest, <span class="type">unsigned</span> <span class="type">long</span> max_load_move,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> sched_domain *sd, <span class="keyword">enum</span> cpu_idle_type idle,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> *all_pinned, <span class="type">int</span> *this_best_prio)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> (*move_one_task) (<span class="keyword">struct</span> rq *this_rq, <span class="type">int</span> this_cpu,</span><br><span class="line">                  <span class="keyword">struct</span> rq *busiest, <span class="keyword">struct</span> sched_domain *sd,</span><br><span class="line">                  <span class="keyword">enum</span> cpu_idle_type idle);</span><br><span class="line">    <span class="type">void</span> (*pre_schedule) (<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task);</span><br><span class="line">    <span class="type">void</span> (*post_schedule) (<span class="keyword">struct</span> rq *this_rq);</span><br><span class="line">    <span class="type">void</span> (*task_wake_up) (<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task);</span><br><span class="line"> </span><br><span class="line">    <span class="type">void</span> (*set_cpus_allowed)(<span class="keyword">struct</span> task_struct *p,</span><br><span class="line">                 <span class="type">const</span> <span class="keyword">struct</span> cpumask *newmask);</span><br><span class="line"> </span><br><span class="line">    <span class="type">void</span> (*rq_online)(<span class="keyword">struct</span> rq *rq);</span><br><span class="line">    <span class="type">void</span> (*rq_offline)(<span class="keyword">struct</span> rq *rq);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="type">void</span> (*set_curr_task) (<span class="keyword">struct</span> rq *rq);</span><br><span class="line">    <span class="type">void</span> (*task_tick) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> queued);</span><br><span class="line">    <span class="type">void</span> (*task_new) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p);</span><br><span class="line"> </span><br><span class="line">    <span class="type">void</span> (*switched_from) (<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task,</span><br><span class="line">                   <span class="type">int</span> running);</span><br><span class="line">    <span class="type">void</span> (*switched_to) (<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task,</span><br><span class="line">                 <span class="type">int</span> running);</span><br><span class="line">    <span class="type">void</span> (*prio_changed) (<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task,</span><br><span class="line">                 <span class="type">int</span> oldprio, <span class="type">int</span> running);</span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*get_rr_interval)</span> <span class="params">(<span class="keyword">struct</span> task_struct *task)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">    <span class="type">void</span> (*moved_group) (<span class="keyword">struct</span> task_struct *p);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></p>
<p>其中的主要函数：</p>
<ul>
<li><code>enqueue_task</code>：当某个任务进入可运行状态时，该函数将得到调用。它将调度实体（进程）放入红黑树中，并对<code>nr_running</code>变量加 1。从前面“Linux进程管理”的分析中可知，进程创建的最后会调用该函数。</li>
<li><code>dequeue_task</code>：当某个任务退出可运行状态时调用该函数，它将从红黑树中去掉对应的调度实体，并从<code>nr_running</code>变量中减 1。</li>
<li><code>yield_task</code>：在<code>compat_yield sysctl</code>关闭的情况下，该函数实际上执行先出队后入队；在这种情况下，它将调度实体放在红黑树的最右端。</li>
<li><code>check_preempt_curr</code>：该函数将检查当前运行的任务是否被抢占。在实际抢占正在运行的任务之前，CFS 调度程序模块将执行公平性测试。这将驱动唤醒式（wakeup）抢占。</li>
<li><code>pick_next_task</code>：该函数选择接下来要运行的最合适的进程。</li>
<li><code>load_balance</code>：每个调度程序模块实现两个函数，<code>load_balance_start()</code>和<code>load_balance_next()</code>，使用这两个函数实现一个迭代器，在模块的<code>load_balance</code>例程中调用。内核调度程序使用这种方法实现由调度模块管理的进程的负载平衡。</li>
<li><code>set_curr_task</code>：当任务修改其调度类或修改其任务组时，将调用这个函数。</li>
<li><code>task_tick</code>：该函数通常调用自 time tick 函数；它可能引起进程切换。这将驱动运行时（running）抢占。</li>
</ul>
<p>调度类的引入是接口和实现分离的设计典范，你可以实现不同的调度算法（例如普通进程和实时进程的调度算法就不一样），但由于有统一的接口，使得调度策略 被模块化，一个Linux调度程序可以有多个不同的调度策略。调度类显著增强了内核调度程序的可扩展性。每个任务都属于一个调度类，这决定了任务将如何调 度。 调度类定义一个通用函数集，函数集定义调度器的行为。例如，每个调度器提供一种方式，添加要调度的任务、调出要运行的下一个任务、提供给调度器等等。每个 调度器类都在一对一连接的列表中彼此相连，使类可以迭代（例如，要启用给定处理器的禁用）。注意，将任务函数加入队列或脱离队列只需从特定调度结构中加入或移除任务。 核心函数 pick_next_task 选择要执行的下一个任务（取决于调度类的具体策略）。</p>
<p><code>sched_rt.c</code>，<code>sched_fair.c</code>，<code>sched_idletask.c</code>等（都在<code>kernel/</code>目录下）就是不同的调度算法实现。不要忘了调度类是任务结构本身的一部分（参见 task_struct）。这一点简化了任务的操作，无论其调度类如何。因为进程描述符中有<code>sched_class</code>引用，这样就可以直接通过进程描述符来 调用调度类中的各种操作。在调度类中，随着调度域的增加，其功能也在增加。 这些域允许您出于负载平衡和隔离的目的将一个或多个处理器按层次关系分组。 一个或多个处理器能够共享调度策略（并在其之间保持负载平衡），或实现独立的调度策略。</p>
<p>可运行队列：<code>struct rq</code>。调度程序每次在进程发生切换时，都要从可运行队列中选取一个最佳的进程来运行。Linux内核使用<code>rq</code>数据结构（以前的内核中该结构为 runqueue）表示一个可运行队列信息（也就是就绪队列），每个CPU都有且只有一个这样的结构。该结构在<code>kernel/sched.c</code>中，不仅描述了每个处理器中处于可运行状态（<code>TASK_RUNNING</code>），而且还描述了该处理器的调度信息。如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rq</span> &#123;</span></span><br><span class="line">    <span class="comment">/* runqueue lock: */</span></span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_running;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CPU_LOAD_IDX_MAX 5</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cpu_load[CPU_LOAD_IDX_MAX];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* capture load from *all* tasks on this cpu: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">load</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_load_updates;</span><br><span class="line">    u64 nr_switches;</span><br><span class="line">    u64 nr_migrations_in;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> <span class="title">cfs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span> <span class="title">rt</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_uninterruptible;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span>, *<span class="title">idle</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> next_balance;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">prev_mm</span>;</span></span><br><span class="line"> </span><br><span class="line">    u64 clock;</span><br><span class="line"> </span><br><span class="line">    <span class="type">atomic_t</span> nr_iowait;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* calc_load related fields */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> calc_load_update;</span><br><span class="line">    <span class="type">long</span> calc_load_active;</span><br><span class="line"> </span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>进程调度的入口点是函数<code>schedule()</code>，该函数调用<code>pick_next_task()</code>，<code>pick_next_task()</code>会以优先级为序，从高到低，一次检查每一个调度类，且从最高优先级的调度类中，选择最高优先级的进程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> __sched <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *switch_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">	<span class="type">int</span> cpu;</span><br><span class="line"> </span><br><span class="line">need_resched:</span><br><span class="line">	preempt_disable();</span><br><span class="line">	cpu = smp_processor_id();</span><br><span class="line">	rq = cpu_rq(cpu);</span><br><span class="line">	rcu_sched_qs(cpu);</span><br><span class="line">	prev = rq-&gt;curr;</span><br><span class="line">	switch_count = &amp;prev-&gt;nivcsw;</span><br><span class="line"> </span><br><span class="line">	release_kernel_lock(prev);</span><br><span class="line">need_resched_nonpreemptible:</span><br><span class="line"> </span><br><span class="line">	schedule_debug(prev);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (sched_feat(HRTICK))</span><br><span class="line">		hrtick_clear(rq);</span><br><span class="line"> </span><br><span class="line">	spin_lock_irq(&amp;rq-&gt;lock);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	clear_tsk_need_resched(prev);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (prev-&gt;state &amp;&amp; !(preempt_count() &amp; PREEMPT_ACTIVE)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(signal_pending_state(prev-&gt;state, prev)))</span><br><span class="line">			prev-&gt;state = TASK_RUNNING;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			deactivate_task(rq, prev, <span class="number">1</span>);</span><br><span class="line">		switch_count = &amp;prev-&gt;nvcsw;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	pre_schedule(rq, prev);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (unlikely(!rq-&gt;nr_running))</span><br><span class="line">		idle_balance(cpu, rq);</span><br><span class="line"> </span><br><span class="line">	put_prev_task(rq, prev);</span><br><span class="line">	&lt;strong&gt;next = pick_next_task(rq);    <span class="comment">//&lt;span&gt;&lt;span&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;//挑选最高优先级别的任务&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (likely(prev != next)) &#123;</span><br><span class="line">		sched_info_switch(prev, next);</span><br><span class="line">		perf_event_task_sched_out(prev, next, cpu);</span><br><span class="line"> </span><br><span class="line">		rq-&gt;nr_switches++;</span><br><span class="line">		rq-&gt;curr = next;</span><br><span class="line">		++*switch_count;</span><br><span class="line"> </span><br><span class="line">		context_switch(rq, prev, next); <span class="comment">/* unlocks the rq */</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * the context switch might have flipped the stack from under</span></span><br><span class="line"><span class="comment">		 * us, hence refresh the local variables.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		cpu = smp_processor_id();</span><br><span class="line">		rq = cpu_rq(cpu);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		spin_unlock_irq(&amp;rq-&gt;lock);</span><br><span class="line"> </span><br><span class="line">	post_schedule(rq);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (unlikely(reacquire_kernel_lock(current) &lt; <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">goto</span> need_resched_nonpreemptible;</span><br><span class="line"> </span><br><span class="line">	preempt_enable_no_resched();</span><br><span class="line">	<span class="keyword">if</span> (need_resched())</span><br><span class="line">		<span class="keyword">goto</span> need_resched;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> task_struct *</span><br><span class="line"><span class="title function_">pick_next_task</span><span class="params">(<span class="keyword">struct</span> rq *rq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Optimization: we know that if all tasks are in</span></span><br><span class="line"><span class="comment">	 * the fair class we can call that function directly:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(rq-&gt;nr_running == rq-&gt;cfs.nr_running)) &#123;</span><br><span class="line">		p = fair_sched_class.pick_next_task(rq);</span><br><span class="line">		<span class="keyword">if</span> (likely(p))</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//从最高优先级类开始，遍历每一个调度类。每一个调度类都实现了pick_next_task，他会返回指向下一个可运行进程的指针，没有时返回NULL。</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> =</span> sched_class_highest;</span><br><span class="line">	<span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">		p = class-&gt;pick_next_task(rq);</span><br><span class="line">		<span class="keyword">if</span> (p)</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Will never be NULL as the idle class always</span></span><br><span class="line"><span class="comment">		 * returns a non-NULL p:</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> =</span> <span class="class"><span class="keyword">class</span>-&gt;</span>next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>被阻塞（休眠）的进程处于不可执行状态，是不能被调度的。进程休眠一般是由于等待一些事件，内核首先把自己标记成休眠状态，从可执行红黑树中移出，放入等待队列，然后调用<code>schedule()</code>选择和执行一个其他进程。唤醒的过程刚好相反，进程设置为可执行状态，然后从等待队列中移到可执行红黑树中。    </p>
<p>等待队列是由等待某些事件发生的进程组成的简单链表。内核用<code>wake_queue_head_t</code>来代表队列。进程把自己放入等待队列中并设置成不可执状态。当等待队列相关事件发生时，队列上进程会被唤醒。函数<code>inotify_read()</code>是实现等待队列的一个典型用法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">inotify_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">                <span class="type">size_t</span> count, <span class="type">loff_t</span> *pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsnotify_group</span> *<span class="title">group</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsnotify_event</span> *<span class="title">kevent</span>;</span></span><br><span class="line">    <span class="type">char</span> __user *start;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    DEFINE_WAIT(wait);</span><br><span class="line"> </span><br><span class="line">    start = buf;</span><br><span class="line">    group = file-&gt;private_data;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//进程的状态变更为`TASK_INTERRUPTIBLE`或`TASK_UNINTERRUPTIBLE。</span></span><br><span class="line">        prepare_to_wait(&amp;group-&gt;notification_waitq, &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line"> </span><br><span class="line">        mutex_lock(&amp;group-&gt;notification_mutex);</span><br><span class="line">        kevent = get_one_event(group, count);</span><br><span class="line">        mutex_unlock(&amp;group-&gt;notification_mutex);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (kevent) &#123;</span><br><span class="line">            ret = PTR_ERR(kevent);</span><br><span class="line">            <span class="keyword">if</span> (IS_ERR(kevent))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ret = copy_event_to_user(group, kevent, buf);</span><br><span class="line">            fsnotify_put_event(kevent);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            buf += ret;</span><br><span class="line">            count -= ret;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        ret = -EAGAIN;</span><br><span class="line">        <span class="keyword">if</span> (file-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ret = -EINTR;</span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (start != buf)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    finish_wait(&amp;group-&gt;notification_waitq, &amp;wait);</span><br><span class="line">    <span class="keyword">if</span> (start != buf &amp;&amp; ret != -EFAULT)</span><br><span class="line">        ret = buf - start;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>唤醒是通过<code>wake_up()</code>进行。她唤醒指定的等待队列上 的所有进程。它调用<code>try_to_wake_up</code>，该函数负责将进程设置为<code>TASK_RUNNING</code>状态，调用<code>active_task()</code>将此进程放入可 执行队列，如果被唤醒进程的优先级比当前正在执行的进程的优先级高，还要设置<code>need_resched</code>标志。</p>
<p>上下文切换，就是从一个可执行进程切换到另一个可执行进程，由定义在<code>kernel/sched.c</code>的<code>context_switch</code>函数负责处理。每当一个新的进程被选出来准备投入运行的时候，schedule`就会调用该函数。它主要完成如下两个工作：</p>
<ol>
<li>调用定义在<code>include/asm/mmu_context.h</code>中的<code>switch_mm()</code>。该函数负责把虚拟内存从上一个进程映射切换到新进程中。</li>
<li>调用定义在<code>include/asm/system.h</code>的<code>switch_to()</code>，该函数负责从上一个进程的处理器状态切换到新进程的处理器状态，这包括保存，恢复栈信息和寄存器信息。</li>
</ol>
<p>内核也必须知道什么时候调用<code>schedule()</code>，单靠用户代码显示调用<code>schedule()</code>，他们可能就会永远地执行下去，相反，内核提供了一个<code>need_resched</code>标志来表明是否需要重新执行一次调度。当 某个进程耗尽它的时间片时，<code>scheduler_tick()</code>就会设置这个标志，当一个优先级高的进程进入可执行状态的时候，<code>try_to_wake_up()</code>也会设置这个标志。内核检查该标志，确认其被设置，调用<code>schedule()</code>来切换到一个新的进程。该标志对内核来讲是一个信息，它表示应当有其他进程应当被运行了。</p>
<p>用于访问和操作<code>need_resched</code>的函数：</p>
<ul>
<li><code>set_tsk_need_resched(task)</code>：设置指定进程中的<code>need_resched</code>标志</li>
<li><code>clear_tsk_need_resched(task)</code>：清除指定进程中的<code>nedd_resched</code>标志</li>
<li><code>need_resched()</code>：检查<code>need_resched</code>标志的值，如果被设置就返回真，否则返回</li>
</ul>
<p>在返回用户空间以及从中断返回的时候，内核也会检查<code>need_resched</code>标志，如果已被设置，内核会在继续执行之前调用该调度程序。最后，每个进程都包含一个<code>need_resched</code>标志，这是因为访 问进程描述符内的数值要比访问一个全局变量要快(因为<code>current</code>宏速度很快并且描述符通常都在高速缓存中)。在2.6内核中，他被移到了<code>thread_info</code>结构体里。</p>
<p>用户抢占发生在：</p>
<ol>
<li>从系统调用返回时；</li>
<li>从终端处理程序返回用户空间时。</li>
</ol>
<p>内核抢占发生在:</p>
<ol>
<li>中断处理正在执行，且返回内核空间前；</li>
<li>内核代码再一次具有可抢占性的时候；</li>
<li>内核任务显式调用<code>schedule()</code>函数；</li>
<li>内核中的任务阻塞的时候。</li>
</ol>
<h1 id="内核同步"><a href="#内核同步" class="headerlink" title="内核同步"></a>内核同步</h1><p>如同Linux应用一样，内核的共享资源也要防止并发，因为如果多个执行线程同时访问和操作数据有可能发生各个线程之间相互覆盖共享数据的情况。</p>
<p>在Linux只是单一处理器的时候，只有在中断发生或内核请求重新调度执行另一个任务时，数据才可能会并发访问。但自从内核开始支持对称多处理器之后，内核代码可以同时运行在多个处理器上，如果此时不加保护，运行在多个处理器上的代码完全可能在同一时刻并发访问共享数据。</p>
<p>一般把访问和操作共享数据的代码段称作临界区，为了避免在临界区中发生并发访问，程序员必须保证临界区代码原子执行，也就是要么全部执行，要么不执行。如果两个执行线程在同一个临界区同时执行，就发生了竞态（race conditions），避免并发防止竞态就是所谓的同步。</p>
<p>在Linux内核中造成并发的原因主要有如下:</p>
<ul>
<li>中断 — 中断几乎可以在任何时刻异步发生，也就可能随时打断当前正在执行的代码。</li>
<li>软中断和<code>tasklet</code> — 内核能在任何时刻唤醒或调度软中断和<code>tasklet</code>，打断当前正在执行的代码。</li>
<li>内核抢占 — 因为内核具有抢占性，所以内核中的任务可能会被另一任务抢占。</li>
<li>睡眠及与用户空间的同步 — 在内核执行的进程可能会睡眠，这就会唤醒调度程序，从而导致调度一个新的用户进程执行。</li>
<li>对称多处理 —  两个或多个处理器可以同时执行代码。（真并发）</li>
</ul>
<p>通过锁可以防止并发执行，并且保护临界区不受竞态影响。任何执行线程要访问临界区代码时首先先获得锁，这样当后面另外的执行线程要访问临界区时就不能再获得该锁，这样临界区就禁止后来执行线程访问。Linux自身实现了多种不同的锁机制，各种锁各有差别，区别主要在于当锁被争用时，有些会简单地执行等待，而有些锁会使当前任务睡眠直到锁可用为止。本节将会分析各锁的使用和实现。但是使用锁也会带来副作用，锁使得线程按串行方式对资源进行访问，所以使用锁无疑会降低系统性能；并且锁使用不当还会造成死锁。</p>
<p>下面来看一下Linux下同步的方法，包括原子操作、自旋锁、信号量等方式。</p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>该操作是其它同步方法的基础，原子操作可以保证指令以原子的方式执行，执行过程不会被打断。Linux内核提供了两组原子操作接口：原子整数操作和原子位操作。</p>
<p>针对整数的原子操作只能对<code>atomic_t</code>类型的数据进行处理。该类类型定义与文件<code>&lt;include/linux/types.h&gt;</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> counter;</span><br><span class="line">&#125; <span class="type">atomic_t</span>;</span><br></pre></td></tr></table></figure><br>下面举例说明原子操作的用法：<br>定义一个<code>atomic_c</code>类型的数据很简单，还可以定义时给它设定初值：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_t</span> u;</span><br><span class="line">     </span><br><span class="line"><span class="comment">/* 定义 u */</span></span><br><span class="line"><span class="type">atomic_t</span> v = ATOMIC_INIT(<span class="number">0</span>)     <span class="comment">/*定义 v 并把它初始化为0*/</span></span><br></pre></td></tr></table></figure></p>
<p>对其操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_set</span>(&amp;v,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* v = 4 ( 原子地)*/</span></span><br><span class="line"><span class="type">atomic_add</span>(<span class="number">2</span>,&amp;v)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* v = v + 2 = 6 (原子地) */</span></span><br><span class="line"><span class="type">atomic_inc</span>(&amp;v)</span><br><span class="line">   </span><br><span class="line"><span class="comment">/* v = v + 1 =7（原子地)*/</span></span><br></pre></td></tr></table></figure></p>
<p>如果需要将<code>atomic_t</code>转换成<code>int</code>型，可以使用<code>atomic_read()</code>来完成：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printk(<span class="string">&quot;%d\n&quot;</span>, <span class="type">atomic_read</span>(&amp;v));    <span class="comment">/* 会打印7*/</span></span><br></pre></td></tr></table></figure></p>
<p>原子整数操作最常见的用途就是实现计数器。使用复杂的锁机制来保护一个单纯的计数器是很笨拙的，所以，开发者最好使用<code>atomic_inc()</code>和<code>atomic_dec()</code>这两个相对来说轻便一点的操作。</p>
<p>还可以用原子整数操作原子地执行一个操作并检查结果。一个常见的例子是原子的减操作和检查。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atomic_dec_and_test</span><span class="params">(<span class="type">atomic_t</span> *v)</span></span><br></pre></td></tr></table></figure></p>
<p>这个函数让给定的原子变量减1，如果结果为0，就返回1；否则返回0。特定体系结构的所有原子整数操作可以在文件<code>&lt;arch/x86/include/asm/atomic.h&gt;</code>中找到。如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_X86_ATOMIC_32_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_X86_ATOMIC_32_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/compiler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/processor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/cmpxchg.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATOMIC_INIT(i)    &#123; (i) &#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">atomic_read</span><span class="params">(<span class="type">const</span> <span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> v-&gt;counter;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">atomic_set</span><span class="params">(<span class="type">atomic_t</span> *v, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    v-&gt;counter = i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">atomic_add</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot;addl %1,%0&quot;</span></span></span><br><span class="line"><span class="params">             : <span class="string">&quot;+m&quot;</span> (v-&gt;counter)</span></span><br><span class="line"><span class="params">             : <span class="string">&quot;ir&quot;</span> (i))</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">atomic_sub</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot;subl %1,%0&quot;</span></span></span><br><span class="line"><span class="params">             : <span class="string">&quot;+m&quot;</span> (v-&gt;counter)</span></span><br><span class="line"><span class="params">             : <span class="string">&quot;ir&quot;</span> (i))</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">atomic_sub_and_test</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot;subl %2,%0; sete %1&quot;</span></span></span><br><span class="line"><span class="params">             : <span class="string">&quot;+m&quot;</span> (v-&gt;counter), <span class="string">&quot;=qm&quot;</span> (c)</span></span><br><span class="line"><span class="params">             : <span class="string">&quot;ir&quot;</span> (i) : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>除了原子整数之外，内核还提供了一组针对位操作的函数，这些操作也是和体系结构相关的。例如在x86下<code>set_bit</code>实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">set_bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr, <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (IS_IMMEDIATE(nr)) &#123;</span><br><span class="line">        <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot;orb %1,%0&quot;</span></span></span><br><span class="line"><span class="params">            : CONST_MASK_ADDR(nr, addr)</span></span><br><span class="line"><span class="params">            : <span class="string">&quot;iq&quot;</span> ((u8)CONST_MASK(nr))</span></span><br><span class="line"><span class="params">            : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">asm</span> <span class="keyword">volatile</span>(LOCK_PREFIX <span class="string">&quot;bts %1,%0&quot;</span></span><br><span class="line">            : BITOP_ADDR(addr) : <span class="string">&quot;Ir&quot;</span> (nr) : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>原子操作是对普通内存地址指针进行的操作，只要指针指向了任何你希望的数据，你就可以对它进行操作。原子位操作(以x86为例)相关函数定义在文件<code>&lt;arch/x86/include/asm/bitops.h&gt;</code>中。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>不是所有的临界区都是像增加或减少变量这么简单，有的时候临界区可能会跨越多个函数，这这时就需要使用更为复杂的同步方法——锁。Linux内核中最常见的锁是自旋锁，自旋锁最多只能被一个可执行线程持有，如果一个可执行线程视图获取一个已经被持有的锁，那么该线程将会一直进行忙循环等待锁重新可用。在任意时候，自旋锁都可以防止多余一个执行线程同时进入临界区。由于自旋忙等过程是很费时间的，所以自旋锁不应该被长时间持有。</p>
<p>自旋锁相关方法如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>spinlock中的定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义<code>spin lock</code>并初始化</td>
<td>DEFINE_SPINLOCK()</td>
</tr>
<tr>
<td>动态初始化<code>spin lock</code></td>
<td>spin_lock_init()</td>
</tr>
<tr>
<td>获取指定的<code>spin lock</code></td>
<td>spin_lock()</td>
</tr>
<tr>
<td>获取指定的<code>spin lock</code>同时<code>disable</code>本CPU中断</td>
<td>spin_lock_irq()</td>
</tr>
<tr>
<td>保存本CPU当前的<code>irq</code>状态，disable本CPU中断并获取指定的<code>spin lock</code></td>
<td>spin_lock_irqsave()</td>
</tr>
<tr>
<td>获取指定的<code>spin lock</code>同时disable本CPU的`bottom half</td>
<td>spin_lock_bh()</td>
</tr>
<tr>
<td>释放指定的<code>spin lock</code></td>
<td>spin_unlock()</td>
</tr>
<tr>
<td>释放指定的<code>spin lock</code>同时enable本CPU中断</td>
<td>spin_lock_irq()</td>
</tr>
<tr>
<td>释放指定的<code>spin lock</code>同时恢复本CPU的中断状态</td>
<td>spin_lock_irqsave()</td>
</tr>
<tr>
<td>获取指定的<code>spin lock</code>同时enable本CPU的bottom half</td>
<td>spin_unlock_bh()</td>
</tr>
<tr>
<td>尝试去获取<code>spin lock</code>，如果失败，不会spin，而是返回非零值</td>
<td>spin_trylock()</td>
</tr>
<tr>
<td>判断<code>spin lock</code>是否是locked，如果其他的thread已经获取了该lock，那么返回非零值，否则返回0</td>
<td>spin_is_locked()</td>
</tr>
</tbody>
</table>
</div>
<p>自旋锁的实现和体系结构密切相关，代码通常通过汇编实现。与体系结构相关的部分定义在<code>&lt;asm/spinlock.h&gt;</code>,实际需要用到的接口定义在文件<code>&lt;linux/spinlock.h&gt;</code>中。一个实际的锁的类型为<code>spinlock_t</code>，定义在文件<code>&lt;include/linux/spinlock_types.h&gt;</code>中:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">raw_spinlock_t</span> raw_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_LOCKBREAK</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> break_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> magic, owner_cpu;</span><br><span class="line">    <span class="type">void</span> *owner;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="type">spinlock_t</span>;</span><br></pre></td></tr></table></figure><br>自旋锁基本使用形式如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_SPINLOCK(lock);</span><br><span class="line">spin_lock(&amp;lock);</span><br><span class="line"><span class="comment">/* 临界区 */</span></span><br><span class="line">spin_unlock(&amp;lock);</span><br></pre></td></tr></table></figure><br>实际上有 4 个函数可以加锁一个自旋锁:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">spin_lock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_lock_irq</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;    <span class="comment">//相当于`spin_lock() + local_irq_disable()。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_lock_irqsave</span><span class="params">(<span class="type">spinlock_t</span> *lock, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="comment">//禁止中断(只在本地处理器)在获得自旋锁之前; 之前的中断状态保存在flags里。相当于spin_lock() + local_irq_save()。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_lock_bh</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;    <span class="comment">//获取锁之前禁止软件中断，但是硬件中断留作打开的，相当于spin_lock() + local_bh_disable()。</span></span><br></pre></td></tr></table></figure></p>
<p>也有 4 个方法来释放一个自旋锁; 你用的那个必须对应你用来获取锁的函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">spin_unlock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_unlock_irqrestore</span><span class="params">(<span class="type">spinlock_t</span> *lock, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_unlock_irq</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spin_unlock_bh</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure><br>下面看一下<code>DEFINE_SPINLOCK()</code>、<code>spin_lock_init()</code>、<code>spin_lock()</code>、<code>spin_lock_irqsave()</code>的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_SPINLOCK(x)    spinlock_t x = __SPIN_LOCK_UNLOCKED(x)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> spin_lock_init(lock)                    \</span></span><br><span class="line"><span class="meta">    do &#123; *(lock) = SPIN_LOCK_UNLOCKED; &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>spin_lock:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> spin_lock(lock)            _spin_lock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __lockfunc _spin_lock(<span class="type">spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    __spin_lock(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __spin_lock(<span class="type">spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    preempt_disable();</span><br><span class="line">    spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">    LOCK_CONTENDED(lock, _raw_spin_trylock, _raw_spin_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>spin_lock_irqsave:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> spin_lock_irqsave(lock, flags)            \</span></span><br><span class="line"><span class="meta">    do &#123;                        \</span></span><br><span class="line"><span class="meta">        typecheck(unsigned long, flags);    \</span></span><br><span class="line"><span class="meta">        flags = _spin_lock_irqsave(lock);    \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __lockfunc _spin_lock_irqsave(<span class="type">spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __spin_lock_irqsave(lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> __spin_lock_irqsave(<span class="type">spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"> </span><br><span class="line">    local_irq_save(flags);    <span class="comment">//spin_lock的实现没有禁止本地中断这一步</span></span><br><span class="line">    preempt_disable();</span><br><span class="line">    spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    LOCK_CONTENDED(lock, _raw_spin_trylock, _raw_spin_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    _raw_spin_lock_flags(lock, &amp;flags);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>读写自旋锁一种比自旋锁粒度更小的锁机制，它保留了“自旋”的概念，但是在写操作方面，只能最多有1个写进程，在读操作方面，同时可以有多个读执行单元。当然，读和写也不能同时进行。读者写者锁有一个类型<code>rwlock_t</code>，在<code>&lt;linux/spinlokc.h&gt;</code>中定义。 它们可以以 2 种方式被声明和被初始化:<br>静态方式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rwlock_t</span> my_rwlock = RW_LOCK_UNLOCKED;</span><br></pre></td></tr></table></figure><br>动态方式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rwlock_t</span> my_rwlock;</span><br><span class="line">rwlock_init(&amp;my_rwlock);</span><br></pre></td></tr></table></figure><br>可用函数的列表现在应当看来相当类似。 对于读者，有下列函数可用:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">read_lock</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_lock_irqsave</span><span class="params">(<span class="type">rwlock_t</span> *lock, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_lock_irq</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_lock_bh</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_unlock</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_unlock_irqrestore</span><span class="params">(<span class="type">rwlock_t</span> *lock, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_unlock_irq</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_unlock_bh</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure></p>
<p>对于写存取的函数是类似的:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_lock</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_lock_irqsave</span><span class="params">(<span class="type">rwlock_t</span> *lock, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_lock_irq</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_lock_bh</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">write_trylock</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_unlock</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_unlock_irqrestore</span><span class="params">(<span class="type">rwlock_t</span> *lock, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_unlock_irq</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_unlock_bh</span><span class="params">(<span class="type">rwlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure><br>在与下半部配合使用时，锁机制必须要小心使用。由于下半部可以抢占进程上下文的代码，所以当下半部和进程上下文共享数据时，必须对进程上下文的共享数据进行保护，所以需要加锁的同时还要禁止下半部执行。同样的，由于中断处理器可以抢占下半部，所以如果中断处理器程序和下半部共享数据，那么就必须在获取恰当的锁的同时还要禁止中断。 同类的<code>tasklet</code>不可能同时运行，所以对于同类<code>tasklet</code>中的共享数据不需要保护，但是当数据被两个不同种类的<code>tasklet</code>共享时，就需要在访问下半部中的数据前先获得一个普通的自旋锁。由于同种类型的两个软中断也可以同时运行在一个系统的多个处理器上，所以被软中断共享的数据必须得到锁的保护。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>一个被占有的自旋锁使得请求它的线程循环等待而不会睡眠，这很浪费处理器时间，所以自旋锁使用段时间占有的情况。Linux提供另外的同步方式可以在锁争用时让请求线程睡眠，直到锁重新可用时在唤醒它，这样处理器就不必循环等待，可以去执行其它代码。这种方式就是即将讨论的信号量。</p>
<p>信号量是一种睡眠锁，如果有一个任务试图获得一个已经被占用的信号量时，信号量会将其放入一个等待队列，然后睡眠。当持有的信号量被释放后，处于等待队列中的那个任务将被唤醒，并获得信号量。信号量比自旋锁提供了更好的处理器利用率，因为没有把时间花费在忙等带上。但是信号量也会有一定的开销，被阻塞的线程换入换出有两次明显的上下文切换，这样的开销比自旋锁要大的多。</p>
<p>如果需要在自旋锁和信号量中做出选择，应该根据锁被持有的时间长短做判断，如果加锁时间不长并且代码不会休眠，利用自旋锁是最佳选择。相反，如果加锁时间可能很长或者代码在持有锁有可能睡眠，那么最好使用信号量来完成加锁功能。信号量一个有用特性就是它可以同时允许任意数量的锁持有者，而自旋锁在一个时刻最多允许一个任务持有它。信号量同时允许的持有者数量可以在声明信号量时指定，当为1时，成为互斥信号量，否则成为计数信号量。</p>
<p>信号量的实现与体系结构相关，信号量使用<code>struct semaphore</code>类型用来表示信号量，定义于文件<code>&lt;include/linux/semaphore.h&gt;</code>中:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">     <span class="type">spinlock_t</span>        lock;</span><br><span class="line">     <span class="type">unsigned</span> <span class="type">int</span>        count;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>信号量初始化方法有如下:</p>
<p>方法一:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem</span>;</span>  </span><br><span class="line"><span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore *sem, <span class="type">int</span> val)</span>;<span class="comment">//初始化信号量，并设置信号量 sem 的值为 val。 </span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore *sem, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> __<span class="title">key</span>;</span></span><br><span class="line">	*sem = (<span class="keyword">struct</span> semaphore) __SEMAPHORE_INITIALIZER(*sem, val);</span><br><span class="line">	lockdep_init_map(&amp;sem-&gt;lock.dep_map, <span class="string">&quot;semaphore-&gt;lock&quot;</span>, &amp;__key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法二:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_MUTEX(name);</span><br></pre></td></tr></table></figure><br>定义一个名为 name 的信号量并初始化为1。<br>其实现为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_MUTEX(name)    \</span></span><br><span class="line"><span class="meta">    struct semaphore name = __SEMAPHORE_INITIALIZER(name, 1)</span></span><br></pre></td></tr></table></figure></p>
<p>方法三:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> init_MUTEX(sem)        sema_init(sem, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以不加锁状态动态创建信号量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> init_MUTEX_LOCKED(sem)    sema_init(sem, 0)    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以加锁状态动态创建信号量 </span></span><br></pre></td></tr></table></figure><br>信号量初始化后就可以使用了，使用信号量主要有如下方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="keyword">struct</span> semaphore * sem)</span>;</span><br><span class="line"><span class="comment">//该函数用于获得信号量 sem，它会导致睡眠，因此不能在中断上下文使用;  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">down_interruptible</span><span class="params">(<span class="keyword">struct</span> semaphore * sem)</span>;</span><br><span class="line"><span class="comment">//该函数功能与 down 类似，不同之处为，因为 down()而进入睡眠状态的进程不能被信号打断，但因为 down_interruptible()而进入睡眠状态的进程能被信号打断，信号也会导致该函数返回，这时候函数的返回值非 0;  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">down_trylock</span><span class="params">(<span class="keyword">struct</span> semaphore * sem)</span>;</span><br><span class="line"><span class="comment">//该函数尝试获得信号量`sem，如果能够立刻获得，它就获得该信号量并返回0， 否则，返回非0值。它不会导致调用者睡眠，可以在中断上下文使用。</span></span><br><span class="line"></span><br><span class="line">up(<span class="keyword">struct</span> semaphore * sem); </span><br><span class="line"><span class="comment">//释放指定信号量，如果睡眠队列不空，则唤醒其中一个队列。</span></span><br></pre></td></tr></table></figure></p>
<p>信号量一般这样使用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义信号量  </span></span><br><span class="line"><span class="comment">DECLARE_MUTEX(mount_sem);  </span></span><br><span class="line"><span class="comment">//down(&amp;mount_sem);/* 获取信号量，保护临界区，信号量被占用之后进入不可中断睡眠状态</span></span><br><span class="line"><span class="comment">down_interruptible(&amp;mount_sem);/* 获取信号量，保护临界区，信号量被占用之后进入不可中断睡眠状态</span></span><br><span class="line"><span class="comment">. . .  </span></span><br><span class="line"><span class="comment">critical section /* 临界区  </span></span><br><span class="line"><span class="comment">. . .  </span></span><br><span class="line"><span class="comment">up(&amp;mount_sem);/* 释放信号量  </span></span><br></pre></td></tr></table></figure><br>下面看一下这些函数的实现：</p>
<p>down():<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"> </span><br><span class="line">    spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (likely(sem-&gt;count &gt; <span class="number">0</span>))</span><br><span class="line">        sem-&gt;count--;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __down(sem);</span><br><span class="line">    spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __sched __down(<span class="keyword">struct</span> semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">    __down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>down_interruptible():<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">down_interruptible</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (likely(sem-&gt;count &gt; <span class="number">0</span>))</span><br><span class="line">        sem-&gt;count--;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = __down_interruptible(sem);</span><br><span class="line">    spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> noinline <span class="type">int</span> __sched __down_interruptible(<span class="keyword">struct</span> semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>down_trylock():<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">down_trylock</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"> </span><br><span class="line">    spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line">    count = sem-&gt;count - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (likely(count &gt;= <span class="number">0</span>))</span><br><span class="line">        sem-&gt;count = count;</span><br><span class="line">    spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> (count &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>up():<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">up</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"> </span><br><span class="line">    spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (likely(list_empty(&amp;sem-&gt;wait_list)))</span><br><span class="line">        sem-&gt;count++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __up(sem);</span><br><span class="line">    spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __sched __up(<span class="keyword">struct</span> semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> *<span class="title">waiter</span> =</span> list_first_entry(&amp;sem-&gt;wait_list,</span><br><span class="line">                        <span class="keyword">struct</span> semaphore_waiter, <span class="built_in">list</span>);</span><br><span class="line">    list_del(&amp;waiter-&gt;<span class="built_in">list</span>);</span><br><span class="line">    waiter-&gt;up = <span class="number">1</span>;</span><br><span class="line">    wake_up_process(waiter-&gt;task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正如自旋锁一样，信号量也有区分读写访问的可能，读写信号量在内核中使用<code>rw_semaphore</code>结构表示，x86体系结构定义在<code>&lt;arch/x86/include/asm/rwsem.h&gt;</code>文件中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> &#123;</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">long</span>        count;</span><br><span class="line">    <span class="type">spinlock_t</span>        wait_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>读写信号量的使用方法和信号量类似，其操作函数有如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_RWSEM(name)  <span class="comment">//声明名为name的读写信号量，并初始化它。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_rwsem</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;  <span class="comment">//对读写信号量`sem`进行初始化。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">down_read</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;   <span class="comment">//读者用来获取`sem，若没获得时，则调用者睡眠等待。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">up_read</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;     <span class="comment">//读者释放`sem。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">down_read_trylock</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>; <span class="comment">//读者尝试获取sem，如果获得返回1，如果没有获得返回0。可在中断上下文使用。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">down_write</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;  <span class="comment">//写者用来获取`sem，若没获得时，则调用者睡眠等待。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">down_write_trylock</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;   <span class="comment">//写者尝试获取sem，如果获得返回1，如果没有获得返回0。可在中断上下文使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">up_write</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>;    <span class="comment">//写者释放sem。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">downgrade_write</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span>; <span class="comment">//把写者降级为读者。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h2><p>除了信号量之外，内核拥有一个更简单的且可睡眠的锁，那就是互斥体。互斥体的行为和计数是1的信号量类似，其接口简单，实现更高效。 互斥体在内核中使用<code>mutex</code>表示，定义于<code>&lt;include/linux/mutex.h&gt;</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 1: unlocked, 0: locked, negative: locked, possible waiters */</span></span><br><span class="line">    <span class="type">atomic_t</span>        count;</span><br><span class="line">    <span class="type">spinlock_t</span>        wait_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>静态定义<code>mutex</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_MUTEX(name);</span><br></pre></td></tr></table></figure><br>实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_MUTEX(mutexname) \</span></span><br><span class="line"><span class="meta">    struct mutex mutexname = __MUTEX_INITIALIZER(mutexname)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MUTEX_INITIALIZER(lockname) \</span></span><br><span class="line"><span class="meta">        &#123; .count = ATOMIC_INIT(1) \</span></span><br><span class="line"><span class="meta">        , .wait_lock = __SPIN_LOCK_UNLOCKED(lockname.wait_lock) \</span></span><br><span class="line"><span class="meta">        , .wait_list = LIST_HEAD_INIT(lockname.wait_list) \</span></span><br><span class="line"><span class="meta">        __DEBUG_MUTEX_INITIALIZER(lockname) \</span></span><br><span class="line"><span class="meta">        __DEP_MAP_MUTEX_INITIALIZER(lockname) &#125;</span></span><br></pre></td></tr></table></figure><br>动态定义<code>mutex</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mutex_init(&amp;mutex);</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> mutex_init(mutex) \</span></span><br><span class="line"><span class="meta">do &#123;                            \</span></span><br><span class="line"><span class="meta">    static struct lock_class_key __key;        \</span></span><br><span class="line"><span class="meta">                            \</span></span><br><span class="line"><span class="meta">    __mutex_init((mutex), #mutex, &amp;__key);        \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span></span><br><span class="line">__mutex_init(<span class="keyword">struct</span> mutex *lock, <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> lock_class_key *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">atomic_set</span>(&amp;lock-&gt;count, <span class="number">1</span>);</span><br><span class="line">    spin_lock_init(&amp;lock-&gt;wait_lock);</span><br><span class="line">    INIT_LIST_HEAD(&amp;lock-&gt;wait_list);</span><br><span class="line">    mutex_clear_owner(lock);</span><br><span class="line"> </span><br><span class="line">    debug_mutex_init(lock, name, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>锁定和解锁如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">/* 临界区 */</span></span><br><span class="line">mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __sched <span class="title function_">mutex_lock</span><span class="params">(<span class="keyword">struct</span> mutex *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    might_sleep();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The locking fastpath is the 1-&gt;0 transition from</span></span><br><span class="line"><span class="comment">     * &#x27;unlocked&#x27; into &#x27;locked&#x27; state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    __mutex_fastpath_lock(&amp;lock-&gt;count, __mutex_lock_slowpath);</span><br><span class="line">    mutex_set_owner(lock);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> __sched <span class="title function_">mutex_unlock</span><span class="params">(<span class="keyword">struct</span> mutex *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The unlocking fastpath is the 0-&gt;1 transition from &#x27;locked&#x27;</span></span><br><span class="line"><span class="comment">     * into &#x27;unlocked&#x27; state:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When debugging is enabled we must not clear the owner before time,</span></span><br><span class="line"><span class="comment">     * the slow path will always be taken, and that clears the owner field</span></span><br><span class="line"><span class="comment">     * after verifying that it was indeed current.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mutex_clear_owner(lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    __mutex_fastpath_unlock(&amp;lock-&gt;count, __mutex_unlock_slowpath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其他<code>mutex</code>方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mutex_trylock</span><span class="params">(<span class="keyword">struct</span> mutex *)</span>;    <span class="comment">//视图获取指定互斥体，成功返回1；否则返回0。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mutex_is_locked</span><span class="params">(<span class="keyword">struct</span> mutex *lock)</span>;    <span class="comment">//判断锁是否被占用，是返回1，否则返回0。</span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>mutex</code>时，要注意一下：</p>
<ul>
<li><code>mutex</code>的使用技术永远是1；在同一上下文中上锁解锁；</li>
<li>当进程持有一个<code>mutex</code>时，进程不可退出；</li>
<li><code>mutex</code>不能在中断或下半部中使用。</li>
</ul>
<h2 id="抢占禁止"><a href="#抢占禁止" class="headerlink" title="抢占禁止"></a>抢占禁止</h2><p>在前面章节讲进程管理的时候听到过内核抢占，由于内核可抢占，内核中的进程随时都可能被另外一个具有更高优先权的进程打断，这也就意味着一个任务与被抢占的任务可能会在同一个临界区运行。所以才有本节前面自旋锁来避免竞态的发生，自旋锁有禁止内核抢占的功能。但像每CPU变量的数据只能被一个处理器访问，可以不需要使用锁来保护，如果没有使用锁，内核又是抢占式的，那么新调度的任务就可能访问同一个变量。这个时候就可以通过禁止内核抢占来避免竞态的发生，禁止内核抢占使用<code>preetmpt_disable()</code>函数，这是一个可以嵌套调用的函数，可以使用任意次。每次调用都必须有一个相应的<code>preempt_enable()</code>调用，当最后一次<code>preempt_enable()</code>被调用时，内核抢占才重新启用。内核抢占相关函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">preempt_enable() </span><br><span class="line"><span class="comment">//内核抢占计数preempt_count减1</span></span><br><span class="line">preempt_disable() </span><br><span class="line"><span class="comment">//内核抢占计数preempt_count加1，当该值降为0时检查和执行被挂起的需要调度的任务</span></span><br><span class="line">preempt_enable_no_resched()</span><br><span class="line"><span class="comment">//内核抢占计数preempt_count减1，但不立即抢占式调度</span></span><br><span class="line">preempt_check_resched () </span><br><span class="line"><span class="comment">//如果必要进行调度</span></span><br><span class="line">preempt_count() </span><br><span class="line"><span class="comment">//返回抢占计数</span></span><br><span class="line">preempt_schedule() </span><br><span class="line"><span class="comment">//内核抢占时的调度程序的入口点 </span></span><br></pre></td></tr></table></figure></p>
<p>以<code>preempt_enable()</code>为例，看一下其实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> preempt_enable() \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">    preempt_enable_no_resched(); \</span></span><br><span class="line"><span class="meta">    barrier(); \</span></span><br><span class="line"><span class="meta">    preempt_check_resched(); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> preempt_enable_no_resched() \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">    barrier(); \</span></span><br><span class="line"><span class="meta">    dec_preempt_count(); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dec_preempt_count() sub_preempt_count(1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sub_preempt_count(val)    do &#123; preempt_count() -= (val); &#125; while (0)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> preempt_check_resched() \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (unlikely(test_thread_flag(TIF_NEED_RESCHED))) \</span></span><br><span class="line"><span class="meta">        preempt_schedule(); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line">asmlinkage <span class="type">void</span> __sched <span class="title function_">preempt_schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">ti</span> =</span> current_thread_info();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If there is a non-zero preempt_count or interrupts are disabled,</span></span><br><span class="line"><span class="comment">     * we do not want to preempt the current task. Just return..</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (likely(ti-&gt;preempt_count || irqs_disabled()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        add_preempt_count(PREEMPT_ACTIVE);</span><br><span class="line">        schedule();</span><br><span class="line">        sub_preempt_count(PREEMPT_ACTIVE);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Check again in case we missed a preemption opportunity</span></span><br><span class="line"><span class="comment">         * between schedule and now.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        barrier();</span><br><span class="line">    &#125; <span class="keyword">while</span> (need_resched());</span><br></pre></td></tr></table></figure></p>
<h1 id="内存管理之页的分配与回收"><a href="#内存管理之页的分配与回收" class="headerlink" title="内存管理之页的分配与回收"></a>内存管理之页的分配与回收</h1><p>内存管理单元（MMU）负责将管理内存，在把虚拟地址转换为物理地址的硬件的时候是按页为单位进行处理，从虚拟内存的角度来看，页就是内存管理中的最小单位。页的大小与体系结构有关，在 x86 结构中一般是4KB（32位）或者8KB（64位）。<br>通过 getconf 命令可以查看系统的<code>page</code>的大小：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># getconf -a | grep PAGE</span><br><span class="line">PAGESIZE                           4096</span><br><span class="line">PAGE_SIZE                          4096</span><br><span class="line">_AVPHYS_PAGES                      230873</span><br><span class="line">_PHYS_PAGES                        744957 </span><br></pre></td></tr></table></figure><br>内核中的每个物理页用<code>struct page</code>结构表示，结构定义于文件<code>&lt;include/linux/mm_types.h&gt;</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;        <span class="comment">/*页的状态*/</span></span><br><span class="line">    <span class="type">atomic_t</span> _count;        <span class="comment">/* 页引用计数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">atomic_t</span> _mapcount; <span class="comment">/* 已经映射到mms的pte的个数*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>        <span class="comment">/* */</span></span><br><span class="line">            u16 inuse;</span><br><span class="line">            u16 objects;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> private;     </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_SPLIT_PTLOCKS</span></span><br><span class="line">        <span class="type">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab</span>;</span>    <span class="comment">/* 指向slab层 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">first_page</span>;</span>    <span class="comment">/* Compound tail pages */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">pgoff_t</span> index;      <span class="comment">/* Our offset within mapping. */</span></span><br><span class="line">        <span class="type">void</span> *freelist;     <span class="comment">/* SLUB: freelist req. slab lock */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span>       <span class="comment">/* 将页关联起来的链表项 */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">    <span class="type">void</span> *virtual;          <span class="comment">/* Kernel virtual address (NULL if</span></span><br><span class="line"><span class="comment">                       not kmapped, ie. highmem) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WANT_PAGE_DEBUG_FLAGS</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> debug_flags;  <span class="comment">/* Use atomic bitops on this */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KMEMCHECK</span></span><br><span class="line">    <span class="type">void</span> *shadow;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>内核使用这一结构来管理系统中所有的页，因为内核需要知道一个该页是否被分配，是被谁拥有的等信息。</p>
<p>由于ISA总线的DMA处理器有严格的限制，只能对物理内存前16M寻址，内核线性地址空间只有1G，CPU不能直接访问所有的物理内存。这样就导致有一些内存不能永久地映射在内核空间上。所以在Linux中，把页分为不同的区，使用区来对具有相似特性的页进行分组。分组如下（以x86-32为例）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>区域</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZONE_DMA</td>
<td>小于16M内存页框，这个区包含的页用来执行DMA操作。</td>
</tr>
<tr>
<td>ZONE_NORMAL</td>
<td>16M~896M内存页框，个区包含的都是能正常映射的页。</td>
</tr>
<tr>
<td>ZONE_HIGHMEM</td>
<td>大于896M内存页框，这个区包”高端内存”，其中的页能不永久地映射到内核地址空间。</td>
</tr>
</tbody>
</table>
</div>
<p>linux 把系统的页划分区，形成不同的内存池，这样就可以根据用途进行分配了。</p>
<p>每个区都用<code>struct zone</code>表示，定义于<code>&lt;include/linux/mmzone.h&gt;</code>中。该结构体较大，详细结构体信息可以查看源码文件。</p>
<p>Linux提供了几个以页为单位分配释放内存的接口，定义于<code>&lt;include/linux/gfp.h&gt;</code>中。分配内存主要有以下方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>alloc_page(gfp_mask)</td>
<td>只分配一页，返回指向页结构的指针</td>
</tr>
<tr>
<td>alloc_pages(gfp_mask, order)</td>
<td>分配 2^order 个页，返回指向第一页页结构的指针</td>
</tr>
<tr>
<td>__get_free_page(gfp_mask)</td>
<td>只分配一页，返回指向其逻辑地址的指针</td>
</tr>
<tr>
<td>__get_free_pages(gfp_mask, order)</td>
<td>分配 2^order 个页，返回指向第一页逻辑地址的指针</td>
</tr>
<tr>
<td>get_zeroed_page(gfp_mask)</td>
<td>只分配一页，让其内容填充为0，返回指向其逻辑地址的指针</td>
</tr>
</tbody>
</table>
</div>
<p><code>alloc_*</code>函数返回的是内存的物理地址，<code>get_*</code>函数返回内存物理地址映射后的逻辑地址。如果无须直接操作物理页结构体的话，一般使用 <code>get_*</code>函数。</p>
<p>释放页的函数有：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __free_pages( <span class="keyword">struct</span> page *page, unsignedintorder); </span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">free_pages</span><span class="params">(<span class="type">unsigned</span> longaddr, <span class="type">unsigned</span> intorder)</span>; </span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">free_hot_page</span><span class="params">( <span class="keyword">struct</span> page *page)</span>;</span><br></pre></td></tr></table></figure><br>当需要以页为单位的连续物理页时，可以使用上面这些分配页的函数，对于常用以字节为单位的分配来说，内核提供来<code>kmalloc()</code>函数。</p>
<p><code>kmalloc()</code>函数和用户空间一族函数类似，它可以以字节为单位分配内存，对于大多数内核分配来说，<code>kmalloc</code>函数用得更多。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> gfp_mask)</span>；</span><br></pre></td></tr></table></figure></p>
<p>参数中有个<code>gfp_mask</code>标志，这个标志是控制分配内存时必须遵守的一些规则。</p>
<p><code>gfp_mask</code>标志有3类：</p>
<ul>
<li>行为标志 ：控制分配内存时，分配器的一些行为，如何分配所需内存。</li>
<li>区标志   ：控制内存分配在那个区(ZONE_DMA, ZONE_NORMAL, ZONE_HIGHMEM 之类)。</li>
<li>类型标志 ：由上面2种标志组合而成的一些常用的场景。</li>
</ul>
<p>行为标志主要有以下几种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>行为标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>__GFP_WAIT</td>
<td>分配器可以睡眠</td>
</tr>
<tr>
<td>__GFP_HIGH</td>
<td>分配器可以访问紧急事件缓冲池</td>
</tr>
<tr>
<td>__GFP_IO</td>
<td>分配器可以启动磁盘`I/O</td>
</tr>
<tr>
<td>__GFP_FS</td>
<td>分配器可以启动文件系统`I/O</td>
</tr>
<tr>
<td>__GFP_COLD</td>
<td>分配器应该使用高速缓存中快要淘汰出去的页</td>
</tr>
<tr>
<td>__GFP_NOWARN</td>
<td>分配器将不打印失败警告</td>
</tr>
<tr>
<td>__GFP_REPEAT</td>
<td>分配器在分配失败时重复进行分配，但是这次分配还存在失败的可能</td>
</tr>
<tr>
<td>__GFP_NOFALL</td>
<td>分配器将无限的重复进行分配。分配不能失败</td>
</tr>
<tr>
<td>__GFP_NORETRY</td>
<td>分配器在分配失败时不会重新分配</td>
</tr>
<tr>
<td>__GFP_NO_GROW</td>
<td>由slab层内部使用</td>
</tr>
<tr>
<td>__GFP_COMP</td>
<td>添加混合页元数据，在 hugetlb 的代码内部使用</td>
</tr>
</tbody>
</table>
</div>
<p>标志主要有以下3种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>区标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__GFP_DMA</code></td>
<td>从 ZONE_DMA 分配</td>
</tr>
<tr>
<td><code>__GFP_DMA32</code></td>
<td>只在 ZONE_DMA32 分配 ，和 ZONE_DMA 类似，该区包含的页也可以进行<code>DMA</code>操作</td>
</tr>
<tr>
<td><code>__GFP_HIGHMEM</code></td>
<td>从 ZONE_HIGHMEM 或者 ZONE_NORMAL 分配，优先从 ZONE_HIGHMEM 分配，如果 ZONE_HIGHMEM 没有多余的页则从ZONE_NORMAL 分配</td>
</tr>
</tbody>
</table>
</div>
<p>类型标志是编程中最常用的，在使用标志时，应首先看看类型标志中是否有合适的，如果没有，再去自己组合 行为标志和区标志。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型标志</th>
<th>描述</th>
<th>实际标志</th>
</tr>
</thead>
<tbody>
<tr>
<td>GFP_ATOMIC</td>
<td>这个标志用在中断处理程序，下半部，持有自旋锁以及其他不能睡眠的地方</td>
<td><code>__GFP_HIGH</code></td>
</tr>
<tr>
<td>GFP_NOWAIT</td>
<td>与 GFP_ATOMIC 类似，不同之处在于，调用不会退给紧急内存池。这就增加了内存分配失败的可能性</td>
<td><code>0</code></td>
</tr>
<tr>
<td>GFP_NOIO</td>
<td>这种分配可以阻塞，但不会启动磁盘<code>I/O</code>。这个标志在不能引发更多磁盘<code>I/O</code>时能阻塞<code>I/O</code>代码，可能会导致递归</td>
<td><code>__GFP_WAIT</code></td>
</tr>
<tr>
<td>GFP_NOFS</td>
<td>这种分配在必要时可能阻塞，也可能启动磁盘<code>I/O</code>，但不会启动文件系统操作。这个标志在你不能再启动另一个文件系统的操作时，用在文件系统部分的代码中</td>
<td><code>(__GFP_WAIT｜ __GFP_IO)</code></td>
</tr>
<tr>
<td>GFP_KERNEL</td>
<td>这是常规的分配方式，可能会阻塞。这个标志在睡眠安全时用在进程上下文代码中。为了获得调用者所需的内存，内核会尽力而为。这个标志应当为首选标志</td>
<td><code>(__GFP_WAIT｜ __GFP_IO ｜ __GFP_FS )</code></td>
</tr>
<tr>
<td>GFP_USER</td>
<td>这是常规的分配方式，可能会阻塞。用于为用户空间进程分配内存时</td>
<td><code>(__GFP_WAIT｜ __GFP_IO ｜ __GFP_FS )</code></td>
</tr>
<tr>
<td>GFP_HIGHUSER</td>
<td>从 ZONE_HIGHMEM 进行分配，可能会阻塞。用于为用户空间进程分配内存</td>
<td><code>(__GFP_WAIT｜ __GFP_IO ｜ __GFP_FS ｜__GFP_HIGHMEM)</code></td>
</tr>
<tr>
<td>GFP_DMA</td>
<td>从 ZONE_DMA 进行分配。需要获取能供<code>DMA</code>使用的内存的设备驱动程序使用这个标志。通常与以上的某个标志组合在一起使用。</td>
<td><code>__GFP_DMA</code></td>
</tr>
</tbody>
</table>
</div>
<p>以上各种类型标志的使用场景总结：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>场景</th>
<th>相应标志</th>
</tr>
</thead>
<tbody>
<tr>
<td>进程上下文，可以睡眠</td>
<td>使用 GFP_KERNEL</td>
</tr>
<tr>
<td>进程上下文，不可以睡眠</td>
<td>使用 GFP_ATOMIC，在睡眠之前或之后以 GFP_KERNEL 执行内存分配</td>
</tr>
<tr>
<td>中断处理程序</td>
<td>使用 GFP_ATOMIC</td>
</tr>
<tr>
<td>软中断</td>
<td>使用 GFP_ATOMIC</td>
</tr>
<tr>
<td>tasklet</td>
<td>使用 GFP_ATOMIC</td>
</tr>
<tr>
<td>需要用于<code>DMA</code>的内存，可以睡眠</td>
<td>使用 (GFP_DMA｜GFP_KERNEL)</td>
</tr>
<tr>
<td>需要用于<code>DMA</code>的内存，不可以睡眠</td>
<td>使用 (GFP_DMA｜GFP_ATOMIC)，或者在睡眠之前执行内存分配</td>
</tr>
</tbody>
</table>
</div>
<p>kmalloc 所对应的释放内存的方法为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *)</span>；</span><br></pre></td></tr></table></figure><br>vmalloc()也可以按字节来分配内存。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *vmalloc(unsigned long size)</span><br></pre></td></tr></table></figure><br>和<code>kmalloc</code>是一样的作用，不同在于前者分配的内存虚拟地址是连续的，而物理地址则无需连续。<code>kmalloc()</code>可以保证在物理地址上都是连续的，虚拟地址当然也是连续的。<code>vmalloc()</code>函数只确保页在虚拟机地址空间内是连续的。它通过分配非联系的物理内存块，再“修正”页表，把内存映射到逻辑地址空间的连续区域中，就能做到这点。但很显然这样会降低处理性能，因为内核不得不做“拼接”的工作。所以这也是为什么不得已才使用<code>vmalloc()</code>的原因 。<code>vmalloc()</code>可能睡眠，不能从中断上下文中进行调用，也不能从其他不允许阻塞的情况下进行调用。释放时必须使用<code>vfree()</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *)</span>；</span><br></pre></td></tr></table></figure></p>
<p>对于内存页面的管理，通常是先在虚存空间中分配一个虚存区间，然后才根据需要为此区间分配相应的物理页面并建立起映射，也就是说，虚存区间的分配在前，而物理页面的分配在后。但由于频繁的请求和释放不同大小的连续页框，必然导致在已分配页框的块内分散了许多小块的空闲页框，由此产生的问题是：即使有足够的空闲页框可以满足请求，但当要分配一个大块的连续页框时，无法满足请求。这就是著名的内存管理问题：外碎片问题。Linux采用著名的伙伴（Buddy）系统算法来解决外碎片问题。</p>
<p>把所有的空闲页框分组为11个块链表。每个块链表包含大小为1,2,4,8,16,32,64,128,256,512，1024个的页框。伙伴系统算法原理为：</p>
<p>假设请求一个256个页框的块，先在256个页框的链表内检查是否有一个空闲的块。如果没有这样的块，算法会查找下一个更大的块，在512个页框的链表中找一个空闲块。如果存在这样的块，内核就把512的页框分成两半，一半用作满足请求，另一半插入256个页框的链表中。如果512个页框的块链表也没有空闲块，就继续找更大的块，1024个页框的块。如果这样的块存在，内核把1024个页框的256个页框用作请求，然后从剩余的768个中拿出512个插入512个页框的链表中，把最后256个插入256个页框的链表中。</p>
<p>页框块的释放过程如下：</p>
<p>如果两个块具有相同的大小：a，并且他们的物理地址连续那么这两个块成为伙伴，内核就会试图把大小为<code>a</code>的一对空闲伙伴块合并为一个大小为<code>2a</code>的单独块。该算法还是迭代的，如果合并成功的话，它还会试图合并<code>2a</code>的块。</p>
<p>管理分区数据结构<code>struct zone_struct</code>中，涉及到空闲区数据结构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>    <span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span>        nr_free; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>采用伙伴算法分配内存时，每次至少分配一个页面。但当请求分配的内存大小为几十个字节或几百个字节时应该如何处理？如何在一个页面中分配小的内存区，小内存区的分配所产生的内碎片又如何解决？slab的分配模式可以解决该问题。</p>
<h1 id="内存管理之slab分配器"><a href="#内存管理之slab分配器" class="headerlink" title="内存管理之slab分配器"></a>内存管理之slab分配器</h1><p>上一节最后说到对于小内存区的请求，如果采用伙伴系统来进行分配，则会在页内产生很多空闲空间无法使用，因此产生slab分配器来处理对小内存区（几十或几百字节）的请求。Linux中引入slab的主要目的是为了减少对伙伴算法的调用次数。</p>
<p>内核经常反复使用某一内存区。例如，只要内核创建一个新的进程，就要为该进程相关的数据结构（task_struct、打开文件对象等）分配内存区。当进程结束时，收回这些内存区。因为进程的创建和撤销非常频繁，Linux把那些频繁使用的页面保存在高速缓存中并重新使用。</p>
<p>slab分配器基于对象进行管理，相同类型的对象归为一类(如进程描述符就是一类)，每当要申请这样一个对象，slab分配器就分配一个空闲对象出去，而当要释放时，将其重新保存在slab分配器中，而不是直接返回给伙伴系统。对于频繁请求的对象，创建适当大小的专用对象来处理。对于不频繁的对象，用一系列几何分布大小的对象来处理（详见通用对象）。</p>
<p>slab分配模式把对象分组放进缓冲区，为缓冲区的组织和管理与硬件高速缓存的命中率密切相关，因此，slab缓冲区并非由各个对象直接构成，而是由一连串的“大块（Slab）”构成，而每个大块中则包含了若干个同种类型的对象，这些对象或已被分配，或空闲。实际上，缓冲区就是主存中的一片区域，把这片区域划分为多个块，每块就是一个slab，每个slab由一个或多个页面组成，每个slab中存放的就是对象。</p>
<p>slab相关数据结构：</p>
<p>缓冲区数据结构使用<code>kmem_cache</code>结构来表示。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line"><span class="comment">/* 1) per-cpu data, touched during every alloc/free */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">array</span>[<span class="title">NR_CPUS</span>];</span></span><br><span class="line"><span class="comment">/* 2) Cache tunables. Protected by cache_chain_mutex */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> batchcount;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> limit;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> shared;</span><br><span class="line"> </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> buffer_size;</span><br><span class="line">	u32 reciprocal_buffer_size;</span><br><span class="line"><span class="comment">/* 3) touched by every alloc &amp; free from the backend */</span></span><br><span class="line"> </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;		<span class="comment">/* constant flags */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num;		<span class="comment">/* # of objs per slab */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 4) cache_grow/shrink */</span></span><br><span class="line">	<span class="comment">/* order of pgs per slab (2^n) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> gfporder;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* force GFP flags, e.g. GFP_DMA */</span></span><br><span class="line">	<span class="type">gfp_t</span> gfpflags;</span><br><span class="line"> </span><br><span class="line">	<span class="type">size_t</span> colour;			<span class="comment">/* cache colouring range */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> colour_off;	<span class="comment">/* colour offset */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slabp_cache</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> slab_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> dflags;		<span class="comment">/* dynamic flags */</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* constructor func */</span></span><br><span class="line">	<span class="type">void</span> (*ctor)(<span class="type">void</span> *obj);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 5) cache creation/removal */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">next</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 6) statistics */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SLAB</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> num_active;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> num_allocations;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> high_mark;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> grown;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> reaped;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> errors;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> max_freeable;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> node_allocs;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> node_frees;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> node_overflow;</span><br><span class="line">	<span class="type">atomic_t</span> allochit;</span><br><span class="line">	<span class="type">atomic_t</span> allocmiss;</span><br><span class="line">	<span class="type">atomic_t</span> freehit;</span><br><span class="line">	<span class="type">atomic_t</span> freemiss;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If debugging is enabled, then the allocator can add additional</span></span><br><span class="line"><span class="comment">	 * fields and/or padding to every object. buffer_size contains the total</span></span><br><span class="line"><span class="comment">	 * object size including these internal fields, the following two</span></span><br><span class="line"><span class="comment">	 * variables contain the offset to the user object and its size.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> obj_offset;</span><br><span class="line">	<span class="type">int</span> obj_size;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_DEBUG_SLAB */</span></span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We put nodelists[] at the end of kmem_cache, because we want to size</span></span><br><span class="line"><span class="comment">	 * this array to nr_node_ids slots instead of MAX_NUMNODES</span></span><br><span class="line"><span class="comment">	 * (see kmem_cache_init())</span></span><br><span class="line"><span class="comment">	 * We still use [MAX_NUMNODES] and not [1] or [0] because cache_cache</span></span><br><span class="line"><span class="comment">	 * is statically defined, so we reserve the max number of nodes.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_list3</span> *<span class="title">nodelists</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Do not add fields after nodelists[]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>其中<code>struct kmem_list3</code>结构体链接slab，共享高速缓存，其定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The slab lists for all objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_list3</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_partial</span>;</span>	<span class="comment">/* partial list first, better asm code */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_full</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_free</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> free_objects;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> free_limit;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> colour_next;	<span class="comment">/* Per-node cache coloring */</span></span><br><span class="line">	<span class="type">spinlock_t</span> list_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">shared</span>;</span>	<span class="comment">/* shared per node */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> **<span class="title">alien</span>;</span>	<span class="comment">/* on other nodes */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> next_reap;	<span class="comment">/* updated without locking */</span></span><br><span class="line">	<span class="type">int</span> free_touched;		<span class="comment">/* updated without locking */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>该结构包含三个链表：<code>slabs_partial</code>、<code>slabs_full</code>、<code>slabs_free</code>，这些链表包含缓冲区所有slab，slab描述符<code>struct slab</code>用于描述每个slab：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * struct slab</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Manages the objs in a slab. Placed either at the beginning of mem allocated</span></span><br><span class="line"><span class="comment"> * for a slab, or allocated from an general cache.</span></span><br><span class="line"><span class="comment"> * Slabs are chained into three list: fully used, partial, fully free slabs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> colouroff;</span><br><span class="line">	<span class="type">void</span> *s_mem;		<span class="comment">/* including colour offset */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> inuse;	<span class="comment">/* num of objs active in slab */</span></span><br><span class="line">	<span class="type">kmem_bufctl_t</span> <span class="built_in">free</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> nodeid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>一个新的缓冲区使用如下函数创建：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> kmem_cache *<span class="title function_">kmem_cache_create</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">size_t</span> size, <span class="type">size_t</span> align, <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">void</span> (*ctor)(<span class="type">void</span> *))</span>; </span><br></pre></td></tr></table></figure><br>函数创建成功会返回一个指向所创建缓冲区的指针；撤销一个缓冲区调用如下函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kmem_cache_destroy</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep)</span>；</span><br></pre></td></tr></table></figure><br>上面两个函数都不能在中断上下文中使用，因为它可能睡眠。<br>在创建来缓冲区之后，可以通过下列函数获取对象：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmem_cache_alloc - Allocate an object</span></span><br><span class="line"><span class="comment"> * @cachep: The cache to allocate from.</span></span><br><span class="line"><span class="comment"> * @flags: See kmalloc().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Allocate an object from this cache.  The flags are only relevant</span></span><br><span class="line"><span class="comment"> * if the cache has no available objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmem_cache_alloc</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ret = __cache_alloc(cachep, flags, __builtin_return_address(<span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line">	trace_kmem_cache_alloc(_RET_IP_, ret,</span><br><span class="line">			       obj_size(cachep), cachep-&gt;buffer_size, flags);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数从给点缓冲区<code>cachep</code>中返回一个指向对象的指针。如果缓冲区的所有slab中都没有空闲对象，那么slab层必须通过<code>kmem_getpages()</code>获取新的页，参数<code>flags</code>传递给<code>_get_free_pages()</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">kmem_getpages</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">gfp_t</span> flags, <span class="type">int</span> nodeid)</span>；</span><br></pre></td></tr></table></figure><br>释放对象使用如下函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmem_cache_free - Deallocate an object</span></span><br><span class="line"><span class="comment"> * @cachep: The cache the allocation was from.</span></span><br><span class="line"><span class="comment"> * @objp: The previously allocated object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Free an object which was previously allocated from this</span></span><br><span class="line"><span class="comment"> * cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kmem_cache_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">void</span> *objp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"> </span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	debug_check_no_locks_freed(objp, obj_size(cachep));</span><br><span class="line">	<span class="keyword">if</span> (!(cachep-&gt;flags &amp; SLAB_DEBUG_OBJECTS))</span><br><span class="line">		debug_check_no_obj_freed(objp, obj_size(cachep));</span><br><span class="line">	__cache_free(cachep, objp);</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line"> </span><br><span class="line">	trace_kmem_cache_free(_RET_IP_, objp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果你要频繁的创建很多相同类型的对象，就要当考虑使用slab高速缓存区。</p>
<p>实际上上一节所讲<code>kmalloc()</code>函数也是使用slab分配器分配的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">cachep</span>;</span></span><br><span class="line">	<span class="type">void</span> *ret;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (__builtin_constant_p(size)) &#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (!size)</span><br><span class="line">			<span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE(x) \</span></span><br><span class="line"><span class="meta">		<span class="keyword">if</span> (size &lt;= x) \</span></span><br><span class="line"><span class="meta">			goto found; \</span></span><br><span class="line"><span class="meta">		<span class="keyword">else</span> \</span></span><br><span class="line"><span class="meta">			i++;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmalloc_sizes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> CACHE</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">found:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">		<span class="keyword">if</span> (flags &amp; GFP_DMA)</span><br><span class="line">			cachep = malloc_sizes[i].cs_dmacachep;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			cachep = malloc_sizes[i].cs_cachep;</span><br><span class="line"> </span><br><span class="line">		ret = kmem_cache_alloc_notrace(cachep, flags);</span><br><span class="line"> </span><br><span class="line">		trace_kmalloc(_THIS_IP_, ret,</span><br><span class="line">			      size, slab_buffer_size(cachep), flags);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> __kmalloc(size, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>kfree</code>函数实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kfree - free previously allocated memory</span></span><br><span class="line"><span class="comment"> * @objp: pointer returned by kmalloc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If @objp is NULL, no operation is performed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Don&#x27;t free memory not originally allocated by kmalloc()</span></span><br><span class="line"><span class="comment"> * or you will run into trouble.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *objp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">c</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"> </span><br><span class="line">	trace_kfree(_RET_IP_, objp);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(objp)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	kfree_debugcheck(objp);</span><br><span class="line">	c = virt_to_cache(objp);</span><br><span class="line">	debug_check_no_locks_freed(objp, obj_size(c));</span><br><span class="line">	debug_check_no_obj_freed(objp, obj_size(c));</span><br><span class="line">	__cache_free(c, (<span class="type">void</span> *)objp);</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，结合上一节，看看分配函数的选择：</p>
<ul>
<li>如果需要连续的物理页，就可以使用某个低级页分配器或<code>kmalloc()</code>。</li>
<li>如果想从高端内存进行分配，使用<code>alloc_pages()</code>。</li>
<li>如果不需要物理上连续的页，而仅仅是虚拟地址上连续的页，那么就是用<code>vmalloc</code>。</li>
<li>如果要创建和销毁很多大的数据结构，那么考虑建立slab高速缓存。</li>
</ul>
<h1 id="内存管理之进程地址空间"><a href="#内存管理之进程地址空间" class="headerlink" title="内存管理之进程地址空间"></a>内存管理之进程地址空间</h1><p>进程地址空间由进程可寻址的虚拟内存组成，Linux 的虚拟地址空间为0~4G字节（注：本节讲述均以32为为例）。Linux内核将这 4G 字节的空间分为两部分。将最高的 1G 字节(从虚拟地址0xC0000000到0xFFFFFFFF)，供内核使用，称为“内核空间”。而将较低的 3G 字节(从虚拟地址 0x00000000 到 0xBFFFFFFF)，供各个进程使用，称为“用户空间” 。因为每个进程可以通过系统调用进入内核。因此，Linux 内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有 4G 字节的虚拟空间。</p>
<p>尽管一个进程可以寻址4G的虚拟内存，但就不代表它就有权限访问所有的地址空间，虚拟内存空间必须映射到某个物理存储空间(内存或磁盘空间)，才真正地可以被使用。进程只能访问合法的地址空间，如果一个进程访问了不合法的地址空间，内核就会终止该进程，并返回“段错误”。虚拟内存的合法地址空间在哪而呢？我们先来看看进程虚拟地址空间的划分：</p>
<p>其中堆栈安排在虚拟地址空间顶部，数据段和代码段分布在虚拟地址空间底部，空洞部分就是进程运行时可以动态分布的空间，包括映射内核地址空间内容、动态申请地址空间、共享库的代码或数据等。在虚拟地址空间中，只有那些映射到物理存储空间的地址才是合法的地址空间。每一片合法的地址空间片段都对应一个独立的虚拟内存区域（VMA，virtual memory areas ），而进程的进程地址空间就是由这些内存区域组成。</p>
<p>Linux 采用了复杂的数据结构来跟踪进程的虚拟地址，进程地址空间使用内存描述符结构体来表示，内存描述符由<code>mm_struct</code>结构体表示，该结构体表示在<code>&lt;include/linux/mm_types.h&gt;</code>文件中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap</span>;</span>        <span class="comment">/* list of VMAs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap_cache</span>;</span>    <span class="comment">/* last find_vma result */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(<span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> pgoff, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line">    <span class="type">void</span> (*unmap_area) (<span class="keyword">struct</span> mm_struct *mm, <span class="type">unsigned</span> <span class="type">long</span> addr);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mmap_base;        <span class="comment">/* base of mmap area */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> task_size;        <span class="comment">/* size of task vm space */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cached_hole_size;     <span class="comment">/* if non-zero, the largest hole below free_area_cache */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> free_area_cache;        <span class="comment">/* first hole of size cached_hole_size or larger */</span></span><br><span class="line">    <span class="type">pgd_t</span> * pgd;</span><br><span class="line">    <span class="type">atomic_t</span> mm_users;            <span class="comment">/* How many users with user space? */</span></span><br><span class="line">    <span class="type">atomic_t</span> mm_count;            <span class="comment">/* How many references to &quot;struct mm_struct&quot; (users count as 1) */</span></span><br><span class="line">    <span class="type">int</span> map_count;                <span class="comment">/* number of VMAs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">mmap_sem</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span> page_table_lock;        <span class="comment">/* Protects page tables and some counters */</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span>        <span class="comment">/* List of maybe swapped mm&#x27;s.    These are globally strung together off init_mm.mmlist, and are protected by mmlist_lock */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Special counters, in some configurations protected by the</span></span><br><span class="line"><span class="comment">    * page_table_lock, in other configurations by being atomic.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">mm_counter_t</span> _file_rss;</span><br><span class="line">    <span class="type">mm_counter_t</span> _anon_rss;</span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hiwater_rss;    <span class="comment">/* High-watermark of RSS usage */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hiwater_vm;    <span class="comment">/* High-water virtual memory usage */</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> total_vm, locked_vm, shared_vm, exec_vm;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_vm, reserved_vm, def_flags, nr_ptes;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_brk, brk, start_stack;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> saved_auxv[AT_VECTOR_SIZE]; <span class="comment">/* for /proc/PID/auxv */</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">binfmt</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">cpumask_t</span> cpu_vm_mask;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line">    <span class="type">mm_context_t</span> context;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Swap token stuff */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Last value of global fault stamp as seen by this process.</span></span><br><span class="line"><span class="comment">     * In other words, this value gives an indication of how long</span></span><br><span class="line"><span class="comment">     * it has been since this task got the token.</span></span><br><span class="line"><span class="comment">     * Look at mm/thrash.c</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> faultstamp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> token_priority;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> last_interval;</span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags; <span class="comment">/* Must use atomic bitops to access the bits */</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">core_state</span> *<span class="title">core_state</span>;</span> <span class="comment">/* coredumping support */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_AIO</span></span><br><span class="line">    <span class="type">spinlock_t</span>        ioctx_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>    <span class="title">ioctx_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MM_OWNER</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * &quot;owner&quot; points to a task that is regarded as the canonical</span></span><br><span class="line"><span class="comment">     * user/owner of this mm. All of the following must be true in</span></span><br><span class="line"><span class="comment">     * order for it to be changed:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * current == mm-&gt;owner</span></span><br><span class="line"><span class="comment">     * current-&gt;mm != mm</span></span><br><span class="line"><span class="comment">     * new_owner-&gt;mm == mm</span></span><br><span class="line"><span class="comment">     * new_owner-&gt;alloc_lock is held</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">    <span class="comment">/* store ref to file /proc/&lt;pid&gt;/exe symlink points to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">exe_file</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> num_exe_file_vmas;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU_NOTIFIER</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mmu_notifier_mm</span> *<span class="title">mmu_notifier_mm</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>该结构体中第一行成员<code>mmap</code>就是内存区域，用结构体<code>struct vm_area_struct</code>来表示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This struct defines a memory VMM memory area. There is one of these</span></span><br><span class="line"><span class="comment"> * per VM-area/task.  A VM area is any part of the process virtual memory</span></span><br><span class="line"><span class="comment"> * space that has a special rule for the page-fault handlers (ie a shared</span></span><br><span class="line"><span class="comment"> * library, the executable area etc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">vm_mm</span>;</span>    <span class="comment">/* The address space we belong to. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_start;        <span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_end;        <span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">                       within vm_mm. */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">pgprot_t</span> vm_page_prot;        <span class="comment">/* Access permissions of this VMA. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_flags;        <span class="comment">/* Flags, see mm.h. */</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * For areas with an address space and backing store,</span></span><br><span class="line"><span class="comment">     * linkage into the address_space-&gt;i_mmap prio tree, or</span></span><br><span class="line"><span class="comment">     * linkage to the list of like vmas hanging off its node, or</span></span><br><span class="line"><span class="comment">     * linkage of vma in the address_space-&gt;i_mmap_nonlinear list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">            <span class="type">void</span> *parent;    <span class="comment">/* aligns with prio_tree_node parent */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">head</span>;</span></span><br><span class="line">        &#125; vm_set;</span><br><span class="line"> </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">raw_prio_tree_node</span> <span class="title">prio_tree_node</span>;</span></span><br><span class="line">    &#125; shared;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A file&#x27;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span></span><br><span class="line"><span class="comment">     * list, after a COW of one of the file pages.    A MAP_SHARED vma</span></span><br><span class="line"><span class="comment">     * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span></span><br><span class="line"><span class="comment">     * or brk vma (with NULL file) can only be in an anon_vma list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_node</span>;</span>    <span class="comment">/* Serialized by anon_vma-&gt;lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>    <span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Information about our backing store: */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_pgoff;        <span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">                       units, *not* PAGE_CACHE_SIZE */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>        <span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">    <span class="type">void</span> * vm_private_data;        <span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_truncate_count;<span class="comment">/* truncate_count or restart_addr */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">vm_region</span>;</span>    <span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span>    <span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><code>vm_area_struct</code>结构体描述了进程地址空间内连续区间上的一个独立内存范围，每一个内存区域都使用该结构体表示，每一个结构体以双向链表的形式连接起来。除链表结构外，Linux 还利用红黑树<code>mm_rb</code>来组织 vm_area_struct。通过这种树结构，Linux 可以快速定位某个虚拟内存地址。</p>
<p>该结构体中成员<code>vm_start</code>和<code>vm_end</code>表示内存区间的首地址和尾地址，两个值相减就是内存区间的长度。</p>
<p>成员<code>vm_mm</code>则指向其属于的进程地址空间结构体。所以两个不同的进程将同一个文件映射到自己的地址空间中，他们分别都会有一个<code>vm_area_struct</code>结构体来标识自己的内存区域。两个共享地址空间的线程则只有一个<code>vm_area_struct</code>结构体来标识，因为他们使用的是同一个进程地址空间。</p>
<p><code>vm_flags</code>标识内存区域所包含的页面的行为和信息，反映内核处理页面所需要遵守的行为准则。</p>
<p>可以使用<code>cat /proc/PID/maps</code>命令和<code>pmap</code>命令查看给定进程空间和其中所含的内存区域。以笔者系统上进程号为17192的进程为例。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/17192/maps     //显示该进程地址空间中全部内存区域</span></span><br><span class="line">001e3000-00201000 r-xp 00000000 fd:00 789547     /lib/ld-2.12.so</span><br><span class="line">00201000-00202000 r--p 0001d000 fd:00 789547     /lib/ld-2.12.so</span><br><span class="line">00202000-00203000 rw-p 0001e000 fd:00 789547     /lib/ld-2.12.so</span><br><span class="line">00209000-00399000 r-xp 00000000 fd:00 789548     /lib/libc-2.12.so</span><br><span class="line">00399000-0039a000 ---p 00190000 fd:00 789548     /lib/libc-2.12.so</span><br><span class="line">0039a000-0039c000 r--p 00190000 fd:00 789548     /lib/libc-2.12.so</span><br><span class="line">0039c000-0039d000 rw-p 00192000 fd:00 789548     /lib/libc-2.12.so</span><br><span class="line">0039d000-003a0000 rw-p 00000000 00:00 0</span><br><span class="line">08048000-08049000 r-xp 00000000 fd:00 1191771    /home/allen/Myprojects/blog/conn_user_kernel/test/a.out</span><br><span class="line">08049000-0804a000 rw-p 00000000 fd:00 1191771    /home/allen/Myprojects/blog/conn_user_kernel/test/a.out</span><br><span class="line">b7755000-b7756000 rw-p 00000000 00:00 0</span><br><span class="line">b776d000-b776e000 rw-p 00000000 00:00 0</span><br><span class="line">b776e000-b776f000 r-xp 00000000 00:00 0          [vdso]</span><br><span class="line">bfc9f000-bfcb4000 rw-p 00000000 00:00 0          [stack]</span><br><span class="line"><span class="comment"># </span></span><br></pre></td></tr></table></figure><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pmap 17192</span></span><br><span class="line">17192:   ./a.out</span><br><span class="line">001e3000    120K r-x--  /lib/ld-2.12.so    //本行和下面两行为动态链接程序ld.so的代码段、数据段、bss段</span><br><span class="line">00201000      4K r----  /lib/ld-2.12.so</span><br><span class="line">00202000      4K rw---  /lib/ld-2.12.so</span><br><span class="line">00209000   1600K r-x--  /lib/libc-2.12.so    //本行和下面为C库中libc.so的代码段、数据段和bss段</span><br><span class="line">00399000      4K -----  /lib/libc-2.12.so</span><br><span class="line">0039a000      8K r----  /lib/libc-2.12.so</span><br><span class="line">0039c000      4K rw---  /lib/libc-2.12.so</span><br><span class="line">0039d000     12K rw---    [ anon ]</span><br><span class="line">08048000      4K r-x--  /home/allen/Myprojects/blog/conn_user_kernel/test/a.out    //可执行对象的代码段</span><br><span class="line">08049000      4K rw---  /home/allen/Myprojects/blog/conn_user_kernel/test/a.out    //可执行对象的数据段</span><br><span class="line">b7755000      4K rw---    [ anon ]</span><br><span class="line">b776d000      4K rw---    [ anon ]</span><br><span class="line">b776e000      4K r-x--    [ anon ]</span><br><span class="line">bfc9f000     84K rw---    [ stack ]    //堆栈段</span><br><span class="line"> total     1860K</span><br></pre></td></tr></table></figure></p>
<p>结构体中<code>vm_ops</code>域指定内存区域相关操作函数表，内核使用表中方法操作VMA，操作函数表由<code>vm_operations_struct</code>结构体表示，定义在<code>&lt;include/linux/mm.h&gt;</code>文件中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These are the virtual MM functions - opening of an area, closing and</span></span><br><span class="line"><span class="comment"> * unmapping it (needed to keep files on disk up-to-date etc), pointer</span></span><br><span class="line"><span class="comment"> * to the functions called when a no-page or a wp-page exception occurs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> (*open)(<span class="keyword">struct</span> vm_area_struct * area);    <span class="comment">//指定内存区域被加载到一个地址空间时函数被调用</span></span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> vm_area_struct * area);    <span class="comment">//指定内存区域从地址空间删除时函数被调用</span></span><br><span class="line">    <span class="type">int</span> (*fault)(<span class="keyword">struct</span> vm_area_struct *vma, <span class="keyword">struct</span> vm_fault *vmf); <span class="comment">//没有出现在物理内存中的页面被访问时，页面故障处理调用该函数</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* notification that a previously read-only page is about to become</span></span><br><span class="line"><span class="comment">     * writable, if an error is returned it will cause a SIGBUS */</span></span><br><span class="line">    <span class="type">int</span> (*page_mkwrite)(<span class="keyword">struct</span> vm_area_struct *vma, <span class="keyword">struct</span> vm_fault *vmf);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* called by access_process_vm when get_user_pages() fails, typically</span></span><br><span class="line"><span class="comment">     * for use by special VMAs that can switch between memory and hardware</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*access)(<span class="keyword">struct</span> vm_area_struct *vma, <span class="type">unsigned</span> <span class="type">long</span> addr,</span><br><span class="line">              <span class="type">void</span> *buf, <span class="type">int</span> len, <span class="type">int</span> write);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    ......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在内核中，给定一个属于某个进程的虚拟地址，要求找到其所属的区间以及<code>vma_area_struct</code>结构，这通过<code>find_vma()</code>来实现，这种搜索通过红-黑树进行。该函数定义于<code>&lt;mm/mmap.c&gt;</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Look up the first VMA which satisfies  addr &lt; vm_end,  NULL if none. */</span></span><br><span class="line"><span class="keyword">struct</span> vm_area_struct *<span class="title function_">find_vma</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (mm) &#123;</span><br><span class="line">        <span class="comment">/* 首先检查最近使用的内存区域，看缓存的VMA是否包含所需地址 */</span></span><br><span class="line">        <span class="comment">/* (命中率接近35%.) */</span></span><br><span class="line">        vma = mm-&gt;mmap_cache;</span><br><span class="line">        <span class="comment">//如果缓存中不包含未包含希望的VMA，该函数搜索红-黑树。</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma &amp;&amp; vma-&gt;vm_end &gt; addr &amp;&amp; vma-&gt;vm_start &lt;= addr)) &#123;</span><br><span class="line">             <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> * <span class="title">rb_node</span>;</span></span><br><span class="line"> </span><br><span class="line">            rb_node = mm-&gt;mm_rb.rb_node;</span><br><span class="line">            vma = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">while</span> (rb_node) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">vma_tmp</span>;</span></span><br><span class="line"> </span><br><span class="line">                vma_tmp = rb_entry(rb_node, <span class="keyword">struct</span> vm_area_struct, vm_rb);</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (vma_tmp-&gt;vm_end &gt; addr) &#123;</span><br><span class="line">                    vma = vma_tmp;</span><br><span class="line">                    <span class="keyword">if</span> (vma_tmp-&gt;vm_start &lt;= addr)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    rb_node = rb_node-&gt;rb_left;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    rb_node = rb_node-&gt;rb_right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (vma)</span><br><span class="line">                mm-&gt;mmap_cache = vma;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当某个程序的映像开始执行时，可执行映像必须装入到进程的虚拟地址空间。如果该进程用到了任何一个共享库，则共享库也必须装入到进程的虚拟地址空间。由此可看出，Linux并不将映像装入到物理内存，相反，可执行文件只是被连接到进程的虚拟地址空间中。随着程序的运行，被引用的程序部分会由操作系统装入到物理内存，这种将映像链接到进程地址空间的方法被称为“内存映射”。</p>
<p>当可执行映像映射到进程的虚拟地址空间时，将产生一组<code>vm_area_struct</code>结构来描述虚拟内存区间的起始点和终止点，每个<code>vm_area_struct</code>结构代表可执行映像的一部分，可能是可执行代码，也可能是初始化的变量或未初始化的数据，这些都是在函数<code>do_mmap()</code>中来实现的。随着<code>vm_area_struct</code>结构的生成，这些结构所描述的虚拟内存区间上的标准操作函数也由 Linux 初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">do_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">unsigned</span> <span class="type">long</span> prot,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">long</span> flag, <span class="type">unsigned</span> <span class="type">long</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ret = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> ((offset + PAGE_ALIGN(len)) &lt; offset)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (!(offset &amp; ~PAGE_MASK))</span><br><span class="line">        ret = do_mmap_pgoff(file, addr, len, prot, flag, offset &gt;&gt; PAGE_SHIFT);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数会将一个新的地址区间加入到进程的地址空间中。定义于<code>&lt;include/linux/mm.h&gt;</code>。<br>函数中参数的含义：</p>
<ul>
<li><code>file</code>：表示要映射的文件。</li>
<li><code>offset</code>：文件内的偏移量，因为我们并不是一下子全部映射一个文件，可能只是映射文件的一部分，off 就表示那部分的起始位置。</li>
<li><code>len</code>：要映射的文件部分的长度。</li>
<li><code>addr</code>：虚拟空间中的一个地址，表示从这个地址开始查找一个空闲的虚拟区。</li>
<li><code>prot</code>：这个参数指定对这个虚拟区所包含页的存取权限。可能的标志有<code>PROT_READ</code>、<code>PROT_WRITE</code>、<code>PROT_EXEC</code>、<code>PROT_NONE</code>。前 3 个标志与标志<code>VM_READ</code>、<code>VM_WRITE</code>、<code>VM_EXEC</code>的意义一样。<code>PROT_NONE</code>表示进程没有以上 3 个存取权限中的任意一个。</li>
<li>flag`：这个参数指定虚拟区的其他标志。</li>
</ul>
<p>该函数调用<code>do_mmap_pgoff()</code>函数，该函数做内存映射的主要工作，该函数比较长，详细实现可查看<code>&lt;mm/mmap.c&gt;</code>文件。</p>
<p>由于文件到虚存的映射仅仅是建立了一种映射关系，虚存页面到物理页面之间的映射还没有建立。当某个可执行映象映射到进程虚拟内存中并开始执行时，因为只有很少一部分虚拟内存区间装入到了物理内存，很可能会遇到所访问的数据不在物理内存。这时，处理器将向 Linux 报告一个页故障及其对应的故障原因，</p>
<p>内核必须从磁盘映像或交换文件(此页被换出)中将其装入物理内存，这就是请页机制。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
