<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="概述Raft 是什么？Raft is a consensus algorithm for managing a replicated log. It produces a result equivalent to (multi-)Paxos, and it is as efficient as Paxos, but its structure is different from Paxos; th">
<meta property="og:type" content="article">
<meta property="og:title" content="解读Raft">
<meta property="og:url" content="http://yoursite.com/2021/12/04/%E8%A7%A3%E8%AF%BBraft/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="概述Raft 是什么？Raft is a consensus algorithm for managing a replicated log. It produces a result equivalent to (multi-)Paxos, and it is as efficient as Paxos, but its structure is different from Paxos; th">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/715f38a55fae4ef6bed7bb7cfd134825_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/f3e463285d0e4d6299fca19c7ef7e334_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/d9f2d1f2d3674a50900eda504ecaa326_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/fc2b320077124da39bade7adeaf7ef08_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/316b81a42ea843a192cc2f3578fbdb81_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/a851f56a384b4a0f9da76644d645ae1f_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/a6e0e622b7384ac78f733e471b280c27_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/d4ce0c7fdf3b4039a0e4b0b200af731a_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/2535cfeb9cfb44d4a0a04506f09f7485_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/04163db3b7ca4b4c8fbfdf4e7253a98f_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/517e2f7939394b3ca35936702a107f07_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/b52e004bd4654cb1b51cdb409182156f_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/33f858652afc4be6bb1d7b1f1dc33eaa_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/7d45e677f6c2428d9b9db7022416fe26_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/1418b09699fe4614a594a565c55055d5_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/f0d9d314c75c4bd989dadf044ecd6307_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/31b9745a2fa94fb693a7ea1257aa5f7f_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/60d6b91f49ac4d11bee43f86f33566d6_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/11bd5a3d291b43d2b31fea3a75fb3655_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/7a17a0e447534541a520ec97a9942cdd_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/2b0c350086014a52a4989f02f5262153_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/6f062cd961a24c5a951f2c025f065bd4_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/97dbbaaf72cc4a2ba148cb252bce95ec_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/a127762b466a48719967d52ab9f0636c_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/f7ebe584867b4c0b98b1e46f595a5007_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/012758dde1ba4305b417d860236a2ecc_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/b1b4e211fca44ca9bf5a67639e92d4d4_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/00cd4fb677dc4a8987c015b6f074a3b8_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/1c063b8c7e824bb88ffe572439c90975_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/85436861e4484446afac9192d02bc292_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/3af62adcab904fbc8d606b1ad29d9a34_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/00ef776fc5b64e56bd2abbfae3371329_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/286a2248256b4b9f84ff613318432103_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/d22cb375fc664ac2a5585417a50028de_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/0d9c3635c4d245188997538e36cb972d_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="og:image" content="http://yoursite.com/img/5d2ab2d829fe4fa086298245edc24dea_tplv-k3u1fbpfcp-watermark.awebp">
<meta property="article:published_time" content="2021-12-03T16:33:00.000Z">
<meta property="article:modified_time" content="2022-01-06T09:01:45.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="分布式系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/715f38a55fae4ef6bed7bb7cfd134825_tplv-k3u1fbpfcp-watermark.awebp">

<link rel="canonical" href="http://yoursite.com/2021/12/04/%E8%A7%A3%E8%AF%BBraft/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>解读Raft | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/resume.pdf" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/12/04/%E8%A7%A3%E8%AF%BBraft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          解读Raft
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-04 00:33:00" itemprop="dateCreated datePublished" datetime="2021-12-04T00:33:00+08:00">2021-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-06 17:01:45" itemprop="dateModified" datetime="2022-01-06T17:01:45+08:00">2022-01-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="Raft-是什么？"><a href="#Raft-是什么？" class="headerlink" title="Raft 是什么？"></a>Raft 是什么？</h2><p>Raft is a consensus algorithm for managing a replicated log. It produces a result equivalent to (multi-)Paxos, and it is as efficient as Paxos, but its structure is different from Paxos; this makes Raft more understandable than Paxos and also provides a better foundation for building practical systems.</p>
<p>—《In Search of an Understandable Consensus Algorithm》</p>
<p>在分布式系统中，为了消除单点提高系统可用性，通常会使用副本来进行容错，但这会带来另一个问题，即如何保证多个副本之间的一致性？</p>
<p>这里我们只讨论强一致性，即线性一致性。弱一致性涵盖的范围较广，涉及根据实际场景进行诸多取舍，不在 Raft 系列的讨论目标范围内。</p>
<p>所谓的强一致性（线性一致性）并不是指集群中所有节点在任一时刻的状态必须完全一致，而是指一个目标，即让一个分布式系统看起来只有一个数据副本，并且读写操作都是原子的，这样应用层就可以忽略系统底层多个数据副本间的同步问题。也就是说，我们可以将一个强一致性分布式系统当成一个整体，一旦某个客户端成功的执行了写操作，那么所有客户端都一定能读出刚刚写入的值。即使发生网络分区故障，或者少部分节点发生异常，整个集群依然能够像单机一样提供服务。</p>
<p>共识算法（Consensus Algorithm）就是用来做这个事情的，它保证即使在小部分（≤ (N-1)/2）节点故障的情况下，系统仍然能正常对外提供服务。共识算法通常基于状态复制机（Replicated State Machine）模型，也就是所有节点从同一个 state 出发，经过同样的操作 log，最终达到一致的 state。<br><img src="/img/715f38a55fae4ef6bed7bb7cfd134825_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>共识算法是构建强一致性分布式系统的基石，Paxos 是共识算法的代表，而 Raft 则是其作者在博士期间研究 Paxos 时提出的一个变种，主要优点是容易理解、易于实现，甚至关键的部分都在论文中给出了伪代码实现。</p>
<h2 id="谁在使用-Raft"><a href="#谁在使用-Raft" class="headerlink" title="谁在使用 Raft"></a>谁在使用 Raft</h2><p>采用 Raft 的系统最著名的当属 etcd 了，可以认为 etcd 的核心就是 Raft 算法的实现。作为一个分布式 kv 系统，etcd 使用 Raft 在多节点间进行数据同步，每个节点都拥有全量的状态机数据。我们在学习了 Raft 以后将会深刻理解为什么 etcd 不适合大数据量的存储（for the most critical data）、为什么集群节点数不是越多越好、为什么集群适合部署奇数个节点等问题。</p>
<p>作为一个微服务基础设施，consul 底层使用 Raft 来保证 consul server 之间的数据一致性。在阅读完第六章后，我们会理解为什么 consul 提供了 default、consistent、stale 三种一致性模式（Consistency Modes）、它们各自适用的场景，以及 consul 底层是如何通过改变 Raft 读模型来支撑这些不同的一致性模式的。</p>
<p>TiKV 同样在底层使用了 Raft 算法。虽然都自称是“分布式 kv 存储”，但 TiKV 的使用场景与 etcd 存在区别。其目标是支持 100TB+ 的数据，类似 etcd 的单 Raft 集群肯定无法支撑这个数据量。因此 TiKV 底层使用 Multi Raft，将数据划分为多个 region，每个 region 其实还是一个标准的 Raft 集群，对每个分区的数据实现了多副本高可用。</p>
<p>目前 Raft 在工业界已经开始大放异彩，对于其各类应用场景这里不再赘述，感兴趣的读者可以参考 这里，下方有列出各种语言的大量 Raft 实现。</p>
<h2 id="Raft-基本概念"><a href="#Raft-基本概念" class="headerlink" title="Raft 基本概念"></a>Raft 基本概念</h2><p>Raft 使用 Quorum 机制来实现共识和容错，我们将对 Raft 集群的操作称为提案，每当发起一个提案，必须得到大多数（&gt; N/2）节点的同意才能提交。</p>
<p>这里的“提案”我们可以先狭义地理解为对集群的读写操作，“提交”理解为操作成功。</p>
<p>那么当我们向 Raft 集群发起一系列读写操作时，集群内部究竟发生了什么呢？我们先来概览式地做一个整体了解，接下来再分章节详细介绍每个部分。</p>
<p>首先，Raft 集群必须存在一个主节点（leader），我们作为客户端向集群发起的所有操作都必须经由主节点处理。所以 Raft 核心算法中的第一部分就是选主（Leader election）——没有主节点集群就无法工作，先票选出一个主节点，再考虑其它事情。</p>
<p>其次，主节点需要承载什么工作呢？它会负责接收客户端发过来的操作请求，将操作包装为日志同步给其它节点，在保证大部分节点都同步了本次操作后，就可以安全地给客户端回应响应了。这一部分工作在 Raft 核心算法中叫日志复制（Log replication）。</p>
<p>然后，因为主节点的责任是如此之大，所以节点们在选主的时候一定要谨慎，只有符合条件的节点才可以当选主节点。此外主节点在处理操作日志的时候也一定要谨慎，为了保证集群对外展现的一致性，不可以覆盖或删除前任主节点已经处理成功的操作日志。所谓的“谨慎处理”，其实就是在选主和提交日志的时候进行一些限制，这一部分在 Raft 核心算法中叫安全性（Safety）。</p>
<p>Raft 核心算法其实就是由这三个子问题组成的：选主（Leader election）、日志复制（Log replication）、安全性（Safety）。这三部分共同实现了 Raft 核心的共识和容错机制。</p>
<p>除了核心算法外，Raft 也提供了几个工程实践中必须面对问题的解决方案。</p>
<ul>
<li>第一个是关于日志无限增长的问题。Raft 将操作包装成为了日志，集群每个节点都维护了一个不断增长的日志序列，状态机只有通过重放日志序列来得到。但由于这个日志序列可能会随着时间流逝不断增长，因此我们必须有一些办法来避免无休止的磁盘占用和过久的日志重放。这一部分叫日志压缩（Log compaction）。</li>
<li>第二个是关于集群成员变更的问题。一个 Raft 集群不太可能永远是固定几个节点，总有扩缩容的需求，或是节点宕机需要替换的时候。直接更换集群成员可能会导致严重的脑裂问题。Raft 给出了一种安全变更集群成员的方式。这一部分叫集群成员变更（Cluster membership change）。</li>
</ul>
<p>此外，我们还会额外讨论线性一致性的定义、为什么 Raft 不能与线性一致划等号、如何基于 Raft 实现线性一致，以及在如何保证线性一致的前提下进行读性能优化。</p>
<p>以上便是理论篇内将会讨论到的大部分内容的概要介绍，这里我们对 Raft 已经有了一个宏观上的认识，知道了各个部分大概是什么内容，以及它们之间的关系。接下来我们将会详细讨论 Raft 算法的每个部分。让我们先从第一部分选主开始。</p>
<h1 id="选主"><a href="#选主" class="headerlink" title="选主"></a>选主</h1><h2 id="什么是选主"><a href="#什么是选主" class="headerlink" title="什么是选主"></a>什么是选主</h2><p>选主（Leader election）就是在分布式系统内抉择出一个主节点来负责一些特定的工作。在执行了选主过程后，集群中每个节点都会识别出一个特定的、唯一的节点作为 leader。</p>
<p>我们开发的系统如果遇到选主的需求，通常会直接基于 zookeeper 或 etcd 来做，把这部分的复杂性收敛到第三方系统。然而作为 etcd 基础的 Raft 自身也存在“选主”的概念，这是两个层面的事情：基于 etcd 的选主指的是利用第三方 etcd 让集群对谁做主节点的决策达成一致，技术上来说利用的是 etcd 的一致性状态机、lease 以及 watch 机制，这个事情也可以改用单节点的 MySQL/Redis 来做，只是无法获得高可用性；而 Raft 本身的选主则指的是在 Raft 集群自身内部通过票选、心跳等机制来协调出一个大多数节点认可的主节点作为集群的 leader 去协调所有决策。</p>
<p>当你的系统利用 etcd 来写入谁是主节点的时候，这个决策也在 etcd 内部被它自己集群选出的主节点处理并同步给其它节点。</p>
<h2 id="Raft-为什么要进行选主？"><a href="#Raft-为什么要进行选主？" class="headerlink" title="Raft 为什么要进行选主？"></a>Raft 为什么要进行选主？</h2><p>按照论文所述，原生的 Paxos 算法使用了一种点对点（peer-to-peer）的方式，所有节点地位是平等的。在理想情况下，算法的目的是制定一个决策，这对于简化的模型比较有意义。但在工业界很少会有系统会使用这种方式，当有一系列的决策需要被制定的时候，先选出一个 leader 节点然后让它去协调所有的决策，这样算法会更加简单快速。</p>
<p>此外，和其它一致性算法相比，Raft 赋予了 leader 节点更强的领导力，称之为 Strong Leader。比如说日志条目只能从 leader 节点发送给其它节点而不能反着来，这种方式简化了日志复制的逻辑，使 Raft 变得更加简单易懂。</p>
<h2 id="Raft-选主过程"><a href="#Raft-选主过程" class="headerlink" title="Raft 选主过程"></a>Raft 选主过程</h2><h3 id="节点角色"><a href="#节点角色" class="headerlink" title="节点角色"></a>节点角色</h3><p>Raft 集群中每个节点都处于以下三种角色之一：</p>
<ul>
<li>Leader: 所有请求的处理者，接收客户端发起的操作请求，写入本地日志后同步至集群其它节点。</li>
<li>Follower: 请求的被动更新者，从 leader 接收更新请求，写入本地文件。如果客户端的操作请求发送给了 follower，会首先由 follower 重定向给 leader。</li>
<li>Candidate: 如果 follower 在一定时间内没有收到 leader 的心跳，则判断 leader 可能已经故障，此时启动 leader election 过程，本节点切换为 candidate 直到选主结束。</li>
</ul>
<h3 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h3><p>每开始一次新的选举，称为一个任期（term），每个 term 都有一个严格递增的整数与之关联。每当 candidate 触发 leader election 时都会增加 term，如果一个 candidate 赢得选举，他将在本 term 中担任 leader 的角色。但并不是每个 term 都一定对应一个 leader，有时候某个 term 内会由于选举超时导致选不出 leader，这时 candicate 会递增 term 号并开始新一轮选举。<br><img src="/img/f3e463285d0e4d6299fca19c7ef7e334_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>Term 更像是一个逻辑时钟（logic clock）的作用，有了它，就可以发现哪些节点的状态已经过期。每一个节点都保存一个 current term，在通信时带上这个 term 号。节点间通过 RPC 来通信，主要有两类 RPC 请求：</p>
<ul>
<li>RequestVote RPCs: 用于 candidate 拉票选举。</li>
<li>AppendEntries RPCs: 用于 leader 向其它节点复制日志以及同步心跳。</li>
</ul>
<h3 id="节点状态转换"><a href="#节点状态转换" class="headerlink" title="节点状态转换"></a>节点状态转换</h3><p>我们知道集群每个节点的状态都只能是 leader、follower 或 candidate，那么节点什么时候会处于哪种状态呢？下图展示了一个节点可能发生的状态转换：<br><img src="/img/d9f2d1f2d3674a50900eda504ecaa326_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>接下来我们详细讨论下每个转换所发生的场景。</p>
<h4 id="Follower-状态转换过程"><a href="#Follower-状态转换过程" class="headerlink" title="Follower 状态转换过程"></a>Follower 状态转换过程</h4><p>Raft 的选主基于一种心跳机制，集群中每个节点刚启动时都是 follower 身份（Step: starts up），leader 会周期性的向所有节点发送心跳包来维持自己的权威，那么首个 leader 是如何被选举出来的呢？方法是如果一个 follower 在一段时间内没有收到任何心跳，也就是选举超时，那么它就会主观认为系统中没有可用的 leader，并发起新的选举（Step: times out, starts election）。</p>
<p>这里有一个问题，即这个“选举超时时间”该如何制定？如果所有节点在同一时刻启动，经过同样的超时时间后同时发起选举，整个集群会变得低效不堪，极端情况下甚至会一直选不出一个主节点。Raft 巧妙的使用了一个随机化的定时器，让每个节点的“超时时间”在一定范围内随机生成，这样就大大的降低了多个节点同时发起选举的可能性。</p>
<p><img src="/img/fc2b320077124da39bade7adeaf7ef08_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：一个五节点 Raft 集群的初始状态，所有节点都是 follower 身份，term 为 1，且每个节点的选举超时定时器不同</p>
<p>若 follower 想发起一次选举，follower 需要先增加自己的当前 term，并将身份切换为 candidate。然后它会向集群其它节点发送“请给自己投票”的消息（RequestVote RPC）。</p>
<p><img src="/img/316b81a42ea843a192cc2f3578fbdb81_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：S1 率先超时，变为 candidate，term + 1，并向其它节点发出拉票请求</p>
<h4 id="Candicate-状态转换过程"><a href="#Candicate-状态转换过程" class="headerlink" title="Candicate 状态转换过程"></a>Candicate 状态转换过程</h4><p>Follower 切换为 candidate 并向集群其他节点发送“请给自己投票”的消息后，接下来会有三种可能的结果，也即上面节点状态图中 candidate 状态向外伸出的三条线。</p>
<p>选举成功（Step: receives votes from majority of servers）。当candicate从整个集群的大多数（N/2+1）节点获得了针对同一 term 的选票时，它就赢得了这次选举，立刻将自己的身份转变为 leader 并开始向其它节点发送心跳来维持自己的权威。<br><img src="/img/a851f56a384b4a0f9da76644d645ae1f_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：“大部分”节点都给了 S1 选票</p>
<p><img src="/img/a6e0e622b7384ac78f733e471b280c27_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：S1 变为 leader，开始发送心跳维持权威</p>
<p>每个节点针对每个 term 只能投出一张票，并且按照先到先得的原则。这个规则确保只有一个 candidate 会成为 leader。</p>
<p>选举失败（Step: discovers current leader or new term）。Candidate 在等待投票回复的时候，可能会突然收到其它自称是 leader 的节点发送的心跳包，如果这个心跳包里携带的 term 不小于 candidate 当前的 term，那么 candidate 会承认这个 leader，并将身份切回 follower。这说明其它节点已经成功赢得了选举，我们只需立刻跟随即可。但如果心跳包中的 term 比自己小，candidate 会拒绝这次请求并保持选举状态。</p>
<p><img src="/img/d4ce0c7fdf3b4039a0e4b0b200af731a_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：S4、S2 依次开始选举</p>
<p><img src="/img/2535cfeb9cfb44d4a0a04506f09f7485_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：S4 成为 leader，S2 在收到 S4 的心跳包后，由于 term 不小于自己当前的 term，因此会立刻切为 follower 跟随 S4</p>
<p>选举超时（Step: times out, new election）。第三种可能的结果是 candidate 既没有赢也没有输。如果有多个 follower 同时成为 candidate，选票是可能被瓜分的，如果没有任何一个 candidate 能得到大多数节点的支持，那么每一个 candidate 都会超时。此时 candidate 需要增加自己的 term，然后发起新一轮选举。如果这里不做一些特殊处理，选票可能会一直被瓜分，导致选不出 leader 来。这里的“特殊处理”指的就是前文所述的随机化选举超时时间。</p>
<p><img src="/img/04163db3b7ca4b4c8fbfdf4e7253a98f_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：S1 ~ S5 都在参与选举</p>
<p><img src="/img/517e2f7939394b3ca35936702a107f07_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：没有任何节点愿意给他人投票</p>
<p><img src="/img/b52e004bd4654cb1b51cdb409182156f_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：如果没有随机化超时时间，所有节点将会继续同时发起选举……</p>
<p>以上便是 candidate 三种可能的选举结果。</p>
<h4 id="Leader-状态转换过程"><a href="#Leader-状态转换过程" class="headerlink" title="Leader 状态转换过程"></a>Leader 状态转换过程</h4><p>节点状态图中的最后一条线是：discovers server with higher term。想象一个场景：当 leader 节点发生了宕机或网络断连，此时其它 follower 会收不到 leader 心跳，首个触发超时的节点会变为 candidate 并开始拉票（由于随机化各个 follower 超时时间不同），由于该 candidate 的 term 大于原 leader 的 term，因此所有 follower 都会投票给它，这名 candidate 会变为新的 leader。一段时间后原 leader 恢复了，收到了来自新leader 的心跳包，发现心跳中的 term 大于自己的 term，此时该节点会立刻切换为 follower 并跟随的新 leader。</p>
<p>上述流程的动画模拟如下：<br><img src="/img/33f858652afc4be6bb1d7b1f1dc33eaa_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：S4 作为 term2 的 leader</p>
<p><img src="/img/7d45e677f6c2428d9b9db7022416fe26_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：S4 宕机，S5 即将率先超时</p>
<p><img src="/img/1418b09699fe4614a594a565c55055d5_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：S5 当选 term3 的 leader</p>
<p><img src="/img/f0d9d314c75c4bd989dadf044ecd6307_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：S4 宕机恢复后收到了来自 S5 的 term3 心跳</p>
<p><img src="/img/31b9745a2fa94fb693a7ea1257aa5f7f_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图：S4 立刻变为 S5 的 follower</p>
<p>以上就是 Raft 的选主逻辑，但还有一些细节（譬如是否给该 candidate 投票还有一些其它条件）依赖算法的其它部分基础，我们会在后续“安全性”一章描述。</p>
<p>当票选出 leader 后，leader 也该承担起相应的责任了，这个责任是什么？就是下一章将介绍的“日志复制”。</p>
<h1 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h1><h2 id="什么是日志复制"><a href="#什么是日志复制" class="headerlink" title="什么是日志复制"></a>什么是日志复制</h2><p>在前文中我们讲过：共识算法通常基于状态复制机（Replicated State Machine）模型，所有节点从同一个 state 出发，经过一系列同样操作 log 的步骤，最终也必将达到一致的 state。也就是说，只要我们保证集群中所有节点的 log 一致，那么经过一系列应用（apply）后最终得到的状态机也就是一致的。</p>
<p>Raft 负责保证集群中所有节点 log 的一致性。</p>
<p>此外我们还提到过：Raft 赋予了 leader 节点更强的领导力（Strong Leader）。那么 Raft 保证 log 一致的方式就很容易理解了，即所有 log 都必须交给 leader 节点处理，并由 leader 节点复制给其它节点。这个过程，就叫做日志复制（Log replication）。</p>
<h2 id="Raft-日志复制机制解析"><a href="#Raft-日志复制机制解析" class="headerlink" title="Raft 日志复制机制解析"></a>Raft 日志复制机制解析</h2><h3 id="整体流程解析"><a href="#整体流程解析" class="headerlink" title="整体流程解析"></a>整体流程解析</h3><p>一旦 leader 被票选出来，它就承担起领导整个集群的责任了，开始接收客户端请求，并将操作包装成日志，并复制到其它节点上去。整体流程如下：</p>
<ul>
<li>Leader 为客户端提供服务，客户端的每个请求都包含一条即将被状态复制机执行的指令。</li>
<li>Leader 把该指令作为一条新的日志附加到自身的日志集合，然后向其它节点发起附加条目请求（AppendEntries RPC），来要求它们将这条日志附加到各自本地的日志集合。</li>
<li>当这条日志已经确保被安全的复制，即大多数（N/2+1）节点都已经复制后，leader 会将该日志 apply 到它本地的状态机中，然后把操作成功的结果返回给客户端。</li>
</ul>
<p>整个集群的日志模型可以宏观表示为下图（x ← 3 代表 x 赋值为 3）：<br><img src="/img/60d6b91f49ac4d11bee43f86f33566d6_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>每条日志除了存储状态机的操作指令外，还会拥有一个唯一的整数索引值（log index）来表明它在日志集合中的位置。此外，每条日志还会存储一个 term 号（日志条目方块最上方的数字，相同颜色 term 号相同），该 term 表示 leader 收到这条指令时的当前任期，term 相同的 log 是由同一个 leader 在其任期内发送的。</p>
<p>当一条日志被 leader 节点认为可以安全的 apply 到状态机时，称这条日志是 committed（上图中的 committed entries）。那么什么样的日志可以被 commit 呢？答案是：当 leader 得知这条日志被集群过半的节点复制成功时。因此在上图中我们可以看到 (term3, index7) 这条日志以及之前的日志都是 committed，尽管有两个节点拥有的日志并不完整。</p>
<p>Raft 保证所有 committed 日志都已经被持久化，且“最终”一定会被状态机apply。</p>
<p>注：这里的“最终”用词很微妙，它表明了一个特点：Raft 保证的只是集群内日志的一致性，而我们真正期望的集群对外的状态机一致性需要我们做一些额外工作，这一点在《线性一致性与读性能优化》一章会着重介绍。</p>
<h3 id="日志复制流程图解"><a href="#日志复制流程图解" class="headerlink" title="日志复制流程图解"></a>日志复制流程图解</h3><p>我们通过 Raft 动画 来模拟常规日志复制这一过程：<br><img src="/img/11bd5a3d291b43d2b31fea3a75fb3655_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>如上图，S1 当选 leader，此时还没有任何日志。我们模拟客户端向 S1 发起一个请求。</p>
<p><img src="/img/7a17a0e447534541a520ec97a9942cdd_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>S1 收到客户端请求后新增了一条日志 (term2, index1)，然后并行地向其它节点发起 AppendEntries RPC。</p>
<p><img src="/img/2b0c350086014a52a4989f02f5262153_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>S2、S4 率先收到了请求，各自附加了该日志，并向 S1 回应响应。</p>
<p><img src="/img/6f062cd961a24c5a951f2c025f065bd4_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>所有节点都附加了该日志，但由于 leader 尚未收到任何响应，因此暂时还不清楚该日志到底是否被成功复制。</p>
<p><img src="/img/97dbbaaf72cc4a2ba148cb252bce95ec_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>当 S1 收到2个节点的响应时，该日志条目的边框就已经变为实线，表示该日志已经安全的复制，因为在5节点集群中，2个 follower 节点加上 leader 节点自身，副本数已经确保过半，此时 S1 将响应客户端的请求。<br><img src="/img/a127762b466a48719967d52ab9f0636c_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>leader 后续会持续发送心跳包给 followers，心跳包中会携带当前已经安全复制（我们称之为 committed）的日志索引，此处为 (term2, index1)。<br><img src="/img/f7ebe584867b4c0b98b1e46f595a5007_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>所有 follower 都通过心跳包得知 (term2, index1) 的 log 已经成功复制 （committed），因此所有节点中该日志条目的边框均变为实线。</p>
<h3 id="对日志一致性的保证"><a href="#对日志一致性的保证" class="headerlink" title="对日志一致性的保证"></a>对日志一致性的保证</h3><p>前边我们使用了 (term2, index1) 这种方式来表示一条日志条目，这里为什么要带上 term，而不仅仅是使用 index？原因是 term 可以用来检查不同节点间日志是否存在不一致的情况，阅读下一节后会更容易理解这句话。</p>
<p>Raft 保证：如果不同的节点日志集合中的两个日志条目拥有相同的 term 和 index，那么它们一定存储了相同的指令。为什么可以作出这种保证？因为 Raft 要求 leader 在一个 term 内针对同一个 index 只能创建一条日志，并且永远不会修改它。同时 Raft 也保证：如果不同的节点日志集合中的两个日志条目拥有相同的 term 和 index，那么它们之前的所有日志条目也全部相同。这是因为 leader 发出的 AppendEntries RPC 中会额外携带上一条日志的 (term, index)，如果 follower 在本地找不到相同的 (term, index) 日志，则拒绝接收这次新的日志。所以，只要 follower 持续正常地接收来自 leader 的日志，那么就可以通过归纳法验证上述结论。</p>
<h3 id="可能出现的日志不一致场景"><a href="#可能出现的日志不一致场景" class="headerlink" title="可能出现的日志不一致场景"></a>可能出现的日志不一致场景</h3><p>在所有节点正常工作的时候，leader 和 follower的日志总是保持一致，AppendEntries RPC 也永远不会失败。然而我们总要面对任意节点随时可能宕机的风险，如何在这种情况下继续保持集群日志的一致性才是我们真正要解决的问题。</p>
<p><img src="/img/012758dde1ba4305b417d860236a2ecc_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>上图展示了一个 term8 的 leader 刚上任时，集群中日志可能存在的混乱情况。例如 follower 可能缺少一些日志（a ~ b），可能多了一些未提交的日志（c ~ d），也可能既缺少日志又多了一些未提交日志（e ~ f）。</p>
<p>注：Follower 不可能比 leader 多出一些已提交（committed）日志，这一点是通过选举上的限制来达成的，会在下一章《安全性》介绍。</p>
<p>我们先来尝试复现上述 a ~ f 场景，最后再讲 Raft 如何解决这种不一致问题。</p>
<ul>
<li>场景a~b. Follower 日志落后于 leader<ul>
<li>这种场景其实很简单，即 follower 宕机了一段时间，follower-a 从收到 (term6, index9) 后开始宕机，follower-b 从收到 (term4, index4) 后开始宕机。这里不再赘述。</li>
</ul>
</li>
<li>场景c. Follower 日志比 leader 多 term6<ul>
<li>当 term6 的 leader 正在将 (term6, index11) 向 follower 同步时，该 leader 发生了宕机，且此时只有 follower-c 收到了这条日志的 AppendEntries RPC。然后经过一系列的选举，term7 可能是选举超时，也可能是 leader 刚上任就宕机了，最终 term8 的 leader 上任了，成就了我们看到的场景 c。</li>
</ul>
</li>
<li>场景d. Follower 日志比 leader 多 term7<ul>
<li>当 term6 的 leader 将 (term6, index10) 成功 commit 后，发生了宕机。此时 term7 的 leader 走马上任，连续同步了两条日志给 follower，然而还没来得及 commit 就宕机了，随后集群选出了 term8 的 leader。</li>
</ul>
</li>
<li>场景e. Follower 日志比 leader 少 term5 ~ 6，多 term4<ul>
<li>当 term4 的 leader 将 (term4, index7) 同步给 follower，且将 (term4, index5) 及之前的日志成功 commit 后，发生了宕机，紧接着 follower-e 也发生了宕机。这样在 term5~7 内发生的日志同步全都被 follower-e 错过了。当 follower-e 恢复后，term8 的 leader 也刚好上任了。</li>
</ul>
</li>
<li>场景f. Follower 日志比 leader 少 term4 ~ 6，多 term2 ~ 3<ul>
<li>当 term2 的 leader 同步了一些日志（index4 ~ 6）给 follower 后，尚未来得及 commit 时发生了宕机，但它很快恢复过来了，又被选为了 term3 的 leader，它继续同步了一些日志（index7~11）给 follower，但同样未来得及 commit 就又发生了宕机，紧接着 follower-f 也发生了宕机，当 follower-f 醒来时，集群已经前进到 term8 了。</li>
</ul>
</li>
</ul>
<h3 id="如何处理日志不一致"><a href="#如何处理日志不一致" class="headerlink" title="如何处理日志不一致"></a>如何处理日志不一致</h3><p>通过上述场景我们可以看到，真实世界的集群情况很复杂，那么 Raft 是如何应对这么多不一致场景的呢？其实方式很简单暴力，想想 Strong Leader 这个词。</p>
<p>Raft 强制要求 follower 必须复制 leader 的日志集合来解决不一致问题。也就是说，follower 节点上任何与 leader 不一致的日志，都会被 leader 节点上的日志所覆盖。这并不会产生什么问题，因为某些选举上的限制，如果 follower 上的日志与 leader 不一致，那么该日志在 follower 上一定是未提交的。未提交的日志并不会应用到状态机，也不会被外部的客户端感知到。</p>
<p>要使得 follower 的日志集合跟自己保持完全一致，leader 必须先找到二者间最后一次达成一致的地方。因为一旦这条日志达成一致，在这之前的日志一定也都一致（回忆下前文）。这个确认操作是在 AppendEntries RPC 的一致性检查步骤完成的。</p>
<p>Leader 针对每个 follower 都维护一个 next index，表示下一条需要发送给该follower 的日志索引。当一个 leader 刚刚上任时，它初始化所有 next index 值为自己最后一条日志的 index+1。但凡某个 follower 的日志跟 leader 不一致，那么下次 AppendEntries RPC 的一致性检查就会失败。在被 follower 拒绝这次 Append Entries RPC 后，leader 会减少 next index 的值并进行重试。</p>
<p>最终一定会存在一个 next index 使得 leader 和 follower 在这之前的日志都保持一致。极端情况下 next index 为1，表示 follower 没有任何日志与 leader 一致，leader 必须从第一条日志开始同步。</p>
<p>针对每个 follower，一旦确定了 next index 的值，leader 便开始从该 index 同步日志，follower 会删除掉现存的不一致的日志，保留 leader 最新同步过来的。</p>
<p>整个集群的日志会在这个简单的机制下自动趋于一致。此外要注意，leader 从来不会覆盖或者删除自己的日志，而是强制 follower 与它保持一致。这就要求集群票选出的 leader 一定要具备“日志的正确性”，这也就关联到了前文提到的：选举上的限制。下一章我们将对此详细讨论。</p>
<h1 id="安全性及正确性"><a href="#安全性及正确性" class="headerlink" title="安全性及正确性"></a>安全性及正确性</h1><p>前面的章节我们讲述了 Raft 算法是如何选主和复制日志的，然而到目前为止我们描述的这套机制还不能保证每个节点的状态机会严格按照相同的顺序 apply 日志。想象以下场景：</p>
<ul>
<li>Leader 将一些日志复制到了大多数节点上，进行 commit 后发生了宕机。</li>
<li>某个 follower 并没有被复制到这些日志，但它参与选举并当选了下一任 leader。</li>
<li>新的 leader 又同步并 commit 了一些日志，这些日志覆盖掉了其它节点上的上一任 committed 日志。</li>
<li>各个节点的状态机可能 apply 了不同的日志序列，出现了不一致的情况。</li>
</ul>
<p>因此我们需要对“选主+日志复制”这套机制加上一些额外的限制，来保证状态机的安全性，也就是 Raft 算法的正确性。</p>
<h2 id="对选举的限制"><a href="#对选举的限制" class="headerlink" title="对选举的限制"></a>对选举的限制</h2><p>我们再来分析下前文所述的 committed 日志被覆盖的场景，根本问题其实发生在第2步。Candidate 必须有足够的资格才能当选集群 leader，否则它就会给集群带来不可预料的错误。Candidate 是否具备这个资格可以在选举时添加一个小小的条件来判断，即：</p>
<p>每个 candidate 必须在 RequestVote RPC 中携带自己本地日志的最新 (term, index)，如果 follower 发现这个 candidate 的日志还没有自己的新，则拒绝投票给该 candidate。</p>
<p>Candidate 想要赢得选举成为 leader，必须得到集群大多数节点的投票，那么它的日志就一定至少不落后于大多数节点。又因为一条日志只有复制到了大多数节点才能被 commit，因此能赢得选举的 candidate 一定拥有所有 committed 日志。因此前一篇文章我们才会断定地说：Follower 不可能比 leader 多出一些 committed 日志。比较两个 (term, index) 的逻辑非常简单：如果 term 不同 term 更大的日志更新，否则 index 大的日志更新。</p>
<h2 id="对提交的限制"><a href="#对提交的限制" class="headerlink" title="对提交的限制"></a>对提交的限制</h2><p>除了对选举增加一点限制外，我们还需对 commit 行为增加一点限制，来完成我们 Raft 算法核心部分的最后一块拼图。</p>
<p>回忆下什么是 commit：当 leader 得知某条日志被集群过半的节点复制成功时，就可以进行 commit，committed 日志一定最终会被状态机 apply。所谓 commit 其实就是对日志简单进行一个标记，表明其可以被 apply 到状态机，并针对相应的客户端请求进行响应。然而 leader 并不能在任何时候都随意 commit 旧任期留下的日志，即使它已经被复制到了大多数节点。Raft 论文给出了一个经典场景：<br><img src="/img/b1b4e211fca44ca9bf5a67639e92d4d4_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>上图从左到右按时间顺序模拟了问题场景。</p>
<ul>
<li>阶段a：S1 是 leader，收到请求后将 (term2, index2) 只复制给了 S2，尚未复制给 S3 ~ S5。</li>
<li>阶段b：S1 宕机，S5 当选 term3 的 leader（S3、S4、S5 三票），收到请求后保存了 (term3, index2)，尚未复制给任何节点。</li>
<li>阶段c：S5 宕机，S1 恢复，S1 重新当选 term4 的 leader，继续将 (term2, index2) 复制给了 S3，已经满足大多数节点，我们将其 commit。</li>
<li>阶段d：S1 又宕机，S5 恢复，S5 重新当选 leader（S2、S3、S4 三票），将 (term3, inde2) 复制给了所有节点并 commit。注意，此时发生了致命错误，已经 committed 的 (term2, index2) 被 (term3, index2) 覆盖了。</li>
</ul>
<p>为了避免这种错误，我们需要添加一个额外的限制：Leader 只允许 commit 包含当前 term 的日志。</p>
<p>针对上述场景，问题发生在阶段c，即使作为 term4 leader 的 S1 将 (term2, index2) 复制给了大多数节点，它也不能直接将其 commit，而是必须等待 term4 的日志到来并成功复制后，一并进行 commit。</p>
<ul>
<li>阶段e：在添加了这个限制后，要么 (term2, index2) 始终没有被 commit，这样 S5 在阶段d将其覆盖就是安全的；要么 (term2, index2) 同 (term4, index3) 一起被 commit，这样 S5 根本就无法当选 leader，因为大多数节点的日志都比它新，也就不存在前边的问题了。</li>
</ul>
<p>以上便是对算法增加的两个小限制，它们对确保状态机的安全性起到了至关重要的作用。</p>
<p>至此我们对 Raft 算法的核心部分，已经介绍完毕。下一章我们会介绍两个同样描述于论文内的辅助技术：集群成员变更和日志压缩，它们都是在 Raft 工程实践中必不可少的部分。</p>
<h1 id="集群成员变更与日志压缩"><a href="#集群成员变更与日志压缩" class="headerlink" title="集群成员变更与日志压缩"></a>集群成员变更与日志压缩</h1><p>尽管我们已经通过前几章了解了 Raft 算法的核心部分，但相较于算法理论来说，在工程实践中仍有一些现实问题需要我们去面对。Raft 非常贴心的在论文中给出了两个常见问题的解决方案，它们分别是：</p>
<ul>
<li>集群成员变更：如何安全地改变集群的节点成员。</li>
<li>日志压缩：如何解决日志集合无限制增长带来的问题。</li>
</ul>
<p>本文我们将分别讲解这两种技术。</p>
<h2 id="集群成员变更"><a href="#集群成员变更" class="headerlink" title="集群成员变更"></a>集群成员变更</h2><p>在前文的理论描述中我们都假设了集群成员是不变的，然而在实践中有时会需要替换宕机机器或者改变复制级别（即增减节点）。一种最简单暴力达成目的的方式就是：停止集群、改变成员、启动集群。这种方式在执行时会导致集群整体不可用，此外还存在手工操作带来的风险。</p>
<p>为了避免这样的问题，Raft 论文中给出了一种无需停机的、自动化的改变集群成员的方式，其实本质上还是利用了 Raft 的核心算法，将集群成员配置作为一个特殊日志从 leader 节点同步到其它节点去。</p>
<h3 id="直接切换集群成员配置"><a href="#直接切换集群成员配置" class="headerlink" title="直接切换集群成员配置"></a>直接切换集群成员配置</h3><p>先说结论：所有将集群从旧配置直接完全切换到新配置的方案都是不安全的。</p>
<p>因此我们不能想当然的将新配置直接作为日志同步给集群并 apply。因为我们不可能让集群中的全部节点在“同一时刻”原子地切换其集群成员配置，所以在切换期间不同的节点看到的集群视图可能存在不同，最终可能导致集群存在多个 leader。为了理解上述结论，我们来看一个实际出现问题的场景，下图对其进行了展现。<br><img src="/img/00cd4fb677dc4a8987c015b6f074a3b8_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<ul>
<li>阶段a. 集群存在 S1 ~ S3 三个节点，我们将该成员配置表示为 C-old，绿色表示该节点当前视图（成员配置）为 C-old，其中红边的 S3 为 leader。</li>
<li>阶段b. 集群新增了 S4、S5 两个节点，该变更从 leader 写入，我们将 S1 ~ S5 的五节点新成员配置表示为 C-new，蓝色表示该节点当前视图为 C-new。</li>
<li>阶段c. 假设 S3 短暂宕机触发了 S1 与 S5 的超时选主。</li>
<li>阶段d. S1 向 S2、S3 拉票，S5 向其它全部四个节点拉票。由于 S2 的日志并没有比 S1 更新，因此 S2 可能会将选票投给 S1，S1 两票当选（因为 S1 认为集群只有三个节点）。而 S5 肯定会得到 S3、S4 的选票，因为 S1 感知不到 S4，没有向它发送 RequestVote RPC，并且 S1 的日志落后于 S3，S3 也一定不会投给 S1，结果 S5 三票当选。最终集群出现了多个主节点的致命错误，也就是所谓的脑裂。</li>
</ul>
<p><img src="/img/1c063b8c7e824bb88ffe572439c90975_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>上图来自论文，用不同的形式展现了和图5-1相同的问题。颜色代表的含义与图5-1是一致的，在 problem: two disjoint majorities 所指的时间点，集群可能会出现两个 leader。但是，多主问题并不是在任何新老节点同时选举时都一定可能出现的</p>
<p><img src="/img/85436861e4484446afac9192d02bc292_tplv-k3u1fbpfcp-watermark.awebp" alt=""><br>图5-3</p>
<p>该假想场景类似图5-1的阶段d，模拟过程如下：</p>
<ul>
<li>S1 为集群原 leader，集群新增 S4、S5，该配置被推给了 S3，S2 尚未收到。</li>
<li>此时 S1 发生短暂宕机，S2、S3 分别触发选主。</li>
<li>最终 S2 获得了 S1 和自己的选票，S3 获得了 S4、S5 和自己的选票，集群出现两个 leader。</li>
</ul>
<p>图5-3过程看起来好像和图5-1没有什么大的不同，只是参与选主的节点存在区别，然而事实是图5-3的情况是不可能出现的。</p>
<p>注意：Raft 论文中传递集群变更信息也是通过日志追加实现的，所以也受到选主的限制。很多读者对选主限制中比较的日志是否必须是 committed 产生疑惑，回看下在《安全性》一文中的描述：</p>
<p>每个 candidate 必须在 RequestVote RPC 中携带自己本地日志的最新 (term, index)，如果 follower 发现这个 candidate 的日志还没有自己的新，则拒绝投票给该 candidate。</p>
<p>这里再帮大家明确下，论文里确实间接表明了，选主时比较的日志是不要求 committed 的，只需比较本地的最新日志就行！</p>
<p>回到图5-3，不可能出现的原因在于，S1 作为原 leader 已经第一个保存了新配置的日志，而 S2 尚未被同步这条日志，根据上一章《安全性》我们讲到的选主限制，S1 不可能将选票投给 S2，因此 S2 不可能成为 leader。</p>
<h3 id="两阶段切换集群成员配置"><a href="#两阶段切换集群成员配置" class="headerlink" title="两阶段切换集群成员配置"></a>两阶段切换集群成员配置</h3><p>Raft 使用一种两阶段方法平滑切换集群成员配置来避免遇到前一节描述的问题，具体流程如下：</p>
<ul>
<li>阶段一<ul>
<li>客户端将 C-new 发送给 leader，leader 将 C-old 与 C-new 取并集并立即apply，我们表示为 C-old,new。</li>
<li>Leader 将 C-old,new 包装为日志同步给其它节点。</li>
<li>Follower 收到 C-old,new 后立即 apply，当 <strong>C-old,new 的大多数节点（即 C-old 的大多数节点和 C-new 的大多数节点）</strong>都切换后，leader 将该日志 commit。</li>
</ul>
</li>
<li>阶段二<ul>
<li>Leader 接着将 C-new 包装为日志同步给其它节点。</li>
<li>Follower 收到 C-new 后立即 apply，如果此时发现自己不在 C-new 列表，则主动退出集群。</li>
<li>Leader 确认 C-new 的大多数节点都切换成功后，给客户端发送执行成功的响应。</li>
</ul>
</li>
</ul>
<p><img src="/img/3af62adcab904fbc8d606b1ad29d9a34_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>上图展示了该流程的时间线。虚线表示已经创建但尚未 commit 的成员配置日志，实线表示 committed 的成员配置日志。</p>
<p>为什么该方案可以保证不会出现多个 leader？我们来按流程逐阶段分析。</p>
<ul>
<li>阶段1. C-old,new 尚未 commit<ul>
<li>该阶段所有节点的配置要么是 C-old，要么是 C-old,new，但无论是二者哪种，只要原 leader 发生宕机，新 leader 都必须得到大多数 C-old 集合内节点的投票。</li>
<li>以图5-1场景为例，S5 在阶段d根本没有机会成为 leader，因为 C-old 中只有 S3 给它投票了，不满足大多数。</li>
</ul>
</li>
<li>阶段2. C-old,new 已经 commit，C-new 尚未下发<ul>
<li>该阶段 C-old,new 已经 commit，可以确保已经被 C-old,new 的大多数节点（再次强调：C-old 的大多数节点和 C-new 的大多数节点）复制。</li>
<li>因此当 leader 宕机时，新选出的 leader 一定是已经拥有 C-old,new 的节点，不可能出现两个 leader。</li>
</ul>
</li>
<li>阶段3. C-new 已经下发但尚未 commit<ul>
<li>该阶段集群中可能有三种节点 C-old、C-old,new、C-new，但由于已经经历了阶段2，因此 C-old 节点不可能再成为 leader。而无论是 C-old,new 还是 C-new 节点发起选举，都需要经过大多数 C-new 节点的同意，因此也不可能出现两个 leader。</li>
</ul>
</li>
<li>阶段4. C-new 已经 commit<ul>
<li>该阶段 C-new 已经被 commit，因此只有 C-new 节点可以得到大多数选票成为 leader。此时集群已经安全地完成了这轮变更，可以继续开启下一轮变更了。</li>
</ul>
</li>
</ul>
<p>以上便是对该两阶段方法可行性的分步验证，Raft 论文将该方法称之为共同一致（Joint Consensus）。关于集群成员变更另一篇更详细的论文还给出了其它方法，简单来说就是论证一次只变更一个节点的的正确性，并给出解决可用性问题的优化方案。感兴趣的同学可以参考：《Consensus: Bridging Theory and Practice》。</p>
<h2 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h2><p>我们知道 Raft 核心算法维护了日志的一致性，通过 apply 日志我们也就得到了一致的状态机，客户端的操作命令会被包装成日志交给 Raft 处理。然而在实际系统中，客户端操作是连绵不断的，但日志却不能无限增长，首先它会占用很高的存储空间，其次每次系统重启时都需要完整回放一遍所有日志才能得到最新的状态机。</p>
<p>因此 Raft 提供了一种机制去清除日志里积累的陈旧信息，叫做日志压缩。</p>
<p>快照（Snapshot）是一种常用的、简单的日志压缩方式，ZooKeeper、Chubby 等系统都在用。简单来说，就是将某一时刻系统的状态 dump 下来并落地存储，这样该时刻之前的所有日志就都可以丢弃了。所以大家对“压缩”一词不要产生错误理解，我们并没有办法将状态机快照“解压缩”回日志序列。<br>注意，在 Raft 中我们只能为 committed 日志做 snapshot，因为只有 committed 日志才是确保最终会应用到状态机的。</p>
<p><img src="/img/00ef776fc5b64e56bd2abbfae3371329_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>上图展示了一个节点用快照替换了 (term1, index1) ~ (term3, index5) 的日志。快照一般包含以下内容：</p>
<ul>
<li>日志的元数据：最后一条被该快照 apply 的日志 term 及 index</li>
<li>状态机：前边全部日志 apply 后最终得到的状态机</li>
</ul>
<p>当 leader 需要给某个 follower 同步一些旧日志，但这些日志已经被 leader 做了快照并删除掉了时，leader 就需要把该快照发送给 follower。</p>
<p>同样，当集群中有新节点加入，或者某个节点宕机太久落后了太多日志时，leader 也可以直接发送快照，大量节约日志传输和回放时间。</p>
<p>同步快照使用一个新的 RPC 方法，叫做 InstallSnapshot RPC。</p>
<h1 id="线性一致性与读性能优化"><a href="#线性一致性与读性能优化" class="headerlink" title="线性一致性与读性能优化"></a>线性一致性与读性能优化</h1><h2 id="什么是线性一致性？"><a href="#什么是线性一致性？" class="headerlink" title="什么是线性一致性？"></a>什么是线性一致性？</h2><p>在该系列首篇《基本概念》中我们提到过：在分布式系统中，为了消除单点提高系统可用性，通常会使用副本来进行容错，但这会带来另一个问题，即如何保证多个副本之间的一致性。</p>
<p>什么是一致性？所谓一致性有很多种模型，不同的模型都是用来评判一个并发系统正确与否的不同程度的标准。而我们今天要讨论的是强一致性（Strong Consistency）模型，也就是线性一致性（Linearizability），我们经常听到的 CAP 理论中的 C 指的就是它。</p>
<p>其实我们在第一篇就已经简要描述过何为线性一致性：</p>
<blockquote>
<p>所谓的强一致性（线性一致性）并不是指集群中所有节点在任一时刻的状态必须完全一致，而是指一个目标，即让一个分布式系统看起来只有一个数据副本，并且读写操作都是原子的，这样应用层就可以忽略系统底层多个数据副本间的同步问题。也就是说，我们可以将一个强一致性分布式系统当成一个整体，一旦某个客户端成功的执行了写操作，那么所有客户端都一定能读出刚刚写入的值。即使发生网络分区故障，或者少部分节点发生异常，整个集群依然能够像单机一样提供服务。</p>
</blockquote>
<p>“像单机一样提供服务”从感官上描述了一个线性一致性系统应该具备的特性，那么我们该如何判断一个系统是否具备线性一致性呢？通俗来说就是不能读到旧（stale）数据，但具体分为两种情况：</p>
<ul>
<li>对于调用时间存在重叠（并发）的请求，生效顺序可以任意确定。</li>
<li>对于调用时间存在先后关系（偏序）的请求，后一个请求不能违背前一个请求确定的结果。</li>
</ul>
<p>只要根据上述两条规则即可判断一个系统是否具备线性一致性。下面我们来看一个非线性一致性系统的例子。</p>
<p><img src="/img/286a2248256b4b9f84ff613318432103_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>如上图所示，裁判将世界杯的比赛结果写入了主库，Alice 和 Bob 所浏览的页面分别从两个不同的从库读取，但由于存在主从同步延迟，Follower 2 的本次同步延迟高于 Follower 1，最终导致 Bob 听到了 Alice 的惊呼后刷新页面看到的仍然是比赛进行中。</p>
<p>虽然线性一致性的基本思想很简单，只是要求分布式系统看起来只有一个数据副本，但在实际中还是有很多需要关注的点，我们继续看几个例子。</p>
<p><img src="/img/d22cb375fc664ac2a5585417a50028de_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>上图从客户端的外部视角展示了多个用户同时请求读写一个系统的场景，每条柱形都是用户发起的一个请求，左端是请求发起的时刻，右端是收到响应的时刻。由于网络延迟和系统处理时间并不固定，所以柱形长度并不相同。</p>
<ul>
<li>x 最初的值为 0，Client C 在某个时间段将 x 写为 1。</li>
<li>Client A 第一个读操作位于 Client C 的写操作之前，因此必须读到原始值 0。</li>
<li>Client A 最后一个读操作位于 Client C 的写操作之后，如果系统是线性一致的，那么必须读到新值 1。</li>
<li>其它与写操作重叠的所有读操作，既可能返回 0，也可能返回 1，因为我们并不清楚写操作在哪个时间段内哪个精确的点生效，这种情况下读写是并发的。</li>
</ul>
<p>仅仅是这样的话，仍然不能说这个系统满足线性一致。假设 Client B 的第一次读取返回了 1，如果 Client A 的第二次读取返回了 0，那么这种场景并不破坏上述规则，但这个系统仍不满足线性一致，因为客户端在写操作执行期间看到 x 的值在新旧之间来回翻转，这并不符合我们期望的“看起来只有一个数据副本”的要求。所以我们需要额外添加一个约束，如下图所示。</p>
<p><img src="/img/0d9c3635c4d245188997538e36cb972d_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>在任何一个客户端的读取返回新值后，所有客户端的后续读取也必须返回新值，这样系统便满足线性一致了。</p>
<p>我们最后来看一个更复杂的例子，继续细化这个时序图。</p>
<p><img src="/img/5d2ab2d829fe4fa086298245edc24dea_tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<p>如上图所示，每个读写操作在某个特定的时间点都是原子性的生效，我们在柱形中用竖线标记出生效的时间点，将这些标记按时间顺序连接起来。那么线性一致的要求就是：连线总是按照时间顺序向右移动，而不会向左回退。所以这个连线结果必定是一个有效的寄存器读写序列：任何客户端的每次读取都必须返回该条目最近一次写入的值。</p>
<p>线性一致性并非限定在分布式环境下，在单机单核系统中可以简单理解为“寄存器”的特性。</p>
<p>Client B 的最后一次读操作并不满足线性一致，因为在连线向右移动的前提下，它读到的值是错误的（因为Client A 已经读到了由 Client C 写入的 4）。此外这张图里还有一些值得指出的细节点，可以解开很多我们在使用线性一致系统时容易产生的误解：</p>
<ul>
<li>Client B 的首个读请求在 Client D 的首个写请求和 Client A 的首个写请求之前发起，但最终读到的却是最后由 Client A 写成功之后的结果。</li>
<li>Client A 尚未收到首个写请求成功的响应时，Client B 就读到了 Client A 写入的值。</li>
</ul>
<p>上述现象在线性一致的语义下都是合理的。</p>
<p>所以线性一致性（Linearizability）除了叫强一致性（Strong Consistency）外，还叫做原子一致性（Atomic Consistency）、立即一致性（Immediate Consistency）或外部一致性（External Consistency），这些名字看起来都是比较贴切的。</p>
<h2 id="Raft-线性一致性读"><a href="#Raft-线性一致性读" class="headerlink" title="Raft 线性一致性读"></a>Raft 线性一致性读</h2><p>在了解了什么是线性一致性之后，我们将其与 Raft 结合来探讨。首先需要明确一个问题，使用了 Raft 的系统都是线性一致的吗？不是的，Raft 只是提供了一个基础，要实现整个系统的线性一致还需要做一些额外的工作。</p>
<p>假设我们期望基于 Raft 实现一个线性一致的分布式 kv 系统，让我们从最朴素的方案开始，指出每种方案存在的问题，最终使整个系统满足线性一致性。</p>
<h3 id="写主读从缺陷分析"><a href="#写主读从缺陷分析" class="headerlink" title="写主读从缺陷分析"></a>写主读从缺陷分析</h3><p>写操作并不是我们关注的重点，如果你稍微看了一些理论部分就应该知道，所有写操作都要作为提案从 leader 节点发起，当然所有的写命令都应该简单交给 leader 处理。真正关键的点在于读操作的处理方式，这涉及到整个系统关于一致性方面的取舍。</p>
<p>在该方案中我们假设读操作直接简单地向 follower 发起，那么由于 Raft 的 Quorum 机制（大部分节点成功即可），针对某个提案在某一时间段内，集群可能会有以下两种状态：</p>
<ul>
<li>某次写操作的日志尚未被复制到一少部分 follower，但 leader 已经将其 commit。</li>
<li>某次写操作的日志已经被同步到所有 follower，但 leader 将其 commit 后，心跳包尚未通知到一部分 follower。</li>
</ul>
<p>以上每个场景客户端都可能读到过时的数据，整个系统显然是不满足线性一致的。</p>
<h3 id="写主读主缺陷分析"><a href="#写主读主缺陷分析" class="headerlink" title="写主读主缺陷分析"></a>写主读主缺陷分析</h3><p>在该方案中我们限定，所有的读操作也必须经由 leader 节点处理，读写都经过 leader 难道还不能满足线性一致？是的！！ 并且该方案存在不止一个问题！！</p>
<h4 id="问题一：状态机落后于-committed-log-导致脏读"><a href="#问题一：状态机落后于-committed-log-导致脏读" class="headerlink" title="问题一：状态机落后于 committed log 导致脏读"></a>问题一：状态机落后于 committed log 导致脏读</h4><p>回想一下前文讲过的，我们在解释什么是 commit 时提到了写操作什么时候可以响应客户端：</p>
<p>所谓 commit 其实就是对日志简单进行一个标记，表明其可以被 apply 到状态机，并针对相应的客户端请求进行响应。</p>
<p>也就是说一个提案只要被 leader commit 就可以响应客户端了，Raft 并没有限定提案结果在返回给客户端前必须先应用到状态机。所以从客户端视角当我们的某个写操作执行成功后，下一次读操作可能还是会读到旧值。</p>
<p>这个问题的解决方式很简单，在 leader 收到读命令时我们只需记录下当前的 commit index，当 apply index 追上该 commit index 时，即可将状态机中的内容响应给客户端。</p>
<h4 id="问题二：网络分区导致脏读"><a href="#问题二：网络分区导致脏读" class="headerlink" title="问题二：网络分区导致脏读"></a>问题二：网络分区导致脏读</h4><p>假设集群发生网络分区，旧 leader 位于少数派分区中，而且此刻旧 leader 刚好还未发现自己已经失去了领导权，当多数派分区选出了新的 leader 并开始进行后续写操作时，连接到旧 leader 的客户端可能就会读到旧值了。</p>
<p>因此，仅仅是直接读 leader 状态机的话，系统仍然不满足线性一致性。</p>
<h3 id="Raft-Log-Read"><a href="#Raft-Log-Read" class="headerlink" title="Raft Log Read"></a>Raft Log Read</h3><p>为了确保 leader 处理读操作时仍拥有领导权，我们可以将读请求同样作为一个提案走一遍 Raft 流程，当这次读请求对应的日志可以被应用到状态机时，leader 就可以读状态机并返回给用户了。这种读方案称为 Raft Log Read，也可以直观叫做 Read as Proposal。</p>
<p>为什么这种方案满足线性一致？因为该方案根据 commit index 对所有读写请求都一起做了线性化，这样每个读请求都能感知到状态机在执行完前一写请求后的最新状态，将读写日志一条一条的应用到状态机，整个系统当然满足线性一致。但该方案的缺点也非常明显，那就是性能差，读操作的开销与写操作几乎完全一致。而且由于所有操作都线性化了，我们无法并发读状态机。</p>
<h2 id="Raft-读性能优化"><a href="#Raft-读性能优化" class="headerlink" title="Raft 读性能优化"></a>Raft 读性能优化</h2><p>接下来我们将介绍几种优化方案，它们在不违背系统线性一致性的前提下，大幅提升了读性能。</p>
<h3 id="Read-Index"><a href="#Read-Index" class="headerlink" title="Read Index"></a>Read Index</h3><p>与 Raft Log Read 相比，Read Index 省掉了同步 log 的开销，能够大幅提升读的吞吐，一定程度上降低读的时延。其大致流程为：</p>
<ul>
<li>Leader 在收到客户端读请求时，记录下当前的 commit index，称之为 read index。</li>
<li>Leader 向 followers 发起一次心跳包，这一步是为了确保领导权，避免网络分区时少数派 leader 仍处理请求。</li>
<li>等待状态机至少应用到 read index（即 apply index 大于等于 read index）。</li>
<li>执行读请求，将状态机中的结果返回给客户端。</li>
</ul>
<p>这里第三步的 apply index 大于等于 read index 是一个关键点。因为在该读请求发起时，我们将当时的 commit index 记录了下来，只要使客户端读到的内容在该 commit index 之后，那么结果一定都满足线性一致（如不理解可以再次回顾下前文线性一致性的例子以及2.2中的问题一）。</p>
<h3 id="Lease-Read"><a href="#Lease-Read" class="headerlink" title="Lease Read"></a>Lease Read</h3><p>与 Read Index 相比，Lease Read 进一步省去了网络交互开销，因此更能显著降低读的时延。基本思路是 leader 设置一个比选举超时（Election Timeout）更短的时间作为租期，在租期内我们可以相信其它节点一定没有发起选举，集群也就一定不会存在脑裂，所以在这个时间段内我们直接读主即可，而非该时间段内可以继续走 Read Index 流程，Read Index 的心跳包也可以为租期带来更新。</p>
<p>Lease Read 可以认为是 Read Index 的时间戳版本，额外依赖时间戳会为算法带来一些不确定性，如果时钟发生漂移会引发一系列问题，因此需要谨慎的进行配置。</p>
<h3 id="Follower-Read"><a href="#Follower-Read" class="headerlink" title="Follower Read"></a>Follower Read</h3><p>在前边两种优化方案中，无论我们怎么折腾，核心思想其实只有两点：</p>
<ul>
<li>保证在读取时的最新 commit index 已经被 apply。</li>
<li>保证在读取时 leader 仍拥有领导权。</li>
</ul>
<p>这两个保证分别对应2.2节所描述的两个问题。</p>
<p>其实无论是 Read Index 还是 Lease Read，最终目的都是为了解决第二个问题。换句话说，读请求最终一定都是由 leader 来承载的。</p>
<p>那么读 follower 真的就不能满足线性一致吗？其实不然，这里我们给出一个可行的读 follower 方案：Follower 在收到客户端的读请求时，向 leader 询问当前最新的 commit index，反正所有日志条目最终一定会被同步到自己身上，follower 只需等待该日志被自己 commit 并 apply 到状态机后，返回给客户端本地状态机的结果即可。这个方案叫做 Follower Read。</p>
<p>注意：Follower Read 并不意味着我们在读过程中完全不依赖 leader 了，在保证线性一致性的前提下完全不依赖 leader 理论上是不可能做到的。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" rel="tag"># 分布式系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/16/6.828-lab/" rel="prev" title="6.828 lab">
      <i class="fa fa-chevron-left"></i> 6.828 lab
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/12/06/%E6%9C%89%E8%B6%A3%E7%9A%84cache%E6%B5%8B%E9%87%8F%E6%95%B0%E6%8D%AE/" rel="next" title="有趣的cache测量数据">
      有趣的cache测量数据 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Raft-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">Raft 是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%81%E5%9C%A8%E4%BD%BF%E7%94%A8-Raft"><span class="nav-number">1.2.</span> <span class="nav-text">谁在使用 Raft</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Raft-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.3.</span> <span class="nav-text">Raft 基本概念</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%89%E4%B8%BB"><span class="nav-number">2.</span> <span class="nav-text">选主</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%89%E4%B8%BB"><span class="nav-number">2.1.</span> <span class="nav-text">什么是选主</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Raft-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E9%80%89%E4%B8%BB%EF%BC%9F"><span class="nav-number">2.2.</span> <span class="nav-text">Raft 为什么要进行选主？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Raft-%E9%80%89%E4%B8%BB%E8%BF%87%E7%A8%8B"><span class="nav-number">2.3.</span> <span class="nav-text">Raft 选主过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E8%A7%92%E8%89%B2"><span class="nav-number">2.3.1.</span> <span class="nav-text">节点角色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E6%9C%9F"><span class="nav-number">2.3.2.</span> <span class="nav-text">任期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.3.3.</span> <span class="nav-text">节点状态转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Follower-%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">Follower 状态转换过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Candicate-%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">Candicate 状态转换过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leader-%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">Leader 状态转换过程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text">日志复制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6"><span class="nav-number">3.1.</span> <span class="nav-text">什么是日志复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Raft-%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90"><span class="nav-number">3.2.</span> <span class="nav-text">Raft 日志复制机制解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90"><span class="nav-number">3.2.1.</span> <span class="nav-text">整体流程解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%A7%A3"><span class="nav-number">3.2.2.</span> <span class="nav-text">日志复制流程图解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%97%A5%E5%BF%97%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E4%BF%9D%E8%AF%81"><span class="nav-number">3.2.3.</span> <span class="nav-text">对日志一致性的保证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%97%A5%E5%BF%97%E4%B8%8D%E4%B8%80%E8%87%B4%E5%9C%BA%E6%99%AF"><span class="nav-number">3.2.4.</span> <span class="nav-text">可能出现的日志不一致场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%97%A5%E5%BF%97%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="nav-number">3.2.5.</span> <span class="nav-text">如何处理日志不一致</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E5%8F%8A%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text">安全性及正确性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E9%80%89%E4%B8%BE%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-number">4.1.</span> <span class="nav-text">对选举的限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E6%8F%90%E4%BA%A4%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-number">4.2.</span> <span class="nav-text">对提交的限制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E6%88%90%E5%91%98%E5%8F%98%E6%9B%B4%E4%B8%8E%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9"><span class="nav-number">5.</span> <span class="nav-text">集群成员变更与日志压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E6%88%90%E5%91%98%E5%8F%98%E6%9B%B4"><span class="nav-number">5.1.</span> <span class="nav-text">集群成员变更</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%88%87%E6%8D%A2%E9%9B%86%E7%BE%A4%E6%88%90%E5%91%98%E9%85%8D%E7%BD%AE"><span class="nav-number">5.1.1.</span> <span class="nav-text">直接切换集群成员配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%88%87%E6%8D%A2%E9%9B%86%E7%BE%A4%E6%88%90%E5%91%98%E9%85%8D%E7%BD%AE"><span class="nav-number">5.1.2.</span> <span class="nav-text">两阶段切换集群成员配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9"><span class="nav-number">5.2.</span> <span class="nav-text">日志压缩</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E8%AF%BB%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">6.</span> <span class="nav-text">线性一致性与读性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="nav-number">6.1.</span> <span class="nav-text">什么是线性一致性？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Raft-%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7%E8%AF%BB"><span class="nav-number">6.2.</span> <span class="nav-text">Raft 线性一致性读</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E4%B8%BB%E8%AF%BB%E4%BB%8E%E7%BC%BA%E9%99%B7%E5%88%86%E6%9E%90"><span class="nav-number">6.2.1.</span> <span class="nav-text">写主读从缺陷分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E4%B8%BB%E8%AF%BB%E4%B8%BB%E7%BC%BA%E9%99%B7%E5%88%86%E6%9E%90"><span class="nav-number">6.2.2.</span> <span class="nav-text">写主读主缺陷分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%B8%80%EF%BC%9A%E7%8A%B6%E6%80%81%E6%9C%BA%E8%90%BD%E5%90%8E%E4%BA%8E-committed-log-%E5%AF%BC%E8%87%B4%E8%84%8F%E8%AF%BB"><span class="nav-number">6.2.2.1.</span> <span class="nav-text">问题一：状态机落后于 committed log 导致脏读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%BA%8C%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E5%AF%BC%E8%87%B4%E8%84%8F%E8%AF%BB"><span class="nav-number">6.2.2.2.</span> <span class="nav-text">问题二：网络分区导致脏读</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Raft-Log-Read"><span class="nav-number">6.2.3.</span> <span class="nav-text">Raft Log Read</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Raft-%E8%AF%BB%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">6.3.</span> <span class="nav-text">Raft 读性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Read-Index"><span class="nav-number">6.3.1.</span> <span class="nav-text">Read Index</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lease-Read"><span class="nav-number">6.3.2.</span> <span class="nav-text">Lease Read</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Follower-Read"><span class="nav-number">6.3.3.</span> <span class="nav-text">Follower Read</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
