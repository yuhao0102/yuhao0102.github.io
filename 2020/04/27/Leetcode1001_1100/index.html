<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Leetcode1002. Find Common CharactersGiven an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  F">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode1001 - 1100">
<meta property="og:url" content="http://yoursite.com/2020/04/27/Leetcode1001_1100/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Leetcode1002. Find Common CharactersGiven an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  F">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/20211116215700.png">
<meta property="og:image" content="http://yoursite.com/img/20190813007.png">
<meta property="og:image" content="http://yoursite.com/img/sum-of-root-to-leaf-binary-numbers.png">
<meta property="og:image" content="http://yoursite.com/img/2whqcep.jpg">
<meta property="og:image" content="http://yoursite.com/img/20190506tree.png">
<meta property="article:published_time" content="2020-04-27T08:26:00.000Z">
<meta property="article:modified_time" content="2022-12-26T08:02:40.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="Leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/20211116215700.png">

<link rel="canonical" href="http://yoursite.com/2020/04/27/Leetcode1001_1100/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>Leetcode1001 - 1100 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/resume.pdf" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">128</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/yuhao0102" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/27/Leetcode1001_1100/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Leetcode1001 - 1100
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-27 16:26:00" itemprop="dateCreated datePublished" datetime="2020-04-27T16:26:00+08:00">2020-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-26 16:02:40" itemprop="dateModified" datetime="2022-12-26T16:02:40+08:00">2022-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Leetcode1002-Find-Common-Characters"><a href="#Leetcode1002-Find-Common-Characters" class="headerlink" title="Leetcode1002. Find Common Characters"></a>Leetcode1002. Find Common Characters</h1><p>Given an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.</p>
<p>You may return the answer in any order.</p>
<p>Example 1:</p>
<p>Input: [“bella”,”label”,”roller”]<br>Output: [“e”,”l”,”l”]<br>Example 2:</p>
<p>Input: [“cool”,”lock”,”cook”]<br>Output: [“c”,”o”]</p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 100</li>
<li>1 &lt;= A[i].length &lt;= 100</li>
<li><code>A[i][j]</code> is a lowercase letter</li>
</ul>
<p>这个打表要二维打表，第一次的时候没有注意，用了一维的，所以错了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">commonChars</span><span class="params">(vector&lt;string&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="type">int</span> vis[<span class="number">102</span>][<span class="number">27</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            s = A[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;A[i].<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">                vis[i][s[j]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打表，记下来每个string中每个字母出现的次数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> minn=<span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;A.<span class="built_in">size</span>();j++)</span><br><span class="line">		    &#123;</span><br><span class="line">			    <span class="keyword">if</span>(vis[j][i]&lt;minn)</span><br><span class="line">				    minn=vis[j][i];</span><br><span class="line">    	    &#125;</span><br><span class="line">    	    <span class="comment">//看这个字母在每个string中出现的最少次数，</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;minn;j++)&#123;</span><br><span class="line">		        string s1;</span><br><span class="line">		        s1+=<span class="built_in">char</span>(<span class="string">&#x27;a&#x27;</span>+i);</span><br><span class="line">                res.<span class="built_in">push_back</span>(s1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1003-Check-If-Word-Is-Valid-After-Substitutions"><a href="#Leetcode1003-Check-If-Word-Is-Valid-After-Substitutions" class="headerlink" title="Leetcode1003. Check If Word Is Valid After Substitutions"></a>Leetcode1003. Check If Word Is Valid After Substitutions</h1><p>We are given that the string “abc” is valid.</p>
<p>From any valid string V, we may split V into two pieces X and Y such that X + Y (X concatenated with Y) is equal to V. (X or Y may be empty.) Then, X + “abc” + Y is also valid.</p>
<p>If for example S = “abc”, then examples of valid strings are: “abc”, “aabcbc”, “abcabc”, “abcabcababcc”. Examples of invalid strings are: “abccba”, “ab”, “cababc”, “bac”.</p>
<p>Return true if and only if the given string S is valid.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aabcbc&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">We start with the valid string &quot;abc&quot;.</span><br><span class="line">Then we can insert another &quot;abc&quot; between &quot;a&quot; and &quot;bc&quot;, resulting in &quot;a&quot; + &quot;abc&quot; + &quot;bc&quot; which is &quot;aabcbc&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcabcababcc&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">&quot;abcabcabc&quot; is valid after consecutive insertings of &quot;abc&quot;.</span><br><span class="line">Then we can insert &quot;abc&quot; before the last letter, resulting in &quot;abcabcab&quot; + &quot;abc&quot; + &quot;c&quot; which is &quot;abcabcababcc&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abccba&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;cababc&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= S.length &lt;= 20000</li>
<li>S[i] is ‘a’, ‘b’, or ‘c’</li>
</ul>
<p>使用 vector 来模拟栈, 当遍历访问到 c 时, 需要判断 stack 中是否已经有 a 和 b 的存在.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; v;</span><br><span class="line">        v.<span class="built_in">resize</span>(<span class="number">20000</span>);</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(p &gt; <span class="number">0</span> &amp;&amp; v[p<span class="number">-1</span>] == <span class="string">&#x27;b&#x27;</span>) || !(p &gt; <span class="number">1</span> &amp;&amp; v[p<span class="number">-2</span>] == <span class="string">&#x27;a&#x27;</span>))  </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                p -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                v[p] = c;</span><br><span class="line">                p ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>() != <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>() != <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                st.<span class="built_in">pop</span>();   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>() != <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1004-Max-Consecutive-Ones-III"><a href="#Leetcode1004-Max-Consecutive-Ones-III" class="headerlink" title="Leetcode1004. Max Consecutive Ones III"></a>Leetcode1004. Max Consecutive Ones III</h1><p>Given an array A of 0s and 1s, we may change up to K values from 0 to 1.</p>
<p>Return the length of the longest (contiguous) subarray that contains only 1s.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:</span><br><span class="line">[1,1,1,0,0,1,1,1,1,1,1]</span><br><span class="line">Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3</span><br><span class="line">Output: 10</span><br><span class="line">Explanation:</span><br><span class="line">[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]</span><br><span class="line">Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 20000</li>
<li>0 &lt;= K &lt;= A.length</li>
<li>A[i] is 0 or 1</li>
</ul>
<p>一个由0和1组成的数组，最多反转k个元素，问能够形成的最长的1序列是多长。这个是滑动窗口的题。对数组进行遍历，如果遇到0，就先把它反转，统计被反转的0的个数，如果反转了0之后，发现反转多了，就移动窗口（left++），直到反转的0小于等于k个，再计算窗口的大小。</p>
<p>用个变量 cnt 记录当前将0变为1的个数，在遍历数组的时候，若遇到了0，则 cnt 自增1。若此时 cnt 大于K了，说明该缩小窗口了，用个 while 循环，若左边界为0，移除之后，此时 cnt 应该自减1，left 自增1，每次用窗口大小更新结果 res 即可<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestOnes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, res = <span class="number">0</span>, len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)</span><br><span class="line">                cnt ++;</span><br><span class="line">            <span class="keyword">while</span>(cnt &gt; k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] == <span class="number">0</span>)</span><br><span class="line">                    cnt --;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们也可以写的更简洁一些，不用 while 循环，但是还是用的滑动窗口的思路，其中i表示左边界，j为右边界。在遍历的时候，若遇到0，则K自减1，若K小于0了，且 A[i] 为0，则K自增1，且i自增1，最后返回窗口的大小即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestOnes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = A.<span class="built_in">size</span>(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] == <span class="number">0</span>) --K;</span><br><span class="line">            <span class="keyword">if</span> (K &lt; <span class="number">0</span> &amp;&amp; A[i++] == <span class="number">0</span>) ++K;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j - i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1005-Maximize-Sum-Of-Array-After-K-Negations"><a href="#Leetcode1005-Maximize-Sum-Of-Array-After-K-Negations" class="headerlink" title="Leetcode1005. Maximize Sum Of Array After K Negations"></a>Leetcode1005. Maximize Sum Of Array After K Negations</h1><p>Given an array A of integers, we must modify the array in the following way: we choose an i and replace A[i] with -A[i], and we repeat this process K times in total.  (We may choose the same index i multiple times.) Return the largest possible sum of the array after modifying it in this way.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [4,2,3], K = 1</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Choose indices (1,) and A becomes [4,-2,3].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [3,-1,0,2], K = 3</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Choose indices (1, 2, 2) and A becomes [3,1,0,2].</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2,-3,-1,5,-4], K = 2</span><br><span class="line">Output: 13</span><br><span class="line">Explanation: Choose indices (1, 4) and A becomes [2,3,-1,5,4].</span><br></pre></td></tr></table></figure></p>
<p>题目的意思是将A中的数进行取反（正变负，负变正）K次，可以重复对一个元素取反，最后求A中元素总和的最大值。取反可以分为两种情况：当A中都是正数的时候，比如{1,2,4,6}，如果K是偶数，那么可以不用进行取反操作，因为负负得正；如果K是奇数，则只需要对最小的数取反一次即可。当A中有正数也有负数的时候，比如{-4,-3,-1,2,5}，此时对负数元素进行取反操作，直到当前元素大于0或者K次转换已用完，此时针对K中剩余的转换次数，又可以细分为两种情况：</p>
<ol>
<li>K中剩余的转换次数为偶数，即A中元素全是正数，依据负负得正，不用再进行额外的转换了。</li>
<li>K中剩余的转换次数为奇数，即还需要再将某个元素转换一次，而为了元素总和最大，需要比较当前元素（正数）和前一个元素（负数）的绝对值大小，对较小的元素进行取反。</li>
</ol>
<p>最后使用一个for循环，计算A中所有元素总和。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> b = <span class="number">0</span>, s = <span class="number">0</span>, length = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(K % <span class="number">2</span>)</span><br><span class="line">                A[<span class="number">0</span>] = -A[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; length &amp;&amp; A[i] &lt; <span class="number">0</span> &amp;&amp; K --) &#123;</span><br><span class="line">                A[i] = -A[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (K &gt; <span class="number">0</span> &amp;&amp; K%<span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="built_in">abs</span>(A[i]) &lt; <span class="built_in">abs</span>(A[i<span class="number">-1</span>]) ? A[i] = -A[i] : A[i<span class="number">-1</span>] = -A[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i ++)</span><br><span class="line">            sum += A[i];</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1006-Clumsy-Factorial"><a href="#Leetcode1006-Clumsy-Factorial" class="headerlink" title="Leetcode1006. Clumsy Factorial"></a>Leetcode1006. Clumsy Factorial</h1><p>Normally, the factorial of a positive integer n is the product of all positive integers less than or equal to n.  For example, factorial(10) = 10 <em> 9 </em> 8 <em> 7 </em> 6 <em> 5 </em> 4 <em> 3 </em> 2 * 1.</p>
<p>We instead make a  clumsy factorial:  using the integers in decreasing order, we swap out the multiply operations for a fixed rotation of operations: multiply (*), divide (/), add (+) and subtract (-) in this order.</p>
<p>For example, clumsy(10) = 10 <em> 9 / 8 + 7 - 6 </em> 5 / 4 + 3 - 2 * 1.  However, these operations are still applied using the usual order of operations of arithmetic: we do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right.</p>
<p>Additionally, the division that we use is  floor division  such that 10 * 9 / 8 equals 11.  This guarantees the result is an integer.</p>
<p>Implement the clumsy function as defined above: given an integer N, it returns the clumsy factorial of N.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: 7 = 4 * 3 / 2 + 1</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Input: 10 Output: 12 Explanation: 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= N &lt;= 10000</li>
<li>-2^31 &lt;= answer &lt;= 2^31 - 1  (The answer is guaranteed to fit within a 32-bit integer.)</li>
</ul>
<p>这道题定义了一种笨拙的阶乘，与正常的连续相乘不同的是，这里按顺序使用乘除加减号来计算，这里要保持乘除的优先级，现在给了一个正整数N，让求这种笨拙的阶乘是多少。由于需要保持乘除的优先级，使得问题变的稍微复杂了一些，否则直接按顺序一个个的计算就好。根据题目中的例子2分析，刚开始的乘和除可以直接计算，紧跟其后的加法，也可以直接累加，但是之后的减号，就不能直接计算，而是要先计算后面的乘和除，所以遇到了减号，是需要特殊处理一下的。</p>
<p>把算式进行分割，注意到算符是循环的，除了第一组是<code>+、*、/、+</code>以外，其他的<code>-、*、/、+</code>，所以用一个临时变量来记下当前组的符号即可，剩下的就按照循环来做。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">clumsy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, i = n, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i != n)</span><br><span class="line">                tmp = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span> &amp;&amp; i &gt; <span class="number">0</span>; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) tmp *= (i --);</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">1</span>) tmp *= (i --);</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">2</span>) tmp /= (i --);</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">3</span>) tmp += (i --);</span><br><span class="line">            &#125;</span><br><span class="line">            sum += tmp;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其他的做法：用个变量j来循环遍历这个数组，从而知道当前该做什么操作。还需要一个变量 cur 来计算乘和除优先级的计算，初始化为N，此时从 N-1 遍历到1，若遇到乘号，则 cur 直接乘以当前数字，若遇到除号，cur 直接除以当前数字，若遇到加号，可以直接把当前数字加到结果 res 中，若遇到减号，此时需要判断一下，因为只有第一个乘和除后的结果是要加到 res 中的，后面的都是要减去的，所以要判断一下若当前数字等于 N-4 的时候，加上 cur，否者都是减去 cur，然后 cur 更新为当前数字，因为减号的优先级小于乘除，不能立马运算。之后j自增1并对4取余，最终返回的时候也需要做个判断，因为有可能数字比较小，减号还没有出来，且此时的最后面的乘除结果还保存在 cur 中，那么是加是减还需要看N的大小，若小于等于4，则加上 cur，反之则减去 cur，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">clumsy</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, cur = N, j = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; ops&#123;<span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ops[j] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                cur *= i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ops[j] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                cur /= i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ops[j] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                res += i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += (i == N - <span class="number">4</span>) ? cur : -cur;</span><br><span class="line">                cur = i;</span><br><span class="line">            &#125;</span><br><span class="line">            j = (j + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + ((N &lt;= <span class="number">4</span>) ? cur : -cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>再来看一种比较简洁的写法，由于每次遇到减号时，优先级会被改变，而前面的乘除加是可以提前计算的，所以可以每次处理四个数字，即首先处理 N, N-1, N-2, N-3 这四个数字，这里希望每次可以得到乘法计算时的第一个数字，可以通过<code>N - i*4</code>得到，这里需要满足<code>i*4 &lt; N</code>，知道了这个数字，然后可以立马算出乘除的结果，只要其大于等于3。然后需要将乘除之后的结果更新到 res 中，还是需要判断一下，若是第一个乘除的结果，需要加上，后面的都是减去。乘除后面跟的是加号，所以要加上 num-3 这个数字，前提是 num 大于3，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">clumsy</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i * <span class="number">4</span> &lt; N; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> num = N - i * <span class="number">4</span>, t = num;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="number">3</span>) t = num * (num - <span class="number">1</span>) / (num - <span class="number">2</span>);</span><br><span class="line">            res += (i == <span class="number">0</span>) ? t : -t;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">3</span>) res += (num - <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1007-Minimum-Domino-Rotations-For-Equal-Row"><a href="#Leetcode1007-Minimum-Domino-Rotations-For-Equal-Row" class="headerlink" title="Leetcode1007. Minimum Domino Rotations For Equal Row"></a>Leetcode1007. Minimum Domino Rotations For Equal Row</h1><p>In a row of dominoes, tops[i] and bottoms[i] represent the top and bottom halves of the ith domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)</p>
<p>We may rotate the ith domino, so that tops[i] and bottoms[i] swap values.</p>
<p>Return the minimum number of rotations so that all the values in tops are the same, or all the values in bottoms are the same.</p>
<p>If it cannot be done, return -1.</p>
<p>Example 1:<br><img src="/img/20211116215700.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">The first figure represents the dominoes as given by tops and bottoms: before we do any rotations.</span><br><span class="line">If we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.</span><br></pre></td></tr></table></figure>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: </span><br><span class="line">In this case, it is not possible to rotate the dominoes to make one row of values equal.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>2 &lt;= tops.length &lt;= 2 * 104</li>
<li>bottoms.length == tops.length</li>
<li>1 &lt;= tops[i], bottoms[i] &lt;= 6</li>
</ul>
<p>这道题说是有长度相等的两个数组A和B，分别表示一排多米诺的上边数字和下边数字，多米诺的个数和数组的长度相同，数字为1到6之间，问最少旋转多少次多米诺，可以使得上边或下边的数字全部相同。例子1中给了图解，很好的帮我们理解题意，实际上出现次数越多的数字越可能就是最终全部相同的数字，所以统计A和B中每个数字出现的次数就变的很重要了，由于A和B中有可能相同位置上的是相同的数字，则不用翻转，要使得同一行变为相同的数字，翻转的地方必须是不同的数字，如何才能知道翻转后可以使同一行完全相同呢？需要某个数字在A中出现的次数加上在B中出现的次数减去A和B中相同位置出现的次数后正好等于数组的长度，这里就需要用三个数组 cntA，cntB，和 same 来分别记录某个数字在A中，B中，A和B相同位置上出现的个数，然后遍历1到6，只要符合上面提到的条件，就可以直接返回数组长度减去该数字在A和B中出现的次数中的较大值。</p>
<p>总结就是：tops中某种大小的个数，加上bottoms中某种大小的个数，减去tops和bottoms里这种大小相同的个数，需要等于总个数，这样才能实现一排相同的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDominoRotations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; tops, vector&lt;<span class="type">int</span>&gt;&amp; bottoms)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = tops.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt1</span><span class="params">(<span class="number">7</span>, <span class="number">0</span>)</span>, <span class="title">cnt2</span><span class="params">(<span class="number">7</span>, <span class="number">0</span>)</span>, <span class="title">same</span><span class="params">(<span class="number">7</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            cnt1[tops[i]] ++;</span><br><span class="line">            cnt2[bottoms[i]] ++;</span><br><span class="line">            <span class="keyword">if</span> (tops[i] == bottoms[i])</span><br><span class="line">                same[tops[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">7</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt1[i] + cnt2[i] - same[i] == n)</span><br><span class="line">                <span class="keyword">return</span> n - <span class="built_in">max</span>(cnt1[i], cnt2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1008-Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#Leetcode1008-Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="Leetcode1008. Construct Binary Search Tree from Preorder Traversal"></a>Leetcode1008. Construct Binary Search Tree from Preorder Traversal</h1><p>Return the root node of a binary search tree that matches the given preorder traversal.</p>
<p>(Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value &lt; node.val, and any descendant of node.right has a value &gt; node.val.  Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.)</p>
<p>Example 1:</p>
<p>Input: [8,5,1,7,10,12]<br>Output: [8,5,10,1,7,null,12]</p>
<p><img src="/img/20190813007.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder,<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> temp=preorder[i];</span><br><span class="line">        <span class="type">int</span> ii;</span><br><span class="line">        <span class="keyword">for</span>(ii=i<span class="number">+1</span>;ii&lt;j;ii++)</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;preorder[ii])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[i]);</span><br><span class="line">        root-&gt;left = <span class="built_in">build</span>(preorder,i<span class="number">+1</span>,ii);</span><br><span class="line">        root-&gt;right = <span class="built_in">build</span>(preorder,ii,j);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstFromPreorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(preorder,<span class="number">0</span>,preorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一道简单的中序遍历题竟然做了这么久。。。</p>
<h1 id="Leetcode1009-Complement-of-Base-10-Integer"><a href="#Leetcode1009-Complement-of-Base-10-Integer" class="headerlink" title="Leetcode1009. Complement of Base 10 Integer"></a>Leetcode1009. Complement of Base 10 Integer</h1><p>Every non-negative integer N has a binary representation.  For example, 5 can be represented as “101” in binary, 11 as “1011” in binary, and so on.  Note that except for N = 0, there are no leading zeroes in any binary representation.</p>
<p>The complement of a binary representation is the number in binary you get when changing every 1 to a 0 and 0 to a 1.  For example, the complement of “101” in binary is “010” in binary.</p>
<p>For a given number N in base-10, return the complement of it’s binary representation as a base-10 integer.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 5 is &quot;101&quot; in binary, with complement &quot;010&quot; in binary, which is 2 in base-10.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 7</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: 7 is &quot;111&quot; in binary, with complement &quot;000&quot; in binary, which is 0 in base-10.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: 10 is &quot;1010&quot; in binary, with complement &quot;0101&quot; in binary, which is 5 in base-10.</span><br></pre></td></tr></table></figure><br>将十进制变成二进制然后取反加和<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bitwiseComplement</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; re;</span><br><span class="line">        <span class="keyword">while</span>(N) &#123;</span><br><span class="line">            re.<span class="built_in">push_back</span>(N &amp; <span class="number">1</span>);</span><br><span class="line">            N = N &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(re.<span class="built_in">begin</span>(), re.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; re.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            res = res * <span class="number">2</span> + (~re[i] &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>方法二，利用位运算直接取反。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bitwiseComplement</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!N)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(N &gt; <span class="built_in">pow</span>(<span class="number">2</span>, i))</span><br><span class="line">            i ++;</span><br><span class="line">        <span class="keyword">return</span> (~N) &amp; ((<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>, i) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1010-Pairs-of-Songs-With-Total-Durations-Divisible-by-60"><a href="#Leetcode1010-Pairs-of-Songs-With-Total-Durations-Divisible-by-60" class="headerlink" title="Leetcode1010. Pairs of Songs With Total Durations Divisible by 60"></a>Leetcode1010. Pairs of Songs With Total Durations Divisible by 60</h1><p>In a list of songs, the i-th song has a duration of time[i] seconds. </p>
<p>Return the number of pairs of songs for which their total duration in seconds is divisible by 60.  Formally, we want the number of indices i, j such that i &lt; j with (time[i] + time[j]) % 60 == 0.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [30,20,150,100,40]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Three pairs have a total duration divisible by 60:</span><br><span class="line">(time[0] = 30, time[2] = 150): total duration 180</span><br><span class="line">(time[1] = 20, time[3] = 100): total duration 120</span><br><span class="line">(time[1] = 20, time[4] = 40): total duration 60</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [60,60,60]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: All three pairs have a total duration of 120, which is divisible by 60.</span><br></pre></td></tr></table></figure><br>一开始的思路，是暴力枚举，枚举第一首歌，然后第二首歌是枚举在第一首歌之后的所有情况，判断条件成立就 ans++ 。但这样子的时间复杂度是 O(n^2) 。题目中，数组长度 n&lt;=6e+4，所以时间复杂度是 3.6e+9，这样子会超时。</p>
<p>因此上述暴力枚举的方法行不通。</p>
<p>如果两首歌时间之和要能被60整除，说明余数为0，那么假设第一首歌对60的余数是 a ，那么另一首歌的对60的余数为 60-a 才行。所以我们可以用一个长度为60的数组，下标刚好对应求余后的数，每次找到一个新的歌余数为 a，就看它前面对应余数为 60-a 的有多少首歌，即可以匹配为多少对。最后这首歌的余数对应的下标数组值 ++。</p>
<p>这样解决之后，我们只用遍历一次数组即可，所以时间复杂度是 O(n) ，但是需要了额外的空间开销。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numPairsDivisibleBy60</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; time)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = time.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">yushu</span><span class="params">(<span class="number">60</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i ++) &#123;</span><br><span class="line">            res += yushu[(<span class="number">60</span> - time[i]%<span class="number">60</span>)%<span class="number">60</span>];</span><br><span class="line">            yushu[ time[i]%<span class="number">60</span> ] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1011-Capacity-To-Ship-Packages-Within-D-Days"><a href="#Leetcode1011-Capacity-To-Ship-Packages-Within-D-Days" class="headerlink" title="Leetcode1011. Capacity To Ship Packages Within D Days"></a>Leetcode1011. Capacity To Ship Packages Within D Days</h1><p>A conveyor belt has packages that must be shipped from one port to another within D days.</p>
<p>The ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.</p>
<p>Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within D days.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: weights = [1,2,3,4,5,6,7,8,9,10], D = 5</span><br><span class="line">Output: 15</span><br><span class="line">Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:</span><br><span class="line">1st day: 1, 2, 3, 4, 5</span><br><span class="line">2nd day: 6, 7</span><br><span class="line">3rd day: 8</span><br><span class="line">4th day: 9</span><br><span class="line">5th day: 10</span><br></pre></td></tr></table></figure></p>
<p>Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.</p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: weights = [3,2,2,4,1,4], D = 3</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:</span><br><span class="line">1st day: 3, 2</span><br><span class="line">2nd day: 2, 4</span><br><span class="line">3rd day: 1, 4</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: weights = [1,2,3,1,1], D = 4</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">1st day: 1</span><br><span class="line">2nd day: 2</span><br><span class="line">3rd day: 3</span><br><span class="line">4th day: 1, 1</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= D &lt;= weights.length &lt;= 5 * 104</li>
<li>1 &lt;= weights[i] &lt;= 500</li>
</ul>
<p>这道题说是有一条传送带在运送包裹货物，每个包裹有各自的重量，每天要把若干包裹运送到货轮上，货轮有特定的承载量，要求在给定的D天内将所有货物装上货轮，问船的最小载重量是多少。</p>
<p>首先来分析，由于船的载重量是固定的，而包裹在传送带上又只能按照顺序上传，并不能挑拣，所以一旦加上当前包裹超过了船的载重量，则必须要放弃这个包裹，比较极端的例子就是，假如船的载重量是 50，现在船上已经装了一个重量为1的包裹，而下一个包裹重量是 50，那么这个包裹只能装在下一条船上。知道了这一点后，再来分析一下，船的载重量的范围，先来分析一下最小值，由于所有的包裹都要上船，所以最小的船载重量至少应该是最重的那个包裹，不然上不了船了，而最大的载重量就是包裹的总重量，一条船就能拉走了。所以正确的答案就在这两个边界范围之内，挨个遍历的话实在有些太不高效了。</p>
<p>这里就要祭出二分搜索法了，当算出了中间值 mid 后，利用这个载重量去算需要多少天能运完，然后去和D做比较，如果大于D，说明需要增加载重量，否则减少载重量，最终会终止到正确的结果。具体来看代码，left 初始化为最大的包裹重量，right 初始化为所有的包裹重量总和。然后进行 while 循环，求出 mid，同时使用两个变量 cnt 和 cur，分别用来计算需要的天数，和当前货物的重量，其中 cnt 初始化为1，至少需要一天来运货物。然后遍历所有的包裹重量，每次加到 cur，若此时 cur 大于 mid 了，说明当前包裹不能加了，将 cur 重置为当前包裹重量，为下条船做准备，然后 cnt 自增1。遍历完了之后，判断若 cnt 大于D，则 left 赋值为 mid+1，否则 right 赋值为 mid，最终返回 left 即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shipWithinDays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; weights, <span class="type">int</span> days)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, size = weights.<span class="built_in">size</span>(), max_val = <span class="number">-1</span>, need;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            max_val = <span class="built_in">max</span>(max_val, weights[i]);</span><br><span class="line">            sum += weights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left = max_val, right = sum, mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            need = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur + weights[i] &gt; mid) &#123;</span><br><span class="line">                    need ++;</span><br><span class="line">                    cur = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur += weights[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (need &gt; days)</span><br><span class="line">                left = mid<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1013-Partition-Array-Into-Three-Parts-With-Equal-Sum"><a href="#Leetcode1013-Partition-Array-Into-Three-Parts-With-Equal-Sum" class="headerlink" title="Leetcode1013. Partition Array Into Three Parts With Equal Sum"></a>Leetcode1013. Partition Array Into Three Parts With Equal Sum</h1><p>Given an array A of integers, return true if and only if we can partition the array into three non-empty parts with equal sums.</p>
<p>Formally, we can partition the array if we can find indexes i+1 &lt; j with (A[0] + A[1] + … + A[i] == A[i+1] + A[i+2] + … + A[j-1] == A[j] + A[j-1] + … + A[A.length - 1])</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [0,2,1,-6,6,-7,9,1,2,0,1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [0,2,1,-6,6,7,9,-1,2,0,1]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [3,3,6,5,-2,2,5,1,-9,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4</span><br></pre></td></tr></table></figure><br>1、检查总数是否能被3整除;<br>2、循环遍历数组A，计算和的一部分;如果找到平均值，则将该部分重置为0，并增加计数器;<br>3、到最后，如果平均可以看到至少3次，返回true;否则返回假。<br>注意:如果在数组结束前找到2次平均值(sum / 3)，那么剩下的部分也等于平均值。因此，计数器达到3后无需继续。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canThreePartsEqualSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, part_sum = <span class="number">0</span>, i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++) </span><br><span class="line">            sum += A[i];</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">3</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum /= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            part_sum += A[i];</span><br><span class="line">            <span class="keyword">if</span>(part_sum == sum)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(part_sum = <span class="number">0</span>, i = i + <span class="number">1</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            part_sum += A[i];</span><br><span class="line">            <span class="keyword">if</span>(part_sum == sum)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1014-Best-Sightseeing-Pair"><a href="#Leetcode1014-Best-Sightseeing-Pair" class="headerlink" title="Leetcode1014. Best Sightseeing Pair"></a>Leetcode1014. Best Sightseeing Pair</h1><p>Given an array A of positive integers, A[i] represents the value of the i-th sightseeing spot, and two sightseeing spots i and j have distance j - i between them.</p>
<p>The  score  of a pair (i &lt; j) of sightseeing spots is (A[i] + A[j] + i - j) : the sum of the values of the sightseeing spots, minus the distance between them.</p>
<p>Return the maximum score of a pair of sightseeing spots.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [8,1,5,2,6]</span><br><span class="line">Output: 11</span><br><span class="line">Explanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>2 &lt;= A.length &lt;= 50000</li>
<li>1 &lt;= A[i] &lt;= 1000</li>
</ul>
<p>这道题给了一个正整数的数组A，定义了一种两个数字对儿的记分方式，为<code>A[i] + A[j] + i - j</code>，现在让找出最大的那组的分数。利用加法的分配律，可以得到<code>A[i] + i + A[j] - j</code>，为了使这个表达式最大化，<code>A[i] + i</code>自然是越大越好，这里可以使用一个变量 mx 来记录之前出现过的<code>A[i] + i</code>的最大值，则当前的数字就可以当作数对儿中的另一个数字，其减去当前坐标值再加上 mx 就可以更新结果 res 了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; values)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxx = INT_MIN, res = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, maxx + values[i] - i);</span><br><span class="line">            maxx = <span class="built_in">max</span>(maxx, values[i] + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1015-Smallest-Integer-Divisible-by-K"><a href="#Leetcode1015-Smallest-Integer-Divisible-by-K" class="headerlink" title="Leetcode1015. Smallest Integer Divisible by K"></a>Leetcode1015. Smallest Integer Divisible by K</h1><p>Given a positive integer K, you need to find the length of the smallest positive integer N such that N is divisible by K, and N only contains the digit 1.</p>
<p>Return <em>the length of </em>N. If there is no such N, return -1.</p>
<p>Note: N may not fit in a 64-bit signed integer.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: K = 1</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The smallest answer is N = 1, which has length 1.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: K = 2</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: There is no such positive integer N divisible by 2.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: K = 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The smallest answer is N = 111, which has length 3.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= K &lt;= 105</li>
</ul>
<p>这道题说是给了一个正整数K，让找到一个长度最短且只由1组成的正整数N，可以整除K，问最短的长度是多少，若没有，则返回 -1。关于整除的一些性质，博主记得小学就应该学过，比如能被2整除的数字必须是偶数，能被3整除的数字各个位加起来必须能被3整除，能被5整除的数字的末尾数字必须是0或者5。由于N都是由1组成的，所以一定不可能整除2或者5，所以只要K中包含2或者5，直接返回 -1。其实有一个定理，若K不能被2或5整除，则一定有一个长度小于等于K且均由1组成的数，可以整除K。这里只要找到那个最短的长度即可。</p>
<p>从1开始检查，每次乘以 10 再加1，就可以得到下一个数字，但是由于K可能很大，则N就会超出整型数的范围，就算是长整型也不一定 hold 的住，所以不能一直变大，而是每次累加后都要对 K 取余，若余数为0，则直接返回当前长度，若不为0，则用余数乘以 10 再加1。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">smallestRepunitDivByK</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span> || k % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++) &#123;</span><br><span class="line">            r = r * <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (r % k == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            r = r % k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1016-Binary-String-With-Substrings-Representing-1-To-N"><a href="#Leetcode1016-Binary-String-With-Substrings-Representing-1-To-N" class="headerlink" title="Leetcode1016. Binary String With Substrings Representing 1 To N"></a>Leetcode1016. Binary String With Substrings Representing 1 To N</h1><p>Given a binary string S (a string consisting only of ‘0’ and ‘1’s) and a positive integer N, return true if and only if for every integer X from 1 to N, the binary representation of X is a substring of S.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;0110&quot;, N = 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;0110&quot;, N = 4</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= S.length &lt;= 1000</li>
<li>1 &lt;= N &lt;= 10^9</li>
</ul>
<p>这道题给了一个二进制的字符串S，和一个正整数N，问从1到N的所有整数的二进制数的字符串是否都是S的子串。</p>
<p>验证从N到1之间所有的数字，先求出其二进制数的字符串，在 C++ 中可以利用 bitset 来做，将其转为字符串即可。由于定义了 32 位的 bitset，转为字符串后可能会有许多 leading zeros，所以首先要移除这些0，通过在字符串中查找第一个1，然后通过取子串的函数就可以去除所有的起始0了。然后在S中查找是否存在这个二进制字符串，若不存在，直接返回 false，遍历完成后返回 true 即可，参见代码如下：</p>
<p>学到了，<code>bitset</code>还可以这么用，转成二进制字符串确实很方便。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">queryString</span><span class="params">(string S, <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = N; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            string b = <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(i).<span class="built_in">to_string</span>();</span><br><span class="line">            <span class="keyword">if</span> (S.<span class="built_in">find</span>(b.<span class="built_in">substr</span>(b.<span class="built_in">find</span>(<span class="string">&quot;1&quot;</span>))) == string::npos) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1017-Convert-to-Base-2"><a href="#Leetcode1017-Convert-to-Base-2" class="headerlink" title="Leetcode1017. Convert to Base -2"></a>Leetcode1017. Convert to Base -2</h1><p>Given an integer n, return a binary string representing its representation in base -2.</p>
<p>Note that the returned string should not have leading zeros unless the string is “0”.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: &quot;110&quot;</span><br><span class="line">Explantion: (-2)2 + (-2)1 = 2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: &quot;111&quot;</span><br><span class="line">Explantion: (-2)2 + (-2)1 + (-2)0 = 3</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4</span><br><span class="line">Output: &quot;100&quot;</span><br><span class="line">Explantion: (-2)2 = 4</span><br></pre></td></tr></table></figure></p>
<p>这道题给了一个十进制的非负数N，让转为以负二进制的数。我们对于十进制数转二进制的数字应该比较熟悉，就是每次<code>N%2</code>或者<code>N&amp;1</code>，然后再将N右移一位，即相当于除以2，直到N为0为止。对于转为负二进制的数字，也是同样的做法，唯一不同的是，每次要除以 -2，即将N右移一位之后，要变为相反数，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">baseNeg2</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span> (N != <span class="number">0</span>) &#123;</span><br><span class="line">            res = <span class="built_in">to_string</span>(N &amp; <span class="number">1</span>) + res;</span><br><span class="line">            N = -(N &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == <span class="string">&quot;&quot;</span> ? <span class="string">&quot;0&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由于转二进制数是要对2取余，则转负二进制就要对 -2 取余，然后N要除以 -2，但是有个问题是，取余操作可能会得到负数，但我们希望只得到0或1，这样就需要做些小调整，使其变为正数，变化方法是，余数加2，N加1，证明方法如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-1 = (-2) * 0 + (-1)</span><br><span class="line">-1 = (-2) * 0 + (-2) + (-1) - (-2)</span><br><span class="line">-1 = (-2) * (0 + 1) + (-1) - (-2)</span><br></pre></td></tr></table></figure></p>
<p>先加上一个 -2，再减去一个 -2，合并后就是N加1，余数加2，这样就可以把余数加到结果字符串中了，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">baseNeg2</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span> (N != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> rem = N % (<span class="number">-2</span>);</span><br><span class="line">            N /= <span class="number">-2</span>;</span><br><span class="line">            <span class="keyword">if</span> (rem &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                rem += <span class="number">2</span>;</span><br><span class="line">                N += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">to_string</span>(rem) + res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == <span class="string">&quot;&quot;</span> ? <span class="string">&quot;0&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1018-Binary-Prefix-Divisible-By-5"><a href="#Leetcode1018-Binary-Prefix-Divisible-By-5" class="headerlink" title="Leetcode1018. Binary Prefix Divisible By 5"></a>Leetcode1018. Binary Prefix Divisible By 5</h1><p>Given an array A of 0s and 1s, consider N_i: the i-th subarray from A[0] to A[i] interpreted as a binary number (from most-significant-bit to least-significant-bit.)</p>
<p>Return a list of booleans answer, where answer[i] is true if and only if N_i is divisible by 5.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,1]</span><br><span class="line">Output: [true,false,false]</span><br><span class="line">Explanation: The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10.  Only the first number is divisible by 5, so answer[0] is true.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,1]</span><br><span class="line">Output: [false,false,false]</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,1,1,1,1]</span><br><span class="line">Output: [true,false,false,false,true,false]</span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,1,0,1]</span><br><span class="line">Output: [false,false,false,false,false]</span><br></pre></td></tr></table></figure><br>假设当前访问 A[i - 1], 表示的数为 old_number, 那么当访问 A[i] 时, 所表示的数 new_number = old_number * 2 + A[i];</p>
<ul>
<li>如果直接判断 new_number 是否能被 5 整除, 容易出现溢出的问题, 因为按照上面遍历的方式, C++ 只能保存 32-bit 的数据, 但是题目中说明 1 &lt;= A.length &lt;= 30000.</li>
<li>我们不需要知道具体的 new_number 数值大小, 而只需要它与 5 的余数;<br>-发现一个数学公式: <code>(a*b + c) % d = ((a%d)*(b%d) + c%d) % d</code>, 因此 <code>new_number % 5</code> 可以表示为 <code>((old_number % 5) * 2 + A[i]) % 5</code>.</li>
<li>由第 4 点, 可以将 number % 5 作为一个整体, 更新公式为 <code>a = (a * 2 + A[i]) % 5</code>.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">prefixesDivBy5</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            ans = ((ans * <span class="number">2</span>)%<span class="number">5</span> + A[i])%<span class="number">5</span>;</span><br><span class="line">            <span class="keyword">if</span>(ans % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1019-Next-Greater-Node-In-Linked-List"><a href="#Leetcode1019-Next-Greater-Node-In-Linked-List" class="headerlink" title="Leetcode1019. Next Greater Node In Linked List"></a>Leetcode1019. Next Greater Node In Linked List</h1><p>You are given the head of a linked list with n nodes.</p>
<p>For each node in the list, find the value of the next greater node. That is, for each node, find the value of the first node that is next to it and has a strictly larger value than it.</p>
<p>Return an integer array answer where answer[i] is the value of the next greater node of the ith node (1-indexed). If the ith node does not have a next greater node, set answer[i] = 0.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [2,1,5]</span><br><span class="line">Output: [5,5,0]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [2,7,4,3,5]</span><br><span class="line">Output: [7,0,5,5,0]</span><br></pre></td></tr></table></figure></p>
<p>这道题给了一个链表，让找出每个结点值的下一个较大的结点值，跟之前的 Next Greater Element I，Next Greater Element II，和 Next Greater Element III 很类似，不同的是这里不是数组，而是链表，就稍稍的增加了一些难度，因为链表无法直接根据下标访问元素，在遍历链表之前甚至不知道总共有多少个结点。基本上来说，为了达到线性的时间复杂度，这里需要维护一个单调递减的栈，若当前的数字小于等于栈顶元素，则加入栈，若当前数字大于栈顶元素，非常棒，说明栈顶元素的下一个较大数字找到了，标记上，且把栈顶元素移除，继续判断下一个栈顶元素和当前元素的关系，直到当前数字小于等于栈顶元素为止。通过这种方法，就可以在线性的时间内找出所有数字的下一个较大的数字了。</p>
<p>这里新建两个数组，res 和 nums 分别保存要求的结果和链表的所有结点值，还需要一个栈 st 和一个变量 cnt（记录当前的数组坐标），然后开始遍历链表，首先把当前结点值加入数组 nums，然后开始循环，若栈不空，且当前结点值大于栈顶元素（注意这里单调栈存的并不是结点值，而是该值在 nums 数组中的坐标值，这是为了更好的在结果 res 中定位），此时用该结点值来更新结果 res 中的对应的位置，然后将栈顶元素移除，继续循环直到条件不满足位置。然后把当前的坐标加入栈中，此时还要更新结果 res 的大小，因为由于链表的大小未知，无法直接初始化 res 的大小，当然我们可以在开头的时候先遍历一遍链表，得到结点的个数也是可以的，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextLargerNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res2</span><span class="params">(cnt, <span class="number">0</span>)</span></span>;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; res[s.<span class="built_in">top</span>()] &lt; head-&gt;val) &#123;</span><br><span class="line">                res2[s.<span class="built_in">top</span>()] = head-&gt;val;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(cnt);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个人写的方法需要经常resize，不一定更快。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextLargerNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res, nums;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            nums.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; head-&gt;val &gt; nums[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                res[st.<span class="built_in">top</span>()] = head-&gt;val;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(cnt);</span><br><span class="line">            res.<span class="built_in">resize</span>(++cnt);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>再看一种方法，首先把链表反转，也是用单调栈的方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextLargerNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        ListNode* revHead = <span class="built_in">reverseList</span>(head);</span><br><span class="line">        ListNode* curr = revHead;</span><br><span class="line">        </span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        std::stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">                st.<span class="built_in">push</span>(curr-&gt;val);</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; curr-&gt;val &gt;= st.<span class="built_in">top</span>())</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">                    result.<span class="built_in">push_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    result.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">                st.<span class="built_in">push</span>(curr-&gt;val);</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::<span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1020-Number-of-Enclaves"><a href="#Leetcode1020-Number-of-Enclaves" class="headerlink" title="Leetcode1020. Number of Enclaves"></a>Leetcode1020. Number of Enclaves</h1><p>Given a 2D array A, each cell is 0 (representing sea) or 1 (representing land)</p>
<p>A move consists of walking from one land square 4-directionally to another land square, or off the boundary of the grid.</p>
<p>Return the number of land squares in the grid for which we cannot walk off the boundary of the grid in any number of moves.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">There are three 1s that are enclosed by 0s, and one 1 that isn&#x27;t enclosed because its on the boundary.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">All 1s are either on the boundary or can reach the boundary.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 500</li>
<li>1 &lt;= A[i].length &lt;= 500</li>
<li>0 &lt;= A[i][j] &lt;= 1</li>
<li>All rows have the same size.</li>
</ul>
<p>这道题给了一个只有0和1的二维数组A，其中0表示海洋，1表示陆地，每次只能从一块陆地走到和其相连的另一块陆地上，问有多少块陆地可以不用走到边界上。其实这道题就是让找出被0完全包围的1的个数，反过来想，如果有1在边界上，那么和其相连的所有1都是不符合题意的，所以只要以边界上的1为起点，遍历所有和其相连的1，并且标记，则剩下的1一定就是被0完全包围的。遍历的方法可以用 BFS 或者 DFS，先来看 BFS 的解法，使用一个队列 queue，遍历数组A，现将所有1的个数累加到结果 res，然后将边界上的1的坐标加入队列中。然后开始 while 循环，去除队首元素，若越界了，或者对应的值不为1，直接跳过。否则标记当前位置值为0，并且 res 自减1，然后将周围四个位置都排入队列中，最后返回结果 res 即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numEnclaves</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>(), num1 = <span class="number">0</span>;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                num1 += grid[i][j];</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || i == m<span class="number">-1</span> || j == <span class="number">0</span> || j == n<span class="number">-1</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> x = q.<span class="built_in">front</span>().first, y = q.<span class="built_in">front</span>().second;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || grid[x][y] != <span class="number">1</span>) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (grid[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">                grid[x][y] = <span class="number">0</span>;</span><br><span class="line">                num1 --;</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x, y<span class="number">+1</span>));</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x, y<span class="number">-1</span>));</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x<span class="number">+1</span>, y));</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x<span class="number">-1</span>, y));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用深度优先确实能快一点点<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[i][j] != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i, j<span class="number">+1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i, j<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i<span class="number">+1</span>, j);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i<span class="number">-1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numEnclaves</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>(), num1 = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">dfs</span>(grid, i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (grid[i][n<span class="number">-1</span>] == <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">dfs</span>(grid, i, n<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[<span class="number">0</span>][i] == <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">dfs</span>(grid, <span class="number">0</span>, i);</span><br><span class="line">            <span class="keyword">if</span> (grid[m<span class="number">-1</span>][i] == <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">dfs</span>(grid, m<span class="number">-1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    num1 ++;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1021-Remove-Outermost-Parentheses"><a href="#Leetcode1021-Remove-Outermost-Parentheses" class="headerlink" title="Leetcode1021. Remove Outermost Parentheses"></a>Leetcode1021. Remove Outermost Parentheses</h1><p>A valid parentheses string is either empty (“”), “(“ + A + “)”, or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, “”, “()”, “(())()”, and “(()(()))” are all valid parentheses strings.</p>
<p>A valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.</p>
<p>Given a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + … + P_k, where P_i are primitive valid parentheses strings.</p>
<p>Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(()())(())&quot;</span><br><span class="line">Output: &quot;()()()&quot;</span><br><span class="line">Explanation: </span><br><span class="line">The input string is &quot;(()())(())&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot;.</span><br><span class="line">After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; = &quot;()()()&quot;.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(()())(())(()(()))&quot;</span><br><span class="line">Output: &quot;()()()()(())&quot;</span><br><span class="line">Explanation: </span><br><span class="line">The input string is &quot;(()())(())(()(()))&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot; + &quot;(()(()))&quot;.</span><br><span class="line">After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; + &quot;()(())&quot; = &quot;()()()()(())&quot;.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()()&quot;</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: </span><br><span class="line">The input string is &quot;()()&quot;, with primitive decomposition &quot;()&quot; + &quot;()&quot;.</span><br><span class="line">After removing outer parentheses of each part, this is &quot;&quot; + &quot;&quot; = &quot;&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ol>
<li>S.length &lt;= 10000</li>
<li>S[i] is “(“ or “)”</li>
<li>S is a valid parentheses string</li>
</ol>
<p>比较简单，把最外边的一层括号移走，可以用栈，也可以用计数器。如果遇到左括号且栈不空说明这个左括号不是外边的括号，加到结果中，再把这个左括号压栈；如果是右括号，就先弹出栈，再判断如果栈不空则说明这个右括号也不是外边的括号，加到结果中。</p>
<p>不知道为啥我这个这么慢，反正过了就行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeOuterParentheses</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        string result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> length = S.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> ss=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ss!=<span class="number">0</span>)</span><br><span class="line">                    result=result+<span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">                ss++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(S[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                ss--;</span><br><span class="line">                <span class="keyword">if</span>(ss!=<span class="number">0</span>)</span><br><span class="line">                    result=result+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1022-Sum-of-Root-To-Leaf-Binary-Numbers"><a href="#Leetcode1022-Sum-of-Root-To-Leaf-Binary-Numbers" class="headerlink" title="Leetcode1022. Sum of Root To Leaf Binary Numbers"></a>Leetcode1022. Sum of Root To Leaf Binary Numbers</h1><p>Given a binary tree, each node has value 0 or 1.  Each root-to-leaf path represents a binary number starting with the most significant bit.  For example, if the path is 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1, then this could represent 01101 in binary, which is 13.</p>
<p>For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.</p>
<p>Return the sum of these numbers.</p>
<p><img src="/img/sum-of-root-to-leaf-binary-numbers.png" alt=""></p>
<p>深度优先遍历一波，因为好久没写dsf了，所以特地写一写。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root ,<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">            result += (now&lt;&lt;<span class="number">1</span>) + root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> val = (now&lt;&lt;<span class="number">1</span>) + root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRootToLeaf</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        result=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1023-Camelcase-Matching"><a href="#Leetcode1023-Camelcase-Matching" class="headerlink" title="Leetcode1023. Camelcase Matching"></a>Leetcode1023. Camelcase Matching</h1><p>A query word matches a given pattern if we can insert lowercase letters to the pattern word so that it equals the query. (We may insert each character at any position, and may insert 0 characters.)</p>
<p>Given a list of queries, and a pattern, return an answer list of booleans, where answer[i] is true if and only if queries[i] matches the pattern.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FB&quot;</span><br><span class="line">Output: [true,false,true,true,false]</span><br><span class="line">Explanation: </span><br><span class="line">&quot;FooBar&quot; can be generated like this &quot;F&quot; + &quot;oo&quot; + &quot;B&quot; + &quot;ar&quot;.</span><br><span class="line">&quot;FootBall&quot; can be generated like this &quot;F&quot; + &quot;oot&quot; + &quot;B&quot; + &quot;all&quot;.</span><br><span class="line">&quot;FrameBuffer&quot; can be generated like this &quot;F&quot; + &quot;rame&quot; + &quot;B&quot; + &quot;uffer&quot;.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FoBa&quot;</span><br><span class="line">Output: [true,false,true,false,false]</span><br><span class="line">Explanation: </span><br><span class="line">&quot;FooBar&quot; can be generated like this &quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot;.</span><br><span class="line">&quot;FootBall&quot; can be generated like this &quot;Fo&quot; + &quot;ot&quot; + &quot;Ba&quot; + &quot;ll&quot;.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FoBaT&quot;</span><br><span class="line">Output: [false,true,false,false,false]</span><br><span class="line">Explanation: </span><br><span class="line">&quot;FooBarTest&quot; can be generated like this &quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot; + &quot;T&quot; + &quot;est&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= queries.length &lt;= 100</li>
<li>1 &lt;= queries[i].length &lt;= 100</li>
<li>1 &lt;= pattern.length &lt;= 100</li>
<li>All strings consists only of lower and upper case English letters.</li>
</ul>
<p>给一个字符串和一个模式串，看能不能在模式串里加小写字母来转换成字符串，比较简单。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">camelMatch</span><span class="params">(vector&lt;string&gt;&amp; queries, string pattern)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;queries.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">bool</span> succ=<span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;queries[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="built_in">islower</span>(queries[i][j])&amp;&amp; pattern[index]!=queries[i][j])&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(pattern[index]==queries[i][j])</span><br><span class="line">                    index++;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    succ=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(succ);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>我的代码比较慢，可以看看大佬们怎么写的。</p>
<p>Solution 1, Find<br>For each query, find all letters in pattern left-to-right. If we found all pattern letters, check that the rest of the letters is in the lower case.</p>
<p>对每个查询，从左到右找pattern里的字幕，如果找到了，检查剩余的是否是小写字母。感觉跟我的类似。</p>
<p>For simplicity, we can replace the found pattern letter in query with a lowercase ‘a’.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">camelMatch</span><span class="params">(vector&lt;string&gt;&amp; qs, string pattern, vector&lt;<span class="type">bool</span>&gt; res = &#123;&#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; qs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = <span class="number">-1</span>, j = <span class="number">0</span>; j &lt; pattern.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">      p = qs[i].<span class="built_in">find</span>(pattern[j], p + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (p == string::npos) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      qs[i][p] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="built_in">size</span>() &lt;= i) res.<span class="built_in">push_back</span>(<span class="built_in">all_of</span>(<span class="built_in">begin</span>(qs[i]), <span class="built_in">end</span>(qs[i]), [](<span class="type">char</span> ch) &#123; <span class="keyword">return</span> <span class="built_in">islower</span>(ch); &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Solution 2, Simple Scan<br>Instead of using the find function, we can just check all characters in the query. If a character matches the pattern pointer (pattern[p]), we advance that pointer (++p). Otherwise, we check that the query character is in the lower case.</p>
<p>检查查询的字符串，如果一个字符与pattern[p]匹配了，就继续，如果不匹配，看是不是小些</p>
<p>With this solution, it’s also easer to realize that the complexity is O(n), where n is the total number of query characters.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">camelMatch</span><span class="params">(vector&lt;string&gt;&amp; qs, string pattern, vector&lt;<span class="type">bool</span>&gt; res = &#123;&#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>, j = <span class="number">0</span>, p = <span class="number">0</span>; i &lt; qs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>, p = <span class="number">0</span>; j &lt; qs[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p &lt; pattern.<span class="built_in">size</span>() &amp;&amp; qs[i][j] == pattern[p]) ++p;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">islower</span>(qs[i][j])) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="built_in">push_back</span>(j == qs[i].<span class="built_in">size</span>() &amp;&amp; p == pattern.<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Complexity Analysis</p>
<ul>
<li>Runtime: O(n), where n is all letters in all queries. We process each letter only once.</li>
<li>Memory: O(m), where m is the number of queries (to store the result).</li>
<li>时间复杂度O(n)，空间复杂度O(m)</li>
</ul>
<h1 id="Leetcode1024-Video-Stitching"><a href="#Leetcode1024-Video-Stitching" class="headerlink" title="Leetcode1024. Video Stitching"></a>Leetcode1024. Video Stitching</h1><p>You are given a series of video clips from a sporting event that lasted T seconds.  These video clips can be overlapping with each other and have varied lengths.</p>
<p>Each video clip clips[i] is an interval: it starts at time clips[i][0] and ends at time clips[i][1].  We can cut these clips into segments freely: for example, a clip [0, 7] can be cut into segments [0, 1] + [1, 3] + [3, 7].</p>
<p>Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event ([0, T]).  If the task is impossible, return -1.</p>
<p>寻找最少的可以覆盖[0, T]区间的区间数量，一开始没搞定，看答案搞定的。总体思路就是一开始先排序，并且记下来两个end，一个是当前的end，一个是之前一次的end，如果现在这个小区间的end比之前的pre_end还小，直接不考虑了。我做的时候忽略了这一点，如果不记下来之前的per_end的话，可能有区间是重复的（现在这个小区间如果加进去了，就跟上次加进去的那个小区间有重复的部分或者重合）</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.</span><br><span class="line">Then, we can reconstruct the sporting event as follows:</span><br><span class="line">We cut [1,9] into segments [1,2] + [2,8] + [8,9].</span><br><span class="line">Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: clips = [[0,1],[1,2]], T = 5</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: </span><br><span class="line">We can&#x27;t cover [0,5] with only [0,1] and [0,2].</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">We can take clips [0,4], [4,7], and [6,9].</span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: clips = [[0,4],[2,8]], T = 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">Notice you can have extra video after the event ends.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= clips.length &lt;= 100<br>0 &lt;= clips[i][0], clips[i][1] &lt;= 100<br>0 &lt;= T &lt;= 100</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">comp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">videoStitching</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; clips, <span class="type">int</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(clips.<span class="built_in">begin</span>(), clips.<span class="built_in">end</span>(), comp);</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>, cur_end=<span class="number">0</span>, pre_end=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; clips.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(clips[i][<span class="number">1</span>] &lt;= cur_end)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(clips[i][<span class="number">0</span>] &gt; cur_end)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(clips[i][<span class="number">0</span>] &gt; pre_end)&#123;</span><br><span class="line">                pre_end = cur_end;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            cur_end = clips[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(cur_end &gt;= T)</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1025-Divisor-Game"><a href="#Leetcode1025-Divisor-Game" class="headerlink" title="Leetcode1025. Divisor Game"></a>Leetcode1025. Divisor Game</h1><p>Alice and Bob take turns playing a game, with Alice starting first.</p>
<p>Initially, there is a number N on the chalkboard.  On each player’s turn, that player makes a move consisting of:</p>
<p>Choosing any x with 0 &lt; x &lt; N and N % x == 0.<br>Replacing the number N on the chalkboard with N - x.<br>Also, if a player cannot make a move, they lose the game.</p>
<p>Return True if and only if Alice wins the game, assuming both players play optimally.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Alice chooses 1, and Bob has no more moves.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.</span><br></pre></td></tr></table></figure><br>Note:</p>
<ul>
<li>1 &lt;= N &lt;= 1000</li>
</ul>
<p>两个人玩游戏，给一个数字N，先轮到A走，A选一个数字x使得<code>0 &lt; x &lt; N</code>且<code>N % x == 0</code>，之后N变为N-x，如果谁选不出来x，那就输了，A遇见偶数赢，奇数输。</p>
<p>如果A看见偶数，就选x=1，则N变成奇数，B只能再选一个奇数，又把N变成偶数，由于1是奇数且1没法再选，故A遇见偶数一定赢，反之则输。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (N%<span class="number">2</span>)==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1026-Maximum-Difference-Between-Node-and-Ancestor"><a href="#Leetcode1026-Maximum-Difference-Between-Node-and-Ancestor" class="headerlink" title="Leetcode1026. Maximum Difference Between Node and Ancestor"></a>Leetcode1026. Maximum Difference Between Node and Ancestor</h1><p>Given the root of a binary tree, find the maximum value V for which there exists different nodes A and B where V = |A.val - B.val| and A is an ancestor of B.</p>
<p>(A node A is an ancestor of B if either: any child of A is equal to B, or any child of A is an ancestor of B.)</p>
<p>Example 1:<br><img src="/img/2whqcep.jpg" alt=""><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [8,3,10,1,6,null,14,null,null,4,7,13]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: </span><br><span class="line">We have various ancestor-node differences, some of which are given below :</span><br><span class="line">|8 - 3| = 5</span><br><span class="line">|3 - 7| = 4</span><br><span class="line">|8 - 1| = 7</span><br><span class="line">|10 - 13| = 3</span><br><span class="line">Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>The number of nodes in the tree is between 2 and 5000.</li>
<li>Each node will have value between 0 and 100000.</li>
</ul>
<p>给一棵树，找到最大值v，这个v是节点和祖先的值的差的绝对值。dfs里一定要有一个最大一个最小，这样才能算出来绝对值最大的一个，之前考虑只放一个值，没有搞定。</p>
<p>一个dfs<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> maxval,<span class="type">int</span> minval)</span></span>&#123;</span><br><span class="line">        val = <span class="built_in">max</span>(val, <span class="built_in">abs</span>(root-&gt;val - maxval));</span><br><span class="line">        val = <span class="built_in">max</span>(val, <span class="built_in">abs</span>(root-&gt;val - minval));</span><br><span class="line">        maxval = <span class="built_in">max</span>(maxval, root-&gt;val);</span><br><span class="line">        minval = <span class="built_in">min</span>(minval, root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) <span class="built_in">dfs</span>(root-&gt;right,maxval,minval);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) <span class="built_in">dfs</span>(root-&gt;left,maxval,minval);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxAncestorDiff</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root,root-&gt;val,root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1027-Longest-Arithmetic-Sequence"><a href="#Leetcode1027-Longest-Arithmetic-Sequence" class="headerlink" title="Leetcode1027. Longest Arithmetic Sequence"></a>Leetcode1027. Longest Arithmetic Sequence</h1><p>Given an array A of integers, return the length of the longest arithmetic subsequence in A.</p>
<p>Recall that a  subsequence  of A is a list A[i_1], A[i_2], …, A[i_k] with 0 &lt;= i_1 &lt; i_2 &lt; … &lt; i_k &lt;= A.length - 1, and that a sequence B is  arithmetic  if B[i+1] - B[i] are all the same value (for 0 &lt;= i &lt; B.length - 1).</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [3,6,9,12]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">The whole array is an arithmetic sequence with steps of length = 3.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [9,4,7,2,10]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">The longest arithmetic subsequence is [4,7,10].</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [20,1,15,3,10,5,8]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">The longest arithmetic subsequence is [20,15,10,5].</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>2 &lt;= A.length &lt;= 1000</li>
<li>0 &lt;= A[i] &lt;= 500</li>
</ul>
<p>这道题给了一个数组，让找最长的等差数列的长度，首先来考虑如何定义 DP 数组，最直接的就是用一个一维数组，其中<code>dp[i]</code>表示区间 [0, i] 中的最长等差数列的长度，但是这样定义的话，很难找出状态转移方程。因为有些隐藏信息被我们忽略了，就是等差数列的相等的差值，不同的等差数列的差值可以是不同的，所以不包括这个信息的话将很难更新 dp 值。所以这里就需要一个二维数组，<code>dp[i][j]</code>表示在区间 [0, i] 中的差值为j的最长等差数列的长度减1，这里减1是因为起始的数字并没有被算进去，不过不要紧，最后再加回来就行了。</p>
<p>还有一个需要注意的地方，由于等差数列的差值有可能是负数，而数组的下标不能是负数，所以需要处理一下，题目中限定了数组中的数字范围为0到 500 之间，所以差值的范围就是 -500 到 500 之间，可以给差值加上个 1000，这样差值范围就是 500 到 1500 了，二维 dp 数组的大小可以初始化为 nx2000。更新 dp 值的时候，先遍历一遍数组，对于每个遍历到的数字，再遍历一遍前面的所有数字，算出差值 diff，再加上 1000，然后此时的<code>dp[i][diff]</code>可以赋值为<code>dp[j][diff]+1</code>，然后用这个新的 dp 值来更新结果 res，最后别忘了 res 加1后返回，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestArithSeqLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = A.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2000</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> diff = A[i] - A[j] + <span class="number">1000</span>;</span><br><span class="line">                dp[i][diff] = dp[j][diff] + <span class="number">1</span>;</span><br><span class="line">                res = <span class="built_in">max</span>(res, dp[i][diff]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1028-Recover-a-Tree-From-Preorder-Traversal"><a href="#Leetcode1028-Recover-a-Tree-From-Preorder-Traversal" class="headerlink" title="Leetcode1028. Recover a Tree From Preorder Traversal"></a>Leetcode1028. Recover a Tree From Preorder Traversal</h1><p>We run a preorder depth-first search (DFS) on the root of a binary tree.</p>
<p>At each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node.  If the depth of a node is D, the depth of its immediate child is D + 1.  The depth of the root node is 0.</p>
<p>If a node has only one child, that child is guaranteed to be the left child.</p>
<p>Given the output traversal of this traversal, recover the tree and return its root.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: traversal = &quot;1-2--3--4-5--6--7&quot;</span><br><span class="line">Output: [1,2,5,3,4,6,7]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: traversal = &quot;1-2--3---4-5--6---7&quot;</span><br><span class="line">Output: [1,2,5,3,null,6,null,4,null,7]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: traversal = &quot;1-401--349---90--88&quot;</span><br><span class="line">Output: [1,401,null,349,88,90]</span><br></pre></td></tr></table></figure></p>
<p>这道题让我们根据一棵二叉树的先序遍历的结果来重建这棵二叉树。这里为了能够只根据先序遍历的结果来唯一的重建出二叉树，提供了每个结点值的深度，用短杠的个数来表示，根结点的深度为0，前方没有短杠，后面的数字前方只有一个短杠的就是根结点的左右子结点，然后紧跟在一个短杠后面的两个短杠的数字就是根结点左子结点的左子结点，以此类推。</p>
<p>遍历输入字符串，先提取短杠的个数，因为除了根结点之外，所有的深度值都是在结点值前面的，所有用一个 for 循环先提取出短杠的个数 level，然后提取结点值，也是用一个 for 循环，因为结点值可能是个多位数，有了结点值之后我们就可以新建一个结点了。下一步就比较 tricky 了，因为先序遍历跟 DFS 搜索一样有一个回到先前位置的过程，比如例子1中，当我们遍历到结点5的时候，此时是从叶结点4回到了根结点的右子结点5，现在栈中有4个结点，而当前深度为1的结点5是要连到根结点的，所以栈中的无关结点就要移除，需要把结点 2，3，4 都移除，就用一个 while 循环，假如栈中元素个数大于当前的深度 level，就移除栈顶元素。那么此时栈中就只剩根结点了，就可以连接了。此时我们的连接策略是，假如栈顶元素的左子结点为空，则连在左子结点上，否则连在右子结点上，因为题目中说了，假如只有一个子结点，一定是左子结点。然后再把当前结点压入栈即可，字符串遍历结束后，栈中只会留有一个结点（题目中限定了树不为空），就是根结点，直接返回即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">recoverFromPreorder</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, level = <span class="number">0</span>, val = <span class="number">0</span>, n = S.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (level = <span class="number">0</span>; i &lt; n &amp;&amp; S[i] == <span class="string">&#x27;-&#x27;</span>; ++i) &#123;</span><br><span class="line">                ++level;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (val = <span class="number">0</span>; i &lt; n &amp;&amp; S[i] != <span class="string">&#x27;-&#x27;</span>; ++i) &#123;</span><br><span class="line">                val = <span class="number">10</span> * val + (S[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">while</span> (st.<span class="built_in">size</span>() &gt; level) st.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">if</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!st.<span class="built_in">back</span>()-&gt;left) st.<span class="built_in">back</span>()-&gt;left = node;</span><br><span class="line">                <span class="keyword">else</span> st.<span class="built_in">back</span>()-&gt;right = node;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push_back</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我自己的方法是根据-的数量得到层数，判断这是到第几层了，如果超过了当前的层数，就说明到底了，返回就行。但是不知道为什么很慢。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(string s, <span class="type">int</span>&amp; cur, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == s.<span class="built_in">length</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> i = cur, len = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len &amp;&amp; i &lt; cur+depth) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != cur+depth)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len)</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                val = val * <span class="number">10</span> + s[i++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        TreeNode* res = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        </span><br><span class="line">        cur = i;</span><br><span class="line">        res-&gt;left = <span class="built_in">dfs</span>(s, cur, depth<span class="number">+1</span>);</span><br><span class="line">        res-&gt;right = <span class="built_in">dfs</span>(s, cur, depth<span class="number">+1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">recoverFromPreorder</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(s, pos, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1029-Two-City-Scheduling"><a href="#Leetcode1029-Two-City-Scheduling" class="headerlink" title="Leetcode1029. Two City Scheduling"></a>Leetcode1029. Two City Scheduling</h1><p>There are 2N people a company is planning to interview. The cost of flying the i-th person to city A is costs[i][0], and the cost of flying the i-th person to city B is costs[i][1].</p>
<p>Return the minimum cost to fly every person to a city such that exactly N people arrive in each city.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[10,20],[30,200],[400,50],[30,20]]</span><br><span class="line">Output: 110</span><br><span class="line">Explanation: </span><br><span class="line">The first person goes to city A for a cost of 10.</span><br><span class="line">The second person goes to city A for a cost of 30.</span><br><span class="line">The third person goes to city B for a cost of 50.</span><br><span class="line">The fourth person goes to city B for a cost of 20.</span><br></pre></td></tr></table></figure><br>The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.</p>
<p>Note:</p>
<ul>
<li>1 &lt;= costs.length &lt;= 100</li>
<li>It is guaranteed that costs.length is even.</li>
<li>1 &lt;= costs[i][0], costs[i][1] &lt;= 1000</li>
</ul>
<p>公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B 市的费用为 costs[i][1]。<br>返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达。</p>
<p>由于人数是偶数个，一半的人去A,一半的人去B，换个角度，每个人要么去A，要么去B。如果他去A比去B的路程短，而且，这个节省的路程比一半的人还多，那么他就去A。所以，以去A和去B的路程差作为Key进行升序排序，前面一半人去A，后面去B。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">comp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;a, vector&lt;<span class="type">int</span>&gt;&amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]-a[<span class="number">1</span>] &lt; b[<span class="number">0</span>]-b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">twoCitySchedCost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(costs.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">sort</span>(costs.<span class="built_in">begin</span>(), costs.<span class="built_in">end</span>(), comp);</span><br><span class="line">        <span class="type">int</span> ii=costs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ii/<span class="number">2</span>;i++)</span><br><span class="line">            result += costs[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;ii;i++)</span><br><span class="line">            result+=costs[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1030-Matrix-Cells-in-Distance-Order"><a href="#Leetcode1030-Matrix-Cells-in-Distance-Order" class="headerlink" title="Leetcode1030. Matrix Cells in Distance Order"></a>Leetcode1030. Matrix Cells in Distance Order</h1><p>We are given a matrix with R rows and C columns has cells with integer coordinates (r, c), where 0 &lt;= r &lt; R and 0 &lt;= c &lt; C.</p>
<p>Additionally, we are given a cell in that matrix with coordinates (r0, c0).</p>
<p>Return the coordinates of all cells in the matrix, sorted by their distance from (r0, c0) from smallest distance to largest distance.  Here, the distance between two cells (r1, c1) and (r2, c2) is the Manhattan distance, |r1 - r2| + |c1 - c2|.  (You may return the answer in any order that satisfies this condition.)</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: R = 1, C = 2, r0 = 0, c0 = 0</span><br><span class="line">Output: [[0,0],[0,1]]</span><br><span class="line">Explanation: The distances from (r0, c0) to other cells are: [0,1]</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: R = 2, C = 2, r0 = 0, c0 = 1</span><br><span class="line">Output: [[0,1],[0,0],[1,1],[1,0]]</span><br><span class="line">Explanation: The distances from (r0, c0) to other cells are: [0,1,1,2]</span><br><span class="line">The answer [[0,1],[1,1],[0,0],[1,0]] would also be accepted as correct.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: R = 2, C = 3, r0 = 1, c0 = 2</span><br><span class="line">Output: [[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]</span><br><span class="line">Explanation: The distances from (r0, c0) to other cells are: [0,1,1,2,2,3]</span><br><span class="line">There are other answers that would also be accepted as correct, such as [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]].</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= R &lt;= 100</li>
<li>1 &lt;= C &lt;= 100</li>
<li>0 &lt;= r0 &lt; R</li>
<li>0 &lt;= c0 &lt; C</li>
</ul>
<p>根据与给定的点的顺序排序。</p>
<p>看到一种比较辣鸡的做法，就是先把所有点都加进去，再排序，顺便学习了一个新的写法，如下的lambda表达式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">allCellsDistOrder</span>(<span class="type">int</span> R, <span class="type">int</span> C, <span class="type">int</span> r0, <span class="type">int</span> c0) &#123;</span><br><span class="line">        <span class="keyword">auto</span> comp = [r0,c0](vector&lt;<span class="type">int</span>&gt; &amp;a, vector&lt;<span class="type">int</span>&gt; &amp;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(a[<span class="number">0</span>]-r0) + <span class="built_in">abs</span>(a[<span class="number">1</span>]-c0) &lt; <span class="built_in">abs</span>(b[<span class="number">0</span>]-r0) + <span class="built_in">abs</span>(b[<span class="number">1</span>]-c0);</span><br><span class="line">        &#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;R;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;C;j++)</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;i,j&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>(),comp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>用bfs做也行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">allCellsDistOrder</span>(<span class="type">int</span> R, <span class="type">int</span> C, <span class="type">int</span> r0, <span class="type">int</span> c0) &#123;</span><br><span class="line">        <span class="type">int</span> visit[R][C];</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*R*C);</span><br><span class="line">        <span class="type">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        queue&lt; pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; qu;</span><br><span class="line">        vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">        qu.<span class="built_in">push</span>(&#123;r0,c0&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            pair&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; temp = qu.<span class="built_in">front</span>();</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> x = temp.first;</span><br><span class="line">            <span class="type">int</span> y = temp.second;</span><br><span class="line">            <span class="keyword">if</span>(visit[x][y]==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;x,y&#125;);</span><br><span class="line">            visit[x][y]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="type">int</span> xx = x + direction[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> yy = y + direction[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> ( xx&gt;= <span class="number">0</span> &amp;&amp; xx &lt; R &amp;&amp; yy &gt;=<span class="number">0</span> &amp;&amp; yy &lt; C &amp;&amp; visit[xx][yy] == <span class="number">0</span>)&#123;</span><br><span class="line">                     qu.<span class="built_in">push</span>(&#123;xx,yy&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>更新一种做法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">comp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">allCellsDistOrder</span>(<span class="type">int</span> R, <span class="type">int</span> C, <span class="type">int</span> r0, <span class="type">int</span> c0) &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(R*C, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; R; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; C; j ++) &#123;</span><br><span class="line">                v[k][<span class="number">0</span>] = i;</span><br><span class="line">                v[k][<span class="number">1</span>] = j;</span><br><span class="line">                v[k][<span class="number">2</span>] = <span class="built_in">abs</span>(i - r0) + <span class="built_in">abs</span>(j - c0);</span><br><span class="line">                k ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), comp);</span><br><span class="line">	        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> kk = <span class="number">0</span>; kk &lt; R*C; kk ++) &#123;</span><br><span class="line">            v[kk].<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1031-Maximum-Sum-of-Two-Non-Overlapping-Subarrays"><a href="#Leetcode1031-Maximum-Sum-of-Two-Non-Overlapping-Subarrays" class="headerlink" title="Leetcode1031. Maximum Sum of Two Non-Overlapping Subarrays"></a>Leetcode1031. Maximum Sum of Two Non-Overlapping Subarrays</h1><p>Given an integer array nums and two integers firstLen and secondLen, return the maximum sum of elements in two non-overlapping subarrays with lengths firstLen and secondLen.</p>
<p>The array with length firstLen could occur before or after the array with length secondLen, but they have to be non-overlapping.</p>
<p>A subarray is a contiguous part of an array.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [0,6,5,2,2,5,1,9,4], firstLen = 1, secondLen = 2</span><br><span class="line">Output: 20</span><br><span class="line">Explanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [3,8,1,3,2,1,8,9,0], firstLen = 3, secondLen = 2</span><br><span class="line">Output: 29</span><br><span class="line">Explanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,1,5,6,0,9,5,0,3,8], firstLen = 4, secondLen = 3</span><br><span class="line">Output: 31</span><br><span class="line">Explanation: One choice of subarrays is [5,6,0,9] with length 4, and [3,8] with length 3.</span><br></pre></td></tr></table></figure></p>
<p>题意：给你一个数组，再给你一个L，M，求在这个数组里面，两个不重合的长度分别为L，M的最的最大和。</p>
<p>思路：先预处理一个<code>dp[i][2]</code>，<code>dp[i][0]</code>表示以i为开头，长度为L的值；<code>dp[i][1]</code>表示以i为开头，长度为M的值。再两层for，遍历i，j分别表示两个数组的头，只要两个数组不重合，就是合适的数组。最后求个最大值就好了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSumTwoNoOverlap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; l &amp;&amp; i+j &lt; n; j ++)</span><br><span class="line">                dp[i][<span class="number">0</span>] += nums[i+j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m &amp;&amp; i+j &lt; n; j ++)</span><br><span class="line">                dp[i][<span class="number">1</span>] += nums[i+j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + l &lt;= j)</span><br><span class="line">                    res = <span class="built_in">max</span>(res, dp[i][<span class="number">0</span>]+dp[j][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (j + m &lt;= i)</span><br><span class="line">                    res = <span class="built_in">max</span>(res, dp[i][<span class="number">0</span>]+dp[j][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这道题给了一个非负数组A，还有两个长度L和M，说是要分别找出不重叠且长度分别为L和M的两个子数组，前后顺序无所谓，问两个子数组最大的数字之和是多少。来看论坛上的高分解法吧，首先建立累加和数组，这里可以直接覆盖A数组，然后定义<code>Lmax</code>为在最后M个数字之前的长度为L的子数组的最大数字之和，同理，<code>Mmax</code>表示在最后L个数字之前的长度为M的子数组的最大数字之和。结果<code>res</code>初始化为前 L+M 个数字之和，然后遍历数组，从 L+M 开始遍历，先更新<code>Lmax</code>和<code>Mmax</code>，其中<code>Lmax</code>用<code>A[i - M] - A[i - M - L]</code>来更新，<code>Mmax</code>用<code>A[i - L] - A[i - M - L]</code>来更新。然后取<code>Lmax + A[i] - A[i - M]</code>和<code>Mmax + A[i] - A[i - L]</code>之间的较大值来更新结果 res 即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSumTwoNoOverlap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> L, <span class="type">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            A[i] += A[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = A[L + M - <span class="number">1</span>], Lmax = A[L - <span class="number">1</span>], Mmax = A[M - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = L + M; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Lmax = <span class="built_in">max</span>(Lmax, A[i - M] - A[i - M - L]);</span><br><span class="line">            Mmax = <span class="built_in">max</span>(Mmax, A[i - L] - A[i - M - L]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(Lmax + A[i] - A[i - M], Mmax + A[i] - A[i - L]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1033-Moving-Stones-Until-Consecutive"><a href="#Leetcode1033-Moving-Stones-Until-Consecutive" class="headerlink" title="Leetcode1033. Moving Stones Until Consecutive"></a>Leetcode1033. Moving Stones Until Consecutive</h1><p>Three stones are on a number line at positions a, b, and c. Each turn, you pick up a stone at an endpoint (ie., either the lowest or highest position stone), and move it to an unoccupied position between those endpoints.  Formally, let’s say the stones are currently at positions x, y, z with x &lt; y &lt; z.  You pick up the stone at either position x or position z, and move that stone to an integer position k, with x &lt; k &lt; z and k != y. The game ends when you cannot make any more moves, ie. the stones are in consecutive positions.</p>
<p>When the game ends, what is the minimum and maximum number of moves that you could have made?  Return the answer as an length 2 array: answer = [minimum_moves, maximum_moves]</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: a = 1, b = 2, c = 5</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: Move the stone from 5 to 3, or move the stone from 5 to 4 to 3.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: a = 4, b = 3, c = 2</span><br><span class="line">Output: [0,0]</span><br><span class="line">Explanation: We cannot make any moves.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: a = 3, b = 5, c = 1</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: Move the stone from 1 to 4; or move the stone from 1 to 2 to 4.</span><br></pre></td></tr></table></figure><br>a,b,c表示三个位置，在三个位置上各有一个石头。现在要移动三个石头中的若干个，每次移动都必须选两端石头的里面的位置，最终使得它们三个放在连续的位置。问最少需要多少次移动，最多需要多少次移动。</p>
<p>如果三个石头本来就连续，则不用移动。例：1，2，3</p>
<p>如果三个石头本来不连续，则：<br>最少移动次数：</p>
<ol>
<li>有两个石头之间的距离小于等于2，则最少只需要一次移动。例：1，2，4，把4移动到3即可；或者例1，3，5，把5移到2即可。</li>
<li>所有石头之间的最小距离&gt;2，则最少需要移动两个石头。例：1，4，7，需要把两个石头移动到另一个的旁边。</li>
</ol>
<p>最多移动次数：<br>题目说了，只能像两端石头里面的那些位置上放，所以最多移动的次数就是本来两端石头中间包含的点（并且去掉中间的石头），策略是每次向内移动一步。例：1，3，5，在1和5中间之间共有2个可以放的点（分别为2，4），所以最多只能有max_ - min_ - 2次移动。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">numMovesStones</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum_ = a + b + c;</span><br><span class="line">        <span class="type">int</span> min_ = <span class="built_in">min</span>(a, <span class="built_in">min</span>(b, c));</span><br><span class="line">        <span class="type">int</span> max_ = <span class="built_in">max</span>(a, <span class="built_in">max</span>(b, c));</span><br><span class="line">        <span class="type">int</span> mid_ = sum_ - min_ - max_;</span><br><span class="line">	        </span><br><span class="line">        <span class="keyword">if</span> (max_ - min_ == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">	        </span><br><span class="line">        <span class="type">int</span> min_move = <span class="built_in">min</span>(mid_ - min_, max_ - mid_) &lt;= <span class="number">2</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> max_move = max_ - min_ - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;min_move, max_move&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1034-Coloring-A-Border"><a href="#Leetcode1034-Coloring-A-Border" class="headerlink" title="Leetcode1034. Coloring A Border"></a>Leetcode1034. Coloring A Border</h1><p>Given a 2-dimensional grid of integers, each value in the grid represents the color of the grid square at that location.</p>
<p>Two squares belong to the same  connected component  if and only if they have the same color and are next to each other in any of the 4 directions.</p>
<p>The  border  of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).</p>
<p>Given a square at location (r0, c0) in the grid and a color, color the border of the connected component of that square with the given color, and return the final grid.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[1,1],[1,2]], r0 = 0, c0 = 0, color = 3</span><br><span class="line">Output: [[3, 3], [3, 2]]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[1,2,2],[2,3,2]], r0 = 0, c0 = 1, color = 3</span><br><span class="line">Output: [[1, 3, 3], [2, 3, 3]]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[1,1,1],[1,1,1],[1,1,1]], r0 = 1, c0 = 1, color = 2</span><br><span class="line">Output: [[2, 2, 2], [2, 1, 2], [2, 2, 2]]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= grid.length &lt;= 50</li>
<li>1 &lt;= grid[0].length &lt;= 50</li>
<li>1 &lt;= grid[i][j] &lt;= 1000</li>
<li>0 &lt;= r0 &lt; grid.length</li>
<li>0 &lt;= c0 &lt; grid[0].length</li>
<li>1 &lt;= color &lt;= 1000</li>
</ul>
<p>这道题给了一个二维数组 grid，和一个起始位置 (r0, c0)，格子里的数字代表不同的颜色，又给了一个新的颜色 color，现在让给起始位置所在的连通区域的边缘填充这种新的颜色。这道题的难点就是如何找出连通区域的边缘，找连通区域并不难，因为有了起始点，可以用 DFS 或者 BFS 来找出所有相连的位置，而边缘位置需要进一步判断，一种情况是当前位置是二维矩阵的边缘，那么其一定也是连通区域的边缘，另一种情况是若四个相邻位置有其他的颜色，则当前位置也一定是边缘。下面先来看 BFS 的解法，主体还是经典的 BFS 写法不变，使用队列 queue，和一个 TreeSet 来记录已经遍历过的位置。将起始位置先放入 queue 和 visited 集合，然后进行 while 循环，取出队首元素，然后判断当前位置是否是二维数组的边缘，是的话直接将颜色更新 color。然后遍历周围四个位置，若越界了或者访问过了直接跳过，然后看若颜色和起始位置的颜色相同，则加入 visited 和 queue，否则将当前位置的颜色更新为 color，因为周围有不同的颜色了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">colorBorder</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> color) &#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>(), ori_color = grid[row][col];</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dirs&#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;  ;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(row*n + col);</span><br><span class="line">        visited[row][col] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> x = q.<span class="built_in">front</span>() / n;</span><br><span class="line">            <span class="type">int</span> y = q.<span class="built_in">front</span>() % n;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span> || x == m<span class="number">-1</span> || y == <span class="number">0</span> || y == n<span class="number">-1</span>)</span><br><span class="line">                grid[x][y] = color;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">                <span class="type">int</span> xx = x + dirs[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> yy = y + dirs[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || xx &gt;= m || yy &lt; <span class="number">0</span> || yy &gt;= n || visited[xx][yy] == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (grid[xx][yy] == ori_color) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(xx * n + yy);</span><br><span class="line">                    visited[xx][yy] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    grid[x][y] = color;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1035-Uncrossed-Lines"><a href="#Leetcode1035-Uncrossed-Lines" class="headerlink" title="Leetcode1035. Uncrossed Lines"></a>Leetcode1035. Uncrossed Lines</h1><p>We write the integers of A and B (in the order they are given) on two separate horizontal lines.</p>
<p>Now, we may draw  connecting lines : a straight line connecting two numbers A[i] and B[j] such that:<code>A[i] == B[j];</code></p>
<p>The line we draw does not intersect any other connecting (non-horizontal) line.</p>
<p>Note that a connecting lines cannot intersect even at the endpoints: each number can only belong to one connecting line.</p>
<p>Return the maximum number of connecting lines we can draw in this way.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,4,2], B = [1,2,4]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We can draw 2 uncrossed lines as in the diagram.</span><br><span class="line">We cannot draw 3 uncrossed lines, because the line from A[1]=4 to B[2]=4 will intersect the line from A[2]=2 to B[1]=2.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2,5,1,2,5], B = [10,5,2,1,5,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,3,7,1,7,5], B = [1,9,2,5,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 500</li>
<li>1 &lt;= B.length &lt;= 500</li>
<li>1 &lt;= A[i], B[i] &lt;= 2000</li>
</ul>
<p>这道题给了A和B两个数字数组，并且上下并列排放，说是可以用线来连接相同的数字，问最多能连多少根线而且不会发生重叠。首先来想一下，什么情况下两条连线会相交，可以观察下例子1给的图，发现若把4和2分别连上会交叉，这是因为在A数组中是 4，2，而且在B数组中是 2，4，顺序不一样。再来看例子2，分别连 5，1，2 或者 2，1，2，或者 5，2，5 都是可以的，仔细观察，可以发现这些其实就是最长公共子序列 Longest Common Subsequence。使用一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示数组A的前i个数字和数组B的前j个数字的最长相同的子序列的数字个数，这里大小初始化为 (m+1)x(n+1)，这里的m和n分别是数组A和数组B的长度。接下来就要找状态转移方程了，如何来更新<code>dp[i][j]</code>，若二者对应位置的字符相同，表示当前的 LCS 又增加了一位，所以可以用<code>dp[i-1][j-1] + 1</code>来更新<code>dp[i][j]</code>。否则若对应位置的字符不相同，由于是子序列，还可以错位比较，可以分别从数组A或者数组B去掉一个当前数字，那么其<code>dp</code>值就是<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>，取二者中的较大值来更新<code>dp[i][j]</code>即可，最终的结果保存在了<code>dp[m][n]</code>中，参见代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxUncrossedLines</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; B)</span> &#123;</span><br><span class="line">        <span class="type">int</span> m = A.size(), n = B.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1037-Valid-Boomerang"><a href="#Leetcode1037-Valid-Boomerang" class="headerlink" title="Leetcode1037. Valid Boomerang"></a>Leetcode1037. Valid Boomerang</h1><p>A boomerang is a set of 3 points that are all distinct and not in a straight line. Given a list of three points in the plane, return whether these points are a boomerang.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1],[2,3],[3,2]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1],[2,2],[3,3]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>points.length == 3<br>points[i].length == 2<br>0 &lt;=<code>points[i][j]</code>&lt;= 100</p>
<p>判断三个点是不是互异且不共线的，简单<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBoomerang</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;points.<span class="built_in">size</span>();j++)</span><br><span class="line">                <span class="keyword">if</span>(points[i][<span class="number">0</span>]==points[j][<span class="number">0</span>] &amp;&amp; points[i][<span class="number">1</span>]==points[j][<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> dx1 = points[<span class="number">1</span>][<span class="number">0</span>] - points[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> dx2 = points[<span class="number">1</span>][<span class="number">1</span>] - points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> dx3 = points[<span class="number">2</span>][<span class="number">0</span>] - points[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> dx4 = points[<span class="number">2</span>][<span class="number">1</span>] - points[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(dx1*dx4-dx2*dx3==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1038-Binary-Search-Tree-to-Greater-Sum-Tree"><a href="#Leetcode1038-Binary-Search-Tree-to-Greater-Sum-Tree" class="headerlink" title="Leetcode1038. Binary Search Tree to Greater Sum Tree"></a>Leetcode1038. Binary Search Tree to Greater Sum Tree</h1><p>Given the root of a binary search tree with distinct values, modify it so that every node has a new value equal to the sum of the values of the original tree that are greater than or equal to node.val.</p>
<p>As a reminder, a binary search tree is a tree that satisfies these constraints:</p>
<p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p>
<p>Example 1:</p>
<p><img src="/img/20190506tree.png" alt=""></p>
<p>Input: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</p>
<p>典型的中序遍历，先遍历右子树，再把root赋值，最后看左子树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">houxu</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            <span class="built_in">houxu</span>(root-&gt;right);</span><br><span class="line">        sum+=root-&gt;val;</span><br><span class="line">        root-&gt;val = sum;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            <span class="built_in">houxu</span>(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstToGst</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">houxu</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1039-Minimum-Score-Triangulation-of-Polygon"><a href="#Leetcode1039-Minimum-Score-Triangulation-of-Polygon" class="headerlink" title="Leetcode1039. Minimum Score Triangulation of Polygon"></a>Leetcode1039. Minimum Score Triangulation of Polygon</h1><p>You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex (i.e., clockwise order).</p>
<p>You will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all n - 2 triangles in the triangulation.</p>
<p>Return  the smallest possible total score that you can achieve with some triangulation of the polygon.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: values = [1,2,3]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The polygon is already triangulated, and the score of the only triangle is 6.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: values = [3,7,4,5]</span><br><span class="line">Output: 144</span><br><span class="line">Explanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.</span><br><span class="line">The minimum score is 144.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: values = [1,3,1,4,1,5]</span><br><span class="line">Output: 13</span><br><span class="line">Explanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>n == values.length</li>
<li>3 &lt;= n &lt;= 50</li>
<li>1 &lt;= values[i] &lt;= 100</li>
</ul>
<p>这道题说有一个N边形，让我们连接不相邻的顶点，从而划分出三角形，最多可以划分出 N-2 个三角形，每划分出一个三角形，得分是三个顶点的乘积，问最小的得分是多少。首先要来定义 DP 数组，这里一维数组肯定是不够用的，因为需要保存区间信息，所以这里用个二维数组，其中<code>dp[i][j]</code>表示从顶点i到顶点j为三角形的一条边，可以组成的所有的三角形的最小得分。接下来推导状态转移方程，由于三角形的一条边已经确定了，接下来就要找另一个顶点的位置，这里需要遍历所有的情况，使用一个变量k，遍历区间 (i, j) 中的所有的顶点，由顶点i，j，和k组成的三角形的得分是<code>A[i] * A[k] * A[j]</code>可以直接算出来，这个三角形将整个区间分割成了两部分，分别是 (i, k) 和 (k, j)，这两个区间的最小得分值可以直接从 dp 数组中取得，分别是<code>dp[i][k]</code>和<code>dp[k][j]</code>，这样状态转移方程就有了，用<code>dp[i][k] + A[i] * A[k] * A[j] + dp[k][j]</code>来更新<code>dp[i][j]</code>，为了防止整型越界，不能直接将 dp 数组都初始化为整型最大值<code>INT_MAX</code>，而是在更新的时候，判断若<code>dp[i][j]</code>为0时，用<code>INT_MAX</code>，否则用其本身值，最终的结果保存在<code>dp[0][n-1]</code>中，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minScoreTriangulation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j] == <span class="number">0</span> ? INT_MAX : dp[i][j], dp[i][k] + A[i] * A[k] * A[j] + dp[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再来看一种同样的 DP 解法，和上面的区别是 dp 数组更新的顺序不同，之前说过了更新大区间的 dp 值需要用到小区间的 dp 值，这里是按照区间的大小来更新的，从2更新到n，然后确定区间 (i, j) 的大小为 len，再遍历中间所有的k，状态转移方程还是跟上面一样的。这种更新方法在其他的题目也有用到，最典型的就是那道 Burst Balloons，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minScoreTriangulation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt; n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + len &lt; n; ++i) &#123;</span><br><span class="line">                <span class="type">int</span> j = i + len;</span><br><span class="line">                dp[i][j] = INT_MAX;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + A[i] * A[k] * A[j] + dp[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1041-Robot-Bounded-In-Circle"><a href="#Leetcode1041-Robot-Bounded-In-Circle" class="headerlink" title="Leetcode1041. Robot Bounded In Circle"></a>Leetcode1041. Robot Bounded In Circle</h1><p>On an infinite plane, a robot initially stands at (0, 0) and faces north. The robot can receive one of three instructions:</p>
<ul>
<li>“G”: go straight 1 unit;</li>
<li>“L”: turn 90 degrees to the left;</li>
<li>“R”: turn 90 degrees to the right.</li>
</ul>
<p>The robot performs the instructions given in order, and repeats them forever.</p>
<p>Return true if and only if there exists a circle in the plane such that the robot never leaves the circle.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: instructions = &quot;GGLLGG&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The robot moves from (0,0) to (0,2), turns 180 degrees, and then returns to (0,0).</span><br><span class="line">When repeating these instructions, the robot remains in the circle of radius 2 centered at the origin.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: instructions = &quot;GG&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The robot moves north indefinitely.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: instructions = &quot;GL&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The robot moves from (0, 0) -&gt; (0, 1) -&gt; (-1, 1) -&gt; (-1, 0) -&gt; (0, 0) -&gt; ...</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= instructions.length &lt;= 100</li>
<li>instructions[i] is ‘G’, ‘L’ or, ‘R’.</li>
</ul>
<p>这道题说是在一个无限大的区域，有个机器人初始化站在原点 (0, 0) 的位置，面朝北方。该机器人有三种指令可以执行，G表示朝当前方向前进一步，L表示向左转 90 度，R表示向右转 90 度，现在给了一些连续的这样的指令，若一直重复的按顺序循环执行下去，问机器人是否会在一个固定的圆圈路径中循环。首先我们需要执行一遍所有的指令，然后根据最后的状态（包括位置和朝向）来分析机器人是否之后会一直走循环路线。若执行过一遍所有指令之后机器人还在原点上，则一定是在一个圆圈路径上（即便是机器人可能就没移动过，一个点也可以看作是圆圈路径）。若机器人偏离了起始位置，只要看此时机器人的朝向，只要不是向北，则其最终一定会回到起点。</p>
<p>知道了最终状态和循环路径的关系，现在就是如何执行这些指令了。也不难，用一个变量表示当前的方向，0表示北，1为东，2为南，3为西，按这个顺序写出偏移量数组 dirs，就是在迷宫遍历的时候经常用到的那个数组。然后记录当前位置 cur，初始化为 (0, 0)，然后就可以执行指令了，若遇到G指令，根据 idx 从 dirs 数组中取出偏移量加到 cur 上即可。若遇到L指令，idx 是要减1的，为了避免负数，先加上个4，再减1，再对4取余。同理，若遇到R指令，idx 加1之后对4取余。最后判断若还在原点，或者朝向不为北的时候，返回 true 即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isRobotBounded</span><span class="params">(string instructions)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dirs&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> xx = <span class="number">0</span>, yy = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> direction = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; instructions.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instructions[i] == <span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">                xx += dirs[direction][<span class="number">0</span>];</span><br><span class="line">                yy += dirs[direction][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (instructions[i] == <span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">                direction = (direction + <span class="number">1</span> ) % <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (instructions[i] == <span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">                direction = (direction + <span class="number">4</span> - <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (xx == <span class="number">0</span> &amp;&amp; yy == <span class="number">0</span>) || direction != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1042-Flower-Planting-With-No-Adjacent"><a href="#Leetcode1042-Flower-Planting-With-No-Adjacent" class="headerlink" title="Leetcode1042. Flower Planting With No Adjacent"></a>Leetcode1042. Flower Planting With No Adjacent</h1><p>You have N gardens, labelled 1 to N.  In each garden, you want to plant one of 4 types of flowers. paths[i] = [x, y] describes the existence of a bidirectional path from garden x to garden y. Also, there is no garden that has more than 3 paths coming into or leaving it.</p>
<p>Your task is to choose a flower type for each garden such that, for any two gardens connected by a path, they have different types of flowers.</p>
<p>Return any such a choice as an array answer, where answer[i] is the type of flower planted in the (i+1)-th garden.  The flower types are denoted 1, 2, 3, or 4.  It is guaranteed an answer exists.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, paths = [[1,2],[2,3],[3,1]]</span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 4, paths = [[1,2],[3,4]]</span><br><span class="line">Output: [1,2,1,2]</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]</span><br><span class="line">Output: [1,2,3,4]</span><br></pre></td></tr></table></figure><br>Note:</p>
<ul>
<li>1 &lt;= N &lt;= 10000</li>
<li>0 &lt;= paths.size &lt;= 20000</li>
<li>No garden has 4 or more paths coming into or leaving it.</li>
<li>It is guaranteed an answer exists.</li>
</ul>
<p>有 N 个花园，按从 1 到 N 标记。在每个花园中，你打算种下四种花之一。 paths[i] = [x, y] 描述了花园 x 到花园 y 的双向路径。另外，没有花园有 3 条以上的路径可以进入或者离开。你需要为每个花园选择一种花，使得通过路径相连的任何两个花园中的花的种类互不相同。以数组形式返回选择的方案作为答案 answer，其中 answer[i] 为在第 (i+1) 个花园中种植的花的种类。花的种类用  1, 2, 3, 4 表示。保证存在答案。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">gardenNoAdj</span><span class="params">(<span class="type">int</span> N, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(N, <span class="number">0</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; paths.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            graph[paths[i][<span class="number">0</span>]<span class="number">-1</span>].<span class="built_in">push_back</span>(paths[i][<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">            graph[paths[i][<span class="number">1</span>]<span class="number">-1</span>].<span class="built_in">push_back</span>(paths[i][<span class="number">0</span>]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;      </span><br><span class="line">            <span class="type">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; j : graph[i])</span><br><span class="line">                mask |= (<span class="number">1</span> &lt;&lt; res[j]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= <span class="number">4</span> &amp;&amp; res[i] == <span class="number">0</span>; ++c)</span><br><span class="line">                <span class="keyword">if</span> (!(mask &amp; (<span class="number">1</span> &lt;&lt; c))) res[i] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1043-Partition-Array-for-Maximum-Sum"><a href="#Leetcode1043-Partition-Array-for-Maximum-Sum" class="headerlink" title="Leetcode1043. Partition Array for Maximum Sum"></a>Leetcode1043. Partition Array for Maximum Sum</h1><p>Given an integer array arr, you should partition the array into (contiguous) subarrays of length at most k. After partitioning, each subarray has their values changed to become the maximum value of that subarray.</p>
<p>Return  the largest sum of the given array after partitioning.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,15,7,9,2,5,10], k = 3</span><br><span class="line">Output: 84</span><br><span class="line">Explanation: arr becomes [15,15,15,9,10,10,10]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4</span><br><span class="line">Output: 83</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1], k = 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= arr.length &lt;= 500</li>
<li>0 &lt;= arr[i] &lt;= 109</li>
<li>1 &lt;= k &lt;= arr.length</li>
</ul>
<p>这道题给了一个数组 arr，和一个正整数k，说是将数组分成若干个长度不超过k的子数组，分割后的子数组所有的数字都变成该子数组中的最大值，让求分割后的所有子数组数字之和。由于分割的子数组长度不固定，用暴力搜索的话将会有很多很多种情况，不出意外的话会超时。对于这种玩子数组，又是求极值的题，刷题老司机们应该立马就能想到用动态规划 Dynamic Programming 来做。先来定义 dp 数组，先从最简单的考虑，使用一个一维的 dp 数组，其中<code>dp[i]</code>就表示分割数组中的前i个数字组成的数组可以得到的最大的数字之和。下面来考虑状态转移方程怎么求，对于<code>dp[i]</code>来说，若把最后k个数字分割出来，那么前i个数字就被分成了两个部分，前 i-k 个数字，其数字之和可以直接由<code>dp[i-k]</code>来取得，后面的k个数字，则需要求出其中最大的数字，然后乘以k，用这两部分之和来更新<code>dp[i]</code>即可。由于题目中说了分割的长度不超过k，那么就是说小于k的也是可以的，则需要遍历 [1, k] 区间所有的长度，均进行分割。接下来看代码，建立一个大小为 n+1 的 dp 数组，然后i从1遍历到n，此时新建一个变量 curMax 记录当前的最大值，然后用j从1遍历到k，同时要保证 i-j 是大于等于0的，因为需要前半部分存在，实际上这是从第i个数字开始往前找j个数字，然后记录其中最大的数字 curMax，并且不断用<code>dp[i-j] + curMax * j</code>来更新<code>dp[i]</code>即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> curMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k &amp;&amp; i - j &gt;= <span class="number">0</span>; ++j) &#123;</span><br><span class="line">                curMax = <span class="built_in">max</span>(curMax, arr[i - j]);</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[i - j] + curMax * j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1046-Last-Stone-Weight"><a href="#Leetcode1046-Last-Stone-Weight" class="headerlink" title="Leetcode1046. Last Stone Weight"></a>Leetcode1046. Last Stone Weight</h1><p>We have a collection of stones, each stone has a positive integer weight.</p>
<p>Each turn, we choose the two heaviest stones and smash them together.  Suppose the stones have weights x and y with x &lt;= y.  The result of this smash is:</p>
<ul>
<li>If x == y, both stones are totally destroyed;</li>
<li>If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.</li>
<li>At the end, there is at most 1 stone left.  Return the weight of this stone (or 0 if there are no stones left.)</li>
</ul>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,7,4,1,8,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,</span><br><span class="line">we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,</span><br><span class="line">we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,</span><br><span class="line">we combine 1 and 1 to get 0 so the array converts to [1] then that&#x27;s the value of last stone.</span><br></pre></td></tr></table></figure></p>
<p>堆排序解法，主要是看看人家的堆排序怎么写。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeight</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p, q;</span><br><span class="line">        <span class="keyword">if</span>(stones.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> stones[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(stones.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">heapsort</span>(stones);</span><br><span class="line">            p = stones.<span class="built_in">back</span>(); stones.<span class="built_in">pop_back</span>();</span><br><span class="line">            q = stones.<span class="built_in">back</span>(); stones.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="type">int</span> diff = p - q;</span><br><span class="line">            <span class="keyword">if</span>(diff)    stones.<span class="built_in">push_back</span>(diff);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stones.<span class="built_in">empty</span>())   </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> stones[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">heapsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stones.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)  <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">build_heap</span>(stones);</span><br><span class="line">        <span class="type">int</span> heap_size = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(heap_size &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(stones[<span class="number">0</span>], stones[heap_size - <span class="number">1</span>]);</span><br><span class="line">            heap_size --;</span><br><span class="line">            <span class="built_in">max_heapify</span>(stones, <span class="number">0</span>, heap_size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build_heap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=stones.<span class="built_in">size</span>()/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="built_in">max_heapify</span>(stones, i, stones.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">max_heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones, <span class="type">int</span> i, <span class="type">int</span> heap_size)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> large = i;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*i<span class="number">+1</span>&lt;heap_size &amp;&amp; stones[i]&lt;stones[<span class="number">2</span>*i<span class="number">+1</span>])  large = <span class="number">2</span>*i<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*i<span class="number">+2</span>&lt;heap_size &amp;&amp; stones[large]&lt;stones[<span class="number">2</span>*i<span class="number">+2</span>])  large = <span class="number">2</span>*i<span class="number">+2</span>;</span><br><span class="line">        <span class="keyword">if</span>(large != i)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(stones[i], stones[large]);</span><br><span class="line">            <span class="built_in">max_heapify</span>(stones, large, heap_size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        temp = a; a = b; b = temp;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1047-Remove-All-Adjacent-Duplicates-In-String"><a href="#Leetcode1047-Remove-All-Adjacent-Duplicates-In-String" class="headerlink" title="Leetcode1047. Remove All Adjacent Duplicates In String"></a>Leetcode1047. Remove All Adjacent Duplicates In String</h1><p>Given a string S of lowercase letters, a duplicate removal consists of choosing two adjacent and equal letters, and removing them.</p>
<p>We repeatedly make duplicate removals on S until we no longer can.</p>
<p>Return the final string after all such duplicate removals have been made.  It is guaranteed the answer is unique.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abbaca&quot;</span><br><span class="line">Output: &quot;ca&quot;</span><br><span class="line">Explanation: </span><br><span class="line">For example, in &quot;abbaca&quot; we could remove &quot;bb&quot; since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is &quot;aaca&quot;, of which only &quot;aa&quot; is possible, so the final string is &quot;ca&quot;.</span><br></pre></td></tr></table></figure><br>Note:</p>
<ul>
<li>1 &lt;= S.length &lt;= 20000</li>
<li>S consists only of English lowercase letters.</li>
</ul>
<p>借用了栈的思想，但是这么做会超内存。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">removeDuplicates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=S.<span class="built_in">length</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>()==S[i])&#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                st.<span class="built_in">push</span>(S[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res = res + st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>借鉴了大佬的做法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">removeDuplicates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">    string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span>&amp; c : S)</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">size</span>() &amp;&amp; c == res.<span class="built_in">back</span>())</span><br><span class="line">            res.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(c);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        string a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : S) </span><br><span class="line">            <span class="keyword">if</span> (a.<span class="built_in">size</span>() &amp;&amp; a.<span class="built_in">back</span>() == c) a.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">else</span> a.<span class="built_in">push_back</span>(c);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里a.size()是返回字符数量，a.back()返回最后一个字符，pop_back和push_back和vector一样了。</p>
<p>把我自己的超时的代码改了一下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> S_len = S.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;S_len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( len&gt;<span class="number">0</span> &amp;&amp; res[len<span class="number">-1</span>]==S[i])&#123;</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res += S[i];</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1048-Longest-String-Chain"><a href="#Leetcode1048-Longest-String-Chain" class="headerlink" title="Leetcode1048. Longest String Chain"></a>Leetcode1048. Longest String Chain</h1><p>Given a list of words, each word consists of English lowercase letters.</p>
<p>Let’s say word1 is a predecessor of word2 if and only if we can add exactly one letter anywhere in word1 to make it equal to word2.  For example, “abc” is a predecessor of “abac”.</p>
<p>A <em>word chain </em>is a sequence of words [word_1, word_2, …, word_k] with k &gt;= 1, where word_1 is a predecessor of word_2, word_2 is a predecessor of word_3, and so on.</p>
<p>Return the longest possible length of a word chain with words chosen from the given list of words.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: One of the longest word chain is &quot;a&quot;,&quot;ba&quot;,&quot;bda&quot;,&quot;bdca&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;xbc&quot;,&quot;pcxbcf&quot;,&quot;xb&quot;,&quot;cxbc&quot;,&quot;pcxbc&quot;]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= words.length &lt;= 1000</li>
<li>1 &lt;= words[i].length &lt;= 16</li>
<li>words[i] only consists of English lowercase letters.</li>
</ul>
<p>这道题给了一个单词数组，定义了一种前任关系，说是假如在 word1 中任意位置加上一个字符，能变成 word2 的话，那么 word1 就是 word2 的前任，实际上 word1 就是 word2 的一个子序列。现在问在整个数组中最长的前任链有多长，暴力搜索的话会有很多种情况，会产生大量的重复计算，所以会超时。这种玩数组求极值的题十有八九都是用动态规划 Dynamic Programming 来做的，这道题其实跟之前那道 Longest Arithmetic Subsequence 求最长的等差数列的思路是很像的。首先来定义 dp 数组，这里用一个一维的数组就行了，其中 dp[i] 表示 [0, i] 区间的单词的最长的前任链。下面来推导状态转移方程，对于当前位置的单词，需要遍历前面所有的单词，这里需要先给单词按长度排个序，因为只有长度小1的单词才有可能是前任，所以只需要遍历之前所有长度正好小1的单词，若是前任关系，则用其 dp 值加1来更新当前 dp 值即可。判断前任关系可以放到一个子数组中来做，其实就是检测是否是子序列，没啥太大的难度，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestStrChain</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = words.<span class="built_in">size</span>(), res = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [](string&amp; a, string &amp;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (words[j].<span class="built_in">size</span>() + <span class="number">1</span> &lt; words[i].<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (words[j].<span class="built_in">size</span>() == words[i].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">helper</span>(words[j], words[i])) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                    res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">helper</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = word<span class="number">1.</span><span class="built_in">size</span>(), n = word<span class="number">2.</span><span class="built_in">size</span>(), i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word2[j] == word1[i]) ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>论坛上的高分解法在检验是否是前任时用了一种更好的方法，不是检测子序列，而是将当前的单词，按顺序每次去掉一个字符，然后看剩下的字符串是否在之前出现过，是的话就说明有前任，用其 dp 值加1来更新当前 dp 值，这是一种更巧妙且简便的方法。这里由于要快速判断前任是否存在，所以不是用的 dp 数组，而是用了个 HashMap，对于每个遍历到的单词，按顺序移除掉每个字符，若剩余的部分在 HashMap 中，则更新 dp 值和结果 res，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestStrChain</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = words.<span class="built_in">size</span>(), res = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [](string&amp; a, string&amp; b)&#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>(); &#125;);</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; dp;</span><br><span class="line">        <span class="keyword">for</span> (string word : words) &#123;</span><br><span class="line">            dp[word] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                string pre = word.<span class="built_in">substr</span>(<span class="number">0</span>, i) + word.<span class="built_in">substr</span>(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (dp.<span class="built_in">count</span>(pre)) &#123;</span><br><span class="line">                    dp[word] = <span class="built_in">max</span>(dp[word], dp[pre] + <span class="number">1</span>);</span><br><span class="line">                    res = <span class="built_in">max</span>(res, dp[word]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1049-Last-Stone-Weight-II"><a href="#Leetcode1049-Last-Stone-Weight-II" class="headerlink" title="Leetcode1049. Last Stone Weight II"></a>Leetcode1049. Last Stone Weight II</h1><p>You are given an array of integers stones where stones[i] is the weight of the ith stone.</p>
<p>We are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights x and y with x &lt;= y. The result of this smash is:</p>
<p>If x == y, both stones are destroyed, and<br>If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.<br>At the end of the game, there is at most one stone left.</p>
<p>Return  the smallest possible weight of the left stone. If there are no stones left, return 0.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: stones = [2,7,4,1,8,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,</span><br><span class="line">we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,</span><br><span class="line">we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,</span><br><span class="line">we can combine 1 and 1 to get 0, so the array converts to [1], then that&#x27;s the optimal value.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: stones = [31,26,33,21,40]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: stones = [1,2]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= stones.length &lt;= 30</li>
<li>1 &lt;= stones[i] &lt;= 100</li>
</ul>
<p>这道题是之前那道 Last Stone Weight 的拓展，之前那道题说是每次取两个最大的进行碰撞，问最后剩下的重量。而这里是可以任意取两个石头进行碰撞，并且需要最后剩余的重量最小，这种玩数组求极值的题十有八九都是用动态规划 Dynamic Programming 来做的。首先来考虑 dp 数组该如何定义，若是直接用 dp[i] 来表示区间 [0, i] 内的石头碰撞后剩余的最小重量，状态转移方程将十分难推导，因为石子是任意选的，当前的 dp 值和之前的没有太大的联系。这里需要重新考虑 dp 数组的定义，这道题的解法其实挺难想的，需要转换一下思维，虽说是求碰撞后剩余的重量，但实际上可以看成是要将石子分为两堆，且尽可能让二者的重量之和最接近。若分为的两堆重量相等，则相互碰撞后最终将直接湮灭，剩余为0；若不相等，则剩余的重量就是两堆石子的重量之差。这道题给的数据范围是石子个数不超过 30 个，每个的重量不超过 100，这样的话总共的石子重量不超过 3000，分为两堆的话，每堆的重量不超过 1500。我们应该将 dp[i] 定义为数组中的石子是否能组成重量为i的一堆，数组大小设为 1501 即可，且 dp[0] 初始化为 true。这里的状态转移的思路跟之前那道 Coin Change 是很相似的，遍历每个石头，累加当前石头重量到 sum，然后从 1500 和 sum 中的较小值开始遍历（因为每堆的总重量不超过 1500），且i要大于 stone，小于当前石头的i不需要更新，由于当前的石头重量 stone 知道了，那么假如 i-stone 的 dp 值为 true 的话，则 dp[i] 也一定为 true。更新完成之后，从 sum/2 开始遍历，假如其 dp 值为 true，则用总重量 sum 减去当前重量的2倍，就是二堆石头重量的差值了，也就是碰撞后的剩余重量了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">1501</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> stone : stones) &#123;</span><br><span class="line">            sum += stone;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">min</span>(<span class="number">1500</span>, sum); i &gt;= stone; --i) &#123;</span><br><span class="line">                dp[i] = dp[i] || dp[i - stone];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = sum / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i]) <span class="keyword">return</span> sum - <span class="number">2</span> * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1051-Height-Checker"><a href="#Leetcode1051-Height-Checker" class="headerlink" title="Leetcode1051. Height Checker"></a>Leetcode1051. Height Checker</h1><p>Students are asked to stand in non-decreasing order of heights for an annual photo.</p>
<p>Return the minimum number of students not standing in the right positions.  (This is the number of students that must move in order for all students to be standing in non-decreasing order of height.)</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,4,2,1,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><br>Explanation:<br>Students with heights 4, 3 and the last 1 are not standing in the right positions.</p>
<p>Note:</p>
<ul>
<li>1 &lt;= heights.length &lt;= 100</li>
<li>1 &lt;= heights[i] &lt;= 100</li>
</ul>
<p>看上去比较简单的题，找到没有按照顺序排列的数，想用一种不需要排序的方法来做，但是失败了，因为如果其他数字有序，只有一个无序，是要移动很多的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*int heightChecker(vector&lt;int&gt;&amp; heights) &#123;</span></span><br><span class="line"><span class="comment">        int res=0;</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;heights.size()-1;i++)&#123;</span></span><br><span class="line"><span class="comment">            if(!(heights[i]&gt;=heights[i-1] &amp;&amp; heights[i]&lt;=heights[i+1]))</span></span><br><span class="line"><span class="comment">                res++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return res;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">heightChecker</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; s = h;</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">begin</span>(s), <span class="built_in">end</span>(s));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; h.<span class="built_in">size</span>(); ++i) </span><br><span class="line">            res += h[i] != s[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1052-Grumpy-Bookstore-Owner"><a href="#Leetcode1052-Grumpy-Bookstore-Owner" class="headerlink" title="Leetcode1052. Grumpy Bookstore Owner"></a>Leetcode1052. Grumpy Bookstore Owner</h1><p>Today, the bookstore owner has a store open for customers.length minutes. Every minute, some number of customers (customers[i]) enter the store, and all those customers leave after the end of that minute.</p>
<p>On some minutes, the bookstore owner is grumpy. If the bookstore owner is grumpy on the i-th minute, grumpy[i] = 1, otherwise grumpy[i] = 0. When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise they are satisfied.</p>
<p>The bookstore owner knows a secret technique to keep themselves not grumpy for X minutes straight, but can only use it once.</p>
<p>Return the maximum number of customers that can be satisfied throughout the day.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3</span><br><span class="line">Output: 16</span><br><span class="line">Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. </span><br><span class="line">The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= X &lt;= customers.length == grumpy.length &lt;= 20000</li>
<li>0 &lt;= customers[i] &lt;= 1000</li>
<li>0 &lt;= grumpy[i] &lt;= 1</li>
</ul>
<p>滑动窗口. 统计在大小为 X 的窗口中, 有多少顾客刚好处在店主脾气不好的时刻, 即<code>grumpy[i] == 1</code>。其中<code>grumpy[i] == 0</code>对应的顾客始终是满意的, 使用 base 来统计. 而对于那些<code>grumpy[i] == 1</code>的顾客, 只有在他们刚好在滑动窗口中, 才能满意, 用 new_satisfied 统计在滑动窗口中新满意的顾客, 在窗口滑动过程中使用 max_satisfied 来记录最大值. 最后返回 base + max_satisfied.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSatisfied</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; customers, vector&lt;<span class="type">int</span>&gt;&amp; grumpy, <span class="type">int</span> minutes)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, len = grumpy.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> sat = <span class="number">0</span>, new_sat = <span class="number">0</span>, max_sat = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grumpy[i] == <span class="number">0</span>)</span><br><span class="line">                sat += customers[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                new_sat += customers[i];</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= minutes)</span><br><span class="line">                new_sat -= (customers[i-minutes] * grumpy[i-minutes]);</span><br><span class="line">            max_sat = <span class="built_in">max</span>(max_sat, new_sat);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sat + max_sat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1053-Previous-Permutation-With-One-Swap"><a href="#Leetcode1053-Previous-Permutation-With-One-Swap" class="headerlink" title="Leetcode1053. Previous Permutation With One Swap"></a>Leetcode1053. Previous Permutation With One Swap</h1><p>Given an array of positive integers arr (not necessarily distinct), return  the lexicographically largest permutation that is smaller than  arr, that can be made with exactly one swap (A  swap  exchanges the positions of two numbers arr[i] and arr[j]). If it cannot be done, then return the same array.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [3,2,1]</span><br><span class="line">Output: [3,1,2]</span><br><span class="line">Explanation: Swapping 2 and 1.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,1,5]</span><br><span class="line">Output: [1,1,5]</span><br><span class="line">Explanation: This is already the smallest permutation.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,9,4,6,7]</span><br><span class="line">Output: [1,7,4,6,9]</span><br><span class="line">Explanation: Swapping 9 and 7.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [3,1,1,3]</span><br><span class="line">Output: [1,3,1,3]</span><br><span class="line">Explanation: Swapping 1 and 3.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= arr.length &lt;= 104</li>
<li>1 &lt;= arr[i] &lt;= 104</li>
</ul>
<p>这道题给了一个正整数的数组，说是让任意交换两个数字，使得变成字母顺序最大的一种全排列，但是需要小于原先的排列，若无法得到这样的全排列（说明当前已经是最小的全排列），则返回原数组。通过分析题目中给的例子不难理解题意，根据例子2来看，若给定的数组就是升序排列的，则无法得到更小的全排列，说明只有遇到降序的位置的时候，才有可能进行交换。但是假如有多个可以下降的地方呢，比如例子1，3到2下降，2到1下降，这里是需要交换2和1的，所以最好是从后往前检验，遇到前一个数字比当前数字大的情况时，前一个数字必定是交换方之一，而当前数字并不是。比如例子3，数字4的前面是9，正确结果是9和7交换，所以还要从4往后遍历一下，找到一个仅次于9的数字交换才行，而且数字相同的话，取坐标较小的那个，比如例子4就是这种情况。</p>
<p>首先从后往前遍历，假如当前数字大于等于前一个数字，直接跳过，否则说明需要交换的。从当前位置再向后遍历一遍，找到第一个仅次于拐点的数字交换即可，注意下面的代码虽然嵌套了两个 for 循环，其实是线性的时间复杂度，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prevPermOpt1</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>(), mx = <span class="number">0</span>, idx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt;= arr[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[i - <span class="number">1</span>] &amp;&amp; mx &lt; arr[j]) &#123;</span><br><span class="line">                    mx = arr[j];</span><br><span class="line">                    idx = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i - <span class="number">1</span>], arr[idx]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1054-Distant-Barcodes"><a href="#Leetcode1054-Distant-Barcodes" class="headerlink" title="Leetcode1054. Distant Barcodes"></a>Leetcode1054. Distant Barcodes</h1><p>In a warehouse, there is a row of barcodes, where the ith barcode is barcodes[i].</p>
<p>Rearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: barcodes = [1,1,1,2,2,2]</span><br><span class="line">Output: [2,1,2,1,2,1]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: barcodes = [1,1,1,1,2,2,3,3]</span><br><span class="line">Output: [1,3,1,3,1,2,1,2]</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= barcodes.length &lt;= 10000</li>
<li>1 &lt;= barcodes[i] &lt;= 10000</li>
</ul>
<p>这道题说在一个仓库，有一排条形码，这里用数字表示，现在让给数字重新排序，使得相邻的数字不相同，并且说了一定会有合理的答案。意思就是说最多的重复个数不会超过数组长度的一半，否则一定会有相邻的重复数字。那么来分析一下题目，既然是为了避免重复数字被排在相邻的位置，肯定是要优先关注出现次数多的数字，因为它们更有可能出现在相邻的位置。这道题是可以用贪婪算法来做的，每次取出出现次数最多的两个数字，将其先排列起来，然后再取下一对出现次数最多的两个数字，以此类推直至排完整个数组。这里为了快速知道出现次数最多的数字，可以使用优先队列来做，里面放一个 pair 对儿，由频率和数字组成，这样优先队列就可以根据频率由高到低来自动排序了。统计频率的话就使用一个 HashMap，然后将频率和数字组成的 pair 对儿加入优先队列。进行 while 循环，条件是队列中的 pair 对儿至少两个，这样才能每次取出两个，将其加入结果 res 中，然后其频率分别减1，只要没减到0，就都加回优先队列中。最后可能队列还有一个剩余，有的话将数字加入结果 res 中即可，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rearrangeBarcodes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; barcodes)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; numCnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : barcodes) ++numCnt[num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : numCnt) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;a.second, a.first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pq.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> a = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">auto</span> b = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(a.second);</span><br><span class="line">            res.<span class="built_in">push_back</span>(b.second);</span><br><span class="line">            <span class="keyword">if</span> (--a.first &gt; <span class="number">0</span>) pq.<span class="built_in">push</span>(a);</span><br><span class="line">            <span class="keyword">if</span> (--b.first &gt; <span class="number">0</span>) pq.<span class="built_in">push</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!pq.<span class="built_in">empty</span>()) </span><br><span class="line">            res.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>().second);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>论坛上的高分解法貌似没有用到优先队列，不过整个思路还是大体相同的，还是用 HashMap 来统计频率，这里将组成的频率和数字的 pair 对儿放到一个数组中，然后给数组按照从大到小的顺序来排列。接下里就要填充 res 数组了，方法是先填偶数坐标的位置，将频率最大的数字分别填进去，当偶数坐标填完了之后，再填奇数坐标的位置，这样保证不会有相连的重复数字。使用一个变量 pos，表示当前要填的坐标，初始化为0，之后来遍历这个频率和数字的 pair 对儿，从高到低，先填充所有偶数，若 pos 大于数组长度了，则切换为填充奇数即可，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rearrangeBarcodes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; barcodes)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = barcodes.<span class="built_in">size</span>(), pos = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; vec;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; numCnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : barcodes) ++numCnt[num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : numCnt) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(&#123;a.second, a.first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">rbegin</span>(), vec.<span class="built_in">rend</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : vec) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.first; ++i, pos += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pos &gt;= n) pos = <span class="number">1</span>;</span><br><span class="line">                res[pos] = a.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1055-Shortest-Way-to-Form-String"><a href="#Leetcode1055-Shortest-Way-to-Form-String" class="headerlink" title="Leetcode1055. Shortest Way to Form String"></a>Leetcode1055. Shortest Way to Form String</h1><p>From any string, we can form a  subsequence  of that string by deleting some number of characters (possibly no deletions).</p>
<p>Given two strings source and target, return the minimum number of subsequences of source such that their concatenation equals target. If the task is impossible, return -1.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: source = &quot;abc&quot;, target = &quot;abcbc&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The target &quot;abcbc&quot; can be formed by &quot;abc&quot; and &quot;bc&quot;, which are subsequences of source &quot;abc&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: source = &quot;abc&quot;, target = &quot;acdbc&quot;</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: The target string cannot be constructed from the subsequences of source string due to the character &quot;d&quot; in target string.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: source = &quot;xyz&quot;, target = &quot;xzyxz&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The target string can be constructed as follows &quot;xz&quot; + &quot;y&quot; + &quot;xz&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>Both the source and target strings consist of only lowercase English letters from “a”-“z”.</li>
<li>The lengths of source and target string are between 1 and 1000.</li>
</ul>
<p>这道题说我们可以通过删除某些位置上的字母从而形成一个新的字符串，现在给了两个字符串 source 和 target，问最少需要删除多个字母，可以把 source 字母串拼接成为 target。注意这里的 target 字符串可能会远长于 source，所以需要多个 source 字符串 concatenate 到一起，然后再进行删除字母。对于 target 中的每个字母，都需要在 source 中匹配到，所以最外层循环肯定是遍历 target 中的每个字母，可以使用一个指针j，初始化赋值为0，接下来就要在 source 中匹配这个 target[j]，所以需要遍历一下 source 字符串，如果匹配上了 target[j]，则j自增1，继续匹配下一个，当循环退出后，此时有一种情况需要考虑，就是对于这个 target[j] 字母，整个 source 字符串都无法匹配，说明 target 中存在 source 中没有的字母，这种情况下是要返回 -1 的，如何判定这种情况呢？当然可以在最开始把 source 中所有的字母放到一个 HashSet 中，然后对于 target 中每个字母都检测看是否在集合中。但这里可以使用更简便的方法，就是在遍历 source 之前，用另一个变量 pre 记录当前j的位置，然后当遍历完 source 之后，若j没有变化，则说明有其他字母存在，直接返回 -1 即可，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestWay</span><span class="params">(string source, string target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, j = <span class="number">0</span>, m = source.<span class="built_in">size</span>(), n = target.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> pre = j;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; n &amp;&amp; source[i] == target[j]) ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == pre) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面这种方法思路和上面基本一样，就是没有直接去遍历 source 数组，而是使用了 STL 的 find 函数。开始还是要遍历 target 字符串，对于每个字母，首先在 source 中调用 find 函数查找一下，假如找不到，直接返回 -1。有的话，就从 pos+1 位置开始再次查找该字母，且其位置赋值为 pos，注意这里 pos+1 的原因是因为其初始化为了 -1，需要从0开始找，或者 pos 已经赋值为上一个匹配位置了，所以要从下一个位置开始查找。假如 pos 为 -1 了，说明当前剩余字母中无法匹配了，需要新的一轮循环，此时将 res 自增1，并将 pos 赋值为新的 source 串中的第一个匹配位置，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestWay</span><span class="params">(string source, string target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>, pos = <span class="number">-1</span>, n = target.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (source.<span class="built_in">find</span>(target[i]) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            pos = source.<span class="built_in">find</span>(target[i], pos + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">                pos = source.<span class="built_in">find</span>(target[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1056-Confusing-Number"><a href="#Leetcode1056-Confusing-Number" class="headerlink" title="Leetcode1056. Confusing Number"></a>Leetcode1056. Confusing Number</h1><p>Given a number N, return true if and only if it is a  confusing number , which satisfies the following condition:</p>
<p>We can rotate digits by 180 degrees to form new digits. When 0, 1, 6, 8, 9 are rotated 180 degrees, they become 0, 1, 9, 8, 6 respectively. When 2, 3, 4, 5 and 7 are rotated 180 degrees, they become invalid. A  confusing number  is a number that when rotated 180 degrees becomes a different number with each digit valid.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 6</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">We get `9` after rotating `6`, `9` is a valid number and `9!=6`.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 89</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">We get `68` after rotating `89`, `86` is a valid number and `86!=89`.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 11</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">We get `11` after rotating `11`, `11` is a valid number but the value remains the same, thus `11` is not a confusing number.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 25</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">We get an invalid number after rotating `25`.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>0 &lt;= N &lt;= 10^9</li>
<li>After the rotation we can ignore leading zeros, for example if after rotation we have 0008 then this number is considered as just 8.</li>
</ul>
<p>这道题定义了一种迷惑数，将数字翻转 180 度，其中 0, 1, 8 旋转后保持不变，6变成9，9变成6，数字 2, 3, 4, 5, 和 7 旋转后变为非法数字。若能将某个数翻转后成为一个合法的新的数，就说这个数是迷惑数。这道题的难度并不大，就是考察的是遍历整数各个位上的数字，使用一个 while 循环，然后用 mod10 取出当前最低位上的数字，将不合法的数字放入一个 HashSet 中，这样直接在 HashSet 中查找一下当前数字是否存在，存在直接返回 false。不存在的话，则要进行翻转，因为只有6和9两个数字翻转后会得到不同的数字，所以单独判断一下，然后将当前数字拼到 num 的最低位即可，最终拼成的 num 就是原数字 N 的翻转，最后别忘了比较一下是否相同，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">confusingNumber</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>, oldN = N;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; invalid&#123;&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> digit = N % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (invalid.<span class="built_in">count</span>(digit)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (digit == <span class="number">6</span>) digit = <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (digit == <span class="number">9</span>) digit = <span class="number">6</span>;</span><br><span class="line">            num = num * <span class="number">10</span> + digit;</span><br><span class="line">            N /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num != oldN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这也可以用一个 HashMap 来建立所有的数字映射，然后还是用一个变量 oldN 来记录原来的数字，然后遍历N上的每一位数字，若其不在 HashMap 中，说明有数字无法翻转，直接返回 false，否则就把翻转后的数字加入 res，最后只要看 res 和 oldN 是否相等即可，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">confusingNumber</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m&#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">6</span>, <span class="number">9</span>&#125;, &#123;<span class="number">8</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line">        <span class="type">long</span> oldN = N, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!m.<span class="built_in">count</span>(N % <span class="number">10</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + m[N % <span class="number">10</span>];</span><br><span class="line">            N /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res != oldN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面来看一种双指针的解法，这里先用一个数组 rotate 来按位记录每个数字翻转后得到的数字，用 -1 来表示非法情况，然后将数字 N 转为字符串，用两个指针 left 和 right 分别指向开头和末尾。用 while 循环进行遍历，假如此时 left 和 right 中有任何一个指向的数字翻转后是非法，直接返回 false。然后看 left 指向的数字翻转后跟 right 指向的数字是否相同，若不同，则将 res 标记为 true，然后移动 left 和 right 指针，最终返回 res 即可，参见代码如下：</p>
<p>解法三：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">confusingNumber</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rotate&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">9</span>, <span class="number">-1</span>, <span class="number">8</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        string str = <span class="built_in">to_string</span>(N);</span><br><span class="line">        <span class="type">int</span> n = str.<span class="built_in">size</span>(), left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rotate[str[left] - <span class="string">&#x27;0&#x27;</span>] == <span class="number">-1</span> || rotate[str[right] - <span class="string">&#x27;0&#x27;</span>] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (rotate[str[left] - <span class="string">&#x27;0&#x27;</span>] != (str[right] - <span class="string">&#x27;0&#x27;</span>)) res = <span class="literal">true</span>;</span><br><span class="line">            ++left; --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1057-Campus-Bikes"><a href="#Leetcode1057-Campus-Bikes" class="headerlink" title="Leetcode1057. Campus Bikes"></a>Leetcode1057. Campus Bikes</h1><p>On a campus represented as a 2D grid, there are N workers and M bikes, with N &lt;= M. Each worker and bike is a 2D coordinate on this grid.</p>
<p>Our goal is to assign a bike to each worker. Among the available bikes and workers, we choose the (worker, bike) pair with the shortest Manhattan distance between each other, and assign the bike to that worker. (If there are multiple (worker, bike) pairs with the same shortest Manhattan distance, we choose the pair with the smallest worker index; if there are multiple ways to do that, we choose the pair with the smallest bike index). We repeat this process until there are no available workers.</p>
<p>The Manhattan distance between two points p1 and p2 is Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|.</p>
<p>Return a vector ans of length N, where ans[i] is the index (0-indexed) of the bike that the i-th worker is assigned to.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]]</span><br><span class="line">Output: [1,0]</span><br><span class="line">Explanation:</span><br><span class="line">Worker 1 grabs Bike 0 as they are closest (without ties), and Worker 0 is assigned Bike 1. So the output is [1, 0].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]]</span><br><span class="line">Output: [0,2,1]</span><br><span class="line">Explanation:</span><br><span class="line">Worker 0 grabs Bike 0 at first. Worker 1 and Worker 2 share the same distance to Bike 2, thus Worker 1 is assigned to Bike 2, and Worker 2 will take Bike 1. So the output is [0,2,1].</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>0 &lt;= workers[i][j], bikes[i][j] &lt; 1000</li>
<li>All worker and bike locations are distinct.</li>
<li>1 &lt;= workers.length &lt;= bikes.length &lt;= 1000</li>
</ul>
<p>这道题用一个二维数组来表示一个校园坐标，上面有一些人和共享单车，人的数量不多余单车的数量，现在要让每一个人都分配一辆单车，人和单车的距离是用曼哈顿距离表示的。这里的分配方法其实是有一些 confuse 的，并不是每个人要拿离其距离最近的单车，也不是每辆单车要分配给距离其最近的人，而是要从所有的 单车-人 对儿中先挑出距离最短的一对儿，然后再挑出距离第二短的组合，以此类推，直到所有的人都被分配到单车了为止。这样的话就需要求出每一对人车距离，将所有的人车距离，和对应的人和车的标号都存到一个二维数组中。然后对这个二维数组进行排序，这里需要重写排序规则，将人车距离小的排前面，假如距离相等，则将人标号小的放前面，假如人的标号也相同，则就将车标号小的放前面。对人车距离数组排好序之后，此时需要两个数组来分别标记每个人被分配的车标号，和每个车的主人标号。现在从最小的人车距离开始取，若此时的人和车都没有分配，则进行分配，遍历完所有的人车距离之后，最终的结果就存在了标记每个人分配的车标号的数组中，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">assignBikes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; workers, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; bikes)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = workers.<span class="built_in">size</span>(), n = bikes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">assignedWorker</span><span class="params">(m, <span class="number">-1</span>)</span>, <span class="title">assignedBike</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dist;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> d = <span class="built_in">abs</span>(workers[i][<span class="number">0</span>] - bikes[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(workers[i][<span class="number">1</span>] - bikes[j][<span class="number">1</span>]);</span><br><span class="line">                dist.<span class="built_in">push_back</span>(&#123;d, i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(dist.<span class="built_in">begin</span>(), dist.<span class="built_in">end</span>(), [](vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>] || (a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]) || (a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] == b[<span class="number">1</span>] &amp;&amp; a[<span class="number">2</span>] &lt; b[<span class="number">2</span>]);</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : dist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (assignedWorker[a[<span class="number">1</span>]] == <span class="number">-1</span> &amp;&amp; assignedBike[a[<span class="number">2</span>]] == <span class="number">-1</span>) &#123;</span><br><span class="line">                assignedWorker[a[<span class="number">1</span>]] = a[<span class="number">2</span>];</span><br><span class="line">                assignedBike[a[<span class="number">2</span>]] = a[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> assignedWorker;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的解法虽然可以通过 OJ，但是并不是很高效，应该是排序的部分拖慢了速度。其实这道题的范围是有限的，因为车和人的坐标是有限的，最大的人车距离也不会超过 2000，那么利用桶排序来做就是个不错的选择，只需要 2001 个桶就行了，桶中放的是 pair 对儿，其中　buckets[i] 表示距离是i的人和车的标号组成的 pair 对儿。这样当计算出每个人车距离后，将其放入对应的桶中即可，就自动排好了序。然后开始遍历每个桶，由于每个桶中可能不止放了一个 pair 对儿，所以需要遍历每个桶中所有的组合，然后的操作就和上面的相同了，若此时的人和车都没有分配，则进行分配，遍历完所有的人车距离之后，最终的结果就存在了标记每个人分配的车标号的数组中，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">assignBikes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; workers, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; bikes)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = workers.<span class="built_in">size</span>(), n = bikes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">assignedWorker</span><span class="params">(m, <span class="number">-1</span>)</span>, <span class="title">assignedBike</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; <span class="built_in">buckets</span>(<span class="number">2001</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> dist = <span class="built_in">abs</span>(workers[i][<span class="number">0</span>] - bikes[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(workers[i][<span class="number">1</span>] - bikes[j][<span class="number">1</span>]);</span><br><span class="line">                buckets[dist].<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> dist = <span class="number">0</span>; dist &lt;= <span class="number">2000</span>; ++dist) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; buckets[dist].<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (assignedWorker[buckets[dist][k].first] == <span class="number">-1</span> &amp;&amp; assignedBike[buckets[dist][k].second] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    assignedWorker[buckets[dist][k].first] = buckets[dist][k].second;</span><br><span class="line">                    assignedBike[buckets[dist][k].second] = buckets[dist][k].first;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> assignedWorker;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1058-Minimize-Rounding-Error-to-Meet-Target"><a href="#Leetcode1058-Minimize-Rounding-Error-to-Meet-Target" class="headerlink" title="Leetcode1058. Minimize Rounding Error to Meet Target"></a>Leetcode1058. Minimize Rounding Error to Meet Target</h1><p>Given an array of prices <code>[p1,p2…,pn]</code> and a target, round each price pi to Roundi(pi) so that the rounded array <code>[Round1(p1),Round2(p2)…,Roundn(pn)]</code> sums to the given target. Each operation Roundi(pi) could be either Floor(pi) or Ceil(pi).</p>
<p>Return the string “-1” if the rounded array is impossible to sum to target. Otherwise, return the smallest rounding error, which is defined as Σ |Roundi(pi) - (pi)| for i from 1 to n, as a string with three places after the decimal.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [“0.700”,”2.800”,”4.900”], target = 8</span><br><span class="line">Output: “1.000”</span><br><span class="line">Explanation: </span><br><span class="line">Use Floor, Ceil and Ceil operations to get (0.7 - 0) + (3 - 2.8) + (5 - 4.9) = 0.7 + 0.2 + 0.1 = 1.0 .</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [“1.500”,”2.500”,”3.500”], target = 10</span><br><span class="line">Output: “-1”</span><br><span class="line">Explanation: </span><br><span class="line">It is impossible to meet the target.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= prices.length &lt;= 500.</li>
<li>Each string of prices prices[i] represents a real number which is between 0 and 1000 and has exactly 3 decimal places.<br>target is between 0 and 1000000.</li>
</ul>
<p>如果一个数字是一个整数， 那么我们只能取floor，不能取ceil。这相当于一个无法调整的数字，否则就是一个可调整的数字。我们把所有可调整的数字的小数部分放入一个priority queue中，把priority queue的size记为pqsize。</p>
<p>然后我们先判断什么情况下无法得到target：</p>
<ul>
<li>如果取最小的可能的和，那么所有数字都要取floor。如果这个和仍然比target大，或者比target-pqsize小，那么就说明无论如何也不可能得到target。这样我们就返回 “-1”</li>
<li>若满足上述条件，我们一定可以取到满足题目条件的和。我们需要知道调整多少个数字，即把floor操作变成ceil操作。需要调整的数字个数等于target-pqsize。</li>
<li>为了的达到最小的rounding error，对于每个调整的操作，我们希望它们小数尽可能大，这可以由之前的priority queue得到。取那个数字的ceil。最后把所有不需要调整的小数也加上，就是最小的rounding error了。</li>
<li>注意最后返回字符串是，需要做些特殊处理，只保留最后3位小数即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minimizeError</span><span class="params">(vector&lt;string&gt;&amp; prices, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">double</span>&gt; pq;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> price : prices) &#123;</span><br><span class="line">            sum += <span class="built_in">floor</span>(<span class="built_in">stod</span>(price));</span><br><span class="line">            <span class="type">double</span> diffPrice = <span class="built_in">stod</span>(price) - <span class="built_in">floor</span>(<span class="built_in">stod</span>(price));</span><br><span class="line">            <span class="keyword">if</span> (diffPrice != <span class="number">0</span>) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(diffPrice);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target || sum &lt; target - pq.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> diff = target - sum;</span><br><span class="line">        <span class="type">double</span> error = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">double</span> fl = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            error += diff &gt; <span class="number">0</span> ? <span class="number">1</span> - fl : fl;</span><br><span class="line">            diff--;</span><br><span class="line">        &#125;        </span><br><span class="line">        string ans = <span class="built_in">to_string</span>(error);</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">substr</span>(<span class="number">0</span>, ans.<span class="built_in">find</span>(<span class="string">&#x27;.&#x27;</span>) + <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1059-从始点到终点的所有路径"><a href="#Leetcode1059-从始点到终点的所有路径" class="headerlink" title="Leetcode1059. 从始点到终点的所有路径"></a>Leetcode1059. 从始点到终点的所有路径</h1><p>给定有向图的边 edges，以及该图的始点 source 和目标终点 destination，确定从始点 source 出发的所有路径是否最终结束于目标终点 destination，即：</p>
<ul>
<li>从始点 source 到目标终点 destination 存在至少一条路径</li>
<li>如果存在从始点 source 到没有出边的节点的路径，则该节点就是路径终点。</li>
<li>从始点source到目标终点 destination 可能路径数是有限数字</li>
<li>当从始点 source 出发的所有路径都可以到达目标终点 destination 时返回 true，否则返回 false。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, edges = [[0,1],[0,2]], source = 0, destination = 2</span><br><span class="line">输出：false</span><br><span class="line">说明：节点 1 和节点 2 都可以到达，但也会卡在那里。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, edges = [[0,1],[0,3],[1,2],[2,1]], source = 0, destination = 3</span><br><span class="line">输出：false</span><br><span class="line">说明：有两种可能：在节点 3 处结束，或是在节点 1 和节点 2 之间无限循环。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, edges = [[0,1],[0,2],[1,3],[2,3]], source = 0, destination = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>简单dfs，搜索时不能搜索到非end的断头路或者有end在中间的路。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">leadToDestination</span><span class="params">(<span class="type">int</span> n,std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;&amp; edge,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">m</span>(m);</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:edge)&#123;</span><br><span class="line">            m[e[<span class="number">0</span>]].<span class="built_in">push_back</span>(e[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!m[end].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DFS</span>(m,visited,start,end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;&amp; m,std::vector&lt;<span class="type">bool</span>&gt;&amp; visitd,<span class="type">int</span> cur,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!m[cur].<span class="built_in">size</span>()==<span class="number">0</span>&amp;&amp;cur!=end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> next:m[cur])&#123;</span><br><span class="line">            <span class="keyword">if</span>(visitd[next])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visitd[next]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">DFS</span>(m,visitd,cur,end))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visitd[next]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1060-Missing-Element-in-Sorted-Array"><a href="#Leetcode1060-Missing-Element-in-Sorted-Array" class="headerlink" title="Leetcode1060. Missing Element in Sorted Array"></a>Leetcode1060. Missing Element in Sorted Array</h1><p>Given a sorted array A of unique numbers, find the K-th missing number starting from the leftmost number of the array.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [4,7,9,10], K = 1</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line">The first missing number is 5.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [4,7,9,10], K = 3</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: </span><br><span class="line">The missing numbers are [5,6,8,...], hence the third missing number is 8.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2,4], K = 3</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: </span><br><span class="line">The missing numbers are [3,5,6,7,...], hence the third missing number is 6.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 50000</li>
<li>1 &lt;= A[i] &lt;= 1e7</li>
<li>1 &lt;= K &lt;= 1e8</li>
</ul>
<p>给出一个有序数组 A，数组中的每个数字都是 独一无二的，找出从数组最左边开始的第 K 个缺失数字。</p>
<p>拿到这个题之后，看了下Note中取值范围都比较大，因此如果想一个数字一个数字去判断的话肯定会超时。所以需要使用一个点小技巧，即跳过不需要判断的数字。直接计算出每两个相邻数字之间能满足多少个，从而更新k。</p>
<p>先对<code>nums</code>排序。然后开始遍历，计算<code>nums</code>相邻两个元素之间的数字数即<code>nums[i] - pre - 1</code>个，是否可以满足需要的k。如果能满足，那么直接找出要返回的数字<code>pre+k</code>。如果不能满足，把k去掉已能满足的数字<code>nums[i] - pre - 1</code>。最后如果所有的<code>nums</code>数字都已经用完，但是还不能满足k，则需要返回<code>nums[nums.size() - 1] + k</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &lt; nums[i] - pre) &#123;</span><br><span class="line">                <span class="keyword">return</span> pre + k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= nums[i] - pre - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre + k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1061-按字典序排列最小的等效字符串"><a href="#Leetcode1061-按字典序排列最小的等效字符串" class="headerlink" title="Leetcode1061. 按字典序排列最小的等效字符串"></a>Leetcode1061. 按字典序排列最小的等效字符串</h1><p>给出长度相同的两个字符串：A 和 B，其中 A[i] 和 B[i] 是一组等价字符。举个例子，如果 A = “abc” 且 B = “cde”，那么就有 ‘a’ == ‘c’, ‘b’ == ‘d’, ‘c’ == ‘e’。</p>
<p>等价字符遵循任何等价关系的一般规则：</p>
<ul>
<li>自反性：’a’ == ‘a’</li>
<li>对称性：’a’ == ‘b’ 则必定有 ‘b’ == ‘a’</li>
<li>传递性：’a’ == ‘b’ 且 ‘b’ == ‘c’ 就表明 ‘a’ == ‘c’</li>
</ul>
<p>例如，A 和 B 的等价信息和之前的例子一样，那么 S = “eed”, “acd” 或 “aab”，这三个字符串都是等价的，而 “aab” 是 S 的按字典序最小的等价字符串。利用 A 和 B 的等价信息，找出并返回 S 的按字典序排列最小的等价字符串。</p>
<p>示例 1：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：A = &quot;parker&quot;, B = &quot;morris&quot;, S = &quot;parser&quot;</span><br><span class="line">输出：&quot;makkek&quot;</span><br><span class="line">解释：根据 A 和 B 中的等价信息，</span><br><span class="line">我们可以将这些字符分为 [m,p], [a,o], [k,r,s], [e,i] 共 4 组。</span><br><span class="line">每组中的字符都是等价的，并按字典序排列。所以答案是 &quot;makkek&quot;。</span><br></pre></td></tr></table></figure></p>
<p>示例 2：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：A = &quot;hello&quot;, B = &quot;world&quot;, S = &quot;hold&quot;</span><br><span class="line">输出：&quot;hdld&quot;</span><br><span class="line">解释：根据 A 和 B 中的等价信息，</span><br><span class="line">我们可以将这些字符分为 [h,w], [d,e,o], [l,r] 共 3 组。</span><br><span class="line">所以只有 S 中的第二个字符 &#x27;o&#x27; 变成 &#x27;d&#x27;，最后答案为 &quot;hdld&quot;。</span><br></pre></td></tr></table></figure></p>
<p>示例 3：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：A = &quot;leetcode&quot;, B = &quot;programs&quot;, S = &quot;sourcecode&quot;</span><br><span class="line">输出：&quot;aauaaaaada&quot;</span><br><span class="line">解释：我们可以把 A 和 B 中的等价字符分为 </span><br><span class="line">[a,o,e,r,s,c], [l,p], [g,t] 和 [d,m] 共 4 组，</span><br><span class="line">因此 S 中除了 &#x27;u&#x27; 和 &#x27;d&#x27; 之外的所有字母都转化成了 &#x27;a&#x27;，最后答案为 &quot;aauaaaaada&quot;。</span><br></pre></td></tr></table></figure></p>
<p>并查集merge的时候，让祖先字符更小的作为代表<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">dsu</span></span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">dsu</span>(<span class="type">int</span> n)</span><br><span class="line">	&#123;</span><br><span class="line">		f.<span class="built_in">resize</span>(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">			f[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> fa = <span class="built_in">find</span>(a), fb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(fa &gt; fb)<span class="comment">//字母小的当代表，关键点</span></span><br><span class="line">		    f[fa] = fb;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f[fb] = fa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> origin = a;</span><br><span class="line">		<span class="keyword">while</span>(a != f[a])</span><br><span class="line">			a = f[a];</span><br><span class="line">		<span class="keyword">return</span> f[origin] = a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">smallestEquivalentString</span><span class="params">(string A, string B, string S)</span> </span>&#123;</span><br><span class="line">    	<span class="function">dsu <span class="title">u</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    		u.<span class="built_in">merge</span>(A[i]-<span class="string">&#x27;a&#x27;</span>, B[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    		S[i] = u.<span class="built_in">find</span>(S[i]-<span class="string">&#x27;a&#x27;</span>)+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    	<span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1062-Longest-Repeating-Substring"><a href="#Leetcode1062-Longest-Repeating-Substring" class="headerlink" title="Leetcode1062. Longest Repeating Substring"></a>Leetcode1062. Longest Repeating Substring</h1><p>Given a string S, find out the length of the longest repeating substring(s). Return 0 if no repeating substring exists.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: “abcd”</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no repeating substring.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: “abbaba”</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The longest repeating substrings are “ab” and “ba”, each of which occurs twice.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: “aabcaabdaab”</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest repeating substring is “aab”, which occurs 3 times.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: “aaaaa”</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest repeating substring is “aaaa”, which occurs twice.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>The string S consists of only lowercase English letters from ‘a’ - ‘z’.</li>
<li>1 &lt;= S.length &lt;= 1500</li>
</ul>
<p>解题思路：这题我们采用动态规划的方法。我们先定义<code>dp[i][j]</code>为分别以第i个字符和第j个字符结尾的<code>substring</code>有相同共同后缀的最大长度。因此，我们也要求i&gt;j。我们注意到，当<code>S[i] != S[j]</code>，那么<code>dp[i][j] = 0</code>，否则<code>dp[i][j] = dp[i-1][j-1] + 1</code>。这就是我们的状态转移方程。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-1] + 1 ----------- S[i] == S[j]</span><br><span class="line">dp[i][j] = 0 -------------------------- S[i] != S[j]</span><br></pre></td></tr></table></figure></p>
<p>我们更新<code>dp[i][j]</code>的最大值，就可以得到最后的答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestRepeatingSubstring</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(S.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(S.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">1</span>; i &lt;= S.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (S[i<span class="number">-1</span>] == S[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析</p>
<ul>
<li>N是字符串的长度。</li>
<li>时间复杂度: O(N^2)</li>
<li>空间复杂度: O(N^2)</li>
</ul>
<h1 id="Leetcode-1064-Fixed-Point"><a href="#Leetcode-1064-Fixed-Point" class="headerlink" title="Leetcode 1064. Fixed Point"></a>Leetcode 1064. Fixed Point</h1><p>Given an array A of distinct integers sorted in ascending order, return the smallest index i that satisfies A[i] == i.  Return -1 if no such i exists.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [-10,-5,0,3,7]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">For the given array, A[0] = -10, A[1] = -5, A[2] = 0, A[3] = 3, thus the output is 3.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,2,5,8,17]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: </span><br><span class="line">A[0] = 0, thus the output is 0.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [-10,-5,3,4,7,9]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: </span><br><span class="line">There is no such i that A[i] = i, thus the output is -1.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt; 10^4</li>
<li>-10^9 &lt;= A[i] &lt;= 10^9</li>
</ul>
<p>因为给出的是一个排序的array，而index也是自然从0到n-1的排序数组，因此本题采用二分法来查找<code>A[i] == i</code>的index。当<code>i &lt; A[i]</code>，我们往左边查找，当<code>i &gt;= A[i]</code>时， 我们往右边查找。需要注意的因为要求最小的index，我们更新右端点时，需要<code>i &gt;= A[i]</code>。如果是最大的index， 则应该是<code>i &gt; A[i]</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fixedPoint</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = A.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[mid] &gt;= mid) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == A[left]) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right == A[right]) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1065-Index-Pairs-of-a-String"><a href="#Leetcode1065-Index-Pairs-of-a-String" class="headerlink" title="Leetcode1065. Index Pairs of a String"></a>Leetcode1065. Index Pairs of a String</h1><p>Given a text string and words (a list of strings), return all index pairs [i, j] so that the substring text[i]…text[j] is in the list of words. </p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: text = “thestoryofleetcodeandme”, words = [“story”,”fleet”,”leetcode”]</span><br><span class="line">Output: [[3,7],[9,13],[10,17]]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: text = “ababa”, words = [“aba”,”ab”]</span><br><span class="line">Output: [[0,1],[0,2],[2,3],[2,4]]</span><br><span class="line">Explanation: </span><br><span class="line">Notice that matches can overlap, see “aba” is found in [0,2] and [2,4].</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>All strings contains only lowercase English letters.</li>
<li>It’s guaranteed that all strings in words are different.</li>
<li>1 &lt;= text.length &lt;= 100</li>
<li>1 &lt;= words.length &lt;= 20</li>
<li>1 &lt;= words[i].length &lt;= 50</li>
</ul>
<p>Return the pairs [i,j] in sorted order (i.e. sort them by their first coordinate in case of ties sort them by their second coordinate).</p>
<p>这道题可以直接用string find函数来做，但是需要分析一下时间复杂度。取决于具体的函数实现，比如CPP的find函数没有用KMP实现，所以最坏的情况复杂度是O(M <em> N)，这样带入本题，时间复杂度是`O(M </em> sum(len(word)))<code>。其中M是text的长度，</code>sum(len(word))`是words中word的长度之和。</p>
<p>如果用字典树Trie来实现，则当<code>M &lt; sum(len(word))</code>时，时间复杂度可以优化。首先建立基于words的字典树trie，然后在text中以每一个位置i为起点向后遍历，并判断往后每一个位置j是否在字典树中，若在则加入要返回的结果rets中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    vector&lt;Trie*&gt; children = <span class="built_in">vector</span>&lt;Trie*&gt;(<span class="number">26</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">bool</span> is_find = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function">Trie* <span class="title">constructTrie</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        Trie* trie = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            Trie* cur = trie;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> ch : word) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;children[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    cur-&gt;children[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;is_find = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> trie;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">indexPairs</span>(string text, vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        <span class="type">const</span> Trie* <span class="type">const</span> trie = <span class="built_in">constructTrie</span>(words);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; rets;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; text.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">const</span> Trie* cur = trie;           </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; text.<span class="built_in">size</span>() &amp;&amp; cur != <span class="literal">nullptr</span>; ++j) &#123;</span><br><span class="line">                cur = cur-&gt;children[text[j] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">if</span> (cur &amp;&amp; cur-&gt;is_find) &#123;</span><br><span class="line">                    rets.<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1071-Greatest-Common-Divisor-of-Strings"><a href="#Leetcode1071-Greatest-Common-Divisor-of-Strings" class="headerlink" title="Leetcode1071. Greatest Common Divisor of Strings"></a>Leetcode1071. Greatest Common Divisor of Strings</h1><p>For strings S and T, we say “T divides S” if and only if S = T + … + T  (T concatenated with itself 1 or more times)</p>
<p>Return the largest string X such that X divides str1 and X divides str2.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: str1 = &quot;ABCABC&quot;, str2 = &quot;ABC&quot;</span><br><span class="line">Output: &quot;ABC&quot;</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: str1 = &quot;ABABAB&quot;, str2 = &quot;ABAB&quot;</span><br><span class="line">Output: &quot;AB&quot;</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: str1 = &quot;LEET&quot;, str2 = &quot;CODE&quot;</span><br><span class="line">Output: &quot;&quot;</span><br></pre></td></tr></table></figure></p>
<p>最长公共重复子串重复若干次之后能分别得到str1和str2，那么最明显地，该子串的长度一定是str1和str2长度的公因数。看了一下字符串的长度最多只有1000，所以我们完全可以对长度进行遍历，判断每个公因数是不是构成最长公共重复子串。因为要找最长的，所以找到最长之后，直接返回即可。时间复杂度O(N^2)。外部循环找到公因数，时间复杂度O(N)；内部要创建新的字符串和原先的字符串进行比较，时间复杂度也是O(N)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">gen</span><span class="params">(string str, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">            res += str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">gcdOfStrings</span><span class="params">(string str1, string str2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l1 = str<span class="number">1.l</span>ength(), l2 = str<span class="number">2.l</span>ength();</span><br><span class="line">        <span class="type">int</span> length = <span class="built_in">min</span>(l1, l2);</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = length; i &gt; <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1 % i == <span class="number">0</span> &amp;&amp; l2 % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> t1 = l1 / i;</span><br><span class="line">                <span class="type">int</span> t2 = l2 / i;</span><br><span class="line">                string gcd = str<span class="number">1.</span><span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">                string s1 = <span class="built_in">gen</span>(gcd, t1);</span><br><span class="line">                string s2 = <span class="built_in">gen</span>(gcd, t2);</span><br><span class="line">                <span class="keyword">if</span> ((s1 == str1) &amp;&amp; (s2 == str2)) &#123;</span><br><span class="line">                    res = gcd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>题目要求 X 能除尽 str1 且 X 能除尽 str2，且 X 为最长。那么可以理解为 str1 由 m 个 X 连接而成， str2 由 n 个 X 连接而成。由此可知 str1 + str2 由 m + n 个 X 拼接而成，而且 str1 + str2 与 str2 + str1 在值上是相等的。然后此题就转化为了求最大公约数。str1 和 str2 长度的最大公约数，就是所求 X 的长度。</p>
<p>辗转相除法是递归算法，一句话概括这个算法就是：两个整数的最大公约数，等于其中较小的数 和两数相除余数 的最大公约数。比如 10 和 25，25 除以 10 商 2 余 5，那么 10 和 25 的最大公约数，等同于 10 和 5 的最大公约数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">gcdOfStrings</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 (str1 + str2) 和 (str2 + str1) 的值不相等</span></span><br><span class="line">        <span class="keyword">if</span> (!(str1 + str2).<span class="built_in">equals</span>(str2 + str1)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两个字符串长度的最大公约数</span></span><br><span class="line">        <span class="type">int</span> maxCommonDivisor = <span class="built_in">gcd</span>(str<span class="number">1.l</span>ength(), str<span class="number">2.l</span>ength());</span><br><span class="line">        <span class="keyword">return</span> str<span class="number">1.</span><span class="built_in">substring</span>(<span class="number">0</span>, maxCommonDivisor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 辗转相除法求最大公约数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a % b == <span class="number">0</span>) ? b : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1072-Flip-Columns-For-Maximum-Number-of-Equal-Rows"><a href="#Leetcode1072-Flip-Columns-For-Maximum-Number-of-Equal-Rows" class="headerlink" title="Leetcode1072. Flip Columns For Maximum Number of Equal Rows"></a>Leetcode1072. Flip Columns For Maximum Number of Equal Rows</h1><p>You are given an m x n binary matrix matrix.</p>
<p>You can choose any number of columns in the matrix and flip every cell in that column (i.e., Change the value of the cell from 0 to 1 or vice versa).</p>
<p>Return the maximum number of rows that have all values equal after some number of flips.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix = [[0,1],[1,1]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: After flipping no values, 1 row has all values equal.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix = [[0,1],[1,0]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: After flipping values in the first column, both rows have equal values.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix = [[0,0,0],[0,0,1],[1,1,0]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: After flipping values in the first two columns, the last two rows have equal values.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>m == matrix.length</li>
<li>n == matrix[i].length</li>
<li>1 &lt;= m, n &lt;= 300</li>
<li>matrix[i][j] is either 0 or 1.</li>
</ul>
<p>其实按照列翻转没有什么用，把0开头的或者1开头的，选一种，全部翻转，用哈希表计数，找到最多出现的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxEqualRowsAfterFlips</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; mat : matrix) &#123;</span><br><span class="line">            <span class="type">int</span> length = mat.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function">string <span class="title">str</span><span class="params">(length, <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (mat[<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i ++) &#123;</span><br><span class="line">                    mat[i] ^= <span class="number">1</span>;</span><br><span class="line">                    str[i] = mat[i] == <span class="number">1</span> ? <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i ++) &#123;</span><br><span class="line">                    str[i] = mat[i] == <span class="number">1</span> ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            m[str] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it ++)</span><br><span class="line">            res = <span class="built_in">max</span>(res, it-&gt;second);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1073-Adding-Two-Negabinary-Numbers"><a href="#Leetcode1073-Adding-Two-Negabinary-Numbers" class="headerlink" title="Leetcode1073. Adding Two Negabinary Numbers"></a>Leetcode1073. Adding Two Negabinary Numbers</h1><p>Given two numbers arr1 and arr2 in base -2, return the result of adding them together.</p>
<p>Each number is given in array format:  as an array of 0s and 1s, from most significant bit to least significant bit.  For example, arr = [1,1,0,1] represents the number (-2)^3 + (-2)^2 + (-2)^0 = -3.  A number arr in array, format is also guaranteed to have no leading zeros: either arr == [0] or arr[0] == 1.</p>
<p>Return the result of adding arr1 and arr2 in the same format: as an array of 0s and 1s with no leading zeros.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr1 = [1,1,1,1,1], arr2 = [1,0,1]</span><br><span class="line">Output: [1,0,0,0,0]</span><br><span class="line">Explanation: arr1 represents 11, arr2 represents 5, the output represents 16.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr1 = [0], arr2 = [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr1 = [0], arr2 = [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= arr1.length, arr2.length &lt;= 1000</li>
<li>arr1[i] and arr2[i] are 0 or 1</li>
<li>arr1 and arr2 have no leading zeros</li>
</ul>
<p>这道题说是有两个负二进制数是用数组来表示的，现在让返回它们相加后的结果，还是放在数组中来表示。这道题其实利用的方法跟那道很像，都是一位一位的处理的，直接加到结果 res 数组中的。这里使用两个指针i和j，分别指向数组 arr1 和 arr2 的末尾，然后用个变量 carry 表示进位，当i大于等于0时，carry 加上i指向的数字，并且i自减1，同理，当j大于等于0时，carry 加上j指向的数字，并且j自减1。由于数组中当每位上只能放一个数字，所以让 carry ‘与’上1，并加入到结果 res 数组后。然后需要再填充更高一位上的数字，对于二进制来说，直接右移1位即可，这里由于是负二进制，所以右移1位之后再取负。之后要移除所有的 leading zeros，因为这里高位是加到了 res 的后面，所以要去除末尾的零，使用个 while 去除。最后别忘了将 res 翻转一下返回即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">addNegabinary</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr1, vector&lt;<span class="type">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>, i = (<span class="type">int</span>)arr<span class="number">1.</span><span class="built_in">size</span>() - <span class="number">1</span>, j = (<span class="type">int</span>)arr<span class="number">2.</span><span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) carry += arr1[i--];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) carry += arr2[j--];</span><br><span class="line">            res.<span class="built_in">push_back</span>(carry &amp; <span class="number">1</span>);</span><br><span class="line">            carry = -(carry &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (res.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; res.<span class="built_in">back</span>() == <span class="number">0</span>) </span><br><span class="line">            res.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1078-Occurrences-After-Bigram"><a href="#Leetcode1078-Occurrences-After-Bigram" class="headerlink" title="Leetcode1078. Occurrences After Bigram"></a>Leetcode1078. Occurrences After Bigram</h1><p>Given words first and second, consider occurrences in some text of the form “first second third”, where second comes immediately after first, and third comes immediately after second.</p>
<p>For each such occurrence, add “third” to the answer, and return the answer.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: text = &quot;alice is a good girl she is a good student&quot;, first = &quot;a&quot;, second = &quot;good&quot;</span><br><span class="line">Output: [&quot;girl&quot;,&quot;student&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: text = &quot;we will we will rock you&quot;, first = &quot;we&quot;, second = &quot;will&quot;</span><br><span class="line">Output: [&quot;we&quot;,&quot;rock&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= text.length &lt;= 1000</li>
<li>text consists of space separated words, where each word consists of lowercase English letters.</li>
<li>1 &lt;= first.length, second.length &lt;= 10</li>
<li>first and second consist of lowercase English letters.</li>
</ul>
<p>第一种是先split，然后对比，运行时间较长但是内存占用小：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string text)</span></span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="type">int</span> begin=<span class="number">0</span>;</span><br><span class="line">        string temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;text.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(temp); </span><br><span class="line">                temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp = temp + text[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findOcurrences</span><span class="params">(string text, string first, string second)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        vector&lt;string&gt; split_string = <span class="built_in">split</span>(text);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;split_string.<span class="built_in">size</span>()<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(split_string[i]==first &amp;&amp; split_string[i<span class="number">+1</span>]==second)</span><br><span class="line">                res.<span class="built_in">push_back</span>(split_string[i<span class="number">+2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>人家有的大佬是用了流做的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findOcurrences</span><span class="params">(string text, string first, string second)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt;rst;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(text)</span></span>;</span><br><span class="line">        string s1,s2,cand;</span><br><span class="line">        ss&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">        <span class="keyword">while</span>(ss&gt;&gt;cand)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1==first &amp;&amp; s2==second)rst.<span class="built_in">push_back</span>(cand);</span><br><span class="line">            s1=s2;</span><br><span class="line">            s2=cand;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1079-Letter-Tile-Possibilities"><a href="#Leetcode1079-Letter-Tile-Possibilities" class="headerlink" title="Leetcode1079. Letter Tile Possibilities"></a>Leetcode1079. Letter Tile Possibilities</h1><p>You have a set of tiles, where each tile has one letter tiles[i] printed on it.  Return the number of possible non-empty sequences of letters you can make.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;AAB&quot;</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: The possible sequences are &quot;A&quot;, &quot;B&quot;, &quot;AA&quot;, &quot;AB&quot;, &quot;BA&quot;, &quot;AAB&quot;, &quot;ABA&quot;, &quot;BAA&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;AAABBC&quot;</span><br><span class="line">Output: 188</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= tiles.length &lt;= 7</li>
<li>tiles consists of uppercase English letters.</li>
</ul>
<p>求一个字符串的所有子串。第一想法优先使用全排列，即深度优先，但有一个核心问题：子串怎么办？全排列无法解决，子串的检索问题，这是我一开始苦思而不得解的地方。</p>
<p>解法一：</p>
<p>这是本题区别于普通全排列中，最隐蔽而又最有趣的一个点：字符串的全排列出来了，那字符串的所有不同子串，还会远吗？答案就是，全排列字符串的所有前缀子串里！检索全排列的全部不同子串（包含全排列本身），即为所求。</p>
<p>解法二：</p>
<p>因为问题的规模在7个字符内，解法一在时间和内存上均可接受。但当问题规模快速扩大时，基于解法一，如何优化？优化核心是，首先将字符串排序（排序大法好），一旦发生不同字符间的交换，则自字符串起始位置至交换发生的位置为前缀的子串，均发生变化！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string tiles, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; tiles.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j &amp;&amp; tiles[i]==tiles[j])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">swap</span>(tiles[i], tiles[j]);</span><br><span class="line">            <span class="built_in">dfs</span>(tiles, i<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTilePossibilities</span><span class="params">(string tiles)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(tiles.<span class="built_in">begin</span>(),tiles.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(tiles,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1080-Insufficient-Nodes-in-Root-to-Leaf-Paths"><a href="#Leetcode1080-Insufficient-Nodes-in-Root-to-Leaf-Paths" class="headerlink" title="Leetcode1080. Insufficient Nodes in Root to Leaf Paths"></a>Leetcode1080. Insufficient Nodes in Root to Leaf Paths</h1><p>Given the root of a binary tree, consider all root to leaf paths: paths from the root to any leaf.  (A leaf is a node with no children.)</p>
<p>A node is insufficient if every such root to leaf path intersecting this node has sum strictly less than limit.</p>
<p>Delete all insufficient nodes simultaneously, and return the root of the resulting binary tree.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1</span><br><span class="line">Output: [1,2,3,4,null,null,7,8,9,null,14]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22</span><br><span class="line">Output: [5,4,8,11,null,17,4,7,null,null,null,5]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,-3,-5,null,4,null], limit = -1</span><br><span class="line">Output: [1,null,-3,4]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>The given tree will have between 1 and 5000 nodes.</li>
<li>-10^5 &lt;= node.val &lt;= 10^5</li>
<li>-10^9 &lt;= limit &lt;= 10^9</li>
</ul>
<p>这道题定义了一种不足结点，就是说经过该结点的所有根到叶路径之和的都小于给定的 limit，现在让去除所有的这样的不足结点，返回剩下的结点组成的二叉树。这题好就好在给的例子都配了图，能够很好的帮助我们理解题意，给的例子很好的覆盖了大多数的情况，博主能想到的唯一没有覆盖的情况就是可能根结点也是不足结点，这样的话有可能会返回空树。这里首先处理一下 corner case，即根结点是叶结点的情况，这样只需要看根结点值是否小于 limit，是的话直接返回空指针，因为此时的根结点是个不足结点，需要被移除，否则直接返回根结点。一个比较快速的判断是否是叶结点的方法是看其左右子结点是否相等，因为只有均为空的时候才会相等。若根结点不为叶结点，且其左子结点存在的话，就对其左子结点调用递归，此时的 limit 需要减去根结点值，将返回的结点赋值给左子结点。同理，若其右子结点存在的话，就对其右子结点调用递归，此时的 limit 需要减去根结点值，将返回的结点赋值给右子结点。最后还需要判断一下，若此时的左右子结点都被赋值为空了，则当前结点也需要被移除，因为经过其左右子结点的根到叶路径就是经过该结点的所有路径，若其和均小于 limit，则当前结点也需要被移除，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sufficientSubset</span><span class="params">(TreeNode* root, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val &lt; limit ? <span class="literal">nullptr</span> : root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            root-&gt;left = <span class="built_in">sufficientSubset</span>(root-&gt;left, limit - root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            root-&gt;right = <span class="built_in">sufficientSubset</span>(root-&gt;right, limit - root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;left == root-&gt;right ? <span class="literal">nullptr</span> : root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1081-Smallest-Subsequence-of-Distinct-Characters"><a href="#Leetcode1081-Smallest-Subsequence-of-Distinct-Characters" class="headerlink" title="Leetcode1081. Smallest Subsequence of Distinct Characters"></a>Leetcode1081. Smallest Subsequence of Distinct Characters</h1><p>Given a string s, return the lexicographically smallest subsequence of s that contains all the distinct characters of s exactly once.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;bcabc&quot;</span><br><span class="line">Output: &quot;abc&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;cbacdcbc&quot;</span><br><span class="line">Output: &quot;acdb&quot;</span><br></pre></td></tr></table></figure></p>
<p>找出字典序最小的子序列。一次遍历，维护一个stack，存一个降序排列的堆，堆底是最小值，如果是之前出现过的字符，则跳过；否则遇到当前字符字典序小于之前最大值，并且最大值之后还会出现，那么就pop掉，直到之前的stack没有值或者比当前小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">smallestSubsequence</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span>* record = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">128</span>);</span><br><span class="line">        <span class="type">int</span>* visited = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">128</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i ++) &#123;</span><br><span class="line">            record[i] = <span class="number">0</span>;</span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) </span><br><span class="line">            record[c] ++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            -- record[c];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (visited[c])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() &gt; c &amp;&amp; record[st.<span class="built_in">top</span>()] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                visited[st.<span class="built_in">top</span>()] = <span class="number">0</span>;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(c);</span><br><span class="line">            visited[c] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res += (<span class="type">char</span>)(st.<span class="built_in">top</span>());</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这道题实际上需要用单调栈的思路来做，首先需要统计每个字母出现的次数，这里可以使用一个大小为 128 的数组 cnt 来表示，还需要一个数组 visited 来记录某个字母是否出现过。先遍历一遍字符串，统计每个字母出现的次数到 cnt 中。再遍历一遍给定的字符串，对于遍历到的字母，在 cnt 数组中减去一个，然后看该字母是否已经在 visited 数组中出现过，是的话直接跳过。否则需要进行一个 while 循环，这里的操作实际上是为了确保得到的结果是字母顺序最小的，若当前字母小于结果 res 中的最后一个字母，且该最后的字母在 cnt 中还存在，说明之后还会遇到这个字母，则可以在 res 中先去掉这个字母，以保证字母顺序最小，并且 visited 数组中标记为0，表示未访问。这里是尽可能的将 res 打造成单调递增的，但如果后面没有这个字母了，就不能移除，所以说并不能保证一定是单调递增的，但可以保证得到的结果是字母顺序最小的。while 循环退出后，将该字母加到结果 res 后，并且 visited 标记为1。这里还有个小 trick，结果 res 在初始化给个0，这样就不用判空了，而且0是小于所有字母的，不会影响这个逻辑，最后返回的时候去掉首位0就行了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">smallestSubsequence</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">128</span>)</span>, <span class="title">visited</span><span class="params">(<span class="number">128</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) ++cnt[c];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            --cnt[c];</span><br><span class="line">            <span class="keyword">if</span> (visited[c]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (c &lt; res.<span class="built_in">back</span>() &amp;&amp; cnt[res.<span class="built_in">back</span>()]) &#123;</span><br><span class="line">                visited[res.<span class="built_in">back</span>()] = <span class="number">0</span>;</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            res += c;</span><br><span class="line">            visited[c] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1089-Duplicate-Zeros"><a href="#Leetcode1089-Duplicate-Zeros" class="headerlink" title="Leetcode1089. Duplicate Zeros"></a>Leetcode1089. Duplicate Zeros</h1><p>Given a fixed length array arr of integers, duplicate each occurrence of zero, shifting the remaining elements to the right. Note that elements beyond the length of the original array are not written. Do the above modifications to the input array in place, do not return anything from your function.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,2,3,0,4,5,0]</span><br><span class="line">Output: null</span><br><span class="line">Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: null</span><br><span class="line">Explanation: After calling your function, the input array is modified to: [1,2,3]</span><br></pre></td></tr></table></figure></p>
<p>双指针也许是本题的最优解法。具体思路是维护一个快指针和一个慢指针。快指针是遇到0就多进一步。这样遍历一遍数据后，快指针和慢指针会有一个差值。这个差值就是需要填充0的个数。</p>
<p>接下来，我们需要从后向前遍历数组。如果慢指针指向的元素不为0，则把快指针指向的元素替换为慢指针指向的元素；如果慢指针指向的元素为0，则把快指针和快指针之前指向的元素替换为0。</p>
<p>你可能会发现对于不同的数组，第一遍遍历之后fast指针的值是不一样的。区别在于数组末尾是否为0，如果末尾为0，则fast指针的值(数组索引)为数组长度+1。如果末尾不是0，则fast指针的值是数组长度。其实数组最后一位是0的话，其实是不用复制这个值的。因此从后向前遍历的时候需要判断fast指针的值是否小于n，这样就可以把数组末尾为0的时候就不会复制了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">duplicateZeros</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[slow] == <span class="number">0</span>)</span><br><span class="line">                fast ++;</span><br><span class="line">            fast ++;</span><br><span class="line">            slow ++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast --;</span><br><span class="line">        slow --;</span><br><span class="line">        <span class="keyword">while</span>(slow &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast &lt; n)</span><br><span class="line">                arr[fast] = arr[slow];</span><br><span class="line">            <span class="keyword">if</span>(arr[slow] == <span class="number">0</span>)</span><br><span class="line">                arr[--fast] = arr[slow];</span><br><span class="line">            fast --;</span><br><span class="line">            slow --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1090-Largest-Values-From-Labels"><a href="#Leetcode1090-Largest-Values-From-Labels" class="headerlink" title="Leetcode1090. Largest Values From Labels"></a>Leetcode1090. Largest Values From Labels</h1><p>We have a set of items: the i-th item has value values[i] and label labels[i].</p>
<p>Then, we choose a subset S of these items, such that:</p>
<ul>
<li>|S| &lt;= num_wanted</li>
<li>For every label L, the number of items in S with label L is &lt;= use_limit.</li>
</ul>
<p>Return the largest possible sum of the subset S.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: values = [5,4,3,2,1], labels = [1,1,2,2,3], `num_wanted` = 3, use_limit = 1</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: The subset chosen is the first, third, and fifth item.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: values = [5,4,3,2,1], labels = [1,3,3,3,2], `num_wanted` = 3, use_limit = 2</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: The subset chosen is the first, second, and third item.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: values = [9,8,8,7,6], labels = [0,0,0,1,1], `num_wanted` = 3, use_limit = 1</span><br><span class="line">Output: 16</span><br><span class="line">Explanation: The subset chosen is the first and fourth item.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: values = [9,8,8,7,6], labels = [0,0,0,1,1], `num_wanted` = 3, use_limit = 2</span><br><span class="line">Output: 24</span><br><span class="line">Explanation: The subset chosen is the first, second, and fourth item.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= values.length == labels.length &lt;= 20000</li>
<li>0 &lt;= values[i], labels[i] &lt;= 20000</li>
<li>1 &lt;= num_wanted, use_limit &lt;= values.length</li>
</ul>
<p>这道题说是给了一堆物品，每个物品有不同的价值和标签，分别放在 values 和 labels 数组中，现在让选不超过 num_wanted 个物品，且每个标签类别的物品不超过 use_limit，问能得到的最大价值是多少。说实话这道题博主研究了好久才弄懂题意，而且主要是看例子分析出来的，看了看踩比赞多，估计许多人跟博主一样吧。这道题可以用贪婪算法来做，因为需要尽可能的选价值高的物品，但同时要兼顾到物品的标签种类。所以可以将价值和标签种类组成一个 pair 对儿，放到一个优先队列中，这样就可以按照价值从高到低进行排列了。同时，由于每个种类的物品不能超过 use_limit 个，所以需要统计每个种类被使用了多少次，可以用一个 HashMap 来建立标签和其使用次数之间的映射。先遍历一遍所有物品，将价值和标签组成 pair 对儿加入优先队列中。然后进行循环，条件是 num_wanted 大于0，且队列不为空，此时取出队顶元素，将其标签映射值加1，若此时仍小于 use_limit，说明当前物品可以入选，将其价值加到 res 中，并且 num_wanted 自减1即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestValsFromLabels</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; values, vector&lt;<span class="type">int</span>&gt;&amp; labels, <span class="type">int</span> num_wanted, <span class="type">int</span> use_limit)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = values.<span class="built_in">size</span>();</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; useMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;values[i], labels[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (num_wanted &gt; <span class="number">0</span> &amp;&amp; !pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> value = pq.<span class="built_in">top</span>().first, label = pq.<span class="built_in">top</span>().second; pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (++useMap[label] &lt;= use_limit) &#123;</span><br><span class="line">                res += value;</span><br><span class="line">                --num_wanted;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1091-Shortest-Path-in-Binary-Matrix"><a href="#Leetcode1091-Shortest-Path-in-Binary-Matrix" class="headerlink" title="Leetcode1091. Shortest Path in Binary Matrix"></a>Leetcode1091. Shortest Path in Binary Matrix</h1><p>Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.</p>
<p>A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:</p>
<ul>
<li>All the visited cells of the path are 0.</li>
<li>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</li>
<li>The length of a clear path is the number of visited cells of this path.</li>
</ul>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[0,1],[1,0]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[0,0,0],[1,1,0],[1,1,0]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[1,0,0],[1,1,0],[1,1,0]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>n == grid.length</li>
<li>n == grid[i].length</li>
<li>1 &lt;= n &lt;= 100</li>
<li>grid[i][j] is 0 or 1</li>
</ul>
<p>这道题给了一个 nxn 的二维数组，里面都是0和1，让找出一条从左上角到右下角的干净路径，所谓的干净路径就是均由0组成，并且定义了相邻的位置是八个方向，不仅仅是通常的上下左右。例子中还给了图帮助理解，但是也有一丢丢的误导，博主最开始以为只需要往右，下，和右下三个方向走就行了，其实并不一定，任何方向都是可能的，说白了还是一道迷宫遍历的问题。既然是迷宫遍历求最少步数，那么广度优先遍历 Breadth-First Search 就是不二之选了，还是使用一个队列 queue 来做，初识时将 (0, 0) 放进去，再用一个 TreeSet 来标记访问过的位置。注意这里的方向数组要用到八个方向，while 循环中用的还是经典的层序遍历的写法，就是经典的写法，没有啥特殊的地方，博主感觉已经写了无数次了，在进行这一切之前，先判断一下起始点，若为1，直接返回 -1 即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = grid.<span class="built_in">size</span>();</span><br><span class="line">        set&lt;vector&lt;<span class="type">int</span>&gt;&gt; visited;</span><br><span class="line">        visited.<span class="built_in">insert</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        queue&lt;vector&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dirs&#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (t[<span class="number">0</span>] == n - <span class="number">1</span> &amp;&amp; t[<span class="number">1</span>] == n - <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> dir : dirs) &#123;</span><br><span class="line">                    <span class="type">int</span> x = t[<span class="number">0</span>] + dir[<span class="number">0</span>], y = t[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= n || grid[x][y] == <span class="number">1</span> || visited.<span class="built_in">count</span>(&#123;x, y&#125;)) <span class="keyword">continue</span>;</span><br><span class="line">                    visited.<span class="built_in">insert</span>(&#123;x, y&#125;);</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1093-Statistics-from-a-Large-Sample"><a href="#Leetcode1093-Statistics-from-a-Large-Sample" class="headerlink" title="Leetcode1093. Statistics from a Large Sample"></a>Leetcode1093. Statistics from a Large Sample</h1><p>You are given a large sample of integers in the range [0, 255]. Since the sample is so large, it is represented by an array count where count[k] is the number of times that k appears in the sample.</p>
<p>Calculate the following statistics:</p>
<ul>
<li>minimum: The minimum element in the sample.</li>
<li>maximum: The maximum element in the sample.</li>
<li>mean: The average of the sample, calculated as the total sum of all elements divided by the total number of elements.</li>
<li>median:<ul>
<li>If the sample has an odd number of elements, then the median is the middle element once the sample is sorted.</li>
<li>If the sample has an even number of elements, then the median is the average of the two middle elements once the sample is sorted.</li>
</ul>
</li>
<li>mode: The number that appears the most in the sample. It is guaranteed to be unique.</li>
</ul>
<p>Return  the statistics of the sample as an array of floating-point numbers [minimum, maximum, mean, median, mode]. Answers within  10-5  of the actual answer will be accepted.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">Output: [1.00000,3.00000,2.37500,2.50000,3.00000]</span><br><span class="line">Explanation: The sample represented by count is [1,2,2,2,3,3,3,3].</span><br><span class="line">The minimum and maximum are 1 and 3 respectively.</span><br><span class="line">The mean is (1+2+2+2+3+3+3+3) / 8 = 19 / 8 = 2.375.</span><br><span class="line">Since the size of the sample is even, the median is the average of the two middle elements 2 and 3, which is 2.5.</span><br><span class="line">The mode is 3 as it appears the most in the sample.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">Output: [1.00000,4.00000,2.18182,2.00000,1.00000]</span><br><span class="line">Explanation: The sample represented by count is [1,1,1,1,2,2,2,3,3,4,4].</span><br><span class="line">The minimum and maximum are 1 and 4 respectively.</span><br><span class="line">The mean is (1+1+1+1+2+2+2+3+3+4+4) / 11 = 24 / 11 = 2.18181818... (for display purposes, the output shows the rounded number 2.18182).</span><br><span class="line">Since the size of the sample is odd, the median is the middle element 2.</span><br><span class="line">The mode is 1 as it appears the most in the sample.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>count.length == 256</li>
<li>0 &lt;= count[i] &lt;= 109</li>
<li>1 &lt;= sum(count) &lt;= 109</li>
<li>The mode of the sample that count represents is unique.</li>
</ul>
<p>这道题说是有很多在0到 255 中的整数，由于重复的数字太多了，所以这里采用的是统计每个数字出现的个数的方式，用数组 count 来表示，其中 count[i] 表示数字i出现的次数。现在让统计原始数组中的最大值，最小值，平均值，中位数，和众数。这里面的最大最小值很好求，最小值就是 count 数组中第一个不为0的位置，最大值就是 count 数组中最后一个不为0的位置。最小值 mn 初始化为 256，在遍历 count 数组的过程中，遇到不为0的数字时，若此时 mn 为 256，则更新为坐标i。最大值 mx 直接每次更新为值不为0的坐标i即可。平均值也好求，只要求出所有的数字之和，跟数字的个数相除就行了，注意由于数字之和可能很大，需要用 double 来表示。众数也不难求，只要找出 count 数组中的最大值，则其坐标就是众数。比较难就是中位数了，由于数组的个数可奇可偶，中位数的求法不同，这里为了统一，采用一个小 trick，比如数组 1，2，3 和 1，2，3，4，可以用坐标为 (n-1)/2 和 n/2 的两个数字求平均值得到，对于长度为奇数的数组，这两个坐标表示的是相同的数字。这里由于是统计数组，所以要找的两个位置是 (cnt+1)/2 和 (cnt+2)/2，其中 cnt 是所有数字的个数。再次遍历 count 数组，使用 cur 来累计当前经过的数字个数，若 cur 小于 first，且 cur 加上 count[i] 大于等于 first，说明当前数字i即为所求，加上其的一半到 median。同理，若 cur 小于 second，cur 加上 count[i] 大于等于 second，说明当前数字i即为所求，加上其的一半到 median 即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">sampleStats</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; count)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> mn = <span class="number">256</span>, mx = <span class="number">0</span>, mean = <span class="number">0</span>, median = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, mode = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (mn == <span class="number">256</span>) mn = i;</span><br><span class="line">            mx = i;</span><br><span class="line">            sum += (<span class="type">double</span>)i * count[i];</span><br><span class="line">            cnt += count[i];</span><br><span class="line">            <span class="keyword">if</span> (count[i] &gt; count[mode]) mode = i;</span><br><span class="line">        &#125;</span><br><span class="line">        mean = sum / cnt;</span><br><span class="line">        <span class="type">int</span> first = (cnt + <span class="number">1</span>) / <span class="number">2</span>, second = (cnt + <span class="number">2</span>) / <span class="number">2</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt; first &amp;&amp; cur + count[i] &gt;= first) median += i / <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt; second &amp;&amp; cur + count[i] &gt;= second) median += i / <span class="number">2.0</span>;</span><br><span class="line">            cur += count[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;mn, mx, sum / cnt, median, (<span class="type">double</span>)mode&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1094-Car-Pooling"><a href="#Leetcode1094-Car-Pooling" class="headerlink" title="Leetcode1094. Car Pooling"></a>Leetcode1094. Car Pooling</h1><p>You are driving a vehicle that has capacity empty seats initially available for passengers.  The vehicle only drives east (ie. it cannot turn around and drive west.)</p>
<p>Given a list of trips, trip[i] = [num_passengers, start_location, end_location] contains information about the i-th trip: the number of passengers that must be picked up, and the locations to pick them up and drop them off.  The locations are given as the number of kilometers due east from your vehicle’s initial location.</p>
<p>Return true if and only if it is possible to pick up and drop off all passengers for all the given trips.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: trips = [[2,1,5],[3,3,7]], capacity = 4</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: trips = [[2,1,5],[3,3,7]], capacity = 5</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: trips = [[2,1,5],[3,5,7]], capacity = 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: trips = [[3,2,7],[3,7,9],[8,3,9]], capacity = 11</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>trips.length &lt;= 1000</li>
<li>trips[i].length == 3</li>
<li>1 &lt;= trips[i][0] &lt;= 100</li>
<li>0 &lt;= trips[i][1] &lt; trips[i][2] &lt;= 1000</li>
<li>1 &lt;= capacity &lt;= 100000</li>
</ul>
<p>这道题说的是拼车的那些事儿，给了一个数组，里面是很多三元对儿，分别包含乘客个数，上车时间和下车时间，还给了一个变量 capacity，说是任何时候的乘客总数不超过 capacity 的话，返回 true，否则就返回 false。这道题其实跟之前的 Meeting Rooms II 是一样，只不过那道题是求需要的房间的总个数，而这里是限定了乘客的总数，问是否会超载。使用的解题思想都是一样的，主要是需要将上车时间点和下车时间点拆分开，然后按时间顺序排列在同一条时间轴上，上车的时候就加上这些人数，下车的时候就减去这些人数。若某个时间点上的总人数超过了限定值，就直接返回 false 就行了，这里博主没有用 TreeMap，而是直接都放到一个数组中，然后对该数组按时间点进行排序，再遍历排序后的数组，进行累加元素之和即可，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">carPooling</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; trips, <span class="type">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; data;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> trip : trips) &#123;</span><br><span class="line">            data.<span class="built_in">push_back</span>(&#123;trip[<span class="number">1</span>], trip[<span class="number">0</span>]&#125;);</span><br><span class="line">            data.<span class="built_in">push_back</span>(&#123;trip[<span class="number">2</span>], -trip[<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : data) &#123;</span><br><span class="line">            cur += a[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (cur &gt; capacity) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接下来看一种更加高效的解法，并不用进行排序，那个太耗时了。题目限定了时间点不会超过 1000，所以这里就建立一个大小为 1001 的 cnt 数组，然后遍历 trips 数组，将对应的上车时间点加上乘客人数，下车时间点减去乘客人数，这样的话就相当于排序完成了，有点计数排序的感觉。之后再遍历这个 cnt 数组，累加当前的值，只要超过 capacity 了，就返回 false，否则最终返回 true 即可，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">carPooling</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; trips, <span class="type">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">1001</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;trip : trips) &#123;</span><br><span class="line">            cnt[trip[<span class="number">1</span>]] += trip[<span class="number">0</span>];</span><br><span class="line">            cnt[trip[<span class="number">2</span>]] -= trip[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">            cur += cnt[i];</span><br><span class="line">            <span class="keyword">if</span> (cur &gt; capacity) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/22/HTTP%20%E5%92%8C%20HTTPS%20%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="prev" title="HTTP 和 HTTPS 的区别">
      <i class="fa fa-chevron-left"></i> HTTP 和 HTTPS 的区别
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/05/Leetcode1101_1200/" rel="next" title="Leetcode1101 - 1200">
      Leetcode1101 - 1200 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1002-Find-Common-Characters"><span class="nav-number">1.</span> <span class="nav-text">Leetcode1002. Find Common Characters</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1003-Check-If-Word-Is-Valid-After-Substitutions"><span class="nav-number">2.</span> <span class="nav-text">Leetcode1003. Check If Word Is Valid After Substitutions</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1004-Max-Consecutive-Ones-III"><span class="nav-number">3.</span> <span class="nav-text">Leetcode1004. Max Consecutive Ones III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1005-Maximize-Sum-Of-Array-After-K-Negations"><span class="nav-number">4.</span> <span class="nav-text">Leetcode1005. Maximize Sum Of Array After K Negations</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1006-Clumsy-Factorial"><span class="nav-number">5.</span> <span class="nav-text">Leetcode1006. Clumsy Factorial</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1007-Minimum-Domino-Rotations-For-Equal-Row"><span class="nav-number">6.</span> <span class="nav-text">Leetcode1007. Minimum Domino Rotations For Equal Row</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1008-Construct-Binary-Search-Tree-from-Preorder-Traversal"><span class="nav-number">7.</span> <span class="nav-text">Leetcode1008. Construct Binary Search Tree from Preorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1009-Complement-of-Base-10-Integer"><span class="nav-number">8.</span> <span class="nav-text">Leetcode1009. Complement of Base 10 Integer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1010-Pairs-of-Songs-With-Total-Durations-Divisible-by-60"><span class="nav-number">9.</span> <span class="nav-text">Leetcode1010. Pairs of Songs With Total Durations Divisible by 60</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1011-Capacity-To-Ship-Packages-Within-D-Days"><span class="nav-number">10.</span> <span class="nav-text">Leetcode1011. Capacity To Ship Packages Within D Days</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1013-Partition-Array-Into-Three-Parts-With-Equal-Sum"><span class="nav-number">11.</span> <span class="nav-text">Leetcode1013. Partition Array Into Three Parts With Equal Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1014-Best-Sightseeing-Pair"><span class="nav-number">12.</span> <span class="nav-text">Leetcode1014. Best Sightseeing Pair</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1015-Smallest-Integer-Divisible-by-K"><span class="nav-number">13.</span> <span class="nav-text">Leetcode1015. Smallest Integer Divisible by K</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1016-Binary-String-With-Substrings-Representing-1-To-N"><span class="nav-number">14.</span> <span class="nav-text">Leetcode1016. Binary String With Substrings Representing 1 To N</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1017-Convert-to-Base-2"><span class="nav-number">15.</span> <span class="nav-text">Leetcode1017. Convert to Base -2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1018-Binary-Prefix-Divisible-By-5"><span class="nav-number">16.</span> <span class="nav-text">Leetcode1018. Binary Prefix Divisible By 5</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1019-Next-Greater-Node-In-Linked-List"><span class="nav-number">17.</span> <span class="nav-text">Leetcode1019. Next Greater Node In Linked List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1020-Number-of-Enclaves"><span class="nav-number">18.</span> <span class="nav-text">Leetcode1020. Number of Enclaves</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1021-Remove-Outermost-Parentheses"><span class="nav-number">19.</span> <span class="nav-text">Leetcode1021. Remove Outermost Parentheses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1022-Sum-of-Root-To-Leaf-Binary-Numbers"><span class="nav-number">20.</span> <span class="nav-text">Leetcode1022. Sum of Root To Leaf Binary Numbers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1023-Camelcase-Matching"><span class="nav-number">21.</span> <span class="nav-text">Leetcode1023. Camelcase Matching</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1024-Video-Stitching"><span class="nav-number">22.</span> <span class="nav-text">Leetcode1024. Video Stitching</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1025-Divisor-Game"><span class="nav-number">23.</span> <span class="nav-text">Leetcode1025. Divisor Game</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1026-Maximum-Difference-Between-Node-and-Ancestor"><span class="nav-number">24.</span> <span class="nav-text">Leetcode1026. Maximum Difference Between Node and Ancestor</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1027-Longest-Arithmetic-Sequence"><span class="nav-number">25.</span> <span class="nav-text">Leetcode1027. Longest Arithmetic Sequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1028-Recover-a-Tree-From-Preorder-Traversal"><span class="nav-number">26.</span> <span class="nav-text">Leetcode1028. Recover a Tree From Preorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1029-Two-City-Scheduling"><span class="nav-number">27.</span> <span class="nav-text">Leetcode1029. Two City Scheduling</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1030-Matrix-Cells-in-Distance-Order"><span class="nav-number">28.</span> <span class="nav-text">Leetcode1030. Matrix Cells in Distance Order</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1031-Maximum-Sum-of-Two-Non-Overlapping-Subarrays"><span class="nav-number">29.</span> <span class="nav-text">Leetcode1031. Maximum Sum of Two Non-Overlapping Subarrays</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1033-Moving-Stones-Until-Consecutive"><span class="nav-number">30.</span> <span class="nav-text">Leetcode1033. Moving Stones Until Consecutive</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1034-Coloring-A-Border"><span class="nav-number">31.</span> <span class="nav-text">Leetcode1034. Coloring A Border</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1035-Uncrossed-Lines"><span class="nav-number">32.</span> <span class="nav-text">Leetcode1035. Uncrossed Lines</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1037-Valid-Boomerang"><span class="nav-number">33.</span> <span class="nav-text">Leetcode1037. Valid Boomerang</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1038-Binary-Search-Tree-to-Greater-Sum-Tree"><span class="nav-number">34.</span> <span class="nav-text">Leetcode1038. Binary Search Tree to Greater Sum Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1039-Minimum-Score-Triangulation-of-Polygon"><span class="nav-number">35.</span> <span class="nav-text">Leetcode1039. Minimum Score Triangulation of Polygon</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1041-Robot-Bounded-In-Circle"><span class="nav-number">36.</span> <span class="nav-text">Leetcode1041. Robot Bounded In Circle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1042-Flower-Planting-With-No-Adjacent"><span class="nav-number">37.</span> <span class="nav-text">Leetcode1042. Flower Planting With No Adjacent</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1043-Partition-Array-for-Maximum-Sum"><span class="nav-number">38.</span> <span class="nav-text">Leetcode1043. Partition Array for Maximum Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1046-Last-Stone-Weight"><span class="nav-number">39.</span> <span class="nav-text">Leetcode1046. Last Stone Weight</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1047-Remove-All-Adjacent-Duplicates-In-String"><span class="nav-number">40.</span> <span class="nav-text">Leetcode1047. Remove All Adjacent Duplicates In String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1048-Longest-String-Chain"><span class="nav-number">41.</span> <span class="nav-text">Leetcode1048. Longest String Chain</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1049-Last-Stone-Weight-II"><span class="nav-number">42.</span> <span class="nav-text">Leetcode1049. Last Stone Weight II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1051-Height-Checker"><span class="nav-number">43.</span> <span class="nav-text">Leetcode1051. Height Checker</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1052-Grumpy-Bookstore-Owner"><span class="nav-number">44.</span> <span class="nav-text">Leetcode1052. Grumpy Bookstore Owner</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1053-Previous-Permutation-With-One-Swap"><span class="nav-number">45.</span> <span class="nav-text">Leetcode1053. Previous Permutation With One Swap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1054-Distant-Barcodes"><span class="nav-number">46.</span> <span class="nav-text">Leetcode1054. Distant Barcodes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1055-Shortest-Way-to-Form-String"><span class="nav-number">47.</span> <span class="nav-text">Leetcode1055. Shortest Way to Form String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1056-Confusing-Number"><span class="nav-number">48.</span> <span class="nav-text">Leetcode1056. Confusing Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1057-Campus-Bikes"><span class="nav-number">49.</span> <span class="nav-text">Leetcode1057. Campus Bikes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1058-Minimize-Rounding-Error-to-Meet-Target"><span class="nav-number">50.</span> <span class="nav-text">Leetcode1058. Minimize Rounding Error to Meet Target</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1059-%E4%BB%8E%E5%A7%8B%E7%82%B9%E5%88%B0%E7%BB%88%E7%82%B9%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="nav-number">51.</span> <span class="nav-text">Leetcode1059. 从始点到终点的所有路径</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1060-Missing-Element-in-Sorted-Array"><span class="nav-number">52.</span> <span class="nav-text">Leetcode1060. Missing Element in Sorted Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1061-%E6%8C%89%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E5%88%97%E6%9C%80%E5%B0%8F%E7%9A%84%E7%AD%89%E6%95%88%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">53.</span> <span class="nav-text">Leetcode1061. 按字典序排列最小的等效字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1062-Longest-Repeating-Substring"><span class="nav-number">54.</span> <span class="nav-text">Leetcode1062. Longest Repeating Substring</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-1064-Fixed-Point"><span class="nav-number">55.</span> <span class="nav-text">Leetcode 1064. Fixed Point</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1065-Index-Pairs-of-a-String"><span class="nav-number">56.</span> <span class="nav-text">Leetcode1065. Index Pairs of a String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1071-Greatest-Common-Divisor-of-Strings"><span class="nav-number">57.</span> <span class="nav-text">Leetcode1071. Greatest Common Divisor of Strings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1072-Flip-Columns-For-Maximum-Number-of-Equal-Rows"><span class="nav-number">58.</span> <span class="nav-text">Leetcode1072. Flip Columns For Maximum Number of Equal Rows</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1073-Adding-Two-Negabinary-Numbers"><span class="nav-number">59.</span> <span class="nav-text">Leetcode1073. Adding Two Negabinary Numbers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1078-Occurrences-After-Bigram"><span class="nav-number">60.</span> <span class="nav-text">Leetcode1078. Occurrences After Bigram</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1079-Letter-Tile-Possibilities"><span class="nav-number">61.</span> <span class="nav-text">Leetcode1079. Letter Tile Possibilities</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1080-Insufficient-Nodes-in-Root-to-Leaf-Paths"><span class="nav-number">62.</span> <span class="nav-text">Leetcode1080. Insufficient Nodes in Root to Leaf Paths</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1081-Smallest-Subsequence-of-Distinct-Characters"><span class="nav-number">63.</span> <span class="nav-text">Leetcode1081. Smallest Subsequence of Distinct Characters</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1089-Duplicate-Zeros"><span class="nav-number">64.</span> <span class="nav-text">Leetcode1089. Duplicate Zeros</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1090-Largest-Values-From-Labels"><span class="nav-number">65.</span> <span class="nav-text">Leetcode1090. Largest Values From Labels</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1091-Shortest-Path-in-Binary-Matrix"><span class="nav-number">66.</span> <span class="nav-text">Leetcode1091. Shortest Path in Binary Matrix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1093-Statistics-from-a-Large-Sample"><span class="nav-number">67.</span> <span class="nav-text">Leetcode1093. Statistics from a Large Sample</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1094-Car-Pooling"><span class="nav-number">68.</span> <span class="nav-text">Leetcode1094. Car Pooling</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuhao0102" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuhao0102" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuhhpc0203@gmail.com" title="E-Mail → mailto:yuhhpc0203@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
