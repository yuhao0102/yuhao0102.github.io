<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="C++要求我们要用特定的类型来声明变量，函数以及其他一些内容。这样很多代码可能就只是处理的变量类型有所不同。比如对不同的数据类型，quicksort的算法实现在结构上可能完全一样，不管是对整形的array，还是字符串类型的vector，只要他们所包含的内容之间可以相互比较。如果你所使用的语言不支持这一泛型特性，你将可能只有如下糟糕的选择：  你可以对不同的类型一遍又一遍的实现相同的算法。 你可以在">
<meta property="og:type" content="article">
<meta property="og:title" content="C++模板">
<meta property="og:url" content="http://yoursite.com/2022/01/07/cpp%E6%A8%A1%E6%9D%BF/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="C++要求我们要用特定的类型来声明变量，函数以及其他一些内容。这样很多代码可能就只是处理的变量类型有所不同。比如对不同的数据类型，quicksort的算法实现在结构上可能完全一样，不管是对整形的array，还是字符串类型的vector，只要他们所包含的内容之间可以相互比较。如果你所使用的语言不支持这一泛型特性，你将可能只有如下糟糕的选择：  你可以对不同的类型一遍又一遍的实现相同的算法。 你可以在">
<meta property="og:locale" content="zn_CH">
<meta property="article:published_time" content="2022-01-07T14:03:00.000Z">
<meta property="article:modified_time" content="2022-01-21T03:37:56.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2022/01/07/cpp%E6%A8%A1%E6%9D%BF/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>C++模板 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/resume.pdf" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/01/07/cpp%E6%A8%A1%E6%9D%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++模板
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-07 22:03:00" itemprop="dateCreated datePublished" datetime="2022-01-07T22:03:00+08:00">2022-01-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-21 11:37:56" itemprop="dateModified" datetime="2022-01-21T11:37:56+08:00">2022-01-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>C++要求我们要用特定的类型来声明变量，函数以及其他一些内容。这样很多代码可能就只是处理的变量类型有所不同。比如对不同的数据类型，quicksort的算法实现在结构上可能完全一样，不管是对整形的array，还是字符串类型的vector，只要他们所包含的内容之间可以相互比较。如果你所使用的语言不支持这一泛型特性，你将可能只有如下糟糕的选择：</p>
<ol>
<li>你可以对不同的类型一遍又一遍的实现相同的算法。</li>
<li>你可以在某一个公共基类（common base type，比如Object和void*）里面实现通用的算法代码。</li>
<li>你也可以使用特殊的预处理方法。</li>
</ol>
<p>如果你是从其它语言转向C++，你可能已经使用过以上几种或全部的方法了。然而他们都各有各的缺点：</p>
<ol>
<li>如果你一遍又一遍地实现相同算法，你就是在重复地制造轮子！</li>
<li>如果在公共基类里实现统一的代码，就等于放弃了类型检查的好处。而且，有时候某些类必须要从某些特殊的基类派生出来，这会进一步增加维护代码的复杂度。</li>
<li>如果采用预处理的方式，你需要实现一些“愚蠢的文本替换机制”，这将很难兼顾作用域和类型检查，因此也就更容易引发奇怪的语义错误。</li>
</ol>
<p>而模板这一方案就不会有这些问题。模板是为了一种或者多种未明确定义的类型而定义的函数或者类。在使用模板时，需要显式地或者隐式地指定模板参数。由于模板是C++的语言特性，类型和作用域检查将依然得到支持。</p>
<h1 id="函数模板（Function-Templates）"><a href="#函数模板（Function-Templates）" class="headerlink" title="函数模板（Function Templates）"></a>函数模板（Function Templates）</h1><p>本章将介绍函数模板。函数模板是被参数化的函数，因此他们代表的是一组具有相似行为的函数。</p>
<h2 id="函数模板初探"><a href="#函数模板初探" class="headerlink" title="函数模板初探"></a>函数模板初探</h2><p>函数模板提供了适用于不同数据类型的函数行为。也就是说，函数模板代表的是一组函数。除了某些信息未被明确指定之外，他们看起来很像普通函数。这些未被指定的信息就是被参数化的信息。我们将通过下面一个简单的例子来说明这一问题。</p>
<h3 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h3><p>以下就是一个函数模板，它返回两个数之中的最大值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果b &lt; a,返回a，否则返回b</span></span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个模板定义了一组函数，它们都返回函数的两个参数中值较大的那一个。这两个参数的类型并没有被明确指定，而是被表示为模板参数T。如你所见，模板参数必须按照如下语法声明：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;由逗号分割的模板参数&gt;</span><br></pre></td></tr></table></figure></p>
<p>在我们的例子中，模板参数是<code>typename T</code>。请留意<code>&lt;</code>和<code>&gt;</code>的使用，它们在这里被称为尖括号。关键字<code>typename</code>标识了一个类型参数。这是到目前为止C++中模板参数最典型的用法，当然也有其他参数（非类型模板参数）。</p>
<p>在这里<code>T</code>是类型参数。你可以用任意标识作为类型参数名，但是习惯上是用<code>T</code>。类型参数可以代表任意类型，它在模板被调用的时候决定。但是该类型（可以是基础类型，类或者其它类型）应该支持模板中用到的运算符。</p>
<p>由于历史原因，除了<code>typename</code>之外你还可以使用<code>class</code>来定义类型参数。关键字<code>typename</code>在C++98标准发展过程中引入的较晚。在那之前，关键字<code>class</code>是唯一可以用来定义类型参数的方法，而且目前这一方法依然有效。因此模板<code>max()</code>也可以被定义成如下等效的方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从语义上来讲，这样写不会有任何不同。因此，在这里你依然可以使用任意类型作为类型参数。只是用<code>class</code>的话可能会引起一些歧义（<code>T</code>并不是只能是<code>class</code>类型），你应该优先使用<code>typename</code>。但是与定义<code>class</code>的情况不同，在声明模板类型参数的时候，不可以用关键字<code>struct</code><br>取代<code>typename</code>。</p>
<h3 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h3><p>下面的程序展示了使用模板的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;max1.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;max(7,i): &quot;</span> &lt;&lt; ::<span class="built_in">max</span>(<span class="number">7</span>,i) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="type">double</span> f1 = <span class="number">3.4</span>;</span><br><span class="line">    <span class="type">double</span> f2 = <span class="number">-6.7</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;max(f1,f2): &quot;</span> &lt;&lt; ::<span class="built_in">max</span>(f1,f2) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::string s1 = <span class="string">&quot;mathematics&quot;</span>;</span><br><span class="line">    std::string s2 = <span class="string">&quot;math&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;max(s1,s2): &quot;</span> &lt;&lt; ::<span class="built_in">max</span>(s1,s2) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，<code>max()</code>被调用了三次：一次是比较两个int，一次是比较两个double，还有一次是比较两个<code>std::string</code>。每一次都会算出最大值。下面是输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">max(7,i): 42</span><br><span class="line">max(f1,f2): 3.4</span><br><span class="line">max(s1,s2): mathematics</span><br></pre></td></tr></table></figure>
<p>注意在调用<code>max()</code>模板的时候使用了作用域限制符<code>::</code>。这样程序将会在全局作用域中查找<code>max()</code>模板。否则的话，在某些情况下标准库中的<code>std::max()</code>模板将会被调用，或者有时候不太容易确定具体哪一个模板会被调用。</p>
<p>在编译阶段，模板并不是被编译成一个可以支持多种类型的实体。而是对每一个用于该模板的类型都会产生一个独立的实体。因此在本例中，<code>max()</code>会被编译出三个实体，因为它被用于三种类型。比如第一次调用时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">... <span class="function">ma</span></span><br><span class="line"><span class="function"><span class="title">x</span><span class="params">(<span class="number">7</span>,i)</span></span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure></p>
<p>函数模板的类型参数是<code>int</code>。因此语义上等效于调用了如下函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上用具体类型取代模板类型参数的过程叫做“实例化”。它会产生模板的一个实例。值得注意的是，模板的实例化不需要程序员做额外的请求，只是简单的使用函数模板就会触发这一实例化过程。</p>
<p>同样的，另外两次调用也会分别为<code>double</code>和<code>std::string</code>各实例化出一个实例，就像是分别定义了下面两个函数一样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">max</span> <span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">max</span> <span class="params">(std::string, std::string)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>另外，只要结果是有意义的，<code>void</code>作为模板参数也是有效的。比如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">(T*)</span></span></span><br><span class="line"><span class="function"></span>&#123; &#125;</span><br><span class="line"><span class="type">void</span>* vp = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">foo</span>(vp); <span class="comment">// OK:模板参数被推断为void</span></span><br><span class="line"><span class="built_in">foo</span>(<span class="type">void</span>*)</span><br></pre></td></tr></table></figure></p>
<h3 id="两阶段编译检查（Two-Phase-Translation-）"><a href="#两阶段编译检查（Two-Phase-Translation-）" class="headerlink" title="两阶段编译检查（Two-Phase Translation ）"></a>两阶段编译检查（Two-Phase Translation ）</h3><p>在实例化模板的时候，如果模板参数类型不支持所有模板中用到的操作符，将会遇到编译期错误。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::complex&lt;<span class="type">float</span>&gt; c1, c2; <span class="comment">// std::complex&lt;&gt;没有提供小于运算符</span></span><br><span class="line">... ::</span><br><span class="line"><span class="built_in">max</span>(c1,c2); <span class="comment">//编译期ERROR</span></span><br></pre></td></tr></table></figure></p>
<p>但是在定义的地方并没有遇到错误提示。这是因为模板是被分两步编译的：</p>
<ul>
<li>在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面：<ul>
<li>语法检查。比如少了分号。</li>
<li>使用了未定义的不依赖于模板参数的名称（类型名，函数名，……）。</li>
<li>未使用模板参数的static assertions。</li>
</ul>
</li>
<li>在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。</li>
</ul>
<p>比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">undeclared</span>(); <span class="comment">//如果undeclared()未定义，第一阶段就会报错，因为与模板参数无关</span></span><br><span class="line">    <span class="built_in">undeclared</span>(t); <span class="comment">//如果undeclared(t)未定义，第二阶段会报错，因为与模板参数有关</span></span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) &gt; <span class="number">10</span>,<span class="string">&quot;int too small&quot;</span>); <span class="comment">//与模板参数无关，总是报错</span></span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(T) &gt; <span class="number">10</span>, <span class="string">&quot;T too small&quot;</span>); <span class="comment">//与模板参数有关，只会在第二阶段报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>名称被检查两次这一现象被称为“两阶段查找”。需要注意的是，有些编译器并不会执行第一阶段中的所有检查。因此如果模板没有被至少实例化一次的话，你可能一直都不会发现代码中的常规错误。</p>
<h3 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h3><p>两阶段的编译检查给模板的处理带来了一个问题：当实例化一个模板的时候，编译器需要（一定程度上）看到模板的完整定义。这不同于函数编译和链接分离的思想，函数在编译阶段只需要声明就够了。</p>
<h2 id="模板参数推断"><a href="#模板参数推断" class="headerlink" title="模板参数推断"></a>模板参数推断</h2><p>当我们调用形如<code>max()</code>的函数模板来处理某些变量时，模板参数将由被传递的调用参数决定。如果我们传递两个int类型的参数给模板函数，C++编译器会将模板参数T推断为int。不过T可能只是实际传递的函数参数类型的一部分。比如我们定义了如下接受常量引用作为函数参数的模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T <span class="type">const</span>&amp; a, T <span class="type">const</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时如果我们传递int类型的调用参数，由于调用参数和<code>int const &amp;</code>匹配，类型参数<code>T</code>将被推断为int。</p>
<h3 id="类型推断中的类型转换"><a href="#类型推断中的类型转换" class="headerlink" title="类型推断中的类型转换"></a>类型推断中的类型转换</h3><p>在类型推断的时候自动的类型转换是受限制的：</p>
<ul>
<li>如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T定义的两个参数，它们实参的类型必须完全一样。</li>
<li>如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的： const和volatile限制符会被忽略，引用被转换成被引用的类型，raw array和函数被转换为相应的指针类型。</li>
<li>通过模板类型参数T定义的两个参数，它们实参的类型在退化（decay）后必须一样。</li>
</ul>
<p>例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b)</span></span>;</span><br><span class="line">... in</span><br><span class="line">    T <span class="type">const</span> c = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>; <span class="comment">//原书缺少i的定义</span></span><br><span class="line">    <span class="built_in">max</span>(i, c); <span class="comment">// OK: T被推断为int，c中的const被decay掉</span></span><br><span class="line">    <span class="built_in">max</span>(c, c); <span class="comment">// OK: T被推断为int</span></span><br><span class="line">    <span class="type">int</span>&amp; ir = i;</span><br><span class="line">    <span class="built_in">max</span>(i, ir); <span class="comment">// OK: T被推断为int，ir中的引用被decay掉</span></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">foo</span>(&amp;i, arr); <span class="comment">// OK: T被推断为int*</span></span><br></pre></td></tr></table></figure></p>
<p>但是像下面这样是错误的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(<span class="number">4</span>, <span class="number">7.2</span>); <span class="comment">// ERROR:不确定T该被推断为int还是double</span></span><br><span class="line">std::string s;</span><br><span class="line"><span class="built_in">foo</span>(<span class="string">&quot;hello&quot;</span>, s); <span class="comment">//ERROR:不确定T该被推断为const[6]还是std::string</span></span><br></pre></td></tr></table></figure></p>
<p>有两种办法解决以上错误：</p>
<ul>
<li>对参数做类型转换</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="number">4</span>), <span class="number">7.2</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<ul>
<li>显式地指出类型参数T的类型，这样编译器就不再会去做类型推导。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>&lt;<span class="type">double</span>&gt;(<span class="number">4</span>, <span class="number">7.2</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<ul>
<li>指明调用参数可能有不同的类型（多个模板参数）。</li>
</ul>
<h3 id="对默认调用参数的类型推断"><a href="#对默认调用参数的类型推断" class="headerlink" title="对默认调用参数的类型推断"></a>对默认调用参数的类型推断</h3><p>需要注意的是，类型推断并不适用于默认调用参数。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T = <span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>); <span class="comment">// OK: T被推断为int,调用f&lt;int&gt; (1)</span></span><br><span class="line"><span class="built_in">f</span>(); <span class="comment">// ERROR:无法推断T的类型</span></span><br></pre></td></tr></table></figure></p>
<p>为应对这一情况，你需要给模板类型参数也声明一个默认参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T </span>= std::string&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T = <span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">... <span class="built_in">f</span>(</span><br><span class="line">); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure></p>
<h2 id="多个模板参数"><a href="#多个模板参数" class="headerlink" title="多个模板参数"></a>多个模板参数</h2><p>目前我们看到了与函数模板相关的两组参数：</p>
<ol>
<li>模板参数，定义在函数模板前面的尖括号里：</li>
<li>调用参数，定义在函数模板名称后面的圆括号里：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// T是模板参数</span></span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b)</span> <span class="comment">// a和b是调用参数</span></span></span><br></pre></td></tr></table></figure>
<p>模板参数可以是一个或者多个。比如，你可以定义这样一个<code>max()</code>模板，它可能接受两个不同类型的调用参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">max</span> <span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m = ::<span class="built_in">max</span>(<span class="number">4</span>, <span class="number">7.2</span>); <span class="comment">// OK,但是返回类型是第一个模板参数T1的类型</span></span><br></pre></td></tr></table></figure></p>
<p>如果你使用其中一个类型参数的类型作为返回类型，当应该返回另一个类型的值的时候，返回值会被做类型转换。这将导致返回值的具体类型和参数的传递顺序有关。C++提供了多种应对这一问题的方法：</p>
<ol>
<li>引入第三个模板参数作为返回类型。</li>
<li>让编译器找出返回类型。</li>
<li>将返回类型定义为两个参数类型的“公共类型”</li>
</ol>
<p>下面将逐一进行讨论。</p>
<h3 id="作为返回类型的模板参数"><a href="#作为返回类型的模板参数" class="headerlink" title="作为返回类型的模板参数"></a>作为返回类型的模板参数</h3><p>我们可以不去显式的指出模板参数的类型。但是也提到，我们也可以显式的指出模板参数的类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b)</span></span>;</span><br><span class="line">... ::</span><br><span class="line"><span class="built_in">max</span>&lt;<span class="type">double</span>&gt;(<span class="number">4</span>, <span class="number">7.2</span>); <span class="comment">// max()被针对double实例化</span></span><br></pre></td></tr></table></figure></p>
<p>当模板参数和调用参数之间没有必然的联系，且模板参数不能确定的时候，就要显式的指明模板参数。比如你可以引入第三个模板来指定函数模板的返回类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> RT&gt;</span></span><br><span class="line"><span class="function">RT <span class="title">max</span> <span class="params">(T1 a, T2 b)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>但是模板类型推断不会考虑返回类型，而RT又没有被用作调用参数的类型。因此RT不会被推断。这样就必须显式的指明模板参数的类型。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> RT&gt;</span></span><br><span class="line"><span class="function">RT <span class="title">max</span> <span class="params">(T1 a, T2 b)</span></span>;</span><br><span class="line">... ::</span><br><span class="line"><span class="built_in">max</span>&lt;<span class="type">int</span>,<span class="type">double</span>,<span class="type">double</span>&gt;(<span class="number">4</span>, <span class="number">7.2</span>); <span class="comment">// OK,但是太繁琐</span></span><br></pre></td></tr></table></figure></p>
<p>另一种办法是只指定第一个模板参数的类型，其余参数的类型通过推断获得。通常而言，我们必须显式指定所有模板参数的类型，直到某一个模板参数的类型可以被推断出来为止。因此，如果你改变了上面例子中的模板参数顺序，调用时只需要指定返回值的类型就可以了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">RT <span class="title">max</span> <span class="params">(T1 a, T2 b)</span></span>;</span><br><span class="line">... ::</span><br><span class="line"><span class="built_in">max</span>&lt;<span class="type">double</span>&gt;(<span class="number">4</span>, <span class="number">7.2</span>) <span class="comment">//OK:返回类型是double，T1和T2根据调用参数推断</span></span><br></pre></td></tr></table></figure></p>
<p>在本例中，调用<code>max&lt;double&gt;</code>时，显式的指明了<code>RT</code>的类型是<code>double</code>，<code>T1</code>和<code>T2</code>则基于传入调用参数的类型被推断为<code>int</code>和<code>double</code>。然而改进版的<code>max()</code>并没有带来显著的变化。使用单模板参数的版本，即使传入的两个调用参数的类型不同，你依然可以显式的指定模板参数类型（也作为返回类型）</p>
<h3 id="返回类型推断"><a href="#返回类型推断" class="headerlink" title="返回类型推断"></a>返回类型推断</h3><p>如果返回类型是由模板参数决定的，那么推断返回类型最简单也是最好的办法就是让编译器来做这件事。从C++14开始，这成为可能，而且不需要把返回类型声明为任何模板参数类型（不过你需要声明返回类型为auto）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>事实上，在不使用尾置返回类型（trailing return type）的情况下将auto用于返回类型，要求返回类型必须能够通过函数体中的返回语句推断出来。当然，这首先要求返回类型能够从函数体中推断出来。因此，必须要有这样可以用来推断返回类型的返回语句，而且多个返回语句之间的推断结果必须一致。</p>
<p>在C++14之前，要想让编译器推断出返回类型，就必须让或多或少的函数实现成为函数声明的一部分。在C++11中，尾置返回类型（trailing return type）允许我们使用函数的调用参数。也就是说，我们可以基于运算符<code>?:</code>的结果声明返回类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> -&gt; <span class="title">decltype</span><span class="params">(b&lt;a?a:b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，返回类型是由运算符<code>?:</code>的结果决定的，这虽然复杂但是可以得到想要的结果。需要注意的是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> -&gt; <span class="title">decltype</span><span class="params">(b&lt;a?a:b)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>是一个声明，编译器在编译阶段会根据运算符<code>?:</code>的返回结果来决定实际的返回类型。不过具体的实现可以有所不同，事实上用true作为运算符<code>?:</code>的条件就足够了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> -&gt; <span class="title">decltype</span><span class="params">(<span class="literal">true</span>?a:b)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>但是在某些情况下会有一个严重的问题：由于T可能是引用类型，返回类型就也可能被推断为引用类型。因此你应该返回的是decay后的T，像下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> -&gt; <span class="keyword">typename</span> std::decay&lt;<span class="title">decltype</span><span class="params">(<span class="literal">true</span>? a:b)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里我们用到了类型萃取（type trait）<code>std::decay&lt;&gt;</code>，它返回其type成员作为目标类型，定义在标准库<code>&lt;type_trait&gt;</code>中。由于其type成员是一个类型，为了获取其结果，需要用关键字<code>typename</code>修饰这个表达式。</p>
<p>在这里请注意，在初始化auto变量的时候其类型总是退化之后了的类型。当返回类型是auto的时候也是这样。用auto作为返回结果的效果就像下面这样，a的类型将被推断为i退化后的类型，也就是int：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span>&amp; ir = i; <span class="comment">// ir是i的引用</span></span><br><span class="line"><span class="keyword">auto</span> a = ir; <span class="comment">// a的类型是it decay之后的类型，也就是int</span></span><br></pre></td></tr></table></figure></p>
<h3 id="将返回类型声明为公共类型（Common-Type）"><a href="#将返回类型声明为公共类型（Common-Type）" class="headerlink" title="将返回类型声明为公共类型（Common Type）"></a>将返回类型声明为公共类型（Common Type）</h3><p>从C++11开始，标准库提供了一种指定“更一般类型”的方式。<code>std::common_type&lt;&gt;::type</code>产生的类型是他的两个模板参数的公共类型。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">std::<span class="type">common_type_t</span>&lt;T1,T2&gt; <span class="title">max</span> <span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样的，<code>std::common_type</code>也是一个类型萃取（type trait），定义在<code>&lt;type_traits&gt;</code>中，它返回一个结构体，结构体的type成员被用作目标类型。因此其主要应用场景如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> std::common_type&lt;T1,T2&gt;::type <span class="comment">//since C++11</span></span><br></pre></td></tr></table></figure></p>
<p>不过从C++14开始，你可以简化“萃取”的用法，只要在后面加个<code>_t</code>，就可以省掉<code>typename</code>和<code>::type</code>，简化后的版本变成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="type">common_type_t</span>&lt;T1,T2&gt; <span class="comment">// equivalent since C++14</span></span><br></pre></td></tr></table></figure></p>
<p><code>std::common_type&lt;&gt;</code>的实现用到了一些比较取巧的模板编程手法。它根据运算符<code>?:</code>的语法规则或者对某些类型的特化来决定目标类型。因此<code>::max(4, 7.2)</code>和<code>::max(7.2, 4)</code>都返回double类型的7.2。需要注意的是，<code>std::common_type&lt;&gt;</code>的结果也是退化的。</p>
<h2 id="默认模板参数"><a href="#默认模板参数" class="headerlink" title="默认模板参数"></a>默认模板参数</h2><p>这些默认值被称为默认模板参数并且可以用于任意类型的模板。它们甚至可以根据其前面的模板参数来决定自己的类型。比如如果你想将前述定义返回类型的方法和多模板参数一起使用，你可以为返回类型引入一个模板参数RT，并将其默认类型声明为其它两个模板参数的公共类型。同样地，我们也有多种实现方法：</p>
<p>我们可以直接使用运算符<code>?:</code>。不过由于我们必须在调用参数a和b被声明之前使用运算符<code>?:</code>，我们只能像下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> RT =</span><br><span class="line">std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(<span class="literal">true</span> ? <span class="built_in">T1</span>() : <span class="built_in">T2</span>())&gt;&gt;</span><br><span class="line">RT <span class="built_in">max</span> (T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请注意在这里我们用到了<code>std::decay_t&lt;&gt;</code>来确保返回的值不是引用类型。同样值得注意的是，这一实现方式要求我们能够调用两个模板参数的默认构造参数。还有另一种方法，使用<code>std::declval</code>，不过这将使得声明部分变得更加复杂。</p>
<p>我们也可以利用类型萃取<code>std::common_type&lt;&gt;</code>作为返回类型的默认值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> RT =</span><br><span class="line">std::<span class="type">common_type_t</span>&lt;T1,T2&gt;&gt;</span><br><span class="line">RT <span class="built_in">max</span> (T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里<code>std::common_type&lt;&gt;</code>也是会做类型退化的，因此返回类型不会是引用。</p>
<p>在以上两种情况下，作为调用者，你即可以使用RT的默认值作为返回类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = ::<span class="built_in">max</span>(<span class="number">4</span>, <span class="number">7.2</span>);</span><br></pre></td></tr></table></figure></p>
<p>也可以显式的指出所有的模板参数的类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = ::<span class="built_in">max</span>&lt;<span class="type">double</span>,<span class="type">int</span>,<span class="type">long</span> <span class="type">double</span>&gt;(<span class="number">7.2</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure></p>
<p>但是，我们再次遇到这样一个问题：为了显式指出返回类型，我们必须显式的指出全部三个模板参数的类型。因此我们希望能够将返回类型作为第一个模板参数，并且依然能够从其它两个模板参数推断出它的类型。</p>
<p>原则上这是可行的，即使后面的模板参数没有默认值，我们依然可以让第一个模板参数有默认值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT </span>= <span class="type">long</span>, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">RT <span class="title">max</span> <span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于这个定义，你可以这样调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i; <span class="type">long</span> l;</span><br><span class="line">... <span class="function">ma</span></span><br><span class="line"><span class="function"><span class="title">x</span><span class="params">(i, l)</span></span>; <span class="comment">//返回值类型是long (RT的默认值)</span></span><br><span class="line"><span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">42</span>); <span class="comment">//返回int，因为其被显式指定</span></span><br></pre></td></tr></table></figure></p>
<h2 id="函数模板的重载"><a href="#函数模板的重载" class="headerlink" title="函数模板的重载"></a>函数模板的重载</h2><p>定义多个有相同函数名的函数，当实际调用的时候，由C++编译器负责决定具体该调用哪一个函数。即使在不考虑模板的时候，这一决策过程也可能异常复杂。下面几行程序展示了函数模板的重载：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maximum of two int values:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// maximum of two values of any type:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ::<span class="built_in">max</span>(<span class="number">7</span>, <span class="number">42</span>); <span class="comment">// calls the nontemplate for two ints</span></span><br><span class="line">    ::<span class="built_in">max</span>(<span class="number">7.0</span>, <span class="number">42.0</span>); <span class="comment">// calls max&lt;double&gt; (by argument deduction)</span></span><br><span class="line">    ::<span class="built_in">max</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>); <span class="comment">//calls max&lt;char&gt; (by argument deduction)</span></span><br><span class="line">    ::max&lt;&gt;(<span class="number">7</span>, <span class="number">42</span>); <span class="comment">// calls max&lt;int&gt; (by argumentdeduction)</span></span><br><span class="line">    ::<span class="built_in">max</span>&lt;<span class="type">double</span>&gt;(<span class="number">7</span>, <span class="number">42</span>); <span class="comment">// calls max&lt;double&gt; (no argumentdeduction)</span></span><br><span class="line">    ::<span class="built_in">max</span>(<span class="string">&quot;a&quot;</span>, <span class="number">42.7</span>); <span class="comment">//calls the nontemplate for two ints</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如你所见，一个非模板函数可以和一个与其同名的函数模板共存，并且这个同名的函数模板可以被实例化为与非模板函数具有相同类型的调用参数。在所有其它因素都相同的情况下，模板解析过程将优先选择非模板函数，而不是从模板实例化出来的函数。第一个调用就属于这种情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::<span class="built_in">max</span>(<span class="number">7</span>, <span class="number">42</span>); <span class="comment">// both int values match the nontemplate function perfectly</span></span><br></pre></td></tr></table></figure></p>
<p>如果模板可以实例化出一个更匹配的函数，那么就会选择这个模板。正如第二和第三次调用<code>max()</code>时那样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">::<span class="built_in">max</span>(<span class="number">7.0</span>, <span class="number">42.0</span>); <span class="comment">// calls the max&lt;double&gt; (by argument deduction)</span></span><br><span class="line">::<span class="built_in">max</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>); <span class="comment">//calls the max&lt;char&gt; (by argument deduction)</span></span><br></pre></td></tr></table></figure></p>
<p>在这里模板更匹配一些，因为它不需要从double和char到int的转换。</p>
<p>也可以显式指定一个空的模板列表。这表明它会被解析成一个模板调用，其所有的模板参数会被通过调用参数推断出来：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::max&lt;&gt;(<span class="number">7</span>, <span class="number">42</span>); <span class="comment">// calls max&lt;int&gt; (by argument deduction)</span></span><br></pre></td></tr></table></figure></p>
<p>由于在模板参数推断时不允许自动类型转换，而常规函数是允许的，因此最后一个调用会选择非模板参函数（‘a’和42.7都被转换成int）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::<span class="built_in">max</span>(<span class="string">&quot;a&quot;</span>, <span class="number">42.7</span>); <span class="comment">//only the nontemplate function allows nontrivial conversions</span></span><br></pre></td></tr></table></figure></p>
<p>一个有趣的例子是我们可以专门为<code>max()</code>实现一个可以显式指定返回值类型的模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">RT <span class="title">max</span> <span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们可以像下面这样调用<code>max()</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = ::<span class="built_in">max</span>(<span class="number">4</span>, <span class="number">7.2</span>); <span class="comment">// uses first template</span></span><br><span class="line"><span class="keyword">auto</span> b = ::<span class="built_in">max</span>&lt;<span class="type">long</span> <span class="type">double</span>&gt;(<span class="number">7.2</span>, <span class="number">4</span>); <span class="comment">// uses second template</span></span><br></pre></td></tr></table></figure></p>
<p>但是像下面这样调用的话：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> c = ::<span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">7.2</span>); <span class="comment">// ERROR: both function templates match</span></span><br></pre></td></tr></table></figure></p>
<p>两个模板都是匹配的，这会导致模板解析过程不知道该调用哪一个模板，从而导致未知错误。因此当重载函数模板的时候，你要保证对任意一个调用，都只会有一个模板匹配。一个比较有用的例子是为指针和C字符串重载<code>max()</code>模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// maximum of two values of any type:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// maximum of two pointers:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T* <span class="title">max</span> <span class="params">(T* a, T* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *b &lt; *a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// maximum of two C-strings:</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="type">const</span>* <span class="title">max</span> <span class="params">(<span class="type">char</span> <span class="type">const</span>* a, <span class="type">char</span> <span class="type">const</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">strcmp</span>(b,a) &lt; <span class="number">0</span> ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> m1 = ::<span class="built_in">max</span>(a,b); <span class="comment">// max() for two values of type int</span></span><br><span class="line">    std::string s1 = <span class="string">&quot;hey&quot;</span>; <span class="string">&quot;</span></span><br><span class="line"><span class="string">    std::string s2 = &quot;</span>yo<span class="string">u&quot;; &quot;</span></span><br><span class="line">    <span class="keyword">auto</span> m2 = ::<span class="built_in">max</span>(s1,s2); <span class="comment">// max() for two values of type std::string</span></span><br><span class="line">    <span class="type">int</span>* p1 = &amp;b;</span><br><span class="line">    <span class="type">int</span>* p2 = &amp;a;</span><br><span class="line">    <span class="keyword">auto</span> m3 = ::<span class="built_in">max</span>(p1,p2); <span class="comment">// max() for two pointers</span></span><br><span class="line">    <span class="type">char</span> <span class="type">const</span>* x = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span>* y = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> m4 = ::<span class="built_in">max</span>(x,y); <span class="comment">// max() for two C-strings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意上面所有<code>max()</code>的重载模板中，调用参数都是按值传递的。通常而言，在重载模板的时候，要尽可能少地做改动。你应该只是改变模板参数的个数或者显式的指定某些模板参数。</p>
<p>否则，可能会遇到意想不到的问题。比如，如果你实现了一个按引用传递的<code>max()</code>模板，然后又重载了一个按值传递两个C字符串作为参数的模板，你不能用接受三个参数的模板来计算三个C字符串的最大值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="comment">// maximum of two values of any type (call-by-reference)</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;typenameT&gt; T <span class="type">const</span>&amp; <span class="title">max</span> <span class="params">(T <span class="type">const</span>&amp; a, T <span class="type">const</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// maximum of two C-strings (call-by-value)</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="type">const</span>* <span class="title">max</span> <span class="params">(<span class="type">char</span> <span class="type">const</span>* a, <span class="type">char</span> <span class="type">const</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">strcmp</span>(b,a) &lt; <span class="number">0</span> ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// maximum of three values of any type (call-by-reference)</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="type">const</span>&amp; <span class="title">max</span> <span class="params">(T <span class="type">const</span>&amp; a, T <span class="type">const</span>&amp; b, T <span class="type">const</span>&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span> (<span class="built_in">max</span>(a,b), c); <span class="comment">// error if max(a,b) uses call-by-value</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> m1 = ::<span class="built_in">max</span>(<span class="number">7</span>, <span class="number">42</span>, <span class="number">68</span>); <span class="comment">// OK</span></span><br><span class="line">    <span class="type">char</span> <span class="type">const</span>* s1 = <span class="string">&quot;frederic&quot;</span>;</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span>* s2 = <span class="string">&quot;anica&quot;</span>;</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span>* s3 = <span class="string">&quot;lucas&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> m2 = ::<span class="built_in">max</span>(s1, s2, s3); <span class="comment">//run-time ERROR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>问题在于当用三个C字符串作为参数调用<code>max()</code>的时候，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">max</span> (<span class="built_in">max</span>(a,b), c);</span><br></pre></td></tr></table></figure></p>
<p>会遇到run-time error，这是因为对C字符串，<code>max(max(a, b), c)</code>会创建一个用于返回的临时局部变量，而在返回语句接受后，这个临时变量会被销毁，导致<code>max()</code>使用了一个悬空的引用。不幸的是，这个错误几乎在所有情况下都不太容易被发现。</p>
<p>作为对比，在求三个int最大值的<code>max()</code>调用中，则不会遇到这个问题。这里虽然也会创建三个临时变量，但是这三个临时变量是在<code>main()</code>里面创建的，而且会一直持续到语句结束。这只是模板解析规则和期望结果不一致的一个例子。再者，需要确保函数模板在被调用时，其已经在前方某处定义。这是由于在我们调用某个模板时，其相关定义不一定是可见的。比如我们定义了一个三参数的<code>max()</code>，由于它看不到适用于两个int的<code>max()</code>，因此它最终会调用两个参数的模板函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// maximum of two values of any type:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;max&lt;T&gt;() \n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// maximum of three values of any type:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b, T c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span> (<span class="built_in">max</span>(a,b), c); <span class="comment">// uses the template version even for ints</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//because the following declaration comes</span></span><br><span class="line"><span class="comment">// too late:</span></span><br><span class="line"><span class="comment">// maximum of two int values:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;max(int,int) \n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ::<span class="built_in">max</span>(<span class="number">47</span>,<span class="number">11</span>,<span class="number">33</span>); <span class="comment">// OOPS: uses max&lt;T&gt;() instead of max(int,int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="难道，我们不应该…？"><a href="#难道，我们不应该…？" class="headerlink" title="难道，我们不应该…？"></a>难道，我们不应该…？</h2><h2 id="按值传递还是按引用传递？"><a href="#按值传递还是按引用传递？" class="headerlink" title="按值传递还是按引用传递？"></a>按值传递还是按引用传递？</h2><p>通常而言，建议将按引用传递用于除简单类型（比如基础类型和<code>std::string_view</code>）以外的类型，这样可以免除不必要的拷贝成本。不过出于以下原因，按值传递通常更好一些：</p>
<ul>
<li>语法简单。</li>
<li>编译器能够更好地进行优化。</li>
<li>移动语义通常使拷贝成本比较低。</li>
<li>某些情况下可能没有拷贝或者移动。</li>
</ul>
<p>再有就是，对于模板，还有一些特有情况：</p>
<ul>
<li>模板既可以用于简单类型，也可以用于复杂类型，因此如果默认选择适合于复杂类型可能方式，可能会对简单类型产生不利影响。</li>
<li>作为调用者，你通常可以使用<code>std::ref()</code>和<code>std::cref()</code>来按引用传递参数。</li>
<li>虽然按值传递string literal和raw array经常会遇到问题，但是按照引用传递它们通常只会遇到更大的问题。</li>
</ul>
<h3 id="为什么不适用inline？"><a href="#为什么不适用inline？" class="headerlink" title="为什么不适用inline？"></a>为什么不适用inline？</h3><p>通常而言，函数模板不需要被声明成inline。不同于非inline函数，我们可以把非inline的函数模板定义在头文件里，然后在多个编译单元里include这个文件。唯一一个例外是模板对某些类型的全特化，这时候最终的code不在是“泛型”的。</p>
<p>严格地从语言角度来看，inline只意味着在程序中函数的定义可以出现很多次。不过它也给了编译器一个暗示，在调用该函数的地方函数应该被展开成inline的：这样做在某些情况下可以提高效率，但是在另一些情况下也可能降低效率。现代编译器在没有关键字inline暗示的情况下，通常也可以很好的决定是否将函数展开成inline的。</p>
<h3 id="为什么不用constexpr？"><a href="#为什么不用constexpr？" class="headerlink" title="为什么不用constexpr？"></a>为什么不用constexpr？</h3><p>从C++11开始，你可以通过使用关键字constexpr来在编译阶段进行某些计算。对于很多模板，这是有意义的。比如为了可以在编译阶段使用求最大值的函数，你必须将其定义成下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如此你就可以在编译阶段的上下文中，实时地使用这个求最大值的函数模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[::<span class="built_in">max</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>),<span class="number">1000u</span>)];</span><br></pre></td></tr></table></figure></p>
<p>或者指定<code>std::array&lt;&gt;</code>的大小：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;std::string, ::max(<span class="keyword">sizeof</span>(<span class="type">char</span>),1000u)&gt; arr;</span><br></pre></td></tr></table></figure></p>
<p>在这里我们传递的1000是unsigned int类型，这样可以避免直接比较一个有符号数值和一个无符号数值时产生的警报。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>函数模板定义了一组适用于不同类型的函数。</li>
<li>当向模板函数传递变量时，函数模板会自行推断模板参数的类型，来决定去实例化出那种类型的函数。</li>
<li>你也可以显式的指出模板参数的类型。</li>
<li>你可以定义模板参数的默认值。这个默认值可以使用该模板参数前面的模板参数的类型，而且其后面的模板参数可以没有默认值。</li>
<li>函数模板可以被重载。</li>
<li>当定义新的函数模板来重载已有的函数模板时，必须要确保在任何调用情况下都只有一个模板是最匹配的。</li>
<li>当你重载函数模板的时候，最好只是显式地指出了模板参数得了类型。</li>
<li>确保在调用某个函数模板之前，编译器已经看到了相对应的模板定义。</li>
</ul>
<h1 id="类模板（Class-Templates）"><a href="#类模板（Class-Templates）" class="headerlink" title="类模板（Class Templates）"></a>类模板（Class Templates）</h1><p>和函数类似，类也可以被一个或多个类型参数化。容器类（Container classes）就是典型的一个例子，它可以被用来处理某一指定类型的元素。</p>
<h2 id="Stack类模板的实现"><a href="#Stack类模板的实现" class="headerlink" title="Stack类模板的实现"></a>Stack类模板的实现</h2><p>和函数模板一样，我们把类模板<code>Stack&lt;&gt;</code>的声明和定义都放在头文件里：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T&gt; elems; <span class="comment">// elements</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; elem)</span></span>; <span class="comment">// push element</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element</span></span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// return top element</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">push</span> (T <span class="type">const</span>&amp; elem)</span><br><span class="line">&#123;</span><br><span class="line">    elems.<span class="built_in">push_back</span>(elem); <span class="comment">// append copy of passed elem</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">pop</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());</span><br><span class="line">    elems.<span class="built_in">pop_back</span>(); <span class="comment">// remove last element</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T <span class="type">const</span>&amp; Stack&lt;T&gt;::<span class="built_in">top</span> () <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">return</span> elems.<span class="built_in">back</span>(); <span class="comment">// return copy of last element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，这个类模板是通过使用一个C++标准库的类模板<code>vector&lt;&gt;</code>实现的。这样我们就不需要自己来实现内存管理，拷贝构造函数和赋值构造函数了，从而可以把更多的精力放在这个类模板的接口实现上。</p>
<h3 id="声明一个类模板"><a href="#声明一个类模板" class="headerlink" title="声明一个类模板"></a>声明一个类模板</h3><p>声明类模板和声明函数模板类似：在开始定义具体内容之前，需要先声明一个或者多个作为模板的类型参数的标识符。同样地，这一标识符通常用T表示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这里，同样可以用关键字<code>class</code>取代<code>typename</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在类模板内部，T可以像普通类型一样被用来声明成员变量和成员函数。在这个例子中，T被用于声明vector中元素的类型，用于声明成员函数<code>push()</code>的参数类型，也被用于成员函数<code>top</code>的返回类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T&gt; elems; <span class="comment">// elements</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; elem)</span></span>; <span class="comment">// push element</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element</span></span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// return top element</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个类的类型是<code>Stack&lt;T&gt;</code>，其中T是模板参数。在将这个<code>Stack&lt;T&gt;</code>类型用于声明的时候，除非可以推断出模板参数的类型，否则就必须使用<code>Stack&lt;T&gt;</code>（Stack后面必须跟着<code>&lt;T&gt;</code>）。不过，如果在类模板内部使用<code>Stack</code>而不是<code>Stack&lt;T&gt;</code>，表明这个内部类的模板参数类型和模板<br>类的参数类型相同。</p>
<p>比如，如果需要定义自己的复制构造函数和赋值构造函数，通常应该定义成这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    ... <span class="built_in">Stack</span> (Stack <span class="type">const</span>&amp;); <span class="comment">// copy constructor</span></span><br><span class="line">    Stack&amp; <span class="keyword">operator</span>= (Stack <span class="type">const</span>&amp;); <span class="comment">// assignment operator</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>它和下面的定义是等效的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    ... <span class="built_in">Stack</span> (Stack&lt;T&gt; <span class="type">const</span>&amp;); <span class="comment">// copy constructor</span></span><br><span class="line">    Stack&lt;T&gt;&amp; <span class="keyword">operator</span>= (Stack&lt;T&gt; <span class="type">const</span>&amp;); <span class="comment">// assignment operator</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一般<code>&lt;T&gt;</code>暗示要对某些模板参数做特殊处理，所以最好还是使用第一种方式。但是如果在类模板的外面，就需要这样定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>== (Stack&lt;T&gt; <span class="type">const</span>&amp; lhs, Stack&lt;T&gt; <span class="type">const</span>&amp; rhs);</span><br></pre></td></tr></table></figure></p>
<p>注意在只需要类的名字而不是类型的地方，可以只用Stack。这和声明构造函数和析构函数的情况相同。</p>
<p>另外，不同于非模板类，不可以在函数内部或者块作用域内（{…}）声明和定义模板。通常模板只能定义在global/namespace作用域，或者是其它类的声明里面。</p>
<h3 id="成员函数的实现"><a href="#成员函数的实现" class="headerlink" title="成员函数的实现"></a>成员函数的实现</h3><p>定义类模板的成员函数时，必须指出它是一个模板，也必须使用该类模板的所有类型限制。因此，要像下面这样定义<code>Stack&lt;T&gt;</code>的成员函数<code>push()</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">push</span> (T <span class="type">const</span>&amp; elem)</span><br><span class="line">&#123;</span><br><span class="line">    elems.<span class="built_in">push_back</span>(elem); <span class="comment">// append copy of passed elem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用了其<code>vector</code>成员的<code>push_back()</code>方法，它向vector的尾部追加一个元素。注意<code>vector</code>的<code>pop_back()</code>方法只是删除掉尾部的元素，并不会返回这一元素。这主要是为了异常安全（exception safety）。不过如果忽略掉这一风险，我们依然可以实现一个返回被删除元素的<code>pop()</code>。为了达到这一目的，我们只需要用T定义一个和vector元素有相同类型的局部变量就可以了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T Stack&lt;T&gt;::<span class="built_in">pop</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());</span><br><span class="line">    T elem = elems.<span class="built_in">back</span>(); <span class="comment">// save copy of last element</span></span><br><span class="line">    elems.<span class="built_in">pop_back</span>(); <span class="comment">// remove last element</span></span><br><span class="line">    <span class="keyword">return</span> elem; <span class="comment">// return copy of saved element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于<code>vector</code>的<code>back()</code>（返回其最后一个元素）和<code>pop_back()</code>（删除最后一个元素）方法在vector为空的时候行为未定义，因此需要对vector是否为空进行测试。在程序中我们断言（assert）vector不能为空，这样可以确保不会对空的Stack调用<code>pop()</code>方法。在<code>top()</code>中也是这样，它返回但是不删除首元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T <span class="type">const</span>&amp; Stack&lt;T&gt;::<span class="built_in">top</span> () <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">return</span> elems.<span class="built_in">back</span>(); <span class="comment">// return copy of last element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，就如同其它成员函数一样，你也可以把类模板的成员函数以内联函数的形式实现在类模板的内部。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span> <span class="params">(T <span class="type">const</span>&amp; elem)</span> </span>&#123;</span><br><span class="line">        elems.<span class="built_in">push_back</span>(elem); <span class="comment">// append copy of passed elem</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Stack类模板的使用"><a href="#Stack类模板的使用" class="headerlink" title="Stack类模板的使用"></a>Stack类模板的使用</h2><p>直到C++17，在使用类模板的时候都需要显式的指明模板参数。下面的例子展示了该如何使用<code>Stack&lt;&gt;</code>类模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack1.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack&lt;<span class="type">int</span>&gt; intStack; <span class="comment">// stack of ints</span></span><br><span class="line">    Stack&lt;std::string&gt; stringStack; <span class="comment">// stack of strings</span></span><br><span class="line">    <span class="comment">// manipulate int stack</span></span><br><span class="line">    intStack.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">    std::cout &lt;&lt; intStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// manipulate string stack</span></span><br><span class="line">    stringStack.<span class="built_in">push</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; stringStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    stringStack.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过声明<code>Stack&lt;int&gt;</code>类型，在类模板内部int会被用作类型<code>T</code>。被创建的<code>instStack</code>会使用一个存储<code>int</code>的vector作为其<code>elems</code>成员，而且所有被用到的成员函数都会被用int实例化。同样的，对于用<code>Stack&lt;std::string&gt;</code>定义的对象，它会使用一个存储<code>std::string</code>的vector作为其<code>elems</code>成员，所有被用到的成员函数也都会用<code>std::string</code>实例化。注意，模板函数和模板成员函数只有在被调用的时候才会实例化。这样一方面会节省时间和空间，同样也允许只是部分的使用类模板。在这个例子中，对<code>int</code>和<code>std::string</code>，默认构造函数，<code>push()</code>以及<code>top()</code>函数都会被实例化。而<code>pop()</code>只会针对<code>std::string</code>实例化。如果一个类模板有static成员，对每一个用到这个类模板的类型，相应的静态成员也只会被实例化一次。</p>
<p>被实例化之后的类模板类型（<code>Stack&lt;int&gt;</code>之类）可以像其它常规类型一样使用。可以用<code>const</code>以及<code>volatile</code>修饰它，或者用它来创建数组和引用。可以通过typedef和using将它用于类型定义的一部分，也可以用它来实例化其它的模板类型。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(Stack &lt;<span class="type">int</span>&gt; <span class="type">const</span>&amp; s)</span> <span class="comment">// parameter s is int stack</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> IntStack = Stack &lt;<span class="type">int</span>&gt;; <span class="comment">// IntStack is another name for</span></span><br><span class="line">    Stack&lt;<span class="type">int</span>&gt;</span><br><span class="line">    Stack&lt; <span class="type">int</span>&gt; istack[<span class="number">10</span>]; <span class="comment">// istack is array of 10 int stacks</span></span><br><span class="line">    IntStack istack2[<span class="number">10</span>]; <span class="comment">// istack2 is also an array of 10 int stacks (same type)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>模板参数可以是任意类型，比如指向float的指针，甚至是存储int的stack:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="type">float</span>*&gt; floatPtrStack; <span class="comment">// stack of float pointers</span></span><br><span class="line">Stack&lt;Stack&lt;<span class="type">int</span>&gt;&gt; intStackStack; <span class="comment">// stack of stack of ints</span></span><br></pre></td></tr></table></figure></p>
<p>模板参数唯一的要求是：它要支持模板中被用到的各种操作（运算符）。</p>
<h2 id="部分地使用类模板"><a href="#部分地使用类模板" class="headerlink" title="部分地使用类模板"></a>部分地使用类模板</h2><p>一个类模板通常会对用来实例化它的类型进行多种操作（包含构造函数和析构函数）。这可能会让你以为，要为模板参数提供所有被模板成员函数用到的操作。但是事实不是这样：模板参数只需要提供那些会被用到的操作（而不是可能会被用到的操作）。比如<code>Stack&lt;&gt;</code>类可能会提供一个成员函数<code>printOn()</code>来打印整个stack的内容，它会调用<code>operator &lt;&lt;</code>来依次打印每一个元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printOn</span><span class="params">()</span> <span class="params">(std::ostream&amp; strm)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T <span class="type">const</span>&amp; elem : elems) &#123;</span><br><span class="line">            strm &lt;&lt; elem &lt;&lt; <span class="string">&quot;&quot;</span>; <span class="comment">// call &lt;&lt; for each element</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个类依然可以用于那些没有提供<code>operator &lt;&lt;</code>运算符的元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;std::pair&lt; <span class="type">int</span>, <span class="type">int</span>&gt;&gt; ps; <span class="comment">// note: std::pair&lt;&gt; has no operator&lt;&lt; defined</span></span><br><span class="line">ps.<span class="built_in">push</span>(&#123;<span class="number">4</span>, <span class="number">5</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">ps.<span class="built_in">push</span>(&#123;<span class="number">6</span>, <span class="number">7</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">std::cout &lt;&lt; ps.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// OK</span></span><br><span class="line">std::cout &lt;&lt; ps.<span class="built_in">top</span>().second &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure></p>
<p>只有在调用<code>printOn()</code>的时候，才会导致错误，因为它无法为这一类型实例化出对<code>operator&lt;&lt;</code>的调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps.<span class="built_in">printOn</span>(std::cout); <span class="comment">// ERROR: operator&lt;&lt; not supported for element type</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h3><p>这样就有一个问题：我们如何才能知道为了实例化一个模板需要哪些操作？名词concept通常被用来表示一组反复被模板库要求的限制条件。例如C++标准库是基于这样一些concepts的：可随机进入的迭代器（random access iterator）和可默认构造的（default constructible）。</p>
<p>从C++11开始，你至少可以通过关键字<code>static_assert</code>和其它一些预定义的类型萃取（type traits）来做一些简单的检查。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_default_constructible&lt;T&gt;::value,</span><br><span class="line">    <span class="string">&quot;Class C requires default-constructible elements&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>即使没有这个<code>static_assert</code>，如果需要T的默认构造函数的话，依然会遇到编译错误。然而还有更复杂的情况需要检查，比如模板类型T的实例需要提供一个特殊的成员函数，或者需要能够通过<code>operator &lt;</code>进行比较。</p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>相比于通过<code>printOn()</code>来打印stack的内容，更好的办法是去重载stack的<code>operator &lt;&lt;</code>运算符。而且和非模板类的情况一样，<code>operator&lt;&lt;</code>应该被实现为非成员函数，在其实现中可以调用<code>printOn()</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printOn</span><span class="params">()</span> <span class="params">(std::ostream&amp; strm)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp; strm, Stack&lt;T&gt; <span class="type">const</span>&amp; s) &#123;</span><br><span class="line">        s.<span class="built_in">printOn</span>(strm);</span><br><span class="line">        <span class="keyword">return</span> strm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意在这里<code>Stack&lt;&gt;</code>的<code>operator&lt;&lt;</code>并不是一个函数模板，而是在需要的时候，随类模板实例化出来的一个常规函数。然而如果你试着先声明一个友元函数，然后再去定义它，情况会变的很复杂。</p>
<p>事实上我们有两种选择：</p>
<ul>
<li>可以隐式的声明一个新的函数模板，但是必须使用一个不同于类模板的模板参数，比如用U：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp;, Stack&lt;U&gt; <span class="type">const</span>&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>无论是继续使用T还是省略掉模板参数声明，都不可以（要么是里面的T隐藏了外面的T，要么是在命名空间作用域内声明了一个非模板函数）。</p>
<ul>
<li>也可以先将<code>Stack&lt;T&gt;</code>的<code>operator&lt;&lt;</code>声明为一个模板，这要求先对<code>Stack&lt;T&gt;</code>进行声明：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp;, Stack&lt;T&gt; <span class="type">const</span>&amp;);</span><br></pre></td></tr></table></figure>
<p>接着就可以将这一模板声明为<code>Stack&lt;T&gt;</code>的友元：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;T&gt; (std::ostream&amp;, Stack&lt;T&gt; <span class="type">const</span>&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意这里在<code>operator&lt;&lt;</code>后面用了<code>&lt;T&gt;</code>，这相当于声明了一个特例化之后的非成员函数模板作为友元。如果没有<code>&lt;T&gt;</code>的话，则相当于定义了一个新的非模板函数。</p>
<p>无论如何，你依然可以将<code>Stack&lt;T&gt;</code>用于没有定义<code>operator &lt;&lt;</code>的元素，只是当你调用<code>operator&lt;&lt;</code>的时候会遇到一个错误：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;std::pair&lt; <span class="type">int</span>, <span class="type">int</span>&gt;&gt; ps; <span class="comment">// std::pair&lt;&gt; has no operator&lt;&lt; defined</span></span><br><span class="line">ps.<span class="built_in">push</span>(&#123;<span class="number">4</span>, <span class="number">5</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">ps.<span class="built_in">push</span>(&#123;<span class="number">6</span>, <span class="number">7</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">std::cout &lt;&lt; ps.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// OK</span></span><br><span class="line">std::cout &lt;&lt; ps.<span class="built_in">top</span>().second &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// OK</span></span><br><span class="line">std::cout &lt;&lt; ps &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// ERROR: operator&lt;&lt; not supported for element type</span></span><br></pre></td></tr></table></figure></p>
<h2 id="模板类的特例化"><a href="#模板类的特例化" class="headerlink" title="模板类的特例化"></a>模板类的特例化</h2><p>可以对类模板的某一个模板参数进行特化。和函数模板的重载类似，类模板的特化允许我们对某一特定类型做优化，或者去修正类模板针对某一特定类型实例化之后的行为。不过如果对类模板进行了特化，那么也需要去特化所有的成员函数。为了特化一个类模板，在类模板声明的前面需要有一个<code>template&lt;&gt;</code>，并且需要指明所希望特化的类型。这些用于特化类模板的类型被用作模板参数，并且需要紧跟在类名的后面：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&lt;std::string&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于被特化的模板，所有成员函数的定义都应该被定义成“常规”成员函数，也就是说所有出现T的地方，都应该被替换成用于特化类模板的类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> Stack&lt;std::string&gt;::<span class="built_in">push</span> (std::string <span class="type">const</span>&amp; elem)</span><br><span class="line">&#123;</span><br><span class="line">    elems.<span class="built_in">push_back</span>(elem); <span class="comment">// append copy of passed elem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是一个用<code>std::string</code>实例化<code>Stack&lt;&gt;</code>类模板的完整例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack1.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&lt;std::string&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::deque&lt;std::string&gt; elems; <span class="comment">// elements</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(std::string <span class="type">const</span>&amp;)</span></span>; <span class="comment">// push element</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element</span></span><br><span class="line">    <span class="function">std::string <span class="type">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// return top element</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> Stack&lt;std::string&gt;::<span class="built_in">push</span> (std::string <span class="type">const</span>&amp; elem)</span><br><span class="line">&#123;</span><br><span class="line">    elems.<span class="built_in">push_back</span>(elem); <span class="comment">// append copy of passed elem</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> Stack&lt;std::string&gt;::<span class="built_in">pop</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());</span><br><span class="line">    elems.<span class="built_in">pop_back</span>(); <span class="comment">// remove last element</span></span><br><span class="line">&#125;</span><br><span class="line">std::string <span class="type">const</span>&amp; Stack&lt;std::string&gt;::<span class="built_in">top</span> () <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">return</span> elems.<span class="built_in">back</span>(); <span class="comment">// return copy of last element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，特例化之后的类在向<code>push()</code>传递参数的时候使用了引用语义，对当前<code>std::string</code>类型这是有意义的，这可以提高性能。</p>
<p>另一个不同是使用了一个<code>deque</code>而不再是<code>vector</code>来存储<code>stack</code>里面的元素。虽然这样做可能不会有什么好处，不过这能够说明，模板类特例化之后的实现可能和模板类的原始实现有很大不同。</p>
<h2 id="部分特例化"><a href="#部分特例化" class="headerlink" title="部分特例化"></a>部分特例化</h2><p>类模板可以只被部分的特例化。这样就可以为某些特殊情况提供特殊的实现，不过使用者还是要定义一部分模板参数。比如，可以特殊化一个<code>Stack&lt;&gt;</code>来专门处理指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack1.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// partial specialization of class Stack&lt;&gt; for pointers:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&lt;T*&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T*&gt; elems; <span class="comment">// elements</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T*)</span></span>; <span class="comment">// push element</span></span><br><span class="line">    <span class="function">T* <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element</span></span><br><span class="line">    <span class="function">T* <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// return top element</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T*&gt;::<span class="built_in">push</span> (T* elem)</span><br><span class="line">&#123;</span><br><span class="line">    elems.<span class="built_in">push_back</span>(elem); <span class="comment">// append copy of passed elem</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Stack&lt;T*&gt;::<span class="built_in">pop</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());</span><br><span class="line">    T* p = elems.<span class="built_in">back</span>();</span><br><span class="line">    elems.<span class="built_in">pop_back</span>(); <span class="comment">// remove last element</span></span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// and return it (unlike in the general case)</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Stack&lt;T*&gt;::<span class="built_in">top</span> () <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">return</span> elems.<span class="built_in">back</span>(); <span class="comment">// return copy of last element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&lt;T*&gt; &#123; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>定义了一个依然是被类型T参数化，但是被特化用来处理指针的类模板<code>Stack&lt;T*&gt;</code>。同样的，特例化之后的函数接口可能不同。比如对<code>pop()</code>，他在这里返回的是一个指针，因此如果这个指针是通过new创建的话，可以对这个被删除的值调用delete：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="type">int</span>*&gt; ptrStack; <span class="comment">// stack of pointers (specialimplementation)</span></span><br><span class="line">ptrStack.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">42</span>&#125;);</span><br><span class="line">std::cout &lt;&lt; *ptrStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">delete</span> ptrStack.<span class="built_in">pop</span>();</span><br></pre></td></tr></table></figure></p>
<h3 id="多模板参数的部分特例化"><a href="#多模板参数的部分特例化" class="headerlink" title="多模板参数的部分特例化"></a>多模板参数的部分特例化</h3><p>类模板也可以特例化多个模板参数之间的关系。比如对下面这个类模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>进行如下这些特例化都是可以的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// partial specialization: both template parameters have same type</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T,T&gt; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// partial specialization: second type is int</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T,<span class="type">int</span>&gt; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// partial specialization: both template parameters are pointer types</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T1*,T2*&gt; &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面的例子展示了以上各种类模板被使用的情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyClass&lt;<span class="type">int</span>, <span class="type">float</span>&gt; mif; <span class="comment">// uses MyClass&lt;T1,T2&gt;</span></span><br><span class="line">MyClass&lt;<span class="type">float</span>, <span class="type">float</span>&gt; mff; <span class="comment">// uses MyClass&lt;T,T&gt;</span></span><br><span class="line">MyClass&lt;<span class="type">float</span>, <span class="type">int</span>&gt; mfi; <span class="comment">// uses MyClass&lt;T,int&gt;</span></span><br><span class="line">MyClass&lt;<span class="type">int</span>*, <span class="type">float</span>*&gt; mp; <span class="comment">// uses MyClass&lt;T1*,T2*&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果有不止一个特例化的版本可以以相同的情形匹配某一个调用，说明定义是有歧义的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m; <span class="comment">// ERROR: matches MyClass&lt;T,T&gt; // and MyClass&lt;T,int&gt;</span></span><br><span class="line">MyClass&lt;<span class="type">int</span>*, <span class="type">int</span>*&gt; m; <span class="comment">// ERROR: matches MyClass&lt;T,T&gt; // and MyClass&lt;T1*,T2*&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>为了消除第二种歧义，你可以提供一个单独的特例化版本来处理相同类型的指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T*,T*&gt; &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="默认类模板参数"><a href="#默认类模板参数" class="headerlink" title="默认类模板参数"></a>默认类模板参数</h2><p>和函数模板一样，也可以给类模板的模板参数指定默认值。比如对<code>Stack&lt;&gt;</code>，你可以将其用来容纳元素的容器声明为第二个模板参数，并指定其默认值是<code>std::vector&lt;&gt;</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont = std::vector&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Cont elems; <span class="comment">// elements</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; elem)</span></span>; <span class="comment">// push element</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element</span></span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// return top element</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T,Cont&gt;::<span class="built_in">push</span> (T <span class="type">const</span>&amp; elem)</span><br><span class="line">&#123;</span><br><span class="line">    elems.<span class="built_in">push_back</span>(elem); <span class="comment">// append copy of passed elem</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T,Cont&gt;::<span class="built_in">pop</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());</span><br><span class="line">    elems.<span class="built_in">pop_back</span>(); <span class="comment">// remove last element</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont&gt;</span><br><span class="line">T <span class="type">const</span>&amp; Stack&lt;T,Cont&gt;::<span class="built_in">top</span> () <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">return</span> elems.<span class="built_in">back</span>(); <span class="comment">// return copy of last element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于现在有两个模板参数，因此每个成员函数的定义也应该包含两个模板参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T,Cont&gt;::<span class="built_in">push</span> (T <span class="type">const</span>&amp; elem)</span><br><span class="line">&#123;</span><br><span class="line">    elems.<span class="built_in">push_back</span>(elem); <span class="comment">// append copy of passed elem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个<code>Stack&lt;&gt;</code>模板可以像之前一样使用。如果只提供第一个模板参数作为元素类型，那么<code>vector</code>将被用来处理Stack中的元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont = std::vector&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Cont elems; <span class="comment">// elements</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>而且在程序中，也可以为Stack指定一个容器类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack3.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// stack of ints:</span></span><br><span class="line">    Stack&lt;<span class="type">int</span>&gt; intStack;</span><br><span class="line">    <span class="comment">// stack of doubles using a std::deque&lt;&gt; to manage the elements</span></span><br><span class="line">    Stack&lt;<span class="type">double</span>,std::deque&lt;<span class="type">double</span>&gt;&gt; dblStack;</span><br><span class="line">    <span class="comment">// manipulate int stack</span></span><br><span class="line">    intStack.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">    std::cout &lt;&lt; intStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    intStack.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="comment">// manipulate double stack</span></span><br><span class="line">    dblStack.<span class="built_in">push</span>(<span class="number">42.42</span>);</span><br><span class="line">    std::cout &lt;&lt; dblStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    dblStack.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="type">double</span>,std::deque&lt;<span class="type">double</span>&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>定义了一个处理double型元素的Stack，其使用的容器是<code>std::deque&lt;&gt;</code>。</p>
<h2 id="类型别名（Type-Aliases）"><a href="#类型别名（Type-Aliases）" class="headerlink" title="类型别名（Type Aliases）"></a>类型别名（Type Aliases）</h2><p>通过给类模板定义一个新的名字，可以使类模板的使用变得更方便。</p>
<h3 id="Typedefs和Alias声明"><a href="#Typedefs和Alias声明" class="headerlink" title="Typedefs和Alias声明"></a>Typedefs和Alias声明</h3><p>为了简化给类模板定义新名字的过程，有两种方法可用：</p>
<p>使用关键字<code>typedef</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Stack&lt;<span class="type">int</span>&gt; IntStack; <span class="comment">// typedef</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span> <span class="params">(IntStack <span class="type">const</span>&amp; s)</span></span>; <span class="comment">// s is stack of ints</span></span><br><span class="line">IntStack istack[<span class="number">10</span>]; <span class="comment">// istack is array of 10 stacks of ints</span></span><br></pre></td></tr></table></figure></p>
<p>我们称这种声明方式为<code>typedef</code>，被定义的名字叫做typedef-name.</p>
<p>使用关键字<code>using</code>（从C++11开始）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> IntStack = Stack &lt;<span class="type">int</span>&gt;; <span class="comment">// alias declaration</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span> <span class="params">(IntStack <span class="type">const</span>&amp; s)</span></span>; <span class="comment">// s is stack of ints</span></span><br><span class="line">IntStack istack[<span class="number">10</span>]; <span class="comment">// istack is array of 10 stacks of ints</span></span><br></pre></td></tr></table></figure></p>
<p>在这两种情况下我们都只是为一个已经存在的类型定义了一个别名，并没有定义新的类型。因此在：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Stack &lt;<span class="type">int</span>&gt; IntStack;</span><br></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> IntStack = Stack &lt;<span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<p>之后，<code>IntStack</code>和<code>Stack&lt;int&gt;</code>将是两个等效的符号。以上两种给一个已经存在的类型定义新名字的方式，被称为type alias declaration。新的名字被称为type alias。</p>
<h3 id="Alias-Templates（别名模板）"><a href="#Alias-Templates（别名模板）" class="headerlink" title="Alias Templates（别名模板）"></a>Alias Templates（别名模板）</h3><p>不同于typedef，alias declaration也可以被模板化，这样就可以给一组类型取一个方便的名字。这一特性从C++11开始生效，被称作alias templates。下面的<code>DequeStack</code>别名模板是被元素类型T参数化的，代表将其元素存储在<code>std::deque</code>中的一组<code>Stack</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> DequeStack = Stack&lt;T, std::deque&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure></p>
<p>因此，类模板和alias templates都是可以被参数化的类型。同样地，这里alias template只是一个已经存在的类型的新名字，原来的名字依然可用。<code>DequeStack&lt;int&gt;</code>和<code>Stack&lt;int, std::deque&lt;int&gt;&gt;</code>代表的是同一种类型。</p>
<p>同样的，通常模板（包含Alias Templates）只可以被声明和定义在global/namespace作用域，或者在一个类的声明中。</p>
<h3 id="Alias-Templates-for-Member-Types（class成员的别名模板）"><a href="#Alias-Templates-for-Member-Types（class成员的别名模板）" class="headerlink" title="Alias Templates for Member Types（class成员的别名模板）"></a>Alias Templates for Member Types（class成员的别名模板）</h3><p>使用alias templates可以很方便的给类模板的成员类型定义一个快捷方式，在：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> ... iterator;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyType</span> &#123;</span><br><span class="line"><span class="keyword">using</span> iterator = ...;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>之后，下面这样的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> MyTypeIterator = <span class="keyword">typename</span> MyType&lt;T&gt;::iterator;</span><br></pre></td></tr></table></figure></p>
<p>允许我们使用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyTypeIterator&lt;<span class="type">int</span>&gt; pos;</span><br></pre></td></tr></table></figure></p>
<p>取代：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> MyType&lt;T&gt;::iterator pos;</span><br></pre></td></tr></table></figure></p>
<h3 id="Type-Traits-Suffix-t-（Suffix-t类型萃取）"><a href="#Type-Traits-Suffix-t-（Suffix-t类型萃取）" class="headerlink" title="Type Traits Suffix_t （Suffix_t类型萃取）"></a>Type Traits Suffix_t （Suffix_t类型萃取）</h3><p>从C++14开始，标准库使用上面的技术，给标准库中所有返回一个类型的type trait定义了快捷方式。比如为了能够使用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="type">add_const_t</span>&lt;T&gt; <span class="comment">// since C++14</span></span><br></pre></td></tr></table></figure></p>
<p>而不是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> std::add_const&lt;T&gt;::type <span class="comment">// since C++11</span></span><br></pre></td></tr></table></figure></p>
<p>标准库做了如下定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">add_const_t</span> = <span class="keyword">typename</span> add_const&lt;T&gt;::type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="类模板的类型推导"><a href="#类模板的类型推导" class="headerlink" title="类模板的类型推导"></a>类模板的类型推导</h2><p>直到C++17，使用类模板时都必须显式指出所有的模板参数的类型（除非它们有默认值）。从C++17开始，这一要求不在那么严格了。如果构造函数能够推断出所有模板参数的类型（对那些没有默认值的模板参数），就不再需要显式的指明模板参数的类型。</p>
<p>比如在之前所有的例子中，不指定模板类型就可以调用copy constructor:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="type">int</span>&gt; intStack1; <span class="comment">// stack of strings</span></span><br><span class="line">Stack&lt;<span class="type">int</span>&gt; intStack2 = intStack1; <span class="comment">// OK in all versions</span></span><br><span class="line">Stack intStack3 = intStack1; <span class="comment">// OK since C++17</span></span><br></pre></td></tr></table></figure></p>
<p>通过提供一个接受初始化参数的构造函数，就可以推断出Stack的元素类型。比如可以定义下面这样一个Stack，它可以被一个元素初始化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T&gt; elems; <span class="comment">// elements</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span> () = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Stack</span> (T <span class="type">const</span>&amp; elem) <span class="comment">// initialize stack with one element</span></span><br><span class="line">        : <span class="built_in">elems</span>(&#123;elem&#125;) &#123;</span><br><span class="line">    &#125;...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后就可以像这样声明一个Stack:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack intStack = <span class="number">0</span>; <span class="comment">// Stack&lt;int&gt; deduced since C++17</span></span><br></pre></td></tr></table></figure></p>
<p>通过用0初始化这个stack时，模板参数T被推断为int，这样就会实例化出一个<code>Stack&lt;int&gt;</code>。但是请注意下面这些细节：</p>
<ul>
<li>由于定义了接受int作为参数的构造函数，要记得向编译器要求生成默认构造函数及其全部默认行为，这是因为默认构造函数只有在没有定义其它构造函数的情况下才会默认生成，方法如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Stack</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>在初始化Stack的vector成员<code>elems</code>时，参数<code>elem</code>被用<code>&#123;&#125;</code>括了起来，这相当于用只有一个元素<code>elem</code>的初始化列表初始化了<code>elems</code>:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: <span class="built_in">elems</span>(&#123;elem&#125;)</span><br></pre></td></tr></table></figure>
<p>这是因为vector没有可以直接接受一个参数的构造函数。</p>
<p>和函数模板不同，类模板可能无法部分的推断模板类型参数（比如在显式的指定了一部分类模板参数的情况下）</p>
<h3 id="类模板对字符串常量参数的类型推断（Class-Template-Arguments-Deduction-with-String-Literals）"><a href="#类模板对字符串常量参数的类型推断（Class-Template-Arguments-Deduction-with-String-Literals）" class="headerlink" title="类模板对字符串常量参数的类型推断（Class Template Arguments Deduction with String Literals）"></a>类模板对字符串常量参数的类型推断（Class Template Arguments Deduction with String Literals）</h3><p>原则上，可以通过字符串常量来初始化Stack：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack stringStack = <span class="string">&quot;bottom&quot;</span>; <span class="comment">// Stack&lt;char const[7]&gt; deduced since C++17</span></span><br></pre></td></tr></table></figure></p>
<p>不过这样会带来一堆问题：当参数是按照T的引用传递的时候（上面例子中接受一个参数的构造函数，是按照引用传递的），参数类型不会被decay，也就是说一个裸的数组类型不会被转换成裸指针。这样我们就等于初始化了一个这样的Stack:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="type">char</span> <span class="type">const</span>[<span class="number">7</span>]&gt;</span><br></pre></td></tr></table></figure></p>
<p>类模板中的T都会被实例化成<code>char const[7]</code>。这样就不能继续向Stack追加一个不同维度的字符串常量了，因为它的类型不是<code>char const[7]</code>。不过如果参数是按值传递的，参数类型就会被decay，也就是说会将裸数组退化成裸指针。这样构造函数的参数类型T会被推断为<code>char const *</code>，实例化后的类模板类型会被推断为<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="type">char</span> <span class="type">const</span> *&gt;。</span><br></pre></td></tr></table></figure></p>
<p>基于以上原因，可能有必要将构造函数声明成按值传递参数的形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T&gt; elems; <span class="comment">// elements</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span> (T elem) <span class="comment">// initialize stack with one element by value</span></span><br><span class="line">        : <span class="built_in">elems</span>(&#123;elem&#125;) &#123; <span class="comment">// to decay on class tmpl arg deduction</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样下面的初始化方式就可以正常工作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack stringStack = <span class="string">&quot;bottom&quot;</span>; <span class="comment">// Stack&lt;char const*&gt; deduced since C++17</span></span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，最好将临时变量<code>elem</code> move到<code>stack</code>中，这样可以免除不必要的拷贝:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T&gt; elems; <span class="comment">// elements</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span> (T elem) <span class="comment">// initialize stack with one element by value</span></span><br><span class="line">        : <span class="built_in">elems</span>(&#123;std::<span class="built_in">move</span>(elem)&#125;) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="推断指引（Deduction-Guides）"><a href="#推断指引（Deduction-Guides）" class="headerlink" title="推断指引（Deduction Guides）"></a>推断指引（Deduction Guides）</h3><p>针对以上问题，除了将构造函数声明成按值传递的，还有一个解决方案：由于在容器中处理裸指针容易导致很多问题，对于容器一类的类，不应该将类型推断为字符的裸指针（<code>char const *</code>）。</p>
<p>可以通过提供“推断指引”来提供额外的模板参数推断规则，或者修正已有的模板参数推断规则。比如你可以定义，当传递一个字符串常量或者C类型的字符串时，应该用<code>std::string</code>实例化Stack模板类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Stack</span>( <span class="type">char</span> <span class="type">const</span>*) -&gt; Stack&lt;std::string&gt;;</span><br></pre></td></tr></table></figure></p>
<p>这个指引语句必须出现在和模板类的定义相同的作用域或者命名空间内。通常它紧跟着模板类的定义。<code>-&gt;</code>后面的类型被称为推断指引的“guided type”。现在，根据这个定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack stringStack&#123;<span class="string">&quot;bottom&quot;</span>&#125;; <span class="comment">// OK: Stack&lt;std::string&gt; deduced since C++17</span></span><br></pre></td></tr></table></figure></p>
<p>Stack将被推断为<code>Stack&lt;std::string&gt;</code>。但是下面这个定义依然不可以：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack stringStack = <span class="string">&quot;bottom&quot;</span>; <span class="comment">// Stack&lt;std::string&gt; deduced, but still not valid</span></span><br></pre></td></tr></table></figure></p>
<p>此时模板参数类型被推断为<code>std::string</code>，也会实例化出<code>Stack&lt;std::string&gt;</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::string&gt; elems; <span class="comment">// elements</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span> (std::string <span class="type">const</span>&amp; elem) <span class="comment">// initialize stack with one element</span></span><br><span class="line">        : <span class="built_in">elems</span>(&#123;elem&#125;) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是根据语言规则，不能通过将字符串字面量传递给一个期望接受<code>std::string</code>的构造函数来拷贝初始化（使用=初始化）一个对象，因此必须要像下面这样来初始化这个Stack:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack stringStack&#123;<span class="string">&quot;bottom&quot;</span>&#125;; <span class="comment">// Stack&lt;std::string&gt; deduced and valid</span></span><br></pre></td></tr></table></figure></p>
<p>如果还不是很确信的话，这里可以明确告诉你，模板参数推断的结果是可以拷贝的。在将<code>stringStack</code>声明为<code>Stack&lt;std::string&gt;</code>之后，下面的初始化语句声明的也将是<code>Stack&lt;std::string&gt;</code>类型的变量（通过拷贝构造函数），而不是用<code>Stack&lt;std::string&gt;</code>类型的元素去初始化一个stack（也就是说，<code>Stack</code>存储的元素类型是<code>std::string</code>，而不是<code>Stack&lt;std::string&gt;</code>）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack stack2&#123;stringStack&#125;; <span class="comment">// Stack&lt;std::string&gt; deduced</span></span><br><span class="line"><span class="function">Stack <span class="title">stack3</span><span class="params">(stringStack)</span></span>; <span class="comment">// Stack&lt;std::string&gt; deduced</span></span><br><span class="line">Stack stack4 = &#123;stringStack&#125;; <span class="comment">// Stack&lt;std::string&gt; deduced</span></span><br></pre></td></tr></table></figure></p>
<h2 id="聚合类的模板化（Templatized-Aggregates）"><a href="#聚合类的模板化（Templatized-Aggregates）" class="headerlink" title="聚合类的模板化（Templatized Aggregates）"></a>聚合类的模板化（Templatized Aggregates）</h2><p>聚合类（这样一类class或者struct：没有用户定义的显式的，或者继承而来的构造函数，没有private或者protected的非静态成员，没有虚函数，没有virtual，private或者protected的基类）也可以是模板。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ValueWithComment</span> &#123;</span><br><span class="line">    T value;</span><br><span class="line">    std::string comment;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>定义了一个成员val的类型被参数化了的聚合类。可以像定义其它类模板的对象一样定义一个聚合类的对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ValueWithComment&lt;<span class="type">int</span>&gt; vc;</span><br><span class="line">vc.value = <span class="number">42</span>;</span><br><span class="line">vc.comment = <span class="string">&quot;initial value&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p>从C++17开始，对于聚合类的类模板甚至可以使用“类型推断指引” ：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ValueWithComment</span>(</span><br><span class="line"><span class="type">char</span> <span class="type">const</span>*, <span class="type">char</span> <span class="type">const</span>*) -&gt; ValueWithComment&lt;std::string&gt;;</span><br><span class="line">ValueWithComment vc2 = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;initial value&quot;</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>没有“推断指引”的话，就不能使用上述初始化方法，因为ValueWithComment没有相应的构造函数来完成相关类型推断。</p>
<p>标准库的<code>std::array&lt;&gt;</code>类也是一个聚合类，其元素类型和尺寸都是被参数化的。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>类模板是一个被实现为有一个或多个类型参数待定的类。</li>
<li>使用类模板时，需要显式或者隐式地传递相应的待定类型参数作为模板参数。之后类模板会被按照传入的模板参数实例化（并且被编译）。</li>
<li>对于类模板，只有其被用到的成员函数才会被实例化。</li>
<li>可以针对某些特定类型对类模板进行特化。</li>
<li>也可以针对某些特定类型对类模板进行部分特化。</li>
<li>从C++17开始，可以（不是一定可以）通过类模板的构造函数来推断模板参数的类型。</li>
<li>可以定义聚合类的类模板。</li>
<li>调用参数如果是按值传递的，那么相应的模板类型会decay。</li>
<li>模板只能被声明以及定义在global或者namespace作用域，或者是定义在其它类的定义里面。</li>
</ul>
<h1 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h1><p>和类模板使用类型作为参数类似，可以使代码的另一些细节留到被使用时再确定，只是对非类型模板参数，待定的不再是类型，而是某个数值。在使用这种模板时需要显式的指出待定数值的具体值，之后代码会被实例化。</p>
<h2 id="类模板的非类型参数"><a href="#类模板的非类型参数" class="headerlink" title="类模板的非类型参数"></a>类模板的非类型参数</h2><p>作为和之前章节中Stack实现方式的对比，可以定义一个使用固定尺寸的array作为容器的Stack。这种方式的优点是可以避免由开发者或者标准库容器负责的内存管理开销。不过对不同应用，这一固定尺寸的具体大小也很难确定。如果指定的值过小，那么Stack就会很容易满。如果指定的值过大，则可能造成内存浪费。因此最好是让Stack的用户根据自身情况指定Stack的大小。</p>
<p>为此，可以将Stack的大小定义成模板的参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::array&lt;T, Maxsize&gt; elems; <span class="comment">// elements</span></span><br><span class="line">    std::<span class="type">size_t</span> numElems; <span class="comment">// current number of elements</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>(); <span class="comment">// constructor</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; elem)</span></span>; <span class="comment">// push element</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element</span></span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// return top element</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">//return whether the stack is empty</span></span><br><span class="line">        <span class="keyword">return</span> numElems == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">//return current number of elements</span></span><br><span class="line">        <span class="keyword">return</span> numElems;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> Maxsize&gt;</span><br><span class="line">Stack&lt;T,Maxsize&gt;::<span class="built_in">Stack</span> ()</span><br><span class="line">    : <span class="built_in">numElems</span>(<span class="number">0</span>) <span class="comment">//start with no elements</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// nothing else to do</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T,Maxsize&gt;::<span class="built_in">push</span> (T <span class="type">const</span>&amp; elem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(numElems &lt; Maxsize);</span><br><span class="line">    elems[numElems] = elem; <span class="comment">// append element</span></span><br><span class="line">    ++numElems; <span class="comment">// increment number of elements</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T,Maxsize&gt;::<span class="built_in">pop</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());</span><br><span class="line">    --numElems; <span class="comment">// decrement number of elements</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> Maxsize&gt;</span><br><span class="line">T <span class="type">const</span>&amp; Stack&lt;T,Maxsize&gt;::<span class="built_in">top</span> () <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">return</span> elems[numElems<span class="number">-1</span>]; <span class="comment">// return last element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二个新的模板参数Maxsize是int类型的。通过它指定了Stack中array的大小：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::array&lt;T,Maxsize&gt; elems; <span class="comment">// elements</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>成员函数<code>push()</code>也用它来检测Stack是否已满：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T,Maxsize&gt;::<span class="built_in">push</span> (T <span class="type">const</span>&amp; elem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(numElems &lt; Maxsize);</span><br><span class="line">    elems[numElems] = elem; <span class="comment">// append element</span></span><br><span class="line">    ++numElems; <span class="comment">// increment number of elements</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了使用这个类模板，需要同时指出Stack中元素的类型和Stack的最大容量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stacknontype.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack&lt;<span class="type">int</span>,<span class="number">20</span>&gt; int20Stack; <span class="comment">// stack of up to 20 ints</span></span><br><span class="line">    Stack&lt;<span class="type">int</span>,<span class="number">40</span>&gt; int40Stack; <span class="comment">// stack of up to 40 ints</span></span><br><span class="line">    Stack&lt;std::string,<span class="number">40</span>&gt; stringStack; <span class="comment">// stack of up to 40 strings</span></span><br><span class="line">    <span class="comment">// manipulate stack of up to 20 ints</span></span><br><span class="line">    int20Stack.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">    std::cout &lt;&lt; int20Stack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    int20Stack.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="comment">// manipulate stack of up to 40 strings</span></span><br><span class="line">    stringStack.<span class="built_in">push</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; stringStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    stringStack.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面每一次模板的使用都会实例化出一个新的类型。因此<code>int20Stack</code>和<code>int40Stack</code>是两种不同的类型，而且由于它们之间没有定义隐式或者显式的类型转换规则。也就不能使用其中一个取代另一个，或者将其中一个赋值给另一个。</p>
<p>对非类型模板参数，也可以指定默认值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>, std::<span class="type">size_t</span> Maxsize = <span class="number">100</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是从程序设计的角度来看，这可能不是一个好的设计方案。默认值应该是直观上正确的。不过对于一个普通的Stack，无论是默认的int类型还是Stack的最大尺寸100，看上去都不够直观。</p>
<h2 id="函数模板的非类型参数"><a href="#函数模板的非类型参数" class="headerlink" title="函数模板的非类型参数"></a>函数模板的非类型参数</h2><p>同样也可以给函数模板定义非类型模板参数。比如下面的这个函数模板，定义了一组可以返回传入参数和某个值之和的函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> Val, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">addValue</span> <span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + Val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当该类函数或操作是被用作其它函数的参数时，可能会很有用。比如当使用C++标准库给一个集合中的所有元素增加某个值的时候，可以将这个函数模板的一个实例化版本用作第4个参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">transform</span> (source.<span class="built_in">begin</span>(), source.<span class="built_in">end</span>(), <span class="comment">//start and end of source</span></span><br><span class="line">    dest.<span class="built_in">begin</span>(), <span class="comment">//start of destination</span></span><br><span class="line">    addValue&lt;<span class="number">5</span>,<span class="type">int</span>&gt;); <span class="comment">// operation</span></span><br></pre></td></tr></table></figure></p>
<p>第4个参数是从<code>addValue&lt;&gt;()</code>实例化出一个可以给传入的int型参数加5的函数实例。这一实例会被用来处理集合source中的所有元素，并将结果保存到目标集合dest中。注意在这里必须将<code>addValue&lt;&gt;()</code>的模板参数T指定为int类型。因为类型推断只会对立即发生的调用起作用，而<code>std::transform()</code>又需要一个完整的类型来推断其第四个参数的类型。目前还不支持先部分地替换或者推断模板参数的类型，然后再基于具体情况去推断其余的模板参数。</p>
<p>同样也可以基于前面的模板参数推断出当前模板参数的类型。比如可以通过传入的非类型模板参数推断出返回类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">auto</span> Val, <span class="keyword">typename</span> T </span>= <span class="keyword">decltype</span>(Val)&gt;</span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>或者可以通过如下方式确保传入的非类型模板参数的类型和类型参数的类型一致：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T Val </span>= T&#123;&#125;&gt;</span><br><span class="line"><span class="function">T <span class="title">bar</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="非类型模板参数的限制"><a href="#非类型模板参数的限制" class="headerlink" title="非类型模板参数的限制"></a>非类型模板参数的限制</h2><p>使用非类型模板参数是有限制的。通常它们只能是整形常量（包含枚举），指向<code>objects</code>/<code>functions</code>/<code>members</code>的指针，<code>objects</code>或者<code>functions</code>的左值引用，或者是<code>std::nullptr_t</code>（类型是<code>nullptr</code>）。浮点型数值或者class类型的对象都不能作为非类型模板参数使用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">double</span> VAT&gt; <span class="comment">// ERROR: floating-point values are not</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">process</span> <span class="params">(<span class="type">double</span> v)</span> <span class="comment">// allowed as template parameters</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v * VAT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;std::string name&gt; <span class="comment">// ERROR: class-type objects are not</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; <span class="comment">// allowed as template parameters</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当传递对象的指针或者引用作为模板参数时，对象不能是字符串常量，临时变量或者数据成员以及其它子对象。由于在C++17之前，C++版本的每次更新都会放宽以上限制，因此还有一些针对不同版本的限制：</p>
<ul>
<li>在C++11中，对象必须要有外部链接。</li>
<li>在C++14中，对象必须是外部链接或者内部链接。</li>
</ul>
<p>因此下面的写法是不对的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">char</span> <span class="type">const</span>* name&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">MyClass&lt;<span class="string">&quot;hello&quot;</span>&gt; x; <span class="comment">//ERROR: string literal &quot;hello&quot; not allowed</span></span><br></pre></td></tr></table></figure></p>
<p>不过有如下变通方法（视C++版本而定）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> <span class="type">const</span> s03[] = <span class="string">&quot;hi&quot;</span>; <span class="comment">// external linkage</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> s11[] = <span class="string">&quot;hi&quot;</span>; <span class="comment">// internal linkage</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass&lt;s03&gt; m03; <span class="comment">// OK (all versions)</span></span><br><span class="line">    MyClass&lt;s11&gt; m11; <span class="comment">// OK since C++11</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> <span class="type">const</span> s17[] = <span class="string">&quot;hi&quot;</span>; <span class="comment">// no linkage</span></span><br><span class="line">    MyClass&lt;s17&gt; m17; <span class="comment">// OK since C++17</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面三种情况下，都是用”hello”初始化了一个字符串常量数组，然后将这个字符串常量数组对象用于类模板中被声明为<code>char const *</code>的模板参数。如果这个对象有外部链接（s03），那么对所有版本的C++都是有效的，如果对象有内部链接（s11），那么对C++11和C++14也是有效的，而对C++17，即使对象没有链接属性也是有效的。</p>
<h3 id="避免无效表达式"><a href="#避免无效表达式" class="headerlink" title="避免无效表达式"></a>避免无效表达式</h3><p>非类型模板参数可以是任何编译期表达式。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> I, <span class="type">bool</span> B&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>;</span><br><span class="line"></span><br><span class="line">C&lt;<span class="built_in">sizeof</span>(<span class="type">int</span>) + <span class="number">4</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>)==<span class="number">4</span>&gt; c;</span><br></pre></td></tr></table></figure></p>
<p>不过如果在表达式中使用了<code>operator &gt;</code>，就必须将相应表达式放在括号里面，否则<code>&gt;</code>会被作为模板参数列表末尾的<code>&gt;</code>，从而截断了参数列表：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C&lt;<span class="number">42</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) &gt; <span class="number">4</span>&gt; c; <span class="comment">// ERROR: first &gt; ends the template argument list</span></span><br><span class="line">C&lt;<span class="number">42</span>, (<span class="built_in">sizeof</span>(<span class="type">int</span>) &gt; <span class="number">4</span>)&gt; c; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure></p>
<h2 id="用auto作为非模板类型参数的类型"><a href="#用auto作为非模板类型参数的类型" class="headerlink" title="用auto作为非模板类型参数的类型"></a>用auto作为非模板类型参数的类型</h2><p>从C++17开始，可以不指定非类型模板参数的具体类型（代之以auto），从而使其可以用于任意有效的非类型模板参数的类型。通过这一特性，可以定义如下更为泛化的大小固定的Stack类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">auto</span> Maxsize&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="keyword">decltype</span>(Maxsize);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::array&lt;T,Maxsize&gt; elems; <span class="comment">// elements</span></span><br><span class="line">    size_type numElems; <span class="comment">// current number of elements</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>(); <span class="comment">// constructor</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; elem)</span></span>; <span class="comment">// push element</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element</span></span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// return top element</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">//return whether the stack isempty</span></span><br><span class="line">        <span class="keyword">return</span> numElems == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">//return current number of elements</span></span><br><span class="line">        <span class="keyword">return</span> numElems;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// constructor</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">auto</span> Maxsize&gt;</span><br><span class="line">Stack&lt;T,Maxsize&gt;::<span class="built_in">Stack</span> ()</span><br><span class="line">    : <span class="built_in">numElems</span>(<span class="number">0</span>) <span class="comment">//start with no elements</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// nothing else to do</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">auto</span> Maxsize&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T,Maxsize&gt;::<span class="built_in">push</span> (T <span class="type">const</span>&amp; elem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(numElems &lt; Maxsize);</span><br><span class="line">    elems[numElems] = elem; <span class="comment">// append element</span></span><br><span class="line">    ++numElems; <span class="comment">// increment number of elements</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">auto</span> Maxsize&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T,Maxsize&gt;::<span class="built_in">pop</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());</span><br><span class="line">    --numElems; <span class="comment">// decrement number of elements</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">auto</span> Maxsize&gt;</span><br><span class="line">T <span class="type">const</span>&amp; Stack&lt;T,Maxsize&gt;::<span class="built_in">top</span> () <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">return</span> elems[numElems<span class="number">-1</span>]; <span class="comment">// return last element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过使用auto的如下定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">auto</span> Maxsize&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>定义了类型待定的Maxsize。它的类型可以是任意非类型参数所允许的类型。在模板内部，既可以使用它的值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;T,Maxsize&gt; elems; <span class="comment">// elements</span></span><br></pre></td></tr></table></figure></p>
<p>也可以使用它的类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> size_type = <span class="keyword">decltype</span>(Maxsize);</span><br></pre></td></tr></table></figure></p>
<p>然后可以将它用于成员函数<code>size()</code>的返回类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">//return current number of elements</span></span><br><span class="line">    <span class="keyword">return</span> numElems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从C++14开始，也可以通过使用auto，让编译器推断出具体的返回类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">//return current number of elements</span></span><br><span class="line">    <span class="keyword">return</span> numElems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据这个类的声明，Stack中numElems成员的类型是由非类型模板参数的类型决定的，当像下面这样使用它的时候：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stackauto.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack&lt;<span class="type">int</span>,<span class="number">20u</span>&gt; int20Stack; <span class="comment">// stack of up to 20 ints</span></span><br><span class="line">    Stack&lt;std::string,<span class="number">40</span>&gt; stringStack; <span class="comment">// stack of up to 40 strings</span></span><br><span class="line">    <span class="comment">// manipulate stack of up to 20 ints</span></span><br><span class="line">    int20Stack.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">    std::cout &lt;&lt; int20Stack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="keyword">auto</span> size1 =</span><br><span class="line">    int20Stack.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// manipulate stack of up to 40 strings</span></span><br><span class="line">    stringStack.<span class="built_in">push</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; stringStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> size2 = stringStack.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (!std::is_same_v&lt;<span class="keyword">decltype</span>(size1), <span class="keyword">decltype</span>(size2)&gt;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;size types differ&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="type">int</span>,<span class="number">20u</span>&gt; int20Stack; <span class="comment">// stack of up to 20 ints</span></span><br></pre></td></tr></table></figure></p>
<p>由于传递的非类型参数是20u，因此内部的<code>size_type</code>是<code>unsigned int</code>类型的。</p>
<p>对于<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;std::string,<span class="number">40</span>&gt; stringStack; <span class="comment">// stack of up to 40 strings</span></span><br></pre></td></tr></table></figure></p>
<p>由于传递的非类型参数是int，因此内部的<code>size_type</code>是int类型的。因为这两个Stack中成员函数<code>size()</code>的返回类型是不一样的，所以<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> size1 = int20Stack.<span class="built_in">size</span>();</span><br><span class="line">... </span><br><span class="line"><span class="keyword">auto</span> size2 = stringStack.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure></p>
<p>中<code>size1</code>和<code>size2</code>的类型也不一样。这可以通过标准类型萃取<code>std::is_same</code>和<code>decltype</code>来验证：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!std::is_same&lt;<span class="keyword">decltype</span>(size1), <span class="keyword">decltype</span>(size2)&gt;::value) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size types differ&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果将是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size types differ</span><br></pre></td></tr></table></figure></p>
<p>从C++17开始，对于返回类型的类型萃取，可以通过使用下标<code>_v</code>省略掉<code>::value</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!std::is_same_v&lt;<span class="keyword">decltype</span>(size1), <span class="keyword">decltype</span>(size2)&gt;) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size types differ&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意关于非类型模板参数的限制依然存在。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="type">int</span>,<span class="number">3.14</span>&gt; sd; <span class="comment">// ERROR: Floating-point nontype argument</span></span><br></pre></td></tr></table></figure></p>
<p>由于可以将字符串作为常量数组用于非类型模板参数，下面的用法也是可以的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">auto</span> T&gt; <span class="comment">// take value of any possible nontype parameter (since C++17)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; T &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Message&lt;<span class="number">42</span>&gt; msg1;</span><br><span class="line">    msg<span class="number">1.</span><span class="built_in">print</span>(); <span class="comment">// initialize with int 42 and print that value</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> <span class="type">const</span> s[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    Message&lt;s&gt; msg2; <span class="comment">// initialize with char const[6] &quot;hello&quot;</span></span><br><span class="line">    msg<span class="number">2.</span><span class="built_in">print</span>(); <span class="comment">// and print that value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以使用<code>template&lt;decltype(auto)&gt;</code>，这样可以将N实例化成引用类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">decltype</span>(<span class="keyword">auto</span>) N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">C&lt;(i)&gt; x; <span class="comment">// N is int&amp;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul>
<li>模板的参数不只可以是类型，也可以是数值。</li>
<li>不可以将浮点型或者class类型的对象用于非类型模板参数。使用指向字符串常量，临时变量和子对象的指针或引用也有一些限制。</li>
<li>通过使用关键字auto，可以使非类型模板参数的类型更为泛化。</li>
</ul>
<h1 id="变参模板"><a href="#变参模板" class="headerlink" title="变参模板"></a>变参模板</h1><p>从C++11开始，模板可以接受一组数量可变的参数。这样就可以在参数数量和参数类型都不确定的情况下使用模板。一个典型应用是通过class或者framework向模板传递一组数量和类型都不确定的参数。另一个应用是提供泛型代码处理一组数量任意且类型也任意的参数。</p>
<h2 id="变参模板-1"><a href="#变参模板-1" class="headerlink" title="变参模板"></a>变参模板</h2><p>可以将模板参数定义成能够接受任意多个模板参数的情况。这一类模板被称为变参模板（variadic template）。</p>
<h3 id="变参模板实列"><a href="#变参模板实列" class="headerlink" title="变参模板实列"></a>变参模板实列</h3><p>比如，可以通过调用下面代码中的<code>print()</code>函数来打印一组数量和类型都不确定的参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span> <span class="params">(T firstArg, Types... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; firstArg &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//print first argument</span></span><br><span class="line">    <span class="built_in">print</span>(args...); <span class="comment">// call print() for remaining arguments</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果传入的参数是一个或者多个，就会调用这个函数模板，这里通过将第一个参数单独声明，就可以先打印第一个参数，然后再递归的调用<code>print()</code>来打印剩余的参数。这些被称为<code>args</code>的剩余参数，是一个函数参数包（function parameter pack）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span> <span class="params">(T firstArg, Types... args)</span></span></span><br></pre></td></tr></table></figure></p>
<p>这里使用了通过模板参数包（template parameter pack）定义的类型“Types” ：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br></pre></td></tr></table></figure></p>
<p>为了结束递归，重载了不接受参数的非模板函数<code>print()</code>，它会在参数包为空的时候被调用。比如，这样一个调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">s</span><span class="params">(<span class="string">&quot;world&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">print</span> (<span class="number">7.5</span>, <span class="string">&quot;hello&quot;</span>, s);</span><br></pre></td></tr></table></figure></p>
<p>输出如下结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7.5</span></span><br><span class="line">hello</span><br><span class="line">World</span><br></pre></td></tr></table></figure></p>
<p>因为这个调用首先会被扩展成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>&lt;<span class="type">double</span>, <span class="type">char</span> <span class="type">const</span>*, std::string&gt; (<span class="number">7.5</span>, <span class="string">&quot;hello&quot;</span>, s);</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>firstArg的值是7.5，其类型T是double。</li>
<li>args是一个可变模板参数，它包含类型是char const*的“hello”和类型是std::string的“world”</li>
</ul>
<p>在打印了firstArg对应的7.5之后，继续调用<code>print()</code>打印剩余的参数，这时<code>print()</code>被扩展为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>&lt;<span class="type">char</span> <span class="type">const</span>*, std::string&gt; (<span class="string">&quot;hello&quot;</span>, s);</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>firstArg的值是“hello”，其类型T是<code>char const *</code>。</li>
<li>args是一个可变模板参数，它包含的参数类型是<code>std::string</code>。</li>
</ul>
<p>在打印了firstArg对应的“hello”之后，继续调用<code>print()</code>打印剩余的参数，这时<code>print()</code>被扩展为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>&lt;std::string&gt; (s);</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>firstArg的值是“world”，其类型T是std::string。</li>
<li>args是一个空的可变模板参数，它没有任何值。</li>
</ul>
<p>这样在打印了firstArg对应的“ world”之后，就会调用被重载的不接受参数的非模板函数<code>print()</code>，从而结束了递归。</p>
<h3 id="变参和非变参模板的重载"><a href="#变参和非变参模板的重载" class="headerlink" title="变参和非变参模板的重载"></a>变参和非变参模板的重载</h3><p>上面的例子也可以这样实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span> <span class="params">(T arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; arg &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//print passed argument</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span> <span class="params">(T firstArg, Types... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(firstArg); <span class="comment">// call print() for the first argument</span></span><br><span class="line">    <span class="built_in">print</span>(args...); <span class="comment">// call print() for remainingarguments</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，当两个函数模板的区别只在于尾部的参数包的时候，会优先选择没有尾部参数包的那一个函数模板。</p>
<h3 id="sizeof…运算符"><a href="#sizeof…运算符" class="headerlink" title="sizeof…运算符"></a>sizeof…运算符</h3><p>C++11为变参模板引入了一种新的sizeof运算符：<code>sizeof...</code>。它会被扩展成参数包中所包含的参数数目。因此：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span> <span class="params">(T firstArg, Types... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; firstArg &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//print first argument</span></span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">sizeof</span>...(Types) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//print number of remaining types</span></span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//print number of remaining args</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在将第一个参数打印之后，会将参数包中剩余的参数数目打印两次。如你所见，运算符<code>sizeof...</code>既可以用于模板参数包，也可以用于函数参数包。这样可能会让你觉得，可以不使用为了结束递归而重载的不接受参数的非模板函数<code>print()</code>，只要在没有参数的时候不去调用任何函数就可以了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span> <span class="params">(T firstArg, Types... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; firstArg &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>...(args) &gt; <span class="number">0</span>) &#123; <span class="comment">//error if sizeof...(args)==0</span></span><br><span class="line">        <span class="built_in">print</span>(args...); <span class="comment">// and no print() for no arguments declared</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这一方式是错误的，因为通常函数模板中if语句的两个分支都会被实例化。是否使用被实例化出来的代码是在运行期间（run-time）决定的，而是否实例化代码是在编译期间（compile-time）决定的。因此如果在只有一个参数的时候调用<code>print()</code>函数模板，虽然<code>args...</code>为空，if语句中的<code>print(args...)</code>也依然会被实例化，但此时没有定义不接受参数的<code>print()</code>函数，因此会报错。</p>
<p>不过从C++17开始，可以使用编译阶段的if语句，这样通过一些稍微不同的语法，就可以实现前面想要的功能。8.5节会对这一部分内容进行讨论。</p>
<h2 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="折叠表达式"></a>折叠表达式</h2><p>从C++17开始，提供了一种可以用来计算参数包（可以有初始值）中所有参数运算结果的二元运算符。比如，下面的函数会返回s中所有参数的和：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foldSum</span> <span class="params">(T... s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (... + s); <span class="comment">// ((s1 + s2) + s3) ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果参数包是空的，这个表达式将是不合规范的（不过此时对于运算符<code>&amp;&amp;</code>，结果会是true，对运算符<code>||</code>，结果会是false，对于逗号运算符，结果会是<code>void()</code>）。</p>
<p>表4.1列举了可能的折叠表达式：<br>|Fold Expression |Evaluation|<br>|—-|—-|<br>|( … op pack )|((( pack1 op pack2 ) op pack3 ) … op packN )|<br>|( pack op … )|( pack1 op ( … ( packN-1 op packN )))|<br>|( init op … op pack )|((( init op pack1 ) op pack2 ) … op packN )|<br>|( pack op … op init )|( pack1 op ( … ( packN op init )))|</p>
<p>几乎所有的二元运算符都可以用于折叠表达式。比如可以使用折叠表达式和运算符<code>-&gt;*</code>遍历一条二叉树的路径：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define binary tree structure and traverse helpers:</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> i=<span class="number">0</span>) : <span class="built_in">value</span>(i), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> left = &amp;Node::left;</span><br><span class="line"><span class="keyword">auto</span> right = &amp;Node::right;</span><br><span class="line"><span class="comment">// traverse tree, using fold expression:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... TP&gt;</span></span><br><span class="line"><span class="function">Node* <span class="title">traverse</span> <span class="params">(T np, TP... paths)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (np -&gt;* ... -&gt;* paths); <span class="comment">// np -&gt;* paths1 -&gt;* paths2 ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// init binary tree structure:</span></span><br><span class="line">    Node* root = <span class="keyword">new</span> Node&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    root-&gt;left = <span class="keyword">new</span> Node&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    root-&gt;left-&gt;right = <span class="keyword">new</span> Node&#123;<span class="number">2</span>&#125;;</span><br><span class="line">    ... <span class="comment">//</span></span><br><span class="line">    traverse binary tree:</span><br><span class="line">    Node* node = <span class="built_in">traverse</span>(root, left, right);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(np -&gt;* ... -&gt;* paths)</span><br></pre></td></tr></table></figure></p>
<p>使用了折叠表达式从np开始遍历了paths中所有可变成员。通过这样一个使用了初始化器的折叠表达式，似乎可以简化打印变参模板参数的过程，像上面那样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span> <span class="params">(Types <span class="type">const</span>&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过这样在参数包各元素之间并不会打印空格。为了打印空格，还需要下面这样一个类模板，它可以在所有要打印的参数后面追加一个空格：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddSpace</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T <span class="type">const</span>&amp; ref; <span class="comment">// refer to argument passed in constructor</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AddSpace</span>(T <span class="type">const</span>&amp; r): <span class="built_in">ref</span>(r) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp; os, AddSpace&lt;T&gt; s) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; s.ref &lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// output passed argument and a space</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span> <span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    ( std::cout &lt;&lt; ... &lt;&lt; <span class="built_in">AddSpace</span>&lt;Args&gt;(args) ) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意在表达式<code>AddSpace(args)</code>中使用了类模板的参数推导（见2.9节），相当于使用了<code>AddSpace&lt;Args&gt;(args)</code>，它会给传进来的每一个参数创建一个引用了该参数的<code>AddSpace</code>对象，当将这个对象用于输出的时候，会在其后面加一个空格。</p>
<h2 id="变参模板的使用"><a href="#变参模板的使用" class="headerlink" title="变参模板的使用"></a>变参模板的使用</h2><p>一个重要的作用是转发任意类型和数量的参数。比如在如下情况下会使用这一特性：</p>
<ul>
<li>向一个由智能指针管理的，在堆中创建的对象的构造函数传递参数：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create shared pointer to complex&lt;float&gt; initialized by 4.2 and 7.7:</span></span><br><span class="line"><span class="keyword">auto</span> sp = std::make_shared&lt;std::complex&lt;<span class="type">float</span>&gt;&gt;(<span class="number">4.2</span>, <span class="number">7.7</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>向一个由库启动的thread传递参数：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span> <span class="params">(foo, <span class="number">42</span>, <span class="string">&quot;hello&quot;</span>)</span></span>; <span class="comment">//call foo(42,&quot;hello&quot;) in a separate thread</span></span><br></pre></td></tr></table></figure>
<ul>
<li>向一个被push进vector中的对象的构造函数传递参数：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Customer&gt; v;</span><br><span class="line">... </span><br><span class="line">v.<span class="built_in">emplace</span>(<span class="string">&quot;Tim&quot;</span>, <span class="string">&quot;Jovi&quot;</span>, <span class="number">1962</span>); <span class="comment">//insert a Customer initialized by three arguments</span></span><br></pre></td></tr></table></figure>
<p>通常是使用移动语义对参数进行完美转发（perfectly forwarded），它们像下面这样进行声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt; </span></span><br><span class="line"><span class="function">    shared_ptr&lt;T&gt; <span class="title">make_shared</span><span class="params">(Args&amp;&amp;... args)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">        <span class="keyword">explicit</span> <span class="title">thread</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Allocator = allocator&lt;T&gt;&gt;</span><br><span class="line">    <span class="keyword">class</span> vector &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">        reference <span class="built_in">emplace_back</span>(Args&amp;&amp;... args);</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，之前关于常规模板参数的规则同样适用于变参模板参数。比如，如果参数是按值传递的，那么其参数会被拷贝，类型也会退化（decay）。如果是按引用传递的，那么参数会是实参的引用，并且类型不会退化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// args are copies with decayed types:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt; <span class="type">void</span> <span class="title">foo</span> <span class="params">(Args... args)</span></span>;</span><br><span class="line"><span class="comment">// args are nondecayed references to passed objects:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt; <span class="type">void</span> <span class="title">bar</span> <span class="params">(Args <span class="type">const</span>&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="变参类模板和变参表达式"><a href="#变参类模板和变参表达式" class="headerlink" title="变参类模板和变参表达式"></a>变参类模板和变参表达式</h2><p>除了上面提到的例子，参数包还可以出现在其它一些地方，比如表达式，类模板，using声明，甚至是推断指引中。</p>
<h3 id="变参表达式"><a href="#变参表达式" class="headerlink" title="变参表达式"></a>变参表达式</h3><p>除了转发所有参数之外，还可以做些别的事情。比如计算它们的值。下面的例子先是将参数包中的所有的参数都翻倍，然后将结果传给<code>print()</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDoubled</span> <span class="params">(T <span class="type">const</span>&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span> (args + args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果这样调用它：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printDoubled</span>(<span class="number">7.5</span>, std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>), std::<span class="built_in">complex</span>&lt;<span class="type">float</span>&gt;(<span class="number">4</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure></p>
<p>效果上和下面的调用相同（除了构造函数方面的不同）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">7.5</span> + <span class="number">7.5</span>, std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>) + std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>),</span><br><span class="line">std::<span class="built_in">complex</span>&lt;<span class="type">float</span>&gt;(<span class="number">4</span>,<span class="number">2</span>) + std::<span class="built_in">complex</span>&lt;<span class="type">float</span>&gt;(<span class="number">4</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure></p>
<p>如果只是想向每个参数加1，省略号…中的点不能紧跟在数值后面：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addOne</span> <span class="params">(T <span class="type">const</span>&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span> (args + <span class="number">1.</span>..); <span class="comment">// ERROR: 1... is a literal with too many decimal points</span></span><br><span class="line">    <span class="built_in">print</span> (args + <span class="number">1</span> ...); <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">print</span> ((args + <span class="number">1</span>)...); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译阶段的表达式同样可以像上面那样包含模板参数包。比如下面这个例子可以用来判断所有参数包中参数的类型是否相同：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span>... TN&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">isHomogeneous</span> <span class="params">(T1, TN...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (std::is_same&lt;T1,TN&gt;::value &amp;&amp; ...); <span class="comment">// since C++17</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是折叠表达式的一种应用。对于：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isHomogeneous</span>(<span class="number">43</span>, <span class="number">-1</span>, <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>会被扩展成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::is_same&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::value &amp;&amp; std::is_same&lt;<span class="type">int</span>,<span class="type">char</span> <span class="type">const</span>*&gt;::value</span><br></pre></td></tr></table></figure></p>
<p>结果自然是false。而对：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isHomogeneous</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>结果则是true，因为所有的参数类型都被推断为<code>char const *</code>（这里因为是按值传递，所以发生了类型退还，否则类型将依次被推断为：<code>char const[6]</code>, <code>char const[1]</code>, <code>char const[6]</code>和<code>char const[2]</code>）。</p>
<h3 id="变参下标（Variadic-Indices）"><a href="#变参下标（Variadic-Indices）" class="headerlink" title="变参下标（Variadic Indices）"></a>变参下标（Variadic Indices）</h3><p>作为另外一个例子，下面的函数通过一组变参下标来访问第一个参数中相应的元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span>... Idx&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printElems</span> <span class="params">(C <span class="type">const</span>&amp; coll, Idx... idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span> (coll[idx]...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; coll = &#123;<span class="string">&quot;good&quot;</span>, <span class="string">&quot;times&quot;</span>, <span class="string">&quot;say&quot;</span>, <span class="string">&quot;bye&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">printElems</span>(coll,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>时，相当于调用了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> (coll[<span class="number">2</span>], coll[<span class="number">0</span>], coll[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure></p>
<p>也可以将非类型模板参数声明成参数包。比如对：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;std::<span class="type">size_t</span>... Idx, <span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printIdx</span> <span class="params">(C <span class="type">const</span>&amp; coll)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(coll[Idx]...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以这样调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; coll = &#123;<span class="string">&quot;good&quot;</span>, <span class="string">&quot;times&quot;</span>, <span class="string">&quot;say&quot;</span>, <span class="string">&quot;bye&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">printIdx</span>&lt;<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>&gt;(coll);</span><br></pre></td></tr></table></figure></p>
<p>效果上和前面的例子相同。</p>
<h3 id="变参类模板"><a href="#变参类模板" class="headerlink" title="变参类模板"></a>变参类模板</h3><p>类模板也可以是变参的。一个重要的例子是，通过任意多个模板参数指定了class相应数据成员的类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Elements&gt;<span class="keyword">class</span> <span class="title class_">Tuple</span>;</span><br><span class="line">Tuple&lt;<span class="type">int</span>, std::string, <span class="type">char</span>&gt; t; <span class="comment">// t can hold integer, string, and character</span></span><br></pre></td></tr></table></figure></p>
<p>另一个例子是指定对象可能包含的类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Variant</span>;</span><br><span class="line">Variant&lt;<span class="type">int</span>, std::string, <span class="type">char</span>&gt; v; <span class="comment">// v can hold integer, string, or character</span></span><br></pre></td></tr></table></figure></p>
<p>也可以将class定义成代表了一组下表的类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type for arbitrary number of indices:</span></span><br><span class="line"><span class="keyword">template</span>&lt;std::<span class="type">size_t</span>...&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Indices</span> &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>可以用它定义一个通过<code>print()</code>打印<code>std::array</code>或者<code>std::tuple</code>中元素的函数，具体打印哪些元素由编译阶段的<code>get&lt;&gt;</code>从给定的下标中获取：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span>... Idx&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printByIdx</span><span class="params">(T t, Indices&lt;Idx...&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(std::<span class="built_in">get</span>&lt;Idx&gt;(t)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以像下面这样使用这个模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;std::string, 5&gt; arr = &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;my&quot;</span>, <span class="string">&quot;new&quot;</span>, <span class="string">&quot;!&quot;</span>, <span class="string">&quot;World&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">printByIdx</span>(arr, <span class="built_in">Indices</span>&lt;<span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>&gt;());</span><br></pre></td></tr></table></figure></p>
<p>或者像下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> t = std::<span class="built_in">make_tuple</span>(<span class="number">12</span>, <span class="string">&quot;monkeys&quot;</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="built_in">printByIdx</span>(t, <span class="built_in">Indices</span>&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&gt;());</span><br></pre></td></tr></table></figure></p>
<h3 id="变参推断指引"><a href="#变参推断指引" class="headerlink" title="变参推断指引"></a>变参推断指引</h3><p>推断指引也可以是变参的。比如在C++标准库中，为<code>std::array</code>定义了如下推断指引：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... U&gt; <span class="title">array</span><span class="params">(T, U...)</span></span></span><br><span class="line"><span class="function">    -&gt; array&lt;<span class="type">enable_if_t</span>&lt;<span class="params">(is_same_v&lt;T, U&gt; &amp;&amp; ...)</span>, T&gt;, <span class="params">(<span class="number">1</span> + <span class="keyword">sizeof</span>...(U))</span>&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>针对这样的初始化:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::array a&#123;<span class="number">42</span>,<span class="number">45</span>,<span class="number">77</span>&#125;;</span><br></pre></td></tr></table></figure><br>会将指引中的T推断为array（首）元素的类型，而<code>U...</code>会被推断为剩余元素的类型。因此<code>array</code>中元素总数目是<code>1 + sizeof...(U)</code>，等效于如下声明:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 3&gt; a&#123;<span class="number">42</span>,<span class="number">45</span>,<span class="number">77</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中对<code>array</code>第一个参的操作<code>std::enable_if&lt;&gt;</code>是一个折叠表达式，可以展开成这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is_same_v&lt;T, U1&gt; &amp;&amp; is_same_v&lt;T, U2&gt; &amp;&amp; is_same_v&lt;T, U3&gt; ...</span><br></pre></td></tr></table></figure></p>
<p>如果结果是false（也就是说array中元素不是同一种类型），推断指引会被弃用，总的类型推断失败。这样标准库就可以确保在推断指引成功的情况下，所有元素都是同一种类型。</p>
<h3 id="变参基类及其使用"><a href="#变参基类及其使用" class="headerlink" title="变参基类及其使用"></a>变参基类及其使用</h3><p>最后，考虑如下例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Customer</span>(std::string <span class="type">const</span>&amp; n) : <span class="built_in">name</span>(n) &#123; &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomerEq</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Customer <span class="type">const</span>&amp; c1, Customer <span class="type">const</span>&amp; c2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c<span class="number">1.</span><span class="built_in">getName</span>() == c<span class="number">2.</span><span class="built_in">getName</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomerHash</span> &#123;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Customer <span class="type">const</span>&amp; c)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">hash</span>&lt;std::string&gt;()(c.<span class="built_in">getName</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// define class that combines operator() for variadic base classes:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Bases&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Overloader</span> : Bases...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">using</span> <span class="title">Bases::operator</span><span class="params">()</span>...</span>; <span class="comment">// OK since C++17</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// combine hasher and equality for customers in one type:</span></span><br><span class="line">    <span class="keyword">using</span> CustomerOP = Overloader&lt;CustomerHash,CustomerEq&gt;;</span><br><span class="line">    std::unordered_set&lt;Customer,CustomerHash,CustomerEq&gt; coll1;</span><br><span class="line">    std::unordered_set&lt;Customer,CustomerOP,CustomerOP&gt; coll2;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里首先定义了一个<code>Customer</code>类和一些用来比较<code>Customer</code>对象以及计算这些对象hash值的函数对象。通过<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Bases&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Overloader</span> : Bases...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">using</span> <span class="title">Bases::operator</span><span class="params">()</span>...</span>; <span class="comment">// OK since C++17</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从个数不定的基类派生出了一个新的类，并且从其每个基类中引入了<code>operator()</code>的声明。比如通过：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> CustomerOP = Overloader&lt;CustomerHash,CustomerEq&gt;;</span><br></pre></td></tr></table></figure></p>
<p>从<code>CustomerHash</code>和<code>CustomerEq</code>派生出了<code>CustomerOP</code>，而且派生类中会包含两个基类中的<code>operator()</code>的实现。</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>通过使用参数包，模板可以有任意多个任意类型的参数。</li>
<li>为了处理这些参数，需要使用递归，而且需要一个非变参函数终结递归（如果使用编译期判断，则不需要非变参函数来终结递归）。</li>
<li>运算符sizeof…用来计算参数包中模板参数的数目。</li>
<li>变参模板的一个典型应用是用来发送（forward）任意多个任意类型的模板参数。</li>
<li>通过使用折叠表达式，可以将某种运算应用于参数包中的所有参数。</li>
</ul>
<h1 id="基础技巧"><a href="#基础技巧" class="headerlink" title="基础技巧"></a>基础技巧</h1><p>本章将涉及一些和模板实际使用有关的晋级知识，包含：关键字typename的使用，定义为模板的成员函数以及嵌套类，模板参数模板（template template parameters），零初始化以及其它一些关于使用字符串常量作为模板参数的细节讨论。</p>
<h2 id="typename关键字"><a href="#typename关键字" class="headerlink" title="typename关键字"></a>typename关键字</h2><p>关键字typename在C++标准化过程中被引入进来，用来澄清模板内部的一个标识符代表的是某种类型，而不是数据成员。考虑下面这个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">typename</span> T::SubType* ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中第二个typename被用来澄清SubType是定义在<code>class T</code>中的一个类型。因此在这里<code>ptr</code>是一个指向<code>T::SubType</code>类型的指针。</p>
<p>如果没有typename的话，SubType会被假设成一个非类型成员（比如static成员或者一个枚举常量，亦或者是内部嵌套类或者using声明的public别名）。这样的话，表达式<code>T::SubType* ptr</code>会被理解成<code>class T</code>的<code>static</code>成员<code>SubType</code>与<code>ptr</code>的乘法运算，这不是一个错误，因为对<code>MyClass&lt;&gt;</code>的某些实例化版本而言，这可能是有效的代码。</p>
<p>通常而言，当一个依赖于模板参数的名称代表的是某种类型的时候，就必须使用<code>typename</code>。使用<code>typename</code>的一种场景是用来声明泛型代码中标准容器的迭代器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// print elements of an STL container</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printcoll</span> <span class="params">(T <span class="type">const</span>&amp; coll)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> T::const_iterator pos; <span class="comment">// iterator to iterate over coll</span></span><br><span class="line">    <span class="function"><span class="keyword">typename</span> T::const_iterator <span class="title">end</span><span class="params">(coll.end())</span></span>; <span class="comment">// end position</span></span><br><span class="line">    <span class="keyword">for</span> (pos=coll.<span class="built_in">begin</span>(); pos!=end; ++pos) &#123;</span><br><span class="line">        std::cout &lt;&lt; *pos &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个函数模板中，调用参数是一个类型为T的标准容器。为了遍历容器中的所有元素，使用了声明于每个标准容器中的迭代器类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">stlcontainer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> iterator = ...; <span class="comment">// iterator for read/write access</span></span><br><span class="line">    <span class="keyword">using</span> const_iterator = ...; <span class="comment">// iterator for read access</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>因此为了使用模板类型T的<code>cons_iterator</code>，必须在其前面使用<code>typename</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> T::const_iterator pos;</span><br></pre></td></tr></table></figure></p>
<h2 id="零初始化"><a href="#零初始化" class="headerlink" title="零初始化"></a>零初始化</h2><p>对于基础类型，比如int，double以及指针类型，由于它们没有默认构造函数，因此它们不会被默认初始化成一个有意义的值。比如任何未被初始化的局部变量的值都是未定义的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// x has undefined value</span></span><br><span class="line">    <span class="type">int</span>* ptr; <span class="comment">// ptr points to anywhere (instead of nowhere)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此在定义模板时，如果想让一个模板类型的变量被初始化成一个默认值，那么只是简单的定义是不够的，因为对内置类型，它们不会被初始化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T x; <span class="comment">// x has undefined value if T is built-in type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>出于这个原因，对于内置类型，最好显式的调用其默认构造函数来将它们初始化成0（对于bool类型，初始化为false，对于指针类型，初始化成nullptr）。通过下面你的写法就可以保证即使是内置类型也可以得到适当的初始化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T x&#123;&#125;; <span class="comment">// x is zero (or false) if T is a built-in type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种初始化的方法被称为“值初始化（value initialization）”，它要么调用一个对象已有的构造函数，要么就用零来初始化这个对象。即使它有显式的构造函数也是这样。</p>
<p>在C++11之前，确保一个对象得到显示初始化的方式是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T x = <span class="built_in">T</span>(); <span class="comment">// x is zero (or false) if T is a built-in type</span></span><br></pre></td></tr></table></figure></p>
<p>在C++17之前，只有在与拷贝初始化对应的构造函数没有被声明为explicit的时候，这一方式才有效（目前也依然被支持）。从C++17开始，由于强制拷贝省略（mandatory copy elision）的使用，这一限制被解除，因此在C++17之后以上两种方式都有效。不过对于用花括号初始化的情况，如果没有可用的默认构造函数，它还可以使用列表初始化构造函数（initializer-list constructor）。</p>
<p>为确保类模板中类型被参数化了的成员得到适当的初始化，可以定义一个默认的构造函数并在其中对相应成员做初始化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() : x&#123;&#125; &#123; <span class="comment">// ensures that x is initialized even for</span></span><br><span class="line">        built-in types</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>C++11之前的语法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>() : <span class="built_in">x</span>() &#123; <span class="comment">//ensures that x is initialized even forbuilt-in types</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>也依然有效。从C++11开始也可以通过如下方式对非静态成员进行默认初始化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T x&#123;&#125;; <span class="comment">// zero-initialize x unless otherwise specified</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是不可以对默认参数使用这一方式，比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T p&#123;&#125;)</span> </span>&#123; <span class="comment">//ERROR</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对这种情况必须像下面这样初始化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T p = T&#123;&#125;)</span> </span>&#123; <span class="comment">//OK (must use T() before C++11)</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用this-gt"><a href="#使用this-gt" class="headerlink" title="使用this-&gt;"></a>使用this-&gt;</h2><p>对于类模板，如果它的基类也是依赖于模板参数的，那么对它而言即使x是继承而来的，使用<code>this-&gt;x</code>和<code>x</code>也不一定是等效的。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : Base&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">bar</span>(); <span class="comment">// calls external bar() or error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>Derived</code>中的<code>bar()</code>永远不会被解析成<code>Base</code>中的<code>bar()</code>。因此这样做要么会遇到错误，要么就是调用了其它地方的<code>bar()</code>（比如可能是定义在其它地方的global的<code>bar()</code>）。</p>
<p>作为经验法则，建议当使用定义于基类中的、依赖于模板参数的成员时，用<code>this-&gt;</code>或者<code>Base&lt;T&gt;::</code>来修饰它。</p>
<h2 id="使用裸数组或者字符串常量的模板"><a href="#使用裸数组或者字符串常量的模板" class="headerlink" title="使用裸数组或者字符串常量的模板"></a>使用裸数组或者字符串常量的模板</h2><p>当向模板传递裸数组或者字符串常量时，需要格外注意以下内容：</p>
<p>第一，如果参数是按引用传递的，那么参数类型不会退化（decay）。也就是说当传递”hello”作为参数时，模板类型会被推断为<code>char const[6]</code>。这样当向模板传递长度不同的裸数组或者字符串常量时就可能遇到问题，因为它们对应的模板类型不一样。只有当按值传递参数时，模板类型才会退化（decay），这样字符串常量会被推断为<code>char const *</code>。</p>
<p>不过也可以像下面这样定义专门用来处理裸数组或者字符串常量的模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N, <span class="type">int</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">less</span> <span class="params">(T(&amp;a)[N], T(&amp;b)[M])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;N &amp;&amp; i&lt;M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i]&lt;b[i]) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">if</span> (b[i]&lt;a[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> N &lt; M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当像下面这样使用该模板的时候：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> y[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">less</span>(x,y) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>less&lt;&gt;</code>中的T会被实例化成int，N被实例化成3，M被实例化成5。也可以将该模板用于字符串常量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in">less</span>(<span class="string">&quot;ab&quot;</span>,<span class="string">&quot;abc&quot;</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p>这里<code>less&lt;&gt;</code>中的T会被实例化成<code>char const</code>，N被实例化成3，M被实例化成4。如果想定义一个只是用来处理字符串常量的函数模板，可以像下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> N, <span class="type">int</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">less</span> <span class="params">(<span class="type">char</span> <span class="type">const</span>(&amp;a)[N], <span class="type">char</span> <span class="type">const</span>(&amp;b)[M])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;N &amp;&amp; i&lt;M; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i]&lt;b[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (b[i]&lt;a[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> N &lt; M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请注意你可以某些情况下可能也必须去为边界未知的数组做重载或者部分特化。下面的代码展示了对数组所做的所有可能的重载：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span>; <span class="comment">//主模板</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> SZ&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span>&lt;T[SZ]&gt; <span class="comment">// partial specialization for arrays of known bounds</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;print() for T[&quot;</span> &lt;&lt; SZ &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> SZ&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span>&lt;<span class="built_in">T</span>(&amp;)[SZ]&gt; <span class="comment">// partial spec. for references to arrays of known bounds</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;print() for T(&amp;)[&quot;</span> &lt;&lt; SZ &lt;&lt;<span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span>&lt;T[]&gt; <span class="comment">// partial specialization for arrays of unknown bounds</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;print() for T[]\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span>&lt;<span class="built_in">T</span>(&amp;)[]&gt; <span class="comment">// partial spec. for references to arrays of unknown bounds</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;print() for T(&amp;)[]\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span>&lt;T*&gt; <span class="comment">// partial specialization for pointers</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;print() for T*\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码针对以下类型对<code>MyClass&lt;&gt;</code>做了特化：边界已知和未知的数组，边界已知和未知的数组的引用，以及指针。它们之间互不相同，在各种情况下的调用关系如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;arrays.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a1[<span class="number">7</span>], <span class="type">int</span> a2[], <span class="comment">// pointers by language rules</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> (&amp;a3)[<span class="number">42</span>], <span class="comment">// reference to array of known bound</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> (&amp;x0)[], <span class="comment">// reference to array of unknown bound</span></span></span></span><br><span class="line"><span class="params"><span class="function">    T1 x1, <span class="comment">// passing by value decays</span></span></span></span><br><span class="line"><span class="params"><span class="function">    T2&amp; x2, T3&amp;&amp; x3)</span> <span class="comment">// passing by reference</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass&lt;<span class="keyword">decltype</span>(a1)&gt;::<span class="built_in">print</span>(); <span class="comment">// uses MyClass&lt;T*&gt;</span></span><br><span class="line">    MyClass&lt;<span class="keyword">decltype</span>(a2)&gt;::<span class="built_in">print</span>(); <span class="comment">// uses MyClass&lt;T*&gt; a1, a2退化成指针</span></span><br><span class="line">    MyClass&lt;<span class="keyword">decltype</span>(a3)&gt;::<span class="built_in">print</span>(); <span class="comment">// uses MyClass&lt;T(&amp;)[SZ]&gt;</span></span><br><span class="line">    MyClass&lt;<span class="keyword">decltype</span>(x0)&gt;::<span class="built_in">print</span>(); <span class="comment">// uses MyClass&lt;T(&amp;)[]&gt;</span></span><br><span class="line">    MyClass&lt;<span class="keyword">decltype</span>(x1)&gt;::<span class="built_in">print</span>(); <span class="comment">// uses MyClass&lt;T*&gt;</span></span><br><span class="line">    MyClass&lt;<span class="keyword">decltype</span>(x2)&gt;::<span class="built_in">print</span>(); <span class="comment">// uses MyClass&lt;T(&amp;)[]&gt;</span></span><br><span class="line">    MyClass&lt;<span class="keyword">decltype</span>(x3)&gt;::<span class="built_in">print</span>(); <span class="comment">// uses MyClass&lt;T(&amp;)[]&gt; //万能引用，引用折叠</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">42</span>];</span><br><span class="line">    MyClass&lt;<span class="keyword">decltype</span>(a)&gt;::<span class="built_in">print</span>(); <span class="comment">// uses MyClass&lt;T[SZ]&gt;</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> x[]; <span class="comment">// forward declare array</span></span><br><span class="line">    MyClass&lt;<span class="keyword">decltype</span>(x)&gt;::<span class="built_in">print</span>(); <span class="comment">// uses MyClass&lt;T[]&gt;</span></span><br><span class="line">    <span class="built_in">foo</span>(a, a, a, x, x, x, x);</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> x[] = &#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">15</span>&#125;; <span class="comment">// define forward-declared array</span></span><br></pre></td></tr></table></figure></p>
<p>注意，根据语言规则，如果调用参数被声明为数组的话，那么它的真实类型是指针类型。而<br>且针对未知边界数组定义的模板，可以用于不完整类型，比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i[];</span><br></pre></td></tr></table></figure></p>
<p>当这一数组被按照引用传递时，它的类型是<code>int(&amp;)[]</code>，同样可以用于模板参数。</p>
<h2 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h2><p>类的成员也可以是模板，对嵌套类和成员函数都是这样。这一功能的作用和优点同样可以通过<code>Stack&lt;&gt;</code>类模板得到展现。通常只有当两个stack类型相同的时候才可以相互赋值（stack的类型相同说明它们的元素类型也相同）。即使两个stack的元素类型之间可以隐式转换，也不能相互赋值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="type">int</span>&gt; intStack1, intStack2; <span class="comment">// stacks for ints</span></span><br><span class="line">Stack&lt;<span class="type">float</span>&gt; floatStack; <span class="comment">// stack for floats</span></span><br><span class="line">...</span><br><span class="line">intStack1 = intStack2; <span class="comment">// OK: stacks have same type</span></span><br><span class="line">floatStack = intStack1; <span class="comment">// ERROR: stacks have different types</span></span><br></pre></td></tr></table></figure></p>
<p>默认的赋值运算符要求等号两边的对象类型必须相同，因此如果两个stack之间的元素类型不同的话，这一条件将得不到满足。但是，只要将赋值运算符定义成模板，就可以将两个元素类型可以做转换的stack相互赋值。新的<code>Stack&lt;&gt;</code>定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::deque&lt;T&gt; elems; <span class="comment">// elements</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp;)</span></span>; <span class="comment">// push element</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element</span></span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// return top element</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// assign stack of elements of type T2</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">    Stack&amp; <span class="keyword">operator</span>= (Stack&lt;T2&gt; <span class="type">const</span>&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上代码中有如下两点改动：</p>
<ol>
<li>赋值运算符的参数是一个元素类型为T2的stack。</li>
<li>新的模板使用<code>std::deque&lt;&gt;</code>作为内部容器。这是为了方便新的赋值运算符的定义。新的赋值运算符被定义成下面这样：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">Stack&lt;T&gt;&amp; Stack&lt;T&gt;::<span class="keyword">operator</span>= (Stack&lt;T2&gt; <span class="type">const</span>&amp; op2)</span><br><span class="line">&#123;</span><br><span class="line">    Stack&lt;T2&gt; <span class="built_in">tmp</span>(op2); <span class="comment">// create a copy of the assigned stack</span></span><br><span class="line">    elems.<span class="built_in">clear</span>(); <span class="comment">// remove existing elements</span></span><br><span class="line">    <span class="keyword">while</span> (!tmp.<span class="built_in">empty</span>()) &#123; <span class="comment">// copy all elements</span></span><br><span class="line">        elems.<span class="built_in">push_front</span>(tmp.<span class="built_in">top</span>());</span><br><span class="line">        tmp.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面先来看一下成员模板的定义语法。在模板类型为T的模板内部，定义了一个模板类型为<code>T2</code>的内部模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>在模板函数内部，你可能希望简化op2中相关元素的访问。但是由于op2属于另一种类型，因此最好使用它们的公共接口。这样访问元素的唯一方法就是通过调用<code>top()</code>。这就要求op2中所有元素相继出现在栈顶，为了不去改动op2，就需要做一次op2的拷贝。由于<code>top()</code>返回的是最后一个被添加进stack的元素，因此需要选用一个支持在另一端插入元素的容器，这就是为什么选用<code>std::deque&lt;&gt;</code>的原因，因为它的<code>push_front()</code>方法可以将元素添加到另一端。</p>
<p>为了访问op2的私有成员，可以将其它所有类型的stack模板的实例都定义成友元：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::deque&lt;T&gt; elems; <span class="comment">// elements</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp;)</span></span>; <span class="comment">// push element</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element</span></span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// return top element</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// assign stack of elements of type T2</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">    Stack&amp; <span class="keyword">operator</span>= (Stack&lt;T2&gt; <span class="type">const</span>&amp;);</span><br><span class="line">    <span class="comment">// to get access to private members of Stack&lt;T2&gt; for any type T2:</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Stack</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如你所见，由于模板参数的名字不会被用到，因此可以被省略掉：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Stack</span>;</span><br></pre></td></tr></table></figure></p>
<p>这样就就可以将赋值运算符定义成如下形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">Stack&lt;T&gt;&amp; Stack&lt;T&gt;::<span class="keyword">operator</span>= (Stack&lt;T2&gt; <span class="type">const</span>&amp; op2)</span><br><span class="line">&#123;</span><br><span class="line">    elems.<span class="built_in">clear</span>(); <span class="comment">// remove existing elements</span></span><br><span class="line">    elems.<span class="built_in">insert</span>(elems.<span class="built_in">begin</span>(), <span class="comment">// insert at the beginning</span></span><br><span class="line">        op<span class="number">2.</span>elems.<span class="built_in">begin</span>(), <span class="comment">// all elements from op2</span></span><br><span class="line">        op<span class="number">2.</span>elems.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>无论采用哪种实现方式，都可以通过这个成员模板将存储int的stack赋值给存储float的stack：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="type">int</span>&gt; intStack; <span class="comment">// stack for ints</span></span><br><span class="line">Stack&lt;<span class="type">float</span>&gt; floatStack; <span class="comment">// stack for floats</span></span><br><span class="line">... </span><br><span class="line">floatStack = intStack; <span class="comment">// OK: stacks have different types,</span></span><br><span class="line"><span class="comment">// but int converts to float</span></span><br></pre></td></tr></table></figure></p>
<p>当然，这样的赋值就不会改变<code>floatStack</code>的类型，也不会改变它的元素的类型。在赋值之后，<code>floatStack</code>存储的元素依然是float类型，<code>top()</code>返回的值也依然是float类型。看上去这个赋值运算符模板不会进行类型检查，这样就可以在存储任意类型的两个stack之间相互赋值，但是事实不是这样。必要的类型检查会在将源stack中的元素插入到目标stack中的时候进行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elems.<span class="built_in">push_front</span>(tmp.<span class="built_in">top</span>());</span><br></pre></td></tr></table></figure></p>
<p>比如如果将存储string的stack赋值给存储int的stack，那么在编译这一行代码的时候会遇到如下错误信息：不能将通过<code>tmp.top()</code>返回的<code>string</code>用作<code>elems.push_front()</code>的参数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;std::string&gt; stringStack; <span class="comment">// stack of strings</span></span><br><span class="line">Stack&lt;<span class="type">float</span>&gt; floatStack; <span class="comment">// stack of floats</span></span><br><span class="line">... </span><br><span class="line">floatStack = stringStack; <span class="comment">// ERROR: std::string doesn&quot;t convert to float</span></span><br></pre></td></tr></table></figure></p>
<p>同样也可以将内部的容器类型参数化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont = std::deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Cont elems; <span class="comment">// elements</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp;)</span></span>; <span class="comment">// push element</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element</span></span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// return top element</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// assign stack of elements of type T2</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2, <span class="keyword">typename</span> Cont2&gt;</span><br><span class="line">    Stack&amp; <span class="keyword">operator</span>= (Stack&lt;T2,Cont2&gt; <span class="type">const</span>&amp;);</span><br><span class="line">    <span class="comment">// to get access to private members of Stack&lt;T2&gt; for any type T2:</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Stack</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>此时赋值运算符的实现会像下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2, <span class="keyword">typename</span> Cont2&gt;</span><br><span class="line">Stack&lt;T,Cont&gt;&amp; Stack&lt;T,Cont&gt;::<span class="keyword">operator</span>= (Stack&lt;T2,Cont2&gt; <span class="type">const</span>&amp; op2)</span><br><span class="line">&#123;</span><br><span class="line">    elems.<span class="built_in">clear</span>(); <span class="comment">// remove existing elements</span></span><br><span class="line">    elems.<span class="built_in">insert</span>(elems.<span class="built_in">begin</span>(), <span class="comment">// insert at the beginning</span></span><br><span class="line">    op<span class="number">2.</span>elems.<span class="built_in">begin</span>(), <span class="comment">// all elements from op2</span></span><br><span class="line">    op<span class="number">2.</span>elems.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>记住，对类模板而言，其成员函数只有在被用到的时候才会被实例化。因此对上面的例子，如果能够避免在不同元素类型的stack之间赋值的话，甚至可以使用vector（没有<code>push_front</code>方法）作为内部容器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack for ints using a vector as an internal container</span></span><br><span class="line">Stack&lt;<span class="type">int</span>,std::vector&lt;<span class="type">int</span>&gt;&gt; vStack;</span><br><span class="line">... </span><br><span class="line">vStack.<span class="built_in">push</span>(<span class="number">42</span>); vStack.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">std::cout &lt;&lt; vStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p>由于没有用到赋值运算符模板，程序运行良好，不会报错说<code>vector</code>没有<code>push_front()</code>方法。</p>
<h3 id="成员模板的特例化"><a href="#成员模板的特例化" class="headerlink" title="成员模板的特例化"></a>成员模板的特例化</h3><p>成员函数模板也可以被全部或者部分地特例化。比如对下面这个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BoolString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BoolString</span> (std::string <span class="type">const</span>&amp; s)</span><br><span class="line">        : <span class="built_in">value</span>(s) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T </span>= std::string&gt;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// get value (converted to T)</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以像下面这样对其成员函数模板<code>get()</code>进行全特例化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// full specialization for BoolString::getValue&lt;&gt;() for bool</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> BoolString::<span class="built_in">get</span>&lt;<span class="type">bool</span>&gt;() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value == <span class="string">&quot;true&quot;</span> || value == <span class="string">&quot;1&quot;</span> || value == <span class="string">&quot;on&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意我们不需要也不能够对特例化的版本进行声明；只能定义它们。由于这是一个定义于头文件中的全实例化版本，如果有多个编译单include了这个头文件，为避免重复定义的错误，必须将它定义成inline的。</p>
<p>可以像下面这样使用这个class以及它的全特例化版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; std::boolalpha;</span><br><span class="line"><span class="function">BoolString <span class="title">s1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; s<span class="number">1.</span><span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//prints hello</span></span><br><span class="line">std::cout &lt;&lt; s<span class="number">1.</span><span class="built_in">get</span>&lt;<span class="type">bool</span>&gt;() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//prints false</span></span><br><span class="line"><span class="function">BoolString <span class="title">s2</span><span class="params">(<span class="string">&quot;on&quot;</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; s<span class="number">2.</span><span class="built_in">get</span>&lt;<span class="type">bool</span>&gt;() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//prints true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="特殊成员函数的模板"><a href="#特殊成员函数的模板" class="headerlink" title="特殊成员函数的模板"></a>特殊成员函数的模板</h3><p>如果能够通过特殊成员函数copy或者move对象，那么相应的特殊成员函数（copy构造函数以及move构造函数）也将可以被模板化。和前面定义的赋值运算符类似，构造函数也可以是模板。但是需要注意的是，构造函数模板或者赋值运算符模板不会取代预定义的构造函数和赋值运算符。成员函数模板不会被算作用来copy或者move对象的特殊成员函数。在上面的例子中，如果在相同类型的stack之间相互赋值，调用的依然是默认赋值运算符。这种行为既有好处也有坏处：</p>
<ul>
<li>某些情况下，对于某些调用，构造函数模板或者赋值运算符模板可能比预定义的copy/move构造函数或者赋值运算符更匹配，虽然这些特殊成员函数模板可能原本只打算用于在不同类型的stack之间做初始化。</li>
<li>想要对copy/move构造函数进行模板化并不是一件容易的事情，比如该如何限制其存在的场景。</li>
</ul>
<h3 id="template的使用"><a href="#template的使用" class="headerlink" title=".template的使用"></a>.template的使用</h3><p>某些情况下，在调用成员模板的时候需要显式地指定其模板参数的类型。这时候就需要使用关键字template来确保符号&lt;会被理解为模板参数列表的开始，而不是一个比较运算符。考虑下面这个使用了标准库中的bitset的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBitset</span> <span class="params">(std::bitset&lt;N&gt; <span class="type">const</span>&amp; bs)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; bs.<span class="keyword">template</span> to_string&lt;<span class="type">char</span>,</span><br><span class="line">    std::char_traits&lt;<span class="type">char</span>&gt;,</span><br><span class="line">    std::allocator&lt;<span class="type">char</span>&gt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于bitset类型的bs，调用了其成员函数模板<code>to_string()</code>，并且指定了<code>to_string()</code>模板的所有模板参数。如果没有<code>.template</code>的话，编译器会将<code>to_string()</code>后面的<code>&lt;</code>符号理解成小于运算符，而不是模板的参数列表的开始。这一这种情况只有在点号前面的对象依赖于模板参数的时候才会发生。在我们的例子中，bs依赖于模板参数N。</p>
<p><code>.template</code>标识符（标识符<code>-&gt;template</code>和<code>::template</code>也类似）只能被用于模板内部，并且它前面的对象应该依赖于模板参数。</p>
<h3 id="泛型lambdas和成员模板"><a href="#泛型lambdas和成员模板" class="headerlink" title="泛型lambdas和成员模板"></a>泛型lambdas和成员模板</h3><p>在C++14中引入的泛型lambdas，是一种成员模板的简化。对于一个简单的计算两个任意类型参数之和的lambda：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[] (<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译器会默认为它构造下面这样一个类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeCompilerSpecificName</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SomeCompilerSpecificName</span>(); <span class="comment">// constructor only callable by compiler</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(T1 x, T2 y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="变量模板"><a href="#变量模板" class="headerlink" title="变量模板"></a>变量模板</h2><p>从C++14开始，变量也可以被某种类型参数化。称为变量模板。例如可以通过下面的代码定义pi，但是参数化了其类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi&#123;<span class="number">3.1415926535897932385</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意，和其它几种模板类似，这个定义最好不要出现在函数内部或者块作用域内部。</p>
<p>在使用变量模板的时候，必须指明它的类型。比如下面的代码在定义<code>pi&lt;&gt;</code>的作用域内使用了两个不同的变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; pi&lt;<span class="type">double</span>&gt; &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; pi&lt;<span class="type">float</span>&gt; &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p>变量模板也可以用于不同编译单元：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T val&#123;&#125;; <span class="comment">// zero initialized value</span></span><br><span class="line"><span class="comment">//== translation unit 1:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;header.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    val&lt;<span class="type">long</span>&gt; = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//== translation unit 2:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;header.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; val&lt;<span class="type">long</span>&gt; &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// OK: prints 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可有默认模板类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">long</span> <span class="type">double</span>&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi = T&#123;<span class="number">3.1415926535897932385</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以像下面这样使用默认类型或者其它类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; pi&lt;&gt; &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//outputs a long double</span></span><br><span class="line">std::cout &lt;&lt; pi&lt;<span class="type">float</span>&gt; &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//outputs a float</span></span><br></pre></td></tr></table></figure></p>
<p>只是无论怎样都要使用尖括号<code>&lt;&gt;</code>，不可以只用pi：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; pi &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure><br>同样可以用非类型参数对变量模板进行参数化，也可以将非类型参数用于参数器的初始化。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line">std::array&lt;<span class="type">int</span>,N&gt; arr&#123;&#125;; <span class="comment">// array with N elements, zero-initialized</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">auto</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">decltype</span><span class="params">(N)</span> dval </span>= N; <span class="comment">// type of dval depends on passed value</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; dval&lt;<span class="string">&quot;c&quot;</span>&gt; &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// N has value &quot;c&quot;of type char</span></span><br><span class="line">    arr&lt;<span class="number">10</span>&gt;[<span class="number">0</span>] = <span class="number">42</span>; <span class="comment">// sets first element of global arr</span></span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;arr&lt;<span class="number">10</span>&gt;.<span class="built_in">size</span>(); ++i) &#123; <span class="comment">// uses values set in arr</span></span><br><span class="line">        std::cout &lt;&lt; arr&lt;<span class="number">10</span>&gt;[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意在不同编译单元间初始化或者遍历arr的时候，使用的都是同一个全局作用域里的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 10&gt; arr。</span><br></pre></td></tr></table></figure></p>
<h3 id="用于数据成员的变量模板"><a href="#用于数据成员的变量模板" class="headerlink" title="用于数据成员的变量模板"></a>用于数据成员的变量模板</h3><p>变量模板的一种应用场景是，用于定义代表类模板成员的变量模板。比如如果像下面这样定义一个类模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> max = <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>那么就可以为<code>MyClass&lt;&gt;</code>的不同特例化版本定义不同的值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> myMax = MyClass&lt;T&gt;::max;</span><br></pre></td></tr></table></figure></p>
<p>应用工程师就可以使用下面这样的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = myMax&lt;std::string&gt;;</span><br></pre></td></tr></table></figure></p>
<p>而不是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = MyClass&lt;std::string&gt;::max;</span><br></pre></td></tr></table></figure></p>
<p>这意味着对于一个标准库的类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">numeric_limits</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_signed = <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> isSigned = std::numeric_limits&lt;T&gt;::is_signed;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isSigned&lt;<span class="type">char</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>代替：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::numeric_limits&lt;<span class="type">char</span>&gt;::is_signed</span><br></pre></td></tr></table></figure></p>
<h3 id="类型萃取Suffix-v"><a href="#类型萃取Suffix-v" class="headerlink" title="类型萃取Suffix_v"></a>类型萃取Suffix_v</h3><p>从C++17开始，标准库用变量模板为其用来产生一个值（布尔型）的类型萃取定义了简化方式。比如为了能够使用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::is_const_v&lt;T&gt; <span class="comment">// since C++17</span></span><br></pre></td></tr></table></figure></p>
<p>而不是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::is_const&lt;T&gt;::value <span class="comment">//since C++11</span></span><br></pre></td></tr></table></figure></p>
<p>标准库做了如下定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">bool</span> is_const_v = is_const&lt;T&gt;::value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="模板参数模板"><a href="#模板参数模板" class="headerlink" title="模板参数模板"></a>模板参数模板</h2><p>如果允许模板参数也是一个类模板的话，会有不少好处。在这里依然使用Stack类模板作为例子。对5.5节中的stack模板，如果不想使用默认的内部容器类型<code>std::deque</code>，那么就需要两次指定stack元素的类型。也就是说为了指定内部容器的类型，必须同时指出容器的类型和元素<br>的类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;&gt; vStack; <span class="comment">// integer stack that uses a vector</span></span><br></pre></td></tr></table></figure></p>
<p>使用模板参数模板，在声明Stack类模板的时候就可以只指定容器的类型而不去指定容器中元素的类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="type">int</span>, std::vector&gt; vStack; <span class="comment">// integer stack that uses a vector</span></span><br></pre></td></tr></table></figure></p>
<p>为此就需要在Stack的定义中将第二个模板参数声明为模板参数模板。可能像下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Elem&gt; <span class="keyword">class</span> <span class="title class_">Cont</span> = std::deque&gt;</span><br><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Cont&lt;T&gt; elems; <span class="comment">// elements</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp;)</span></span>; <span class="comment">// push element</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element</span></span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// return top element</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>区别在于第二个模板参数被定义为一个类模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Elem&gt; <span class="keyword">class</span> <span class="title class_">Cont</span></span><br></pre></td></tr></table></figure></p>
<p>默认类型也从<code>std::deque&lt;T&gt;</code>变成<code>std::deque</code>。这个参数必须是一个类模板，它将被第一个模板参数实例化：<code>Cont&lt;T&gt; elems;</code>。</p>
<p>用第一个模板参数实例化第二个模板参数的情况是由Stack自身的情况决定的。实际上，可以在类模板内部用任意类型实例化一个模板参数模板。和往常一样，声明模板参数时可以使用class代替typename。在C++11之前，Cont只能被某个类模板的名字取代。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Elem</span>&gt; <span class="keyword">class</span> <span class="title class_">Cont</span> = std::deque&gt;</span><br><span class="line"><span class="keyword">class</span> Stack &#123; <span class="comment">//OK</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从C++11开始，也可以用别名模板（alias template）取代Cont，但是直到C++17，在声明模板参数模板时才可以用typename代替class：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Elem&gt; <span class="keyword">typename</span> Cont = std::deque&gt;</span><br><span class="line"><span class="keyword">class</span> Stack &#123; <span class="comment">//ERROR before C++17</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这两个变化的目的都一样：用class代替typename不会妨碍我们使用别名模板（alias template）作为和Cont对应的模板参数。由于模板参数模板中的模板参数没有被用到，作为惯例可以省略它：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Cont</span> = std::deque&gt;</span><br><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>成员函数也要做相应的更改。必须将第二个模板参数指定为模板参数模板。比如对于<code>push()</code>成员，其实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Cont</span>&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T,Cont&gt;::<span class="built_in">push</span> (T <span class="type">const</span>&amp; elem)</span><br><span class="line">&#123;</span><br><span class="line">    elems.<span class="built_in">push_back</span>(elem); <span class="comment">// append copy of passed elem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，虽然模板参数模板是类或者别名类（alias templates）的占位符，但是并没有与其对应的函数模板或者变量模板的占位符。</p>
<h3 id="模板参数模板的参数匹配"><a href="#模板参数模板的参数匹配" class="headerlink" title="模板参数模板的参数匹配"></a>模板参数模板的参数匹配</h3><p>如果你尝试使用新版本的Stack，可能会遇到错误说默认的<code>std::deque</code>和模板参数模板<code>Cont</code>不匹配。这是因为在C++17之前，<code>template&lt;typename Elem&gt; typename Cont = std::deque</code>中的模板参数必须和实际参数（<code>std::deque</code>）的模板参数匹配。而且实际参数（<code>std::deque</code>有两个参数，第二个是默认参数<code>allocator</code>）的默认参数也要被匹配，这样<code>template&lt;typename Elem&gt; typename Cont = std::dequ</code>就不满足以上要求。</p>
<p>作为变通，可以将类模板定义成下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Elem,</span><br><span class="line">    <span class="keyword">typename</span> Alloc = std::allocator&lt;Elem&gt;&gt; <span class="keyword">class</span> Cont = std::deque&gt;</span><br><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Cont&lt;T&gt; elems; <span class="comment">// elements</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中的Alloc同样可以被省略掉。因此最终的Stack模板会像下面这样（包含了赋值运算符模板）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Elem, <span class="keyword">typename</span> =</span><br><span class="line">    std::allocator&lt;Elem&gt;&gt; <span class="keyword">class</span> Cont = std::deque&gt;</span><br><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Cont&lt;T&gt; elems; <span class="comment">// elements</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp;)</span></span>; <span class="comment">// push element</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element</span></span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// return top element</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// assign stack of elements of type T2</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Elem2,</span><br><span class="line">        <span class="keyword">typename</span> = std::allocator&lt;Elem2&gt; &gt;<span class="keyword">class</span> Cont2&gt;</span><br><span class="line">    Stack&lt;T,Cont&gt;&amp; <span class="keyword">operator</span>= (Stack&lt;T2,Cont2&gt; <span class="type">const</span>&amp;);</span><br><span class="line">    <span class="comment">// to get access to private members of any Stack with elements of type T2:</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt;<span class="keyword">class</span>&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Stack</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>,<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Cont</span>&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T,Cont&gt;::<span class="built_in">push</span> (T <span class="type">const</span>&amp; elem)</span><br><span class="line">&#123;</span><br><span class="line">    elems.<span class="built_in">push_back</span>(elem); <span class="comment">// append copy of passed elem</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>,<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Cont</span>&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T,Cont&gt;::<span class="built_in">pop</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());</span><br><span class="line">    elems.<span class="built_in">pop_back</span>(); <span class="comment">// remove last element</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>,<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Cont</span>&gt;</span><br><span class="line">T <span class="type">const</span>&amp; Stack&lt;T,Cont&gt;::<span class="built_in">top</span> () <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!elems.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">return</span> elems.<span class="built_in">back</span>(); <span class="comment">// return copy of last element</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>,<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Cont</span>&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>,<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Cont2</span>&gt;</span><br><span class="line">Stack&lt;T,Cont&gt;&amp; Stack&lt;T,Cont&gt;::<span class="keyword">operator</span>= (Stack&lt;T2,Cont2&gt; <span class="type">const</span>&amp; op2)</span><br><span class="line">&#123;</span><br><span class="line">    elems.<span class="built_in">clear</span>(); <span class="comment">// remove existing elements</span></span><br><span class="line">    elems.<span class="built_in">insert</span>(elems.<span class="built_in">begin</span>(), <span class="comment">// insert at the beginning</span></span><br><span class="line">    op<span class="number">2.</span>elems.<span class="built_in">begin</span>(), <span class="comment">// all elements from op2</span></span><br><span class="line">    op<span class="number">2.</span>elems.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里为了访问赋值运算符op2中的元素，将其它所有类型的Stack声明为friend（省略模板参数的名称）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt;<span class="keyword">class</span>&gt;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Stack</span>;</span><br></pre></td></tr></table></figure></p>
<p>同样，不是所有的标准库容器都可以用做Cont参数。比如std::array就不行，因为它有一个非类型的代表数组长度的模板参数，在上面的模板中没有与之对应的模板参数。下面的例子用到了最终版Stack模板的各种特性：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack9.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack&lt;<span class="type">int</span>&gt; iStack; <span class="comment">// stack of ints</span></span><br><span class="line">    Stack&lt;<span class="type">float</span>&gt; fStack; <span class="comment">// stack of floats</span></span><br><span class="line">    <span class="comment">// manipulate int stack</span></span><br><span class="line">    iStack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    iStack.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;iStack.top(): &quot;</span> &lt;&lt; iStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// manipulate float stack:</span></span><br><span class="line">    fStack.<span class="built_in">push</span>(<span class="number">3.3</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;fStack.top(): &quot;</span> &lt;&lt; fStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// assign stack of different type and manipulate again</span></span><br><span class="line">    fStack = iStack;</span><br><span class="line">    fStack.<span class="built_in">push</span>(<span class="number">4.4</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;fStack.top(): &quot;</span> &lt;&lt; fStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// stack for doubless using a vector as an internal container</span></span><br><span class="line">    Stack&lt;<span class="type">double</span>, std::vector&gt; vStack;</span><br><span class="line">    vStack.<span class="built_in">push</span>(<span class="number">5.5</span>);</span><br><span class="line">    vStack.<span class="built_in">push</span>(<span class="number">6.6</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vStack.top(): &quot;</span> &lt;&lt; vStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    vStack = fStack;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vStack: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (! vStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; vStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    vStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序输出如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iStack.<span class="built_in">top</span>(): <span class="number">2</span></span><br><span class="line">fStack.<span class="built_in">top</span>(): <span class="number">3.3</span></span><br><span class="line">fStack.<span class="built_in">top</span>(): <span class="number">4.4</span></span><br><span class="line">vStack.<span class="built_in">top</span>(): <span class="number">6.6</span></span><br><span class="line">vStack: <span class="number">4.4</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><ul>
<li>为了使用依赖于模板参数的类型名称，需要用typename修饰该名称。</li>
<li>为了访问依赖于模板参数的父类中的成员，需要用this-&gt;或者类名修饰该成员。</li>
<li>嵌套类或者成员函数也可以是模板。一种应用场景是实现可以进行内部类型转换的泛型代码。</li>
<li>模板化的构造函数或者赋值运算符不会取代预定义的构造函数和赋值运算符。</li>
<li>使用花括号初始化或者显式地调用默认构造函数，可以保证变量或者成员模板即使被内置类型实例化，也可以被初始化成默认值。</li>
<li>可以为裸数组提供专门的特化模板，它也可以被用于字符串常量。</li>
<li>只有在裸数组和字符串常量不是被按引用传递的时候，参数类型推断才会退化。（裸数组退化成指针）</li>
<li>可以定义变量模板（从C++14开始）。</li>
<li>模板参数也可以是类模板，称为模板参数模板（template template parameters）。</li>
<li>模板参数模板的参数类型必须得到严格匹配。</li>
</ul>
<h1 id="移动语义和enable-if-lt-gt"><a href="#移动语义和enable-if-lt-gt" class="headerlink" title="移动语义和enable_if&lt;&gt;"></a>移动语义和enable_if&lt;&gt;</h1><p>移动语义（move semantics）是C++11引入的一个重要特性。在copy或者赋值的时候，可以通过它将源对象中的内部资源move（“steal” ）到目标对象，而不是copy这些内容。当然这样做的前提是源对象不在需要这些内部资源或者状态（因为源对象将会被丢弃）。</p>
<h2 id="完美转发（Perfect-Forwarding）"><a href="#完美转发（Perfect-Forwarding）" class="headerlink" title="完美转发（Perfect Forwarding）"></a>完美转发（Perfect Forwarding）</h2><p>假设希望实现的泛型代码可以将被传递参数的基本特性转发出去：</p>
<ul>
<li>可变对象被转发之后依然可变。</li>
<li>Const对象被转发之后依然是const的。</li>
<li>可移动对象（可以从中窃取资源的对象）被转发之后依然是可移动的。</li>
</ul>
<p>不使用模板的话，为达到这一目的就需要对以上三种情况分别编程。比如为了将调用<code>f()</code>时传递的参数转发给函数<code>g()</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span> <span class="params">(X&amp;)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;g() for variable\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span> <span class="params">(X <span class="type">const</span>&amp;)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;g() for constant\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span> <span class="params">(X&amp;&amp;)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;g() for movable object\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let f() forward argument val to g():</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(X&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">g</span>(val); <span class="comment">// val is non-const lvalue =&gt; calls g(X&amp;)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(X <span class="type">const</span>&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">g</span>(val); <span class="comment">// val is const lvalue =&gt; calls g(X const&amp;)</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(X&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">g</span>(std::<span class="built_in">move</span>(val)); <span class="comment">// val is non-const lvalue =&gt; needs ::move() to call g(X&amp;&amp;)</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X v; <span class="comment">// create variable</span></span><br><span class="line">    X <span class="type">const</span> c; <span class="comment">// create constant</span></span><br><span class="line">    <span class="built_in">f</span>(v); <span class="comment">// f() for nonconstant object calls f(X&amp;) =&gt; calls g(X&amp;)</span></span><br><span class="line">    <span class="built_in">f</span>(c); <span class="comment">// f() for constant object calls f(X const&amp;) =&gt; calls g(X const&amp;)</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="built_in">X</span>()); <span class="comment">// f() for temporary calls f(X&amp;&amp;) =&gt; calls g(X&amp;&amp;)</span></span><br><span class="line">    <span class="built_in">f</span>(std::<span class="built_in">move</span>(v)); <span class="comment">// f() for movable variable calls f(X&amp;&amp;) =&gt; calls</span></span><br><span class="line">    <span class="built_in">g</span>(X&amp;&amp;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里定义了三种不同的<code>f()</code>，它们分别将其参数转发给<code>g()</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(X&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">g</span>(val); <span class="comment">// val is non-const lvalue =&gt; calls g(X&amp;)</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(X <span class="type">const</span>&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">g</span>(val); <span class="comment">// val is const lvalue =&gt; calls g(X const&amp;)</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(X&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">g</span>(std::<span class="built_in">move</span>(val)); <span class="comment">// val is non-const lvalue =&gt; needs std::move() to call g(X&amp;&amp;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意其中针对可移动对象（一个右值引用）的代码不同于其它两组代码；它需要用<code>std::move()</code>来处理其参数，因为参数的移动语义不会被一起传递。虽然第三个<code>f()</code>中的<code>val</code>被声明成右值引用，但是当其在<code>f()</code>内部被使用时，它依然是一个非常量左值，其行为也将和第一个<code>f()</code>中的情况一样。因此如果不使用<code>std::move()</code>的话，在第三个<code>f()</code>中调用的将是<code>g(X&amp;)</code>而不是<code>g(X&amp;&amp;)</code>。如果试图在泛型代码中统一以上三种情况，会遇到这样一个问题：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(T val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">g</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个模板只对前两种情况有效，对第三种用于可移动对象的情况无效。</p>
<p>基于这一原因，C++11引入了特殊的规则对参数进行完美转发（perfect forwarding）。实现这一目的的惯用方法如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">g</span>(std::forward&lt;T&gt;(val)); <span class="comment">// perfect forward val to g()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意<code>std::move</code>没有模板参数，并且会无条件地移动其参数；而<code>std::forward&lt;&gt;</code>会根据被传递参数的具体情况决定是否“转发”其潜在的移动语义。</p>
<p>不要以为模板参数<code>T</code>的<code>T&amp;&amp;</code>和具体类型<code>X</code>的<code>X&amp;&amp;</code>是一样的。虽然语法上看上去类似，��是它们适用于不同的规则：</p>
<ul>
<li>具体类型<code>X</code>的<code>X&amp;&amp;</code>声明了一个右值引用参数。只能被绑定到一个可移动对象上（一个prvalue，比如临时对象，一个xvalue，比如通过<code>std::move()</code>传递的参数）。它的值总是可变的，而且总是可以被“窃取”。</li>
<li>模板参数<code>T</code>的<code>T&amp;&amp;</code>声明了一个转发引用（亦称万能引用）。可以被绑定到可变、不可变（比如const）或者可移动对象上。在函数内部这个参数也可以是可变、不可变或者指向一个可以被窃取内部数据的值。</li>
</ul>
<p>注意T必须是模板参数的名字。只是依赖于模板参数是不可以的。对于模板参数T，形如<code>typename T::iterator&amp;&amp;</code>的声明只是声明了一个右值引用，不是一个转发引用。因此，一个可以完美转发其参数的程序会像下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span> <span class="params">(X&amp;)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;g() for variable\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span> <span class="params">(X <span class="type">const</span>&amp;)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;g() for constant\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span> <span class="params">(X&amp;&amp;)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;g() for movable object\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let f() perfect forward argument val to g():</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">g</span>(std::forward&lt;T&gt;(val)); <span class="comment">// call the right g() for any passed argument val</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X v; <span class="comment">// create variable</span></span><br><span class="line">    X <span class="type">const</span> c; <span class="comment">// create constant</span></span><br><span class="line">    <span class="built_in">f</span>(v); <span class="comment">// f() for variable calls f(X&amp;) =&gt; calls g(X&amp;)</span></span><br><span class="line">    <span class="built_in">f</span>(c); <span class="comment">// f() for constant calls f(X const&amp;) =&gt; calls g(X const&amp;)</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="built_in">X</span>()); <span class="comment">// f() for temporary calls f(X&amp;&amp;) =&gt; calls g(X&amp;&amp;)</span></span><br><span class="line">    <span class="built_in">f</span>(std::<span class="built_in">move</span>(v)); <span class="comment">// f() for move-enabled variable calls f(X&amp;&amp;)=&gt;</span></span><br><span class="line">    <span class="function">calls <span class="title">g</span><span class="params">(X&amp;&amp;)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>完美转发同样可以被用于变参模板。</p>
<h2 id="特殊成员函数模板"><a href="#特殊成员函数模板" class="headerlink" title="特殊成员函数模板"></a>特殊成员函数模板</h2><p>特殊成员函数也可以是模板，比如构造函数，但是有时候这可能会带来令人意外的结果。考虑下面这个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// constructor for passed initial name:</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(std::string <span class="type">const</span>&amp; n)</span> : name(n) &#123;</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;copying string-CONSTR for &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(std::string&amp;&amp; n)</span> : name(std::move(n)) &#123;</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;moving string-CONSTR for &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy and move constructor:</span></span><br><span class="line">    <span class="built_in">Person</span> (Person <span class="type">const</span>&amp; p) : <span class="built_in">name</span>(p.name) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;COPY-CONSTR Person &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;/n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span> (Person&amp;&amp; p) : <span class="built_in">name</span>(std::<span class="built_in">move</span>(p.name)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MOVE-CONSTR Person &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;sname&quot;</span>;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(s)</span></span>; <span class="comment">// init with string object =&gt; calls copying string-CONSTR</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;tmp&quot;</span>)</span></span>; <span class="comment">// init with string literal =&gt; calls moving string-CONSTR</span></span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(p1)</span></span>; <span class="comment">// copy Person =&gt; calls COPY-CONSTR</span></span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(std::move(p1))</span></span>; <span class="comment">// move Person =&gt; calls MOVE-CONST</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//copying string-CONSTR for sname</span></span><br><span class="line"><span class="comment">//moving string-CONSTR for tmp</span></span><br><span class="line"><span class="comment">//COPY-CONSTR Persosname</span></span><br><span class="line"><span class="comment">//MOVE-CONSTR Person sname</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>例子中<code>Person</code>类有一个<code>string</code>类型的<code>name</code>成员和几个初始化构造函数。为了支持移动语义，重载了接受<code>std::string</code>作为参数的构造函数：</p>
<ul>
<li>一个以<code>std::string</code>对象为参数，并用其副本来初始化name成员：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span>(std::string <span class="type">const</span>&amp; n) : <span class="built_in">name</span>(n) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;copying string-CONSTR for &quot;</span><span class="string">&quot; &lt;&lt; name &lt;&lt; &quot;</span><span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一个以可移动的<code>std::string</code>对象作为参数，并通过<code>std:move()</code>从中窃取值来初始化<code>name</code>：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span>(std::string&amp;&amp; n) : <span class="built_in">name</span>(std::<span class="built_in">move</span>(n)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;moving string-CONSTR for &quot;</span><span class="string">&quot; &lt;&lt; name &lt;&lt; &quot;</span><span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和预期的一样，当传递一个正在使用的值（左值）作为参数时，会调用第一个构造函数，而以可移动对象（右值）为参数时，则会调用第二个构造函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;sname&quot;</span>;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(s)</span></span>; <span class="comment">// init with string object =&gt; calls copying string-CONSTR</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;tmp&quot;</span>)</span></span>; <span class="comment">// init with string literal =&gt; calls moving string-CONSTR</span></span><br></pre></td></tr></table></figure></p>
<p>除了这两个构造函数，例子中还提供了一个拷贝构造函数和一个移动构造函数，从中可以看出Person对象是如何被拷贝和移动的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p1)</span></span>; <span class="comment">// copy Person =&gt; calls COPY-CONSTR</span></span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(std::move(p1))</span></span>; <span class="comment">// move Person =&gt; calls MOVE-CONSTR</span></span><br></pre></td></tr></table></figure></p>
<p>现在将上面两个以<code>std::string</code>作为参数的构造函数替换为一个泛型的构造函数，它将传入的参数完美转发（perfect forward）给成员name：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// generic constructor for passed initial name:</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(STR&amp;&amp; n)</span> : name(std::forward&lt;STR&gt;(n)) &#123;</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;TMPL-CONSTR for &quot;</span><span class="string">&quot; &lt;&lt; name &lt;&lt; &quot;</span><span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy and move constructor:</span></span><br><span class="line">    <span class="built_in">Person</span> (Person <span class="type">const</span>&amp; p) : <span class="built_in">name</span>(p.name) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;COPY-CONSTR Person &quot;</span><span class="string">&quot; &lt;&lt; name &lt;&lt; &quot;</span><span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span> (Person&amp;&amp; p) : <span class="built_in">name</span>(std::<span class="built_in">move</span>(p.name)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MOVE-CONSTR Person &quot;</span><span class="string">&quot; &lt;&lt; name &lt;&lt; &quot;</span><span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这时如果传入参数是<code>std::string</code>的话，依然能够正常工作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;sname&quot;</span>;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(s)</span></span>; <span class="comment">// init with string object =&gt; calls TMPL-CONSTR</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;tmp&quot;</span>)</span></span>; <span class="comment">//init with string literal =&gt; calls TMPL-CONS</span></span><br></pre></td></tr></table></figure></p>
<p>注意这里在构建p2的时候并不会创建一个临时的<code>std::string</code>对象：<code>STR</code>的类型被推断为<code>char const[4]</code>。但是将<code>std::forward&lt;STR&gt;</code>用于指针参数没有太大意义。成员<code>name</code>将会被一个以<code>null</code>结尾的字符串构造。但是，当试图调用拷贝构造函数的时候，会遇到错误：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p1)</span></span>; <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure></p>
<p>而用一个可移动对象初始化<code>Person</code>的话却可以正常工作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(std::move(p1))</span></span>; <span class="comment">// OK: move Person =&gt; calls MOVECONST</span></span><br></pre></td></tr></table></figure></p>
<p>如果试图拷贝一个<code>Person</code>的<code>const</code>对象的话，也没有问题：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="type">const</span> <span class="title">p2c</span><span class="params">(<span class="string">&quot;ctmp&quot;</span>)</span></span>; <span class="comment">//init constant object with string literal</span></span><br><span class="line"><span class="function">Person <span class="title">p3c</span><span class="params">(p2c)</span></span>; <span class="comment">// OK: copy constant Person =&gt; calls COPY-CONSTR</span></span><br></pre></td></tr></table></figure></p>
<p>问题出在这里：根据C++重载解析规则，对于一个非const左值的<code>Person p</code>，成员模板<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR&gt;</span></span><br><span class="line"><span class="function"><span class="title">Person</span><span class="params">(STR&amp;&amp; n)</span></span></span><br></pre></td></tr></table></figure></p>
<p>通常比预定义的拷贝构造函数更匹配：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span> (Person <span class="type">const</span>&amp; p)</span><br></pre></td></tr></table></figure></p>
<p>这里<code>STR</code>可以直接被替换成<code>Person&amp;</code>，但是对拷贝构造函数还要做一步const转换。</p>
<p>额外提供一个非const的拷贝构造函数看上去是个不错的方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span> (Person&amp; p)</span><br></pre></td></tr></table></figure></p>
<p>不过这只是一个部分解决问题的方法，更好的办法依然是使用模板。我们真正想做的是当参数是一个Person对象或者一个可以转换成Person对象的表达式时，不要启用模板。这可以通过<code>std::enable_if&lt;&gt;</code>实现。</p>
<h2 id="通过std-enable-if-lt-gt-禁用模板"><a href="#通过std-enable-if-lt-gt-禁用模板" class="headerlink" title="通过std::enable_if&lt;&gt;禁用模板"></a>通过std::enable_if&lt;&gt;禁用模板</h2><p>从C++11开始，通过C++标准库提供的辅助模板<code>std::enable_if&lt;&gt;</code>，可以在某些编译期条件下忽略掉函数模板。比如，如果函数模板<code>foo&lt;&gt;</code>的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;(<span class="built_in">sizeof</span>(T) &gt; <span class="number">4</span>)&gt;::<span class="function">type <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一模板定义会在<code>sizeof(T) &gt; 4</code>不成立的时候被忽略掉。如果<code>sizeof&lt;T&gt; &gt; 4</code>成立，函数模板会展开成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说<code>std::enable_if&lt;&gt;</code>是一种类型萃取（type trait），它会根据一个作为其（第一个）模板参数的编译期表达式决定其行为：</p>
<ul>
<li>如果这个表达式结果为true，它的type成员会返回一个类型：<ul>
<li>如果没有第二个模板参数，返回类型是void。</li>
<li>否则，返回类型是其第二个参数的类型。</li>
</ul>
</li>
<li>如果表达式结果false，则其成员类型是未定义的。根据模板的一个叫做SFINAE（substitute failure is not an error，替换失败不是错误）的规则，这会导致包含<code>std::enable_if&lt;&gt;</code>表达式的函数模板被忽略掉。</li>
</ul>
<p>由于从C++14开始所有的模板萃取（type traits）都返回一个类型，因此可以使用一个与之对应的别名模板<code>std::enable_if_t&lt;&gt;</code>，这样就可以省略掉<code>template</code>和<code>::type</code>了。如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="type">enable_if_t</span>&lt;(<span class="built_in">sizeof</span>(T) &gt; <span class="number">4</span>)&gt; <span class="built_in">foo</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果给<code>std::enable_if&lt;&gt;</code>或者<code>std::enable_if_t&lt;&gt;</code>传递第二个模板参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="type">enable_if_t</span>&lt;(<span class="built_in">sizeof</span>(T) &gt; <span class="number">4</span>), T&gt;</span><br><span class="line"><span class="built_in">foo</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">T</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么在<code>sizeof(T) &gt; 4</code>时，<code>enable_if</code>会被扩展成其第二个模板参数。因此如果与T对应的模板参数被推断为<code>MyType</code>，而且其size大于4，那么其等效于：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyType <span class="title">foo</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>但是由于将<code>enable_if</code>表达式放在声明的中间不是一个明智的做法，因此使用<code>std::enable_if&lt;&gt;</code>的更常见的方法是使用一个额外的、有默认值的模板参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;(<span class="built_in">sizeof</span>(T) &gt; <span class="number">4</span>)&gt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">foo</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果<code>sizeof(T) &gt; 4</code>，它会被展开成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> </span>= <span class="type">void</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你认为这依然不够明智，并且希望模板的约束更加明显，那么你可以用别名模板（alias template）给它定义一个别名：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> EnableIfSizeGreater4 = std::<span class="type">enable_if_t</span>&lt;(<span class="built_in">sizeof</span>(T) &gt; <span class="number">4</span>)&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = EnableIfSizeGreater4&lt;T&gt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">foo</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用enable-if-lt-gt"><a href="#使用enable-if-lt-gt" class="headerlink" title="使用enable_if&lt;&gt;"></a>使用enable_if&lt;&gt;</h2><p>我们要解决的问题是：当传递的模板参数的类型不正确的时候，禁用如下构造函数模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR&gt;</span></span><br><span class="line"><span class="function"><span class="title">Person</span><span class="params">(STR&amp;&amp; n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>为了这一目的，需要使用另一个标准库的类型萃取，<code>std::is_convertiable&lt;FROM, TO&gt;</code>。在C++17中，相应的构造函数模板的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR, <span class="keyword">typename</span> =</span><br><span class="line">std::<span class="type">enable_if_t</span>&lt;std::is_convertible_v&lt;STR, std::string&gt;&gt;&gt;</span><br><span class="line"><span class="built_in">Person</span>(STR&amp;&amp; n);</span><br></pre></td></tr></table></figure></p>
<p>如果<code>STR</code>可以转换成<code>std::string</code>，这个定义会扩展成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR, <span class="keyword">typename</span> </span>= <span class="type">void</span>&gt;</span><br><span class="line"><span class="built_in">Person</span>(STR&amp;&amp; n);</span><br></pre></td></tr></table></figure></p>
<p>否则这个函数模板会被忽略。</p>
<p>这里同样可以使用别名模板给限制条件定义一个别名：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> EnableIfString = std::<span class="type">enable_if_t</span>&lt;std::is_convertible_v&lt;T,</span><br><span class="line">std::string&gt;&gt;;</span><br><span class="line">... </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR, <span class="keyword">typename</span> = EnableIfString&lt;STR&gt;&gt;</span><br><span class="line"><span class="built_in">Person</span>(STR&amp;&amp; n);</span><br></pre></td></tr></table></figure></p>
<p>现在完整Person类如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> EnableIfString =</span><br><span class="line">std::<span class="type">enable_if_t</span>&lt;std::is_convertible_v&lt;T,std::string&gt;&gt;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// generic constructor for passed initial name:</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR, <span class="keyword">typename</span> = EnableIfString&lt;STR&gt;&gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(STR&amp;&amp; n) : <span class="built_in">name</span>(std::forward&lt;STR&gt;(n)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;TMPL-CONSTR for &quot;</span><span class="string">&quot; &lt;&lt; name &lt;&lt; &quot;</span><span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy and move constructor:</span></span><br><span class="line">    <span class="built_in">Person</span> (Person <span class="type">const</span>&amp; p) : <span class="built_in">name</span>(p.name) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;COPY-CONSTR Person &quot;</span><span class="string">&quot; &lt;&lt; name &lt;&lt; &quot;</span><span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span> (Person&amp;&amp; p) : <span class="built_in">name</span>(std::<span class="built_in">move</span>(p.name)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MOVE-CONSTR Person &quot;</span><span class="string">&quot; &lt;&lt; name &lt;&lt; &quot;</span><span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>所有的调用也都会表现正常：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;specialmemtmpl3.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;sname&quot;</span>;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(s)</span></span>; <span class="comment">// init with string object =&gt; calls TMPL-CONSTR</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;tmp&quot;</span>)</span></span>; <span class="comment">// init with string literal =&gt; calls TMPL-CONSTR</span></span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(p1)</span></span>; <span class="comment">// OK =&gt; calls COPY-CONSTR</span></span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(std::move(p1))</span></span>; <span class="comment">// OK =&gt; calls MOVE-CONST</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意在C++14中，由于没有给产生一个值的类型萃取定义带<code>_v</code>的别名，必须使用如下定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> EnableIfString =</span><br><span class="line">std::<span class="type">enable_if_t</span>&lt;std::is_convertible&lt;T,std::string&gt;::value&gt;;</span><br></pre></td></tr></table></figure></p>
<p>而在C++11中，由于没有给产生一个类型的类型萃取定义带<code>_t</code>的别名，必须使用如下定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> EnableIfString</span><br><span class="line">= <span class="keyword">typename</span> std::enable_if&lt;std::is_convertible&lt;T,</span><br><span class="line">        std::string&gt;::value &gt;::type;</span><br></pre></td></tr></table></figure></p>
<p>但是通过定义<code>EnableIfString</code>，这些复杂的语法都被隐藏了。</p>
<p>除了使用要求类型之间可以隐式转换的<code>std::is_convertible&lt;&gt;</code>之外，还可以使用<code>std::is_constructible&lt;&gt;</code>，它要求可以用显式转换来做初始化。但是需要注意的是，它的参数顺序和<code>std::is_convertible&lt;&gt;</code>相反：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> EnableIfString =</span><br><span class="line">std::<span class="type">enable_if_t</span>&lt;std::is_constructible_v&lt;std::string, T&gt;&gt;;</span><br></pre></td></tr></table></figure></p>
<h3 id="禁用某些成员函数"><a href="#禁用某些成员函数" class="headerlink" title="禁用某些成员函数"></a>禁用某些成员函数</h3><p>注意我们不能通过使用<code>enable_if&lt;&gt;</code>来禁用copy/move构造函数以及赋值构造函数。这是因为成员函数模板不会被算作特殊成员函数（依然会生成默认构造函数），而且在需要使用copy构造函数的地方，相应的成员函数模板会被忽略掉。因此即使像下面这样定义类模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="title">C</span> <span class="params">(T <span class="type">const</span>&amp;)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;tmpl copy constructor\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在需要copy构造函数的地方依然会使用预定义的copy构造函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C x;</span><br><span class="line">C y&#123;x&#125;; <span class="comment">// still uses the predefined copy constructor (not the member template)</span></span><br></pre></td></tr></table></figure></p>
<p>删掉copy构造函数也不行，因为这样在需要copy构造函数的地方会报错说该函数被删除了。但是也有一个办法：可以定义一个接受const volatile的copy构造函数并将其标示为delete。这样做就不会再隐式声明一个接受const参数的copy构造函数。在此基础上，可以定义一个构造函数模板，对于non volatile的类型，它会优选被选择（相较于已删除的copy构造函数）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">... <span class="comment">// user-define the predefined copy constructor as deleted</span></span><br><span class="line"><span class="comment">// (with conversion to volatile to enable better matches)</span></span><br><span class="line">    <span class="built_in">C</span>(C <span class="type">const</span> <span class="keyword">volatile</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="comment">// implement copy constructor template with better match:</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">C</span> <span class="params">(T <span class="type">const</span>&amp;)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;tmpl copy constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样即使对常规copy，也会调用模板构造函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C x;</span><br><span class="line">C y&#123;x&#125;; <span class="comment">// uses the member template</span></span><br></pre></td></tr></table></figure></p>
<p>于是就可以给这个模板构造函数添加<code>enable_if&lt;&gt;</code>限制。比如可以禁止对通过int类型参数实例化出来的<code>C&lt;&gt;</code>模板实例进行copy：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">... <span class="comment">// user-define the predefined copy constructor as deleted</span></span><br><span class="line"><span class="comment">// (with conversion to volatile to enable better matches)</span></span><br><span class="line">    <span class="built_in">C</span>(C <span class="type">const</span> <span class="keyword">volatile</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="comment">// if T is no integral type, provide copy constructor template with better match:</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;!std::is_integral&lt;U&gt;::value&gt;&gt;</span><br><span class="line">    <span class="built_in">C</span> (C&lt;U&gt; <span class="type">const</span>&amp;) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用concept简化enable-if-lt-gt-表达式"><a href="#使用concept简化enable-if-lt-gt-表达式" class="headerlink" title="使用concept简化enable_if&lt;&gt;表达式"></a>使用concept简化enable_if&lt;&gt;表达式</h2><p>即使使用了模板别名，<code>enable_if</code>的语法依然显得很蠢，因为它使用了一个变通方法：为了达到目的，使用了一个额外的模板参数，并且通过“滥用”这个参数对模板的使用做了限制。原则上我们所需要的只是一个能够对函数施加限制的语言特性，当这一限制不被满足的时候，函数会被忽略掉。</p>
<p>这个语言特性就是人们期盼已久的concept，可以通过其简单的语法对函数模板施加限制条件。不幸的是，虽然已经讨论了很久，但是concept依然没有被纳入C++17标准。一些编译器目前对concept提供了试验性的支持，不过其很有可能在C++17之后的标准中得到支持。通过使用concept可以写出下面这样的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">requires</span> std::is_convertible_v&lt;STR,std::string&gt;</span></span><br><span class="line"><span class="function"><span class="title">Person</span><span class="params">(STR&amp;&amp; n)</span> : name(std::forward&lt;STR&gt;(n)) &#123;</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>甚至可以将其中模板的使用条件定义成通用的concept：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> ConvertibleToString = std::is_convertible_v&lt;T,std::string&gt;;</span><br></pre></td></tr></table></figure></p>
<p>然后将这个concept用作模板条件：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">requires</span> ConvertibleToString&lt;STR&gt;</span></span><br><span class="line"><span class="function"><span class="title">Person</span><span class="params">(STR&amp;&amp; n)</span> : name(std::forward&lt;STR&gt;(n)) &#123;</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以写成下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;ConvertibleToString STR&gt;</span></span><br><span class="line"><span class="function"><span class="title">Person</span><span class="params">(STR&amp;&amp; n)</span> : name(std::forward&lt;STR&gt;(n)) &#123;</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><ul>
<li>在模板中，可以通过使用“转发引用” （亦称“万能引用”，声明方式为模板参数<code>T</code>加<code>&amp;&amp;</code>）和<code>std::forward&lt;&gt;</code>将模板调用参完美地数转发出去。</li>
<li>将完美转发用于成员函数模板时，在copy或者move对象的时候它们可能比预定义的特殊成员函数更匹配。</li>
<li>可以通过使用<code>std::enable_if&lt;&gt;</code>并在其条件为false的时候禁用模板。</li>
<li>通过使用<code>std::enable_if&lt;&gt;</code>，可以避免一些由于构造函数模板或者赋值构造函数模板比隐式产生的特殊构造函数更加匹配而带来的问题。</li>
<li>可以通过删除对const volatile类型参数预定义的特殊成员函数，并结合使用<code>std::enable_if&lt;&gt;</code>，将特殊成员函数模板化。</li>
<li>通过concept可以使用更直观的语法对函数模板施加限制。</li>
</ul>
<h1 id="按值传递还是按引用传递"><a href="#按值传递还是按引用传递" class="headerlink" title="按值传递还是按引用传递"></a>按值传递还是按引用传递</h1><ol>
<li>X const &amp;（const左值引用）：参数引用了被传递的对象，并且参数不能被更改。</li>
<li>X &amp;（非const左值引用）：参数引用了被传递的对象，但是参数可以被更改。</li>
<li>X &amp;&amp;（右值引用）：参数通过移动语义引用了被传递的对象，并且参数值可以被更改或者被“窃取”。</li>
</ol>
<p>仅仅对已知的具体类型，决定参数的方式就已经很复杂了。在参数类型未知的模板中，就更难选择合适的传递方式了。</p>
<p>我们曾经建议在函数模板中应该优先使用按值传递，除非遇到以下情况：</p>
<ul>
<li>对象不允许被copy。</li>
<li>参数被用于返回数据。</li>
<li>参数以及其所有属性需要被模板转发到别的地方。</li>
<li>可以获得明显的性能提升。</li>
</ul>
<h2 id="按值传递"><a href="#按值传递" class="headerlink" title="按值传递"></a>按值传递</h2><p>当按值传递参数时，原则上所有的参数都会被拷贝。因此每一个参数都会是被传递实参的一份拷贝。对于class的对象，参数会通过class的拷贝构造函数来做初始化。调用拷贝构造函数的成本可能很高。但是有多种方法可以避免按值传递的高昂成本：事实上编译器可以通过移动语义（move semantics）来优化掉对象的拷贝，这样即使是对复杂类型的拷贝，其成本也不会很高。比如下面这个简单的按值传递参数的函数模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printV</span> <span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当将该函数模板用于int类型参数时，实例化后的代码是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printV</span> <span class="params">(<span class="type">int</span> arg)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参数<code>arg</code>变成任意实参的一份拷贝，不管实参是一个对象，一个常量还是一个函数的返回值。</p>
<p>如果定义一个<code>std::string</code>对象并将其用于上面的函数模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"><span class="built_in">printV</span>(s);</span><br></pre></td></tr></table></figure></p>
<p>模板参数<code>T</code>被实例化为<code>std::string</code>，实例化后的代码是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printV</span> <span class="params">(std::string arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在传递字符串时，<code>arg</code>变成s的一份拷贝。此时这一拷贝是通过<code>std::string</code>的拷贝构造函数创建的，这可能会是一个成本很高的操作，因为这个拷贝操作会对源对象做一次深拷贝，它需要开辟足够的内存来存储字符串的值。</p>
<p>但是并不是所有的情况都会调用拷贝构造函数。考虑如下情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">returnString</span><span class="params">()</span></span>;</span><br><span class="line">std::string s = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"><span class="built_in">printV</span>(s); <span class="comment">//copy constructor</span></span><br><span class="line"><span class="built_in">printV</span>(std::<span class="built_in">string</span>(<span class="string">&quot;hi&quot;</span>)); <span class="comment">//copying usually optimized away (if not, move constructor)</span></span><br><span class="line"><span class="built_in">printV</span>(<span class="built_in">returnString</span>()); <span class="comment">// copying usually optimized away (if not, move constructor)</span></span><br><span class="line"><span class="built_in">printV</span>(std::<span class="built_in">move</span>(s)); <span class="comment">// move constructor</span></span><br></pre></td></tr></table></figure></p>
<p>在第一次调用中，被传递的参数是左值（lvalue），因此拷贝构造函数会被调用。但是在第二和第三次调用中，被传递的参数是纯右值，此时编译器会优化参数传递，使得拷贝构造函数不会被调用。从C++17开始，C++标准要求这一优化方案必须被实现。在C++17之前，如果编译器没有优化掉这一类拷贝，它至少应该先尝试使用移动语义，这通常也会使拷贝成本变得比较低廉。</p>
<p>在最后一次调用中，被传递参数是<code>xvalue</code>（一个使用了<code>std::move()</code>的已经存在的非const对象），这会通过告知编译器我们不在需要s的值来强制调用移动构造函数（move constructor）。</p>
<p>综上所述，在调用<code>printV()</code>（参数是按值传递的）的时候，只有在被传递的参数是<code>lvalue</code>（对象在函数调用之前创建，并且通常在之后还会被用到，而且没有对其使用<code>std::move()</code>）时，调用成本才会比较高。不幸的是，这唯一的情况也是最常见的情况，因为我们几乎总是先创建一个对象，然后在将其传递给其它函数。</p>
<h3 id="按值传递会导致类型退化（decay）"><a href="#按值传递会导致类型退化（decay）" class="headerlink" title="按值传递会导致类型退化（decay）"></a>按值传递会导致类型退化（decay）</h3><p>关于按值传递，还有一个必须被讲到的特性：当按值传递参数时，参数类型会退化（decay）。也就是说，裸数组会退化成指针，const和volatile等限制符会被删除（就像用一个值去初始化一个用auto声明的对象那样）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printV</span> <span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125; </span><br><span class="line">std::string <span class="type">const</span> c = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"><span class="built_in">printV</span>(c); <span class="comment">// c decays so that arg has type std::string</span></span><br><span class="line"><span class="built_in">printV</span>(<span class="string">&quot;hi&quot;</span>); <span class="comment">//decays to pointer so that arg has type char const*</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">printV</span>(arr); <span class="comment">// decays to pointer so that arg has type int *</span></span><br></pre></td></tr></table></figure></p>
<p>当传递字符串常量“hi”的时候，其类型<code>char const[3]</code>退化成<code>char const *</code>，这也就是模板参数<code>T</code>被推断出来的类型。此时模板会被实例化成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printV</span> <span class="params">(<span class="type">char</span> <span class="type">const</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一行为继承自C语言，既有优点也有缺点。通常它会简化对被传递字符串常量的处理，但是缺点是在<code>printV()</code>内部无法区分被传递的是一个对象的指针还是一个存储一组对象的数组。</p>
<h2 id="按引用传递"><a href="#按引用传递" class="headerlink" title="按引用传递"></a>按引用传递</h2><p>现在来讨论按引用传递。按引用传递不会拷贝对象（因为形参将引用被传递的实参）。而且，按引用传递时参数类型也不会退化（decay）。</p>
<h3 id="按const引用传递"><a href="#按const引用传递" class="headerlink" title="按const引用传递"></a>按const引用传递</h3><p>为了避免（不必要的）拷贝，在传递非临时对象作为参数时，可以使用const引用传递。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printR</span> <span class="params">(T <span class="type">const</span>&amp; arg)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个模板永远不会拷贝被传递对象（不管拷贝成本是高还是低）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">returnString</span><span class="params">()</span></span>;</span><br><span class="line">std::string s = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"><span class="built_in">printR</span>(s); <span class="comment">// no copy</span></span><br><span class="line"><span class="built_in">printR</span>(std::<span class="built_in">string</span>(<span class="string">&quot;hi&quot;</span>)); <span class="comment">// no copy</span></span><br><span class="line"><span class="built_in">printR</span>(<span class="built_in">returnString</span>()); <span class="comment">// no copy</span></span><br><span class="line"><span class="built_in">printR</span>(std::<span class="built_in">move</span>(s)); <span class="comment">// no copy</span></span><br></pre></td></tr></table></figure></p>
<p>即使是按引用传递一个int类型的变量，虽然这样可能会事与愿违，也依然不会拷贝。因此如下调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">printR</span>(i); <span class="comment">// passes reference instead of just copying i</span></span><br></pre></td></tr></table></figure><br>会将<code>printR()</code>实例化为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printR</span><span class="params">(<span class="type">int</span> <span class="type">const</span>&amp; arg)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样做之所以不能提高性能，是因为在底层实现上，按引用传递还是通过传递参数的地址实现的。</p>
<h3 id="按引用传递不会做类型退化（decay）"><a href="#按引用传递不会做类型退化（decay）" class="headerlink" title="按引用传递不会做类型退化（decay）"></a>按引用传递不会做类型退化（decay）</h3><p>按引用传递参数时，其类型不会退化（decay）。也就是说不会把裸数组转换为指针，也不会移除const和volatile等限制符。而且由于调用参数被声明为<code>T const &amp;</code>，被推断出来的模板参数<code>T</code>的类型将不包含const。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printR</span> <span class="params">(T <span class="type">const</span>&amp; arg)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">std::string <span class="type">const</span> c = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"><span class="built_in">printR</span>(c); <span class="comment">// T deduced as std::string, arg is std::string const&amp;</span></span><br><span class="line"><span class="built_in">printR</span>(<span class="string">&quot;hi&quot;</span>); <span class="comment">// T deduced as char[3], arg is char const(&amp;)[3]</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">printR</span>(arr); <span class="comment">// T deduced as int[4], arg is int const(&amp;)[4]</span></span><br></pre></td></tr></table></figure></p>
<p>因此对于在<code>printR()</code>中用<code>T</code>声明的变量，它们的类型中也不会包含const。</p>
<h3 id="按非const引用传递"><a href="#按非const引用传递" class="headerlink" title="按非const引用传递"></a>按非const引用传递</h3><p>如果想通过调用参数来返回变量值（比如修改被传递变量的值），就需要使用非const引用（要么就使用指针）。同样这时候也不会拷贝被传递的参数。被调用的函数模板可以直接访问被传递的参数。考虑如下情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outR</span> <span class="params">(T&amp; arg)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意对于<code>outR()</code>，通常不允许将临时变量（prvalue）或者通过<code>std::move()</code>处理过的已存在的变量（xvalue）用作其参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">returnString</span><span class="params">()</span></span>;</span><br><span class="line">std::string s = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"><span class="built_in">outR</span>(s); <span class="comment">//OK: T deduced as std::string, arg is std::string&amp;</span></span><br><span class="line"><span class="built_in">outR</span>(std::<span class="built_in">string</span>(<span class="string">&quot;hi&quot;</span>)); <span class="comment">//ERROR: not allowed to pass a temporary (prvalue)</span></span><br><span class="line"><span class="built_in">outR</span>(<span class="built_in">returnString</span>()); <span class="comment">// ERROR: not allowed to pass a temporary (prvalue)</span></span><br><span class="line"><span class="built_in">outR</span>(std::<span class="built_in">move</span>(s)); <span class="comment">// ERROR: not allowed to pass an xvalue</span></span><br></pre></td></tr></table></figure></p>
<p>同样可以传递非const类型的裸数组，其类型也不会decay：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">outR</span>(arr); <span class="comment">// OK: T deduced as int[4], arg is int(&amp;)[4]</span></span><br></pre></td></tr></table></figure></p>
<p>这样就可以修改数组中元素的值，也可以处理数组的长度。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outR</span> <span class="params">(T&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (std::is_array&lt;T&gt;::value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;got array of &quot;</span> &lt;&lt; std::extent&lt;T&gt;::value &lt;&lt; <span class="string">&quot;elems\n&quot;</span>;</span><br><span class="line">    &#125;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是在这里情况有一些复杂。此时如果传递的参数是const的，<code>arg</code>的类型就有可能被推断为const引用，也就是说这时可以传递一个右值（rvalue）作为参数，但是模板所期望的参数类型却是左值（lvalue）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string <span class="type">const</span> c = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"><span class="built_in">outR</span>(c); <span class="comment">// OK: T deduced as std::string const</span></span><br><span class="line"><span class="built_in">outR</span>(<span class="built_in">returnConstString</span>()); <span class="comment">// OK: same if returnConstString() returns const string</span></span><br><span class="line"><span class="built_in">outR</span>(std::<span class="built_in">move</span>(c)); <span class="comment">// OK: T deduced as std::string const6</span></span><br><span class="line"><span class="built_in">outR</span>(<span class="string">&quot;hi&quot;</span>); <span class="comment">// OK: T deduced as char const[3]</span></span><br></pre></td></tr></table></figure></p>
<p>在这种情况下，在函数模板内部，任何试图更改被传递参数的值的行为都是错误的。在调用表达式中也可以传递一个const对象，但是当函数被充分实例化之后（可能发生在接接下来的编译过程中），任何试图更改参数值的行为都会触发错误。</p>
<p>如果想禁止向非const应用传递const对象，有如下选择：</p>
<ul>
<li>使用static_assert触发一个编译期错误：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outR</span> <span class="params">(T&amp; arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">static_assert</span>(!std::is_const&lt;T&gt;::value, <span class="string">&quot;out parameter of foo&lt;T&gt;(T&amp;) is const&quot;</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过使用<code>std::enable_if&lt;&gt;</code>禁用该情况下的模板：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line"><span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;!std::is_const&lt;T&gt;::value&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">outR</span> (T&amp; arg) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>或者是在concepts被支持之后，通过concepts来禁用该模板：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">requires</span> !<span class="function">std::is_const_v&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outR</span> <span class="params">(T&amp; arg)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="按转发引用传递参数（Forwarding-Reference）"><a href="#按转发引用传递参数（Forwarding-Reference）" class="headerlink" title="按转发引用传递参数（Forwarding Reference）"></a>按转发引用传递参数（Forwarding Reference）</h3><p>使用引用调用（call-by-reference）的一个原因是可以对参数进行完美转发（perfect forward）。但是请记住在使用转发引用时，有它自己特殊的规则。考虑如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">passR</span> <span class="params">(T&amp;&amp; arg)</span> </span>&#123; <span class="comment">// arg declared as forwarding reference</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以将任意类型的参数传递给转发引用，而且和往常的按引用传递一样，都不会创建被传递参数的备份：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"><span class="built_in">passR</span>(s); <span class="comment">// OK: T deduced as std::string&amp; (also the type of arg)</span></span><br><span class="line"><span class="built_in">passR</span>(std::<span class="built_in">string</span>(<span class="string">&quot;hi&quot;</span>)); <span class="comment">// OK: T deduced as std::string, arg is std::string&amp;&amp;</span></span><br><span class="line"><span class="built_in">passR</span>(<span class="built_in">returnString</span>()); <span class="comment">// OK: T deduced as std::string, arg is std::string&amp;&amp;</span></span><br><span class="line"><span class="built_in">passR</span>(std::<span class="built_in">move</span>(s)); <span class="comment">// OK: T deduced as std::string, arg is std::string&amp;&amp;</span></span><br><span class="line"><span class="built_in">passR</span>(arr); <span class="comment">// OK: T deduced as int(&amp;)[4] (also the type of arg)</span></span><br></pre></td></tr></table></figure></p>
<p>但是，这种情况下类型推断的特殊规则可能会导致意想不到的结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string <span class="type">const</span> c = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"><span class="built_in">passR</span>(c); <span class="comment">//OK: T deduced as std::string const&amp;</span></span><br><span class="line"><span class="built_in">passR</span>(<span class="string">&quot;hi&quot;</span>); <span class="comment">//OK: T deduced as char const(&amp;)[3] (also the type of arg)</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">passR</span>(arr); <span class="comment">//OK: T deduced as int (&amp;)[4] (also the type of arg)</span></span><br></pre></td></tr></table></figure></p>
<p>在以上三种情况中，都可以在<code>passR()</code>内部从<code>arg</code>的类型得知被传递的参数是一个右值（rvalue）还是一个const或者非const的左值（lvalue）。这是唯一一种可以传递一个参数，并用它来区分以上三种情况的方法。</p>
<p>看上去将一个参数声明为转发引用总是完美的。但是，没有免费的午餐。比如，由于转发引用是唯一一种可以将模板参数T隐式推断为引用的情况，此时如果在模板内部直接用T声明一个未初始化的局部变量，就会触发一个错误（引用对象在创建的时候必须被初始化）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">passR</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123; <span class="comment">// arg is a forwarding reference</span></span><br><span class="line">    T x; <span class="comment">// for passed lvalues, x is a reference, which requires an initializer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">foo</span>(<span class="number">42</span>); <span class="comment">// OK: T deduced as int</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">foo</span>(i); <span class="comment">// ERROR: T deduced as int&amp;, which makes the declaration of x in passR() invalid</span></span><br></pre></td></tr></table></figure></p>
<h2 id="使用std-ref-和std-cref"><a href="#使用std-ref-和std-cref" class="headerlink" title="使用std::ref()和std::cref()"></a>使用std::ref()和std::cref()</h2><p>从C++11开始，可以让调用者自行决定向函数模板传递参数的方式。如果模板参数被声明成按值传递的，调用者可以使用定义在头文件<code>&lt;functional&gt;</code>中的<code>std::ref()</code>和<code>std::cref()</code>将参数按引用传递给函数模板。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printT</span> <span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">std::string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">printT</span>(s); <span class="comment">//pass s By value</span></span><br><span class="line"><span class="built_in">printT</span>(std::<span class="built_in">cref</span>(s)); <span class="comment">// pass s “as if by reference”</span></span><br></pre></td></tr></table></figure></p>
<p>但是请注意，<code>std::cref()</code>并没有改变函数模板内部处理参数的方式。相反，在这里它使用了一个技巧：它用一个行为和引用类似的对象对参数进行了封装。事实上，它创建了一个<code>std::reference_wrapper&lt;&gt;</code>的对象，该对象引用了原始参数，并被按值传递给了函数模板。</p>
<p><code>std::reference_wrapper&lt;&gt;</code>可能只支持一个操作：向原始类型的隐式类型转换，该转换返回原始参数对象。因此当需要操作被传递对象时，都可以直接使用这个<code>std::reference_wrapper&lt;&gt;</code>对象。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// for std::cref()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printString</span><span class="params">(std::string <span class="type">const</span>&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printT</span> <span class="params">(T arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printString</span>(arg); <span class="comment">// might convert arg back to std::string</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">printT</span>(s); <span class="comment">// print s passed by value</span></span><br><span class="line">    <span class="built_in">printT</span>(std::<span class="built_in">cref</span>(s)); <span class="comment">// print s passed “as if by reference”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后一个调用将一个<code>std::reference_wrapper&lt;string const&gt;</code>对象按值传递给参数arg，这样<code>std::reference_wrapper&lt;string const&gt;</code>对象被传进函数模板并被转换为原始参数类型<code>std::string</code>。</p>
<p>注意，编译器必须知道需要将<code>std::reference_wrapper&lt;string const&gt;</code>对象转换为原始参数类型，才会进行隐式转换。因此<code>std::ref()</code>和<code>std::cref()</code>通常只有在通过泛型代码传递对象时才能正常工作。比如如果尝试直接输出传递进来的类型为T的对象，就会遇到错误，因为<code>std::reference_wrapper&lt;string const&gt;</code>中并没有定义输出运算符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printV</span> <span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; arg &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;... </span><br><span class="line">std::string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">printV</span>(s); <span class="comment">//OK</span></span><br><span class="line"><span class="built_in">printV</span>(std::<span class="built_in">cref</span>(s)); <span class="comment">// ERROR: no operator &lt;&lt; for reference wrapper defined</span></span><br></pre></td></tr></table></figure></p>
<p>同样下面的代码也会报错，因为不能将一个<code>std::reference_wrapper&lt;string const&gt;</code>对象和一个<code>char const*</code>或者<code>std::string</code>进行比较：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isless</span><span class="params">(T1 arg1, T2 arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 &lt; arg2;</span><br><span class="line">&#125;... </span><br><span class="line">std::string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isless</span>(std::<span class="built_in">cref</span>(s), <span class="string">&quot;world&quot;</span>)) ... <span class="comment">//ERROR</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isless</span>(std::<span class="built_in">cref</span>(s), std::<span class="built_in">string</span>(<span class="string">&quot;world&quot;</span>))) ... <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure></p>
<p>此时即使让<code>arg1</code>和<code>arg2</code>使用相同的模板参数T，也不会有帮助：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isless</span><span class="params">(T arg1, T arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 &lt; arg2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为编译器在推断<code>arg1</code>和<code>arg2</code>的类型时会遇到类型冲突。</p>
<p>综上，<code>std::reference_wrapper&lt;&gt;</code>是为了让开发者能够像使用“第一类对象（first class object）”一样使用引用，可以对它进行拷贝并将其按值传递给函数模板。也可以将它用在class内部，比如让它持有一个指向容器中对象的引用。但是通常总是要将其转换会原始类型。</p>
<h2 id="处理字符串常量和裸数组"><a href="#处理字符串常量和裸数组" class="headerlink" title="处理字符串常量和裸数组"></a>处理字符串常量和裸数组</h2><p>到目前为止，我们看到了将字符串常量和裸数组用作模板参数时的不同效果：</p>
<ul>
<li>按值传递时参数类型会decay，参数类型会退化成指向其元素类型的指针。</li>
<li>按引用传递是参数类型不会decay，参数类型是指向数组的引用。</li>
</ul>
<p>两种情况各有其优缺点。将数组退化成指针，就不能区分它是指向对象的指针还是一个被传递进来的数组。另一方面，如果传递进来的是字符串常量，那么类型不退化的话就会带来问题，因为不同长度的字符串的类型是不同的。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span> <span class="params">(T <span class="type">const</span>&amp; arg1, T <span class="type">const</span>&amp; arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">foo</span>(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;guy&quot;</span>); <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure></p>
<p>这里<code>foo(&quot;hi&quot;, &quot;guy&quot;)</code>不能通过编译，因为<code>hi</code>的类型是<code>char const [3]</code>，而<code>guy</code>的类型是<code>char const [4]</code>，但是函数模板要求两个参数的类型必须相同。这种code只有在两个字符串常量的长度相同时才能通过编译。因此，强烈建议在测试代码中使用长度不同的字符串。如果将<code>foo()</code>声明成按值传递的，这种调用可能可以正常运行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span> <span class="params">(T arg1, T arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">foo</span>(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;guy&quot;</span>); <span class="comment">//compiles, but ...</span></span><br></pre></td></tr></table></figure></p>
<p>但是这样并不能解决所有的问题。反而可能会更糟，编译期间的问题可能会变为运行期间的问题。考虑如下代码，它用==运算符比较两个传进来的参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span> <span class="params">(T arg1, T arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arg1 == arg2) &#123; <span class="comment">//OOPS: compares addresses of passed arrays</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">foo</span>(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;guy&quot;</span>); <span class="comment">//compiles, but ...</span></span><br></pre></td></tr></table></figure></p>
<p>如上，此时很容易就能知道需要将被传递进来的的字符指针理解成字符串。但是情况并不总是这么简单，因为模板还要处理类型可能已经退化过了的字符串常量参数。然而，退化在很多情况下是有帮助的，尤其是在需要验证两个对象（两个对象都是参数，或者一个对象是参数，并用它给另一个赋值）是否有相同的类型或者可以转换成相同的类型的时候。这种情况的一个典型应用就是用于完美转发（perfect forwarding）。但是使用完美转发需要将参数声明为转发引用。这时候就需要使用类型萃取<code>std::decay&lt;&gt;()</code>显式的退化参数类型。</p>
<p>注意，有些类型萃取本身可能就会对类型进行隐式退化，比如用来返回两个参数的公共类型的<code>std::common_type&lt;&gt;</code>。</p>
<h3 id="关于字符串常量和裸数组的特殊实现"><a href="#关于字符串常量和裸数组的特殊实现" class="headerlink" title="关于字符串常量和裸数组的特殊实现"></a>关于字符串常量和裸数组的特殊实现</h3><p>有时候可能必须要对数组参数和指针参数做不同的实现。此时当然不能退化数组的类型。为了区分这两种情况，必须要检测到被传递进来的参数是不是数组。通常有两种方法：</p>
<ul>
<li>可以将模板定义成只能接受数组作为参数：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> L1, std::<span class="type">size_t</span> L2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T (&amp;arg1)[L1], T (&amp;arg2)[L2])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T* pa = arg1; <span class="comment">// decay arg1</span></span><br><span class="line">    T* pb = arg2; <span class="comment">// decay arg2</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">compareArrays</span>(pa, L1, pb, L2)) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数<code>arg1</code>和<code>arg2</code>必须是元素类型相同、长度可以不同的两个数组。但是为了支持多种不同类型的裸数组，可能需要更多实现方式。</p>
<ul>
<li>可以使用类型萃取来检测参数是不是一个数组：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> =</span><br><span class="line">std::<span class="type">enable_if_t</span>&lt;std::is_array_v&lt;T&gt;&gt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">foo</span> (T&amp;&amp; arg1, T&amp;&amp; arg2)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这些特殊的处理方式过于复杂，最好还是使用一个不同的函数名来专门处理数组参数。或者更近一步，让模板调用者使用<code>std::vector</code>或者<code>std::array</code>作为参数。但是只要字符串还是裸数组，就必须对它们进行单独考虑。</p>
<h2 id="处理返回值"><a href="#处理返回值" class="headerlink" title="处理返回值"></a>处理返回值</h2><p>返回值也可以被按引用或者按值返回。但是按引用返回可能会带来一些麻烦，因为它所引用的对象不能被很好的控制。不过在日常编程中，也有一些情况更倾向于按引用返回：</p>
<ul>
<li>返回容器或者字符串中的元素（比如通过[]运算符或者front()方法访问元素）</li>
<li>允许修改类对象的成员</li>
<li>为链式调用返回一个对象（比如&gt;&gt;和&lt;&lt;运算符以及赋值运算符）</li>
</ul>
<p>另外对成员的只读访问，通常也通过返回const引用实现。但是如果使用不当，以上几种情况就可能导致一些问题。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string* s = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;whatever&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span>&amp; c = (*s)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">delete</span> s;</span><br><span class="line">std::cout &lt;&lt; c; <span class="comment">//run-time ERROR</span></span><br></pre></td></tr></table></figure></p>
<p>这里声明了一个指向字符串中元素的引用，但是在使用这个引用的地方，对应的字符串却不存在了（成了一个悬空引用），这将导致未定义的行为。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> s = std::<span class="built_in">make_shared</span>&lt;std::string&gt;(<span class="string">&quot;whatever&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span>&amp; c = (*s)[<span class="number">0</span>];</span><br><span class="line">s.<span class="built_in">reset</span>();</span><br><span class="line">std::cout &lt;&lt; c; <span class="comment">//run-time ERROR</span></span><br></pre></td></tr></table></figure></p>
<p>因此需要确保函数模板采用按值返回的方式。但是正如接下来要讨论的，使用函数模板T作为返回类型并不能保证返回值不会是引用，因为T在某些情况下会被隐式推断为引用类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">retR</span><span class="params">(T&amp;&amp; p)</span> <span class="comment">// p is a forwarding reference</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T&#123;...&#125;; <span class="comment">// OOPS: returns by reference when called for lvalues</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即使函数模板被声明为按值传递，也可以显式地将T指定为引用类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">retV</span><span class="params">(T p)</span> <span class="comment">//Note: T might become a reference</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T&#123;...&#125;; <span class="comment">// OOPS: returns a reference if T is a reference</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">retV</span>&lt;<span class="type">int</span>&amp;&gt;(x); <span class="comment">// retT() instantiated for T as int&amp;</span></span><br></pre></td></tr></table></figure></p>
<p>安全起见，有两种选择：</p>
<ul>
<li>用类型萃取<code>std::remove_reference&lt;&gt;</code>将T转为非引用类型：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="function">type <span class="title">retV</span><span class="params">(T p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T&#123;...&#125;; <span class="comment">// always returns by value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::decay&lt;&gt;</code>之类的类型萃取可能也会有帮助，因为它们也会隐式的去掉类型的引用。</p>
<ul>
<li>将返回类型声明为auto，从而让编译器去推断返回类型，这是因为auto也会导致类型退化：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">retV</span><span class="params">(T p)</span> <span class="comment">// by-value return type deduced by compiler</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T&#123;...&#125;; <span class="comment">// always returns by value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于模板参数声明的推荐方法"><a href="#关于模板参数声明的推荐方法" class="headerlink" title="关于模板参数声明的推荐方法"></a>关于模板参数声明的推荐方法</h2><p>正如前几节介绍的那样，函数模板有多种传递参数的方式：</p>
<ul>
<li>将参数声明成按值传递：这一方法很简单，它会对字符串常量和裸数组的类型进行退化，但是对比较大的对象可能会受影响性能。在这种情况下，调用者仍然可以通过<code>std::cref()</code>和<code>std::ref()</code>按引用传递参数，但是要确保这一用法是有效的。</li>
<li>将参数声明成按引用传递：对于比较大的对象这一方法能够提供比较好的性能。尤其是在下面几种情况下：<ul>
<li>将已经存在的对象（lvalue）按照左值引用传递，</li>
<li>将临时对象（prvalue）或者被<code>std::move()</code>转换为可移动的对象（xvalue）按右值引用传递，</li>
<li>或者是将以上几种类型的对象按照转发引用传递。</li>
</ul>
</li>
</ul>
<p>由于这几种情况下参数类型都不会退化，因此在传递字符串常量和裸数组时要格外小心。对于转发引用，需要意识到模板参数可能会被隐式推断为引用类型（引用折叠）。</p>
<p>对于函数模板有如下建议：</p>
<ol>
<li>默认情况下，将参数声明为按值传递。这样做比较简单，即使对字符串常量也可以正常工作。对于比较小的对象、临时对象以及可移动对象，其性能也还不错。对于比较大的对象，为了避免成本高昂的拷贝，可以使用<code>std::ref()</code>和<code>std::cref()</code>。</li>
<li>如果有充分的理由，也可以不这么做：<ol>
<li>如果需要一个参数用于输出，或者即用于输入也用于输出，那么就将这个参数按非const引用传递。</li>
<li>如果使用模板是为了转发它的参数，那么就使用完美转发（perfect forwarding）。也就是将参数声明为转发引用并在合适的地方使用<code>std::forward&lt;&gt;()</code>。考虑使用<code>std::decay&lt;&gt;</code>或者<code>std::common_type&lt;&gt;</code>来处理不同的字符串常量类型以及裸数组类型的情况。</li>
<li>如果重点考虑程序性能，而参数拷贝的成本又很高，那么就使用const引用。不过如果最终还是要对对象进行局部拷贝的话，这一条建议不适用。</li>
</ol>
</li>
<li>如果你更了解程序的情况，可以不遵循这些建议。但是请不要仅凭直觉对性能做评估。</li>
</ol>
<h3 id="不要过分泛型化"><a href="#不要过分泛型化" class="headerlink" title="不要过分泛型化"></a>不要过分泛型化</h3><p>值得注意的是，在实际应用中，函数模板通常并不是为了所有可能的类型定义的，而是有一定的限制。这时候最好不要将该函数模板定义的过于泛型化，否则，可能会有一些令人意外的副作用。针对这种情况应该使用如下的方式定义模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span> <span class="params">(std::vector&lt;T&gt; <span class="type">const</span>&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里通过的参数v，可以确保T不会是引用类型，因为vector不能用引用作为其元素类型。而且将vector类型的参数声明为按值传递不会有什么好处，因为按值传递一个vector的成本明显会比较高昂（vector的拷贝构造函数会拷贝vector中的所有元素）。此处如果直接将参数v的类型声明为<code>T</code>，就不容易从函数模板的声明上看出该使用那种传递方式了。</p>
<h4 id="以std-make-pair-lt-gt-为例"><a href="#以std-make-pair-lt-gt-为例" class="headerlink" title="以std::make_pair&lt;&gt;为例"></a>以std::make_pair&lt;&gt;为例</h4><p><code>std::make_pair&lt;&gt;()</code>是一个很好的介绍参数传递机制相关陷阱的例子。使用它可以很方便的通过类型推断创建<code>std::pair&lt;&gt;</code>对象。它的定义在各个版本的C++中都不一样：</p>
<ul>
<li>在第一版C++标准C++98中，<code>std::make_pair&lt;&gt;</code>被定义在std命名空间中，并且使用按引用传递来避免不必要的拷贝：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">pair&lt;T1,T2&gt; <span class="title">make_pair</span> <span class="params">(T1 <span class="type">const</span>&amp; a, T2 <span class="type">const</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pair</span>&lt;T1,T2&gt;(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是当使用<code>std::pair&lt;&gt;</code>存储不同长度的字符串常量或者裸数组时，这样做会导致严重的问题。</p>
<ul>
<li>因此在C++03中，该函数模板被定义成按值传递参数：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">pair&lt;T1,T2&gt; <span class="title">make_pair</span> <span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pair</span>&lt;T1,T2&gt;(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不过在C++11中，由于<code>make_pair&lt;&gt;()</code>需要支持移动语义，就必须使用转发引用。因此，其定义大体上是这样：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">constexpr</span> pair&lt;<span class="keyword">typename</span> decay&lt;T1&gt;::type, <span class="keyword">typename</span> decay&lt;T2&gt;::type&gt;</span><br><span class="line"><span class="built_in">make_pair</span> (T1&amp;&amp; a, T2&amp;&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pair&lt;<span class="keyword">typename</span> decay&lt;T1&gt;::type, <span class="keyword">typename</span> decay&lt;T2&gt;::type&gt;(forward&lt;T1&gt;(a), forward&lt;T2&gt;(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的实现还要复杂的多：为了支持<code>std::ref()</code>和<code>std::cref()</code>，该函数会将<code>std::reference_wrapper</code>展开成真正的引用。</p>
<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><ul>
<li>最好使用不同长度的字符串常量对模板进行测试。</li>
<li>模板参数的类型在按值传递时会退化，按引用传递则不会。</li>
<li>可以使用<code>std::decay&lt;&gt;</code>对按引用传递的模板参数的类型进行退化。</li>
<li>在某些情况下，对被声明成按值传递的函数模板，可以使用<code>std::cref()</code>和<code>std::ref()</code>将参数按引用进行传递。</li>
<li>按值传递模板参数的优点是简单，但是可能不会带来最好的性能。</li>
<li>除非有更好的理由，否则就将模板参数按值传递。</li>
<li>对于返回值，请确保按值返回（这也意味着某些情况下不能直接将模板参数直接用于返回类型）。</li>
<li>在比较关注性能时，做决定之前最好进行实际测试。不要相信直觉，它通常都不准确。</li>
</ul>
<h1 id="编译期编程"><a href="#编译期编程" class="headerlink" title="编译期编程"></a>编译期编程</h1><h2 id="模板元编程"><a href="#模板元编程" class="headerlink" title="模板元编程"></a>模板元编程</h2><p>模板的实例化发生在编译期间（而动态语言的泛型是在程序运行期间决定的）。事实证明C++模板的某些特性可以和实例化过程相结合，这样就产生了一种C++自己内部的原始递归的“编程语言”。因此模板可以用来“计算一个程序的结果”。下面的代码在编译期间就能判断一个数是不是质数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> p, <span class="type">unsigned</span> d&gt; <span class="comment">// p: number to check, d: current divisor</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DoIsPrime</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = (p%d != <span class="number">0</span>) &amp;&amp; DoIsPrime&lt;p,d<span class="number">-1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> p&gt; <span class="comment">// end recursion if divisor is 2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DoIsPrime</span>&lt;p,<span class="number">2</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = (p%<span class="number">2</span> != <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> p&gt; <span class="comment">// primary template</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsPrime</span> &#123;</span><br><span class="line">    <span class="comment">// start recursion with divisor from p/2:</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = DoIsPrime&lt;p,p/<span class="number">2</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// special cases (to avoid endless recursion with template instantiation):</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsPrime</span>&lt;<span class="number">0</span>&gt; &#123; <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">false</span>; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsPrime</span>&lt;<span class="number">1</span>&gt; &#123; <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">false</span>; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsPrime</span>&lt;<span class="number">2</span>&gt; &#123; <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">true</span>; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsPrime</span>&lt;<span class="number">3</span>&gt; &#123; <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">true</span>; &#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>IsPrime&lt;&gt;</code>模板将结果存储在其成员<code>value</code>中。为了计算出模板参数是不是质数，它实例化了<code>DoIsPrime&lt;&gt;</code>模板，这个模板会被递归展开，以计算<code>p</code>除以<code>p/2</code>和<code>2</code>之间的数之后是否会有余数。</p>
<ul>
<li>我们通过递归地展开<code>DoIsPrime&lt;&gt;</code>来遍历所有介于<code>p/2</code>和2之间的数，以检查是否有某个数可以被p整除。</li>
<li>用<code>d</code>等于2偏特例化出来的<code>DoIsPrime&lt;&gt;</code>被用于终止递归调用。</li>
</ul>
<p>但是以上过程都是在编译期间进行的。也就是说：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IsPrime&lt;<span class="number">9</span>&gt;::value</span><br></pre></td></tr></table></figure></p>
<p>在编译期间就被扩展成false了。</p>
<h2 id="通过constexpr进行计算"><a href="#通过constexpr进行计算" class="headerlink" title="通过constexpr进行计算"></a>通过constexpr进行计算</h2><p>C++11引入了一个叫做constexpr的新特性，它大大简化了各种类型的编译期计算。如果给定了合适的输入，constexpr函数就可以在编译期间完成相应的计算。虽然C++11对constexpr函数的使用有诸多限制，但是在C++14中这些限制中的大部分都被移除了。当然，为了能够成功地进行constexpr函数中的计算，依然要求各个计算步骤都能在编译期进行：目前堆内存分配和异常抛出都不被支持。</p>
<p>在C++11中，判断一个数是不是质数的实现方式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">doIsPrime</span> <span class="params">(<span class="type">unsigned</span> p, <span class="type">unsigned</span> d)</span> <span class="comment">// p: number to check, d: current divisor</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d!=<span class="number">2</span> ? (p%d!=<span class="number">0</span>) &amp;&amp; <span class="built_in">doIsPrime</span>(p,d<span class="number">-1</span>) <span class="comment">// check this and smaller divisors</span></span><br><span class="line">                : (p%<span class="number">2</span>!=<span class="number">0</span>); <span class="comment">// end recursion if divisor is 2</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">isPrime</span> <span class="params">(<span class="type">unsigned</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p &lt; <span class="number">4</span> ? !(p&lt;<span class="number">2</span>) <span class="comment">// handle special cases</span></span><br><span class="line">                : <span class="built_in">doIsPrime</span>(p,p/<span class="number">2</span>); <span class="comment">// start recursion with divisor from p/2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了满足C++11中只能有一条语句的要求，此处只能使用条件运算符来进行条件选择。不过由于这个函数只用到了C++的常规语法，因此它比第一版中，依赖于模板实例化的代码要容易理解的多。</p>
<p>在C++14中，constexpr函数可以使用常规C++代码中大部分的控制结构。因此为了判断一个数是不是质数，可以不再使用笨拙的模板方式以及略显神秘的单行代码方式，而直接使用一个简单的for循环：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">isPrime</span> <span class="params">(<span class="type">unsigned</span> <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> d=<span class="number">2</span>; d&lt;=p/<span class="number">2</span>; ++d) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p % d == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// found divisor without remainder&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p &gt; <span class="number">1</span>; <span class="comment">// no divisor without remainder found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在C++11和C++14中实现的<code>constexpr isPrime()</code>，都可以通过直接调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isPrime</span>(<span class="number">9</span>)</span><br></pre></td></tr></table></figure></p>
<p>来判断9是不是一个质数。但是上面所说的“可以”在编译期执行，并不是一定会在编译期执行。在其他上下文中，编译期可能会也可能不会尝试进行编译期计算，如果在编译期尝试了，但是现有条件不满足编译期计算的要求，那么也不会报错，相应的函数调用被推迟到运行期间执行。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> b1 = <span class="built_in">isPrime</span>(<span class="number">9</span>); <span class="comment">// evaluated at compile time</span></span><br></pre></td></tr></table></figure></p>
<p>会在编译期进行计算（因为<code>b1</code>被<code>constexpr</code>修饰）。而对<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">bool</span> b2 = <span class="built_in">isPrime</span>(<span class="number">9</span>); <span class="comment">// evaluated at compile time if in namespace scope</span></span><br></pre></td></tr></table></figure></p>
<p>如果<code>b2</code>被定义于全局作用域或者namespace作用域，也会在编译期进行计算。如果<code>b2</code>被定义于块作用域（{}内），那么将由编译器决定是否在编译期间进行计算。下面这个例子就属于这种情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fiftySevenIsPrime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isPrime</span>(<span class="number">57</span>); <span class="comment">// evaluated at compile or running time</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时是否进行编译期计算将由编译期决定。</p>
<p>另一方面，在如下调用中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line">... st</span><br><span class="line">d::cout &lt;&lt; <span class="built_in">isPrime</span>(x); <span class="comment">// evaluated at run time</span></span><br></pre></td></tr></table></figure><br>不管x是不是质数，调用都只会在运行期间执行。</p>
<h2 id="通过部分特例化进行路径选择"><a href="#通过部分特例化进行路径选择" class="headerlink" title="通过部分特例化进行路径选择"></a>通过部分特例化进行路径选择</h2><p>诸如<code>isPrime()</code>这种在编译期进行相关测试的功能，有一个有意思的应用场景：可以在编译期间通过部分特例化在不同的实现方案之间做选择。</p>
<p>比如，可以以一个非类型模板参数是不是质数为条件，在不同的模板之间做选择：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primary helper template:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> SZ, <span class="type">bool</span> = <span class="built_in">isPrime</span>(SZ)&gt;</span><br><span class="line"><span class="keyword">struct</span> Helper;</span><br><span class="line"><span class="comment">// implementation if SZ is not a prime number:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> SZ&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Helper</span>&lt;SZ, <span class="literal">false</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// implementation if SZ is a prime number:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> SZ&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Helper</span>&lt;SZ, <span class="literal">true</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> SZ&gt;</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">foo</span> <span class="params">(std::array&lt;T,SZ&gt; <span class="type">const</span>&amp; coll)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Helper&lt;SZ&gt; h; <span class="comment">// implementation depends on whether array has prime number as size</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里根据参数<code>std::array&lt;&gt;</code>的<code>size</code>是不是一个质数，实现了两种<code>Helper&lt;&gt;</code>模板。这一偏特例化的使用方法，被广泛用于基于模板参数属性，在不同模板实现方案之间做选择。在上面的例子中，对两种可能的情况实现了两种偏特例化版本。但是也可以将主模板用于其中一种情况，然后再特例化一个版本代表另一种情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primary helper template (used if no specialization fits):</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> SZ, <span class="type">bool</span> = <span class="built_in">isPrime</span>(SZ)&gt;</span><br><span class="line"><span class="keyword">struct</span> Helper</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// special implementation if SZ is a prime number:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> SZ&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Helper</span>&lt;SZ, <span class="literal">true</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由于函数模板不支持部分特例化，当基于一些限制在不同的函数实现之间做选择时，必须要使用其它一些方法：</p>
<ul>
<li>使用有static函数的类，</li>
<li>使用<code>std::enable_if</code>，</li>
<li>使用SFINAE特性，</li>
<li>或者使用从C++17开始生效的编译期的if特性。</li>
</ul>
<h2 id="SFINAE-Substitution-Failure-Is-Not-An-Error-替换失败不是错误"><a href="#SFINAE-Substitution-Failure-Is-Not-An-Error-替换失败不是错误" class="headerlink" title="SFINAE (Substitution Failure Is Not An Error,替换失败不是错误)"></a>SFINAE (Substitution Failure Is Not An Error,替换失败不是错误)</h2><p>在一个函数调用的备选方案中包含函数模板时，编译器首先要决定应该将什么样的模板参数用于各种模板方案，然后用这些参数替换函数模板的参数列表以及返回类型，最后评估替换后的函数模板和这个调用的匹配情况。但是这一替换过程可能会遇到问题：替换产生的结果可能没有意义。不过这一类型的替换不会导致错误，C++语言规则要求忽略掉这一类型的替换结果。这一原理被称为SFINAE（发音类似sfee-nay），代表的是“substitution failure is not an error”。</p>
<p>但是上面讲到的替换过程和实际的实例化过程不一样：即使对那些最终被证明不需要被实例化的模板也要进行替换（不然就无法知道到底需不需要实例化）。不过它只会替换直接出现在函数模板声明中的相关内容（不包含函数体）。考虑如下的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// number of elements in a raw array:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt;</span></span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">len</span> <span class="params">(T(&amp;)[N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// number of elements for a type having size_type:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::size_type <span class="title">len</span> <span class="params">(T <span class="type">const</span>&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里定义了两个接受一个泛型参数的函数模板<code>len()</code>：</p>
<ol>
<li>第一个函数模板的参数类型是<code>T (&amp;)[N]</code>，也就是说它是一个包含了N个T型元素的数组。</li>
<li>第二个函数模板的参数类型就是简单的T，除了返回类型要是<code>T::size_type</code>之外没有别的限制，这要求被传递的参数类型必须有一个<code>size_type</code>成员。</li>
</ol>
<p>当传递的参数是裸数组或者字符串常量时，只有那个为裸数组定义的函数模板能够匹配：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">len</span>(a); <span class="comment">// OK: only len() for array matches</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">len</span>(<span class="string">&quot;tmp&quot;</span>); <span class="comment">//OK: only len() for array matches</span></span><br></pre></td></tr></table></figure></p>
<p>如果只是从函数签名来看的话，对第二个函数模板也可以分别用<code>int[10]</code>和<code>char const [4]</code>替换类型参数<code>T</code>，但是这种替换在处理返回类型<code>T::size_type</code>时会导致错误。因此对于这两个调用，第二个函数模板会被忽略掉。</p>
<p>如果传递<code>std::vector&lt;&gt;</code>作为参数的话，则只有第二个模板参数能够匹配：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">len</span>(v); <span class="comment">// OK: only len() for a type with size_type matches</span></span><br></pre></td></tr></table></figure></p>
<p>如果传递的是裸指针话，以上两个模板都不会被匹配上（但是不会因此而报错）。此时编译期会抱怨说没有发现合适的<code>len()</code>函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">len</span>(p); <span class="comment">// ERROR: no matching len() function found</span></span><br></pre></td></tr></table></figure></p>
<p>但是这和传递一个有<code>size_type</code>成员但是没有<code>size()</code>成员函数的情况不一样。比如如果传递的参数是<code>std::allocator&lt;&gt;</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::allocator&lt;<span class="type">int</span>&gt; x;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">len</span>(x); <span class="comment">// ERROR: len() function found, but can&quot;t size()</span></span><br></pre></td></tr></table></figure></p>
<p>此时编译器会匹配到第二个函数模板。因此不会报错说没有发现合适的<code>len()</code>函数，而是会报一个编译期错误说对<code>std::allocator&lt;int&gt;</code>而言<code>size()</code>是一个无效调用。此时第二个模板函数不会被忽略掉。</p>
<p>如果忽略掉那些在替换之后返回值类型为无效的备选项，那么编译器会选择另外一个参数类型匹配相差的备选项。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// number of elements in a raw array:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt;</span></span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">len</span> <span class="params">(T(&amp;)[N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// number of elements for a type having size_type:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::size_type <span class="title">len</span> <span class="params">(T <span class="type">const</span>&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对所有类型的应急选项:</span></span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">len</span> <span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处额外提供了一个通用函数<code>len()</code>，它总会匹配所有的调用，但是其匹配情况也总是所有重载选项中最差的。</p>
<p>此时对于裸数组和vector，都有两个函数可以匹配上，但是其中不是通过省略号（…）匹配的那一个是最佳匹配。对于指针，只有应急选项能够匹配上，此时编译器不会再报缺少适用于本次调用的<code>len()</code>。不过对于<code>std::allocator&lt;int&gt;</code>的调用，虽然第二个和第三个函数都能匹配上，但是第二个函数依然是最佳匹配项。因此编译器依然会报错说缺少<code>size()</code>成员函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">len</span>(a); <span class="comment">// OK: len() for array is best match</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">len</span>(<span class="string">&quot;tmp&quot;</span>); <span class="comment">//OK: len() for array is best match</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">len</span>(v); <span class="comment">// OK: len() for a type with size_type is best match</span></span><br><span class="line"><span class="type">int</span>* p;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">len</span>(p); <span class="comment">// OK: only fallback len() matches</span></span><br><span class="line">std::allocator&lt;<span class="type">int</span>&gt; x;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">len</span>(x); <span class="comment">// ERROR: 2nd len() function matches best, but can’t call size() for x</span></span><br></pre></td></tr></table></figure></p>
<p>当我们说“我们SFINAE掉了一个函数”时，意思是我们通过让模板在一些限制条件下产生无效代码，从而确保在这些条件下会忽略掉该模板。当你在C++标准里读到“除非在某些情况下，该模板不应该参与重载解析过程”时，它的意思就是“在该情况下，使用SFINAE方法SFINAE掉了这个函数模板”。比如<code>std::thread</code>类模板声明了如下构造函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ... </span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">        <span class="keyword">explicit</span> <span class="title">thread</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并做了如下备注：如果<code>decay_t&lt;F&gt;</code>的类型和<code>std:thread</code>相同的话，该构造函数不应该参与重载解析过程。</p>
<p>它的意思是如果在调用该构造函数模板时，使用<code>std::thread</code>作为第一个也是唯一一个参数的话，那么这个构造函数模板就会被忽略掉。这是因为一个类似的成员函数模板在某些情况下可能比预定义的copy或者move构造函数更能匹配相关调用。通过SFINAE掉将该构造函数模板用于<code>thread</code>的情况，就可以确保在用一个<code>thread</code>构造另一个<code>thread</code>的时候总是会调用预定义的copy或者move构造函数。</p>
<p>但是使用该技术逐项禁用相关模板是不明智的。幸运的是标准库提供了更简单的禁用模板的方法。其中最广为人知的一个就是<code>std::enable_if&lt;&gt;</code>。因此典型的<code>std::thread</code>的实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args, <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;!std::is_same_v&lt;std::<span class="type">decay_t</span>&lt;F&gt;, thread&gt;&gt;&gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">thread</span>(F&amp;&amp; f, Args&amp;&amp;... args);</span><br><span class="line">    ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="通过decltype进行SFINAE（此处是动词）的表达式"><a href="#通过decltype进行SFINAE（此处是动词）的表达式" class="headerlink" title="通过decltype进行SFINAE（此处是动词）的表达式"></a>通过decltype进行SFINAE（此处是动词）的表达式</h3><p>对于有些限制条件，并不总是很容易地就能找到并设计出合适的表达式来SFINAE掉函数模板。</p>
<p>比如，对于有<code>size_type</code>成员但是没有<code>size()</code>成员函数的参数类型，我们想要保证会忽略掉函数模板<code>len()</code>。如果没有在函数声明中以某种方式要求<code>size()</code>成员函数必须存在，这个函数模板就会被选择并在实例化过程中导致错误：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::size_type <span class="title">len</span> <span class="params">(T <span class="type">const</span>&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">size</span>();</span><br><span class="line">&#125; </span><br><span class="line">std::allocator&lt;<span class="type">int</span>&gt; x;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">len</span>(x) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//ERROR: len() selected, but x has no size()</span></span><br></pre></td></tr></table></figure></p>
<p>处理这一情况有一种常用模式或者说习惯用法：</p>
<ul>
<li>通过尾置返回类型语法（trailing return type syntax）来指定返回类型（在函数名前使用<code>auto</code>，并在函数名后面的<code>-&gt;</code>后指定返回类型）。</li>
<li>通过decltype和逗号运算符定义返回类型。</li>
<li>将所有需要成立的表达式放在逗号运算符的前面（为了预防可能会发生的运算符被重载的情况，需要将这些表达式的类型转换为void）。</li>
<li>在逗号运算符的末尾定义一个类型为返回类型的对象。</li>
</ul>
<p>比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">len</span> <span class="params">(T <span class="type">const</span>&amp; t)</span> -&gt; <span class="title">decltype</span><span class="params">( (<span class="type">void</span>)(t.size()), T::size_type() )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里返回类型被定义成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>( (<span class="type">void</span>)(t.size)(), T::<span class="built_in">size_type</span>() )</span><br></pre></td></tr></table></figure></p>
<p>类型指示符<code>decltype</code>的操作数是一组用逗号隔开的表达式，因此最后一个表达式<code>T::size_type()</code>会产生一个类型为返回类型的对象（decltype会将其转换为返回类型）。而在最后一个逗号前面的所有表达式都必须成立，在这个例子中逗号前面只有<code>t.size()</code>。之所以将其类型转换为<code>void</code>，是为了避免因为用户重载了该表达式对应类型的逗号运算符而导致的不确定性。注意<code>decltype</code>的操作数是不会被计算的，也就是说可以不调用构造函数而直接创建其“dummy”对象。</p>
<h2 id="编译期if"><a href="#编译期if" class="headerlink" title="编译期if"></a>编译期if</h2><p>部分特例化，SFINAE以及<code>std::enable_if</code>可以一起被用来禁用或者启用某个模板。而C++17又在此基础上引入了同样可以在编译期基于某些条件禁用或者启用相应模板的编译期if语句。通过使用<code>if constexpr(...)</code>语法，编译器会使用编译期表达式来决定是使用if语句的then对应的部分还是else对应的部分。</p>
<p>作为第一个例子，考虑变参函数模板<code>print()</code>。它用递归的方法打印其参数（可能是任意类型）。如果使用<code>constexp if</code>，就可以在函数内部决定是否要继续递归下去，而不用再单独定义一个函数来终结递归：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span> <span class="params">(T <span class="type">const</span>&amp; firstArg, Types <span class="type">const</span>&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; firstArg &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(<span class="keyword">sizeof</span>...(args) &gt; <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(args...); <span class="comment">//code only available if sizeof...(args)&gt;0 (since C++17)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里如果只给<code>print()</code>传递一个参数，那么<code>args...</code>就是一个空的参数包，此时<code>sizeof...(args)</code>等于0。这样if语句里面的语句就会被丢弃掉，也就是说这部分代码不会被实例化。因此也就不再需要一个单独的函数来终结递归。</p>
<p>事实上上面所说的不会被实例化，意思是对这部分代码只会进行第一阶段编译，此时只会做语法检查以及和模板参数无关的名称检查。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::is_integral_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">foo</span>(t<span class="number">-1</span>); <span class="comment">// OK</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">undeclared</span>(t); <span class="comment">// error if not declared and not discarded (i.e. T is not integral)</span></span><br><span class="line">        <span class="built_in">undeclared</span>(); <span class="comment">// error if not declared (even if discarded)</span></span><br><span class="line">        <span class="built_in">static_assert</span>(<span class="literal">false</span>, <span class="string">&quot;no integral&quot;</span>); <span class="comment">// always asserts (even if discarded)</span></span><br><span class="line">        <span class="built_in">static_assert</span>(!std::is_integral_v&lt;T&gt;, <span class="string">&quot;no integral&quot;</span>); <span class="comment">//OK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处<code>if constexpr</code>的使用并不仅限于模板函数，而是可以用于任意类型的函数。它所需要的只是一个可以返回布尔值的编译期表达式。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::numeric_limits&lt;<span class="type">char</span>&gt;::is_signed)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">foo</span>(<span class="number">42</span>); <span class="comment">// OK</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">undeclared</span>(<span class="number">42</span>); <span class="comment">// error if undeclared() not declared</span></span><br><span class="line">        <span class="built_in">static_assert</span>(<span class="literal">false</span>, <span class="string">&quot;unsigned&quot;</span>); <span class="comment">// always asserts (even if discarded)</span></span><br><span class="line">        <span class="built_in">static_assert</span>(!std::numeric_limits&lt;<span class="type">char</span>&gt;::is_signed, <span class="string">&quot;char is unsigned&quot;</span>); <span class="comment">//OK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>利用这一特性，也可以让编译期函数<code>isPrime()</code>在非类型参数不是质数的时候执行一些额外的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> SZ&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span> <span class="params">(std::array&lt;T,SZ&gt; <span class="type">const</span>&amp; coll)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(!isPrime(SZ))</span> </span>&#123;</span><br><span class="line">        ... <span class="comment">//special additional handling if the passed array has no prime number as size</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><ul>
<li>模板提供了在编译器进行计算的能力（比如使用递归进行迭代以及使用部分特例化或者?:进行选择）。</li>
<li>通过使用constexpr函数，可以用在编译期上下文中能够被调用的“常规函数（要有constexpr）”替代大部分的编译期计算工作。</li>
<li>通过使用部分特例化，可以基于某些编译期条件在不同的类模板实现之间做选择。</li>
<li>模板只有在被需要的时候才会被使用，对函数模板声明进行替换不会产生有效的代码。这一原理被称为SFINAE。</li>
<li>SFINAE可以被用来专门为某些类型或者限制条件提供函数模板。</li>
<li>从C++17开始，可以通过使用编译期if基于某些编译期条件启用或者禁用某些语句。</li>
</ul>
<h1 id="在实践中使用模板"><a href="#在实践中使用模板" class="headerlink" title="在实践中使用模板"></a>在实践中使用模板</h1><h2 id="包含模式"><a href="#包含模式" class="headerlink" title="包含模式"></a>包含模式</h2><p>有很多中组织模板源码的方式。本章讨论这其中最流行的一种方法：包含模式。</p>
<h3 id="链接错误"><a href="#链接错误" class="headerlink" title="链接错误"></a>链接错误</h3><p>大多数C和C++程序员都会按照如下方式组织代码：</p>
<ul>
<li>类和其它类型被放在头文件里。其文件扩展名为.hpp</li>
<li>对于全局变量（非inline）和函数（非inline），只将其声明放在头文件里，定义则被放在一个被当作其自身编译单元的文件里。这一类文件的扩展名为.cpp。</li>
</ul>
<p>这样做效果很好：既能够在整个程序中很容易的获得所需类型的定义，同时又避免了链接过程中的重复定义错误。</p>
<p>受这一惯例的影响，刚开始接触模板的程序员通常都会遇到下面这个程序中的错误。和处理“常规代码”的情况一样，在头文件中声明模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYFIRST_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYFIRST_HPP</span></span><br><span class="line"><span class="comment">// declaration of template</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTypeof</span> <span class="params">(T <span class="type">const</span>&amp;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//MYFIRST_HPP</span></span></span><br></pre></td></tr></table></figure></p>
<p>其中<code>printTypeof()</code>是一个简单的辅助函数的声明，它会打印一些类型相关信息。而它的具体实现则被放在了一个CPP文件中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myfirst.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// implementation/definition of template</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTypeof</span> <span class="params">(T <span class="type">const</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(x).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数用<code>typeid</code>运算符打印了一个用来描述被传递表达式的类型的字符串。该运算符返回一个左值静态类型<code>std::type_info</code>，它的成员函数<code>name()</code>可以返回某些表达式的类型。C++标准并没有要求<code>name()</code>必须返回有意义的结果，但是在比较好的C++实现中，它的返回结果应该能够很好的表述传递给typeid的参数的类型。</p>
<p>接着在另一个CPP文件中使用该模板，它会include该模板的头文件：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myfirst.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// use of the template</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> ice = <span class="number">3.0</span>;</span><br><span class="line">    <span class="built_in">printTypeof</span>(ice); <span class="comment">// call function template for type double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译器很可能会正常编译这个程序，但是链接器则可能会报错说：找不到函数<code>printTypeof()</code>的定义。出现这一错误的原因是函数模板<code>printTypeof()</code>的定义没有被实例化。为了实例化一个模板，编译器既需要知道需要实例化哪个函数，也需要知道应该用哪些模板参数来进行实例化。不���的是，在上面这个例子中，这两组信息都是被放在别的文件里单独进行编译的。因此当编译器遇到对<code>printTypeof()</code>的调用时，却找不到相对应的函数模板定义来针对double类型进行实例化</p>
<h3 id="头文件中的模板"><a href="#头文件中的模板" class="headerlink" title="头文件中的模板"></a>头文件中的模板</h3><p>解决以上问题的方法和处理宏以及inline函数的方法一样：将模板定义和模板声明都放在头文件里。</p>
<p>也就是说需要重写<code>myfirst.hpp</code>，让它包含所有模板声明和模板定义，而不再提供<code>myfirst.cpp</code>文件：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYFIRST_HPP#<span class="keyword">define</span> MYFIRST_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="comment">// declaration of template</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTypeof</span> <span class="params">(T <span class="type">const</span>&amp;)</span></span>;</span><br><span class="line"><span class="comment">// implementation/definition of template</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTypeof</span> <span class="params">(T <span class="type">const</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(x).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//MYFIRST_HPP</span></span></span><br></pre></td></tr></table></figure></p>
<p>这种组织模板相关代码的方法被称为“包含模式”。使用这个方法，程序的编译，链接和执行都可以正常进行。</p>
<p>目前有几个问题需要指出。最值得注意的一个是，这一方法将大大增加include头文件<code>myfirst.hpp</code>的成本。在这个例子中，成本主要不是由模板自身定义导致的，而是由那些为了使用这个模板而必须包含的头文件导致的，比如<code>&lt;iostream&gt;</code>和<code>&lt;typeinfo&gt;</code>。由于诸如<code>&lt;iostream&gt;</code>的头文件还会包含一些它们自己的模板，因此这可能会带来额外的数万行的代码。</p>
<h2 id="模板和inline"><a href="#模板和inline" class="headerlink" title="模板和inline"></a>模板和inline</h2><p>提高程序运行性能的一个常规手段是将函数声明为inline的。Inline关键字的意思是给编译器做一个暗示，要优先在函数调用处将函数体做inline替换展开，而不是按常规的调用机制执行。</p>
<p>和inline函数类似，函数模板也可以被定义在多个编译单元中。比如我们通常将模板定义放在头文件中，而这个头文件又被多个CPP文件包含。但是这并不意味着函数模板在默认情况下就会使用inline替换。在模板调用处是否进行inline替换完全是由编译器决定的事情。编译器通常能够更好的评估inline替换一个被调用函数是否能够提升程序性能。因此不同编译器之间对inline函数处理的精准原则也是不同的，这甚至会受编译选项的影响。</p>
<p>程序员希望自己能够决定是否需要进行inline替换。有时候这只能通过编译器的具体属性实现，比如<code>noinline</code>和<code>always_inline</code>。</p>
<h2 id="预编译头文件"><a href="#预编译头文件" class="headerlink" title="预编译头文件"></a>预编译头文件</h2><p>即使不适用模板，C++的头文件也会大到需要很长时间进行编译。而模板的引入则进一步加剧了这一问题，程序员对这一问题的抱怨促使编译器供应商提供了一种叫做预编译头文件（PCH: precomplied header）的方案来降低编译时间。</p>
<p>预编译头文件方案的实现基于这样一个事实：在组织代码的时候，很多文件都以相同的几行代码作为开始。为了便于讨论，假设那些将要被编译文件的前N行内容都相同。这样就可以单独编译这N行代码，并将编译完成后的状态保存在一个预编译头文件中（precompiledheader）。接着所有以这N行代码开始的文件，在编译时都会重新载入这个被保存的状态，然后从第N+1行开始编译。在这里需要指出，重新载入被保存的前N行代码的预编译状态可能会比再次编译这N行代码要快很多很多倍。但是保存这个状态可能要比单次编译这N行代码慢的多，编译时间可能延长20%到200%。</p>
<p>因此利用预编译头文件提高编译速度的关键点是；让尽可能多的文件，以尽可能多的相同的代码作为开始。也就是说在实践中，文件要以相同的#include指令（它们可能占用大量的编译时间）开始。因此如果#include头文件的顺序相同的话，就会对提高编译性能很有帮助。但是对下面的文件：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>和<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>预编译头文件不会起作用，因为它们的起始状态并不一致（顺序不一致）。一些程序员认为，即使可能会错过一个利用预编译头文件加速文件编译的机会，也应该多#include一些可能用不到的头文件。这样做可以大大简化预编译头文件的使用方式。比如通常可以创建一个包含所有标准头文件的头文件，称之为<code>std.hpp</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>这个文件可以被预编译，其它所有用到标准库的文件都可以直接在文件开始处include这个头文件：</p>
<h2 id="破译大篇幅的错误信息"><a href="#破译大篇幅的错误信息" class="headerlink" title="破译大篇幅的错误信息"></a>破译大篇幅的错误信息</h2><p>常规函数的编译错误信息通常非常简单且直中要点。比如当编译器报错说”class X has no member ‘fun’”时，找到代码中相应的错误并不会很难。但是模板并不是这样。看下面这些例子。</p>
<h3 id="简单的类型不匹配情况"><a href="#简单的类型不匹配情况" class="headerlink" title="简单的类型不匹配情况"></a>简单的类型不匹配情况</h3><p>考虑下面这个使用了C++标准库的简单例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::map&lt;std::string,<span class="type">double</span>&gt; coll;</span><br><span class="line">    ... <span class="comment">// find the first nonempty string in coll:</span></span><br><span class="line">    <span class="keyword">auto</span> pos = std::<span class="built_in">find_if</span> (coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(), [] (std::string <span class="type">const</span>&amp; s)&#123;<span class="keyword">return</span> s != <span class="string">&quot;&quot;</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中有一个相当小的错误：一个lambda函数被用来找到第一个匹配的字符串，它依次将map中的元素和一个字符串比较。但是，由于map中的元素是key/value对，因此传入lambda的元素也将是一个<code>std::pair&lt;std::string const, double&gt;</code>，而它是不能直接和字符串进行比较的。针对这个错误，主流的GUN C++编译器会报如下错误：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1 In file included from /cygdrive/p/gcc/gcc61-include/bits/stl_algobase.h:71:0,</span><br><span class="line">2 from /cygdrive/p/gcc/gcc61-include/bits/char_traits.h:39,</span><br><span class="line">3 from /cygdrive/p/gcc/gcc61-include/string:40,</span><br><span class="line">4 from errornovel1.cpp:1:</span><br><span class="line">5 /cygdrive/p/gcc/gcc61-</span><br><span class="line">include/bits/predefined_ops.h: In instantiation of &#x27;bool __gnu_cxx ::__ops::_Iter_pred&lt;_Predicate&gt;::operator() (_Iterator) [with _Iterator = std::_Rb_tree_i terator&lt;std::pair&lt;const std::__cxx11::basic_string&lt;char&gt;, double::&lt;lambda(const string&amp;)&gt;]&#x27;:</span><br><span class="line">6 /cygdrive/p/gcc/gcc61-include/bits/stl_algo.h:104:42: required from &#x27;_InputIterator std::__find_if(_InputIterator, _InputIterator, _Predicate, std:[with _InputIterator = std::_Rb_tree_iterator&lt;std::pair&lt;const &lt;char&gt;, double&gt; &gt;; _Predicate = __gnu_cxx::__ops::_Iter_pred&lt;&lt;lambda(const string&amp;)&gt; &gt;]&#x27;</span><br><span class="line">7 /cygdrive/p/gcc/gcc61-include/bits/stl_algo.h:161:23: required from &#x27;_Iterator std::__find_if(_Iterator, _Iterator, _Predicate) [with _Iterator = std pair&lt;const std::__cxx11::basic_string&lt;char&gt;, double&gt; &gt;; _Predic Iter_pred&lt;main()::&lt;lambda(const string&amp;)&gt; &gt;]&#x27;</span><br><span class="line">8 /cygdrive/p/gcc/gcc61-include/bits/stl_algo.h:3824:28: required from &#x27;_IIter std::find_if(_IIter, _IIter, _Predicate) [with _IIter = std::_Rb_tree_it std::__cxx11::basic_string&lt;char&gt;, double&gt; &gt;; _Predicate = main &lt;lambda(const string&amp;)&gt;]&#x27;</span><br><span class="line">9 errornovel1.cpp:13:29: required from here /cygdrive/p/gcc/gcc61-include/bits/predefined_ops.h:234:11: error: no match for call to &#x27;(main()::&lt;lambda(const string&amp;)&gt;) (std::pair&lt;const std::__cxx11::basic_string&lt;double&gt;&amp;)&#x27;11 &#123; return bool(_M_pred(*__it)); &#125;</span><br><span class="line">12 ^~~~~~~~~~~~~~~~~~~~</span><br><span class="line">13 /cygdrive/p/gcc/gcc61-include/bits/predefined_ops.h:234:11: note: candidate: bool (*)( const string&amp;) &#123;aka bool (*)(const std::__cxx11::basic_string&lt;char&gt;&amp;)&#125; &lt;conversion&gt;</span><br><span class="line">14 /cygdrive/p/gcc/gcc61-include/bits/predefined_ops.h:234:11: note: candidate expects 2arguments, 2 provided 15 errornovel1.cpp:11:52: note: candidate: main()::&lt;lambda(const string&amp;)&gt;</span><br><span class="line">16 [] (std::string const&amp; s) &#123;</span><br><span class="line">17 ^</span><br><span class="line">18 errornovel1.cpp:11:52: note: no known conversion for argument std::__cxx11::basic_string&lt;char&gt;, double&gt;&#x27; to &#x27;const string&amp; &#123;a basic_string&lt;char&gt;&amp;&#125;&#x27;</span><br></pre></td></tr></table></figure></p>
<p>以上错误信息中第一部分的意思是，在一个函数模板的实例中遇到了错误，这个模板位于一个内部头文件<code>predefined_ops.h</code>中。在这一行以及后面的几行中，编译器报告了哪些模板被用哪些参数实例化了。本例子中从以下开始：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pos = std::<span class="built_in">find_if</span> (coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(),</span><br><span class="line">    [] (std::string <span class="type">const</span>&amp; s) &#123;</span><br><span class="line">        <span class="keyword">return</span> s != <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这导致了一个<code>find_if</code>的实例化，这个在<code>stl_algo.h</code>头文件<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IIter = std::_Rb_tree_iterator&lt;std::pair&lt;<span class="type">const</span> std::__cxx11::basic_string&lt;<span class="type">char</span>&gt;, <span class="type">double</span>&gt; &gt;_Predicate = <span class="built_in">main</span>()::&lt;<span class="built_in">lambda</span>(<span class="type">const</span> string&amp;)&gt;</span><br></pre></td></tr></table></figure></p>
<p>编译器会报告所有这些，以防我们根本不期望所有这些模板都被实例化。它允许我们确定导致实例化的事件链。然而，在我们的示例中，我们愿意相信各种模板都需要实例化，我们只是想知道为什么它不起作用。此信息出现在消息的最后部分：“调用不匹配”部分表示由于参数类型和参数类型不匹配，因此无法解析函数调用。它列出了调用的内容:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">main</span>()::&lt;<span class="built_in">lambda</span>(<span class="type">const</span> string&amp;)&gt;) (std::pair&lt;<span class="type">const</span> std::__cxx11::basic_string&lt;<span class="type">char</span>&gt;, <span class="type">double</span>&gt;&amp;)</span><br></pre></td></tr></table></figure></p>
<p>此外，就在这之后，包含“note: candidate:”的行解释说有一个候选类型需要一个<code>const string&amp;</code>，并且这个候选类型在<code>errornovel1.cpp</code>的第 11 行中定义<code>lambda [] (std::string const&amp; s)</code></p>
<p>毫无疑问，错误信息可能会更好。实际问题可能会在实例化之前发出，而不是使用完全扩展的模板实例化名称，如<code>std::__cxx11::basic_string&lt;char&gt;</code>，仅使用<code>std::string</code>可能就足够了。但是，此诊断中的所有信息在某些情况下可能很有用。</p>
<h2 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h2><ul>
<li>模板的包含模式被广泛用来组织模板代码。第14章会介绍另一种替代方法。</li>
<li>当被定义在头文件中，且不在类或者结构体中时，函数模板的全特例化版本需要使用inline。</li>
<li>为了充分发挥预编译的特性，要确保#include指令的顺序相同。</li>
<li>Debug模板相关代码很有挑战性。</li>
</ul>
<h1 id="模板基本术语"><a href="#模板基本术语" class="headerlink" title="模板基本术语"></a>模板基本术语</h1><h2 id="“类模板”还是“模板类”"><a href="#“类模板”还是“模板类”" class="headerlink" title="“类模板”还是“模板类”"></a>“类模板”还是“模板类”</h2><p>在C++中，structs，classes以及unions都被称为class types。如果没有特殊声明的话，“class”的字面意思是用关键字class或者struct声明的class types。注意class types包含unions，但是class不包含。关于该如何称呼一个是模板的类，有一些困扰：</p>
<ul>
<li>术语class template是指这个class是模板。也就是说它是一组class的参数化表达。</li>
<li>术语template class则被：<ul>
<li>用作class template的同义词。</li>
<li>用来指代从template实例化出来的classes。</li>
<li>用来指代名称是一个template-id（模板名+ &lt;模板参数&gt;）的类。</li>
</ul>
</li>
</ul>
<h2 id="替换，实例化，和特例化"><a href="#替换，实例化，和特例化" class="headerlink" title="替换，实例化，和特例化"></a>替换，实例化，和特例化</h2><p>在处理模板相关的代码时，C++编译器必须经常去用模板实参替换模板参数。有时后这种替换只是试探性的：编译器需要验证这个替换是否有效。用实际参数替换模板参数，以从一个模板创建一个常规类、类型别名、函数、成员函数或者变量的过程，被称为“模板实例化”。</p>
<p>不过令人意外的是，目前就该如何表示通过模板参数替换创建一个声明（不是定义）的过程，还没有相关标准以及基本共识。有人使用“部分实例化（partial instantiation）”或者“声明的实例化（instantiation of a declaration）”，但是这些用法都不够普遍。或许使用“不完全实例化（incomplete instantiation）”会更直观一些。</p>
<p>通过实例化或者不完全实例化产生的实体通常被称为特例化（specialization）。但是在C++中，实例化过程并不是产生特例化的唯一方式。另外一些方式允许程序员显式的指定一个被关联到模板参数的、被进行了特殊替换的声明。这一类特例化以一个<code>template&lt;&gt;</code>开始：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="comment">// primary class template</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="comment">// explicit specialization</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;std::string,<span class="type">float</span>&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>严格来说，这被称为显式特例化（explicit specialization）。</p>
<p>如果特例化之后依然还有模板参数，就称之为部分特例化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// partial specialization</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T,T&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// partial specialization</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">bool</span>,T&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h2><p>到目前为止，“声明”和“定义”只在本书中使用了几次。但是在标准C++中，这些单词有着明确的定义，我们也将采用这些定义。</p>
<p>“声明”是一个C++概念，它将一个名称引入或者再次引入到一个C++作用域内。引入的过程中可能会包含这个名称的一部分类别，但是一个有效的声明并不需要相关名称的太多细节。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>; <span class="comment">// a declaration of C as a class</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> p)</span></span>; <span class="comment">// a declaration of f() as a function and p as a named parameter</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> v; <span class="comment">// a declaration of v as a variable</span></span><br></pre></td></tr></table></figure></p>
<p>注意，在C++中虽然宏和goto标签也都有名字，但是它们并不是声明。对于声明，如果其细节已知，或者是需要申请相关变量的存储空间，那么声明就变成了定义。对于class类型的定义和函数定义，意味着需要提供一个包含在{}中的主体，或者是对函数使用了=defaul/=delete。对于变量，如果进行了初始化或者没有使用extern，那么声明也会变成定义。下面是一些“定义”的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;&#125;; <span class="comment">// definition (and declaration) of class C</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; <span class="comment">//definition (and declaration) of function f()</span></span><br><span class="line">std::cout &lt;&lt; p &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> v = <span class="number">1</span>; <span class="comment">// an initializer makes this a definition for v</span></span><br><span class="line"><span class="type">int</span> w; <span class="comment">// global variable declarations not preceded by extern are also definitions</span></span><br></pre></td></tr></table></figure></p>
<p>作为扩展，如果一个类模板或者函数模板有包含在{}中的主体的话，那么声明也会变成定义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span> <span class="params">(T)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>是一个声明。而：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>则是一个定义。</p>
<h3 id="完整类型和非完整类型（complete-versus-incomplete-types）"><a href="#完整类型和非完整类型（complete-versus-incomplete-types）" class="headerlink" title="完整类型和非完整类型（complete versus incomplete types）"></a>完整类型和非完整类型（complete versus incomplete types）</h3><p>类型可以是完整的（complete）或者是不完整的（incomplete），这一名词和声明以及定义之间的区别密切相关。有些语言的设计要求完整类型，有一些也适用于非完整类型。非完整类型是以下情况之一：</p>
<ul>
<li>一个被声明但是还没有被定义的class类型。</li>
<li>一个没有指定边界的数组。</li>
<li>一个存储非完整类型的数组。</li>
<li>Void类型。</li>
<li>一个底层类型未定义或者枚举值未定义的枚举类型。</li>
<li>任何一个被const或者volatile修饰的以上某种类型。</li>
</ul>
<p>其它所有类型都是完整类型。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>; <span class="comment">// C is an incomplete type</span></span><br><span class="line">C <span class="type">const</span>* cp; <span class="comment">// cp is a pointer to an incomplete type</span></span><br><span class="line"><span class="keyword">extern</span> C elems[<span class="number">10</span>]; <span class="comment">// elems has an incomplete type</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> arr[]; <span class="comment">// arr has an incomplete type...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123; &#125;; <span class="comment">// C now is a complete type (and therefore cpand elems</span></span><br><span class="line"><span class="comment">// no longer refer to an incomplete type)</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>]; <span class="comment">// arr now has a complete type</span></span><br></pre></td></tr></table></figure></p>
<h2 id="唯一定义法则"><a href="#唯一定义法则" class="headerlink" title="唯一定义法则"></a>唯一定义法则</h2><p>C++语言中对实体的重复定义做了限制。这一限制就是“唯一定义法则（one-definition rule, ODR）”。目前只要记住以下基础的ODR就够了：</p>
<ul>
<li>常规（比如非模板）非inline函数和成员函数，以及非inline的全局变量和静态数据成员，在整个程序中只能被定义一次。</li>
<li>Class类型（包含struct和union），模板（包含部分特例化，但不能是全特例化），以及inline函数和变量，在一个编译单元中只能被定义一次，而且不同编译单元间的定义应该相同。</li>
</ul>
<p>编译单元是通过预处理源文件产生的一个文件；它包含通过#include指令包含的内容以及宏展开之后的内容。</p>
<p>在后面的章节中，可链接实体（linkable entity）指的是下面的任意一种：一个函数或者成员函数，一个全局变量或者静态数据成员，以及通过模板产生的类似实体，只要对linker可见就行。</p>
<h2 id="Template-Arguments-versus-Template-Parameters"><a href="#Template-Arguments-versus-Template-Parameters" class="headerlink" title="Template Arguments versus Template Parameters"></a>Template Arguments versus Template Parameters</h2><p>考虑如下类模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayInClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T array[N];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>和一个类似的类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleArrayInClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> array[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果将前者中的模板参数T和N替换为double和10，那么它将和后者相同。在C++中这种类型的模板参数替换被表示为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayInClass&lt;<span class="type">double</span>,<span class="number">10</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>注意模板名称后面的尖括号以及其中的模板实参。</p>
<p>不管这些实参是否和模板参数有关，模板名称以及其后面的尖括号和其中的模板实参，被称为template-id。其用法和非模板类的用法非常相似。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ArrayInClass&lt;<span class="type">double</span>,<span class="number">10</span>&gt; ad; </span><br><span class="line">    ad.array[<span class="number">0</span>] = <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有必要对模板参数（template parameters）和模板实参（template arguments）进行区分。简单来讲可以说“模板参数是被模板实参初始化的”。或者更准确的说：</p>
<ul>
<li>模板参数是那些在模板定义或者声明中，出现在template关键字后面的尖括号中的名称。</li>
<li>模板实参是那些用来替换模板参数的内容。不同于模板参数，模板实参可以不只是“名称”。</li>
</ul>
<p>当指出模板的template-id的时候，用模板实参替换模板参数的过程就是显式的，但是在很多情况这一替换则是隐式的（比如模板参数被其默认值替换的情况）。</p>
<p>一个基本原则是：任何模板实参都必须是在编译期可知的。就如接下来会澄清的，这一要求对降低模板运行期间的成本很有帮助。由于模板参数最终都会被编译期的值进行替换，它们也可以被用于编译期表达式。在ArrayInClass模板中指定成员array的尺寸时就用到了这一特性。数组的尺寸必须是一个常量表达式，而模板参数N恰好满足这一要求。</p>
<p>对这一特性的使用可以更进一步：由于模板参数是编译期实体，它们也可以被用作模板实参。就像下面这个例子这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dozen</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ArrayInClass&lt;T,<span class="number">12</span>&gt; contents;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中T既是模板参数也是模板实参。这样这一原理就可以被用来从简单模板构造更复杂的模板。当然，在原理上，这和我们构造类型和函数并没有什么不同。</p>
<h2 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h2><ul>
<li>对那些是模板的类，函数和变量，我们称之为类模板，函数模板和变量模板。</li>
<li>模板实例化过程是一个用实参取代模板参数，从而创建常规类或者函数的过程。最终产生的实体是一个特化。</li>
<li>类型可以是完整的或者非完整的。</li>
<li>根据唯一定义法则（ODR），非inline函数，成员函数，全局变量和静态数据成员在整个程序中只能被定义一次。</li>
</ul>
<h1 id="泛型库"><a href="#泛型库" class="headerlink" title="泛型库"></a>泛型库</h1><h2 id="可调用对象（Callables）"><a href="#可调用对象（Callables）" class="headerlink" title="可调用对象（Callables）"></a>可调用对象（Callables）</h2><p>一些库包含这样一种接口，客户端代码可以向该类接口传递一个实体，并要求该实体必须被调用。相关的例子有：必须在另一个线程中被执行的操作，一个指定该如何处理hash值并将其存在hash表中的函数（hash函数），一个指定集合中元素排序方式的对象。标准库也不例外：它定义了很多可以接受可调用对象作为参数的组件。</p>
<p>这里会用到一个叫做回调（callback）的名词。传统上这一名词被作为函数调用实参使用，我们将保持这一传统。比如一个排序函数可能会接受一个回调参数并将其用作排序标准，该回调参数将决定排序顺序。</p>
<p>在C++中，由于一些类型既可以被作为函数调用参数使用，也可以按照<code>f(...)</code>的形式调用，因此可以被用作回调参数：</p>
<ul>
<li>函数指针类型</li>
<li>重载了<code>operator()</code>的class类型（有时被称为仿函数（functors）），这其中包含lambda函数</li>
<li>包含一个可以产生一个函数指针或者函数引用的转换函数的class类型</li>
</ul>
<p>这些类型被统称为函数对象类型（function object types），其对应的值被称为函数对象（function object）。</p>
<p>如果可以接受某种类型的可调用对象的话，泛型代码通常可以从中受益，而模板使其称为可能。</p>
<h3 id="函数对象的支持"><a href="#函数对象的支持" class="headerlink" title="函数对象的支持"></a>函数对象的支持</h3><p>来看一下标准库中的<code>for_each()</code>算法是如何实现的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Callable&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foreach</span> <span class="params">(Iter current, Iter end, Callable op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (current != end) &#123; <span class="comment">//as long as not reached the end</span></span><br><span class="line">        <span class="built_in">op</span>(*current); <span class="comment">// call passed operator for current element</span></span><br><span class="line">        ++current; <span class="comment">// and move iterator to next element</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面的代码展示了将以上模板用于多种函数对象的情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foreach.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// a function to call:</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;func() called for: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a function object type (for objects that can be used as functions):</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FuncObj</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span> </span>&#123; <span class="comment">//Note: const member function</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;FuncObj::op() called for: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; primes = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span> &#125;;</span><br><span class="line">    foreach(primes.<span class="built_in">begin</span>(), primes.<span class="built_in">end</span>(), <span class="comment">// range</span></span><br><span class="line">            func); <span class="comment">// function as callable (decays to pointer)</span></span><br><span class="line">    foreach(primes.<span class="built_in">begin</span>(), primes.<span class="built_in">end</span>(), <span class="comment">// range</span></span><br><span class="line">            &amp;func); <span class="comment">// function pointer as callable</span></span><br><span class="line">    foreach(primes.<span class="built_in">begin</span>(), primes.<span class="built_in">end</span>(), <span class="comment">// range</span></span><br><span class="line">            <span class="built_in">FuncObj</span>()); <span class="comment">// function object as callable</span></span><br><span class="line">    foreach(primes.<span class="built_in">begin</span>(), primes.<span class="built_in">end</span>(), <span class="comment">// range</span></span><br><span class="line">            [] (<span class="type">int</span> i) &#123; <span class="comment">//lambda as callable</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;lambda called for: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>详细看一下以上各种情况：</p>
<ul>
<li>当把函数名当作函数参数传递时，并不是传递函数本体，而是传递其指针或者引用。和数组情况类似，在按值传递时，函数参数退化为指针，如果参数类型是模板参数，那么类型会被推断为指向函数的指针。和数组一样，按引用传递的函数的类型不会decay。但是函数类型不能真正用const限制。如果将<code>foreach()</code>的最后一个参数的类型声明为<code>Callable const &amp;</code>，const会被省略。</li>
<li>在第二个调用中，函数指针被显式传递（传递了一个函数名的地址）。这和第一中调用方式相同（函数名会隐式的decay成指针），但是相对而言会更清楚一些。</li>
<li>如果传递的是仿函数，就是将一个类的对象当作可调用对象进行传递。通过一个class类型进行调用通常等效于调用了它的<code>operator()</code>。因此下面这样的调用：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">op</span>(*current);</span><br></pre></td></tr></table></figure>
<p>会被转换成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op.<span class="built_in">operator</span>()(*current); <span class="comment">// call operator() with parameter *current for op</span></span><br></pre></td></tr></table></figure></p>
<p>注意在定义<code>operator()</code>的时候最好将其定义成const成员函数。否则当一些框架或者库不希望该调用会改变被传递对象的状态时，会遇到很不容易debug的error。</p>
<ul>
<li>Lambda表达式会产生仿函数（也称闭包），因此它与仿函数（重载了<code>operator()</code>的类）的情况没有不同。不过Lambda引入仿函数的方法更为简便，因此它们从C++11开始变得很常见。<ul>
<li>有意思的是，以<code>[]</code>开始的lambdas（没有捕获）会产生一个向函数指针进行转换的运算符。</li>
</ul>
</li>
</ul>
<h3 id="处理成员函数以及额外的参数"><a href="#处理成员函数以及额外的参数" class="headerlink" title="处理成员函数以及额外的参数"></a>处理成员函数以及额外的参数</h3><p>在以上例子中漏掉了另一种可以被调用的实体：成员函数。这是因为在调用一个非静态成员函数的时候需要像下面这样指出对象：<code>object.memfunc(...)</code>或者<code>ptr-&gt;memfunc(...)</code>，这和常规情况下的直接调用方式不同：<code>func(...)</code>。</p>
<p>幸运的是，从C++17开始，标准库提供了一个工具：<code>std::invlke()</code>，它非常方便的统一了上面的成员函数情况和常规函数情况，这样就可以用同一种方式调用所有的可调用对象。下面代码中<code>foreach()</code>的实现使用了<code>std::invoke()</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> Callable, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foreach</span> <span class="params">(Iter current, Iter end, Callable op, Args <span class="type">const</span>&amp;...args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (current != end) &#123; <span class="comment">//as long as not reached the end of the elements</span></span><br><span class="line">        std::<span class="built_in">invoke</span>(op, <span class="comment">//call passed callable with</span></span><br><span class="line">            args..., <span class="comment">//any additional args</span></span><br><span class="line">            *current); <span class="comment">// and the current element</span></span><br><span class="line">        ++current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里除了作为参数的可调用对象，<code>foreach()</code>还可以接受任意数量的参数。然后<code>foreach()</code>将参数传递给<code>std::invoke()</code>。<code>std::invoke()</code>会这样处理相关参数：</p>
<ul>
<li>如果可调用对象是一个指向成员函数的指针，它会将<code>args...</code>中的第一个参数当作<code>this</code>对象（不是指针）。<code>args...</code>中其余的参数则被当做常规参数传递给可调用对象。</li>
<li>否则，所有的参数都被直接传递给可调用对象。</li>
</ul>
<p>注意这里对于可调用对象和<code>agrs...</code>都不能使用完美转发（perfect forward）：因为第一次调用可能会steal(偷窃)相关参数的值，导致在随后的调用中出现错误。</p>
<p>现在既可以像之前那样调用<code>foreach()</code>，也可以向它传递额外的参数，而且可调用对象可以是一个成员函数。正如下面的代码展现的那样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foreachinvoke.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// a class with a member function that shall be called</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">memfunc</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass::memfunc() called for: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; primes = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span> &#125;;</span><br><span class="line">    <span class="comment">// pass lambda as callable and an additional argument:</span></span><br><span class="line">    foreach(primes.<span class="built_in">begin</span>(), primes.<span class="built_in">end</span>(), <span class="comment">//elements for 2nd arg of lambda</span></span><br><span class="line">        [](std::string <span class="type">const</span>&amp; prefix, <span class="type">int</span> i) &#123; <span class="comment">//lambda to call</span></span><br><span class="line">            std::cout &lt;&lt; prefix &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;, <span class="string">&quot;- value:&quot;</span>); <span class="comment">//1st arg of lambda</span></span><br><span class="line">    <span class="comment">// call obj.memfunc() for/with each elements in primes passed as argument</span></span><br><span class="line">    MyClass obj;</span><br><span class="line">    foreach(primes.<span class="built_in">begin</span>(), primes.<span class="built_in">end</span>(), <span class="comment">//elements used as args</span></span><br><span class="line">            &amp;MyClass::memfunc, <span class="comment">//member function to call</span></span><br><span class="line">            obj); <span class="comment">// object to call memfunc() for</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一次调用<code>foreach()</code>时，第四个参数被作为lambda函数的第一个参数传递给lambda，而vector中的元素被作为第二个参数传递给lambda。第二次调用中，第三个参数<code>memfunc()</code>被第四个参数obj调用。</p>
<h3 id="函数调用的包装"><a href="#函数调用的包装" class="headerlink" title="函数调用的包装"></a>函数调用的包装</h3><p><code>std::invoke()</code>的一个常规用法是封装一个单独的函数调用。此时可以通过完美转发可调用对象以及被传递的参数来支持移动语义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// for std::invoke()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// for std::forward()</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">call</span><span class="params">(Callable&amp;&amp; op, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">invoke</span>(std::forward&lt;Callable&gt;(op), <span class="comment">//passed callable with</span></span><br><span class="line">                std::forward&lt;Args&gt;(args)...); <span class="comment">// any additional args</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个比较有意思的地方是该如何处理被调用函数的返回值，才能将其“完美转发”给调用者。为了能够返回引用（比如<code>std::ostream&amp;</code>），需要使用<code>decltype(auto)</code>而不是<code>auto</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">call</span><span class="params">(Callable&amp;&amp; op, Args&amp;&amp;... args)</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>decltype(auto)</code>（在C++14中引入）是一个占位符类型，它根据相关表达式决定了变量、返回值、或者模板实参的类型。</p>
<p>如果你想暂时的将<code>std::invoke()</code>的返回值存储在一个变量中，并在做了某些别的事情后将其返回（比如处理该返回值或者记录当前调用的结束），也必须将该临时变量声明为<code>decltype(auto)</code>类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) ret&#123;std::<span class="built_in">invoke</span>(std::forward&lt;Callable&gt;(op),</span><br><span class="line">std::forward&lt;Args&gt;(args)...)&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure></p>
<p>注意这里将<code>ret</code>声明为<code>auto &amp;&amp;</code>是不对的。<code>auto&amp;&amp;</code>作为引用会将变量的生命周期扩展到作用域的末尾，但是不会扩展到超出return的地方。不过即使是使用<code>decltype(auto)</code>也还是有一个问题：如果可调用对象的返回值是void，那么将<code>ret</code>初始化为<code>decltype(auto)</code>是不可以的，这是因为void是不完整类型。此时有如下选择：</p>
<ul>
<li>在当前行前面声明一个对象，并在其析构函数中实现期望的行为。比如：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cleanup</span> &#123;</span><br><span class="line">    ~<span class="built_in">cleanup</span>() &#123;</span><br><span class="line">        ... <span class="comment">//code to perform on return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; dummy;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">invoke</span>(std::forward&lt;Callable&gt;(op),</span><br><span class="line">    std::forward&lt;Args&gt;(args)...);</span><br></pre></td></tr></table></figure>
<ul>
<li>分别实现void和非void的情况：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// for std::invoke()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// for std::forward()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// for std::is_same&lt;&gt; and invoke_result&lt;&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">call</span><span class="params">(Callable&amp;&amp; op, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::is_same_v&lt;std::<span class="type">invoke_result_t</span>&lt;Callable,</span></span></span><br><span class="line"><span class="params"><span class="function">    Args...&gt;, <span class="type">void</span>&gt;)</span> </span>&#123;<span class="comment">// return type is void:</span></span><br><span class="line">        std::<span class="built_in">invoke</span>(std::forward&lt;Callable&gt;(op),</span><br><span class="line">        std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// return type is not void:</span></span><br><span class="line">        <span class="keyword">decltype</span>(<span class="keyword">auto</span>) ret&#123;std::<span class="built_in">invoke</span>(std::forward&lt;Callable&gt;(op),</span><br><span class="line">        std::forward&lt;Args&gt;(args)...)&#125;;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::is_same_v&lt;std::<span class="type">invoke_result_t</span>&lt;Callable, Args...&gt;, <span class="type">void</span>&gt;)</span></span></span><br></pre></td></tr></table></figure></p>
<p>在编译期间检查使用<code>Args...</code>的callable的返回值是不是void类型。后续的C++版本可能会免除掉这种对void的特殊操作。</p>
<h2 id="其他一些实现泛型库的工具"><a href="#其他一些实现泛型库的工具" class="headerlink" title="其他一些实现泛型库的工具"></a>其他一些实现泛型库的工具</h2><p><code>std::invoke()</code>只是C++标准库提供的诸多有用工具中的一个。在接下来的内容中，我们会介绍其他一些重要的工具。</p>
<h3 id="类型萃取"><a href="#类型萃取" class="headerlink" title="类型萃取"></a>类型萃取</h3><p>标准库提供了各种各样的被称为类型萃取（type traits）的工具，它们可以被用来计算以及修改类型。这样就可以在实例化的时候让泛型代码适应各种类型或者对不同的类型做出不同的响应。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ensure that T is not void (ignoring const or volatile):</span></span><br><span class="line"><span class="built_in">static_assert</span>(!std::is_same_v&lt;std::<span class="type">remove_cv_t</span>&lt;T&gt;,<span class="type">void</span>&gt;,</span><br><span class="line"><span class="string">&quot;invalid instantiation of class C for void type&quot;</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">f</span><span class="params">(V&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::is_reference_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">            ... <span class="comment">// special code if T is a reference type</span></span><br><span class="line">        &#125; <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::is_convertible_v&lt;std::<span class="type">decay_t</span>&lt;V&gt;,T&gt;)</span> </span>&#123;</span><br><span class="line">            ... <span class="comment">// special code if V is convertible to T</span></span><br><span class="line">        &#125; <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::has_virtual_destructor_v&lt;V&gt;)</span> </span>&#123;</span><br><span class="line">            ... <span class="comment">// special code if V has virtual destructor</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，通过检查某些条件,可以在模板的不同实现之间做选择。在这里用到了编译期的<code>if</code>特性，该特性从C++17开始可用，作为替代选项，这里也可以使用<code>std::enable_if</code>、部分特例化或者SFINAE。但是使用类型萃取的时候需要额外小心：其行为可能和程序员的预期不同。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="type">remove_const_t</span>&lt;<span class="type">int</span> <span class="type">const</span>&amp;&gt; <span class="comment">// yields int const&amp;</span></span><br></pre></td></tr></table></figure></p>
<p>这里由于引用不是const类型的（虽然你不可以改变它），这个操作不会有任何效果。这样，删除引用和删除const的顺序就很重要了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="type">remove_const_t</span>&lt;std::<span class="type">remove_reference_t</span>&lt;<span class="type">int</span> <span class="type">const</span>&amp;&gt;&gt; <span class="comment">// int</span></span><br><span class="line">std::<span class="type">remove_reference_t</span>&lt;std::<span class="type">remove_const_t</span>&lt;<span class="type">int</span> <span class="type">const</span>&amp;&gt;&gt; <span class="comment">// int const</span></span><br></pre></td></tr></table></figure></p>
<p>另一种方法是，直接调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="type">decay_t</span>&lt;<span class="type">int</span> <span class="type">const</span>&amp;&gt; <span class="comment">// yields int</span></span><br></pre></td></tr></table></figure></p>
<p>但是这同样会让裸数组和函数类型退化为相应的指针类型。</p>
<p>当然还有一些类型萃取的使用是有要求的。这些要求不被满足的话，其行为将是未定义的。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">make_unsigned_t</span>&lt;<span class="type">int</span>&gt; <span class="comment">// unsigned int</span></span><br><span class="line"><span class="type">make_unsigned_t</span>&lt;<span class="type">int</span> <span class="type">const</span>&amp;&gt; <span class="comment">// undefined behavior (hopefully error)</span></span><br></pre></td></tr></table></figure></p>
<p>某些情况下，结果可能会让你很意外。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">add_rvalue_reference_t</span>&lt;<span class="type">int</span> <span class="type">const</span>&gt; <span class="comment">// int const&amp;&amp;</span></span><br><span class="line"><span class="type">add_rvalue_reference_t</span>&lt;<span class="type">int</span> <span class="type">const</span>&amp;&gt; <span class="comment">// int const&amp; (lvalueref remains lvalue-ref)</span></span><br></pre></td></tr></table></figure></p>
<p>这里我们期望add_rvalue_reference总是能够返回一个右值引用，但是C++中的引用塌缩会令左值引用和右值引用的组合返回一个左值引用。另一个例子是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">is_copy_assignable_v&lt;<span class="type">int</span>&gt; <span class="comment">// yields true (generally, you can assign an int to an int)</span></span><br><span class="line">is_assignable_v&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="comment">// yields false (can&quot;t call 42 = 42)</span></span><br></pre></td></tr></table></figure></p>
<p>其中<code>is_copy_assignable</code>通常只会检查是否能够将一个int赋值给另外一个（检查左值的相关操作），而<code>is_assignable</code>则会考虑值的种类（value category，会检查是否能将一个右值赋值给另外一个）。也就是说第一个语句等效于：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is_assignable_v&lt;<span class="type">int</span>&amp;,<span class="type">int</span>&amp;&gt; <span class="comment">// yields true</span></span><br></pre></td></tr></table></figure></p>
<p>对下面的例子也是这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">is_swappable_v&lt;<span class="type">int</span>&gt; <span class="comment">// yields true (assuming lvalues)</span></span><br><span class="line">is_swappable_v&lt;<span class="type">int</span>&amp;,<span class="type">int</span>&amp;&gt; <span class="comment">// yields true (equivalent to the previous check)</span></span><br><span class="line">is_swappable_with_v&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="comment">// yields false (taking value category into account)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="std-addressoff"><a href="#std-addressoff" class="headerlink" title="std::addressoff()"></a>std::addressoff()</h3><p>函数模板<code>std::addressof&lt;&gt;()</code>会返回一个对象或者函数的准确地址。即使一个对象重载了运算符<code>&amp;</code>也是这样。虽然后者中的情况很少遇到，但是也会发生（比如在智能指针中）。因此，如果需要获得任意类型的对象的地址，那么推荐使用<code>addressof()</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(T&amp;&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = &amp;x; <span class="comment">// might fail with overloaded operator &amp;</span></span><br><span class="line">    <span class="keyword">auto</span> q = std::<span class="built_in">addressof</span>(x); <span class="comment">// works even with overloaded operator &amp;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="std-declval"><a href="#std-declval" class="headerlink" title="std::declval()"></a>std::declval()</h3><p>函数模板<code>std::declval()</code>可以被用作某一类型的对象的引用的占位符。该函数模板没有定义，因此不能被调用（也不会创建对象）。因此它只能被用作不会被计算的操作数（比如<code>decltype</code>和<code>sizeof</code>）。也因此，在不创建对象的情况下，依然可以假设有相应类型的可用对象。比如在如下例子中，会基于模板参数<code>T1</code>和<code>T2</code>推断出返回类型RT：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2,</span><br><span class="line"><span class="keyword">typename</span> RT = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(<span class="literal">true</span> ? std::<span class="built_in">declval</span>&lt;T1&gt;() :</span><br><span class="line">std::<span class="built_in">declval</span>&lt;T2&gt;())&gt;&gt;</span><br><span class="line">RT <span class="built_in">max</span> (T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了避免在调用运算符<code>?:</code>的时候不得不去调用T1和T2的（默认）构造函数，这里使用了<code>std::declval</code>，这样可以在不创建对象的情况下“使用”它们。不过该方式只能在不会做真正的计算时（比如decltype）使用。不要忘了使用<code>std::decay&lt;&gt;</code>来确保返回类型不会是一个引用，因为<code>std::declval&lt;&gt;</code>本身返回的是右值引用。否则，类似<code>max(1,2)</code>这样的调用将会返回一个<code>int&amp;&amp;</code>类型。</p>
<h2 id="完美转发临时变量"><a href="#完美转发临时变量" class="headerlink" title="完美转发临时变量"></a>完美转发临时变量</h2><p>可以使用转发引用（forwarding reference）以及<code>std::forward&lt;&gt;</code>来完美转发泛型参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(T&amp;&amp; t)</span> <span class="comment">// t is forwarding reference</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">g</span>(std::forward&lt;T&gt;(t)); <span class="comment">// perfectly forward passed argument t to g()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是某些情况下，在泛型代码中我们需要转发一些不是通过参数传递进来的数据。此时我们可以使用<code>auto &amp;&amp;</code>创建一个可以被转发的变量。比如，假设我们需要相继的调用<code>get()</code>和<code>set()</code>两个函数，并且需要将<code>get()</code>的返回值完美的转发给<code>set()</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>(<span class="built_in">get</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设以后我们需要更新代码对<code>get()</code>的返回值进行某些操作，可以通过将<code>get()</code>的返回值存储在一个被声明为<code>auto &amp;&amp;</code>的变量中实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; val = <span class="built_in">get</span>(x);</span><br><span class="line">    ... <span class="comment">// perfectly forward the return value of get() to set():</span></span><br><span class="line">    <span class="built_in">set</span>(std::forward&lt;<span class="keyword">decltype</span>(val)&gt;(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样可以避免对中间变量的多余拷贝。</p>
<h2 id="作为模板参数的引用"><a href="#作为模板参数的引用" class="headerlink" title="作为模板参数的引用"></a>作为模板参数的引用</h2><p>虽然不是很常见，但是模板参数的类型依然可以是引用类型。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tmplParamIsReference</span><span class="params">(T)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;T is reference: &quot;</span> &lt;&lt; std::is_reference_v&lt;T&gt; &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span>&amp; r = i;</span><br><span class="line">    <span class="built_in">tmplParamIsReference</span>(i); <span class="comment">// false</span></span><br><span class="line">    <span class="built_in">tmplParamIsReference</span>(r); <span class="comment">// false</span></span><br><span class="line">    <span class="built_in">tmplParamIsReference</span>&lt;<span class="type">int</span>&amp;&gt;(i); <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">tmplParamIsReference</span>&lt;<span class="type">int</span>&amp;&gt;(r); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即使传递给<code>tmplParamIsReference()</code>的参数是一个引用变量，T依然会被推断为被引用的类型（因为对于引用变量v，表达式v的类型是被引用的类型，表达式（expression）的类型永远不可能是引用类型）。不过我们可以显示指定T的类型化为引用类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tmplParamIsReference</span>&lt;<span class="type">int</span>&amp;&gt;(r);</span><br><span class="line"><span class="built_in">tmplParamIsReference</span>&lt;<span class="type">int</span>&amp;&gt;(i);</span><br></pre></td></tr></table></figure></p>
<p>这样做可以从根本上改变模板的行为，不过由于这并不是模板最初设计的目的，这样做可能会触发错误或者不可预知的行为。考虑如下例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T Z = T&#123;&#125;&gt;</span><br><span class="line"><span class="keyword">class</span> RefMem &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T zero;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RefMem</span>() : zero&#123;Z&#125; &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> null = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RefMem&lt;<span class="type">int</span>&gt; rm1, rm2;</span><br><span class="line">    rm1 = rm2; <span class="comment">// OK</span></span><br><span class="line">    RefMem&lt;<span class="type">int</span>&amp;&gt; rm3; <span class="comment">// ERROR: invalid default value for N</span></span><br><span class="line">    RefMem&lt;<span class="type">int</span>&amp;, <span class="number">0</span>&gt; rm4; <span class="comment">// ERROR: invalid default value for N extern</span></span><br><span class="line">    <span class="type">int</span> null;</span><br><span class="line">    RefMem&lt;<span class="type">int</span>&amp;,null&gt; rm5, rm6;</span><br><span class="line">    rm5 = rm6; <span class="comment">// ERROR: operator= is deleted due to reference member</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处模板的模板参数为T，其非类型模板参数z被进行了零初始化。用int实例化该模板会获得预期的行为。但是如果尝试用引用对其进行实例化的话，情况就有点复杂了：</p>
<ul>
<li>非模板参数的默认初始化不在可行。</li>
<li>不再能够直接用0来初始化非参数模板参数。</li>
<li>最让人意外的是，赋值运算符也不再可用，因为对于具有非static引用成员的类，其默赋值运算符会被删除掉。</li>
</ul>
<p>而且将引用类型用于非类型模板参数同样会变的复杂和危险。考虑如下例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span>&amp; SZ&gt; <span class="comment">// Note: size is reference</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Arr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T&gt; elems;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Arr</span>() : <span class="built_in">elems</span>(SZ) &#123; <span class="comment">//use current SZ as initial vector size</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;SZ; ++i) &#123; <span class="comment">//loop over SZ elements</span></span><br><span class="line">            std::cout &lt;&lt; elems[i] &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> size = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Arr&lt;<span class="type">int</span>&amp;,size&gt; y; <span class="comment">// compile-time ERROR deep in the code of class</span></span><br><span class="line">    std::vector&lt;&gt;</span><br><span class="line">    Arr&lt;<span class="type">int</span>,size&gt; x; <span class="comment">// initializes internal vector with 10 elements</span></span><br><span class="line">    x.<span class="built_in">print</span>(); <span class="comment">// OK</span></span><br><span class="line">    size += <span class="number">100</span>; <span class="comment">// OOPS: modifies SZ in Arr&lt;&gt;</span></span><br><span class="line">    x.<span class="built_in">print</span>(); <span class="comment">// run-time ERROR: invalid memory access: loops over 120 elements</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中尝试将Arr的元素实例化为引用类型会导致<code>std::vector&lt;&gt;</code>中很深层次的错误，因为其元素类型不能被实例化为引用类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arr&lt;<span class="type">int</span>&amp;,size&gt; y; <span class="comment">// compile-time ERROR deep in the code of class</span></span><br><span class="line">std::vector&lt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>可能更糟糕的是将引用用于size这一类参数导致的运行时错误：可能在容器不知情的情况下，自身的size却发生了变化（比如size值变得无效）。如下这样使用size的操作就很可能会导致未定义的行为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = <span class="number">10</span>;</span><br><span class="line">... </span><br><span class="line">Arr&lt;<span class="type">int</span>,size&gt; x; <span class="comment">// initializes internal vector with 10 elements</span></span><br><span class="line">size += <span class="number">100</span>; <span class="comment">// OOPS: modifies SZ in Arr&lt;&gt;</span></span><br><span class="line">x.<span class="built_in">print</span>(); <span class="comment">// run-time ERROR: invalid memory access: loops over 120 elements</span></span><br></pre></td></tr></table></figure></p>
<p>注意这里并不能通过将<code>SZ</code>声明为<code>int const &amp;</code>来修正这一错误，因为size本身依然是可变的。看上去这一类问题根本就不会发生。但是在更复杂的情况下，确实会遇到此类问题。比如在C++17中，非类型模板参数可以通过推断得到：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">decltype</span>(<span class="keyword">auto</span>) SZ&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Arr</span>;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>decltype(auto)</code>很容易得到引用类型，因此在这一类上下文中应该尽量避免使用auto。基于这一原因，C++标准库在某些情况下制定了很特殊的规则和限制。比如：</p>
<ul>
<li>在模板参数被用引用类型实例化的情况下，为了依然能够正常使用赋值运算符，<code>std::pair&lt;&gt;</code>和<code>std::tuple&lt;&gt;</code>都没有使用默认的赋值运算符，而是做了单独的定义。比如：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pair</span> &#123;</span><br><span class="line">        T1 first;</span><br><span class="line">        T2 second;</span><br><span class="line">        ... <span class="comment">// default copy/move constructors are OK even with references:</span></span><br><span class="line">        <span class="built_in">pair</span>(pair <span class="type">const</span>&amp;) = <span class="keyword">default</span>;</span><br><span class="line">        <span class="built_in">pair</span>(pair&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">        ... <span class="comment">// but assignment operator have to be defined to be available with references:</span></span><br><span class="line">        pair&amp; <span class="keyword">operator</span>=(pair <span class="type">const</span>&amp; p);</span><br><span class="line">        pair&amp; <span class="keyword">operator</span>=(pair&amp;&amp; p) <span class="built_in">noexcept</span>(...);</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>由于这些副作用可能导致的复杂性，在C++17中用引用类型实例化标准库模板<code>std::optional&lt;&gt;</code>和<code>std::variant&lt;&gt;</code>的过程看上去有些古怪。为了禁止用引用类型进行实例化，一个简单的<code>static_assert</code>就够了：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">optional</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!std::is_reference&lt;T&gt;::value, <span class="string">&quot;Invalid</span></span><br><span class="line"><span class="string">    instantiation of optional&lt;T&gt; for references&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通常引用类型和其他类型有很大不同，并且受一些语言规则的限制。这会影响对调用参数的声明以及对类型萃取的定义。</p>
<h2 id="推迟计算（Defer-Evaluation）"><a href="#推迟计算（Defer-Evaluation）" class="headerlink" title="推迟计算（Defer Evaluation）"></a>推迟计算（Defer Evaluation）</h2><p>在实现模板的过程中，有时候需要面对是否需要考虑不完整类型的问题。考虑如下的类模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cont</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* elems;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>到目前为止，该class可以被用于不完整类型。这很有用，比如可以让其成员指向其自身的类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string value;</span><br><span class="line">    Cont&lt;Node&gt; next; <span class="comment">// only possible if Cont accepts incomplete types</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是，如果使用了某些类型萃取的话，可能就不能将其用于不完整类型了。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cont</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* elems;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">typename</span> std::conditional&lt;std::is_move_constructible&lt;T&gt;::value, T&amp;&amp;, T&amp; &gt;::<span class="function">type <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里通过使用<code>std::conditional</code>来决定<code>foo()</code>的返回类型是<code>T&amp;&amp;</code>还是<code>T&amp;</code>。决策标准是看模板参数T是否支持move语义。问题在于<code>std::is_move_constructible</code>要求其参数必须是完整类型。使用这种类型的<code>foo()</code>，<code>struct node</code>的声明就会报错。为了解决这一问题，需要使用一个成员模板代替现有<code>foo()</code>的定义，这样就可以将<code>std::is_move_constructible</code>的计算推迟到<code>foo()</code>的实例化阶段：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cont</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* elems;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> D = T&gt;</span><br><span class="line">    <span class="keyword">typename</span> std::conditional&lt;std::is_move_constructible&lt;D&gt;::value, T&amp;&amp;, T&amp;&gt;::type <span class="built_in">foo</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在，类型萃取依赖于模板参数D（默认值是T），并且编译器会一直等到<code>foo()</code>被以完整类型（比如Node）为参数调用时，才会对类型萃取部分进行计算（此时Node是一个完整类型，其只有在定义时才是非完整类型）。</p>
<h2 id="在写泛型库时需要考虑的事情"><a href="#在写泛型库时需要考虑的事情" class="headerlink" title="在写泛型库时需要考虑的事情"></a>在写泛型库时需要考虑的事情</h2><ul>
<li>在模板中使用转发引用来转发数值。如果数值不依赖于模板参数，就使用<code>auto &amp;&amp;</code>。</li>
<li>如果一个参数被声明为转发引用，并且传递给它一个左值的话，那么模板参数会被推断为引用类型。</li>
<li>在需要一个依赖于模板参数的对象的地址的时候，最好使用<code>std::addressof()</code>来获取地址，这样能避免因为对象被绑定到一个重载了operator &amp;的类型而导致的意外情况。</li>
<li>对于成员函数，需要确保它们不会比预定义的copy/move构造函数或者赋值运算符更能匹配某个调用。</li>
<li>如果模板参数可能是字符串常量，并且不是被按值传递的，那么请考虑使用<code>std::decay</code></li>
<li>如果你有被用于输出或者即用于输入也用于输出的、依赖于模板参数的调用参数，请为可能的、 const类型的模板参数做好准备。</li>
<li>请为将引用用于模板参数的副作用做好准备。尤其是在你需要确保返回类型不会是引用的时候。</li>
<li>请为将不完整类型用于嵌套式数据结构这一类情况做好准备。</li>
<li>为所有数组类型进行重载，而不仅仅是<code>T[SZ]</code>。</li>
</ul>
<h2 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h2><ul>
<li>可以将函数，函数指针，函数对象，仿函数和lambdas作为可调用对象（callables）传递给模板。</li>
<li>如果需要为一个class重载<code>operator()</code>，那么就将其声明为const的（除非该调用会修改它的状态）。</li>
<li>通过使用<code>std::invoke()</code>，可以实现能够处理所有类型的、可调用对象（包含成员函数）的代码。</li>
<li>使用<code>decltype(auto)</code>来完美转发返回值。</li>
<li>类型萃取是可以检查类型的属性和功能的类型函数。</li>
<li>当在模板中需要一个对象的地址时，使用<code>std::addressof()</code>。</li>
<li>在不经过表达式计算的情况下，可以通过使用<code>std::declval()</code>创建特定类型的值。</li>
<li>在泛型代码中，如果一个对象不依赖于模板参数，那么就使用<code>auto&amp;&amp;</code>来完美转发它。</li>
<li>可以通过模板来延迟表达式的计算（这样可以在class模板中支持不完整类型）。</li>
</ul>
<h1 id="深入模板"><a href="#深入模板" class="headerlink" title="深入模板"></a>深入模板</h1><p>C++ 目前支持四种基本类型的模板：类模板、函数模板、变量模板和别名模板。这些模板类型中的每一种都可以出现在命名空间范围内，也可以出现在类范围内。在类范围内，它们成为嵌套类模板、成员函数模板、静态数据成员模板和成员别名模板。注意 C++17 引入了另一个构造：演绎指南。这些在本书中不被称为模板，但选择的语法是为了让人想起函数模板。首先，一些例子说明了四种模板。它们可以出现在命名空间范围内（全局或在命名空间中），如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// a namespace scope class template </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> copyable = <span class="literal">true</span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// a namespace scope function template</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span> <span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// a namespace scope variable template (since C++14)</span></span><br><span class="line">T zero = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// a namespace scope variable template (since C++14)</span></span><br><span class="line"><span class="type">bool</span> dataCopyable = Data&lt;T&gt;::copyable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// a namespace scope alias template</span></span><br><span class="line"><span class="keyword">using</span> DataList = Data&lt;T*&gt;;</span><br></pre></td></tr></table></figure></p>
<p>请注意，在此示例中，静态数据成员<code>Data&lt;T&gt;::copyable</code>不是变量模板，即使它是通过类模板 Data 的参数化间接参数化的。但是，变量模板可以出现在类范围内（如下例所示），在这种情况下，它是一个静态数据成员模板。以下示例将四种模板显示为在其父类中定义的类成员：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Collection</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// an in-class member class template definition</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// an in-class (and therefore implicitly inline)</span></span><br><span class="line">    <span class="function">T* <span class="title">alloc</span><span class="params">()</span> </span>&#123; <span class="comment">//member function template definition</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// a member variable template (since C++14)</span></span><br><span class="line"><span class="type">static</span> T zero = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// a member alias template </span></span><br><span class="line"><span class="keyword">using</span> NodePtr = Node&lt;T&gt;*;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>请注意，在 C++17 中，变量（包括静态数据成员）和变量模板可以“内联”，这意味着它们的定义可以跨翻译单元重复。这对于变量模板来说是多余的，它总是可以在多个翻译单元中定义。然而，与成员函数不同的是，在其封闭类中定义的静态数据成员不会使其内联：关键字 inline 在所有情况下都必须指定。</p>
<p>最后，以下代码演示了如何在类外定义非别名模板的成员模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// a namespace scope class template</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">List</span>() = <span class="keyword">default</span>; <span class="comment">// because a template constructor is defined</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="comment">// another member class template,</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Handle</span>; <span class="comment">// without its definition</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="comment">// a member function template</span></span><br><span class="line">    <span class="built_in">List</span> (List&lt;U&gt; <span class="type">const</span>&amp;); <span class="comment">// (constructor)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="comment">// a member variable template (since C++14)</span></span><br><span class="line">    <span class="type">static</span> U zero;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// out-of-class member class template definition</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span>&lt;T&gt;::Handle &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// out-of-class member function template definition</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">List&lt;T&gt;::<span class="built_in">List</span> (List&lt;T2&gt; <span class="type">const</span>&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// out-of-class static data member template definition</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">U List&lt;T&gt;::zero = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>在其封闭类之外定义的成员模板可能需要多个模板参数化子句：一个用于每个封闭类模板，一个用于成员模板本身。从最外层的类模板开始列出子句。</p>
<p>另请注意，构造函数模板（一种特殊的成员函数模板）禁用默认构造函数的隐式声明（因为只有在没有声明其他构造函数时才隐式声明它）。添加默认声明<code>List() = default</code>；确保<code>List&lt;T&gt;</code>的实例是默认可构造的，具有隐式声明的构造函数的语义。</p>
<p>联合模板联合模板也是可能的（它们被认为是一种类模板）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">AllocChunk</span> &#123;</span><br><span class="line">    T object;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> bytes[<span class="built_in">sizeof</span>(T)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>函数模板可以像普通函数声明一样具有默认调用参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">report_top</span> <span class="params">(Stack&lt;T&gt; <span class="type">const</span>&amp;, <span class="type">int</span> number = <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fill</span> <span class="params">(Array&lt;T&gt;&amp;, T <span class="type">const</span>&amp; = T&#123;&#125;)</span></span>; <span class="comment">// T&#123;&#125; is zero for built-in types</span></span><br></pre></td></tr></table></figure></p>
<p>后一个声明表明默认调用参数可能依赖于模板参数。也可以定义为<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fill</span> <span class="params">(Array&lt;T&gt;&amp;, T <span class="type">const</span>&amp; = T())</span></span>; <span class="comment">// T() is zero for built-in types</span></span><br></pre></td></tr></table></figure></p>
<p>调用<code>fill()</code>函数时，如果提供了第二个函数调用参数，则不会实例化默认参数。这样可以确保如果无法为特定 T 实例化默认调用参数，则不会发出错误。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Value</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">// no default constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span> <span class="params">(Array&lt;Value&gt;&amp; array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Value <span class="title">zero</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">fill</span>(array, zero); <span class="comment">// OK: default constructor not used</span></span><br><span class="line">    <span class="built_in">fill</span>(array); <span class="comment">// ERROR: undefined default constructor for Value is used</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="类模板的非模板成员"><a href="#类模板的非模板成员" class="headerlink" title="类模板的非模板成员"></a>类模板的非模板成员</h2><p>除了在类中声明的四种基本模板之外，您还可以通过作为类模板的一部分来参数化普通类成员。它们有时（错误地）也称为成员模板。它们的参数完全由它们所属的模板决定。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> I&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CupBoard</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Shelf</span>; <span class="comment">// ordinary class in class template</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">()</span></span>; <span class="comment">// ordinary function in class template</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Wood</span> : <span class="type">unsigned</span> <span class="type">char</span>; <span class="comment">// ordinary enumeration type in class template</span></span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> totalWeight; <span class="comment">// ordinary static data member in class template</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>相应的定义只为父类模板指定了参数化子句，但没有为成员本身指定一个参数化子句，因为它不是模板（即，没有参数化子句与出现在最后一个<code>::</code>之后的名称相关联）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> I&gt; <span class="comment">// definition of ordinary class in class template</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CupBoard</span>&lt;I&gt;::Shelf &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> I&gt; <span class="comment">// definition of ordinary function in class template</span></span><br><span class="line"><span class="type">void</span> CupBoard&lt;I&gt;::<span class="built_in">open</span>()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> I&gt; <span class="comment">// definition of ordinary enumeration type class in class template</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CupBoard</span>&lt;I&gt;::Wood &#123;</span><br><span class="line">    Maple, Cherry, Oak</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> I&gt; <span class="comment">// definition of ordinary static member in class template</span></span><br><span class="line"><span class="type">double</span> CupBoard&lt;I&gt;::totalWeight = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure></p>
<p>从C++17开始，静态的<code>totalWeight</code>成员可以在模板类内初始化<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> I&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CupBoard</span> &#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">double</span> totalWeight = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>尽管此类参数化定义通常称为模板，但该术语并不完全适用于它们。偶尔为这些实体提出的术语是<code>temploid</code>。自 C++17 以来，C++ 标准确实定义了模板化实体的概念，它包括模板和模板以及递归地在模板化实体中定义或创建的任何实体。到目前为止，模板实体和模板实体都没有获得太大的吸引力，但它们可能是将来更准确地传达 C++ 模板的有用术语。</p>
<h3 id="虚拟成员函数"><a href="#虚拟成员函数" class="headerlink" title="虚拟成员函数"></a>虚拟成员函数</h3><p>成员函数模板不能声明为虚拟的。施加此约束是因为虚函数调用机制的通常实现使用一个固定大小的表，每个虚函数有一个条目。然而，成员函数模板的实例化数量在整个程序被翻译之前是不固定的。因此，支持虚拟成员函数模板需要在 C++ 编译器和链接器中支持一种全新的机制。</p>
<p>相反，类模板的普通成员可以是虚拟的，因为它们的数量在类被实例化时是固定的：</p>
<h3 id="模板外联"><a href="#模板外联" class="headerlink" title="模板外联"></a>模板外联</h3><p>每个模板都必须有一个名称，并且该名称在其范围内必须是唯一的，除了函数模板可以重载。特别注意，与类类型不同，类模板不能与不同类型的实体共享名称：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> C;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>; <span class="comment">// OK: class names and nonclass names are in a different “space”</span></span><br><span class="line"><span class="type">int</span> X;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>; <span class="comment">// ERROR: conflict with variable X</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span>; <span class="comment">// ERROR: conflict with struct S</span></span><br></pre></td></tr></table></figure></p>
<p>模板名称有链接，但不能有 C 链接。非标准链接可能具有依赖于实现的含义（但是，我们不知道支持模板的非标准名称链接的实现）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C++&quot;</span> <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">normal</span><span class="params">()</span></span>; <span class="comment">//this is the default: the linkage specification could be left out</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">invalid</span><span class="params">()</span></span>; <span class="comment">//ERROR: templates cannot have C linkage</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;Java&quot;</span> <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">javaLink</span><span class="params">()</span></span>; <span class="comment">//non standard, but maybe some compiler will someday</span></span><br><span class="line"><span class="comment">// support linkage compatible with Java generics</span></span><br></pre></td></tr></table></figure></p>
<p>模板通常具有外部链接。唯一的例外是具有静态说明符的命名空间范围函数模板、作为未命名命名空间的直接或间接成员（具有内部链接）的模板以及未命名类的成员模板（没有链接）。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// refers to the same entity as a declaration of the same name (and scope) in another file</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">external</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// unrelated to a template with the same name in another file</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">internal</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// redeclaration of the previous declaration</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">internal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="comment">// also unrelated to a template with the same name</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">otherInternal</span><span class="params">()</span></span>; <span class="comment">// in another file, even one that similarly appears</span></span><br><span class="line">&#125; <span class="comment">//in an unnamed namespace</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="comment">// redeclaration of the previous template declaration</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">otherInternal</span><span class="params">()</span></span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T)</span> </span>&#123;&#125; <span class="comment">//no linkage: cannot be redeclared</span></span><br><span class="line">&#125; x;</span><br></pre></td></tr></table></figure></p>
<p>请注意，由于后一个成员模板没有链接，因此必须在未命名的类中定义它，因为无法在类之外提供定义。</p>
<p>目前模板不能在函数作用域或局部类作用域中声明，但是具有包含成员函数模板的相关闭包类型的通用 lambdas可以出现在局部作用域中，这实际上意味着一种本地成员函数模板。</p>
<p>模板实例的链接就是模板的链接。例如，从上面声明的模板 internal 实例化的函数<code>internal&lt;void&gt;()</code>将具有内部链接。这在变量模板的情况下会产生一个有趣的结果。实际上，请考虑以下示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T zero = T&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>zero</code>的所有实例都有外部链接，甚至像<code>zero&lt;int const&gt;</code>这样的东西。考虑到<code>int const zero_int = int&#123;&#125;;</code>，这可能是违反直觉的，但也具有内部链接，因为它是用 const 类型声明的。同样，模板的所有实例化都有外部链接，尽管所有这些实例也具有 int const 类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">int</span> <span class="type">const</span> max_volume = <span class="number">11</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="主要模板"><a href="#主要模板" class="headerlink" title="主要模板"></a>主要模板</h3><p>模板的正常声明声明了主模板。此类模板声明的声明无需在模板名称后的尖括号中添加模板参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Box</span>; <span class="comment">// OK: primary template</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt;; <span class="comment">// ERROR: does not specialize</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">translate</span><span class="params">(T)</span></span>; <span class="comment">// OK: primary template</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="built_in">translate</span>&lt;T&gt;(T); <span class="comment">// ERROR: not allowed for functions</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">constexpr</span> T zero = T&#123;&#125;; <span class="comment">// OK: primary template</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">constexpr</span> T zero&lt;T&gt; = T&#123;&#125;; <span class="comment">// ERROR: does not specialize</span></span><br></pre></td></tr></table></figure></p>
<p>声明类或变量模板的部分特化时会出现非主模板。函数模板必须始终是主模板。</p>
<h2 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h2><p>有三个基本的模板参数</p>
<ol>
<li>类型参数</li>
<li>非类型参数</li>
<li>模板模板参数</li>
</ol>
<p>模板参数在临时声明的介绍性参数化子句中声明，这些声明不需要命名：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br></pre></td></tr></table></figure></p>
<p>当然，如果稍后在模板中引用参数，则需要参数名。还请注意，模板参数名称可以在后续参数声明中引用（但不能在此之前）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T Root, <span class="keyword">template</span>&lt;T&gt; <span class="keyword">class</span> <span class="title class_">Buf</span>&gt; </span><br><span class="line"><span class="comment">//the first parameter is used</span></span><br><span class="line"><span class="comment">//in the declaration of the second one and</span></span><br><span class="line"><span class="comment">// in the declaration of the third one</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Structure</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h3><p>类型参数与关键字typename或关键字class一起引入：两者完全等效。关键字后面必须跟一个简单标识符，该标识符后面必须跟一个逗号以表示下一个参数声明的开始，一个收尾角括号（&gt;）以表示参数化子句的结束，或者一个等号（=）以表示默认模板参数的开始。在模板声明中，类型参数的作用很像类型别名。例如，当T是模板参数时，即使T被类类型替换，也不可能使用格式类T的详细名称：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Allocator&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Allocator</span>* allocptr; <span class="comment">// ERROR: use “Allocator* allocptr”</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Allocator</span>; <span class="comment">// ERROR: use “friend Allocator”</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="非类型参数"><a href="#非类型参数" class="headerlink" title="非类型参数"></a>非类型参数</h3><p>非类型模板参数代表可在编译或链接时确定的常量值。此类参数的类型（换句话说，它所代表的值的类型）必须是以下类型之一：</p>
<ul>
<li>整数类型或枚举类型</li>
<li>指针类型</li>
<li>指向成员类型的指针</li>
<li>左值引用类型（对象引用和函数引用均可接受）</li>
<li><code>std::nullptr_t</code></li>
<li>包含auto或decltype（自动）的类型</li>
</ul>
<p>目前排除了所有其他类型（尽管将来可能会添加浮点类型）。也许令人惊讶的是，在某些情况下，非类型模板参数的声明也可以以关键字typename或者class开始：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="comment">//a type parameter</span></span><br><span class="line"><span class="keyword">typename</span> T::Allocator* Allocator&gt; <span class="comment">// a nontype parameter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">X</span>*&gt; <span class="comment">// a nontype parameter of pointer type</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span>;</span><br></pre></td></tr></table></figure></p>
<p>这两种情况很容易区分，因为第一种情况后面跟着一个简单的标识符，然后是一组小标记中的一个（“=”表示默认参数，“，”表示后面跟着另一个模板参数，或是结束&gt;表示模板参数列表）。</p>
<p>可以指定函数和数组类型，但它们会隐式地调整为它们所退化到的指针类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> buf[<span class="number">5</span>]&gt; <span class="keyword">class</span> <span class="title class_">Lexer</span>; <span class="comment">// buf is really an int*</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span>* buf&gt; <span class="keyword">class</span> <span class="title class_">Lexer</span>; <span class="comment">// OK: this is a redeclaration</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span>&gt; <span class="keyword">struct</span> FuncWrap</span>; <span class="comment">// fun really has pointer to function type</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="built_in">int</span> (*)()&gt; <span class="keyword">struct</span> <span class="title class_">FuncWrap</span>; <span class="comment">// OK: this is a redeclaration</span></span><br></pre></td></tr></table></figure></p>
<p>非类型模板参数的声明非常类似于变量，但它们不能具有静态、可变等非类型说明符。它们可以有常量和volatile限定符，但如果这样的限定符出现在参数类型的最外层，它将被忽略：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> <span class="type">const</span> length&gt; <span class="keyword">class</span> <span class="title class_">Buffer</span>; <span class="comment">// const is useless here</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> length&gt; <span class="keyword">class</span> <span class="title class_">Buffer</span>; <span class="comment">// same as previous declaration</span></span><br></pre></td></tr></table></figure><br>最后，在表达式中使用非引用非类型参数时，它们始终是prvalues。他们的地址无法获取，也无法分配给。另一方面，左值引用类型的非类型参数可用于表示左值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span>&amp; Counter&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LocalIncrement</span> &#123;</span><br><span class="line">    <span class="built_in">LocalIncrement</span>() &#123; Counter = Counter + <span class="number">1</span>; &#125; <span class="comment">//OK: reference to an integer</span></span><br><span class="line">    ~<span class="built_in">LocalIncrement</span>() &#123; Counter = Counter - <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="模板模板参数"><a href="#模板模板参数" class="headerlink" title="模板模板参数"></a>模板模板参数</h3><p>模板模板参数是类模板或别名模板的占位符。它们的声明非常类似于类模板，但不能使用关键字struct和union：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt; <span class="keyword">class</span> <span class="title class_">C</span>&gt; <span class="comment">// OK</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(C&lt;<span class="type">int</span>&gt;* p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt; <span class="keyword">struct</span> <span class="title class_">C</span>&gt; <span class="comment">// ERROR: struct not valid here</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(C&lt;<span class="type">int</span>&gt;* p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt; <span class="keyword">union</span> <span class="title class_">C</span>&gt; <span class="comment">// ERROR: union not valid here</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(C&lt;<span class="type">int</span>&gt;* p)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>C++17允许使用typename而不是class：这一变化的动机是，模板参数不仅可以由类模板替换，还可以由别名模板（实例化为任意类型）替换。因此，在C++17中，我们上面的示例可以写成<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt; <span class="keyword">typename</span> C&gt; <span class="comment">// OK since C++17</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(C&lt;<span class="type">int</span>&gt;* p)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>在其声明范围内，模板参数的使用与其他类或别名模板一样。</p>
<p>模板参数的参数可以具有默认模板参数。如果在使用模板参数时未指定相应的参数，则这些默认参数适用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> A = MyAllocator&gt; <span class="keyword">class</span> Container&gt;</span><br><span class="line"><span class="keyword">class</span> Adaptation &#123;</span><br><span class="line">    Container&lt;<span class="type">int</span>&gt; storage; <span class="comment">// implicitly equivalent to Container&lt;int,MyAllocator&gt;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>T和A是模板参数容器的模板参数的名称。这些名称只能在声明该模板参数的其他参数时使用。以下模板说明了此概念：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T*&gt; <span class="keyword">class</span> <span class="title class_">Buf</span>&gt; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lexer</span> &#123;</span><br><span class="line">    <span class="type">static</span> T* storage; <span class="comment">// ERROR: a template template parameter cannot be used here</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是，通常在声明其他模板参数时不需要模板参数的模板参数名称，因此通常不命名。例如，我们早期的适应模板可以声明如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span> = MyAllocator&gt; <span class="keyword">class</span> Container&gt;</span><br><span class="line"><span class="keyword">class</span> Adaptation &#123;</span><br><span class="line">    Container&lt;<span class="type">int</span>&gt; storage; <span class="comment">// implicitly equivalent to Container&lt;int,MyAllocator&gt;</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="模板参数包"><a href="#模板参数包" class="headerlink" title="模板参数包"></a>模板参数包</h3><p>自C++11以来，任何类型的模板参数都可以通过在模板参数名称之前引入省略号（…）转换为模板参数包，或者，如果模板参数未命名，则模板参数名称将出现在以下位置：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt; <span class="comment">// declares a template parameter pack named Types</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuple</span>;</span><br></pre></td></tr></table></figure></p>
<p>模板参数包的行为与其基础模板参数类似，但有一个关键区别：虽然普通模板参数只匹配一个模板参数，但模板参数包可以匹配任意数量的模板参数。这意味着上面声明的元组类模板接受任意数量（可能不同）的类型作为模板参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> IntTuple = Tuple&lt;<span class="type">int</span>&gt;; <span class="comment">// OK: one template argument</span></span><br><span class="line"><span class="keyword">using</span> IntCharTuple = Tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt;; <span class="comment">// OK: two template arguments</span></span><br><span class="line"><span class="keyword">using</span> IntTriple = Tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;; <span class="comment">// OK: three template arguments</span></span><br><span class="line"><span class="keyword">using</span> EmptyTuple = Tuple&lt;&gt;; <span class="comment">// OK: zero template arguments</span></span><br></pre></td></tr></table></figure></p>
<p>类似地，非类型和模板参数的模板参数包可以分别接受任意数量的非类型或模板参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span>... Dimensions&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiArray</span>; <span class="comment">// OK: declares a nontype template parameter pack</span></span><br><span class="line"><span class="keyword">using</span> TransformMatrix = MultiArray&lt;<span class="type">double</span>, <span class="number">3</span>, <span class="number">3</span>&gt;; <span class="comment">// OK: 3x3 matrix</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt;... Containers&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testContainers</span><span class="params">()</span></span>; <span class="comment">// OK: declares a template template parameter pack</span></span><br></pre></td></tr></table></figure></p>
<p>MultiArray示例要求所有非类型模板参数都是同一类型的无符号参数。C++17引入了推导非类型模板参数的可能性，这允许我们在某种程度上绕过该限制</p>
<p>主类模板、变量模板和别名模板最多可以有一个模板参数包，如果存在，模板参数包必须是最后一个模板参数。函数模板有一个较弱的限制：允许使用多个模板参数包，只要模板参数包后面的每个模板参数都有一个默认值（请参见下一节）或可以推断：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types, <span class="keyword">typename</span> Last&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LastType</span>; <span class="comment">// ERROR: template parameter pack is not the last template parameter</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TestTypes, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">runTests</span><span class="params">(T value)</span></span>; <span class="comment">// OK: template parameter pack is followed by a deducible template parameter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span>...&gt; <span class="keyword">struct</span> <span class="title class_">Tensor</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">unsigned</span>... Dims1, <span class="type">unsigned</span>... Dims2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">compose</span><span class="params">(Tensor&lt;Dims<span class="number">1.</span>..&gt;, Tensor&lt;Dims<span class="number">2.</span>..&gt;)</span></span>;</span><br><span class="line"><span class="comment">// OK: the tensor dimensions can be deduced</span></span><br></pre></td></tr></table></figure><br>最后一个例子是一个带有推导返回类型的函数声明。</p>
<p>类和变量模板的部分特化声明可以有多个参数包，这与它们的主要模板对应物不同。这是因为部分专业化是通过与用于函数模板的推导过程几乎相同的推导过程来选择的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt; Typelist;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Y&gt; <span class="keyword">struct</span> <span class="title class_">Zip</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Xs, <span class="keyword">typename</span>... Ys&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Zip</span>&lt;Typelist&lt;Xs...&gt;, Typelist&lt;Ys...&gt;&gt;;</span><br><span class="line"><span class="comment">// OK: partial specialization uses deduction to determine</span></span><br><span class="line"><span class="comment">// theXs and Ys substitutions</span></span><br></pre></td></tr></table></figure><br>也许并不奇怪，类型参数包不能在其自己的参���子句中扩展。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts, Ts... vals&gt; <span class="keyword">struct</span> <span class="title class_">StaticValues</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// ERROR: Ts cannot be expanded in its own parameter list</span></span><br></pre></td></tr></table></figure></p>
<p>但是，嵌套模板可以创建类似的有效情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt; <span class="keyword">struct</span> <span class="title class_">ArgList</span> &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;Ts... vals&gt; <span class="keyword">struct</span> <span class="title class_">Vals</span> &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">ArgList&lt;<span class="type">int</span>, <span class="type">char</span>, <span class="type">char</span>&gt;::Vals&lt;<span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>&gt; tada;</span><br></pre></td></tr></table></figure></p>
<h3 id="默认模板参数-1"><a href="#默认模板参数-1" class="headerlink" title="默认模板参数"></a>默认模板参数</h3><p>任何不是模板形参包的模板形参都可以配备默认实参，尽管它必须与相应的实参相匹配（例如，类型形参不能有非类型默认实参）。默认参数不能依赖于它自己的参数，因为参数的名称在默认参数之后才在范围内。但是，它可能取决于以前的参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Allocator = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> List;</span><br></pre></td></tr></table></figure></p>
<p>仅当还为后续参数提供了默认参数时，类模板、变量模板或别名模板的模板参数才能具有默认模板参数。（默认函数调用参数存在类似的约束。）后续的默认值通常在同一个模板声明中提供，但它们也可以在该模板的先前声明中声明。下面的例子清楚地说明了这一点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4 = <span class="type">char</span>, <span class="keyword">typename</span> T5 = <span class="type">char</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Quintuple; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3 = <span class="type">char</span>, <span class="keyword">typename</span> T4, <span class="keyword">typename</span> T5&gt;</span><br><span class="line"><span class="keyword">class</span> Quintuple; <span class="comment">// OK: T4 and T5 already have defaults</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1 = <span class="type">char</span>, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4, <span class="keyword">typename</span> T5&gt;</span><br><span class="line"><span class="keyword">class</span> Quintuple; <span class="comment">// ERROR: T1 cannot have a default argument because T2 doesn’t have a default</span></span><br></pre></td></tr></table></figure></p>
<p>函数模板的模板形参的默认模板实参不需要后续模板形参具有默认模板实参：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R </span>= <span class="type">void</span>, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">R* <span class="title">addressof</span><span class="params">(T&amp; value)</span></span>; <span class="comment">// OK: if not explicitly specified, R will be void</span></span><br></pre></td></tr></table></figure></p>
<p>默认模板参数不能重复：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Value; <span class="comment">// ERROR: repeated default argument</span></span><br></pre></td></tr></table></figure></p>
<p>许多地方不允许默认模板参数：</p>
<ul>
<li>部分特化：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>;...</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> C&lt;T*&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数包：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts = <span class="type">int</span>&gt; <span class="keyword">struct</span> X; <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure>
<ul>
<li>类模板成员的类外定义：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt; T X&lt;T&gt;::<span class="built_in">f</span>() &#123; <span class="comment">// ERROR</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>友类模板声明：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="type">void</span>&gt; <span class="keyword">friend</span> <span class="keyword">struct</span> F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>友元函数模板声明，除非它是一个定义并且在翻译单元的其他任何地方都没有出现它的声明：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> </span>= <span class="type">void</span>&gt; <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// ERROR: not a definition</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> </span>= <span class="type">void</span>&gt; <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="comment">//OK so far </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>; <span class="comment">// ERROR: g() was given a default template argument</span></span><br><span class="line">                            <span class="comment">// when defined; no other declaration may exist here</span></span><br></pre></td></tr></table></figure>
<h2 id="模板参数-1"><a href="#模板参数-1" class="headerlink" title="模板参数"></a>模板参数</h2><p>实例化模板时，模板参数由模板参数替换。可以使用几种不同的机制来确定参数：</p>
<ul>
<li>显式模板参数：模板名称后面可以跟用尖括号括起来的显式模板参数。生成的名称称为模板 ID。</li>
<li>注入的类名：在具有模板参数 P1、P2、……的类模板 X 的范围内，该模板的名称 (X) 可以等同于模板ID <code>X&lt;P1, P2, ...&gt;</code>。</li>
<li>默认模板参数：如果默认模板参数可用，则可以从模板实例中省略显式模板参数。但是，对于类或别名模板，即使所有模板参数都有默认值，也必须提供（可能为空的）尖括号。</li>
<li>参数推导：未显式指定的函数模板参数可以从调用中的函数调用参数的类型推导出来。在其他一些情况下也进行了演绎。如果可以推导出所有模板参数，则不需要在函数模板名称后指定尖括号。C++17 还引入了从变量声明或函数符号类型转换的初始化程序推导出类模板参数的能力。</li>
</ul>
<h3 id="函数模板参数"><a href="#函数模板参数" class="headerlink" title="函数模板参数"></a>函数模板参数</h3><p>函数模板的模板参数可以显式指定，从模板的使用方式推导出来，或者作为默认模板参数提供。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ::<span class="built_in">max</span>&lt;<span class="type">double</span>&gt;(<span class="number">1.0</span>, <span class="number">-3.0</span>); <span class="comment">// explicitly specify template argument</span></span><br><span class="line">    ::<span class="built_in">max</span>(<span class="number">1.0</span>, <span class="number">-3.0</span>); <span class="comment">// template argument is implicitly deduced to be double</span></span><br><span class="line">    ::<span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(<span class="number">1.0</span>, <span class="number">3.0</span>); <span class="comment">// the explicit &lt;int&gt; inhibits thededuction;</span></span><br><span class="line">    <span class="comment">// hence the result has type int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>某些模板参数永远无法推导出来，因为它们对应的模板参数没有出现在函数参数类型中或出于某些其他原因。相应的参数通常放置在模板参数列表的开头，因此可以显式指定它们，同时允许推导其他参数。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DstT, <span class="keyword">typename</span> SrcT&gt;</span></span><br><span class="line"><span class="function">DstT <span class="title">implicit_cast</span> <span class="params">(SrcT <span class="type">const</span>&amp; x)</span> <span class="comment">// SrcT can be deduced, but DstT cannot</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> value = <span class="built_in">implicit_cast</span>&lt;<span class="type">double</span>&gt;(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们在此示例中颠倒了模板参数的顺序（换句话说，如果我们编写了<code>template&lt;typename SrcT, typename DstT&gt;</code>），则对<code>implicit_cast</code>的调用将必须显式指定两个模板参数。此外，此类参数不能有用地放置在模板参数包之后或出现在部分特化中，因为无法显式指定或推断它们。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... Ts, <span class="type">int</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">double</span> (&amp;)[N<span class="number">+1</span>], Ts ... ps)</span></span>; <span class="comment">// useless declaration because N</span></span><br><span class="line">                            <span class="comment">// cannot be specified or deduced</span></span><br></pre></td></tr></table></figure></p>
<p>因为函数模板可以重载，显式提供函数模板的所有参数可能不足以标识单个函数：在某些情况下，它标识一组函数。以下示例说明了此观察的结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">apply</span> <span class="params">(Func funcPtr, T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">funcPtr</span>(x);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">single</span><span class="params">(T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">multi</span><span class="params">(T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">multi</span><span class="params">(T*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">apply</span>(&amp;single&lt;<span class="type">int</span>&gt;, <span class="number">3</span>); <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">apply</span>(&amp;multi&lt;<span class="type">int</span>&gt;, <span class="number">7</span>); <span class="comment">// ERROR: no single multi&lt;int&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在此示例中，第一次调用<code>apply()</code>有效，因为表达式<code>&amp;single&lt;int&gt;</code>的类型是明确的。结果，很容易推导出<code>Func</code>参数的模板参数值。然而，在第二次调用中，<code>&amp;multi&lt;int&gt;</code>可能是两种不同类型之一，因此在这种情况下无法推断出<code>Func</code>。</p>
<p>此外，在函数模板中替换模板参数可能会导致尝试构造无效的 C++ 类型或表达式。考虑以下重载函数模板（RT1 和 RT2 是未指定的类型）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; RT1 <span class="title">test</span><span class="params">(<span class="keyword">typename</span> T::X <span class="type">const</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; RT2 <span class="title">test</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>表达式<code>test&lt;int&gt;</code>对于两个函数模板中的第一个没有意义，因为 int 类型没有成员类型 X。但是，第二个模板没有这样的问题。因此，表达式<code>&amp;test&lt;int&gt;</code>标识单个函数的地址。将 int 替换为第一个模板失败的事实并不会使表达式无效。</p>
<h3 id="非类型参数-1"><a href="#非类型参数-1" class="headerlink" title="非类型参数"></a>非类型参数</h3><p>非类型模板参数是替代非类型参数的值。这样的值必须是以下事物之一：</p>
<ul>
<li>另一个具有正确类型的非类型模板参数。</li>
<li>整数（或枚举）类型的编译时常量值。仅当相应参数具有与值的类型匹配的类型或值可以隐式转换为的类型而不缩小时，这才是可接受的。例如，可以为 int 参数提供 char 值，但赋值 500 对 8 位 char 参数无效。</li>
<li>以内置一元&amp;（“地址”）运算符开头的外部变量或函数的名称。对于函数和数组变量，&amp; 可以省略。这样的模板参数匹配指针类型的非类型参数。C++17 放宽了这个要求，允许任何产生指向函数或变量的指针的常量表达式。</li>
<li>前一种类型的参数但没有前导&amp; 运算符是引用类型的非类型参数的有效参数。在这里，C++17 也放宽了约束，允许函数或变量使用任何常量表达式泛左值。</li>
<li>指向成员常量的指针；换句话说，<code>&amp;C::m</code> 形式的表达式，其中 C 是类类型，m 是非静态成员（数据或函数）。这仅匹配指向成员类型的非类型参数。再一次，在 C++17 中，实际的句法形式不再受到限制：允许任何对匹配的指向成员常量的指针求值的常量表达式。</li>
<li>空指针常量是指针或成员指针类型的非类型参数的有效参数。</li>
</ul>
<p>对于整型的非类型参数——可能是最常见的非类型参数——考虑到参数类型的隐式转换。随着 C++11 中 constexpr 转换函数的引入，这意味着转换前的参数可以具有类类型。</p>
<p>在 C++17 之前，当将参数与作为指针或引用的参数匹配时，不考虑用户定义的转换（一个参数的构造函数和转换运算符）和派生到基的转换，即使在其他情况下也是如此它们将是有效的隐式转换。使参数更 const 和/或更易变的隐式转换是可以的。以下是非类型模板参数的一些有效示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T nontypeParam&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>;</span><br><span class="line">C&lt;<span class="type">int</span>, <span class="number">33</span>&gt;* c1; <span class="comment">// integer type</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">C&lt;<span class="type">int</span>*, &amp;a&gt;* c2; <span class="comment">// address of an external variable</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">C&lt;<span class="built_in">void</span> (*)(<span class="type">int</span>), f&gt;* c3; <span class="comment">// name of a function: overload resolution selects</span></span><br><span class="line"><span class="comment">// f(int) in this case; the &amp; is implied</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">templ_func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">C&lt;<span class="built_in">void</span>(), &amp;templ_func&lt;<span class="type">double</span>&gt;&gt;* c4; <span class="comment">// function template instantiations are functions</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> b;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">C&lt;<span class="type">bool</span>&amp;, X::b&gt;* c5; <span class="comment">// static class members are acceptable variable/function names</span></span><br><span class="line">C&lt;<span class="type">int</span> X::*, &amp;X::n&gt;* c6; <span class="comment">// an example of a pointer-to-member constant</span></span><br><span class="line">C&lt;<span class="type">long</span>, X&#123;&#125;&gt;* c7; <span class="comment">// OK: X is first converted to int viaa constexpr conversion</span></span><br><span class="line"><span class="comment">// function and then to long via a standard integer conversion</span></span><br></pre></td></tr></table></figure></p>
<p>模板参数的一般约束是编译器或链接器必须能够在构建程序时表达它们的值。直到程序运行才知道的值（例如，局部变量的地址）与构建程序时实例化模板的概念不兼容。即便如此，有一些常量值当前无效：</p>
<ul>
<li>浮点数字</li>
<li>字符串文字（在 C++11 之前，也不允许空指针常量。）</li>
</ul>
<p>字符串文字的问题之一是两个相同的文字可以存储在两个不同的地址。表达通过常量字符串实例化的模板的另一种（但繁琐）方法涉及引入一个额外的变量来保存字符串：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">char</span> <span class="type">const</span>* str&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> <span class="type">const</span> hello[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="type">char</span> <span class="type">const</span> hello11[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> <span class="type">const</span> hello17[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    Message&lt;hello&gt; msg03; <span class="comment">// OK in all versions</span></span><br><span class="line">    Message&lt;hello11&gt; msg11; <span class="comment">// OK since C++11</span></span><br><span class="line">    Message&lt;hello17&gt; msg17; <span class="comment">// OK since C++17</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要求是声明为引用或指针的非类型模板参数可以是具有所有 C++ 版本中的外部链接、自 C++11 以来的内部链接或自 C++17 以来的任何链接的常量表达式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T nontypeParam&gt;<span class="keyword">class</span> <span class="title class_">C</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125; base;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">&#125; derived;</span><br><span class="line">C&lt;Base*, &amp;derived&gt;* err1; <span class="comment">// ERROR: derived-to-base conversions are not considered</span></span><br><span class="line">C&lt;<span class="type">int</span>&amp;, base.i&gt;* err2; <span class="comment">// ERROR: fields of variables aren’t considered to be variables</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">C&lt;<span class="type">int</span>*, &amp;a[<span class="number">0</span>]&gt;* err3; <span class="comment">// ERROR: addresses of array elements aren’t acceptable either</span></span><br></pre></td></tr></table></figure></p>
<h3 id="模板模板参数-1"><a href="#模板模板参数-1" class="headerlink" title="模板模板参数"></a>模板模板参数</h3><p>模板模板参数通常必须是类模板或别名模板，其参数与它所替代的模板模板参数的参数完全匹配。在 C++17 之前，模板模板实参的默认模板实参被忽略（但如果模板模板形参具有默认实参，则在模板的实例化过程中会考虑它们）。C++17 放宽了匹配规则，只要求模板模板参数至少与相应的模板模板参数一样专门化。这使得以下示例在 C++17 之前无效：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="comment">// declares in namespace std:</span></span><br><span class="line"><span class="comment">// template&lt;typename T, typename Allocator = allocator&lt;T&gt;&gt;</span></span><br><span class="line"><span class="comment">// class list;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Cont</span>&gt; <span class="comment">// Cont expects one parameter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rel</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Rel&lt;<span class="type">int</span>, <span class="type">double</span>, std::list&gt; rel; <span class="comment">// ERROR before C++17: std::list has more than</span></span><br><span class="line"><span class="comment">// one template parameter</span></span><br></pre></td></tr></table></figure></p>
<p>这个例子的问题是标准库的<code>std::list</code>模板有多个参数。第二个参数（描述分配器）具有默认值，但在 C++17 之前，将<code>std::list</code>与 Container 参数匹配时不考虑该值。</p>
<p>可变参数模板模板参数是上述 C++17 之前的“精确匹配”规则的一个例外，并提供了对此限制的解决方案：它们可以对模板模板参数进行更一般的匹配。模板模板参数包可以匹配模板模板参数中的零个或多个相同类型的模板参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2,</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... &gt; <span class="keyword">class</span> <span class="title class_">Cont</span>&gt; <span class="comment">// Cont expects any number of</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rel</span> &#123; <span class="comment">// type parameters</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">Rel&lt;<span class="type">int</span>, <span class="type">double</span>, std::list&gt; rel; <span class="comment">// OK: std::list has two template parameters</span></span><br><span class="line"><span class="comment">// but can be used with one argument</span></span><br></pre></td></tr></table></figure></p>
<h1 id="模板中的名称"><a href="#模板中的名称" class="headerlink" title="模板中的名称"></a>模板中的名称</h1><p>名称是大多数编程语言中的基本概念。它们是程序员可以引用先前构造的实体的方法。当 C++ 编译器遇到名称时，它必须“查找”以识别所引用的实体。从实现者的角度来看，C++ 在这方面是一门硬语言。考虑 C++ 语句 x*y;。如果 x 和 y 是变量的名称，则该语句是乘法，但如果 x 是类型的名称，则该语句将 y 声明为指向 x 类型的实体的指针。</p>
<p>这个小例子表明 C++（和 C 一样）是一种上下文相关的语言：一个结构在不知道其更广泛的上下文的情况下总是无法被理解。这与模板有什么关系？好吧，模板是必须处理多个更广泛上下文的构造：</p>
<ol>
<li>模板出现的上下文，</li>
<li>模板实例化的上下文，</li>
<li>与模板参数相关联的上下文</li>
</ol>
<p>因此，在 C++ 中必须非常小心地处理“名称”也就不足为奇了。</p>
<h2 id="名称分类"><a href="#名称分类" class="headerlink" title="名称分类"></a>名称分类</h2><p>C++ 以多种方式对名称进行分类——事实上，方式多种多样。幸运的是，您可以通过熟悉两个主要的命名概念来深入了解大多数 C++ 模板问题：</p>
<ol>
<li>如果名称所属的范围使用范围解析运算符 (::) 或成员访问运算符 (. 或 -&gt;) 明确表示，则名称是限定名称。例如，<code>this-&gt;count</code>是一个限定名，但<code>count</code>不是（即使普通的<code>count</code>实际上可能指的是一个类成员）。</li>
<li>如果名称以某种方式依赖于模板参数，则该名称是从属名称。例如，<code>std::vector&lt;T&gt;::iterator</code>通常是一个从属名称，如果T 是模板参数，但如果 T 是已知类型别名，则它是非依赖名称。</li>
</ol>
<h2 id="查找名称"><a href="#查找名称" class="headerlink" title="查找名称"></a>查找名称</h2><p>在限定构造所暗示的范围内查找限定名称。如果该范围是一个类，则还可以搜索基类。但是，在查找限定名称时不考虑封闭范围。以下说明了这一基本原则：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(D* pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pd-&gt;i = <span class="number">3</span>; <span class="comment">// finds B::i</span></span><br><span class="line">    D::x = <span class="number">2</span>; <span class="comment">// ERROR: does not find ::x in the enclosing scope</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相比之下，非限定名称通常在连续更封闭的范围内查找（尽管在成员函数定义中，类及其基类的范围在任何其他封闭范围之前搜索）。这称为普通查找。这是一个基本示例，显示了普通查找的主要思想：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> count; <span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup_example</span><span class="params">(<span class="type">int</span> count)</span> <span class="comment">// #2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// #3</span></span><br><span class="line">        <span class="built_in">lookup_example</span>(count); <span class="comment">// unqualified count refers to #3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count + ::count; <span class="comment">// the first (unqualified) count     refers to #2;</span></span><br><span class="line">&#125; <span class="comment">//the second (qualified) countrefers to #1</span></span><br></pre></td></tr></table></figure></p>
<p>对非限定名称的查找最近的一个转折是它们有时可能会进行参数相关的查找 (ADL)。在继续详细介绍 ADL 之前，让我们激发该机制：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在假设我们需要将此模板应用到另一个命名空间中定义的类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> BigMath &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigNumber</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (BigNumber <span class="type">const</span>&amp;, BigNumber <span class="type">const</span>&amp;);</span><br><span class="line">...</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">using</span> BigMath::BigNumber;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span> <span class="params">(BigNumber <span class="type">const</span>&amp; a, BigNumber <span class="type">const</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BigNumber x = ::<span class="built_in">max</span>(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的问题是<code>max()</code>模板不知道<code>BigMath</code>命名空间，但普通查找不会找到适用于<code>BigNumber</code>类型值的运算符<code>&lt;</code>。如果没有一些特殊的规则，这会大大降低模板在存在 C++ 命名空间的情况下的适用性。ADL 是对这些“特殊规则”的 C++ 答案。</p>
<h3 id="参数相关查找ADL"><a href="#参数相关查找ADL" class="headerlink" title="参数相关查找ADL"></a>参数相关查找ADL</h3><p>ADL 主要适用于看起来像是在函数调用或运算符调用中命名非成员函数的非限定名称。如果普通查找发现以下情况，ADL 不会发生</p>
<ul>
<li>成员函数的名称，</li>
<li>变量的名称，</li>
<li>类型的名称，或</li>
<li>块作用域函数声明的名称。</li>
</ul>
<p>如果要调用的函数的名称用括号括起来，ADL 也会被禁止。<br>否则，如果名称后跟括在括号中的参数表达式列表，ADL 会继续在名称空间和与调用参数类型“关联”的类中查找名称。这些关联的命名空间和相关类的精确定义在后面给出，但直观地它们可以被认为是与给定类型相当直接连接的所有命名空间和类。例如，如果类型是指向类 X 的指针，则关联的类和命名空间将包括 X 以及 X 所属的任何命名空间或类。</p>
<p>给定类型的关联命名空间和关联类集的精确定义由以下规则确定：</p>
<ul>
<li>对于内置类型，这是空集。</li>
<li>对于指针和数组类型，关联命名空间和类的集合是基础类型的集合。</li>
<li>对于枚举类型，关联的命名空间是声明枚举的命名空间。</li>
<li>对于类成员，封闭类是关联类。</li>
<li>对于类类型（包括联合类型），关联类的集合是类型本身、封闭类以及任何直接和间接基类。关联命名空间的集合是声明相关类的命名空间。如果类是类模板实例，则还包括模板类型参数的类型以及声明模板模板参数的类和命名空间。</li>
<li>对于函数类型，相关命名空间和类的集合包括与所有参数类型相关的命名空间和类以及与返回类型相关的命名空间和类。</li>
<li>对于指向X 类成员的指针类型，关联的命名空间和类集包括与X 关联的那些以及与成员类型关联的那些。然后，ADL 在所有关联的命名空间中查找名称，就好像该名称已被这些命名空间中的每一个依次限定一样，除了 using 指令被忽略。以下示例说明了这一点：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> X &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T)</span></span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> N &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> X;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">E</span> &#123; e1 &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(E)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;N::f(N::E) called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;::f(int) called\n&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ::<span class="built_in">f</span>(N::e1); <span class="comment">// qualified function name: no ADL</span></span><br><span class="line">    <span class="built_in">f</span>(N::e1); <span class="comment">// ordinary lookup finds ::f() and ADL finds N::f(),</span></span><br><span class="line">&#125; <span class="comment">//the latter is preferred</span></span><br></pre></td></tr></table></figure>
<h2 id="解析模板"><a href="#解析模板" class="headerlink" title="解析模板"></a>解析模板</h2><p>大多数编程语言的编译器的两个基本活动是标记化（也称为扫描或词法分析）和解析。标记化过程将源代码作为字符序列读取，并从中生成标记序列。例如，在看到字符序列<code>int* p = 0;</code>时，“tokenizer”将为关键字int、符号/运算符 <em>、标识符 p、符号/运算符 =、整数文字 0 生成token描述，和一个符号/运算符<code>;</code>。然后，解析器将通过递归地将标记或先前找到的模式减少到更高级别的构造中来找到标记序列中的已知模式。例如，标记 0 是一个有效的表达式，后跟标识符 p 的组合`</em>` 是一个有效的声明符，而后跟“=”的声明符和表达式“0”是一个有效的 init 声明符。最后，关键字 int 是一个已知的类型名称，并且当其后跟 init-declarator *p = 0 时，您将获得 p 的初始化声明。</p>
<h3 id="非模板中的上下文敏感性"><a href="#非模板中的上下文敏感性" class="headerlink" title="非模板中的上下文敏感性"></a>非模板中的上下文敏感性</h3><p>正如您可能知道或期望的那样，标记化比解析更容易。幸运的是，解析是一个已经发展了坚实理论的学科，并且许多有用的语言使用这个理论并不难解析。然而，该理论最适用于上下文无关语言，我们已经注意到 C++ 是上下文敏感的。为了处理这个问题，C++ 编译器将符号表耦合到标记器和解析器：当解析声明时，它被输入到符号表中。当标记器找到一个标识符时，它会查找它并在找到类型时注释结果标记。</p>
<p>例如，如果 C++ 编译器看到<code>x*</code>，分词器查找<code>x</code>。如果它找到一个类型，解析器会看到<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">identifier, type, x</span><br><span class="line">symbol, *</span><br></pre></td></tr></table></figure></p>
<p>并得出声明已开始的结论。但是，如果 x 不是类型，则解析器从分词器接收<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">identifier, nontype, x</span><br><span class="line">symbol, *</span><br></pre></td></tr></table></figure></p>
<p>并且该构造只能作为乘法进行有效解析。这些原则的细节取决于特定的实施策略，但要点应该在那里。以下表达式说明了上下文敏感性的另一个示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">X</span>&lt;<span class="number">1</span>&gt; (<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>如果 X 是类模板的名称，则前面的表达式将整数 0 转换为从该模板生成的类型<code>X&lt;1&gt;</code>。如果 X 不是模板，那么前面的表达式等价于<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(X&lt;<span class="number">1</span>)&gt;<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>换句话说，X 与 1 进行比较，并且比较的结果与 0 进行比较。虽然这样的代码很少使用，但它是有效的 C++。因此，C++ 解析器将查找出现在 &lt; 之前的名称，并且仅当已知名称是模板的名称时，才将 &lt; 视为尖括号；否则，&lt; 被视为普通的小于运算符。</p>
<p>这种形式的上下文敏感性是选择尖括号来分隔模板参数列表的不幸结果。这是另一个这样的后果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> B&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Invert</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> <span class="type">const</span> result = !B;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> test = Invert&lt;(<span class="number">1</span>&gt;<span class="number">0</span>)&gt;::result; <span class="comment">// parentheses required!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果省略<code>Invert&lt;(1&gt;0)&gt;</code>中的括号，则大于号将被误认为是模板参数列表的结束。这将使代码无效，因为编译器会将其读取为等效于<code>((Invert&lt;1&gt;))0&gt;::result</code>。分词器也不能幸免尖括号符号的问题。例如，在<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;<span class="type">int</span>&gt;&gt; a;</span><br><span class="line"><span class="comment">//            ^-- no space between right angle brackets</span></span><br></pre></td></tr></table></figure></p>
<p>两个<code>&gt;</code>字符组合成一个右移标记<code>&gt;&gt;</code>，因此标记器永远不会将其视为两个单独的标记。C++ 实现必须将尽可能多的连续字符收集到一个标记中。</p>
<p>从 C++11 开始，C++ 标准专门修改了这种情况。</p>
<h1 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h1><p>模板实例化是从通用模板定义生成类型、函数和变量的过程。C++ 模板实例化的概念是基本的，但也有些复杂。这种复杂性的根本原因之一是模板生成的实体的定义不再局限于源代码中的单个位置。模板的位置、使用模板的位置以及定义模板参数的位置都对实体的含义起作用。</p>
<p>在本章中，我们将解释如何组织源代码以启用正确的模板使用。此外，我们调查了最流行的 C++ 编译器用于处理模板实例化的各种方法。尽管所有这些方法在语义上都应该是等价的，但了解编译器实例化策略的基本原理还是很有用的。在构建实际软件时，每种机制都有其一组小怪癖，相反，每一种都会影响标准 C++ 的最终规范。</p>
<h2 id="按需实例化"><a href="#按需实例化" class="headerlink" title="按需实例化"></a>按需实例化</h2><p>当 C++ 编译器遇到模板特化的使用时，它将通过用所需的参数替换模板参数来创建该特化。这是自动完成的，不需要客户端代码（或模板定义，就此而言）的指示。这种按需实例化功能将 C++ 模板与其他早期编译语言（如 Ada 或 Eiffel；其中一些语言需要显式实例化指令，而另一些使用运行时调度机制来完全避免实例化过程）中的类似设施区分开来。它有时也称为隐式或自动实例化。</p>
<p>按需实例化意味着编译器通常需要在使用时访问模板及其某些成员的完整定义（换句话说，不仅仅是声明）。考虑以下微小的源代码文件：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">C</span>; <span class="comment">// #1 declaration only</span></span><br><span class="line">C&lt;<span class="type">int</span>&gt;* p = <span class="number">0</span>; <span class="comment">// #2 fine: definition of C&lt;int&gt; not needed</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// #3 member declaration</span></span><br><span class="line">&#125;; <span class="comment">// #4 class template definition completed</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span> <span class="params">(C&lt;<span class="type">int</span>&gt;&amp; c)</span> <span class="comment">// #5 use class template declaration only</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c.<span class="built_in">f</span>(); <span class="comment">// #6 use class template definition;</span></span><br><span class="line">&#125; <span class="comment">// will need definition of</span></span><br><span class="line">C::<span class="built_in">f</span>()</span><br><span class="line"><span class="comment">// in this translation unit</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> C&lt;T&gt;::<span class="built_in">f</span>() <span class="comment">//required definition due to #6</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在源代码中的第 1 点，只有模板的声明可用，而不是定义（这样的声明有时称为前向声明）。与普通类的情况一样，我们不需要类模板的定义可见来声明对该类型的指针或引用，就像在第 #2 点所做的那样。例如，函数<code>g()</code>的参数类型不需要模板 C 的完整定义。但是，只要组件需要知道模板特化的大小或访问此类特化的成员，整个类模板定义必须是可见的。这就解释了为什么在源代码中的#6 处，必须看到类模板定义；否则，编译器无法验证该成员是否存在且可访问（不是私有的或受保护的）。此外，还需要成员函数定义，因为调用点 #6 需要存在<code>C&lt;int&gt;::f()</code>。这是另一个需要实例化前一个类模板的表达式，因为<code>C&lt;void&gt;</code>的大小是需要：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C&lt;<span class="type">void</span>&gt;* p = <span class="keyword">new</span> C&lt;<span class="type">void</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<p>在这种情况下，需要实例化，以便编译器可以确定<code>C&lt;void&gt;</code>的大小，new-expression 需要该大小来确定要分配多少存储空间。您可能会观察到，对于这个特定的模板，用 X 代替 T 的参数类型不会影响模板的大小，因为在任何情况下，<code>C&lt;X&gt;</code>都是一个空类。但是，编译器不需要通过分析模板定义来避免实例化（并且所有编译器都会在实践中执行实例化）。此外，在此示例中还需要实例化来确定<code>C&lt;void&gt;</code>是否具有可访问的默认构造函数，并确保<code>C&lt;void&gt;</code>不声明成员运算符 new 或 delete。访问类模板成员的需要并不总是非常明确可见 在源代码中。例如，C++ 重载需要对候选函数参数的类类型的可见性：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span>); <span class="comment">// a constructor that can be called with a single parameter</span></span><br><span class="line">&#125;; <span class="comment">// may be used for implicit conversions</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">candidate</span><span class="params">(C&lt;<span class="type">double</span>&gt;)</span></span>; <span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">candidate</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; &#125; <span class="comment">// #2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">candidate</span>(<span class="number">42</span>); <span class="comment">// both previous function declarations can be called</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用<code>Candidate(42)</code>将解析为点 #2 处的重载声明。但是，也可以实例化点 #1 处的声明以检查它是否是调用的可行候选者（在这种情况下，因为单参数构造函数可以将 42 隐式转换为<code>C&lt;double&gt;</code>类型的右值）。请注意，如果编译器可以在没有它的情况下解析调用，则允许（但不是必需）执行此实例化（本示例中可能就是这种情况，因为不会在完全匹配上选择隐式转换）。另请注意，<code>C&lt;double&gt;</code>的实例化可能会触发错误，这可能会令人惊讶。</p>
<h2 id="惰性实例化"><a href="#惰性实例化" class="headerlink" title="惰性实例化"></a>惰性实例化</h2><p>到目前为止的示例说明了与使用非模板类时的需求没有根本区别的需求。许多用途需要一个完整的类类型。对于模板的情况，编译器将从类模板定义中生成这个完整的定义。现在出现了一个相关的问题：有多少模板被实例化了？一个模糊的答案如下：只有真正需要的量。换句话说，编译器在实例化模板时应该是“惰性的”。让我们看看这种懒惰到底意味着什么。</p>
<h3 id="部分和全部实例化"><a href="#部分和全部实例化" class="headerlink" title="部分和全部实例化"></a>部分和全部实例化</h3><p>正如我们所见，编译器有时不需要替换类或函数模板的完整定义。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <span class="title">f</span> <span class="params">(T p)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>*p; &#125;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>(<span class="number">2</span>)) x = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p>在此示例中，由<code>decltype(f(2))</code>指示的类型不需要函数模板<code>f()</code>的完整实例化。因此，编译器只允许替换<code>f()</code>的声明，而不是它的“主体”。这有时称为部分实例化。<br>类似地，如果引用类模板的实例而不需要该实例是完整类型，则编译器不应执行该类模板实例的完整实例化。考虑以下示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Q</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">typename</span> T::Type;</span><br><span class="line">&#125;;</span><br><span class="line">Q&lt;<span class="type">int</span>&gt;* p = <span class="number">0</span>; <span class="comment">// OK: the body of Q&lt;int&gt; is not substituted</span></span><br></pre></td></tr></table></figure></p>
<p>在这里，<code>Q&lt;int&gt;</code>的完整实例化会触发错误，因为当<code>T</code>为<code>int</code>时<code>T::Type</code>没有意义。但是因为在这个例子中<code>Q&lt;int&gt;</code>不需要是完整的，所以没有执行完整的实例化并且代码是好的（尽管可疑）。</p>
<p>变量模板也有“完整”与“部分”实例化的区别。以下示例说明了这一点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T v = T::<span class="built_in">default_value</span>();</span><br><span class="line"><span class="keyword">decltype</span>(v&lt;<span class="type">int</span>&gt;) s; <span class="comment">// OK: initializer of v&lt;int&gt; not instantiated</span></span><br></pre></td></tr></table></figure></p>
<p><code>v&lt;int&gt;</code>的完整实例化会引发错误，但如果我们只需要变量模板实例的类型，则不需要这样做。有趣的是，别名模板没有这种区别：没有两种方法可以替代它们。在 C++ 中，当谈到“模板实例化”而不具体说明完全或部分实例化时，前者是有意的。也就是说，默认情况下，实例化是完全实例化。</p>
<h3 id="实例化组件"><a href="#实例化组件" class="headerlink" title="实例化组件"></a>实例化组件</h3><p>当一个类模板被隐式（完全）实例化时，其成员的每个声明也被实例化，但相应的定义不是（即，成员被部分实例化）。有几个例外。首先，如果类模板包含匿名联合，则该联合定义的成员也会被实例化。另一个例外发生在虚拟成员函数中。它们的定义可能会或可能不会作为实例化类模板的结果而被实例化。在实例化模板时，会单独考虑默认函数调用参数。具体来说，除非调用实际使用默认参数的函数（或成员函数），否则它们不会被实例化。另一方面，如果使用覆盖默认值的显式参数调用函数，则不会实例化默认参数。同样，除非需要，否则不会实例化异常规范和默认成员初始化程序。让我们一起举一些例子来说明一些这些原则：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Safe</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Danger</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[N]; <span class="comment">// OK here, although would fail for N&lt;=0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;<span class="keyword">class</span> <span class="title class_">Tricky</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">noBodyHere</span><span class="params">(Safe&lt;T&gt; = <span class="number">3</span>)</span></span>; <span class="comment">// OK until usage of default value results in an error</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Danger&lt;N&gt; noBoomYet; <span class="comment">// OK until inclass() is used with N&lt;=0 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Nested</span> &#123;</span><br><span class="line">        Danger&lt;N&gt; pfew; <span class="comment">// OK until Nested is used with N&lt;=0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">union</span> &#123; <span class="comment">//due anonymous union:</span></span><br><span class="line">        Danger&lt;N&gt; anonymous; <span class="comment">// OK until Tricky is instantiated with N&lt;=0</span></span><br><span class="line">        <span class="type">int</span> align;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unsafe</span><span class="params">(T (*p)[N])</span></span>; <span class="comment">// OK until Tricky is instantiated with N&lt;=0</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Danger&lt;<span class="number">-1</span>&gt; boom; <span class="comment">// always ERROR (which not all compilers detect)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>标准 C++ 编译器将检查这些模板定义以检查语法和一般语义约束。这样做时，它会在检查涉及模板参数的约束时“假设最好”。例如，成员<code>Danger::arr</code>中的参数 N 可以为零或负数（这将是无效的），但假设不是这种情况。<code>inclass()</code>、<code>struct Nested</code>和匿名联合的定义是因此不成问题。同理，成员<code>unsafe(T (*p)[N])</code>的声明也不成问题，只要 N 是未替换的模板形参即可。<code>membernoBodyHere()</code>的声明是可疑的，因为模板<code>Safe&lt;&gt;</code>不能用整数初始化，但假设是<code>Safe&lt;T&gt;</code>的通用定义实际上不需要默认参数或<code>Safe&lt;T&gt;</code>将被专门化以启用整数值初始化。但是，即使没有实例化模板，成员函数<code>error()</code>的定义也是错误的，因为使用<code>Danger&lt;-1&gt;</code>需要完整定义类<code>Danger&lt;-1&gt;</code>，并且生成该类会尝试定义一个负大小的数组。有趣的是，虽然标准明确指出此代码无效，但它也允许编译器在未实际使用模板实例时不诊断错误。也就是说，由于<code>Tricky&lt;T,N&gt;::error()</code>不用于任何具体的 T 和 N，因此不需要编译器针对这种情况发出错误。</p>
<p>例如，在撰写本文时，GCC 和 Visual C++ 并未诊断此错误。现在让我们分析当我们添加以下定义时会发生什么：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tricky&lt;<span class="type">int</span>, <span class="number">-1</span>&gt; inst;</span><br></pre></td></tr></table></figure></p>
<p>这会导致编译器（完全）通过在模板<code>Tricky&lt;&gt;</code>的定义中用<code>int</code>代替<code>T</code>和<code>-1</code>代替<code>N</code>来实例化<code>Tricky&lt;int, -1&gt;</code>。并不是所有的成员定义都需要，但是默认构造函数和析构函数（在这种情况下都是隐式声明的）肯定会被调用，因此它们的定义必须以某种方式可用（在我们的示例中就是这种情况，因为它们是隐式生成的）。如上所述，<code>Tricky&lt;int, -1&gt;</code>的成员被部分实例化（即，它们的声明被替换）：该过程可能会导致错误。例如，<code>unsafe(T (*p) [N])</code>的声明创建了一个包含负数元素的数组类型，这是一个错误。同样，成员匿名现在会触发错误，因为类型<code>Danger&lt;-1&gt;</code>无法完成。相反，成员<code>inclass()</code>和<code>struct Nested</code>的定义尚未实例化，因此它们需要完整类型<code>Danger&lt;-1&gt;</code>不会发生错误。</p>
<p>如前所述，在实例化模板时，实际上还应提供虚拟成员的定义。否则，很可能会发生链接器错误。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">VirtualClass</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">vmem</span><span class="params">()</span></span>; <span class="comment">// Likely ERROR if instantiated without definition</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VirtualClass&lt;<span class="type">int</span>&gt; inst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后是对<code>operator-&gt;</code>的讨论。考虑：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T <span class="keyword">operator</span>-&gt; ();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通常，<code>operator-&gt;</code>必须返回一个指针类型或<code>operator-&gt;</code>应用到的另一个类类型。这表明<code>C&lt;int&gt;</code>的完成会触发错误，因为它为<code>operator-&gt;</code>声明了<code>int</code>的返回类型。但是，由于某些自然类模板定义会触发这些类型的定义，语言规则更加灵活。用户定义的<code>operator-&gt;</code>只需要返回一个类型，如果该运算符实际上是通过重载决议选择的，则另一个（例如，内置的）<code>operator-&gt;</code>适用于该类型。即使在模板之外也是如此（尽管宽松的行为在这些情况下不太有用）。因此，这里的声明不会触发错误，即使 int 被替换为返回类型。</p>
<h2 id="C-实例化模型"><a href="#C-实例化模型" class="headerlink" title="C++实例化模型"></a>C++实例化模型</h2><p>模板实例化是通过适当替换模板参数从相应的模板实体中获取常规类型、函数或变量的过程。这听起来可能相当简单，但实际上需要正式确定许多细节。</p>
<h3 id="两阶段查找"><a href="#两阶段查找" class="headerlink" title="两阶段查找"></a>两阶段查找</h3><p>在第 13 章中，我们看到解析模板时无法解析依赖名称。相反，在实例化点再次查找它们。但是，不依赖的名称会被尽早查找，以便在第一次看到模板时可以诊断出许多错误。这就引出了两阶段查找的概念：第一阶段是模板的解析，第二阶段是它的实例化：</p>
<ol>
<li>在第一阶段，在解析模板时，使用普通查找规则和（如果适用）参数相关查找 (ADL) 规则查找非依赖名称。使用普通查找规则查找未限定的依赖名称（它们是依赖的，因为它们看起来像具有依赖参数的函数调用中的函数名称），但在执行附加查找之前，查找结果不被认为是完整的第二阶段（当模板被实例化时）。</li>
<li>在第二阶段，在称为实例化点 (POI) 的点实例化模板时，会查找相关的限定名称（模板参数替换为该特定实例化的模板参数），并且额外的 ADL 是对在第一阶段使用普通查找查找的非限定从属名称执行。</li>
</ol>
<p>对于不合格的从属名称，初始普通查找（虽然不完整）用于确定名称是否为模板。考虑以下示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> N &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">E</span> &#123; e &#125;;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">h</span><span class="params">(T P)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>&lt;<span class="type">int</span>&gt;(p); <span class="comment">// #1</span></span><br><span class="line">    <span class="built_in">g</span>&lt;<span class="type">int</span>&gt;(p); <span class="comment">// #2 ERROR</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">h</span>(N::e); <span class="comment">// calls template h with T = N::E</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在第 #1 行中，当看到名称 f 后跟 &lt; 时，编译器必须确定该 &lt; 是尖括号还是小于号。这取决于是否知道 f 是模板的名称；在这种情况下，普通查找会找到 f 的声明，它确实是一个模板，因此使用尖括号解析成功。</p>
<p>但是，第 #2 行会产生错误，因为使用普通查找没有找到模板 g； &lt; 因此被视为小于号，在本例中这是一个语法错误。如果我们能解决这个问题，我们最终会在为<code>T = N::E</code>实例化 h 时使用 ADL 找到模板 N::g（因为 N 是与 E 关联的命名空间），但我们无法做到这一点，直到我们成功解析 h 的通用定义。</p>
<h3 id="实例化点"><a href="#实例化点" class="headerlink" title="实例化点"></a>实例化点</h3><p>我们已经说明，在模板客户端的源代码中，C++ 编译器必须能够访问模板实体的声明或定义。当代码构造以这样的方式引用模板特化时创建实例化点 (POI)，即需要实例化相应模板的定义以创建该特化。POI 是源中可以插入替换模板的点。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInt</span>(<span class="type">int</span> i);</span><br><span class="line">&#125;;</span><br><span class="line">MyInt <span class="keyword">operator</span> - (MyInt <span class="type">const</span>&amp;);</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &gt; (MyInt <span class="type">const</span>&amp;, MyInt <span class="type">const</span>&amp;);</span><br><span class="line"><span class="keyword">using</span> Int = MyInt;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">g</span>(-i);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;<span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(Int)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// #2</span></span><br><span class="line">    <span class="built_in">f</span>&lt;Int&gt;(<span class="number">42</span>); <span class="comment">// point of call</span></span><br><span class="line">    <span class="comment">// #3</span></span><br><span class="line">&#125; <span class="comment">// #4</span></span><br></pre></td></tr></table></figure>
<p>当 C++ 编译器看到调用<code>f&lt;Int&gt;(42)</code>时，它知道需要将模板<code>f</code>实例化为用<code>MyInt</code>替换的<code>T</code>：创建一个 POI。点 #2 和 #3 非常接近调用点，但它们不能是 POI，因为 C++ 不允许我们在那里插入<code>::f&lt;Int&gt;(Int)</code>的定义。第 1 点和第 4 点之间的本质区别在于，在第 4 点，函数<code>g(Int)</code>是可见的，因此可以解决依赖于模板的调用<code>g(-i)</code>。但是，如果点 #1 是 POI，则无法解析该调用，因为<code>g(Int)</code>尚不可见。幸运的是，C++ 将函数模板特化引用的 POI 定义为紧跟在最近的命名空间范围声明或包含该引用的定义之后。在我们的示例中，这是第 4 点。</p>
<p>您可能想知道为什么这个示例涉及类型<code>MyInt</code>而不是<code>simpleint</code>。答案在于在 POI 执行的第二次查找只是一个 ADL。因为 int 没有关联的命名空间，所以 POI 查找不会发生，也不会找到函数 g。因此，如果我们将 Int 的类型别名声明替换为<code>using Int = int;</code>，前面的示例将不再编译。以下示例遇到了类似的问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">g1</span>(x); <span class="comment">// #1</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g1</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">7</span>); <span class="comment">// ERROR: g1 not found!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #2 POI for f1&lt;int&gt;(int)</span></span><br></pre></td></tr></table></figure>
<p>调用<code>f1(7)</code>为<code>f1&lt;int&gt;(int)</code>就在<code>main()</code>之外的点 #2 创建一个 POI。在这个实例化中，关键问题是函数<code>g1</code>的查找。当第一次遇到模板<code>f1</code>的定义时，注意到非限定名称<code>g1</code>是依赖的，因为它是带有依赖参数的函数调用中的函数名称（参数 x 的类型取决于模板参数 T）。因此，使用普通查找规则在点 #1 查找<code>g1</code>； 但是，此时看不到<code>g1</code>。在点 #2，POI，函数在关联的命名空间和类中再次查找，但唯一的参数类型是 int，它没有关联的命名空间和类。因此，即使在 POI 上的普通查找会找到 g1，也永远找不到 g1。变量模板的实例化点与函数模板的处理类似。对于类模板特化，情况有所不同，如下例所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">h</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// #2</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">long</span>)<span class="built_in">sizeof</span>(S&lt;<span class="type">int</span>&gt;);</span><br><span class="line">    <span class="comment">// #3</span></span><br><span class="line">&#125;<span class="comment">// #4</span></span><br></pre></td></tr></table></figure></p>
<p>同样，函数作用域点#2 和#3 不能是 POI，因为命名空间作用域类<code>S&lt;int&gt;</code>的定义不能出现在那里（并且模板通常不能出现在函数作用域中）。如果我们要遵循函数模板实例的规则，POI 将在点 #4 ，但是表达式<code>sizeof(S&lt;int&gt;)</code>是无效的，因为 S<int> 的大小直到点 #4 才能确定 到达。因此，对生成的类实例的引用的 POI 被定义为紧接在包含对该实例的引用的最近的命名空间范围声明或定义之前的点。在我们的示例中，这是点 #1 。</p>
<p>当模板被实际实例化时，可能会出现对额外实例化的需求。考虑一个简短的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> I = <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S&lt;<span class="type">char</span>&gt;::I var1 = <span class="number">41</span>;</span><br><span class="line">    <span class="keyword">typename</span> S&lt;T&gt;::I var2 = <span class="number">42</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>&lt;<span class="type">double</span>&gt;();</span><br><span class="line">&#125;<span class="comment">// #2 : #2a , #2b</span></span><br></pre></td></tr></table></figure>
<p>我们前面的讨论已经确定<code>f&lt;double&gt;()</code>的 POI 位于 #2 处。函数模板<code>f()</code>还引用了类特化<code>S&lt;char&gt;</code>，其 POI 因此位于点 #1 。它也引用了<code>S&lt;T&gt;</code>，但是因为它仍然是依赖的，所以我们现在不能真正实例化它。但是，如果我们在点 #2 实例化<code>f&lt;double&gt;()</code>，我们注意到我们还需要实例化<code>S&lt;double&gt;</code>的定义。此类次要或可传递 POI 的定义略有不同。对于功能模板，辅助 POI 与主 POI 完全相同。对于类实体，次要 POI 紧接在（在最近的封闭命名空间范围内）主要 POI 之前。在我们的示例中，这意味着<code>f&lt;double&gt;()</code>的 POI 可以放置在点 #2b 处，而就在它之前——在点 #2a——是<code>S&lt;double&gt;</code>的辅助 POI。请注意这与<code>S&lt;char&gt;</code>的 POI 有何不同。一个翻译单元通常包含同一个实例的多个 POI。对于类模板实例，仅保留每个翻译单元中的第一个 POI，而忽略后面的 POI（它们并不真正被视为 POI）。对于函数和变量模板的实例，保留所有 POI。在任何一种情况下，ODR 都要求在任何保留的 POI 上发生的实例化是等效的，但 C++ 编译器不需要验证和诊断违反此规则的情况。这允许 C++ 编译器只选择一个非类 POI 来执行实际实例化，而不必担心另一个 POI 可能会导致不同的实例化。</p>
<p>在实践中，大多数编译器将大多数函数模板的实际实例化延迟到翻译单元的末尾。某些实例化不能延迟，包括需要实例化来确定推导的返回类型的情况以及函数为 constexpr 并且必须评估以产生恒定结果的情况.一些编译器在第一次使用内联函数时会立即实例化内联函数。这有效地将相应模板专业化的 POI 移动到翻译单元的末尾，这是 C++ 标准允许的替代 POI。</p>
<h2 id="编译期if段"><a href="#编译期if段" class="headerlink" title="编译期if段"></a>编译期if段</h2><p>C++增加了编译期if，它还在实例化过程中引入了一个新问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">bool</span> <span class="title">f</span><span class="params">(T p)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>(T) &lt;= <span class="keyword">sizeof</span>(<span class="type">long</span> <span class="type">long</span>))</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p&gt;<span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p.<span class="built_in">compare</span>(<span class="number">0</span>) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">g</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(n); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译时 if 是一个 if 语句，其中 if 关键字紧跟<code>constexpr</code>关键字（如本例所示）。后面的带括号的条件必须有一个常量布尔值（到 bool 的隐式转换包含在该考虑中）。因此，编译器知道将选择哪个分支；另一个分支称为丢弃的分支。特别有趣的是，在模板（包括通用 lambda）的实例化过程中，丢弃的分支不会被实例化。这对于我们的示例有效是必要的：我们用 T = int 实例化 f(T)，这意味着 else 分支被丢弃。如果它没有被丢弃，它将被实例化，并且我们会遇到表达式<code>p.compare(0)</code>的错误（当 p 是一个简单整数时它是无效的）。在 C++17 及其 constexpr if 语句之前，避免此类错误需要显式模板特化或重载以实现类似效果。</p>
<p>上面的例子，在 C++14 中，可能实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> b&gt; <span class="keyword">struct</span> <span class="title class_">Dispatch</span> &#123; <span class="comment">//only to be instantiated when b is false</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">f</span><span class="params">(T p)</span> </span>&#123; <span class="comment">//(due to next specialization for true)</span></span><br><span class="line">        <span class="keyword">return</span> p.<span class="built_in">compare</span>(<span class="number">0</span>) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">Dispatch</span>&lt;<span class="literal">true</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">f</span><span class="params">(T p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">bool</span> <span class="title">f</span><span class="params">(T p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Dispatch&lt;<span class="built_in">sizeof</span>(T) &lt;= <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>)&gt;::<span class="built_in">f</span>(p);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">g</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(n); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>显然，<code>constexpr if</code>替代方案更清楚、更简洁地表达了我们的意图。但是，它需要实现来细化实例化单元：虽然以前函数定义总是作为一个整体实例化，但现在必须可以禁止部分实例化。<code>constexpr if</code>的另一个非常方便的用法是表示处理函数参数包所需的递归。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Remainder&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Head&amp;&amp; h, Remainder&amp;&amp;... r)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">doSomething</span>(std::forward&lt;Head&gt;(h));</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(r) != <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// handle the remainder recursively (perfectly forwarding the arguments):</span></span><br><span class="line">        <span class="built_in">f</span>(std::forward&lt;Remainder&gt;(r)...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果没有<code>constexpr if</code>语句，这需要<code>f()</code>模板的额外重载以确保递归终止。</p>
<p>即使在非模板上下文中，<code>constexpr if</code>语句也有一些独特的效果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>(<span class="type">int</span>) == <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">h</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在大多数平台上，<code>g()</code>中的条件为假，因此对<code>h()</code>的调用被丢弃。因此，<code>h()</code>根本不需要定义（当然，除非它在其他地方使用）。如果在此示例中省略了关键字<code>constexpr</code>，则缺少<code>h()</code>的定义通常会在链接时引发错误。</p>
<h2 id="在标准库中"><a href="#在标准库中" class="headerlink" title="在标准库中"></a>在标准库中</h2><p>C++ 标准库包含许多模板，这些模板通常只与少数基本类型一起使用。例如，<code>std::basic_string</code>类模板最常与 char（因为<code>std::string</code>是<code>std::basic_string&lt;char&gt;</code>的类型别名）或<code>wchar_t</code>一起使用，尽管可以用其他类似字符的方式实例化它。因此，标准库实现通常会为这些常见情况引入显式实例化声明。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> charT, <span class="keyword">typename</span> traits = char_traits&lt;charT&gt;,</span><br><span class="line">    <span class="keyword">typename</span> Allocator = allocator&lt;charT&gt;&gt;</span><br><span class="line">    <span class="keyword">class</span> basic_string &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">basic_string</span>&lt;<span class="type">char</span>&gt;;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">basic_string</span>&lt;<span class="type">wchar_t</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="模板参数推导"><a href="#模板参数推导" class="headerlink" title="模板参数推导"></a>模板参数推导</h1><p>在每次调用函数模板时显式指定模板参数（例如，<code>concat&lt;std::string, int&gt;(s, 3)</code>）会很快导致代码笨拙。幸运的是，C++ 编译器通常可以使用称为模板参数推导的强大过程自动确定预期的模板参数。尽管模板参数推导最初是为了简化函数模板的调用而开发的，但它后来被扩展以适用于其他几种用途，包括从它们的初始值设定项中确定变量的类型。</p>
<h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><p>基本推导过程将函数调用的参数类型与函数模板的相应参数化类型进行比较，并尝试得出对一个或多个推导参数的正确替换。每个参数-参数对都是独立分析的，如果最终得出的结论不同，则推理过程失败。考虑以下示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">auto</span> g = <span class="built_in">max</span>(<span class="number">1</span>, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>
<p>这里第一个调用参数是 int 类型，所以我们最初的<code>max()</code>模板的参数<code>T</code>被初步推导出为<code>int</code>。然而，第二个调用参数是双精度的，因此对于这个参数，<code>T</code>应该是双精度的：这与前面的结论相冲突。请注意，我们说“扣除过程失败”，而不是“程序无效”。毕竟，对于另一个名为<code>max</code>的模板，推演过程可能会成功（函数模板可以像普通函数一样被重载）。</p>
<p>如果所有推导的模板参数都是一致确定的，如果在函数声明的其余部分中替换参数导致无效构造，则推导过程仍然会失败。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::ElementT <span class="title">at</span> <span class="params">(T a, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[i];</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">at</span>(p, <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里T被推断为<code>int*</code>（T出现的参数类型只有一种，所以显然没有分析冲突）。但是，在返回类型<code>T::ElementT</code>中用<code>int*</code>代替<code>T</code>显然是无效的 C++，推演过程失败。</p>
<p>我们仍然需要探索参数-参数匹配是如何进行的。我们根据将类型 A（从调用参数类型派生）与参数化类型 P（从调用参数声明派生）匹配来描述它。如果调用参数是用引用声明符声明的，则 P 被认为是引用的类型，A 是参数的类型。然而，否则，P 是声明的参数类型，而 A 是通过将数组和函数类型退化为指针类型从参数类型中获得的，忽略const 和 volatile 限定符。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T)</span></span>; <span class="comment">// parameterized type P is T</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">g</span><span class="params">(T&amp;)</span></span>; <span class="comment">// parameterized type P is also T</span></span><br><span class="line"><span class="type">double</span> arr[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> seven = <span class="number">7</span>;<span class="built_in">f</span>(arr); <span class="comment">// nonreference parameter: T is double*</span></span><br><span class="line"><span class="built_in">g</span>(arr); <span class="comment">// reference parameter: T is double[20]</span></span><br><span class="line"><span class="built_in">f</span>(seven); <span class="comment">// nonreference parameter: T is int</span></span><br><span class="line"><span class="built_in">g</span>(seven); <span class="comment">// reference parameter: T is int const</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">7</span>); <span class="comment">// nonreference parameter: T is int</span></span><br><span class="line"><span class="built_in">g</span>(<span class="number">7</span>); <span class="comment">// reference parameter: T is int =&gt; ERROR: can’t pass 7 to int&amp;</span></span><br></pre></td></tr></table></figure></p>
<p>对于调用<code>f(arr)</code>，<code>arr</code>的数组类型退化为<code>double*</code>类型，这是为<code>T</code>推导出的类型。在<code>f(seven)</code>中，<code>const</code>限定被去除，因此<code>T</code>被推导出为<code>int</code>。相反，调用<code>g(x)</code>将<code>T</code>推导出为<code>double[20]</code>类型（不发生退化）。类似地，<code>g(seven)</code>有一个<code>int const</code>类型的左值参数，并且因为在匹配引用参数时不会删除 const 和 volatile 限定符，所以<code>T</code>被推导出为<code>int const</code>。但是，请注意<code>g(7)</code>会将<code>T</code>推导出为<code>int</code>（因为非类右值表达式从不具有 const 或 volatile 限定类型），并且调用将失败，因为参数无法传递给<code>int&amp;</code>类型的参数。</p>
<p>当参数是字符串文字时，绑定到引用参数的参数不会发生退化这一事实可能令人惊讶。重新考虑使用引用声明的<code>max()</code>模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="type">const</span>&amp; <span class="title">max</span><span class="params">(T <span class="type">const</span>&amp; a, T <span class="type">const</span>&amp; b)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>可以合理地预期，对于表达式<code>max(&quot;Apple&quot;, &quot;Pie&quot;)</code>，T 被推导出为<code>char const*</code>。但是，“Apple”的类型是<code>char const[6]</code>，而“Pie”的类型是<code>char const[4]</code>。不会发生数组到指针的退化（因为推导涉及参考参数），因此<code>T</code>必须同时是<code>char[6]</code>和<code>char[4]</code>才能成功推导。那当然是不可能的。</p>
<h2 id="推断的上下文"><a href="#推断的上下文" class="headerlink" title="推断的上下文"></a>推断的上下文</h2><p>比“T”复杂得多的参数化类型可以匹配给定的参数类型。以下是一些仍然相当基本的示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T*)</span></span>;<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E, <span class="type">int</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(E(&amp;)[N])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(T1 (T2::*)(T3*))</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">double</span>*)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span> <span class="params">(<span class="type">int</span>*** ppp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> b[<span class="number">42</span>];</span><br><span class="line">    <span class="built_in">f1</span>(ppp); <span class="comment">// deduces T to be int**</span></span><br><span class="line">    <span class="built_in">f2</span>(b); <span class="comment">// deduces E to be bool and N to be 42</span></span><br><span class="line">    <span class="built_in">f3</span>(&amp;S::f); <span class="comment">// deduces T1 = void, T2 = S, and T3 = double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>复杂类型声明是从更基本的构造（指针、引用、数组和函数声明符；指向成员声明符的指针；模板标识符等）构建的，匹配过程从顶层构造开始，并通过组合进行递归元素。公平地说，大多数类型声明构造都可以通过这种方式匹配，这些被称为推导上下文。但是，一些构造不是推断的上下文。例如：</p>
<ul>
<li>限定类型名称。例如，像<code>Q&lt;T&gt;::X</code>这样的类型名称永远不会用于推断模板参数 T。</li>
<li>不只是非类型参数的非类型表达式。例如，像<code>S&lt;I+1&gt;</code>这样的类型名称永远不会用于推断 I。也不会通过匹配<code>int(&amp;)[sizeof(S&lt;T&gt;)]</code>类型的参数来推断 T。这些限制应该不足为奇，因为推导通常不是唯一的（甚至是有限的），尽管这种限定类型名称的限制有时很容易被忽略。非推导的上下文并不自动暗示程序有错误，甚至分析的参数不能参与类型推导。为了说明这一点，请考虑以下更复杂的示例：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;<span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> I = <span class="type">int</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fppm</span><span class="params">(<span class="type">void</span> (X&lt;N&gt;::*p)(<span class="keyword">typename</span> X&lt;N&gt;::I))</span></span>;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fppm</span>(&amp;X&lt;<span class="number">33</span>&gt;::f); <span class="comment">// fine: N deduced to be 33</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数模板<code>fppm()</code>中，子构造<code>X&lt;N&gt;::I</code>是非推导上下文。但是，成员指针类型的成员类组件<code>X&lt;N&gt;</code>是一个可推导的上下文，并且当从它推导的参数 N 插入到非推导上下文中时，获得与实际参数<code>&amp;X&lt;33&gt;::f</code>的类型兼容的类型。因此，推论在该参数-参数对上成功。</p>
<p>相反，可以为完全从推断的上下文构建的参数类型推断出矛盾。例如，假设适当声明的类模板 X 和 Y：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(X&lt;Y&lt;T&gt;, Y&lt;T&gt;&gt;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(X&lt;Y&lt;<span class="type">int</span>&gt;, Y&lt;<span class="type">int</span>&gt;&gt;()); <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">f</span>(X&lt;Y&lt;<span class="type">int</span>&gt;, Y&lt;<span class="type">char</span>&gt;&gt;()); <span class="comment">// ERROR: deduction fails</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二次调用函数模板<code>f()</code>的问题是两个参数为参数 T 推导了不同的参数，这是无效的。（在这两种情况下，函数调用参数都是通过调用类模板 X 的默认构造函数获得的临时对象。）</p>
<h2 id="特殊推导情况"><a href="#特殊推导情况" class="headerlink" title="特殊推导情况"></a>特殊推导情况</h2><p>从函数调用的实参和函数模板的形参中获取不到用于推导的对(A, P)有几种情况。第一种情况发生在获取函数模板的地址时。在这种情况下，P 是函数模板声明的参数化类型，A 是初始化或分配给指针的函数类型。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T, T)</span></span>;</span><br><span class="line"><span class="built_in">void</span> (*pf)(<span class="type">char</span>, <span class="type">char</span>) = &amp;f;</span><br></pre></td></tr></table></figure></p>
<p>在此示例中，P 为<code>void(T, T)</code>，A 为<code>void(char, char)</code>。用<code>char</code>代替 T 推演成功，并且 pf 被初始化为特化<code>f&lt;char&gt;</code>的地址。类似地，函数类型用于 P 和 A 用于其他一些特殊情况：</p>
<ul>
<li>确定重载函数模板之间的偏序</li>
<li>将显式特化与函数模板匹配</li>
<li>将显式实例化与模板匹配</li>
<li>将友元函数模板特化与模板匹配</li>
<li>将放置操作符<code>delete</code>或<code>operator delete[]</code>与相应的放置操作符<code>new</code>或<code>operator new[]</code>模板匹配</li>
</ul>
<p>另一种特殊情况发生在转换函数模板中。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">operator</span> T&amp;();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这种情况下，获得对 (P, A) 就好像它涉及我们尝试转换的类型的参数和作为转换函数的返回类型的参数类型。以下代码说明了一种变体：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> (&amp;)[<span class="number">20</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(S s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们尝试将<code>S</code>转换为<code>int (&amp;)[20]</code>。因此类型<code>A</code>是<code>int[20]</code>，类型 P 是 T。推演成功，T 被<code>int[20]</code>替换。</p>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p>当函数调用的参数是初始化列表时，该参数没有特定类型，因此通常不会从给定的对 (A, P) 中执行推导，因为没有 A。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// ERROR: cannot deduce T from a braced list</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，如果参数类型 P 在删除引用和 const 和 volatile 限定符后，对于某些具有可推导模式的类型 P’ 等价于<code>std::initializer_list&lt;P&#39;&gt;</code>，则推断过程仅当所有元素都具有相同类型时才成功：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(std::initializer_list&lt;T&gt;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;); <span class="comment">// OK: T is deduced to int</span></span><br><span class="line">    <span class="built_in">f</span>(&#123;’a’, ’e’, ’i’, ’o’, ’u’, <span class="number">42</span>&#125;); <span class="comment">//ERROR: T deduced to both char and int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类似地，如果参数类型 P 是对具有可推导模式的某些类型 P’ 的数组类型的引用，则通过将 P’ 与初始化器列表中每个元素的类型进行比较来进行推导，仅当所有元素具有相同的类型。此外，如果具有可推导的模式（即，仅命名非类型模板参数），则被推导为列表中的元素数。</p>
<h2 id="参数包"><a href="#参数包" class="headerlink" title="参数包"></a>参数包</h2><p>推导过程将每个参数与每个参数匹配以确定模板参数的值。 然而，在对可变参数模板执行模板实参推导时，形参和实参之间的 1:1 关系不再成立，因为形参包可以匹配多个实参。 在这种情况下，相同的参数包 (P) 与多个参数 (A) 匹配，每次匹配都会为 P 中的任何模板参数包生成附加值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Rest&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(First first, Rest... rest)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span> i, <span class="type">double</span> j, <span class="type">int</span>* k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(i, j, k); <span class="comment">// deduces First to int, Rest to &#123;double, int*&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，第一个函数参数的推导很简单，因为它不涉及任何参数包。第二个函数参数<code>rest</code>是一个函数参数包。它的类型是一个包扩展 (<code>Rest...</code>)，其模式是<code>Rest</code>类型：该模式用作<code>P</code>，与第二个和第三个调用参数的类型 A 进行比较。当与第一个这样的 A（double 类型）进行比较时，模板参数包<code>Rest</code>中的第一个值被推导出为<code>double</code>。类似地，当与第二个这样的 A（类型<code>int*</code>）进行比较时，模板参数包 Rest 中的第二个值被推导出为<code>int*</code>。因此，推导确定参数包Rest 的值是序列<code>&#123;double, int*&#125;</code>。</p>
<p>将该推导的结果和第一个函数参数的推导替换为函数类型<code>void(int, double, int*)</code>，它与调用站点的参数类型匹配。因为函数参数包的推导使用扩展的模式进行比较，所以模式可以任意复杂，并且可以从每个参数类型确定多个模板参数和参数包的值。考虑函数<code>h1()</code>和<code>h2()</code>的推演行为，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">class</span> <span class="title class_">pair</span> &#123; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Rest&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">h1</span><span class="params">(pair&lt;T, Rest&gt; <span class="type">const</span>&amp;...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts, <span class="keyword">typename</span>... Rest&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">h2</span><span class="params">(pair&lt;Ts, Rest&gt; <span class="type">const</span>&amp;...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">float</span>&gt; pif, pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; pid, pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; pdd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">h1</span>(pif, pid); <span class="comment">// OK: deduces T to int, Rest to &#123;float, double&#125;</span></span><br><span class="line">    <span class="built_in">h2</span>(pif, pid); <span class="comment">// OK: deduces Ts to &#123;int, int&#125;, Rest to &#123;float, double&#125;</span></span><br><span class="line">    <span class="built_in">h1</span>(pif, pdd); <span class="comment">// ERROR: T deduced to int from the 1st arg, but to double from the 2nd</span></span><br><span class="line">    <span class="built_in">h2</span>(pif, pdd); <span class="comment">// OK: deduces Ts to &#123;int, double&#125;, Rest to &#123;float, double&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于<code>h1()</code>和<code>h2()</code>，P 是一个引用类型，它被调整为引用的非限定版本（<code>pair&lt;T, Rest&gt;</code>或<code>pair&lt;Ts, Rest&gt;</code>），以针对每个参数类型进行推导。由于所有参数和参数都是类模板对的特化，因此模板参数被比较。对于<code>h1()</code>，第一个模板参数 (T) 不是参数包，因此它的值是为每个参数独立推导的。如果推导不同，如第二次调用<code>h1()</code>，则推导失败。对于<code>h1()</code>和<code>h2() (Rest)</code>中的第二对模板参数，以及<code>h2() (Ts)</code>中的第一对参数，推导从 A 中的每个参数类型确定模板参数包的连续值.</p>
<p>参数包的推导不限于参数-参数对来自调用参数的函数参数包。事实上，只要包展开位于函数参数列表或模板参数列表的末尾，就会使用此推导。例如，考虑对简单 Tuple 类型的两个类似操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt; <span class="keyword">class</span> <span class="title class_">Tuple</span> &#123; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f1</span><span class="params">(Tuple&lt;Types...&gt;, Tuple&lt;Types...&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types1, <span class="keyword">typename</span>... Types2&gt;<span class="function"><span class="type">bool</span> <span class="title">f2</span><span class="params">(Tuple&lt;Types<span class="number">1.</span>..&gt;, Tuple&lt;Types<span class="number">2.</span>..&gt;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(Tuple&lt;<span class="type">short</span>, <span class="type">int</span>, <span class="type">long</span>&gt; sv, Tuple&lt;<span class="type">unsigned</span> <span class="type">short</span>, <span class="type">unsigned</span>, <span class="type">unsigned</span> <span class="type">long</span>&gt; uv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f1</span>(sv, sv); <span class="comment">// OK: Types is deduced to &#123;short, int, long&#125;</span></span><br><span class="line">    <span class="built_in">f2</span>(sv, sv); <span class="comment">// OK: Types1 is deduced to &#123;short, int, long&#125;,</span></span><br><span class="line">    <span class="comment">// Types2 is deduced to &#123;short, int, long&#125;</span></span><br><span class="line">    <span class="built_in">f1</span>(sv, uv); <span class="comment">// ERROR: Types is deduced to &#123;short, int, long&#125; from the 1st arg, but</span></span><br><span class="line">    <span class="comment">// to &#123;unsigned short, unsigned, unsigned long&#125; from the 2nd</span></span><br><span class="line">    <span class="built_in">f2</span>(sv, uv); <span class="comment">// OK: Types1 is deduced to &#123;short, int, long&#125;,</span></span><br><span class="line">    <span class="comment">// Types2 is deduced to &#123;unsigned short, unsigned, unsigned long&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>f1()</code>和<code>f2()</code>中，模板参数包是通过将嵌入在<code>Tuple</code>类型（例如，<code>h1()</code>的类型）中的包扩展模式与由提供的<code>Tuple</code>类型的每个模板参数进行比较来推导出的调用参数，推导出相应模板参数包的连续值。函数<code>f1()</code>在两个函数参数中使用相同的模板参数包类型，确保只有当两个函数调用参数具有与其类型相同的<code>Tuple</code>特化时，推导才会成功。另一方面，函数<code>f2()</code>对每个函数参数中的<code>Tuple</code>类型使用不同的参数包，因此函数调用参数的类型可以不同——只要两者都是 Tuple 的特化。</p>
<h1 id="模板的多态性"><a href="#模板的多态性" class="headerlink" title="模板的多态性"></a>模板的多态性</h1><p>多态在C++中它主要由继承和虚函数实现。由于这一机制主要（至少是一部分）在运行期间起作用，因此我们称之为动态多态（dynamic polymorphism）。模板也允许我们用单个统一符号将不同的特定行为关联起来，不过该关联主要发生在编译期间，我们称之为静态多态（static polymorphism）。</p>
<h2 id="动态多态（dynamic-polymorphism）"><a href="#动态多态（dynamic-polymorphism）" class="headerlink" title="动态多态（dynamic polymorphism）"></a>动态多态（dynamic polymorphism）</h2><p>由于历史原因，C++在最开始的时候只支持通过继承和虚函数实现的多态。在此情况下，多态设计的艺术性主要体现在从一些相关的对象类型中提炼出一组统一的功能，然后将它们声明成一个基类的虚函数接口。</p>
<p>这一设计方式的范例之一是一种用来维护多种几何形状、并通过某些方式将其渲染的应用。在这样一种应用中，我们可以发现一个抽线基类（abstract base class，ABC），在其中声明了适用于几何对象的统一的操作和属性。其余适用于特定几何对象的类都从它做了继承：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;coord.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// common abstract base class GeoObj for geometric objects</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeoObj</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// draw geometric object:</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// return center of gravity of geometric object:</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Coord <span class="title">center_of_gravity</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">GeoObj</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// concrete geometric object class Circle</span></span><br><span class="line"><span class="comment">// - derived from GeoObj</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> GeoObj &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Coord <span class="title">center_of_gravity</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// concrete geometric object class Line</span></span><br><span class="line"><span class="comment">// - derived from GeoObj</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span> : <span class="keyword">public</span> GeoObj &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Coord <span class="title">center_of_gravity</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在创建了具体的对象之后，客户端代码可以通过指向公共基类的指针或者引用，使用虚函数的派发机制来操作它们。在通过基类的指针或者引用调用一个虚函数的时候，所调用的函数将是指针或者引用所指对象的真正类型中的相应函数。在我们的例子中，具体的代码可以被简写成这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dynahier.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// draw any GeoObj</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myDraw</span> <span class="params">(GeoObj <span class="type">const</span>&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.<span class="built_in">draw</span>(); <span class="comment">// call draw() according to type of object</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// compute distance of center of gravity between two GeoObjs</span></span><br><span class="line"><span class="function">Coord <span class="title">distance</span> <span class="params">(GeoObj <span class="type">const</span>&amp; x1, GeoObj <span class="type">const</span>&amp; x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Coord c = x<span class="number">1.</span><span class="built_in">center_of_gravity</span>() - x<span class="number">2.</span><span class="built_in">center_of_gravity</span>();</span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">abs</span>(); <span class="comment">// return coordinates as absolute values</span></span><br><span class="line">&#125; <span class="comment">// draw heterogeneous collection of GeoObjs</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawElems</span> <span class="params">(std::vector&lt;GeoObj*&gt; <span class="type">const</span>&amp; elems)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (std::size_type i=<span class="number">0</span>; i&lt;elems.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        elems[i]-&gt;<span class="built_in">draw</span>(); <span class="comment">// call draw() according to type of element</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Line l;</span><br><span class="line">    Circle c, c1, c2;</span><br><span class="line">    <span class="built_in">myDraw</span>(l); <span class="comment">// myDraw(GeoObj&amp;) =&gt; Line::draw()</span></span><br><span class="line">    <span class="built_in">myDraw</span>(c); <span class="comment">// myDraw(GeoObj&amp;) =&gt; Circle::draw()</span></span><br><span class="line">    <span class="built_in">distance</span>(c1,c2); <span class="comment">// distance(GeoObj&amp;,GeoObj&amp;)</span></span><br><span class="line">    <span class="built_in">distance</span>(l,c); <span class="comment">// distance(GeoObj&amp;,GeoObj&amp;)</span></span><br><span class="line">    std::vector&lt;GeoObj*&gt; coll; <span class="comment">// heterogeneous collection</span></span><br><span class="line">    coll.<span class="built_in">push_back</span>(&amp;l); <span class="comment">// insert line</span></span><br><span class="line">    coll.<span class="built_in">push_back</span>(&amp;c); <span class="comment">// insert circle</span></span><br><span class="line">    <span class="built_in">drawElems</span>(coll); <span class="comment">// draw different kinds of GeoObjs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关键的多态接口是函数<code>draw()</code>和<code>center_of_gravity()</code>，都是虚成员函数。上述例子在函数<code>mydraw()</code>，<code>distance()</code>，以及<code>drawElems()</code>中展示了这两个虚函数的用法。而后面这几个函数使用的都是公共基类<code>GeoObj</code>。这一方式的结果是，在编译期间并不能知道将要被真正调用<br>的函数。但是，在运行期间，则会基于各个对象的完整类型来决定将要调用的函数。因此，取决于集合对象的真正类型，适当的操作将会被执行：如果<code>mydraw()</code>处理的是Line的对象，表达式<code>obj.draw()</code>将调用<code>Line::draw()</code>，如果处理的是Circle的对象，那么就会调用<code>Circle::draw()</code>。</p>
<p>能够处理异质集合中不同类型的对象，或许是动态多态最吸引人的特性。这一概念在<code>drawElems()</code>函数中得到了体现：表达式<code>elems[i]-&gt;draw()</code>会调用不同的成员函数，具体情况取决于元素的动态类型。</p>
<h2 id="静态多态"><a href="#静态多态" class="headerlink" title="静态多态"></a>静态多态</h2><p>模板也可以被用来实现多态。不同的是，它们不依赖于对基类中公共行为的分解。取而代之的是，这一“共性（commonality）”隐式地要求不同的“形状（shapes）”必须支持使用了相同语法的操作（比如，相关函数的名字必须相同）。在定义上，具体的class之间彼此相互独立。在用这些具体的class去实例化模板的时候，这一多态能力得以实现。</p>
<p>比如，上一节中的<code>myDraw()</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myDraw</span> <span class="params">(GeoObj <span class="type">const</span>&amp; obj)</span> <span class="comment">// GeoObj is abstract base</span></span></span><br><span class="line"><span class="function"><span class="keyword">class</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.<span class="built_in">draw</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以被实现成下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> GeoObj&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myDraw</span> <span class="params">(GeoObj <span class="type">const</span>&amp; obj)</span> <span class="comment">// GeoObj is template parameter</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.<span class="built_in">draw</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>比较<code>myDraw()</code>的两种实现，可以发现其主要的区别是将GeoObj用作模板参数而不是公共基类。但是，在表象之下还有很多区别。比如，使用动态多态的话，在运行期间只有一个<code>myDraw()</code>函数，但是在使用模板的情况下，却会有多种不同的函数，例如<code>myDraw&lt;Line&gt;()</code>和<code>myDraw&lt;Circle&gt;()</code>。</p>
<p>我们可能希望用static多态重新实现上一节中的完整例子。首先，我们不再使用有层级结构的几何类，而是直接使用一些彼此独立的几何类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;coord.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// concrete geometric object class Circle</span></span><br><span class="line"><span class="comment">// - not derived from any class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">Coord <span class="title">center_of_gravity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// concrete geometric object class Line</span></span><br><span class="line"><span class="comment">// - not derived from any class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">Coord <span class="title">center_of_gravity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在，可以像下面这样使用这些类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;statichier.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// draw any GeoObj</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> GeoObj&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myDraw</span> <span class="params">(GeoObj <span class="type">const</span>&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.<span class="built_in">draw</span>(); <span class="comment">// call draw() according to type of object</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// compute distance of center of gravity between two GeoObjs</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> GeoObj1, <span class="keyword">typename</span> GeoObj2&gt;</span></span><br><span class="line"><span class="function">Coord <span class="title">distance</span> <span class="params">(GeoObj1 <span class="type">const</span>&amp; x1, GeoObj2 <span class="type">const</span>&amp; x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Coord c = x<span class="number">1.</span><span class="built_in">center_of_gravity</span>() - x<span class="number">2.</span><span class="built_in">center_of_gravity</span>();</span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">abs</span>(); <span class="comment">// return coordinates as absolute values</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// draw homogeneous collection of GeoObjs</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> GeoObj&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawElems</span> <span class="params">(std::vector&lt;GeoObj&gt; <span class="type">const</span>&amp; elems)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i=<span class="number">0</span>; i&lt;elems.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        elems[i].<span class="built_in">draw</span>(); <span class="comment">// call draw() according to type of element</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Line l;</span><br><span class="line">    Circle c, c1, c2;</span><br><span class="line">    <span class="built_in">myDraw</span>(l); <span class="comment">// myDraw&lt;Line&gt;(GeoObj&amp;) =&gt; Line::draw()</span></span><br><span class="line">    <span class="built_in">myDraw</span>(c); <span class="comment">// myDraw&lt;Circle&gt;(GeoObj&amp;) =&gt; Circle::draw()</span></span><br><span class="line">    <span class="built_in">distance</span>(c1,c2); <span class="comment">//distance&lt;Circle,Circle&gt;(GeoObj1&amp;,GeoObj2&amp;)</span></span><br><span class="line">    <span class="built_in">distance</span>(l,c); <span class="comment">// distance&lt;Line,Circle&gt;(GeoObj1&amp;,GeoObj2&amp;)</span></span><br><span class="line">    <span class="comment">// std::vector&lt;GeoObj*&gt; coll; //ERROR: no heterogeneous  collection possible</span></span><br><span class="line">    std::vector&lt;Line&gt; coll; <span class="comment">// OK: homogeneous collection possible</span></span><br><span class="line">    coll.<span class="built_in">push_back</span>(l); <span class="comment">// insert line</span></span><br><span class="line">    <span class="built_in">drawElems</span>(coll); <span class="comment">// draw all lines</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和<code>myDraw()</code>类似，我们不能够再将GeoObj作为具体的参数类型用于<code>distance()</code>。我们引入了两个模板参数，GeoObj1和GeoObj2，来支持不同类型的集合对象之间的距离计算：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">distance</span>(l,c); <span class="comment">// distance&lt;Line,Circle&gt;(GeoObj1&amp;,GeoObj2&amp;)</span></span><br></pre></td></tr></table></figure></p>
<p>但是使用这种方式，我们将不再能够透明地处理异质容器。这也正是static多态中的static部分带来的限制：所有的类型必须在编译期可知。不过，我们可以很容易的为不同的集合对象类型引入不同的集合。这样就不再要求集合的元素必须是指针类型，这对程序性能和类型安全都会有帮助。</p>
<h2 id="动态多态VS静态多态"><a href="#动态多态VS静态多态" class="headerlink" title="动态多态VS静态多态"></a>动态多态VS静态多态</h2><p>让我们来对这两种多态性形式进行分类和比较。</p>
<p>Static和dynamic多态提供了对不同C++编程术语的支持：</p>
<ul>
<li>通过继承实现的多态是有界的（bounded）和动态的（dynamic）：<ul>
<li>有界的意思是，在设计公共基类的时候，参与到多态行为中的类型的相关接口就已经确定（该概念的其它一些术语是侵入的（invasive和intrusive））。</li>
<li>动态的意思是，接口的绑定是在运行期间执行的。</li>
</ul>
</li>
<li>通过模板实现的多态是无界的（unbounded）和静态的（static）：<ul>
<li>无界的意思是，参与到多态行为中的类型的相关接口是不可预先确定的</li>
<li>静态的意思是，接口的绑定是在编译期间执行的</li>
</ul>
</li>
</ul>
<p>因此，严格来讲，在C++中，动态多态和静态多态分别是有界动态多态和无界静态多态的缩写。在其它语言中还会有别的组合（比如在Smakktalk中的无界动态多态）。但是在C++语境中，更简洁的动态多态和静态多态也不会带来困扰。</p>
<p>C++中的动态多态有如下优点：</p>
<ul>
<li>可以很优雅的处理异质集合。</li>
<li>可执行文件的大小可能会比较小（因为它只需要一个多态函数，不像静态多态那样，需要为不同的类型进行各自的实例化）。</li>
<li>代码可以被完整的编译；因此没有必须要被公开的代码（在发布模板库时通常需要发布模板的源代码实现）。</li>
</ul>
<p>作为对比，下面这些可以说是C++中static多态的优点：</p>
<ul>
<li>内置类型的集合可以被很容易的实现。更通俗地说，接口的公共性不需要通过公共基类实现。</li>
<li>产生的代码可能会更快（因为不需要通过指针进行重定向，先验的（priori）非虚函数通常也更容易被inline）。</li>
<li>即使某个具体类型只提供了部分的接口，也可以用于静态多态，只要不会用到那些没有被实现的接口即可。</li>
</ul>
<p>通常认为静态多态要比动态多态更类型安全（type safe），因为其所有的绑定都在编译期间进行了检查。例如，几乎不用担心将一个通过模板实例化得到的、类型不正确的对象插入到一个已有容器中（编译期间会报错）。但是，对于一个存储了指向公共基类的指针的容器，其所存储的指针却有可能指向一个不同类型的对象。<br>在实际中，当相同的接口后面隐藏着不同的语义假设时，模板实例化也会带来一些问题。比如，当关联运算符operator +被一个没实现其所需的关联操作的类型实例化时，就会遇到错误。在实际中，对于基于继承的设计层次，很少会遇到这一类的语义不匹配，这或许是因为相应的接口规格得到了较好的说明。</p>
<h2 id="使用concepts"><a href="#使用concepts" class="headerlink" title="使用concepts"></a>使用concepts</h2><p>针对使用了模板的静态多态的一个争议是，接口的绑定是通过实例化相应的模板执行的。也就是说没有可供编程的公共接口或者公共class。取而代之的是，如果所有实例化的代码都是有效的，那么对模板的任何使用也都是有效的。否则，就会导致难以理解的错误信息，或者是产生了有效的代码却导致了意料之外的行为。</p>
<p>基于这一原因，C++语言的设计者们一直在致力于实现一种能够为模板参数显式地提供（或者是检查）接口的能力。在C++中这一接口被称为concept。它代表了为了能够成功的实例化模板，模板参数必须要满足的一组约束条件。</p>
<p>Concept可以被理解成静态多态的一类“接口”。在我们的例子中，可能会像下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;coord.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> GeoObj = <span class="built_in">requires</span>(T x) &#123;</span><br><span class="line">    &#123; x.<span class="built_in">draw</span>() &#125; -&gt; <span class="type">void</span>;</span><br><span class="line">    &#123; x.<span class="built_in">center_of_gravity</span>() &#125; -&gt; Coord;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这里我们使用关键字concept定义了一个<code>GeoObj concept</code>，它要求一个类型要有可被调用的成员函数<code>draw()</code>和<code>center_of_gravity()</code>，同时也对它们的返回类型做了限制。现在我们可以重写样例模板中的一部分代码，以在其中使用requires子句要求模板参数满足GeoObj concept：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;conceptsreq.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// draw any GeoObj</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">requires</span> GeoObj&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myDraw</span> <span class="params">(T <span class="type">const</span>&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.<span class="built_in">draw</span>(); <span class="comment">// call draw() according to type of object</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// compute distance of center of gravity between two GeoObjs</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">requires</span> GeoObj&lt;T1&gt; &amp;&amp; GeoObj&lt;T2&gt;</span></span><br><span class="line"><span class="function">Coord <span class="title">distance</span> <span class="params">(T1 <span class="type">const</span>&amp; x1, T2 <span class="type">const</span>&amp; x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Coord c = x<span class="number">1.</span><span class="built_in">center_of_gravity</span>() - x<span class="number">2.</span><span class="built_in">center_of_gravity</span>();</span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">abs</span>(); <span class="comment">// return coordinates as absolute values</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// draw homogeneous collection of GeoObjs</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">requires</span> GeoObj&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawElems</span> <span class="params">(std::vector&lt;T&gt; <span class="type">const</span>&amp; elems)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (std::size_type i=<span class="number">0</span>; i&lt;elems.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        elems[i].<span class="built_in">draw</span>(); <span class="comment">// call draw() according to type of element</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于那些可以参与到静态多态行为中的类型，该方法依然是非侵入的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concrete geometric object class Circle</span></span><br><span class="line"><span class="comment">// - not derived from any class or implementing any interface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">Coord <span class="title">center_of_gravity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，这一类类型的定义中依然不包含特定的基类，或者require子句，而且它们也依然可以是基础数据类型或者来自独立框架的类型。</p>
<h2 id="泛型编程（Generic-Programming）"><a href="#泛型编程（Generic-Programming）" class="headerlink" title="泛型编程（Generic Programming）"></a>泛型编程（Generic Programming）</h2><p>在C++的语境中，泛型编程有时候也被定义成模板编程（而面向对象编程被认为是基于虚函数的编程）。在这个意义上，几乎任何C++模板的使用都可以被看作泛型编程的实例。但是，开发者通常认为泛型编程还应包含如下这一额外的要素：</p>
<ul>
<li>该模板必须被定义于一个框架中，且必须能够适用于大量的、有用的组合。</li>
</ul>
<p>到目前为止，在该领域中最重要的一个贡献是标准模板库（Standard Template Library, STL）。STL的设计者们找到了一种可以用于任意线性集合、称之为迭代器（iterators）抽象概念。从本质上来说，容器操作中针对于集合的某些方面已经被分解到迭代器的功能中，这样就可以不用去给所有的线性容器都提供一些诸如<code>max_element()</code>的操作，容器本身只要提供一个能够遍历序列中数值的迭代器类型，以及一些能够创建这些迭代器的成员函数就可以了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, ...&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">vector</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> const_iterator = ...; <span class="comment">// implementation-specific iterator</span></span><br><span class="line">        ... <span class="comment">// type for constantvectors</span></span><br><span class="line">        <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// iterator for start of collection</span></span><br><span class="line">        <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// iterator for end of collection</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, ...&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">list</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> const_iterator = ...; <span class="comment">// implementation-specific iterator</span></span><br><span class="line">        ... <span class="comment">// type for constant lists</span></span><br><span class="line">        <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// iterator for start of collection</span></span><br><span class="line">        <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// iterator for end of collection</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在就可以通过调用泛型操作<code>max_element()</code>（以容器的beginning和end伟参数）来寻找任意集合中的最大值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMax</span> <span class="params">(T <span class="type">const</span>&amp; coll)</span></span>&#123;</span><br><span class="line">    <span class="comment">// compute position of maximum value</span></span><br><span class="line">    <span class="keyword">auto</span> pos = std::<span class="built_in">max_element</span>(coll.<span class="built_in">begin</span>(),coll.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// print value of maximum element of coll (if any):</span></span><br><span class="line">    <span class="keyword">if</span> (pos != coll.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; *pos &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;empty&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;MyClass&gt; c1;</span><br><span class="line">    std::list&lt;MyClass&gt; c2;</span><br><span class="line">    ... </span><br><span class="line">    <span class="built_in">printMax</span>(c1);</span><br><span class="line">    <span class="built_in">printMax</span>(c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>泛型的关键是迭代器，它由容器提供并被算法使用。这样之所以可行，是因为迭代器提供了特定的、可以被算法使用的接口。这些接口通常被称为concept，它代表了为了融入该框架，模板必须满足的一组限制条件。此外，该概念还可用于其它一些操作和数据结构。</p>
<p>原则上，类似于STL方法的一类功能都可以用动态多态实现。但是在实际中，由于迭代器的concept相比于虚函数的调用过于轻量级，因此多态这一方法的用途有限。基于虚函数添加一个接口层，很可能会将我们的操作性能降低一个数量级（甚至更多）。泛型编程之所以实用，正是因为它依赖于静态多态，这样就可以在编译期间就决定具体的接口。另一方面，需要在编译期间解析出接口的这一要求，又催生出了一些与面向对象设计原则（object oriented principles）不同的新原则。</p>
<h1 id="萃取的实现"><a href="#萃取的实现" class="headerlink" title="萃取的实现"></a>萃取的实现</h1><p>萃取（或者叫萃取模板，traits/traits template）是C++编程的组件，它们对管理那些在设计工业级应用模板时所需要管理的多余参数很有帮助。</p>
<h2 id="一个例子：对一个序列求和"><a href="#一个例子：对一个序列求和" class="headerlink" title="一个例子：对一个序列求和"></a>一个例子：对一个序列求和</h2><p>计算一个序列中所有元素的和是一个很常规的任务。也正是这个简单的问题，给我们提供了一个很好的、可以用来介绍各种不同等级的萃取应用的例子。</p>
<h3 id="固定的萃取（Fixed-Traits）"><a href="#固定的萃取（Fixed-Traits）" class="headerlink" title="固定的萃取（Fixed Traits）"></a>固定的萃取（Fixed Traits）</h3><p>让我们先来考虑这样一种情况：待求和的数据存储在一个数组中，然后我们有一个指向数组中第一个元素的指针，和一个指向最后一个元素的指针。由于本书介绍的是模板，我们自然也希望写出一个适用于各种类型的模板。下面是一个看上去很直接的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ACCUM_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACCUM_HPP</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">accum</span> <span class="params">(T <span class="type">const</span>* beg, T <span class="type">const</span>* end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T total&#123;&#125;; <span class="comment">// assume this actually creates a zero value</span></span><br><span class="line">    <span class="keyword">while</span> (beg != end) &#123;</span><br><span class="line">        total += *beg;</span><br><span class="line">        ++beg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//ACCUM_HPP</span></span></span><br></pre></td></tr></table></figure></p>
<p>例子中唯一有些微妙的地方是，如何创建一个类型正确的零值（zero value）来作为求和的起始值。</p>
<p>这就意味着这个局部的total对象要么被其默认值初始化，要么被零（zero）初始化（对应指针是用nullptr初始化，对应bool值是用false初始化）。为了引入我们的第一个萃取模板，考虑下面这一个使用了<code>accum()</code>的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;accum1.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create array of 5 integer values</span></span><br><span class="line">    <span class="type">int</span> num[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// print average value</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;the average value of the integer values is &quot;</span> &lt;&lt; <span class="built_in">accum</span>(num, num<span class="number">+5</span>) / <span class="number">5</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// create array of character values</span></span><br><span class="line">    <span class="type">char</span> name[] = <span class="string">&quot;templates&quot;</span>;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">sizeof</span>(name)<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// (try to) print average character value</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;the average value of the characters in \&quot;&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\&quot; is &quot;</span> &lt;&lt; <span class="built_in">accum</span>(name, name+length) / length &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在例子的前半部分，我们用<code>accum()</code>对5个整型遍历求和：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">... </span><br><span class="line"><span class="built_in">accum</span>(num0, num<span class="number">+5</span>)</span><br></pre></td></tr></table></figure></p>
<p>接着就可以用这些变量的和除变量的数目得到平均值。</p>
<p>例子的第二部分试图为单词“templates”中所有的字符做相同的事情。结果应该是a到z之间的某一个值。在当今的大多数平台上，这个值都是通过ASCII码决定的： a被编码成97，z被编码成122。因此我们可能会期望能够得到一个介于97和122之间的返回值。但是在我们的平台上，程序的输出却是这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">the average value of the integer values is <span class="number">3</span></span><br><span class="line">the average value of the characters in <span class="string">&quot;templates&quot;</span> is <span class="number">-5</span></span><br></pre></td></tr></table></figure></p>
<p>问题在于我们的模板是被char实例化的，其数值范围即使是被用来存储相对较小的数值的和也是不够的。很显然，为了解决这一问题我们应该引入一个额外的模板参数AccT，并将其用于返回值total的类型。但是这会给模板的用户增加负担：在调用这一模板的时候，他们必须额外指定一个类型。对于上面的例子，我们可能需要将其写称这个样子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">accum</span>&lt;<span class="type">int</span>&gt;(name,name<span class="number">+5</span>)</span><br></pre></td></tr></table></figure></p>
<p>这并不是一个过于严苛的要求，但是确实是可以避免的。一个可以避免使用额外的模板参数的方式是，在每个被用来实例化<code>accum()</code>的T和与之对应的应该被用来存储返回值的类型之间建立某种联系。这一联系可以被认为是T的某种属性。正如下面所展示的一样，可以通过模板的偏特化建立这种联系：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AccumulationTraits</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AccumulationTraits</span>&lt;<span class="type">char</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> AccT = <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AccumulationTraits</span>&lt;<span class="type">short</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> AccT = <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AccumulationTraits</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> AccT = <span class="type">long</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AccumulationTraits</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> AccT = <span class="type">unsigned</span> <span class="type">long</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AccumulationTraits</span>&lt;<span class="type">float</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> AccT = <span class="type">double</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>AccumulationTraits</code>模板被称为萃取模板，因为它是提取了其参数类型的特性。（通常而言可以有不只一个萃取，也可以有不只一个参数）。我们选择不对这一模板进行泛型定义，因为在不了解一个类型的时候，我们无法为其求和的类型做出很好的选择。但是，可能有人会辩解说T类型本身就是最好的待选类型（很显然对于我们前面的例子不是这样）。</p>
<p>有了这些了解之后，我们可以将<code>accum()</code>按照下面的方式重写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ACCUM_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACCUM_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;accumtraits2.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">accum</span> <span class="params">(T <span class="type">const</span>* beg, T <span class="type">const</span>* end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// return type is traits of the element type</span></span><br><span class="line">    <span class="keyword">using</span> AccT = <span class="keyword">typename</span> AccumulationTraits&lt;T&gt;::AccT;</span><br><span class="line">    AccT total&#123;&#125;; <span class="comment">// assume this actually creates a zero value</span></span><br><span class="line">    <span class="keyword">while</span> (beg != end) &#123;</span><br><span class="line">        total += *beg;</span><br><span class="line">        ++beg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//ACCUM_HPP</span></span></span><br></pre></td></tr></table></figure></p>
<p>此时程序的输出就和我们所预期一样了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">the average value of the integer values is <span class="number">3</span></span><br><span class="line">the average value of the characters in <span class="string">&quot;templates&quot;</span> is <span class="number">108</span></span><br></pre></td></tr></table></figure></p>
<p>考虑到我们为算法加入了很好的检查机制，总体而言这些变化不算太大。而且，如果要将<code>accum()</code>用于新的类型的话，只要对AccumulationTraits再进行一次显式的偏特化，就会得到一个AccT。值得注意的是，我们可以为任意类型进行上述操作：基础类型，声明在其它库<br>中的类型，以及其它诸如此类的类型。</p>
<h3 id="值萃取（Value-Traits）"><a href="#值萃取（Value-Traits）" class="headerlink" title="值萃取（Value Traits）"></a>值萃取（Value Traits）</h3><p>到目前为止我们看到的萃取，代表的都是特定“主”类型的额外的类型信息。在本节我们将会看到，这一“额外的信息”并不仅限于类型信息。还可以将常量以及其它数值类和一个类型关联起来。</p>
<p>在最原始的<code>accum()</code>模板中，我们使用默认构造函数对返回值进行了初始化，希望将其初始化为一个类似零（zero like）的值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AccT total&#123;&#125;; <span class="comment">// assume this actually creates a zero value</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> total;</span><br></pre></td></tr></table></figure><br>很显然，这并不能保证一定会生成一个合适的初始值。因为AccT可能根本就没有默认构造函数。</p>
<p>萃取可以再一次被用来救场。对于我们的例子，我们可以为AccumulationTraits添加一个新的值萃取（value trait，似乎翻译成值特性会更好一些）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AccumulationTraits</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AccumulationTraits</span>&lt;<span class="type">char</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> AccT = <span class="type">int</span>;</span><br><span class="line">    <span class="type">static</span> AccT <span class="type">const</span> zero = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AccumulationTraits</span>&lt;<span class="type">short</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> AccT = <span class="type">int</span>;</span><br><span class="line">    <span class="type">static</span> AccT <span class="type">const</span> zero = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AccumulationTraits</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> AccT = <span class="type">long</span>;</span><br><span class="line">    <span class="type">static</span> AccT <span class="type">const</span> zero = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，新的萃取提供了一个可以在编译期间计算的，const的zero成员。此时，<code>accum()</code>的实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ACCUM_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACCUM_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;accumtraits3.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">accum</span> <span class="params">(T <span class="type">const</span>* beg, T <span class="type">const</span>* end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// return type is traits of the element type</span></span><br><span class="line">    <span class="keyword">using</span> AccT = <span class="keyword">typename</span> AccumulationTraits&lt;T&gt;::AccT;</span><br><span class="line">    AccT total = AccumulationTraits&lt;T&gt;::zero; <span class="comment">// init total by trait value</span></span><br><span class="line">    <span class="keyword">while</span> (beg != end) &#123;</span><br><span class="line">        total += *beg;</span><br><span class="line">        ++beg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// ACCUM_HPP</span></span></span><br></pre></td></tr></table></figure></p>
<p>在上述代码中，存储求和结果的临时变量的初始化依然很直观：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AccT total = AccumulationTraits&lt;T&gt;::zero;</span><br></pre></td></tr></table></figure></p>
<p>这一实现的一个不足之处是，C++只允许我们在类中对一个整形或者枚举类型的static const数据成员进行初始化。</p>
<p>Constexpr的static数据成员会稍微好一些，允许我们对float类型以及其它字面值类型进行类内初始化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AccumulationTraits</span>&lt;<span class="type">float</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Acct = <span class="type">float</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">float</span> zero = <span class="number">0.0f</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是无论是const还是constexpr都禁止对非字面值类型进行这一类初始化。比如，一个用户定义的任意精度的BigInt类型，可能就不是字面值类型，因为它可能会需要将一部分信息存储在堆上（这会阻碍其成为一个字面值类型），或者是因为我们所需要的构造函数不是constexpr的。下面这个实例化的例子就是错误的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span> &#123;</span><br><span class="line"><span class="built_in">BigInt</span>(<span class="type">long</span> <span class="type">long</span>);</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">... </span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AccumulationTraits</span>&lt;BigInt&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> AccT = BigInt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> BigInt zero = BigInt&#123;<span class="number">0</span>&#125;; <span class="comment">// ERROR: not a literal type</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一个比较直接的解决方案是，不再\在类中定义值萃取（只做声明）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AccumulationTraits</span>&lt;BigInt&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> AccT = BigInt;</span><br><span class="line">    <span class="type">static</span> BigInt <span class="type">const</span> zero; <span class="comment">// declaration only</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后在源文件中对其进行初始化，像下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigInt <span class="type">const</span> AccumulationTraits&lt;BigInt&gt;::zero = BigInt&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样虽然可以工作，但是却有些麻烦（必须在两个地方同时修改代码），这样可能还会有些低效，因为编译期通常并不知晓在其它文件中的变量定义。在C++17中，可以通过使用inline变量来解决这一问题：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AccumulationTraits</span>&lt;BigInt&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> AccT = BigInt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> BigInt <span class="type">const</span> zero = BigInt&#123;<span class="number">0</span>&#125;; <span class="comment">// OK since C++17</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在C++17之前的另一种解决办法是，对于那些不是总是生成整型值的值萃取，使用inline成员函数。同样的，如果成员函数返回的是字面值类型，可以将该函数声明为constexpr的。比如，我们可以像下面这样重写AccumulationTraits：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AccumulationTraits</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AccumulationTraits</span>&lt;<span class="type">char</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> AccT = <span class="type">int</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> AccT <span class="title">zero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AccumulationTraits</span>&lt;<span class="type">short</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> AccT = <span class="type">int</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> AccT <span class="title">zero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AccumulationTraits</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> AccT = <span class="type">long</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> AccT <span class="title">zero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AccumulationTraits</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> AccT = <span class="type">unsigned</span> <span class="type">long</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> AccT <span class="title">zero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AccumulationTraits</span>&lt;<span class="type">float</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> AccT = <span class="type">double</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> AccT <span class="title">zero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>然后针我们自定义的类型对这些萃取进行扩展：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AccumulationTraits</span>&lt;BigInt&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> AccT = BigInt;</span><br><span class="line">    <span class="function"><span class="type">static</span> BigInt <span class="title">zero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BigInt&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在应用端，唯一的区别是函数的调用语法（不像访问一个static数据成员那么简洁）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AccT total = AccumulationTraits&lt;T&gt;::<span class="built_in">zero</span>(); <span class="comment">// init total by trait function</span></span><br></pre></td></tr></table></figure></p>
<p>很明显，萃取可以不只是类型。在我们的例子中，萃取可以是一种能够提供所有在调用<code>accum()</code>时所需的调用参数的信息的技术。这是萃取这一概念的关键：萃取为泛型编程提供了一种配置（configure）具体元素（通常是类型）的手段。</p>
<h3 id="参数化的萃取"><a href="#参数化的萃取" class="headerlink" title="参数化的萃取"></a>参数化的萃取</h3><p>在前面几节中，在<code>accum()</code>里使用的萃取被称为固定的（fixed），这是因为一旦定义了解耦合萃取，在算法中它就不可以被替换。但是在某些情况下，这一类重写（overriding）行为却又是我们所期望的。比如，我们可能碰巧知道某一组float数值的和可以被安全地存储在一个float变量中，而这样做可能又会带来一些性能的提升。</p>
<p>为了解决这一问题，可以为萃取引入一个新的模板参数AT，其默认值由萃取模板决定：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ACCUM_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACCUM_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;accumtraits4.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> AT = AccumulationTraits&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">accum</span> (T <span class="type">const</span>* beg, T <span class="type">const</span>* end)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typename</span> AT::AccT total = AT::<span class="built_in">zero</span>();</span><br><span class="line">    <span class="keyword">while</span> (beg != end) &#123;</span><br><span class="line">        total += *beg;</span><br><span class="line">        ++beg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//ACCUM_HPP</span></span></span><br></pre></td></tr></table></figure></p>
<p>采用这种方式，一部分用户可以忽略掉额外模板参数，而对于那些有着特殊需求的用户，他们可以指定一个新的类型来取代默认类型。但是可以推断，大部分的模板用户永远都不需要显式的提供第二个模板参数，因为我们可以为第一个模板参数的每一种（通过推断得到的）类型都配置一个合适的默认值。</p>
<h2 id="萃取还是策略以及策略类"><a href="#萃取还是策略以及策略类" class="headerlink" title="萃取还是策略以及策略类"></a>萃取还是策略以及策略类</h2><p>到目前为止我们并没有区分累积（accumulation）和求和（summation）。但是我们也可以相像其它种类的累积。比如，我们可以对一组数值求积。或者说，如果这些值是字符串的话，我们可以将它们连接起来。即使是求一个序列中最大值的问题，也可以转化成一个累积问题。在所有这些例子中，唯一需要变得的操作是<code>accum()</code>中的<code>total += *beg</code>。我们可以称这一操作为累积操作的一个策略（policy）。</p>
<p>下面是一个在<code>accum()</code>中引入这样一个策略的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ACCUM_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACCUM_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;accumtraits4.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sumpolicy1.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line"><span class="keyword">typename</span> Policy = SumPolicy,</span><br><span class="line"><span class="keyword">typename</span> Traits = AccumulationTraits&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">accum</span> (T <span class="type">const</span>* beg, T <span class="type">const</span>* end)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> AccT = <span class="keyword">typename</span> Traits::AccT;</span><br><span class="line">    AccT total = Traits::<span class="built_in">zero</span>();</span><br><span class="line">    <span class="keyword">while</span> (beg != end) &#123;</span><br><span class="line">        Policy::<span class="built_in">accumulate</span>(total, *beg);</span><br><span class="line">        ++beg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//ACCUM_HPP</span></span></span><br></pre></td></tr></table></figure></p>
<p>在这一版的<code>accum()</code>中，SumPolicy是一个策略类，也就是一个通过预先商定好的接口，为算法实现了一个或多个策略的类。SumPolicy可以被实现成下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SUMPOLICY_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUMPOLICY_HPP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SumPolicy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="type">void</span> <span class="title">accumulate</span> <span class="params">(T1&amp; total, T2 <span class="type">const</span>&amp; value)</span> </span>&#123;</span><br><span class="line">        total += value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SUMPOLICY_HPP</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果提供一个不同的策略对数值进行累积的话，我们可以计算完全不同的事情。比如考虑下面这个程序，它试图计算一组数值的乘积：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;accum6.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultPolicy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="type">void</span> <span class="title">accumulate</span> <span class="params">(T1&amp; total, T2 <span class="type">const</span>&amp; value)</span> </span>&#123;</span><br><span class="line">        total *= value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create array of 5 integer values</span></span><br><span class="line">    <span class="type">int</span> num[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// print product of all values</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;the product of the integer values is &quot;</span> &lt;&lt;</span><br><span class="line">    <span class="built_in">accum</span>&lt;<span class="type">int</span>,MultPolicy&gt;(num, num<span class="number">+5</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这个程序的输出却和我们所期望的有所不同：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the product of the integer values is <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>问题出在我们对初始值的选取：虽然0能很好的满足求和的需求，但是却不适用于求乘积（初始值0会让乘积的结果也是0）。这说明不同的萃取和策略可能会相互影响，也恰好强调了仔细设计模板的重要性。</p>
<p>在这种情况下，我们可能会认识到，累积循环的初始值应该是累计策略的一部分。这个策略可以使用也可以不使用其zero()萃取。其它一些方法也应该被记住：不是所有的事情都要用萃取和策略才能够解决的。比如，C++标准库中的<code>std::accumulate()</code>就将其初始值当作了第三个参数。</p>
<h3 id="萃取和策略：有什么区别"><a href="#萃取和策略：有什么区别" class="headerlink" title="萃取和策略：有什么区别"></a>萃取和策略：有什么区别</h3><p>可以设计一个合适的例子来证明策略只是萃取的一个特例。相反地，也可以认为萃取只是编码了一个特定的策略。</p>
<p>引入了萃取技术的Nathan Myers则建议使用如下更为开放的定义：</p>
<ul>
<li>萃取类：一个用来代替模板参数的类。作为一个类，它整合了有用的类型和常量；作为一个模板，它为实现一个可以解决所有软件问题的“额外的中间层”提供了方法。</li>
</ul>
<p>总体而言，我们更倾向于使用如下（稍微模糊的）定义：</p>
<ul>
<li>萃取代表的是一个模板参数的本质的、额外的属性。</li>
<li>策略代表的是泛型函数和类型（通常都有其常用地默认值）的可以配置的行为。</li>
</ul>
<p>为了进一步阐明两者之间可能的差异，我们列出了如下和萃取有关的观察结果：</p>
<ul>
<li>萃取在被当作固定萃取（fixed traits）的时候会比较有用（比如，当其不是被作为模板参数传递的时候）。</li>
<li>萃取参数通常都有很直观的默认参数（很少被重写，或者简单的说是不能被重写）。</li>
<li>萃取参数倾向于紧密的依赖于一个或者多个主模板参数。</li>
<li>萃取在大多数情况下会将类型和常量结合在一起，而不是成员函数。</li>
<li>萃取倾向于被汇集在萃取模板中。</li>
</ul>
<p>对于策略类，我们有如下观察结果：</p>
<ul>
<li>策略类如果不是被作为模板参数传递的话，那么其作用会很微弱。</li>
<li>策略参数不需要有默认值，它们通常是被显式指定的（虽有有些泛型组件通常会使用默认策略）。</li>
<li>策略参数通常是和其它模板参数无关的。</li>
<li>策略类通常会包含成员函数。</li>
<li>策略可以被包含在简单类或者类模板中。</li>
</ul>
<p>但是，两者之间并没有一个清晰的界限。比如，C++标准库中的字符萃取就定义了一些函数行为（比如比较，移动和查找字符）。通过替换这些萃取，我们定义一个大小写敏感的字符类型，同时又可以保留相同的字符类型。因此，虽然它们被称为萃取，但是它们的一些属性和策略确实有联系的。</p>
<h3 id="成员模板还是模板模板参数？"><a href="#成员模板还是模板模板参数？" class="headerlink" title="成员模板还是模板模板参数？"></a>成员模板还是模板模板参数？</h3><p>为了实现累积策略（accumulation policy），我们选择将SumPolicy和MultPolicy实现为有成员模板的常规类。另一种使用类模板设计策略类接口的方式，此时就可以被当作模板模板参数使用。比如，我们可以将SumPolicy重写为如下模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SUMPOLICY_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUMPOLICY_HPP</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SumPolicy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">accumulate</span> <span class="params">(T1&amp; total, T2 <span class="type">const</span>&amp; value)</span> </span>&#123;</span><br><span class="line">        total += value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SUMPOLICY_HPP</span></span></span><br></pre></td></tr></table></figure></p>
<p>此时就可以调整Accum，让其使用一个模板模板参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ACCUM_HPP#<span class="keyword">define</span> ACCUM_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;accumtraits4.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sumpolicy2.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>,<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Policy</span> = SumPolicy,</span><br><span class="line">        <span class="keyword">typename</span> Traits = AccumulationTraits&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">accum</span> (T <span class="type">const</span>* beg, T <span class="type">const</span>* end)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> AccT = <span class="keyword">typename</span> Traits::AccT;</span><br><span class="line">    AccT total = Traits::<span class="built_in">zero</span>();</span><br><span class="line">    <span class="keyword">while</span> (beg != end) &#123;</span><br><span class="line">        Policy&lt;AccT,T&gt;::<span class="built_in">accumulate</span>(total, *beg);</span><br><span class="line">        ++beg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">//ACCUM_HPP</span></span></span><br></pre></td></tr></table></figure></p>
<p>相同的转化也可以被用于萃取参数。</p>
<p>通过模板模板参数访问策略类的主要优势是，让一个策略类通过一个依赖于模板参数的类型携带一些状态信息会更容易一些（比如static数据成员）。（在我们的第一个方法中，static数据成员必须要被嵌入到一个成员类模板中。）但是，模板模板参数方法的一个缺点是，策略类必须被实现为模板，而且模板参数必须和我们的接口所定义的参数一样。这可能会使萃取本身的表达相比于非模板类变得更繁琐，也更不自然。</p>
<h3 id="结合多个策略以及-或者萃取"><a href="#结合多个策略以及-或者萃取" class="headerlink" title="结合多个策略以及/或者萃取"></a>结合多个策略以及/或者萃取</h3><p>该如何给这些模板参数排序？一个简单的策略是，根据参数默认值被选择的可能型进行递增排序（也就是说，越是有可能使用一个参数的默认值，就将其排的越靠后）。比如说，萃取参数通常要在策略参数后面。</p>
<p>如果我们不介意增加代码的复杂性的话，还有一种可以按照任意顺序指定非默认参数的方法。</p>
<h3 id="通过普通迭代器实现累积"><a href="#通过普通迭代器实现累积" class="headerlink" title="通过普通迭代器实现累积"></a>通过普通迭代器实现累积</h3><p>在结束萃取和策略的介绍之前，最好再看下另一个版本的<code>accum()</code>的实现，在该实现中添加了处理泛化迭代器的能力（不再只是简单的指针），这是为了支持工业级的泛型组件。有意思的是，我们依然可以用指针来调用这一实现，因为C++标准库提供了迭代器萃取。此时我们就可以像下面这样定义我们最初版本的<code>accum()</code>了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ACCUM_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACCUM_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iter&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">accum</span> <span class="params">(Iter start, Iter end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> VT = <span class="keyword">typename</span> std::iterator_traits&lt;Iter&gt;::value_type;</span><br><span class="line">    VT total&#123;&#125;; <span class="comment">// assume this actually creates a zero value</span></span><br><span class="line">    <span class="keyword">while</span> (start != end) &#123;</span><br><span class="line">        total += *start;</span><br><span class="line">        ++start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//ACCUM_HPP</span></span></span><br></pre></td></tr></table></figure></p>
<p>这里的<code>std::iterator_traits</code>包含了所有迭代器相关的属性。由于存在一个针对指针的偏特化，这些萃取可以很方便的被用于任意常规的指针类型。标准库对这一特性的支持可能会像下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; &#123;</span><br><span class="line">        <span class="keyword">using</span> difference_type = <span class="type">ptrdiff_t</span>;</span><br><span class="line">        <span class="keyword">using</span> value_type = T;</span><br><span class="line">        <span class="keyword">using</span> pointer = T*;</span><br><span class="line">        <span class="keyword">using</span> reference = T&amp;;</span><br><span class="line">        <span class="keyword">using</span> iterator_category = random_access_iterator_tag ;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，此时并没有一个适用于迭代器所指向的数值的累积的类型；因此我们依然需要设计自己的AccumulationTraits。</p>
<h2 id="类型函数"><a href="#类型函数" class="headerlink" title="类型函数"></a>类型函数</h2><p>最初的示例说明我们可以基于类型定义行为。传统上我们在C和C++里定义的函数可以被更明确的称为值函数（value functions）：它们接收一些值作为参数并返回一个值作为结果。对于模板，我们还可以定义类型函数（type functions）：它们接收一些类型作为参数并返回一个类型或者常量作为结果。一个很有用的内置类型函数是<code>sizeof</code>，它返回了一个代表了给定类型大小（单位是byte）的常数。类模板依然可以被用作类型函数。此时类型函数的参数是模板参数，其结果被提取为成员类型或者成员常量。比如，sizeof运算符可以被作为如下接口提供：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeSize</span> &#123;</span><br><span class="line">    <span class="type">static</span> std::<span class="type">size_t</span> <span class="type">const</span> value = <span class="built_in">sizeof</span>(T);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;TypeSize&lt;int&gt;::value = &quot;</span> &lt;&lt; TypeSize&lt;<span class="type">int</span>&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这看上去可能没有那么有用，因为我们已经有了一个内置的<code>sizeof</code>运算符，但是请注意此处的<code>TypeSize&lt;T&gt;</code>是一个类型，它可以被作为类模板参数传递。或者说，<code>TypeSize</code>是一个模板，也可以被作为模板模板参数传递。</p>
<h3 id="元素类型"><a href="#元素类型" class="headerlink" title="元素类型"></a>元素类型</h3><p>假设我们有很多的容器模板，比如<code>std::vector&lt;&gt;</code>和<code>std::list&lt;&gt;</code>，也可以包含内置数组。我们希望得到这样一个类型函数，当给的一个容器类型时，它可以返回相应的元素类型。这可以通过偏特化实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ElementT</span>; <span class="comment">// primary template</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ElementT</span>&lt;std::vector&lt;T&gt;&gt; &#123; <span class="comment">//partial specialization for std::vector</span></span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ElementT</span>&lt;std::list&lt;T&gt;&gt; &#123; <span class="comment">//partial specialization for std::list</span></span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line">... </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ElementT</span>&lt;T[N]&gt; &#123; <span class="comment">//partial specialization for arrays of known bounds</span></span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ElementT</span>&lt;T[]&gt; &#123; <span class="comment">//partial specialization for arrays of unknown bounds</span></span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>注意此处我们应该为所有可能的数组类型提供偏特化。我们可以像下面这样使用这些类型函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;elementtype.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printElementType</span> <span class="params">(T <span class="type">const</span>&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Container of &quot;</span> &lt;&lt;</span><br><span class="line">    <span class="built_in">typeid</span>(<span class="keyword">typename</span> ElementT&lt;T&gt;::Type).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; elements.\n&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">bool</span>&gt; s;</span><br><span class="line">    <span class="built_in">printElementType</span>(s);</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">42</span>];</span><br><span class="line">    <span class="built_in">printElementType</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>偏特化的使用使得我们可以在容器类型不知道具体类型函数存在的情况下去实现类型函数。但是在某些情况下，类型函数是和其所适用的类型一起被设计的，此时相关实现就可以被简化。比如，如果容器类型定义了<code>value_type</code>成员类型（标准库容器都会这么做），我们就可以有如下实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ElementT</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">typename</span> C::value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个实现可以是默认实现，它不会排除那些针对没有定义成员类型<code>value_type</code>的容器的偏特化实现。</p>
<p>虽然如此，我们依然建议为类模板的类型参数提供相应的成员类型定义，这样在泛型代码中就可以更容易的访问它们（和标准库容器的处理方式类似）。下面的代码体现了这一思想：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, ...&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ... = T1;</span><br><span class="line">    <span class="keyword">using</span> ... = T2;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>那么类型函数的作用体现在什么地方呢？它允许我们根据容器类型参数化一个模板，但是又不需要提供代表了元素类型和其它特性的参数。比如，相比于使用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function">T <span class="title">sumOfElements</span> <span class="params">(C <span class="type">const</span>&amp; c)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这一需要显式指定元素类型的模板（<code>sumOfElements&lt;int&gt; list</code>），我们可以定义这样一个模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="keyword">typename</span> ElementT&lt;C&gt;::<span class="function">Type <span class="title">sumOfElements</span> <span class="params">(C <span class="type">const</span>&amp; c)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>其元素类型是通过类型函数得到的。</p>
<p>注意观察萃取是如何被实现为已有类型的扩充的；也就是说，我们甚至可以为基本类型和封闭库的类型定义类型函数。</p>
<p>在上述情况下，<code>ElementT</code>被称为萃取类，因为它被用来访问一个已有容器类型的萃取（通常而言，在这样一个类中可以有多个萃取）。因此萃取类的功能并不仅限于描述容器参数的特性，而是可以描述任意“主参数”的特性。</p>
<p>为了方便，我们可以为类型函数创建一个别名模板。比如，我们可以引入：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> ElementType = <span class="keyword">typename</span> ElementT&lt;T&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>这可以让sumOfEkements的定义变得更加简单：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function">ElementType&lt;C&gt; <span class="title">sumOfElements</span> <span class="params">(C <span class="type">const</span>&amp; c)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="转换萃取（Transformation-Traits）"><a href="#转换萃取（Transformation-Traits）" class="headerlink" title="转换萃取（Transformation Traits）"></a>转换萃取（Transformation Traits）</h3><p>除了可以被用来访问主参数类型的某些特性，萃取还可以被用来做类型转换，比如为某个类型添加或移除引用、 const以及volatile限制符。</p>
<h4 id="删除引用"><a href="#删除引用" class="headerlink" title="删除引用"></a>删除引用</h4><p>比如，我们可以实现一个RemoveReferenceT萃取，用它将引用类型转换成其底层对象或者函数的类型，对于非引用类型则保持不变：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RemoveReferenceT</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RemoveReferenceT</span>&lt;T&amp;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RemoveReferenceT</span>&lt;T&amp;&amp;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>同样地，引入一个别名模板可以简化上述萃取的使用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> RemoveReference = <span class="keyword">typename</span> RemoveReference&lt;T&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>当类型是通过一个有时会产生引用类型的构造器获得的时候，从一个类型中删除引用会很有意义。</p>
<h4 id="添加引用"><a href="#添加引用" class="headerlink" title="添加引用"></a>添加引用</h4><p>我们也可以给一个已有类型添加左值或者右值引用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AddLValueReferenceT</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T&amp;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> AddLValueReference = <span class="keyword">typename</span> AddLValueReferenceT&lt;T&gt;::Type;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AddRValueReferenceT</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T&amp;&amp;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> AddRValueReference = <span class="keyword">typename</span> AddRValueReferenceT&lt;T&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>引用折叠的规则在这一依然适用。比如对于<code>AddLValueReference&lt;int &amp;&amp;&gt;</code>，返回的类型是<code>int&amp;</code>，因为我们不需要对它们进行偏特化实现。</p>
<p>如果我们只实现AddLValueReferenceT和AddRValueReferenceT，而又不对它们进行偏特化的话，最方便的别名模板可以被简化成下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> AddLValueReferenceT = T&amp;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> AddRValueReferenceT = T&amp;&amp;;</span><br></pre></td></tr></table></figure></p>
<p>此时不通过类模板的实例化就可以对其进行实例化（因此称得上是一个轻量级过程）。但是这样做是由风险的，因此我们依然希望能够针对特殊的情况对这些模板进行特例化。比如，如果适用上述简化实现，那么我们就不能将其用于void类型。一些显式的特化实现可以被用来处理这些情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AddLValueReferenceT</span>&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="type">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AddLValueReferenceT</span>&lt;<span class="type">void</span> <span class="type">const</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="type">void</span> <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AddLValueReferenceT</span>&lt;<span class="type">void</span> <span class="keyword">volatile</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="type">void</span> <span class="keyword">volatile</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AddLValueReferenceT</span>&lt;<span class="type">void</span> <span class="type">const</span> <span class="keyword">volatile</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="type">void</span> <span class="type">const</span> <span class="keyword">volatile</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>有了这些偏特化之后，上文中的别名模板必须被实现为类模板的形式，这样才能保证相应的篇特换在需要的时候被正确选取（因为别名模板不能被特化）。</p>
<p>C++标准库中也提供了与之相应的类型萃取：<code>std::add_lvalue_reference&lt;&gt;</code>和<code>std::add_rvalue_reference&lt;&gt;</code>。该标准模板也包含了对void类型的特化。</p>
<h4 id="移除限制符"><a href="#移除限制符" class="headerlink" title="移除限制符"></a>移除限制符</h4><p>转换萃取可以分解或者引入任意种类的复合类型，并不仅限于引用。比如，如果一个类型中存在const限制符，我们可以将其移除：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RemoveConstT</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RemoveConstT</span>&lt;T <span class="type">const</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> RemoveConst = <span class="keyword">typename</span> RemoveConstT&lt;T&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>而且，转换萃取可以是多功能的，比如创建一个可以被用来移除const和volatile的RemoveCVT萃取：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;removeconst.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;removevolatile.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RemoveCVT</span> : RemoveConstT&lt;<span class="keyword">typename</span> RemoveVolatileT&lt;T&gt;::Type&gt;</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> RemoveCV = <span class="keyword">typename</span> RemoveCVT&lt;T&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p><code>RemoveCVT</code>中有两个需要注意的地方。第一个需要注意的地方是，它同时使用了<code>RemoveConstT</code>和相关的<code>RemoveVolitleT</code>，首先移除类型中可能存在的volatile，然后将得到了类型传递给<code>RemoveConstT</code>。第二个需要注意的地方是，它没有定义自己的和<code>RemoveConstT</code>中Type类似的成员，而是通过使用元函数转发（metafunction forwarding）从<code>RemoveConstT</code>中继承了Type成员。这里元函数转发被用来简单的减少<code>RemoveCVT</code>中的类型成员。但是，即使是对于没有为所有输入都定义了元函数的情况，元函数转发也会很有用。</p>
<p><code>RemoveCVT</code>的别名模板可以被进一步简化成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> RemoveCV = RemoveConst&lt;RemoveVolatile&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure></p>
<p>同样地，这一简化只适用于<code>RemoveCVT</code>没有被特化的情况。但是和<code>AddLValueReference</code>以及<code>AddRValueReference</code>的情况不同的是，我们想不出一种对其进行特化的原因。</p>
<p>C++标准库也提供了与之对应的<code>std::remove_volatile&lt;&gt;</code>，<code>std::remove_const&lt;&gt;</code>，以及<code>std::remove_cv&lt;&gt;</code>。</p>
<h4 id="退化（Decay）"><a href="#退化（Decay）" class="headerlink" title="退化（Decay）"></a>退化（Decay）</h4><p>为了使对转换萃取的讨论变得更完整，我们接下来会实现一个模仿了按值传递参数时的类型转化行为的萃取。该类型转换继承自C语言，这意味着参数类型会发生退化（数组类型退化成指针类型，函数类型退化成指向函数的指针类型），而且会删除相应的顶层const，volatile以及引用限制符（因为在解析一个函数调用时，会会忽略掉参数类型中的顶层限制符）。下面的程序展现了按值传递的效果，它会打印出经过编译器退化之后的参数类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printParameterType</span><span class="params">(<span class="type">void</span> (*)(A))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Parameter type: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(A).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;- is int: &quot;</span> &lt;&lt;std::is_same&lt;A,<span class="type">int</span>&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;- is const: &quot;</span> &lt;&lt;std::is_const&lt;A&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;- is pointer: &quot;</span> &lt;&lt;std::is_pointer&lt;A&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printParameterType</span>(&amp;f&lt;<span class="type">int</span>&gt;);</span><br><span class="line">    <span class="built_in">printParameterType</span>(&amp;f&lt;<span class="type">int</span> <span class="type">const</span>&gt;);</span><br><span class="line">    <span class="built_in">printParameterType</span>(&amp;f&lt;<span class="type">int</span>[<span class="number">7</span>]&gt;);</span><br><span class="line">    <span class="built_in">printParameterType</span>(&amp;f&lt;<span class="built_in">int</span>(<span class="type">int</span>)&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在程序的输出中，除了<code>int</code>参数保持不变外，其余<code>int const</code>，<code>int[7]</code>，以及<code>int(int)</code>参数分别退化成了<code>int</code>，<code>int*</code>，以及<code>int(*)(int)</code>。我们可以实现一个与之功能类似的萃取。为了和C++标准库中的<code>std::decay</code>保持匹配，我们称之为<code>DecayT</code>。它的实现结合了上文中介绍的多种技术。首先我们对非数组、非函数的情况进行定义，该情况只需要删除const和volatile限制符即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DecayT</span> : RemoveCVT&lt;T&gt;</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后我们处理数组到指针的退化，这需要用偏特化来处理所有的数组类型（有界和无界数组）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DecayT</span>&lt;T[]&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T*;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DecayT</span>&lt;T[N]&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T*;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>最后来处理函数到指针的退化，这需要应对所有的函数类型，不管是什么返回类型以及有多数参数。为此，我们适用了变参模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DecayT</span>&lt;<span class="built_in">R</span>(Args...)&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="built_in">R</span> (*)(Args...);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DecayT</span>&lt;<span class="built_in">R</span>(Args..., ...)&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="built_in">R</span> (*)(Args..., ...);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意，上面第二个偏特化可以匹配任意使用了C-style可变参数的函数。下面的例子展示了DecayT主模板以及其全部四种偏特化的使用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;decay.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDecayedType</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> A = <span class="keyword">typename</span> DecayT&lt;T&gt;::Type;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Parameter type: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(A).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;- is int: &quot;</span> &lt;&lt; std::is_same&lt;A,<span class="type">int</span>&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;- is const: &quot;</span> &lt;&lt; std::is_const&lt;A&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;- is pointer: &quot;</span> &lt;&lt; std::is_pointer&lt;A&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printDecayedType</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="built_in">printDecayedType</span>&lt;<span class="type">int</span> <span class="type">const</span>&gt;();</span><br><span class="line">    <span class="built_in">printDecayedType</span>&lt;<span class="type">int</span>[<span class="number">7</span>]&gt;();</span><br><span class="line">    <span class="built_in">printDecayedType</span>&lt;<span class="built_in">int</span>(<span class="type">int</span>)&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和往常一样，我们也提供了一个很方便的别名模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Decay = <span class="keyword">typename</span> DecayT&lt;T&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<h3 id="预测型萃取"><a href="#预测型萃取" class="headerlink" title="预测型萃取"></a>预测型萃取</h3><p>到目前为止，我们学习并开发了适用于单个类型的类型函数：给定一个类型，产生另一些相关的类型或者常量。但是通常而言，也可以设计基于多个参数的类型函数。这同样会引出另外一种特殊的类型萃取—类型预测（产生一个bool数值的类型函数）。</p>
<p><code>IsSameT</code>将判断两个类型是否相同：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsSameT</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsSameT</span>&lt;T, T&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里的主模板说明通常我们传递进来的两个类型是不同的，因此其value成员是false。但是，通过使用偏特化，当遇到传递进来的两个相同类型的特殊情况，value成员就是true的。比如，如下表达式会判断传递进来的模板参数是否是整型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IsSameT&lt;T, <span class="type">int</span>&gt;::value) ...</span><br></pre></td></tr></table></figure></p>
<p>对于产生一个常量的萃取，我们没法为之定义一个别名模板，但是可以为之定义一个扮演可相同角色的constexpr的变量模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> isSame = IsSameT&lt;T1, T2&gt;::value;</span><br></pre></td></tr></table></figure></p>
<h4 id="true-type和false-type"><a href="#true-type和false-type" class="headerlink" title="true_type和false_type"></a>true_type和false_type</h4><p>通过为可能的输出结果true和false提供不同的类型，我们可以大大的提高对IsSameT的定义。事实上，如果我们声明一个BoolConstant模板以及两个可能的实例TrueType和FalseType：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> val&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BoolConstant</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = BoolConstant&lt;val&gt;;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> TrueType = BoolConstant&lt;<span class="literal">true</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> FalseType = BoolConstant&lt;<span class="literal">false</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<p>就可以基于两个类型是否匹配，让相应的IsSameT分别继承自TrueType和FalseType:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;boolconstant.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsSameT</span> : FalseType&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsSameT</span>&lt;T, T&gt; : TrueType&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在<code>IsSameT&lt;T, int&gt;</code>的返回类型会被隐式的转换成其基类TrueType或者FalseType，这样就不仅提供了相应的value成员，还允许在编译期间将相应的需求派发到对应的函数实现或者类模板的偏特化上。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;issame.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fooImpl</span><span class="params">(T, TrueType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;fooImpl(T,true) for int called\n&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fooImpl</span><span class="params">(T, FalseType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;fooImpl(T,false) for other type called\n&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fooImpl</span>(t, IsSameT&lt;T,<span class="type">int</span>&gt;&#123;&#125;); <span class="comment">// choose impl. depending on whether T is int</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">42</span>); <span class="comment">// calls fooImpl(42, TrueType)</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">7.7</span>); <span class="comment">// calls fooImpl(42, FalseType)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一技术被称为标记派发（tag dispatching）。注意在BoolConstant的实现中还有一个Type成员，这样就可以通过它为IsSameT引入一个<br>别名模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> isSame = <span class="keyword">typename</span> IsSameT&lt;T&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>这里的别名模板可以和之前的变量模板isSame并存。</p>
<p>通常而言，产生bool值的萃取都应该通过从诸如TrueType和FalseType的类型进行派生来支持标记派发。但是为了尽可能的进行泛化，应该只有一个类型代表true，也应该只有一个类型代表false，而不是让每一个泛型库都为bool型常量定义它自己的类型。幸运的是，从C++11开始C++标准库在<code>&lt;type_traits&gt;</code>中提供了相应的类型：<code>std::true_type</code>和<code>std::false_type</code>。在C++11和C++14中其定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">using</span> true_type = integral_constant&lt;<span class="type">bool</span>, <span class="literal">true</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> false_type = integral_constant&lt;<span class="type">bool</span>, <span class="literal">false</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在C++17中，其定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">using</span> true_type = bool_constant&lt;<span class="literal">true</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> false_type = bool_constant&lt;<span class="literal">false</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>bool_constant</code>的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> B&gt;</span><br><span class="line">    <span class="keyword">using</span> bool_constant = integral_constant&lt;<span class="type">bool</span>, B&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="返回结果类型萃取"><a href="#返回结果类型萃取" class="headerlink" title="返回结果类型萃取"></a>返回结果类型萃取</h3><p>另一个可以被用来处理多个类型的类型函数的例子是返回值类型萃取。在编写操作符模板的时候它们会很有用。为了引出这一概念，我们来写一个可以对两个Array容器求和的函数模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Array&lt;T&gt; <span class="keyword">operator</span>+ (Array&lt;T&gt; <span class="type">const</span>&amp;, Array&lt;T&gt; <span class="type">const</span>&amp;);</span><br></pre></td></tr></table></figure></p>
<p>这看上去很好，但是由于语言本身允许我们对一个char型数值和一个整形数值求和，我们自然也很希望能够对Array也执行这种混合类型（mixed-type）的操作。这样我们就要处理该如何决定相关模板的返回值的问题：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">Array&lt;???&gt; <span class="keyword">operator</span>+ (Array&lt;T1&gt; <span class="type">const</span>&amp;, Array&lt;T2&gt; <span class="type">const</span>&amp;);</span><br></pre></td></tr></table></figure></p>
<p>一个可以解决上述问题的方式就是返回值类型模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">Array&lt;<span class="keyword">typename</span> PlusResultT&lt;T1, T2&gt;::Type&gt;</span><br><span class="line"><span class="keyword">operator</span>+ (Array&lt;T1&gt; <span class="type">const</span>&amp;, Array&lt;T2&gt; <span class="type">const</span>&amp;);</span><br></pre></td></tr></table></figure></p>
<p>如果有便捷别名模板可用的话，还可以将其写称这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">Array&lt;PlusResult&lt;T1, T2&gt;&gt;</span><br><span class="line"><span class="keyword">operator</span>+ (Array&lt;T1&gt; <span class="type">const</span>&amp;, Array&lt;T2&gt; <span class="type">const</span>&amp;);</span><br></pre></td></tr></table></figure></p>
<p>其中的PlusResultT萃取会自行判断通过+操作符对两种类型（可能是不同类型）的数值求和所得到的类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PlusResultT</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">decltype</span>(<span class="built_in">T1</span>() + <span class="built_in">T2</span>());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">using</span> PlusResult = <span class="keyword">typename</span> PlusResultT&lt;T1, T2&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>这一萃取模板通过使用decltype来计算表达式<code>T1()+T2()</code>的类型，将决定结果类型这一艰巨的工作（包括处理类型增进规则（promotion rules）和运算符重载）留给了编译器。</p>
<p>但是对于我们的例子而言，decltype却保留了过多的信息。比如，我们的PlusResultT可能会返回一个引用类型，但是我们的Array模板却很可能不是为引用类型设计的。更为实际的例子是，重载的<code>operator+</code>可能会返回一个const类型的数值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span> &#123; ... &#125;;</span><br><span class="line">Integer <span class="type">const</span> <span class="keyword">operator</span>+ (Integer <span class="type">const</span>&amp;, Integer <span class="type">const</span>&amp;);</span><br></pre></td></tr></table></figure></p>
<p>对两个<code>Array&lt;Integer&gt;</code>的值进行求和却得到了一个存储了Integer const数值的Array，这很可能不是我们所期望的结果。事实上我们所期望的是将返回值类型中的引用和限制符移除之后所得到的类型，正如我们在上一小节所讨论的那样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">Array&lt;RemoveCV&lt;RemoveReference&lt;PlusResult&lt;T1, T2&gt;&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">operator</span>+ (Array&lt;T1&gt; <span class="type">const</span>&amp;, Array&lt;T2&gt; <span class="type">const</span>&amp;);</span><br></pre></td></tr></table></figure></p>
<p>这一萃取的嵌套形式在模板库中很常见，在元编程中也经常被用到。</p>
<p>到目前为止，数组的求和运算符可以正确地计算出对两个元素类型可能不同的Array进行求和的结果类型。但是上述形式的PlusResultT却对元素类型T1和T2施加了一个我们所不期望的限制：由于表达式<code>T1() + T2()</code>试图对类型T1和T2的数值进行值初始化，这两个类型必须要有可访问的、未被删除的默认构造函数（或者是非class类型）。Array类本身可能并没有要求其元素类型可以被进行值初始化，因此这是一个额外的、不必要的限制。</p>
<h4 id="declval"><a href="#declval" class="headerlink" title="declval"></a>declval</h4><p>好在我们可以很简单的在不需要构造函数的情况下计算+表达式的值，方法就是使用一个可以为一个给定类型T生成数值的函数。为了这一目的，C++标准提供了<code>std::declval&lt;&gt;</code>。在<code>&lt;utility&gt;</code>中其定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">add_rvalue_reference_t</span>&lt;T&gt; <span class="title">declval</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>表达式<code>declval&lt;&gt;</code>可以在不需要使用默认构造函数（或者其它任意操作）的情况下为类型T生成一个值。该函数模板被故意设计成未定义的状态，因为我们只希望它被用于decltype，sizeof或者其它不需要相关定义的上下文中。它有两个很有意思的属性：</p>
<ul>
<li>对于可引用的类型，其返回类型总是相关类型的右值引用，这能够使declval适用于那些不能够正常从函数返回的类型，比如抽象类的类型（包含纯虚函数的类型）或者数组类型。因此当被用作表达式时，从类型<code>T</code>到<code>T&amp;&amp;</code>的转换对<code>declval&lt;T&gt;()</code>的行为是没有影响的：其结果都是右值（如果T是对象类型的话），对于右值引用，其结果之所以不会变是因为存在引用塌缩。</li>
<li>在noexcept异常规则中提到，一个表达式不会因为使用了declval而被认成是会抛出异常的。当declval被用在noexcept运算符上下文中时，这一特性会很有帮助</li>
</ul>
<p>有了declval，我们就可以不用在PlusResultT中使用值初始化了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PlusResultT</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T1&gt;() + std::<span class="built_in">declval</span>&lt;T2&gt;());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">using</span> PlusResult = <span class="keyword">typename</span> PlusResultT&lt;T1, T2&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>返回值类型萃取提供了一种从特定操作中获取准确的返回值类型的方式，在确定函数模板的返回值的类型的时候，它会很有用。</p>
<h2 id="基于SFINAE的萃取（SFINAE-Based-Traits）"><a href="#基于SFINAE的萃取（SFINAE-Based-Traits）" class="headerlink" title="基于SFINAE的萃取（SFINAE-Based Traits）"></a>基于SFINAE的萃取（SFINAE-Based Traits）</h2><p>SFINAE会将在模板参数推断过程中，构造无效类型和表达式的潜在错误（会导致程序出现语法错误）转换成简单的推断错误，这样就允许重载解析继续在其它待选项中间做选择。虽然SFINAE最开始是被用来避免与函数模板重载相关的伪错误，我们也可以用它在编译期间判断特定类型和表达式的有效性。比如我们可以通过萃取来判断一个类型是否有某个特定的成员，是否支持某个特定的操作，或者该类型本身是不是一个类。</p>
<p>基于SFINAE的两个主要技术是：用SFINAE排除某些重载函数，以及用SFINAE排除某些偏特化。</p>
<h3 id="用SFINAE排除某些重载函数"><a href="#用SFINAE排除某些重载函数" class="headerlink" title="用SFINAE排除某些重载函数"></a>用SFINAE排除某些重载函数</h3><p>我们触及到的第一个基于SFINAE的例子是将SFINAE用于函数重载，以判断一个类型是否是默认可构造的，对于可以默认构造的类型，就可以不通过值初始化来创建对象。也就是说，对于类型T，诸如<code>T()</code>的表达式必须是有效的。一个基础的实现可能会像下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;issame.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsDefaultConstructibleT</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// test() trying substitute call of a default constructor for</span></span><br><span class="line"><span class="comment">//T passed as U :</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> </span>= <span class="keyword">decltype</span>(<span class="built_in">U</span>())&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">char</span> <span class="title">test</span><span class="params">(<span class="type">void</span>*)</span></span>;<span class="comment">// test() fallback:</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="type">long</span> <span class="title">test</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value =</span><br><span class="line">    IsSameT&lt;<span class="keyword">decltype</span>(<span class="built_in">test</span>&lt;T&gt;(<span class="literal">nullptr</span>)), <span class="type">char</span>&gt;::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过函数重载实现一个基于SFINAE的萃取的常规方式是声明两个返回值类型不同的同名（<code>test()</code>）重载函数模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;...&gt; <span class="type">static</span> <span class="type">char</span> <span class="title">test</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;...&gt; <span class="type">static</span> <span class="type">long</span> <span class="title">test</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>第一个重载函数只有在所需的检查成功时才会被匹配到（后文会讨论其实现方式）。第二个重载函数是用来应急的：它会匹配任意调用，但是由于它是通过”…”（省略号）进行匹配的，因此其它任何匹配的优先级都比它高。</p>
<p>返回值value的具体值取决于最终选择了哪一个test函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value</span><br><span class="line">= IsSameT&lt;<span class="keyword">decltype</span>(<span class="built_in">test</span>&lt;...&gt;(<span class="literal">nullptr</span>)), <span class="type">char</span>&gt;::value;</span><br></pre></td></tr></table></figure></p>
<p>如果选择的是第一个<code>test()</code>函数，由于其返回值类型是char，value会被初始化为<code>isSame&lt;char, char&gt;</code>，也就是true。否则，value会被初始化为<code>isSame&lt;long, char&gt;</code>，也就是false。</p>
<p>现在，到了该处理我们所需要检测的属性的时候了。目标是只有当我们所关心的测试条件被满足的时候，才可以使第一个<code>test()</code>有效。在这个例子中，我们想要测试的条件是被传递进来的类型T是否是可以被默认构造的。为了实现这一目的，我们将T传递给U，并给第一个<code>test()</code>声明增加一个无名的（dummy）模板参数，该模板参数被一个只有在这一转换有效的情况下才有效的构造函数进行初始化。在这个例子中，我们使用的是只有当存在隐式或者显式的默认构造函数<code>U()</code>时才有效的表达式。我们对<code>U()</code>的结果施加了deltype操作，这样就可以用其结果初始化一个类型参数了。</p>
<p>第二个模板参数不可以被推断，因为我们不会为之传递任何参数。而且我们也不会为之提供显式的模板参数。因此，它只会被替换，如果替换失败，基于SFINAE，相应的<code>test()</code>声明会被丢弃掉，因此也就只有应急方案可以匹配相应的调用。</p>
<p>因此，我们可以像下面这样使用这一萃取：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IsDefaultConstructibleT&lt;<span class="type">int</span>&gt;::value <span class="comment">//yields true</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="built_in">S</span>() = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line">IsDefaultConstructibleT&lt;S&gt;::value <span class="comment">//yields false</span></span><br></pre></td></tr></table></figure></p>
<p>但是需要注意，我们不能在第一个<code>test()</code>声明里直接使用模板参数T：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsDefaultConstructibleT</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ERROR: test() uses T directly:</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span> </span>= <span class="keyword">decltype</span>(<span class="built_in">T</span>())&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">char</span> <span class="title">test</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line">    <span class="comment">// test() fallback:</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="type">long</span> <span class="title">test</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value</span><br><span class="line">    = IsSameT&lt;<span class="keyword">decltype</span>(<span class="built_in">test</span>&lt;T&gt;(<span class="literal">nullptr</span>)), <span class="type">char</span>&gt;::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是这样做并不可以，因为对于任意的T，所有模板参数为T的成员函数都会被执行模板参数替换，因此对一个不可以默认构造的类型，这些代码会遇到编译错误，而不是忽略掉第一个<code>test()</code>。通过将类模板的模板参数T传递给函数模板的参数U，我们就只为第二个<code>test()</code>的重载创建了特定的SFINAE上下文。</p>
<h4 id="另一种基于SFINAE的萃取的实现策略"><a href="#另一种基于SFINAE的萃取的实现策略" class="headerlink" title="另一种基于SFINAE的萃取的实现策略"></a>另一种基于SFINAE的萃取的实现策略</h4><p>远在1998年发布第一版C++标准之前，基于SFINAE的萃取的实现就已经成为了可能。该方法的核心一致都是实现两个返回值类型不同的重载函数模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;...&gt; <span class="type">static</span> <span class="type">char</span> <span class="title">test</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;...&gt; <span class="type">static</span> <span class="type">long</span> <span class="title">test</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>但是，在最早的实现技术中，会基于返回值类型的大小来判断使用了哪一个重载函数（也会用到0和enum，因为在当时nullptr和constexpr还没有被引入）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; value = <span class="built_in">sizeof</span>(<span class="built_in">test</span>&lt;...&gt;(<span class="number">0</span>)) == <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>在某些平台上，<code>sizeof(char)</code>的值可能会等于<code>sizeof(long)</code>的值。基于此，我们希望能够确保<code>test()</code>的返回值类型在所有的平台上都有不同的值。比如，在定义了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Size1T = <span class="type">char</span>;</span><br><span class="line"><span class="keyword">using</span> Size2T = <span class="keyword">struct</span> &#123; <span class="type">char</span> a[<span class="number">2</span>]; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Size1T = <span class="built_in">char</span>(&amp;)[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">using</span> Size2T = <span class="built_in">char</span>(&amp;)[<span class="number">2</span>];</span><br></pre></td></tr></table></figure></p>
<p>之后，可以像下面这样定义<code>test()</code>的两个重载版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;...&gt; <span class="type">static</span> Size1T <span class="title">test</span><span class="params">(<span class="type">void</span>*)</span></span>; <span class="comment">// checking test()</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;...&gt; <span class="type">static</span> Size2T <span class="title">test</span><span class="params">(...)</span></span>; <span class="comment">// fallback</span></span><br></pre></td></tr></table></figure></p>
<p>这样，我们要么返回Size1T，其大小为1，要么返回Size2T，在所有的平台上其值都至少是2。使用了上述某一种方式的代码目前依然很常见。但是要注意，传递给<code>test()</code>的调用参数的类型并不重要。我们所要保证的是被传递的参数和所期望的类型能够匹配。比如，可以将其定义成能够接受整型常量42的形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;...&gt; <span class="type">static</span> Size1T <span class="title">test</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">// checking test()</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;...&gt; <span class="type">static</span> Size2T <span class="title">test</span><span class="params">(...)</span></span>; <span class="comment">// fallback</span></span><br><span class="line">... </span><br><span class="line"><span class="keyword">enum</span> &#123; value = <span class="built_in">sizeof</span>(<span class="built_in">test</span>&lt;...&gt;(<span class="number">42</span>)) == <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="用SFINAE排除偏特化"><a href="#用SFINAE排除偏特化" class="headerlink" title="用SFINAE排除偏特化"></a>用SFINAE排除偏特化</h3><p>另一种实现基于SFINAE的萃取的方式会用到偏特化。这里，我们同样可以使用上文中用来判断类型T是否是可以被默认初始化的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;issame.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">//defines true_type and false_type</span></span></span><br><span class="line"><span class="comment">//别名模板，helper to ignore any number of template parameters:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...&gt; <span class="keyword">using</span> VoidT = <span class="type">void</span>;</span><br><span class="line"><span class="comment">// primary template:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span> = VoidT&lt;&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> IsDefaultConstructibleT : std::false_type</span><br><span class="line">&#123; &#125;;</span><br><span class="line"><span class="comment">// partial specialization (may be SFINAE&quot;d away):</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsDefaultConstructibleT</span>&lt;T, VoidT&lt;<span class="keyword">decltype</span>(<span class="built_in">T</span>())&gt;&gt; :</span><br><span class="line">std::true_type</span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>和上文中优化之后的IsDefaultConstructibleT预测萃取类似，我们让适用于一般情况的版本继承自std::false_type，因为默认情况下一个类型没有size_type成员。此处一个比较有意思的地方是，第二个模板参数的默认值被设定为一个辅助别名模板VoidT。这使得我们能够定义各种使用了任意数量的编译期类型构造的偏特化。针对我们的例子，只需要一个类型构造：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">T</span>())</span><br></pre></td></tr></table></figure></p>
<p>这样就可以检测类型T是否是可以被默认初始化的。如果对于某个特定的类型T，其默认构造函数是无效的，此时SIFINEAE就是使该偏特化被丢弃掉，并最终使用主模板。否则该偏特化就是有效的，并且会被选用。</p>
<p>在C++17中，C++标准库引入了与VoidT对应的类型萃取<code>std::void_t&lt;&gt;</code>。在C++17之前，向上面那样定义我们自己的<code>std::void_t</code>是很有用的，甚至可以将其定义在std命名空间里：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __cpp_lib_void_t</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt; <span class="keyword">using</span> <span class="type">void_t</span> = <span class="type">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>从C++14开始，C++标准委员会建议通过定义预先达成一致的特征宏（feature macros）来标识那些标准库的内容以及被实现了。这并不是标准的强制性要求，但是实现者通常都会遵守这一建议，以为其用户提供方便。<code>__cpp_lib_void_t</code>就是被建议用来标识在一个库中是否实现了<code>std::void_t</code>的宏，所以在上面的code中我们将其用于了条件判断。</p>
<h3 id="将泛型Lambdas用于SFINAE"><a href="#将泛型Lambdas用于SFINAE" class="headerlink" title="将泛型Lambdas用于SFINAE"></a>将泛型Lambdas用于SFINAE</h3><p>无论使用哪一种技术，在定义萃取的时候总是需要用到一些样板代码：重载并调用两个<code>test()</code>成员函数，或者实现多个偏特化。接下来我们会展示在C++17中，如何通过指定一个泛型lambda来做条件测试，将样板代码的数量最小化。作为开始，先介绍一个用两个嵌套泛型lambda表达式构造的工具：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="comment">// helper: checking validity of f (args...) for F f and Args... args:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args, <span class="keyword">typename</span> = <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;F&gt;() (std::<span class="built_in">declval</span>&lt;Args&amp;&amp;&gt;()...))&gt;</span><br><span class="line">std::true_type <span class="built_in">isValidImpl</span>(<span class="type">void</span>*);</span><br><span class="line"><span class="comment">// fallback if helper SFINAE&quot;d out:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">std::false_type <span class="title">isValidImpl</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="comment">// define a lambda that takes a lambda f and returns whether calling f with args is valid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span></span><br><span class="line"><span class="keyword">auto</span> isValid = [](<span class="keyword">auto</span> f) &#123;</span><br><span class="line">    <span class="keyword">return</span> [](<span class="keyword">auto</span>&amp;&amp;... args) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">decltype</span>(<span class="built_in">isValidImpl</span>&lt;<span class="keyword">decltype</span>(f),</span><br><span class="line">        <span class="keyword">decltype</span>(args)&amp;&amp;...&gt;(<span class="literal">nullptr</span>))&#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// helper template to represent a type as a value</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeT</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// helper to wrap a type as a value</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> type = TypeT&lt;T&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// helper to unwrap a wrapped type in unevaluated contexts</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">valueT</span><span class="params">(TypeT&lt;T&gt;)</span></span>; <span class="comment">// no definition needed</span></span><br></pre></td></tr></table></figure></p>
<p>先从<code>isValid</code>的定义开始：它是一个类型为lambda闭包的constexpr变量。声明中必须要使用一个占位类型（placeholder type，代码中的auto），因为C++没有办法直接表达一个闭包类型。在C++17之前，lambda表达式不能出现在const表达式中，因此上述代码只有在C++17中才有效。因为<code>isValid</code>是闭包类型的，因此它可以被调用，但是它被调用之后返回的依然是一个闭包类型，返回结果由内部的lambda表达式生成。</p>
<p>在深入讨论内部的lambda表达式之前，先来看一个isValid的典型用法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> isDefaultConstructible</span><br><span class="line">= <span class="built_in">isValid</span>([](<span class="keyword">auto</span> x) -&gt; <span class="keyword">decltype</span>((<span class="type">void</span>)<span class="keyword">decltype</span>(<span class="built_in">valueT</span>(x))() &#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>我们已经知道isDefaultConstructible的类型是闭包类型，而且正如其名字所暗示的那样，它是一个可以被用来测试某个类型是不是可以被默认构造的函数对象。也就是说，<code>isValid</code>是一个萃取工厂（traits factory）：它会为其参数生成萃取，并用生成的萃取对对象进行测试。</p>
<p>辅助变量模板type允许我们用一个值代表一个类型。对于通过这种方式获得的数值x，我们可以通过使用<code>decltype(valueT(x))</code>得到其原始类型，这也正是上面被传递给<code>isValid</code>的lambda所做的事情。如果提取的类型不可以被默认构造，我们要么会得到一个编译错误，要么相关联的声明就会被SFINAE掉（得益于<code>isValid</code>的具体定义，我们代码中所对应的情况是后者）。可以像下面这样使用isDefaultConstructible：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isDefaultConstructible</span>(type&lt;<span class="type">int</span>&gt;) <span class="comment">//true (int is defaultconstructible)</span></span><br><span class="line"><span class="built_in">isDefaultConstructible</span>(type&lt;<span class="type">int</span>&amp;&gt;) <span class="comment">//false (references are not default-constructible)</span></span><br></pre></td></tr></table></figure></p>
<p>为了理解各个部分是如何工作的，先来看看当isValid的参数f被绑定到<code>isDefaultConstructible</code>的泛型lambda参数时，<code>isValid</code>内部的lambda表达式会变成什么样子。通过对<code>isValid</code>的定义进行替换，我们得到如下等价代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> isDefaultConstructible= [](<span class="keyword">auto</span>&amp;&amp;... args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">decltype</span>(isValidImpl&lt;<span class="keyword">decltype</span>([](<span class="keyword">auto</span> x) -&gt;</span><br><span class="line">    <span class="keyword">decltype</span>((<span class="type">void</span>)<span class="keyword">decltype</span>(<span class="built_in">valueT</span>(x))())),</span><br><span class="line">    <span class="keyword">decltype</span>(args)&amp;&amp;...&gt; (<span class="literal">nullptr</span>))&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果我们回头看看第一个<code>isValidImpl()</code>的定义，会发现它还有一个如下形式的默认模板参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;F&gt;()(std::<span class="built_in">declval</span>&lt;Args&amp;&amp;&gt;()...))&gt;</span><br></pre></td></tr></table></figure></p>
<p>它试图对第一个模板参数的值进行调用，而这第一个参数正是<code>isDefaultConstructible</code>定义中的lambda的闭包类型，调用参数为传递给<code>isDefaultConstructible</code>的(<code>decltype(args)&amp;&amp;...</code>)类型的值。由于lambda中只有一个参数x，因此<code>args</code>就需要扩展成一个参数；在我们上面的<code>static_assert</code>例子中，参数类型为<code>TypeT&lt;int&gt;</code>或者<code>TypeT&lt;int&amp;&gt;</code>。对于<code>TypeT&lt;int&amp;&gt;</code>的情况，<code>decltype(valueT(x))</code>的结果是<code>int&amp;</code>，此时<code>decltype(valueT(x))()</code>是无效的，因此在第一个<code>isValidImpl()</code>的声明中默认模板参数的替换会失败，从而该<code>isValidImpl()</code>声明会被SFINAE掉。这样就只有第二个声明可用，且其返回值类型为<code>std::false_type</code>。整体而言，在传递<code>type&lt;int&amp;&gt;</code>的时候，<code>isDefaultConstructible</code>会返回false_type。而如果传递的是<code>type&lt;int&gt;</code>的话，替换不会失败，因此第一个<code>isValidImpl()</code>的声明会被选择，返回结果也就是true_type类型的值。</p>
<p>我们的isDefaultConstructible萃取和之前的萃取在实现上有一些不同，主要体现在它需要执行函数形式的调用，而不是指定模板参数。这可能是一种更为刻度的方式，但是也可以按照之前的方式实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="keyword">using</span> IsDefaultConstructibleT</span><br><span class="line">= <span class="keyword">decltype</span>(<span class="built_in">isDefaultConstructible</span>(std::<span class="built_in">declval</span>&lt;T&gt;()));</span><br></pre></td></tr></table></figure></p>
<p>虽然这是传统的模板声明方式，但是它只能出现在namespace作用域内，然而<code>isDefaultConstructible</code>的定义却很可能被在一个块作用域内引入。</p>
<p>到目前为止，这一技术看上去好像并没有那么有竞争力，因为无论是实现中涉及的表达式还是其使用方式都要比之前的技术复杂得多。但是，一旦有了<code>isValid</code>，并且对其进行了很好的理解，有很多萃取都可以只用一个声明实现。比如，对是否能够访问名为first的成员进行测试，就非常简洁：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> hasFirst</span><br><span class="line">= <span class="built_in">isValid</span>([](<span class="keyword">auto</span> x) -&gt; <span class="keyword">decltype</span>((<span class="type">void</span>)<span class="built_in">valueT</span>(x).first) &#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="SFINAE友好的萃取"><a href="#SFINAE友好的萃取" class="headerlink" title="SFINAE友好的萃取"></a>SFINAE友好的萃取</h3><p>通常，类型萃取应该可以在不使程序出现问题的情况下回答特定的问题。基于SFINAE的萃取解决这一难题的方式是“小心地将潜在的问题捕获进一个SFINAE上下文中”，将可能出现的错误转变成相反的结果。</p>
<p>但是，到目前为止我们所展示的一些萃取在应对错误的时候表现的并不是那么好。回忆一下之前关于PlusResultT的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PlusResultT</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T1&gt;() + std::<span class="built_in">declval</span>&lt;T2&gt;());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">using</span> PlusResult = <span class="keyword">typename</span> PlusResultT&lt;T1, T2&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>在这一定义中，用到+的上下文并没有被SFINAE保护。因此，如果程序试着对不支持+运算符的类型执行PlusResultT的话，那么PlusResultT计算本身就会使成勋遇到错误，比如下面这个例子中，试着为两个无关类型A和B的数组的求和运算声明返回类型的情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// declare + for arrays of different element types:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">Array&lt;<span class="keyword">typename</span> PlusResultT&lt;T1, T2&gt;::Type&gt; <span class="keyword">operator</span>+ (Array&lt;T1&gt; <span class="type">const</span>&amp;,</span><br><span class="line">Array&lt;T2&gt; <span class="type">const</span>&amp;);</span><br><span class="line">很显然，如果没有为数组元素定义合适的+运算符的话，使用PlusResultT&lt;&gt;就会遇到错误。</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addAB</span><span class="params">(Array&lt;A&gt; arrayA, Array&lt;B&gt; arrayB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sum = arrayA + arrayB; <span class="comment">// ERROR: fails in instantiation of PlusResultT&lt;A, B&gt;</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的问题并不是错误会发生在代码明显有问题的地方（没办法对元素类型分别为A和B的数组进行求和），而是错误会发生在对<code>operator+</code>进行模板参数推断的时候，在很深层次的<code>PlusResultT&lt;A,B&gt;</code>的实例化中。这会导致一个很值得注意的结果：即使我们为A和B的数组重载一个求和函数，程序依然可能会遇到编译错误，因为C++不指定如果另一个重载更好的话，一个函数模板中的类型是否真的实例化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declare generic + for arrays of different element types:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">Array&lt;<span class="keyword">typename</span> PlusResultT&lt;T1, T2&gt;::Type&gt;</span><br><span class="line"><span class="keyword">operator</span>+ (Array&lt;T1&gt; <span class="type">const</span>&amp;, Array&lt;T2&gt; <span class="type">const</span>&amp;);</span><br><span class="line"><span class="comment">// overload + for concrete types:</span></span><br><span class="line">Array&lt;A&gt; <span class="keyword">operator</span>+(Array&lt;A&gt; <span class="type">const</span>&amp; arrayA, Array&lt;B&gt; <span class="type">const</span>&amp; arrayB);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addAB</span><span class="params">(Array&lt;A&gt; <span class="type">const</span>&amp; arrayA, Array&lt;B&gt; <span class="type">const</span>&amp; arrayB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sum = arrayA + arrayB; <span class="comment">// ERROR?: depends on whether the compiler</span></span><br><span class="line">    ... <span class="comment">// instantiates PlusResultT&lt;A,B&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果编译器可以在不对第一个<code>operator+</code>模板声明进行推断和替换的情况下，就能够判断出第二个<code>operator+</code>声明会更加匹配的话，上述代码也不会有问题。</p>
<p>但是，在推断或者替换一个备选函数模板的时候，任何发生在类模板定义的实例化过程中的事情都不是函数模板替换的立即上下文（immediate context），SFINAE也不会保护我们不会在其中构建无效类型或者表达式。此时并不会丢弃这一函数模板待选项，而是会立即报出试图在<code>PlusResult&lt;&gt;</code>中为A和B调用<code>operator+</code>的错误：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PlusResultT</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T1&gt;() + std::<span class="built_in">declval</span>&lt;T2&gt; ());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了解决这一问题，我们必须要将PlusResultT变成SFINAR友好的，也就是说需要为之提供更恰当的定义，以使其即使会在decltype中遇到错误，也不会诱发编译错误。参考在之前章节中介绍的HassLessT，我们可以通过定义一个<code>HasPlusT</code>萃取，来判断给定的类型是有一个可用的+运算符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// for declval</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// for true_type, false_type, and void_t primary template:</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>, <span class="keyword">typename</span> = std::<span class="type">void_t</span>&lt;&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> HasPlusT : std::false_type</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="comment">// partial specialization (may be SFINAE&quot;d away):</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HasPlusT</span>&lt;T1, T2, std::<span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T1&gt;() + std::<span class="built_in">declval</span>&lt;T2&gt; ())&gt;&gt;</span><br><span class="line">: std::true_type</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果其返回结果为true，PlusResultT就可以使用现有的实现。否则，PlusResultT就需要一个安全的默认实现。对于一个萃取，如果对某一组模板参数它不能生成有意义的结果，那么最好的默认行为就是不为其提供Type成员。这样，如果萃取被用于SFINAE上下文中（比如之前代码中array类型的<code>operator+</code>的返回值类型），缺少Type成员会导致模板参数推断出错，这也正是我们所期望的、 array类型的<code>operator+</code>模板的行为。下面这一版PlusResultT的实现就提供了上述的行为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hasplus.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="type">bool</span> = HasPlusT&lt;T1, T2&gt;::value&gt;</span><br><span class="line"><span class="keyword">struct</span> PlusResultT &#123; <span class="comment">//primary template, used when HasPlusT yields true</span></span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T1&gt;() + std::<span class="built_in">declval</span>&lt;T2&gt;());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PlusResultT</span>&lt;T1, T2, <span class="literal">false</span>&gt; &#123; <span class="comment">//partial specialization, used otherwise</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这一版的实现中，我们引入了一个有默认值的模板参数，它会使用上文中的HasPlusT来判断前面的两个模板参数是否支持求和操作。然后我们对于第三个模板参数的值为false的情况进行了偏特化，而且在该偏特化中没有任何成员，从而避免了我们所描述过的问题。对与支持求和操作的情况，第三个模板参数的值是true，因此会选用主模板，也就是定义了<code>Type</code>成员的那个模板。这样就保证了只有对支持+操作的类型，PlusResultT才会提供返回类型。</p>
<p>再次考虑<code>Array&lt;A&gt;</code>和<code>Array&lt;B&gt;</code>的求和：如果使用最新的<code>PlusResultT</code>实现，那么<code>PlusResultT&lt;A, B&gt;</code>的实例化将不会有Type成员，因为不能够对A和B进行求和。因此对应的<code>operator+</code>模板的返回值类型是无效的，该函数模板也就会被SFINAE掉。这样就会去选择专门为<code>Array&lt;A&gt;</code>和<code>Array&lt;B&gt;</code>指定的operator+的重载版本。</p>
<p>作为一般的设计原则，在给定了合理的模板参数的情况下，萃取模板永远不应该在实例化阶段出错。其实先方式通常是执行两次相关的检查：</p>
<ol>
<li>一次是检查相关操作是否有效</li>
<li>一次是计算其结果</li>
</ol>
<p>在PlusResultT中我们已经见证了这一原则，在那里我们通过调用<code>HasPlusT&lt;&gt;</code>来判断<code>PlusResultImpl&lt;&gt;</code>中对<code>operator+</code>的调用是否有效。</p>
<h2 id="IsConvertibleT"><a href="#IsConvertibleT" class="headerlink" title="IsConvertibleT"></a>IsConvertibleT</h2><p>细节很重要。因此基于SIFINAE萃取的常规方法在实际中会变得更加复杂。为了展示这一复杂性，我们将定义一个能够判断一种类型是否可以被转化成另外一种类型的萃取，比如当我们期望某个基类或者其某一个子类作为参数的时候。·就可以判断其第一个类型参数是否可以被转换成第二个类型参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// for true_type and false_type</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// for declval</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FROM, <span class="keyword">typename</span> TO&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsConvertibleHelper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// test() trying to call the helper aux(TO) for a FROM passed as F :</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">aux</span><span class="params">(TO)</span></span>;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T,</span><br><span class="line">    <span class="keyword">typename</span> = <span class="keyword">decltype</span>(<span class="built_in">aux</span>(std::<span class="built_in">declval</span>&lt;F&gt;()))&gt;</span><br><span class="line">    <span class="type">static</span> std::true_type <span class="built_in">test</span>(<span class="type">void</span>*);</span><br><span class="line">    <span class="comment">// test() fallback:</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> std::false_type <span class="title">test</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">decltype</span>(<span class="built_in">test</span>&lt;FROM&gt;(<span class="literal">nullptr</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FROM, <span class="keyword">typename</span> TO&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsConvertibleT</span> : IsConvertibleHelper&lt;FROM, TO&gt;::Type &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FROM, <span class="keyword">typename</span> TO&gt;</span><br><span class="line"><span class="keyword">using</span> IsConvertible = <span class="keyword">typename</span> IsConvertibleT&lt;FROM, TO&gt;::Type;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FROM, <span class="keyword">typename</span> TO&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> isConvertible = IsConvertibleT&lt;FROM, TO&gt;::value;</span><br></pre></td></tr></table></figure></p>
<p>我们在一个辅助类中定义了两个名为<code>test()</code>的返回值类型不同的重载函数，并为该辅助类声明了Type成员类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;...&gt; <span class="type">static</span> std::true_type <span class="title">test</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;...&gt; <span class="type">static</span> std::false_type <span class="title">test</span><span class="params">(...)</span></span>;</span><br><span class="line">... </span><br><span class="line"><span class="keyword">using</span> Type = <span class="keyword">decltype</span>(<span class="built_in">test</span>&lt;FROM&gt;(<span class="literal">nullptr</span>));</span><br><span class="line">... </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FROM, <span class="keyword">typename</span> TO&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsConvertibleT</span> : IsConvertibleHelper&lt;FROM, TO&gt;::Type &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>和往常一样，第一个<code>test()</code>只有在所需的检查成功的时候才会被匹配到，第二个<code>test()</code>则是应急方案。因此问题的关键就是让第一个test()只有在类型FROM可以被转换成TO的时候才有效。为了实现这一目的，我们再次给第一个<code>test()</code>分配了一个dummy（并且无名）的模板参数，并将其初始化成只有当转换又消失才有效的内容。该模板参数不可以被推断，我们也不会为之提供显式的模板参数。因此它会被替换，而且当替换失败之后，该<code>test()</code>声明会被丢弃掉。</p>
<p>请再次注意，下面这种声明是不可以的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">aux</span><span class="params">(TO)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keyword">decltype</span>(<span class="built_in">aux</span>(std::<span class="built_in">declval</span>&lt;FROM&gt;()))&gt;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> <span class="built_in">test</span>(<span class="type">void</span>*);</span><br></pre></td></tr></table></figure></p>
<p>这样当成员函数模板被解析的时候，FROM和TO都已经完全确定了，因此对一组不适合做相应转换的类型，在调用<code>test()</code>之前就会立即触发错误。由于这一原因，我们引入了作为成员函数模板参数的F：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">aux</span><span class="params">(TO)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> = <span class="keyword">decltype</span>(<span class="built_in">aux</span>(std::<span class="built_in">declval</span>&lt;F&gt; ()))&gt;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> <span class="built_in">test</span>(<span class="type">void</span>*);</span><br></pre></td></tr></table></figure></p>
<p>并在<code>value</code>的初始化中将<code>FROM</code>类型用作调用<code>test()</code>时的显式模板参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value</span><br><span class="line">= isSame&lt;<span class="keyword">decltype</span>(<span class="built_in">test</span>&lt;FROM&gt;(<span class="literal">nullptr</span>)), <span class="type">char</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<p>请注意这里是如何在不调用任何构造函数的情况下，通过使用<code>std::declval</code>生成一个类型的值的。如果这个值可以被转换成TO，对<code>aux()</code>的调用就是有效的，相应的<code>test()</code>调用也就会被匹配到。否则，会触发SFINAE错误，导致应急<code>test()</code>被调用。然后，我们就可以像下面这样使用该萃取了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IsConvertibleT&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::value <span class="comment">//yields true</span></span><br><span class="line">IsConvertibleT&lt;<span class="type">int</span>, std::string&gt;::value <span class="comment">//yields false</span></span><br><span class="line">IsConvertibleT&lt;<span class="type">char</span> <span class="type">const</span>*, std::string&gt;::value <span class="comment">//yields true</span></span><br><span class="line">IsConvertibleT&lt;std::string, <span class="type">char</span> <span class="type">const</span>*&gt;::value <span class="comment">//yields false</span></span><br></pre></td></tr></table></figure></p>
<h4 id="处理特殊情况"><a href="#处理特殊情况" class="headerlink" title="处理特殊情况"></a>处理特殊情况</h4><p>下面3种情况还不能被上面的<code>IsConvertibleT</code>正确处理：</p>
<ol>
<li>向数组类型的转换要始终返回false，但是在上面的代码中，<code>aux()</code>声明中的类型为TO的参数会退化成指针类型，因此对于某些FROM类型，它会返回true。</li>
<li>向指针类型的转换也应该始终返回false，但是和1中的情况一样，上述实现只会将它们当作退化后的类型。</li>
<li>向（被const/volatile修饰）的void类型的转换需要返回true。但是不幸的是，在TO是void的时候，上述实现甚至不能被正确实例化，因为参数类型不能包含void类型（而且aux()的定义也用到了这一参数）。</li>
</ol>
<p>对于这几种情况，我们需要对它们进行额外的偏特化。但是，为所有可能的与const以及volatile的组合情况都分别进行偏特化是很不明智的。相反，我们为辅助类模板引入了一个额外的模板参数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FROM, <span class="keyword">typename</span> TO, <span class="type">bool</span> = IsVoidT&lt;TO&gt;::value ||</span><br><span class="line">    IsArrayT&lt;TO&gt;::value || IsFunctionT&lt;TO&gt;::value&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> IsConvertibleHelper &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = std::integral_constant&lt;<span class="type">bool</span>, IsVoidT&lt;TO&gt;::value &amp;&amp; IsVoidT&lt;FROM&gt;::value&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FROM, <span class="keyword">typename</span> TO&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsConvertibleHelper</span>&lt;FROM,TO,<span class="literal">false</span>&gt; &#123;</span><br><span class="line">... <span class="comment">//previous implementation of IsConvertibleHelper here</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>额外的bool型模板参数能够保证，对于上面的所有特殊情况，都会最终使用主辅助萃取（而不是偏特化版本）。如果我们试图将FROM转换为数组或者函数，或者FROM是void而TO不是，都会得到<code>false_type</code>的结果，不过对于FROM和TO都是<code>false_type</code>的情况，它也会返回<code>false_type</code>。其它所有的情况，都会使第三个模板参数为false，从而选择偏特化版本的实现（对应于我们之前介绍的实现）。</p>
<h2 id="探测成员（Detecting-Members）"><a href="#探测成员（Detecting-Members）" class="headerlink" title="探测成员（Detecting Members）"></a>探测成员（Detecting Members）</h2><p>另一种对基于SFINAE的萃取的应用是，创建一个可以判断一个给定类型T是否含有名为X的成员（类型或者非类型成员）的萃取。</p>
<h3 id="探测类型成员"><a href="#探测类型成员" class="headerlink" title="探测类型成员"></a>探测类型成员</h3><p>首先定义一个可以判断给定类型T是否含有类型成员size_type的萃取：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="comment">// defines true_type and false_type</span></span><br><span class="line"><span class="comment">// helper to ignore any number of template parameters:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...&gt; <span class="keyword">using</span> VoidT = <span class="type">void</span>;</span><br><span class="line"><span class="comment">// primary template:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span> = VoidT&lt;&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> HasSizeTypeT : std::false_type</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="comment">// partial specialization (may be SFINAE&quot;d away):</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HasSizeTypeT</span>&lt;T, VoidT&lt;<span class="keyword">typename</span> T::size_type&gt;&gt; : std::true_type</span><br><span class="line">&#123;&#125; ;</span><br></pre></td></tr></table></figure></p>
<p>和往常已有，对于预测萃取，我们让一般情况派生自std::false_type，因为某些情况下一个类型是没有size_type成员的。在这种情况下，我们只需要一个条件：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> T::size_type</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">该条件只有在T含有类型成员size_type的时候才有效，这也正是我们所想要做的。如果对于某个类型T，该条件无效，那么SFINAE会使偏特化实现被丢弃，我们就退回到主模板的情况。否则，偏特化有效并且会被有限选取。可以像下面这样使用萃取：</span><br><span class="line">```C++</span><br><span class="line">std::cout &lt;&lt; HasSizeTypeT&lt;<span class="type">int</span>&gt;::value; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CX</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> size_type = std::<span class="type">size_t</span>;</span><br><span class="line">&#125;;</span><br><span class="line">std::cout &lt;&lt; HasSizeType&lt;CX&gt;::value; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，如果类型成员size_type是private的，HasSizeTypeT会返回false，因为我们的萃取模板并没有访问该类型的特殊权限，因此<code>typename T::size_type</code>是无效的（触发SFINAE）。也就是说，该萃取所做的事情是测试我们是否能够访问类型成员size_type。</p>
<h3 id="探测任意类型成员"><a href="#探测任意类型成员" class="headerlink" title="探测任意类型成员"></a>探测任意类型成员</h3><p>在定义了诸如HasSizeTypeT的萃取之后，我们会很自然的想到该如何将该萃取参数化，以对任意名称的类型成员做探测。</p>
<p>不幸的是，目前这一功能只能通过宏来实现，因为还没有语言机制可以被用来描述“潜在”的名字。当前不使用宏的、与该功能最接近的方法是使用泛型lambda。</p>
<p>如下的宏可以满足我们的需求：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// for true_type, false_type, and void_t</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_HAS_TYPE(MemType) \</span></span><br><span class="line"><span class="meta">template<span class="string">&lt;typename, typename = std::void_t&lt;&gt;</span>&gt; \</span></span><br><span class="line"><span class="meta">struct HasTypeT_##MemType \</span></span><br><span class="line"><span class="meta">: std::false_type &#123;</span></span><br><span class="line">&#125;; \</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; \</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HasTypeT_</span>##MemType&lt;T, std::<span class="type">void_t</span>&lt;<span class="keyword">typename</span> T::MemType&gt;&gt; \</span><br><span class="line">: std::true_type &#123; &#125; <span class="comment">// ; intentionally skipped</span></span><br></pre></td></tr></table></figure></p>
<p>每一次对<code>DEFINE_HAS_TYPE(MemberType)</code>的使用都相当于定义了一个新的<code>HasTypeT_MemberType</code>萃取。比如，我们可以用之来探测一个类型是否有<code>value_type</code>或者<code>char_type</code>类型成员：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hastype.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">DEFINE_HAS_TYPE</span>(value_type);</span><br><span class="line"><span class="built_in">DEFINE_HAS_TYPE</span>(char_type);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int::value_type: &quot;</span> &lt;&lt; HasTypeT_value_type&lt;<span class="type">int</span>&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::vector&lt;int&gt;::value_type: &quot;</span> &lt;&lt; HasTypeT_value_type&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::iostream::value_type: &quot;</span> &lt;&lt; HasTypeT_value_type&lt;std::iostream&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::iostream::char_type: &quot;</span> &lt;&lt; HasTypeT_char_type&lt;std::iostream&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="探测非类型成员"><a href="#探测非类型成员" class="headerlink" title="探测非类型成员"></a>探测非类型成员</h3><p>可以继续修改上述萃取，以让其能够测试数据成员和（单个的）成员函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// for true_type, false_type, and void_t</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_HAS_MEMBER(Member) \</span></span><br><span class="line"><span class="meta">template<span class="string">&lt;typename, typename = std::void_t&lt;&gt;</span>&gt; \</span></span><br><span class="line"><span class="meta">struct HasMemberT_##Member \</span></span><br><span class="line"><span class="meta">: std::false_type &#123; &#125;; \</span></span><br><span class="line"><span class="meta">template<span class="string">&lt;typename T&gt;</span> \</span></span><br><span class="line"><span class="meta">struct HasMemberT_##Member&lt;T,</span></span><br><span class="line">std::<span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(&amp;T::Member)&gt;&gt; \</span><br><span class="line">: std::true_type &#123; &#125; <span class="comment">// ; intentionally skipped</span></span><br></pre></td></tr></table></figure></p>
<p>当<code>&amp;::Member</code>无效的时候，偏特化实现会被SFINAE掉。为了使条件有效，必须满足如下条件：</p>
<ul>
<li>Member必须能够被用来没有歧义的识别出T的一个成员（比如，它不能是重载成员你函数的名字，也不能是多重继承中名字相同的成员的名字）。</li>
<li>成员必须可以被访问。</li>
<li>成员必须是非类型成员以及非枚举成员（否则前面的&amp;会无效）。</li>
<li>如果<code>T::Member</code>是static的数据成员，那么与其对应的类型必须没有提供使得<code>&amp;T::Member</code>无效的<code>operator&amp;</code>（比如，将<code>operator&amp;</code>设成不可访问的）。</li>
</ul>
<p>所有以上条件都满足之后，我们可以像下面这样使用该模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hasmember.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="built_in">DEFINE_HAS_MEMBER</span>(size);</span><br><span class="line"><span class="built_in">DEFINE_HAS_MEMBER</span>(first);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int::size: &quot;</span> &lt;&lt; HasMemberT_size&lt;<span class="type">int</span>&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::vector&lt;int&gt;::size: &quot;</span> &lt;&lt; HasMemberT_size&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::pair&lt;int,int&gt;::first: &quot;</span> &lt;&lt; HasMemberT_first&lt;std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改上面的偏特化实现以排除那些<code>&amp;T::Member</code>不是成员指针的情况（比如排除static数据成员的情况）并不会很难。类似地，也可以限制该偏特化仅适用于数据成员或者成员函数。</p>
<p>注意，HasMember萃取只可以被用来测试是否存在“唯一”一个与特定名称对应的成员。如果存在两个同名的成员的话，该测试也会失败，比如当我们测试某些重载成员函数是否存在的时候：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DEFINE_HAS_MEMBER</span>(begin);</span><br><span class="line">std::cout &lt;&lt; HasMemberT_begin&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;::value; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="用泛型Lambda探测成员"><a href="#用泛型Lambda探测成员" class="headerlink" title="用泛型Lambda探测成员"></a>用泛型Lambda探测成员</h3><p>下面这个例子展示了定义可以检测数据或者类型成员是否存在（比如first或者size_type），或者有没有为两个不同类型的对象定义operator &lt;的萃取的方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;isvalid.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    cout &lt;&lt; boolalpha;</span><br><span class="line">    <span class="comment">// define to check for data member first:</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> hasFirst = <span class="built_in">isValid</span>([](<span class="keyword">auto</span> x) -&gt; <span class="keyword">decltype</span>((<span class="type">void</span>)<span class="built_in">valueT</span>(x).first) &#123;&#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hasFirst: &quot;</span> &lt;&lt; <span class="built_in">hasFirst</span>(type&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// define to check for member type size_type:</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> hasSizeType = <span class="built_in">isValid</span>([](<span class="keyword">auto</span> x) -&gt; <span class="keyword">typename</span> <span class="keyword">decltype</span>(<span class="built_in">valueT</span>(x))::size_type &#123; &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CX</span> &#123;</span><br><span class="line">        <span class="keyword">using</span> size_type = std::<span class="type">size_t</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hasSizeType: &quot;</span> &lt;&lt; <span class="built_in">hasSizeType</span>(type&lt;CX&gt;) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// true</span></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(!hasSizeType(type&lt;<span class="type">int</span>&gt;))</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;int has no size_type\n&quot;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// define to check for &lt;:</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> hasLess = <span class="built_in">isValid</span>([](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) -&gt; <span class="keyword">decltype</span>(<span class="built_in">valueT</span>(x) &lt; <span class="built_in">valueT</span>(y)) &#123;&#125;);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">hasLess</span>(<span class="number">42</span>, type&lt;<span class="type">char</span>&gt;) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//yields true</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">hasLess</span>(type&lt;string&gt;, type&lt;string&gt;) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//yields true</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">hasLess</span>(type&lt;string&gt;, type&lt;<span class="type">int</span>&gt;) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//yields false</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">hasLess</span>(type&lt;string&gt;, <span class="string">&quot;hello&quot;</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//yields true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请再次注意，<code>hasSizeType</code>通过使用<code>std::decay</code>将参数x中的引用删除了，因为我们不能访问引用中的类型成员。如果不这么做，该萃取（对于引用类型）会始终返回false，从而导致第二个重载的<code>isValidImpl&lt;&gt;</code>被使用。</p>
<p>为了能够使用统一的泛型语法（将类型用于模板参数），我们可以继续定义额外的辅助工具。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;isvalid.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> hasFirst = <span class="built_in">isValid</span>([](<span class="keyword">auto</span>&amp;&amp; x) -&gt; <span class="keyword">decltype</span>((<span class="type">void</span>)&amp;x.first) &#123;&#125;);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> HasFirstT = <span class="keyword">decltype</span>(<span class="built_in">hasFirst</span>(std::<span class="built_in">declval</span>&lt;T&gt;()));</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> hasSizeType = <span class="built_in">isValid</span>([](<span class="keyword">auto</span>&amp;&amp; x) -&gt; <span class="keyword">typename</span> std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(x)&gt;::size_type &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> HasSizeTypeT = <span class="keyword">decltype</span>(<span class="built_in">hasSizeType</span>(std::<span class="built_in">declval</span>&lt;T&gt;()));</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> hasLess = <span class="built_in">isValid</span>([](<span class="keyword">auto</span>&amp;&amp; x, <span class="keyword">auto</span>&amp;&amp; y) -&gt; <span class="keyword">decltype</span>(x &lt; y) &#123; &#125;);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">using</span> HasLessT = <span class="keyword">decltype</span>(<span class="built_in">hasLess</span>(std::<span class="built_in">declval</span>&lt;T1&gt;(), std::<span class="built_in">declval</span>&lt;T2&gt;()));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;first: &quot;</span> &lt;&lt; HasFirstT&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CX</span> &#123;</span><br><span class="line">        <span class="keyword">using</span> size_type = std::<span class="type">size_t</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size_type: &quot;</span> &lt;&lt; HasSizeTypeT&lt;CX&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// true</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size_type: &quot;</span> &lt;&lt; HasSizeTypeT&lt;<span class="type">int</span>&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// false</span></span><br><span class="line">    cout &lt;&lt; HasLessT&lt;<span class="type">int</span>, <span class="type">char</span>&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// true</span></span><br><span class="line">    cout &lt;&lt; HasLessT&lt;string, string&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// true</span></span><br><span class="line">    cout &lt;&lt; HasLessT&lt;string, <span class="type">int</span>&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// false</span></span><br><span class="line">    cout &lt;&lt; HasLessT&lt;string, <span class="type">char</span>*&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在可以像下面这样使用<code>HasFirstT</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HasFirstT&lt;std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;::value</span><br></pre></td></tr></table></figure></p>
<p>它会为一个包含两个int的pair调用hasFirst，其行为和之前的讨论一致。</p>
<h2 id="其它的萃取技术"><a href="#其它的萃取技术" class="headerlink" title="其它的萃取技术"></a>其它的萃取技术</h2><p>最后让我们来介绍其它一些在定义萃取时可能会用到的方法。</p>
<h3 id="If-Then-Else"><a href="#If-Then-Else" class="headerlink" title="If-Then-Else"></a>If-Then-Else</h3><p>在上一小节中，PlusResultT的定义采用了和之前完全不同的实现方法，该实现方法依赖于另一个萃取（HasPlusT）的结果。我们可以用一个特殊的类型模板IfThenElse来表达这一if-then-else的行为，它接受一个bool型的模板参数，并根据该参数从另外两个类型参数中间做选择：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> IFTHENELSE_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IFTHENELSE_HPP</span></span><br><span class="line"><span class="comment">// primary template: yield the second argument by default and rely on</span></span><br><span class="line"><span class="comment">// a partial specialization to yield the third argument</span></span><br><span class="line"><span class="comment">// if COND is false</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> COND, <span class="keyword">typename</span> TrueType, <span class="keyword">typename</span> FalseType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IfThenElseT</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = TrueType;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// partial specialization: false yields third argument</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TrueType, <span class="keyword">typename</span> FalseType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IfThenElseT</span>&lt;<span class="literal">false</span>, TrueType, FalseType&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = FalseType;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> COND, <span class="keyword">typename</span> TrueType, <span class="keyword">typename</span> FalseType&gt;</span><br><span class="line"><span class="keyword">using</span> IfThenElse = <span class="keyword">typename</span> IfThenElseT&lt;COND, TrueType, FalseType&gt;::Type;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//IFTHENELSE_HPP</span></span></span><br></pre></td></tr></table></figure>
<p>下面的例子展现了该模板的一种应用，它定义了一个可以为给定数值选择最合适的整形类型的函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ifthenelse.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">auto</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SmallestIntT</span> &#123;</span><br><span class="line"><span class="keyword">using</span> Type = <span class="keyword">typename</span> IfThenElseT&lt;N &lt;= std::numeric_limits&lt;<span class="type">char</span>&gt; ::<span class="built_in">max</span>(), <span class="type">char</span>, </span><br><span class="line">    <span class="keyword">typename</span> IfThenElseT&lt;N &lt;=</span><br><span class="line">    std::numeric_limits&lt;<span class="type">short</span>&gt; ::<span class="built_in">max</span>(), <span class="type">short</span>,</span><br><span class="line">    <span class="keyword">typename</span> IfThenElseT&lt;N &lt;=</span><br><span class="line">    std::numeric_limits&lt;<span class="type">int</span>&gt; ::<span class="built_in">max</span>(), <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">typename</span> IfThenElseT&lt;N &lt;=</span><br><span class="line">    std::numeric_limits&lt;<span class="type">long</span>&gt;::<span class="built_in">max</span>(), <span class="type">long</span>,</span><br><span class="line">    <span class="keyword">typename</span> IfThenElseT&lt;N &lt;=</span><br><span class="line">    std::numeric_limits&lt;<span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">max</span>(), <span class="type">long</span> <span class="type">long</span>, <span class="comment">//then</span></span><br><span class="line">    <span class="type">void</span> <span class="comment">//fallback</span></span><br><span class="line">    &gt;::Type</span><br><span class="line">    &gt;::Type</span><br><span class="line">    &gt;::Type</span><br><span class="line">    &gt;::Type</span><br><span class="line">    &gt;::Type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，和常规的C++ if-then-else语句不同，在最终做选择之前，then和else分支中的模板参数都会被计算，因此两个分支中的代码都不能有问题，否则整个程序就会有问题。考虑下面这个例子，一个可以为给定的有符号类型生成与之对应的无符号类型的萃取。已经有一个标准萃取（std::make_unsigned）可以做这件事情，但是它要求传递进来的类型是有符号的整形，而且不能是bool类型；否则它将使用未定义行为的结果。</p>
<p>这一萃取不够安全，因此最好能够实现一个这样的萃取，当可能的时候，它就正常返回相应的无符号类型，否则就原样返回被传递进来的类型（这样，当传递进来的类型不合适时，也能避免触发未定义行为）。下面这个简单的实现是不行的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ERROR: undefined behavior if T is bool or no integral type:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UnsignedT</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = IfThenElse&lt;std::is_integral&lt;T&gt;::value</span><br><span class="line">    &amp;&amp; !std::is_same&lt;T,<span class="type">bool</span>&gt;::value, <span class="keyword">typename</span> std::make_unsigned&lt;T&gt;::type, T&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>因为在实例化<code>UnsingedT&lt;bool&gt;</code>的时候，行为依然是未定义的，编译期依然会试图从下面的代码中生成返回类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> std::make_unsigned&lt;T&gt;::type</span><br></pre></td></tr></table></figure></p>
<p>为了解决这一问题，我们需要再引入一层额外的间接层，从而让IfThenElse的参数本身用类型函数去封装结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// yield T when using member Type:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IdentityT</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// to make unsigned after IfThenElse was evaluated:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MakeUnsignedT</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">typename</span> std::make_unsigned&lt;T&gt;::type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UnsignedT</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">typename</span> IfThenElse&lt;std::is_integral&lt;T&gt;::value</span><br><span class="line">        &amp;&amp; !std::is_same&lt;T,<span class="type">bool</span>&gt;::value,</span><br><span class="line">        MakeUnsignedT&lt;T&gt;,</span><br><span class="line">        IdentityT&lt;T&gt;</span><br><span class="line">    &gt;::Type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这一版UnsignedT的定义中，IfThenElse的类型参数本身也都是类型函数的实例。只不过在最终IfThenElse做出选择之前，类型函数不会真正被计算。而是由IfThenElse选择合适的类型实例（MakeUnsignedT或者IdentityT）。最后由<code>::Type</code>对被选择的类型函数实例进行计算，并生成结果Type。</p>
<p>此处值得强调的是，之所以能够这样做，是因为IfThenElse中未被选择的封装类型永远不会被完全实例化。下面的代码也不能正常工作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UnsignedT</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">typename</span> IfThenElse&lt;std::is_integral&lt;T&gt;::value</span><br><span class="line">    &amp;&amp; !std::is_same&lt;T,<span class="type">bool</span>&gt;::value,</span><br><span class="line">    MakeUnsignedT&lt;T&gt;::Type, </span><br><span class="line">    T</span><br><span class="line">    &gt;::Type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们必须要延后对<code>MakeUnsignedT&lt;T&gt;</code>使用<code>::Type</code>，也就是意味着，我们同样需要为else分支中的T引入IdentyT辅助模板，并同样延后对其使用<code>::Type</code>。</p>
<p>我们同样不能在当前语境中使用如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Identity = <span class="keyword">typename</span> IdentityT&lt;T&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>我们当然可以定义这样一个别名模板，在其它地方它可能也很有用，但是我们唯独不能将其用于<code>IfThenElse</code>的定义中，因为任意对<code>Identity&lt;T&gt;</code>的使用都会立即触发对<code>IdentityT&lt;T&gt;</code>的完全实例化，不然无法获取其Type成员。</p>
<p>在C++标准库中有与IfThenElseT模板对应的模板。使用这一标准库模板实现的UnsignedT萃取如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UnsignedT</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">typename</span> std::<span class="type">conditional_t</span>&lt;std::is_integral&lt;T&gt;::value</span><br><span class="line">        &amp;&amp; !std::is_same&lt;T,<span class="type">bool</span>&gt;::value,</span><br><span class="line">        MakeUnsignedT&lt;T&gt;,</span><br><span class="line">        IdentityT&lt;T&gt;</span><br><span class="line">    &gt;::Type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="探测不抛出异常的操作"><a href="#探测不抛出异常的操作" class="headerlink" title="探测不抛出异常的操作"></a>探测不抛出异常的操作</h3><p>我们可能偶尔会需要判断某一个操作会不会抛出异常。比如，在可能的情况下，移动构造函数应当被标记成noexcept的，意思是它不会抛出异常。但是，某一特定class的move constructor是否会抛出异常，通常决定于其成员或者基类的移动构造函数会不会抛出异常。</p>
<p>比如对于下面这个简单类模板（Pair）的移动构造函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pair</span>(Pair&amp;&amp; other)</span><br><span class="line">    : <span class="built_in">first</span>(std::forward&lt;T1&gt;(other.first)),</span><br><span class="line">    <span class="built_in">second</span>(std::forward&lt;T2&gt;(other.second)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当T1或者T2的移动操作会抛出异常时，Pair的移动构造函数也会抛出异常。如果有一个叫做IsNothrowMoveConstructibleT的萃取，就可以在Pair的移动构造函数中通过使用noexcept将这一异常的依赖关系表达出来：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Pair</span>(Pair&amp;&amp; other)</span><br><span class="line"><span class="built_in">noexcept</span>(IsNothrowMoveConstructibleT&lt;T1&gt;::value &amp;&amp;</span><br><span class="line">IsNothrowMoveConstructibleT&lt;T2&gt;::value)</span><br><span class="line">: <span class="built_in">first</span>(std::forward&lt;T1&gt;(other.first)),</span><br><span class="line"><span class="built_in">second</span>(std::forward&lt;T2&gt;(other.second))</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在剩下的事情就是去实现<code>IsNothrowMoveConstructibleT</code>萃取了。我们可以直接用noexcept运算符实现这一萃取，这样就可以判断一个表达式是否被进行nothrow修饰了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// for declval</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// for bool_constant</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsNothrowMoveConstructibleT</span></span><br><span class="line">: std::bool_constant&lt;<span class="built_in">noexcept</span>(<span class="built_in">T</span>(std::<span class="built_in">declval</span>&lt;T&gt;()))&gt;</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里使用了运算符版本的noexcept，它会判断一个表达式是否会抛出异常。由于其结果是bool型的，我们可以直接将它用于<code>std::bool_constant&lt;&gt;</code>基类的定义（<code>std::bool_constant</code>也被用来定义<code>std::true_type</code>和<code>std::false_type</code>）。</p>
<p>但是该实现还应该被继续优化，因为它不是SFINAE友好的：如果它被一个没有可用移动或者拷贝构造函数的类型（这样表达式<code>T(std::declval&lt;T&amp;&amp;&gt;())</code>就是无效的）实例化，整个程序就会遇到问题：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">E</span>(E&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line">... </span><br><span class="line">std::cout &lt;&lt; IsNothrowMoveConstructibleT&lt;E&gt;::value; <span class="comment">// compiletime ERROR</span></span><br></pre></td></tr></table></figure></p>
<p>在这种情况下，我们所期望的并不是让整个程序奔溃，而是获得一个false类型的值。就像在第19.4.4节介绍的那样，在真正做计算之前，必须先对被用来计算结果的表达式的有效性进行判断。在这里，我们要在检查移动构造函数是不是noexcept之前，先对其有效性进行判断。因此，我们要重写之前的萃取实现，给其增加一个默认值是void的模板参数，并根据移动构造函数是否可用对其进行偏特化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// for declval</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// for true_type, false_type, and bool_constant&lt;&gt;</span></span></span><br><span class="line"><span class="comment">// primary template:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = std::<span class="type">void_t</span>&lt;&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> IsNothrowMoveConstructibleT : std::false_type</span><br><span class="line">&#123; &#125;;</span><br><span class="line"><span class="comment">// partial specialization (may be SFINAE&quot;d away):</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsNothrowMoveConstructibleT</span>&lt;T,</span><br><span class="line">std::<span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(<span class="built_in">T</span>(std::<span class="built_in">declval</span>&lt;T&gt;()))&gt;&gt;</span><br><span class="line">: std::bool_constant&lt;<span class="built_in">noexcept</span>(<span class="built_in">T</span>(std::<span class="built_in">declval</span>&lt;T&gt;()))&gt;</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果在偏特化中对<code>std::void_t&lt;...&gt;</code>的替换有效，那么就会选择该偏特化实现，在其父类中的<code>noexcept(...)</code>表达式也可以被安全的计算出来。否则，偏特化实现会被丢弃（也不会对其进行实例化），被实例化的也将是主模板（产生一个<code>std::false_type</code>的返回值）。</p>
<p>值得注意的是，除非真正能够调用移动构造函数，否则我们无法判断移动构造函数是不是会抛出异常。也就是说，移动构造函数仅仅是public和未被标识为delete的还不够，还要求对应的类型不能是抽象类（但是抽象类的指针或者引用却可以）。因此，该类型萃取被命名为<code>IsNothrowMoveConstructible</code>，而不是<code>HasNothrowMoveConstructor</code>。对于其它所有的情况，我们都需要编译期支持。</p>
<h3 id="萃取的便捷性"><a href="#萃取的便捷性" class="headerlink" title="萃取的便捷性"></a>萃取的便捷性</h3><p>一个关于萃取的普遍不满是它们相对而言有些繁琐，因为对类型萃取的使用通需要提供一个<code>::Type</code>尾缀，而且在依赖上下文中（dependent context），还需要一个typename前缀，两者几成范式。当同时使用多个类型萃取时，会让代码形式变得很笨拙，就如同在我们的operator+例子中一样，如果想正确的对其进行实现，需要确保不会返回const或者引用类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">Array&lt; <span class="keyword">typename</span> RemoveCVT&lt;<span class="keyword">typename</span> RemoveReferenceT&lt;<span class="keyword">typename</span></span><br><span class="line">PlusResultT&lt;T1, T2&gt;::Type &gt;::Type &gt;::Type&gt;</span><br><span class="line"><span class="keyword">operator</span>+ (Array&lt;T1&gt; <span class="type">const</span>&amp;, Array&lt;T2&gt; <span class="type">const</span>&amp;);</span><br></pre></td></tr></table></figure></p>
<p>通过使用别名模板（alias templates）和变量模板（variable templates），可以让对产生类型或者数值的萃取的使用变得很方便。但是也需要注意，在某些情况下这一简便方式并不使用，我们依然要使用最原始的类模板。我们已经讨论过一个这一类的例子（MemberPointerToIntT），但是更详细的讨论还在后面。</p>
<h4 id="别名模板和萃取"><a href="#别名模板和萃取" class="headerlink" title="别名模板和萃取"></a>别名模板和萃取</h4><p>别名模板为降低代码繁琐性提供了一种方法。相比于将类型萃取表达成一个包含了Type类型成员的类模板，我们可以直接使用别名模板。比如，下面的三个别名模板封装了之前的三种类型萃取：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> RemoveCV = <span class="keyword">typename</span> RemoveCVT&lt;T&gt;::Type;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> RemoveReference = <span class="keyword">typename</span> RemoveReferenceT&lt;T&gt;::Type;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">using</span> PlusResult = <span class="keyword">typename</span> PlusResultT&lt;T1, T2&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>有了这些别名模板，我们可以将operator+的声明简化成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">Array&lt;RemoveCV&lt;RemoveReference&lt;PlusResultT&lt;T1, T2&gt;&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">operator</span>+ (Array&lt;T1&gt; <span class="type">const</span>&amp;, Array&lt;T2&gt; <span class="type">const</span>&amp;);</span><br></pre></td></tr></table></figure></p>
<p>这一版本的实现明显更简洁，也让人更容易分辨其组成。这一特性使得别名模板非常适用于某些类型萃取。</p>
<p>但是，将别名模板用于类型萃取也有一些缺点：</p>
<ol>
<li>别名模板不能够被进行特化，但是由于很多编写萃取的技术都依赖于特化，别名模板最终可能还是需要被重新导向到类模板。</li>
<li>有些萃取是需要由用户进行特化的，比如描述了一个求和运算符是否是可交换的萃取，此时在很多使用都用到了别名模板的情况下，对类模板进行特换会很让人困惑。</li>
<li>对别名模板的使用最会让该类型被实例化（比如，底层类模板的特化），这样对于给定类型我们就很难避免对其进行无意义的实例化。对最后一点的另外一种表述方式是，别名模板不可以和元函数转发一起使用。</li>
</ol>
<h4 id="变量模板和萃取"><a href="#变量模板和萃取" class="headerlink" title="变量模板和萃取"></a>变量模板和萃取</h4><p>对于返回数值的萃取需要使用一个::value（或者类似的成员）来生成萃取的结果。在这种情况下，constexpr修饰的变量模板提供了一种简化代码的方法。比如，下面的变量模板封装了IsSameT萃取和IsConvertibleT萃取：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> IsSame = IsSameT&lt;T1,T2&gt;::value;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FROM, <span class="keyword">typename</span> TO&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> IsConvertible = IsConvertibleT&lt;FROM, TO&gt;::value;</span><br></pre></td></tr></table></figure></p>
<p>此时我们可以将这一类代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IsSameT&lt;T,<span class="type">int</span>&gt;::value || IsConvertibleT&lt;T,<span class="type">char</span>&gt;::value) ...</span><br></pre></td></tr></table></figure></p>
<p>简化成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IsSame&lt;T,<span class="type">int</span>&gt; || IsConvertible&lt;T,<span class="type">char</span>&gt;) ...</span><br></pre></td></tr></table></figure></p>
<h2 id="类型分类"><a href="#类型分类" class="headerlink" title="类型分类"></a>类型分类</h2><p>如果能够知道一个模板参数的类型是内置类型，指针类型，class类型，或者是其它什么类型，将会很有帮助。在接下来的章节中，我们定义了一组类型萃取，通过它们我们可以判断给定类型的各种特性。这样我们就可以单独为特定的某些类型编写代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IsClassT&lt;T&gt;::value) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者是将其用于编译期if以及某些为了萃取的便利性而引入的特性：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(IsClass&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者时将其用于偏特化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">bool</span> = IsClass&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> C &#123; <span class="comment">//primary template for the general case</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;T, <span class="literal">true</span>&gt; &#123; <span class="comment">//partial specialization for class types</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>此外，诸如<code>IsPointerT&lt;T&gt;::value</code>一类的表达式的结果是bool型常量，因此它们也将是有效的非类型模板参数。这样，就可以构造更为高端和强大的模板，这些模板可以被基于它们的类型参数的特性进行特化。</p>
<h3 id="判断基础类型"><a href="#判断基础类型" class="headerlink" title="判断基础类型"></a>判断基础类型</h3><p>作为开始，我们先定义一个可以判断某个类型是不是基础类型的模板。默认情况下，我们认为类型不是基础类型，而对于基础类型，我们分别进行了特化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span> <span class="comment">// for nullptr_t</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// for true_type, false_type, and bool_constant&lt;&gt;</span></span></span><br><span class="line"><span class="comment">// primary template: in general T is not a fundamental type template&lt;typename T&gt;</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsFundaT</span> : std::false_type &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// macro to specialize for fundamental types</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MK_FUNDA_TYPE(T) \</span></span><br><span class="line"><span class="meta">    template<span class="string">&lt;&gt;</span> struct IsFundaT<span class="string">&lt;T&gt;</span> : std::true_type &#123; \</span></span><br><span class="line"><span class="meta">&#125;;</span></span><br><span class="line"><span class="built_in">MK_FUNDA_TYPE</span>(<span class="type">void</span>)</span><br><span class="line"><span class="built_in">MK_FUNDA_TYPE</span>(<span class="type">bool</span>)</span><br><span class="line"><span class="built_in">MK_FUNDA_TYPE</span>(<span class="type">char</span>)</span><br><span class="line"><span class="built_in">MK_FUNDA_TYPE</span>(<span class="type">signed</span> <span class="type">char</span>)</span><br><span class="line"><span class="built_in">MK_FUNDA_TYPE</span>(<span class="type">unsigned</span> <span class="type">char</span>)</span><br><span class="line"><span class="built_in">MK_FUNDA_TYPE</span>(<span class="type">wchar_t</span>)</span><br><span class="line"><span class="built_in">MK_FUNDA_TYPE</span>(<span class="type">char16_t</span>)</span><br><span class="line"><span class="built_in">MK_FUNDA_TYPE</span>(<span class="type">char32_t</span>)</span><br><span class="line"><span class="built_in">MK_FUNDA_TYPE</span>(<span class="type">signed</span> <span class="type">short</span>)</span><br><span class="line"><span class="built_in">MK_FUNDA_TYPE</span>(<span class="type">unsigned</span> <span class="type">short</span>)</span><br><span class="line"><span class="built_in">MK_FUNDA_TYPE</span>(<span class="type">signed</span> <span class="type">int</span>)</span><br><span class="line"><span class="built_in">MK_FUNDA_TYPE</span>(<span class="type">unsigned</span> <span class="type">int</span>)</span><br><span class="line"><span class="built_in">MK_FUNDA_TYPE</span>(<span class="type">signed</span> <span class="type">long</span>)</span><br><span class="line"><span class="built_in">MK_FUNDA_TYPE</span>(<span class="type">unsigned</span> <span class="type">long</span>)</span><br><span class="line"><span class="built_in">MK_FUNDA_TYPE</span>(<span class="type">signed</span> <span class="type">long</span> <span class="type">long</span>)</span><br><span class="line"><span class="built_in">MK_FUNDA_TYPE</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)</span><br><span class="line"><span class="built_in">MK_FUNDA_TYPE</span>(<span class="type">float</span>)</span><br><span class="line"><span class="built_in">MK_FUNDA_TYPE</span>(<span class="type">double</span>)</span><br><span class="line"><span class="built_in">MK_FUNDA_TYPE</span>(<span class="type">long</span> <span class="type">double</span>)</span><br><span class="line"><span class="built_in">MK_FUNDA_TYPE</span>(std::<span class="type">nullptr_t</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> MK_FUNDA_TYPE</span></span><br></pre></td></tr></table></figure></p>
<p>主模板定义了常规情况。也就是说，通常而言<code>IfFundaT&lt;T&gt;::value</code>会返回false：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsFundaT</span> : std::false_type &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于每一种基础类型，我们都进行了特化，因此<code>IsFundaT&lt;T&gt;::value</code>的结果也都会返回true。为了简单，我们定义了一个可以扩展成所需代码的宏。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MK_FUNDA_TYPE</span>(<span class="type">bool</span>)</span><br></pre></td></tr></table></figure></p>
<p>会扩展成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">IsFundaT</span>&lt;<span class="type">bool</span>&gt; : std::true_type &#123;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面的例子展示了该模板的一种可能的应用场景：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;isfunda.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span> <span class="params">(T <span class="type">const</span>&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsFundaT&lt;T&gt;::value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;T is a fundamental type&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;T is not a fundamental type&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>(<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">test</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其输出如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T is a fundamental type</span><br><span class="line">T is <span class="keyword">not</span> a fundamental type</span><br></pre></td></tr></table></figure></p>
<p>采用同样会的方式，我们也可以定义类型函数IsIntegralT和IsFloatingT来区分哪些类型是整形标量类型以及浮点型标量类型。</p>
<p>C++标准库采用了一种更为细粒度的方法来测试一个类型是不是基础类型。它先定义了主要的类型种类，每一种类型都被匹配到一个相应的种类，然后合成诸如<code>std::is_integral</code>和<code>std::is_fundamental</code>类型种类。</p>
<h3 id="判断复合类型"><a href="#判断复合类型" class="headerlink" title="判断复合类型"></a>判断复合类型</h3><p>复合类型是由其它类型构建出来的类型。简单的复合类型包含指针类型，左值以及右值引用类型，指向成员的指针类型（pointer-to-member types），和数组类型。它们是由一种或者两种底层类型构造的。Class类型以及函数类型同样也是复合类型，但是它们可能是由任意数量的类型组成的。在这一分类方法中，枚举类型同样被认为是复杂的符合类型，虽然它们不是由多种底层类型构成的。简单的复合类型可以通过偏特化来区分。</p>
<p>我们从指针类型这一简单的分类开始：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsPointerT</span> : std::false_type &#123; <span class="comment">//primary template: by default not a pointer</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsPointerT</span>&lt;T*&gt; : std::true_type &#123; <span class="comment">//partial specialization for pointers</span></span><br><span class="line">    <span class="keyword">using</span> BaseT = T; <span class="comment">// type pointing to</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>主模板会捕获所有的非指针类型，和往常一样，其值为fase的value成员是通过基类<code>std::false_type</code>提供的，表明该类型不是指针。偏特化实现会捕获所有的指针类型（<code>T*</code>），其为true的成员value表明该类型是一个指针。偏特化实现还额外提供了类型成员<code>BaseT</code>，描述了指针所指向的类型。注意该类型成员只有在原始类型是指针的时候才有，从其使其变成SFINAE友好的类型萃取。</p>
<p>C++标准库也提供了相对应的萃取<code>std::is_pointer&lt;&gt;</code>，但是没有提供一个成员类型来描述指针所指向的类型。</p>
<p>相同的方法也可以被用来识别左值引用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsLValueReferenceT</span> : std::false_type &#123; <span class="comment">//by default no lvalue reference</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsLValueReferenceT</span>&lt;T&amp;&gt; : std::true_type &#123; <span class="comment">//unless T is lvalue references</span></span><br><span class="line"><span class="keyword">using</span> BaseT = T; <span class="comment">// type referring to</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以及右值引用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsRValueReferenceT</span> : std::false_type &#123; <span class="comment">//by default no rvalue reference</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsRValueReferenceT</span>&lt;T&amp;&amp;&gt; : std::true_type &#123; <span class="comment">//unless T is rvalue reference</span></span><br><span class="line">    <span class="keyword">using</span> BaseT = T; <span class="comment">// type referring to</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>它俩又可以被组合成<code>IsReferenceT&lt;&gt;</code>萃取：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;islvaluereference.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;isrvaluereference.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ifthenelse.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IsReferenceT</span></span><br><span class="line">: <span class="keyword">public</span> IfThenElseT&lt;IsLValueReferenceT&lt;T&gt;::value,</span><br><span class="line">        IsLValueReferenceT&lt;T&gt;,</span><br><span class="line">        IsRValueReferenceT&lt;T&gt;</span><br><span class="line">    &gt;::Type &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这一实现中，我们用<code>IfThenElseT</code>从<code>ISLvalueReference&lt;T&gt;</code>和<code>IsRValueReferenceT&lt;T&gt;</code>中选择基类，这里还用到了元函数转发。如果T是左值引用，我们会从<code>IsLReference&lt;T&gt;</code>做继承，并通过继承得到相应的value和BaseT成员。否则，我们就从<code>IsRValueReference&lt;T&gt;</code>做继承，它会判断一个类型是不是右值引用。</p>
<p>C++标准库也提供了相应的<code>std::is_lvalue_reference&lt;&gt;</code>和<code>std::is_rvalue_reference&lt;&gt;</code>萃取，还有<code>std::is_reference&lt;&gt;</code>。同样的，这些萃取也没有提供代表其所引用的类型的类型成员。</p>
<p>在定义可以判断数组的萃取时，让人有些意外的是偏特化实现中的模板参数数量要比主模板多：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsArrayT</span> : std::false_type &#123; <span class="comment">//primary template: not an array</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsArrayT</span>&lt;T[N]&gt; : std::true_type &#123; <span class="comment">//partial specialization for arrays</span></span><br><span class="line">    <span class="keyword">using</span> BaseT = T;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> std::<span class="type">size_t</span> size = N;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsArrayT</span>&lt;T[]&gt; : std::true_type &#123; <span class="comment">//partial specialization for unbound arrays</span></span><br><span class="line">    <span class="keyword">using</span> BaseT = T;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> std::<span class="type">size_t</span> size = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这里，多个额外的成员被用来描述被用来分类的数组的信息：数组的基本类型和大小（被用来标识未知大小的数组的尺寸）。</p>
<p>C++标准库提供了相应的<code>std::is_array&lt;&gt;</code>来判断一个类型是不是数组。除此之外，诸如<code>std::rank&lt;&gt;</code>和<code>std::extent&lt;&gt;</code>之类的萃取还允许我们去查询数组的维度以及某个维度的大小。</p>
<p>也可以用相同的方式处理指向成员的指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsPointerToMemberT</span> : std::false_type &#123; <span class="comment">//by default no pointer-to-member</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsPointerToMemberT</span>&lt;T C::*&gt; : std::true_type &#123; <span class="comment">//partial specialization</span></span><br><span class="line">    <span class="keyword">using</span> MemberT = T;</span><br><span class="line">    <span class="keyword">using</span> ClassT = C;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里额外的成员（MemberT和ClassT）提供了与成员的类型以及class的类型相关的信息。 C++标准库提供了更为具体的萃取，<code>std::is_member_object_pointer&lt;&gt;</code>和<code>std::is_member_function_pointer&lt;&gt;</code>，<code>std::is_member_pointer&lt;&gt;</code>。</p>
<h3 id="识别函数类型"><a href="#识别函数类型" class="headerlink" title="识别函数类型"></a>识别函数类型</h3><p>函数类型比较有意思，因为它们除了返回类型，还可能会有任意数量的参数。因此，在匹配一个函数类型的偏特化实现中，我们用一个参数包来捕获所有的参数类型，就如同我们在对<code>DecayT</code>所做的那样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../typelist/typelist.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsFunctionT</span> : std::false_type &#123; <span class="comment">//primary template: no function</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsFunctionT</span>&lt;<span class="built_in">R</span> (Params...)&gt; : std::true_type</span><br><span class="line">&#123; <span class="comment">//functions</span></span><br><span class="line">    <span class="keyword">using</span> Type = R;</span><br><span class="line">    <span class="keyword">using</span> ParamsT = Typelist&lt;Params...&gt;;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> variadic = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsFunctionT</span>&lt;<span class="built_in">R</span> (Params..., ...)&gt; : std::true_type &#123; <span class="comment">//variadic functions</span></span><br><span class="line">    <span class="keyword">using</span> Type = R;</span><br><span class="line">    <span class="keyword">using</span> ParamsT = Typelist&lt;Params...&gt;;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> variadic = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上述实现中函数类型的每一部分都被暴露了出来：返回类型被Type标识，所有的参数都被作为ParamsT捕获进了一个typelist中（在第24章有关于typelist的介绍），而可变参数（…）表示的是当前函数类型使用的是不是C风格的可变参数。</p>
<p>不幸的是，这一形式的IsFunctionT并不能处理所有的函数类型，因为函数类型还可以包含const和volatile修饰符，以及左值或者右值引用修饰符，在C++17之后，还有noexcept修饰符。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MyFuncType = <span class="built_in">void</span> (<span class="type">int</span>&amp;) <span class="type">const</span>;</span><br></pre></td></tr></table></figure></p>
<p>这一类函数类型只有在被用于非static成员函数的时候才有意义，但是不管怎样都算得上是函数类型。而且，被标记为const的函数类型并不是真正意义上的const类型，因此RemoveConst并不能将const从函数类型中移除。因此，为了识别有限制符的函数类型，我们需要引入一大批额外的偏特化实现，来覆盖所有可能的限制符组合（每一个实现都需要包含C风格和非C风格的可变参数情况）。这里，我们只展示所有偏特化实现中的5中情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsFunctionT</span>&lt;<span class="built_in">R</span> (Params...) <span class="type">const</span>&gt; : std::true_type &#123;</span><br><span class="line"><span class="keyword">using</span> Type = R;</span><br><span class="line"><span class="keyword">using</span> ParamsT = Typelist&lt;Params...&gt;;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> variadic = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsFunctionT</span>&lt;<span class="built_in">R</span> (Params..., ...) <span class="keyword">volatile</span>&gt; : std::true_type &#123;</span><br><span class="line"><span class="keyword">using</span> Type = R;</span><br><span class="line"><span class="keyword">using</span> ParamsT = Typelist&lt;Params...&gt;;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> variadic = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsFunctionT</span>&lt;<span class="built_in">R</span> (Params..., ...) <span class="type">const</span> <span class="keyword">volatile</span>&gt; : std::true_type &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = R;</span><br><span class="line">    <span class="keyword">using</span> ParamsT = Typelist&lt;Params...&gt;;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> variadic = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsFunctionT</span>&lt;<span class="built_in">R</span> (Params..., ...) &amp;&gt; : std::true_type &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = R;</span><br><span class="line">    <span class="keyword">using</span> ParamsT = Typelist&lt;Params...&gt;;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> variadic = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsFunctionT</span>&lt;<span class="built_in">R</span> (Params..., ...) <span class="type">const</span>&amp;&gt; : std::true_type &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = R;</span><br><span class="line">    <span class="keyword">using</span> ParamsT = Typelist&lt;Params...&gt;;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> variadic = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当所有这些都准备完毕之后，我们就可以识别除class类型和枚举类型之外的所有类型了。我们会在接下来的章节中除了这两种例外情况。C++标准库也提供了相应的<code>std::is_function&lt;&gt;</code>萃取。</p>
<h3 id="判断class类型"><a href="#判断class类型" class="headerlink" title="判断class类型"></a>判断class类型</h3><p>和到目前为止我们已经处理的各种复合类型不同，我们没有相应的偏特化模式来专门匹配class类型。也不能像处理基础类型一样一一列举所有的class类型。相反，我们需要用一种间接的方法来识别class类型，为此我们需要找出一些适用于所有class类型的类型或者表达式（但是不能适用于其它类型）。</p>
<p>Class中可以被我们用来识别class类型的最为方便的特性是：只有class类型可以被用于指向成员的指针类型（pointer-to-member types）的基础。也就是说，对于<code>X Y::*</code>一类的类型结构，Y只能是class类型。下面的<code>IsClassT&lt;&gt;</code>就利用了这一特性（将X随机选择为int）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = std::<span class="type">void_t</span>&lt;&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> IsClassT : std::false_type &#123; <span class="comment">//primary template: by default no</span></span><br><span class="line"><span class="keyword">class</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsClassT</span>&lt;T, std::<span class="type">void_t</span>&lt;<span class="type">int</span> T::*&gt;&gt; <span class="comment">// classes can have pointer-to-member</span></span><br><span class="line">: std::true_type &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>C++语言规则指出，lambda表达式的类型是“唯一的，未命名的，非枚举class类型”。因此在将<code>IsClassT</code>萃取用于lambda表达时，我们得到的结果是true：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> l = []&#123;&#125;;</span><br><span class="line"><span class="keyword">static_assert</span>&lt;IsClassT&lt;<span class="keyword">decltype</span>(l)&gt;::value, <span class="string">&quot;&quot;</span>&gt;; <span class="comment">//succeeds</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，<code>int T::*</code>表达式同样适用于unit类型（更具C++标准，枚举类型也是class类型）。</p>
<p>C++标准库提供了<code>std::is_class&lt;&gt;</code>和<code>std::is_union</code>萃取。但是，这些萃取需要编译期进行专门的支持，因为目前还不能通过任何核心的语言技术（standard core language techniques）将class和struct从union类型中分辨出来。</p>
<h3 id="识别枚举类型"><a href="#识别枚举类型" class="headerlink" title="识别枚举类型"></a>识别枚举类型</h3><p>目前通过我们已有的萃取技术还唯一不能识别的类型是枚举类型。我们可以通过编写基于SFINAE的萃取来实现这一功能，这里首先需要测试是否可以像整形类型（比如int）进行显式转换，然后依次排除基础类型，class类型，引用类型，指针类型，还有指向成员的指针类型（这些类型都可以被转换成整形类型，但是都不是枚举类型）。但是也有更简单的方法，因为我们发现所有不属于其它任何一种类型的类型就是枚举类型，这样就可以像下面这样实现该萃取：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsEnumT</span> &#123;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = !IsFundaT&lt;T&gt;::value</span><br><span class="line">    &amp;&amp; !IsPointerT&lt;T&gt;::value &amp;&amp;</span><br><span class="line">    !IsReferenceT&lt;T&gt;::value</span><br><span class="line">    &amp;&amp; !IsArrayT&lt;T&gt;::value &amp;&amp;</span><br><span class="line">    !IsPointerToMemberT&lt;T&gt;::value</span><br><span class="line">    &amp;&amp; !IsFunctionT&lt;T&gt;::value &amp;&amp;</span><br><span class="line">    !IsClassT&lt;T&gt;::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>C++标准库提供了相对应的<code>std::is_enum&lt;&gt;</code>萃取。通常，为了提高编译性能，编译期会直接提供这一类萃取，而不是将其实现为其它的样子。</p>
<h2 id="策略萃取（Policy-Traits）"><a href="#策略萃取（Policy-Traits）" class="headerlink" title="策略萃取（Policy Traits）"></a>策略萃取（Policy Traits）</h2><p>到目前为止，我们例子中的萃取模板被用来判断模板参数的特性：它们代表的是哪一种类型，作用于该类型数值的操作符的返回值的类型，以及其它特性。这一类萃取被称为特性萃取（property traits）。</p>
<p>最为对比，某些萃取定义的是该如何处理某些类型。我们称之为策略萃取（policy traits）。这里会对之前介绍的策略类（policy class，我们已经指出，策略类和策略萃取之间的界限并不青霞）的概念进行回顾，但是策略萃取更倾向于是模板参数的某一独有特性（而策略类却通常和其它模板参数无关）。</p>
<p>虽然特性萃取通常都可以被实现为类型函数，策略萃取却通常将策略包装进成员函数中。为了展示这一概念，先来看一下一个定义了特定策略（必须传递只读参数）的类型函数。</p>
<h3 id="只读参数类型"><a href="#只读参数类型" class="headerlink" title="只读参数类型"></a>只读参数类型</h3><p>在C++和C中，函数的调用参数（call parameters）默认情况下是按照值传递的。这意味着，调用函数计算出来的参数的值，会被拷贝到由被调用函数控制的位置。对于比较大的结构体，这一拷贝的成本会非常高，因此对于这一类结构体最好能够将其按照常量引用（reference-to-const）或者是C中的常量指针（pointer-to-const）进行传递。对于小的结构体，到底该怎样实现目前还没有定论，从性能的角度来看，最好的机制依赖于代码所运行的具体架构。在大多数情况下这并没有那么关键，但是某些情况下，即使是对小的结构体我们也要仔细应对。</p>
<p>正如之前暗示的那样，这一类问题通常应当用策略萃取模板（一个类型函数）来处理：该函数将预期的参数类型T映射到最佳的参数类型T或者是T const&amp;。作为第一步的近似，主模板会将大小不大于两个指针的类型按值进行传递，对于其它所有类型都按照常量引用进行传递：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RParam</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">typename</span> IfThenElseT&lt;<span class="built_in">sizeof</span>(T) &lt;=<span class="number">2</span>*<span class="built_in">sizeof</span>(<span class="type">void</span>*),</span><br><span class="line">        T,</span><br><span class="line">        T <span class="type">const</span>&amp;&gt;::Type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>另一方面，对于那些另sizeof运算符返回一个很小的值，但是拷贝构造函数成本却很高的容器类型，我们可能需要分别对它们进行特化或者偏特化，就像下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RParam</span>&lt;Array&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = Array&lt;T&gt; <span class="type">const</span>&amp;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由于这一类类型在C++中很常见，如果只将那些拥有简单拷贝以及移动构造函数的类型按值进行传递，当需要考虑性能因素时，再选择性的将其它一些class类型加入按值传递的行列（C++标准库中包含了<code>std::is_trivially_copy_constructible</code>和<code>std::is_trivially_move_constructible</code>类型萃取）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RPARAM_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RPARAM_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ifthenelse.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RParam</span> &#123;</span><br><span class="line"><span class="keyword">using</span> Type = IfThenElse&lt;(<span class="built_in">sizeof</span>(T) &lt;= <span class="number">2</span>*<span class="built_in">sizeof</span>(<span class="type">void</span>*)</span><br><span class="line">    &amp;&amp; std::is_trivially_copy_constructible&lt;T&gt;::value</span><br><span class="line">    &amp;&amp; std::is_trivially_move_constructible&lt;T&gt;::value),</span><br><span class="line">    T,</span><br><span class="line">    T <span class="type">const</span>&amp;&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//RPARAM_HPP</span></span></span><br></pre></td></tr></table></figure></p>
<p>无论采用哪一种方式，现在该策略都可以被集成到萃取模板的定义中，客户也可以用它们去实现更好的效果。比如，假设我们有两个class，对于其中一个class我们指明要按值传递只读参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rparam.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass1</span> () &#123;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="built_in">MyClass1</span> (MyClass1 <span class="type">const</span>&amp;) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MyClass1 copy constructor called\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass2</span> () &#123; &#125; </span><br><span class="line">    <span class="built_in">MyClass2</span> (MyClass2 <span class="type">const</span>&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass2 copy constructor called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// pass MyClass2 objects with RParam&lt;&gt; by value</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RParam</span>&lt;MyClass2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = MyClass2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在，我们就可以定义将<code>PParam&lt;&gt;</code>用于只读参数的函数了，并对其进行调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rparam.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rparamcls.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// function that allows parameter passing by value or by reference</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span> <span class="params">(<span class="keyword">typename</span> RParam&lt;T1&gt;::Type p1, <span class="keyword">typename</span> RParam&lt;T2&gt;::Type p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass1 mc1;</span><br><span class="line">    MyClass2 mc2;</span><br><span class="line">    <span class="built_in">foo</span>&lt;MyClass1,MyClass2&gt;(mc1,mc2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不幸的是，<code>PParam</code>的使用有一些很大的缺点。第一，函数的声明很凌乱。第二，可能也是更有异议的地方，就是在调用诸如<code>foo()</code>一类的函数时不能使用参数推断，因为模板参数只出现在函数参数的限制符中。因此在调用时必须显式的指明所有的模板参数。一个稍显笨拙的权宜之计是：使用提供了完美转发的inline封装函数（inline wrapper function），但是需要假设编译器将省略inline函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rparam.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rparamcls.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// function that allows parameter passing by value or by reference</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_core</span> <span class="params">(<span class="keyword">typename</span> RParam&lt;T1&gt;::Type p1, <span class="keyword">typename</span> RParam&lt;T2&gt;::Type p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// wrapper to avoid explicit template parameter passing</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span> <span class="params">(T1 &amp;&amp; p1, T2 &amp;&amp; p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo_core</span>&lt;T1,T2&gt;(std::forward&lt;T1&gt;(p1),std::forward&lt;T2&gt;(p2));</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass1 mc1;</span><br><span class="line">    MyClass2 mc2;</span><br><span class="line">    <span class="built_in">foo</span>(mc1,mc2); <span class="comment">// same as foo_core&lt;MyClass1,MyClass2&gt; (mc1,mc2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="在标准库中的情况"><a href="#在标准库中的情况" class="headerlink" title="在标准库中的情况"></a>在标准库中的情况</h2><p>在C++11中，类型萃取变成了C++标准库中固有的一部分。它们或多或少的构成了在本章中讨论的所有的类型函数和类型萃取。但是，对于它们中的一部分，比如个别的操作探测，以及有过讨论的<code>std::is_union</code>，目前都还没有已知的语言解决方案。而是由编译器为这些萃取提供了支持。同样的，编译器也开始支持一些已经由语言本身提供了解决方案的萃取，这主要是为了减少编译时间。</p>
<p>C++标准库也定义了一些策略和属性萃取：</p>
<ul>
<li>类模板<code>std::char_traits</code>被<code>std::string</code>和I/O stream当作策略萃取使用。</li>
<li>为了将算法简单的适配于标准迭代器的种类，标准库提供了一个很简单的<code>std::iterator_traits</code>属性萃取模板。</li>
<li>模板<code>std::numeric_limits</code>作为属性萃取模板也会很有帮助。</li>
<li>最后，为标准库容器类型进行的内存分配是由策略萃取类处理的（参见<code>std::shared_ptr</code>的实现）。从C++98开始，标准库专门为了这一目的提供了<code>std::allocator</code>模板。从C++11开始，标准库引入了<code>std::allocator_traits</code>模板，这样就能够修改内存分配器的策略或者行为了。</li>
</ul>
<h1 id="基于类型属性的重载"><a href="#基于类型属性的重载" class="headerlink" title="基于类型属性的重载"></a>基于类型属性的重载</h1><p>函数重载使得相同的函数名能够被多个函数使用，只要能够通过这些函数的参数类型区分它们就行。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(<span class="type">char</span> <span class="type">const</span>*)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>对于函数模板，可以在类型模式上进行重载，比如针对指向T的指针或者<code>Array&lt;T&gt;</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(Array&lt;T&gt;)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>在类型萃取的概念流行起来之后，很自然地会想到基于模板参数对函数模板进行重载。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Number&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(Number)</span></span>; <span class="comment">// only for numbers</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(Container)</span></span>;<span class="comment">// only for containers</span></span><br></pre></td></tr></table></figure></p>
<p>但是，目前C++还没有提供任何可以直接基于类型属性进行重载的方法。事实上，上面的两个模板声明的是完全相同的函数模板，而不是进行了重载，因为在比较两个函数模板的时候不会比较模板参数的名字。</p>
<h2 id="算法特化"><a href="#算法特化" class="headerlink" title="算法特化"></a>算法特化</h2><p>函数模板重载的一个动机是，基于算法适用的类型信息，为算法提供更为特化的版本。考虑一个交换两个数值的<code>swap()</code>操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; x, T&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">tmp</span><span class="params">(x)</span></span>;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一实现用到了三次拷贝操作。但是对于某些类型，可以有一种更为高效的<code>swap()</code>实现，比如对于存储了指向具体数组内容的指针和数组长度的<code>Array&lt;T&gt;</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Array&lt;T&gt;&amp; x, Array&lt;T&gt;&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(x.ptr, y.ptr);</span><br><span class="line">    <span class="built_in">swap</span>(x.len, y.len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>俩种<code>swap()</code>实现都可以正确的交换两个<code>Array&lt;T&gt;</code>对象的内容。但是，后一种实现方式的效率要高很多，因为它利用了<code>Array&lt;T&gt;</code>中额外的特性。因此后一种实现方式要（在概念上）比第一种实现方式更为“特化”，这是因为它只为适用于前一种实现的类型的一个子集提供了交换操作。幸运的是，基于函数模板的部分排序规则，第二种函数模板也是更为特化的，在有更为特化的版本（也更高效）可用的时候，编译器会优先选择该版本，在其不适用的时候，会退回到更为泛化的版本（可能会不那么高效）。</p>
<p>对于特定类型的迭代器（比如提供了随机访问操作的迭代器)，我们可以为该操作提供一个更为高效的实现方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> Distance&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advanceIter</span><span class="params">(RandomAccessIterator&amp; x, Distance n)</span> </span>&#123;</span><br><span class="line">    x += n; <span class="comment">// constant time</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是不幸的是，同时定义以上两种函数模板会导致编译错误，正如我们在序言中介绍的那样，这是因为只有模板参数名字不同的函数模板是不可以被重载的。</p>
<h2 id="标记派发（Tag-Dispatching）"><a href="#标记派发（Tag-Dispatching）" class="headerlink" title="标记派发（Tag Dispatching）"></a>标记派发（Tag Dispatching）</h2><p>算法特化的一个方式是，用一个唯一的、可以区分特定变体的类型来标记（tag）不同算法变体的实现。比如为了解决上述<code>advanceIter()</code>中的问题，可以用标准库中的迭代器种类标记类型，来区分<code>advanceIter()</code>算法的两个变体实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Distance&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advanceIterImpl</span><span class="params">(Iterator&amp; x, Distance n,</span></span></span><br><span class="line"><span class="params"><span class="function">std::input_iterator_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123; <span class="comment">//linear time</span></span><br><span class="line">        ++x;</span><br><span class="line">        --n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Distance&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advanceIterImpl</span><span class="params">(Iterator&amp; x, Distance n,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::random_access_iterator_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x += n; <span class="comment">// constant time</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，通过<code>advanceIter()</code>函数模板将其参数连同与之对应的tag一起转发出去：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Distance&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advanceIter</span><span class="params">(Iterator&amp; x, Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">advanceIterImpl</span>(x, n, <span class="keyword">typename</span></span><br><span class="line">    std::iterator_traits&lt;Iterator&gt;::<span class="built_in">iterator_category</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>萃取类模板<code>std::iterator_traits</code>通过其成员类型<code>iterator_category</code>返回了迭代器的种类。迭代器种类是前述<code>_tag</code>类型中的一种，它指明了相关类型的具体迭代器种类。在C++标准库中，可用的tags被定义成了下面这样，在其中使用了继承来反映出一个用tag表述的种类是不是从另一个种类派生出来的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123; &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123; &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : <span class="keyword">public</span> input_iterator_tag &#123; &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> : <span class="keyword">public</span> forward_iterator_tag</span><br><span class="line">    &#123; &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : <span class="keyword">public</span> bidirectional_iterator_tag &#123; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有效使用标记派发（tag dispatching）的关键在于理解tags之间的内在关系。我们用来标记两个advanceIterImpl变体的标记是<code>std::input_iterator_tag</code>和<code>std::random_access_iterator_tag</code>，而由于<code>std::random_access_iterator_tag</code>继承自<code>std::input_iterator_tag</code>，对于随机访问迭代器，会优先选择更为特化的<code>advanceIterImpl()</code>变体（使用了<code>std::random_access_iterator_tag</code>的那一个）。因此，标记派发依赖于将单一的主函数模板的功能委托给一组<code>_impl</code>变体，这些变体都被进行了标记，因此正常的函数重载机制会选择适用于特定模板参数的最为特化的版本。</p>
<p>当被算法用到的特性具有天然的层次结构，并且存在一组为这些标记提供了值的萃取机制的时候，标记派发可以很好的工作。而如果算法特化依赖于专有（ad hoc）类型属性的话（比如依赖于类型T是否含有拷贝赋值运算符），标记派发就没那么方便了。对于这种情况，我们需要一个更强大的技术。</p>
<h2 id="Enable-Disable函数模板"><a href="#Enable-Disable函数模板" class="headerlink" title="Enable/Disable函数模板"></a>Enable/Disable函数模板</h2><p>算法特化需要提供可以基于模板参数的属性进行选择的、不同的函数模板。不幸的是，无论是函数模板的部分排序规则还是重载解析，都不能满足更为高阶的算法特化的要求。C++标准库为之提供的一个辅助工具是<code>std::enable_if</code>。本节将介绍通过引入一个对应的模板别名，实现该辅助工具的方式，为了避免名称冲突，我们将称之称为<code>EnableIf</code>。</p>
<p>和<code>std::enable_if</code>一样，<code>EnableIf</code>模板别名也可以被用来基于特定的条件<code>enable</code>(或<code>disable</code>)特定的函数模板。比如，随机访问版本的<code>advanceIter()</code>算法可以被实现成这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> IsRandomAccessIterator = IsConvertible&lt; <span class="keyword">typename</span> std::iterator_traits&lt;Iterator&gt;::iterator_category, std::random_access_iterator_tag&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line">EnableIf&lt;IsRandomAccessIterator&lt;Iterator&gt;&gt;</span><br><span class="line"><span class="built_in">advanceIter</span>(Iterator&amp; x, Distance n)&#123;</span><br><span class="line">    x += n; <span class="comment">// constant time</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里使用了基于<code>EnableIf</code>的偏特化，在迭代器是随机访问迭代器的时候启用特定的<code>advanceIter()</code>变体。<code>EnableIf</code>包含两个参数，一个是标示着该模板是否应该被启用的bool型条件参数，另一个是在第一个参数为true时，EnableIf应该包含的类型。</p>
<p>EnableIf的实现非常简单：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span>, <span class="keyword">typename</span> T = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> EnableIfT &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EnableIfT</span>&lt;<span class="literal">true</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> Cond, <span class="keyword">typename</span> T = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">using</span> EnableIf = <span class="keyword">typename</span> EnableIfT&lt;Cond, T&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>EnableIf会扩展成一个类型，因此它被实现成了一个别名模板（alias template）。我们希望为之使用偏特化，但是别名模板（alias template）并不能被偏特化。幸运的是，我们可以引入一个辅助类模板（helper class template）EnableIfT，并将真正要做的工作委托给它，而别名模板EnableIf所要做的只是简单的从辅助模板中选择结果类型。当条件是true的时候，<code>EnableIfT&lt;...&gt;::Type</code>（也就是<code>EnableIf&lt;...&gt;</code>）的计算结果将是第二个模板参数T。当条件是false的时候，<code>EnableIf</code>不会生成有效的类型，因为主模板<code>EnableIfT</code>没有名为Type的成员。通常这应该是一个错误，但是在SFINAE中它只会导致模板参数推断失败，并将函数模板从待选项中移除。</p>
<p>对于<code>advanceIter()</code>，<code>EnableIf</code>的使用意味着只有当<code>Iterator</code>参数是随机访问迭代器的时候，函数模板才可以被使用（而且返回类型是void），而当Iterator不是随机访问迭代器的时候，函数模板则会被从待选项中移除。我们可以将EnableIf理解成一种在模板参数不满足特定需<br>求的时候，防止模板被实例化的防卫手段。由于<code>advanceIter()</code>需要一些只有随机访问迭代器才有操作，因此只能被随机访问迭代器实例化。有时候这样使用EnableIf也不是绝对安全的，此时EnableIf可以被用来帮助尽早的发现这一类错误。</p>
<p>我们还需要“去激活（de-activate）”不够特化的模板，因为在两个模板都适用的时候，编译期没有办法在两者之间做决断（order），从而会报出一个模板歧义错误。幸运的是，实现这一目的方法并不复杂：我们为不够特化的模板使用相同模式的EnableIf，只是适用相反的判断条件。这样，就可以确保对于任意Iterator类型，都只有一个模板会被激活。因此，适用于非随机访问迭代器的<code>advanceIter()</code>会变成下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line">EnableIf&lt;!IsRandomAccessIterator&lt;Iterator&gt;&gt;</span><br><span class="line"><span class="built_in">advanceIter</span>(Iterator&amp; x, Distance n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;<span class="comment">//linear time</span></span><br><span class="line">        ++x;</span><br><span class="line">        --n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="提供多种特化版本"><a href="#提供多种特化版本" class="headerlink" title="提供多种特化版本"></a>提供多种特化版本</h3><p>上述模式可以被继续泛化以满足有两种以上待选项的情况：可以为每一个待选项都配备一个<code>EnableIf</code>，并且让它们的条件部分，对于特定的模板参数彼此互斥。这些条件部分通常会用到多种可以用类型萃取（type traits）表达的属性。</p>
<p>比如，考虑另外一种情况，第三种<code>advanceIter()</code>算法的变体：允许指定一个负的距离参数，以让迭代器向“后”移动。很显然这对一个“输入迭代器（input itertor）”是不适用的，对一个随机访问迭代器却是适用的。但是，标准库也包含一种双向迭代器（bidirectional iterator）的概念，这一类迭代器可以向后移动，但却不要求必须同时是随机访问迭代器。实现这一情况需要稍微复杂一些的逻辑：每个函数模板都必须使用一个包含了在所有函数模板间彼此互斥EnableIf条件，这些函数模板代表了同一个算法的不同变体。这样就会有下面一组条件：</p>
<ul>
<li>随机访问迭代器：适用于随机访问的情况（常数时间复杂度，可以向前或向后移动）</li>
<li>双向迭代器但又不是随机访问迭代器：适用于双向情况（线性时间复杂度，可以向前或向后移动）</li>
<li>输入迭代器但又不是双向迭代器：适用于一般情况（线性时间复杂度，只能向前移动）</li>
</ul>
<p>相关函数模板的具体实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="comment">// implementation for random access iterators:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line">EnableIf&lt;IsRandomAccessIterator&lt;Iterator&gt;&gt;</span><br><span class="line"><span class="built_in">advanceIter</span>(Iterator&amp; x, Distance n) &#123;</span><br><span class="line">    x += n; <span class="comment">// constant time</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> IsBidirectionalIterator = IsConvertible&lt; <span class="keyword">typename</span></span><br><span class="line">std::iterator_traits&lt;Iterator&gt;::iterator_category,</span><br><span class="line">std::bidirectional_iterator_tag&gt;;</span><br><span class="line"><span class="comment">// implementation for bidirectional iterators:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line">EnableIf&lt;IsBidirectionalIterator&lt;Iterator&gt;</span><br><span class="line">    &amp;&amp; !IsRandomAccessIterator&lt;Iterator&gt;&gt;</span><br><span class="line"><span class="built_in">advanceIter</span>(Iterator&amp; x, Distance n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; ++x, --n) &#123; <span class="comment">//linear time</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> ( ; n &lt; <span class="number">0</span>; --x, ++n) &#123; <span class="comment">//linear time</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// implementation for all other iterators:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line">EnableIf&lt;!IsBidirectionalIterator&lt;Iterator&gt;&gt;</span><br><span class="line"><span class="built_in">advanceIter</span>(Iterator&amp; x, Distance n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;advanceIter(): invalid iterator category for negative n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123; <span class="comment">//linear time</span></span><br><span class="line">        ++x;</span><br><span class="line">        --n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过让每一个函数模板的EnableIf条件与其它所有函数模板的条件互相排斥，可以保证对于一组参数，最多只有一个函数模板可以在模板参数推断中胜出。</p>
<p>上述例子已体现出通过EnableIf实现算法特化的一个缺点：每当一个新的算法变体被加入进来，就需要调整所有算法变体的EnableIf条件，以使得它们之间彼此互斥。作为对比，当通过标记派发（tag dispatching）引入一个双向迭代器的算法变体时，则只需要使用标记<code>std::bidirectional_iterator_tag</code>重载一个<code>advanceIterImpl()</code>即可。</p>
<p>标记派发（tag dispatching）和EnableIf两种技术所适用的场景有所不同：一般而言，标记派发可以基于分层的tags支持简单的派发，而EnableIf则可以基于通过使用类型萃取（type trait）获得的任意一组属性来支持更为复杂的派发。</p>
<h3 id="EnableIf所之何处"><a href="#EnableIf所之何处" class="headerlink" title="EnableIf所之何处"></a>EnableIf所之何处</h3><p>EnableIf通常被用于函数模板的返回类型。但是，该方法不适用于构造函数模板以及类型转换模板，因为它们都没有被指定返回类型。而且，使用EnableIf也会使得返回类型很难被读懂。对于这一问题，我们可以通过将EnableIf嵌入一个默认的模板参数来解决，比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;enableif.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;isconvertible.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> IsInputIterator = IsConvertible&lt; <span class="keyword">typename</span></span><br><span class="line">std::iterator_traits&lt;Iterator&gt;::iterator_category,</span><br><span class="line">std::input_iterator_tag&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// construct from an input iterator sequence:</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> =</span><br><span class="line">    EnableIf&lt;IsInputIterator&lt;Iterator&gt;&gt;&gt;</span><br><span class="line">    <span class="built_in">Container</span>(Iterator first, Iterator last);</span><br><span class="line">    <span class="comment">// convert to a container so long as the value types are convertible:</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> = EnableIf&lt;IsConvertible&lt;T, U&gt;&gt;&gt;</span><br><span class="line">    <span class="keyword">operator</span> <span class="built_in">Container</span>&lt;U&gt;() <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是，这样做也有一个问题。如果我们尝试再添加一个版本的重载的话，会导致错误：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// construct from an input iterator sequence:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,</span><br><span class="line"><span class="keyword">typename</span> = EnableIf&lt;IsInputIterator&lt;Iterator&gt;</span><br><span class="line">    &amp;&amp; !IsRandomAccessIterator&lt;Iterator&gt;&gt;&gt;</span><br><span class="line">    <span class="built_in">Container</span>(Iterator first, Iterator last);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> = EnableIf&lt;IsRandomAccessIterator&lt;Iterator&gt;&gt;&gt;</span><br><span class="line">    <span class="built_in">Container</span>(Iterator first, Iterator last); <span class="comment">// ERROR: redeclaration </span></span><br><span class="line">    <span class="comment">//of constructor template</span></span><br></pre></td></tr></table></figure></p>
<p>问题在于这两个模板唯一的区别是默认模板参数，但是在判断两个模板是否相同的时候却又不会考虑默认模板参数。</p>
<p>该问题可以通过引入另外一个模板参数来解决，这样两个构造函数模板就有数量不同的模板参数了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// construct from an input iterator sequence:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> =</span><br><span class="line">    EnableIf&lt;IsInputIterator&lt;Iterator&gt;</span><br><span class="line">    &amp;&amp; !IsRandomAccessIterator&lt;Iterator&gt;&gt;&gt;</span><br><span class="line">    <span class="built_in">Container</span>(Iterator first, Iterator last);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> =</span><br><span class="line">    EnableIf&lt;IsRandomAccessIterator&lt;Iterator&gt;&gt;, <span class="keyword">typename</span> = <span class="type">int</span>&gt; <span class="comment">// extra</span></span><br><span class="line">    dummy parameter to enable both constructors</span><br><span class="line">    <span class="built_in">Container</span>(Iterator first, Iterator last); <span class="comment">//OK now</span></span><br></pre></td></tr></table></figure></p>
<h3 id="编译期if-1"><a href="#编译期if-1" class="headerlink" title="编译期if"></a>编译期if</h3><p>值得注意的是，C++17的constexpr if特性使得某些情况下可以不再使用<code>EnableIf</code>。比如在C++17中可以像下面这样重写<code>advanceIter()</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Distance&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advanceIter</span><span class="params">(Iterator&amp; x, Distance n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(IsRandomAccessIterator&lt;Iterator&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// implementation for random access iterators:</span></span><br><span class="line">        x += n; <span class="comment">// constant time</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span>(IsBidirectionalIterator&lt;Iterator&gt;) &#123;</span><br><span class="line">        <span class="comment">// implementation for bidirectional iterators:</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; ++x, --n) &#123; <span class="comment">//linear time for positive n</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> ( ; n &lt; <span class="number">0</span>; --x, ++n) &#123; <span class="comment">//linear time for negative n</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// implementation for all other iterators that are at least input iterators:</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;advanceIter(): invalid iterator category for negative n&quot;</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123; <span class="comment">//linear time for positive n only</span></span><br><span class="line">            ++x;</span><br><span class="line">            --n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样会更好一些。更为特化的代码分支只会被那些支持它们的类型实例化。因此，对于使用了不被所有的迭代器都支持的代码的情况，只要它们被放在合适的constexpr if分支中，就是安全的。</p>
<p>但是，该方法也有其缺点。只有在泛型代码组件可以被在一个函数模板中完整的表述时，这一使用constexpr if的方法才是可能的。在下面这些情况下，我们依然需要EnableIf：</p>
<ul>
<li>需要满足不同的“接口”需求</li>
<li>需要不同的class定义</li>
<li>对于某些模板参数列表，不应该存在有效的实例化。</li>
</ul>
<p>对于最后一种情况，下面这种做法看上去很有吸引力：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T p)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(condition&lt;T&gt;::value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something here...</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// not a T for which f() makes sense:</span></span><br><span class="line">        <span class="built_in">static_assert</span>(condition&lt;T&gt;::value, <span class="string">&quot;can&#x27;t call f() for such a T&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h3><p>上述技术到目前为止都还不错，但是有时候却稍显笨拙，它们可能会占用很多的编译器资源，以及在某些情况下，可能会产生难以理解的错误信息。因此某些泛型库的作者一直都在盼望着一种能够更简单、直接地实现相同效果的语言特性。为了满足这一需求，一个被称为conceptes的特性很可能会被加入到C++语言中。比如，我们可能希望被重载的container的构造函数可以像下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//construct from an input iterator sequence:</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">requires</span> IsInputIterator&lt;Iterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">Container</span><span class="params">(Iterator first, Iterator last)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct from a random access iterator sequence:</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">requires</span> IsRandomAccessIterator&lt;Iterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">Container</span><span class="params">(Iterator first, Iterator last)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert to a container so long as the value types are convertible:</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">requires</span> IsConvertible&lt;T, U&gt;</span><br><span class="line">    <span class="keyword">operator</span> <span class="built_in">Container</span>&lt;U&gt;() <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中requires条款描述了使用当前模板的要求。如果某个要求不被满足，那么相应的模板就不会被当作备选项考虑。因此它可以被当作EnableIf这一想法的更为直接的表达方式，而且是被语言自身支持的。</p>
<p>Requires条款还有另外一些优于EnableIf的地方。约束包容（constraint subsumption）为只有requires不同的模板进行了排序，这样就不再需要标记派发了（tag dispatching）。而且，requires条款也可以被用于非模板。比如只有在T的对象可以被<code>&lt;</code>运算符比较的时候，才为容器提供<code>sort()</code>成员函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">requires</span> HasLess&lt;T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="类的特化"><a href="#类的特化" class="headerlink" title="类的特化"></a>类的特化</h2><p>类模板的偏特化可以被用来提供一个可选的、为特定模板参数进行了特化的实现，这一点和函数模板的重载很相像。而且，和函数模板的重载类似，如果能够基于模板参数的属性对各种偏特化版本进行区分，也会很有意义。考虑一个以key和value的类型为模板参数的泛型Dictionary类模板。只要key的类型提供了operator==()运算符，就可以实现一个简单（但是低效）的Dictionary：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dictionary</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;pair&lt;Key <span class="type">const</span>, Value&gt;&gt; data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//subscripted access to the data:</span></span><br><span class="line">    value&amp; <span class="keyword">operator</span>[](Key <span class="type">const</span>&amp; key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// search for the element with this key:</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element.first == key)&#123;</span><br><span class="line">                <span class="keyword">return</span> element.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// there is no element with this key; add one</span></span><br><span class="line">        data.<span class="built_in">push_back</span>(<span class="built_in">pair</span>&lt;Key <span class="type">const</span>, Value&gt;(key, <span class="built_in">Value</span>()));</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">back</span>().second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果key的类型提供了<code>operator &lt;()</code>运算符的话，则可以基于标准库的map容器提供一种相对高效的实现方式。类似的，如果key的类型提供了哈希操作的话，则可以基于标准库的unordered_map提供一种更为高效的实现方式。</p>
<h3 id="启用-禁用类模板"><a href="#启用-禁用类模板" class="headerlink" title="启用/禁用类模板"></a>启用/禁用类模板</h3><p>启用/禁用类模板的不同实现方式的方法是使用类模板的偏特化。为了将EnableIf用于类模板的偏特化，需要先为Dictionary引入一个未命名的、 默认的模板参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Dictionary</span><br><span class="line">&#123;</span><br><span class="line">... <span class="comment">//vector implementation as above</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个新的模板参数将是我们使用EnableIf的入口，现在它可以被嵌入到基于map的偏特化Dictionary的模板参数例表中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dictionary</span>&lt;Key, Value, EnableIf&lt;HasLess&lt;Key&gt;&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;Key, Value&gt; data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    value&amp; <span class="keyword">operator</span>[](Key <span class="type">const</span>&amp; key) &#123;</span><br><span class="line">        <span class="keyword">return</span> data[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">和函数模板的重载不同，我们不需要对主模板的任意条件进行禁用，因为对于类模板，任意偏特化版本的优先级都比主模板高。但是，当我们针对支持哈希操作的另一组keys进行特化时，则需要保证不同偏特化版本间的条件是互斥的：</span><br><span class="line">```C++</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Dictionary</span><br><span class="line">&#123;</span><br><span class="line">... <span class="comment">// vector implementation as above</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dictionary</span>&lt;Key, Value, EnableIf&lt;HasLess&lt;Key&gt; &amp;&amp; !HasHash&lt;Key&gt;&gt;&gt; &#123;</span><br><span class="line">&#123;</span><br><span class="line">... <span class="comment">// map implementation as above</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dictionary</span> Key, Value, EnableIf HasHash Key&gt;&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map Key, Value&gt; data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    value&amp; <span class="keyword">operator</span>[](Key <span class="type">const</span>&amp; key) &#123;</span><br><span class="line">        <span class="keyword">return</span> data[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="类模板的标记派发"><a href="#类模板的标记派发" class="headerlink" title="类模板的标记派发"></a>类模板的标记派发</h3><p>同样地，标记派发也可以被用于在不同的模板特化版本之间做选择。为了展示这一技术，我们定义一个类似于之前章节中介绍的<code>advanceIter()</code>算法的函数对象类型<code>Advance&lt;Iterator&gt;</code>，它同样会以一定的步数移动迭代器。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primary template (intentionally undefined):</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,</span><br><span class="line"><span class="keyword">typename</span> Tag = BestMatchInSet&lt; <span class="keyword">typename</span> </span><br><span class="line">    std::iterator_traits&lt;Iterator&gt; ::iterator_category,</span><br><span class="line">    std::input_iterator_tag,</span><br><span class="line">    std::bidirectional_iterator_tag,</span><br><span class="line">    std::random_access_iterator_tag&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Advance;</span><br><span class="line"><span class="comment">// general, linear-time implementation for input iterators:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Advance</span>&lt;Iterator, std::input_iterator_tag&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> DifferenceType = <span class="keyword">typename</span> std::iterator_traits&lt;Iterator&gt;::difference_type;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Iterator&amp; x, DifferenceType n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ++x;</span><br><span class="line">            --n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// bidirectional, linear-time algorithm for bidirectional iterators:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Advance</span>&lt;Iterator, std::bidirectional_iterator_tag&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> DifferenceType =<span class="keyword">typename</span></span><br><span class="line">    std::iterator_traits&lt;Iterator&gt;::difference_type;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Iterator&amp; x, DifferenceType n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ++x;</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                --x;</span><br><span class="line">                ++n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// bidirectional, constant-time algorithm for random access iterators:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Advance</span>&lt;Iterator, std::random_access_iterator_tag&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> DifferenceType =</span><br><span class="line">    <span class="keyword">typename</span> std::iterator_traits&lt;Iterator&gt;::difference_type;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Iterator&amp; x, DifferenceType n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x += n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这一实现形式和函数模板中的标记派发很相像。但是，比较困难的是BestMatchInSet的实现，它主要被用来为一个给定的迭代器选择选择最匹配tag。本质上，这个类型萃取所做的是，当给定一个迭代器种类标记的值之后，要判断出该从以下重载函数中选择哪一个，并返回其参数类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::input_iterator_tag)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::bidirectional_iterator_tag)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::random_access_iterator_tag)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>模拟重载解析最简单的方式就是使用重载解析，就像下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// construct a set of match() overloads for the types in Types...:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MatchOverloads</span>;</span><br><span class="line"><span class="comment">// basis case: nothing matched:</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MatchOverloads</span>&lt;&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">match</span><span class="params">(...)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// recursive case: introduce a new match() overload:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span>... Rest&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MatchOverloads</span>&lt;T1, Rest...&gt; : <span class="keyword">public</span> MatchOverloads&lt;Rest...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> T1 <span class="title">match</span><span class="params">(T1)</span></span>; <span class="comment">// introduce overload for T1</span></span><br><span class="line">    <span class="keyword">using</span> MatchOverloads&lt;Rest...&gt;::match;<span class="comment">// collect overloads from bases</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// find the best match for T in Types...</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BestMatchInSetT</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">decltype</span>(MatchOverloads&lt;Types...&gt;::<span class="built_in">match</span>(<span class="built_in">declval</span>&lt;T&gt; ()));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line">    <span class="keyword">using</span> BestMatchInSet = <span class="keyword">typename</span> BestMatchInSetT&lt;T, Types...&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p><code>MatchOverloads</code>模板通过递归继承为输入的一组<code>Types</code>中的每一个类型都声明了一个<code>match()</code>函数。每一次递归模板<code>MatchOverloads</code>偏特化的实例化都为列表中的下一个类型引入了一个新的<code>match()</code>函数。然后通过使用<code>using</code>声明将基类中的<code>match()</code>函数引入当前作用域。当递归地使用该模板的时候，我们就有了一组和给定类型完全对应的<code>match()</code>函数的重载，每一个重载函数返回的都是其参数的类型。然后<code>BestMatchInSetT</code>模板会将T类型的对象传递给一组<code>match()</code>的重载函数，并返回最匹配的<code>match()</code>函数的返回类型。如果没有任何一个<code>match()</code>函数被匹配上，那么返回基本情况对应的void（使用省略号来捕获任意参数）将代表出现了匹配错误。总结来讲，<code>BestMatchInSetT</code>将函数重载的结果转化成了类型萃取，这样可以让通过标记派发，在不同的模板偏特化之间做选择的情况变得相对容易一些。</p>
<h2 id="实例化安全的模板"><a href="#实例化安全的模板" class="headerlink" title="实例化安全的模板"></a>实例化安全的模板</h2><p><code>EnableIf</code>技术的本质是：只有在模板参数满足某些条件的情况下才允许使用某个模板或者某个偏特化模板。比如，最为高效的<code>advanceIter()</code>算法会检查迭代器的参数种类是否可以被转化成<code>std::random_access_iterator_tag</code>，也就意味着各种各样的随机访问迭代器都适用于该算<br>法。</p>
<p>如果我们将这一概念发挥到极致，将所有模板用到的模板参数的操作都编码进EnableIf的条件，会怎样呢？这样一个模板的实例化永远都不会失败，因为那些没有提供EnableIf所需操作的模板参数会导致一个推断错误，而不是任由可能会出错的实例化继续进行。我们称这一类模板为“实例化安全（instantiation-safe ）”的模板，接下来会对其进行简单介绍。先从一个计算两个数之间的最小值的简单模板min()开始。我们可能会将其实现成下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="type">const</span>&amp; <span class="title">min</span><span class="params">(T <span class="type">const</span>&amp; x, T <span class="type">const</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; x) &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个模板要求类型为T的两个值可以通过&lt;运算符进行比较，并将比较结果转换成bool类型给if语句使用。可以检查类型是否支持&lt;操作符，并计算其返回值类型的类型萃取。为了方便，我们此处依然列出LessResultT的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// for declval()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// for true_type and false_type</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasLess</span> &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">Identity</span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U1, <span class="keyword">typename</span> U2&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> std::true_type</span></span><br><span class="line"><span class="function">        <span class="title">test</span><span class="params">(Identity&lt;<span class="keyword">decltype</span>(std::declval&lt;U1&gt;() &lt; std::declval&lt;U2&gt;())&gt;*)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U1, <span class="keyword">typename</span> U2&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> std::false_type</span></span><br><span class="line"><span class="function">        <span class="title">test</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="keyword">decltype</span>(<span class="built_in">test</span>&lt;T1, T2&gt; (<span class="literal">nullptr</span>))::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="type">bool</span> HasLess&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LessResultImpl</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T1&gt;() &lt; std::<span class="built_in">declval</span>&lt;T2&gt;());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LessResultImpl</span>&lt;T1, T2, <span class="literal">false</span>&gt; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LessResultT</span> : <span class="keyword">public</span> LessResultImpl&lt;T1, T2, HasLess&lt;T1, T2&gt;::value&gt; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">using</span> LessResult = <span class="keyword">typename</span> LessResultT&lt;T1, T2&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>现在就可以通过将该萃取和IsConvertible一起使用，使<code>min()</code>变成实例化安全的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;isconvertible.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lessresult.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">EnableIf&lt;IsConvertible&lt;LessResult&lt;T <span class="type">const</span>&amp;, T <span class="type">const</span>&amp;&gt;, <span class="type">bool</span>&gt;, T <span class="type">const</span>&amp;&gt;</span><br><span class="line"><span class="built_in">min</span>(T <span class="type">const</span>&amp; x, T <span class="type">const</span>&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; x) &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过各种实现了不同<code>&lt;</code>运算符的类型来调用<code>min()</code>，要更能说明问题一些，就像下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;min.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X1</span> &#123; &#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (X1 <span class="type">const</span>&amp;, X1 <span class="type">const</span>&amp;) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X2</span> &#123; &#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(X2, X2) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X3</span> &#123; &#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(X3&amp;, X3&amp;) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X4</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BoolConvertible</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125; <span class="comment">// implicit conversion to bool</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X5</span> &#123; &#125;;</span><br><span class="line">BoolConvertible <span class="keyword">operator</span>&lt; (X5 <span class="type">const</span>&amp;, X5 <span class="type">const</span>&amp;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BoolConvertible</span>();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NotBoolConvertible</span> &#123; <span class="comment">// no conversion to bool</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X6</span> &#123; &#125;;</span><br><span class="line">NotBoolConvertible <span class="keyword">operator</span>&lt; (X6 <span class="type">const</span>&amp;, X6 <span class="type">const</span>&amp;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NotBoolConvertible</span>();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BoolLike</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125; <span class="comment">// explicit conversion to bool</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X7</span> &#123; &#125;;</span><br><span class="line">BoolLike <span class="keyword">operator</span>&lt; (X7 <span class="type">const</span>&amp;, X7 <span class="type">const</span>&amp;) &#123; <span class="keyword">return</span> <span class="built_in">BoolLike</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">min</span>(<span class="built_in">X1</span>(), <span class="built_in">X1</span>()); <span class="comment">// X1 can be passed to min()</span></span><br><span class="line">    <span class="built_in">min</span>(<span class="built_in">X2</span>(), <span class="built_in">X2</span>()); <span class="comment">// X2 can be passed to min()</span></span><br><span class="line">    <span class="built_in">min</span>(<span class="built_in">X3</span>(), <span class="built_in">X3</span>()); <span class="comment">// ERROR: X3 cannot be passed to min()</span></span><br><span class="line">    <span class="built_in">min</span>(<span class="built_in">X4</span>(), <span class="built_in">X4</span>()); <span class="comment">// ERROR: X4 cannot be passed to min()</span></span><br><span class="line">    <span class="built_in">min</span>(<span class="built_in">X5</span>(), <span class="built_in">X5</span>()); <span class="comment">// X5 can be passed to min()</span></span><br><span class="line">    <span class="built_in">min</span>(<span class="built_in">X6</span>(), <span class="built_in">X6</span>()); <span class="comment">// ERROR: X6 cannot be passed to min()</span></span><br><span class="line">    <span class="built_in">min</span>(<span class="built_in">X7</span>(), <span class="built_in">X7</span>()); <span class="comment">// UNEXPECTED ERROR: X7 cannot be passed to min()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在编译上述程序的时候，要注意虽然针对<code>min()</code>函数会报出4个错误（X3，X4，X6，以及X7），但它们都不是从<code>min()</code>的函数体中报出来的（如果不是实例化安全的话，则会从函数体中报出错误）。相反，编译器只会抱怨说没有合适的min()函数，因为唯一的选择已经被SFINAE排除了。</p>
<p>我们需要一个可以判断某个类型是否是“语境上可以转换成bool”的萃取技术。控制流程语句对该萃取技术的实现没有帮助，因为语句不可以出现在SFINAE上下文中，同样的，可以被任意类型重载的逻辑操作也不可以。幸运的是，三元运算符?:是一个表达式，而且不可以被重载，因此它可以被用来测试一个类型是否是“语境上可以转换成bool”的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// for declval()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// for true_type and false_type</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IsContextualBoolT</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">Identity</span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> std::true_type <span class="title">test</span><span class="params">(Identity&lt;<span class="keyword">decltype</span>(declval&lt;U&gt;()? <span class="number">0</span> : <span class="number">1</span>)&gt;*)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> std::false_type <span class="title">test</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="keyword">decltype</span>(<span class="built_in">test</span>&lt;T&gt; (<span class="literal">nullptr</span>))::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> IsContextualBool = IsContextualBoolT&lt;T&gt;::value;</span><br></pre></td></tr></table></figure></p>
<p>有了这一萃取，我们就可以实现一个使用了正确的EnableIf条件且实例化安全的<code>min()</code>了:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iscontextualbool.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lessresult.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">EnableIf&lt;IsContextualBool&lt;LessResult&lt;T <span class="type">const</span>&amp;, T <span class="type">const</span>&amp;&gt;&gt;, T <span class="type">const</span>&amp;&gt;</span><br><span class="line"><span class="built_in">min</span>(T <span class="type">const</span>&amp; x, T <span class="type">const</span>&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; x) &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将各种各样的条件检查，组合进描述了类型种类（比如前向迭代器）的萃取技术，并将这些萃取技术一起放在EnableIf的条件检查中，这一使min()变得实例化安全的技术可以被推广到用于描述其它重要模板的条件。</p>
<h2 id="在标准库中的情况-1"><a href="#在标准库中的情况-1" class="headerlink" title="在标准库中的情况"></a>在标准库中的情况</h2><p>C++标准库为输入，输出，前向，双向以及随机访问迭代器提供了迭代器标记，我们对这些都已经做了展示。这些迭代器标记是标准迭代器萃取<code>std::iterator_traits</code>技术以及施加于迭代器的需求的一部分，因此它们可以被安全得用于标记派发。</p>
<p>C++11标准库中的<code>std::enable_if</code>模板提供了和我们所展示的EnableIf相同的行为。唯一的不同是标准库用了一个小写的成员类型type，而我们使用的是Type。</p>
<p>算法的偏特化在C++标准库中被用在了很多地方。比如，<code>std::advance()</code>以及<code>std::distance()</code>基于其迭代器参数的种类的不同，都有很多变体。虽然很多标准库的实现都倾向于使用标记派发（tag dispatch），但是最近其中一些实现也已经使用<code>std::enable_if</code>来进行算法特化了。而且，很多的C++标准库的实现，在内部也都用这些技术去实现各种标准库算法的偏特化。比如，当迭代器指向连续内存且它们所指向的值有拷贝赋值运算符的时候，<code>std::copy()</code>可以通过调用<code>std::memory()</code>和<code>std::memmove()</code>来进行偏特化。同样的，<code>std::fill()</code>也可以通过调用<code>std::memset</code>进行优化，而且在知晓一个类型有一个普通的析构函数（trivial destructor）的情况下，很多算法都可以避免去调用析构函数。C++标准并没有对这些算法特化的实现方式进行统一（比如统一采用<code>std::advance()</code>和<code>std::distance()</code>的方式），但是实现者还是为了性能<br>而选择类似的方式。</p>
<p>正如第8.4节介绍的那样，C++标准库强烈的建议在其所需要施加的条件中使用<code>std::enable_if&lt;&gt;</code>或者其它类似SFINAE的技术。比如，<code>std::vector</code>就有一个允许其从迭代器序列进行构造的构造函数模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator&gt;</span></span><br><span class="line"><span class="function"><span class="title">vector</span><span class="params">(InputIterator first, InputIterator second,</span></span></span><br><span class="line"><span class="params"><span class="function">allocator_type <span class="type">const</span>&amp; alloc = allocator_type())</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>它要求“当通过类型InputIterator调用构造函数的时候，如果该类型不属于输入迭代器（input iterator），那么该构造函数就不能参与到重载解析中”。这一措辞并没有精确到足以使当前最高效的技术被应用到实现当中，但是在其被引入到标准中的时候，<code>std::enable_if&lt;&gt;</code>确实被寄予了这一期望。</p>
<h1 id="模板和继承"><a href="#模板和继承" class="headerlink" title="模板和继承"></a>模板和继承</h1><h2 id="空基类优化"><a href="#空基类优化" class="headerlink" title="空基类优化"></a>空基类优化</h2><p>C++中的类经常是“空”的，也就是说它们的内部表征在运行期间不占用内存。典型的情况是那写只包含类型成员，非虚成员函数，以及静态数据成员的类。而非静态数据成员，虚函数，以及虚基类，在运行期间则是需要占用内存的。然而即使是空的类，其所占用的内存大小也不是零。如果愿意的话，运行下面的程序可以证明这一点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmptyClass</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(EmptyClass):&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(EmptyClass) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在某些平台上，这个程序会打印出1。在少数对class类型实施了严格内存对齐要求的平台上，则可能会打印出其它结果（典型的结果是4）。</p>
<h3 id="布局原则"><a href="#布局原则" class="headerlink" title="布局原则"></a>布局原则</h3><p>C++的设计者有很多种理由不去使用内存占用为零的class。比如，一个存储了内存占用为零的class的数组，其内存占用也将是零，这样的话常规的指针运算规则都将不在适用。假设ZeroSizedT是一个内存占用为零的类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZeroSizedT z[<span class="number">10</span>];</span><br><span class="line">... </span><br><span class="line">&amp;z[i] - &amp;z[j] <span class="comment">//compute distance between pointers/addresses</span></span><br></pre></td></tr></table></figure></p>
<p>正常情况下，上述例子中的结果可以用两个地址之间的差值，除以该数组中元素类型的大小得到，但是如果元素所占用内存为零的话，上述结论显然不再成立。虽然在C++中没有内存占用为零的类型，但是C++标准却指出，在空class被用作基类的时候，如果不给它分配内存并不会导致其被存储到与其它同类型对象或者子对象相同的地址上，那么就可以不给它分配内存。下面通过一些例子来看看实际应用中空基类优化（empty class optimization，EBCO）的意义。考虑如下程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Int = <span class="type">int</span>;<span class="comment">// type alias members don&quot;t make a class nonempty</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmptyToo</span> : <span class="keyword">public</span> Empty &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmptyThree</span> : <span class="keyword">public</span> EmptyToo &#123;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(Empty): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Empty) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(EmptyToo): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(EmptyToo) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(EmptyThree): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(EmptyThree) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你所使用的编译器实现了EBCO的话，它打印出来的三个class的大小将是相同的，但是它们的结果也都不会是零。这意味着在EmptyToo中，Empty没有被分配内存。注意一个继承自优化后的空基类（且只有这一个基类）的空类依然是空的。这就解释了为什么EmptyThree的大小和Empty相同。如果你所用的编译器没有实现EBCO的话，那么它打印出来的各个class的大小将不同。</p>
<p>考虑一种EBCO不适用的情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Int = <span class="type">int</span>; <span class="comment">// type alias members don&quot;t make a class nonempty</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmptyToo</span> : <span class="keyword">public</span> Empty &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonEmpty</span> : <span class="keyword">public</span> Empty, <span class="keyword">public</span> EmptyToo &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt;<span class="string">&quot;sizeof(Empty): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Empty) &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt;<span class="string">&quot;sizeof(EmptyToo): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(EmptyToo) &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt;<span class="string">&quot;sizeof(NonEmpty): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(NonEmpty) &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可能有点意外的是，NonEmpty不再是一个空的类。毕竟它以及它的基类都没有任何数据成员。但是NonEmpty的基类Empty和EmptyToo不可以被分配到相同的地址上，因为这会导致EmptyToo的基类Empty和NonEmpty的基类Empty被分配到相同的地址。或者说两个类型相同的子对象会被分配到相同的地址上，而这在C++布局规则中是不被允许的。你可能会想到将其中一个Empty基类的子对象放在偏移量为“0字节”的地方，将另一个放在偏移量为“1字节”的地方，但是完整的NonEmpty对象的内存占用依然不能是1字节，因为在一个包含了两个NonEmpty对象的数组中，第一个元素的Empty子对象不能和第二个元素中的Empty子对象占用相同的地址。</p>
<p>EBCO之所以会有这一限制，是因为我们希望能够通过比较两个指针来确定它们所指向的是不是同一个对象。由于指针在程序中几乎总是被表示为单纯的地址，因此就需要我们来确保两个不同的地址（比如指针的值）指向的总是两个不同的对象。</p>
<h3 id="将数据成员实现为基类"><a href="#将数据成员实现为基类" class="headerlink" title="将数据成员实现为基类"></a>将数据成员实现为基类</h3><p>EBCO和数据成员之间没有对等关系，因为（其中一个问题是）它会在用指针指向数据成员的表示上造成一些问题。结果就是，在有些情况下会期望将其实现为一个private的基类，这样粗看起来就可以将其视作成员变量。但是，这样做也并不是没有问题。由于模板参数经常会被空class类型替换，因此在模板上下文中这一问题要更有意思一些，但是通常我们不能依赖这一规则。如果我们对类型参数一无所知，就不能很容易的使用EBCO。考虑下面的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 a;</span><br><span class="line">    T2 b;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中的一个或者两个模板参数完全有可能被空class类型替换。如果真是这样，那么<code>MyClass&lt;T1, T2&gt;</code>这一表达方式可能不是最优的选择，它可能会为每一个<code>MyClass&lt;T1,T2&gt;</code>的实例都浪费一个字的内存。这一内存浪费可以通过把模板参数作为基类使用来避免：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">private</span> T1, <span class="keyword">private</span> T2 &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是这一直接的替代方案也有其自身的缺点：</p>
<ul>
<li>当T1或者T2被一个非class类型或者union类型替换的时候，该方法不再适用。</li>
<li>在两个模板参数被同一种类型替换的时候，该方法不再适用（虽然这一问题简单地通过增加一层额外的继承来解决，参见513页）。</li>
<li>用来替换T1或者T2的类型可能是final的，此时尝试从其派生出新的类会触发错误。</li>
</ul>
<p>即使这些问题能够很好的解决，也还有一个严重的问题存在：给一个class添加一个基类，可能会从根本上改变该class的接口。对于我们的MyClass类，由于只有很少的接口会被影响到，这可能看上去不是一个重要的问题。但是正如在本章接下来的内容中将要看到的，从一个模板参数做继承，会影响到一个成员函数是否可以是virtual的。很显然，EBCO的这一适用方式会带来各种各样的问题。</p>
<p>当已知模板参数只会被class类型替换，以及需要支持另一个模板参数的时候，可以使用另一种更实际的方法。其主要思想是通过使用EBCO将可能为空的类型参数与别的参数“合并”。比如，相比于这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CustomClass&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Optimizable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CustomClass info; <span class="comment">// might be empty</span></span><br><span class="line">    <span class="type">void</span>* storage;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一个模板开发者会使用如下方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CustomClass&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Optimizable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BaseMemberPair&lt;CustomClass, <span class="type">void</span>*&gt; info_and_storage;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>虽然还没有看到BaseMemberPari的具体实现方式，但是可以肯定它的引入会使Optimizable的实现变得更复杂。但是很多的模板开发者都反应，相比于复杂度的增加，它带来的性能提升是值得的。<code>BaseMemberPair</code>的实现可以非常简洁：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BASE_MEMBER_PAIR_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASE_MEMBER_PAIR_HPP</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Base, <span class="keyword">typename</span> Member&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseMemberPair</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Member mem;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// constructor</span></span><br><span class="line">    <span class="built_in">BaseMemberPair</span> (Base <span class="type">const</span> &amp; b, Member <span class="type">const</span> &amp; m)</span><br><span class="line">    : <span class="built_in">Base</span>(b), <span class="built_in">mem</span>(m) &#123;</span><br><span class="line">    &#125; <span class="comment">// access base class data via first()</span></span><br><span class="line">    <span class="function">Base <span class="type">const</span>&amp; <span class="title">base</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Base <span class="type">const</span>&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function">Base&amp; <span class="title">base</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Base&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="comment">// access member data via second()</span></span><br><span class="line">    <span class="function">Member <span class="type">const</span>&amp; <span class="title">member</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;mem;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function">Member&amp; <span class="title">member</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;mem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// BASE_MEMBER_PAIR_HPP</span></span></span><br></pre></td></tr></table></figure></p>
<p>相应的实现需要使用<code>base()</code>和<code>member()</code>成员函数来获取被封装的（或者被执行了内存优化的）数据成员。</p>
<h2 id="The-Curiously-Recurring-Template-Pattern-CRTP"><a href="#The-Curiously-Recurring-Template-Pattern-CRTP" class="headerlink" title="The Curiously Recurring Template Pattern (CRTP)"></a>The Curiously Recurring Template Pattern (CRTP)</h2><p>另一种模式是CRTP。这一个有着奇怪名称的模式指的是将派生类作为模板参数传递给其某个基类的一类技术。该模式的一种最简单的C++实现方式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CuriousBase</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Curious</span> : <span class="keyword">public</span> CuriousBase&lt;Curious&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的CRTP的例子使用了非依赖性基类（nondependent base class）：Curious不是一个模板类，因此它对在依赖性基类中遇到的名称可见性问题是免疫的。但是这并不是CRTP的固有特征。事实上，我们同样可以使用下面的这一实现方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CuriousBase</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CuriousTemplate</span> : <span class="keyword">public</span> CuriousBase&lt;CuriousTemplate&lt;T&gt;&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>将派生类通过模板参数传递给其基类，基类可以在不使用虚函数的情况下定制派生类的行为。这使得CRTP对那些只能被实现为成员函数的情况（比如构造函数，析构函数，以及下表运算符）或者依赖于派生类的特性的情况很有帮助。</p>
<p>一个CRTP的简单应用是将其用于追踪从一个class类型实例化出了多少对象。这一功能也可以通过在构造函数中递增一个static数据成员、并在析构函数中递减该数据成员来实现。但是给不同的class都提供相同的代码是一件很无聊的事情，而通过一个基类（非CRTP）实现这一功能又会将不同派生类实例的数目混杂在一起。事实上，可以实现下面这一模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CountedType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectCounter</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> std::<span class="type">size_t</span> count = <span class="number">0</span>; <span class="comment">// number of existing objects</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// default constructor</span></span><br><span class="line">    <span class="built_in">ObjectCounter</span>() &#123;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125; <span class="comment">// copy constructor</span></span><br><span class="line">    <span class="built_in">ObjectCounter</span> (ObjectCounter&lt;CountedType&gt; <span class="type">const</span>&amp;) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125; <span class="comment">// move constructor</span></span><br><span class="line">    <span class="built_in">ObjectCounter</span> (ObjectCounter&lt;CountedType&gt; &amp;&amp;) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125; <span class="comment">// destructor</span></span><br><span class="line">    ~<span class="built_in">ObjectCounter</span>() &#123;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// return number of existing objects:</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::<span class="type">size_t</span> <span class="title">live</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意这里为了能够在class内部初始化count成员，使用了inline。在C++17之前，必须在class模板外面定义它：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CountedType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectCounter</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::<span class="type">size_t</span> count; <span class="comment">// number of existing objects</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// initialize counter with zero:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CountedType&gt;</span><br><span class="line">std::<span class="type">size_t</span> ObjectCounter&lt;CountedType&gt;::count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>当我们想要统计某一个class的对象（未被销毁）数目时，只需要让其派生自ObjectCounter即可。比如，可以按照下面的方式统计MyString的对象数目：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;objectcounter.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CharT&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> : <span class="keyword">public</span> ObjectCounter&lt;MyString&lt;CharT&gt;&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyString&lt;<span class="type">char</span>&gt; s1, s2;</span><br><span class="line">    MyString&lt;<span class="type">wchar_t</span>&gt; ws;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num of MyString&lt;char&gt;: &quot;</span></span><br><span class="line">    &lt;&lt; MyString&lt;<span class="type">char</span>&gt;::<span class="built_in">live</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num of MyString&lt;wchar_t&gt;: &quot;</span></span><br><span class="line">    &lt;&lt; ws.<span class="built_in">live</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="The-Barton-Nackman-Trick"><a href="#The-Barton-Nackman-Trick" class="headerlink" title="The Barton-Nackman Trick"></a>The Barton-Nackman Trick</h3><p>该技术产生的动力之一是：在当时，函数模板的重载是严重受限的，而且namespace在当时也不为大多数编译器所支持。</p>
<p>为了说明这一技术，假设我们有一个需要为之定义operator ==的类模板Array。一个可能的方案是将该运算符定义为类模板的成员，但是由于其第一个参数（绑定到this指针上的参数）和第二个参数的类型转换规则不同。由于我们希望<code>operator ==</code>对其参数是对称的，因此更倾向与将其定义为某一个namespace中的函数。一种很直观的实现方式可能会像下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="type">bool</span> <span class="keyword">operator</span>== (Array&lt;T&gt; <span class="type">const</span>&amp; a, Array&lt;T&gt; <span class="type">const</span>&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过如果函数模板不可以被重载的话，这会引入一个问题：在当前作用域内不可以再声明其它的<code>operator ==</code>模板，而其它的类模板却又很可能需要这样一个类似的模板。通过将<code>operator ==</code>定义成class内部的一个常规友元函数解决了这一问题：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">areEqual</span><span class="params">(Array&lt;T&gt; <span class="type">const</span>&amp; a, Array&lt;T&gt; <span class="type">const</span>&amp; b)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">... </span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== (Array&lt;T&gt; <span class="type">const</span>&amp; a, Array&lt;T&gt; <span class="type">const</span>&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">areEqual</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>假设我们用float实例化了该Array类。作为实例化的结果，该友元运算符函数也会被连带声明，但是请注意该函数本身并不是一个函数模板的实例。作为实例化过程的一个副产品，它是一个被注入到全局作用域的常规非模板函数。由于它是非模板函数，即使在重载函数模板的功能被引入之前，也可以用其它的<code>operator ==</code>对其进行重载。由于这样做避免了去定义一个适用于所有类型<code>T</code>的<code>operator ==(T, T)</code>模板，称为restricted template expansion。</p>
<p>由于<code>operator== (Array&lt;T&gt; const&amp;, Array&lt;T&gt; const&amp;)</code>被定义在一个class的定义中，它会被隐式地当作inline函数，因此我们决定将其实现委托给一个static成员函数（不需要是inline的）。</p>
<h3 id="运算符的实现"><a href="#运算符的实现" class="headerlink" title="运算符的实现"></a>运算符的实现</h3><p>在给一个类重载运算符的时候，通常也需要重载一些其它的（当然也是相关的）运算符。比如，一个实现了<code>operator ==</code>的类，通常也会实现<code>operator !=</code>，一个实现了<code>operator &lt;</code>的类，通常也会实现其它的关系运算符（&gt;，&lt;=，&gt;=）。在很多情况下，这些运算符中只有一个运算符的定义比较有意思，其余的运算符都可以通过它来定义。例如，类X的<code>operator !=</code>可以通过使用<code>operator ==</code>来定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!= (X <span class="type">const</span>&amp; x1, X <span class="type">const</span>&amp; x2) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(x1 == x2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于那些<code>operator !=</code>的定义类似的类型，可以通过模板将其泛型化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!= (T <span class="type">const</span>&amp; x1, T <span class="type">const</span>&amp; x2) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(x1 == x2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>事实上，在C++标准库的<code>&lt;utility&gt;</code>头文件中已经包含了类似的定义。但是，一些别的定义在标准化过程中则被放到了<code>namespace std::rel_ops</code>中，因为当时可以确定如果让它们在std中可见的话，会导致一些问题。</p>
<p>虽然上述第一个问题可以通过SFINAE技术解决，这样的话这个<code>!= operator</code>的定义只会在某种类型有合适的<code>== operator</code>时才会被进行相应的实例化。但是第二个问题依然存在：相比于用户定义的需要进行从派生类到基类的转化的<code>!= operator</code>，上述通用的<code>!=operator</code>定义总是会被优先选择，这有时会导致意料之外的结果。</p>
<p>另一种基于CRTP的运算符模板形式，则允许程序去选择泛型的运算符定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EqualityComparable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>!= (Derived <span class="type">const</span>&amp; x1, Derived <span class="type">const</span>&amp; x2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !(x1 == x2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> : <span class="keyword">public</span> EqualityComparable&lt;X&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== (X <span class="type">const</span>&amp; x1, X <span class="type">const</span>&amp; x2) &#123;</span><br><span class="line">    <span class="comment">// implement logic for comparing two objects of type X</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X x1, x2;</span><br><span class="line">    <span class="keyword">if</span> (x1 != x2) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>EqualityComparable&lt;&gt;</code>为了基于派生类中定义的<code>operator==</code>给其派生类提供<code>operator !=</code>，使用了CRTP。事实上这一定义是通过friend<br>函数定义的形式提供的，这使得两个参数在类型转换时的<code>operator !=</code>行为一致。</p>
<h2 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h2><p>考虑一个包含了一组点的简单Polygon类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>() : <span class="built_in">x</span>(<span class="number">0.0</span>), <span class="built_in">y</span>(<span class="number">0.0</span>) &#123; &#125;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Polygon</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Point&gt; points;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">... <span class="comment">//public operations</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果可以扩展与每个Point相关联的一组信息的话（比如包含特定应用中每个点的颜色，或者给每个点加个标签），那么Polygon类将变得更为实用。实现该扩展的一种方式是用点的类型对Polygon进行参数化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> P&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Polygon</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;P&gt; points;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">... <span class="comment">//public operations</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>用户可以通过继承创建与Point类似，但是包含了特定应用所需数据，并且提供了与Point相同的接口的类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LabeledPoint</span> : <span class="keyword">public</span> Point</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string label;</span><br><span class="line">    <span class="built_in">LabeledPoint</span>() : <span class="built_in">Point</span>(), <span class="built_in">label</span>(<span class="string">&quot;&quot;</span>) &#123; &#125;</span><br><span class="line">    <span class="built_in">LabeledPoint</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">Point</span>(x, y), <span class="built_in">label</span>(<span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这一实现方式有其自身的缺点。比如，首先需要将Point类型暴露给用户，这样用户才能从它派生出自己的类型。而且LablePoint的作者也需要格外小心地提供与Point完全一样的接口（比如，继承或者提供所有与Point相同的构造函数），否则在Polygon中使用LabledPoint的时候会遇到问题。这一问题在Point随Polygon模板版本发生变化时将会变得更加严重：</p>
<ul>
<li>如果给Point新增一个构造函数，就需要去更新所有的派生类。</li>
</ul>
<p>Mixins是另一种可以客制化一个类型的行为但是不需要从其进行继承的方法。事实上，Mixins反转了常规的继承方向，因为新的类型被作为类模板的基类“混合进”了继承层级中，而不是被创建为一个新的派生类。这一方式允许在引入新的数据成员以及某些操作的时候，不需要去复制相关接口。一个支持了mixins的类模板通常会接受一组任意数量的class，并从之进行派生：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Mixins&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> : <span class="keyword">public</span> Mixins...</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">double</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>() : <span class="built_in">Mixins</span>()..., <span class="built_in">x</span>(<span class="number">0.0</span>), <span class="built_in">y</span>(<span class="number">0.0</span>) &#123; &#125;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">Mixins</span>()..., <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在，我们就可以通过将一个包含了label的基类“混合进来（mix in）”来生成一个LabledPoint：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Label</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string label;</span><br><span class="line">    <span class="built_in">Label</span>() : <span class="built_in">label</span>(<span class="string">&quot;&quot;</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> LabeledPoint = Point&lt;Label&gt;;</span><br></pre></td></tr></table></figure></p>
<p>甚至是“mix in”几个基类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> red = <span class="number">0</span>, green = <span class="number">0</span>, blue = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> MyPoint = Point&lt;Label, Color&gt;;</span><br></pre></td></tr></table></figure></p>
<p>有了这个基于mixin的Point，就可以在不改变其接口的情况下很容易的为Point引入额外的信息，因此Polygon的使用和维护也将变得相对简单一些。为了访问相关数据和接口，用户只需进行从Point到它们的mixin类型（Label或者Color）之间的隐式转化即可。而且，通过提供给Polygon类模板的mixins，Point类甚至可以被完全隐藏：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Mixins&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Polygon</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Point&lt;Mixins...&gt;&gt; points;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">... <span class="comment">//public operations</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当需要对模板进行少量客制化的时候，Mixins会很有用，比如在需要用用户指定的数据去装饰内部存储的对象时，使用mixins就不需要将内部数据类型和接口暴露出来并写进文档。</p>
<h3 id="Curious-Mixins"><a href="#Curious-Mixins" class="headerlink" title="Curious Mixins"></a>Curious Mixins</h3><p>一个CRTP-mixin版本的Point可以被下称下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;... Mixins&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> : <span class="keyword">public</span> Mixins&lt;Point&gt;...</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>() : <span class="built_in">Mixins</span>&lt;Point&gt;()..., <span class="built_in">x</span>(<span class="number">0.0</span>), <span class="built_in">y</span>(<span class="number">0.0</span>) &#123; &#125;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">Mixins</span>&lt;Point&gt;()..., <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这一实现方式需要对那些将要被混合进来（mix in）的类做一些额外的工作，因此诸如Label和Color一类的class需要被调整成类模板。但是，现在这些被混合进来的class的行为可以基于其降要被混合进的派生类进行调整。比如，我们可以将前述的ObjectCounter模板混合进Point，这样就可以统计在Polygon中创建的点的数目。</p>
<h3 id="Parameterized-Virtuality"><a href="#Parameterized-Virtuality" class="headerlink" title="Parameterized Virtuality"></a>Parameterized Virtuality</h3><p>Minxins还允许我们去间接的参数化派生类的其它特性，比如成员函数的虚拟性。下面的简单例子展示了这一令人称奇的技术：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotVirtual</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Virtual</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Mixins&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> : <span class="keyword">public</span> Mixins...</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// the virtuality of foo() depends on its declaration</span></span><br><span class="line">    <span class="comment">// (if any) in the base classes Mixins...</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base::foo()&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Mixins&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;Mixins...&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived::foo()&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base&lt;NotVirtual&gt;* p1 = <span class="keyword">new</span> Derived&lt;NotVirtual&gt;;</span><br><span class="line">    p1-&gt;<span class="built_in">foo</span>(); <span class="comment">// calls Base::foo()</span></span><br><span class="line">    Base&lt;Virtual&gt;* p2 = <span class="keyword">new</span> Derived&lt;Virtual&gt;;</span><br><span class="line">    p2-&gt;<span class="built_in">foo</span>(); <span class="comment">// calls Derived::foo()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该技术提供了这样一种工具，使用它可以设计出一个既可以用来实例化具体的类，也可以通过继承对其进行扩展的类模板。但是，要获得一个可以为某些更为特化的功能产生一个更好的基类的类，仅仅是针对某些成员函数进行虚拟化还是不够的。这一类开发方法需要更为基础的设计决策。更为实际的做法是设计两个不同的工具（类或者类模板层级），而不是将它们集成进一个模板层级。</p>
<h2 id="Named-Template-Arguments"><a href="#Named-Template-Arguments" class="headerlink" title="Named Template Arguments"></a>Named Template Arguments</h2><p>不少模板技术有时会导致类模板包含很多不同的模板类型参数。但是，其中一些模板参数通常都会有合理的默认值。其中一种这一类模板的定义方式可能会向下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Policy1 = DefaultPolicy1,</span><br><span class="line"><span class="keyword">typename</span> Policy2 = DefaultPolicy2,</span><br><span class="line"><span class="keyword">typename</span> Policy3 = DefaultPolicy3,</span><br><span class="line"><span class="keyword">typename</span> Policy4 = DefaultPolicy4&gt;</span><br><span class="line"><span class="keyword">class</span> BreadSlicer &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以想象，在使用这样一个模板时通常都可以使用模板参数的默认值。但是，如果需要指定某一个非默认参数的值的话，那么也需要指定该参数前面的所有参数的值（虽然使用的可能是它们的默认值）。</p>
<p>很显然，我们更倾向于使用<code>BreadSlicer&lt;Policy3 = Custom&gt;</code>的形式，而不是<code>BreadSlicer&lt;DefaultPolicy1, DefaultPolicy2, Custom&gt;</code>。在下面的内容在，我们开发了一种几乎可以完全实现以上功能的技术。</p>
<p>我们的技术方案是将默认类型放在一个基类中，然后通过派生将其重载。相比与直接指定类型参数，我们会通过辅助类（helper classes）来提供相关信息。比如我们可以将其写成这样<code>BreadSlicer&lt;Policy3_is&lt;Custom&gt;&gt;</code>。由于每一个模板参数都可以表述任一条款，默认值就不能不同。或者说，在更高的层面上，每一个模板参数都是等效的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> PolicySetter1 = DefaultPolicyArgs,</span><br><span class="line"><span class="keyword">typename</span> PolicySetter2 = DefaultPolicyArgs,</span><br><span class="line"><span class="keyword">typename</span> PolicySetter3 = DefaultPolicyArgs,</span><br><span class="line"><span class="keyword">typename</span> PolicySetter4 = DefaultPolicyArgs&gt;</span><br><span class="line"><span class="keyword">class</span> BreadSlicer &#123;</span><br><span class="line"><span class="keyword">using</span> Policies = PolicySelector&lt;PolicySetter1,</span><br><span class="line">PolicySetter2,</span><br><span class="line">PolicySetter3,</span><br><span class="line">PolicySetter4&gt;;</span><br><span class="line"><span class="comment">// use Policies::P1, Policies::P2, ... to refer to the various policies</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>剩余的挑战就是该如何设计PolicySelector模板了。必须将不同的模板参数融合进一个单独的类型，而且这个类型需要用那个没有指定默认值的类型去重载默认的类型别名成员。可以通过继承实现这一融合：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PolicySelector&lt;A,B,C,D&gt; creates A,B,C,D as base classes</span></span><br><span class="line"><span class="comment">// Discriminator&lt;&gt; allows having even the same base class more than once</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Base, <span class="type">int</span> D&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Discriminator</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Setter1, <span class="keyword">typename</span> Setter2,</span><br><span class="line"><span class="keyword">typename</span> Setter3, <span class="keyword">typename</span> Setter4&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PolicySelector</span> : <span class="keyword">public</span> Discriminator&lt;Setter1,<span class="number">1</span>&gt;,</span><br><span class="line"><span class="keyword">public</span> Discriminator&lt;Setter2,<span class="number">2</span>&gt;,</span><br><span class="line"><span class="keyword">public</span> Discriminator&lt;Setter3,<span class="number">3</span>&gt;,</span><br><span class="line"><span class="keyword">public</span> Discriminator&lt;Setter4,<span class="number">4</span>&gt;</span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意此处对中间的Discriminator模板的使用。其要求不同的Setter类型是类似的（不能使用多个类型相同的直接基类。而非直接基类，则可以使用和其它基类类似的类型）。</p>
<p>正如之前提到的，我们将全部的默认值收集到基类中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name default policies as P1, P2, P3, P4</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DefaultPolicies</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> P1 = DefaultPolicy1;</span><br><span class="line">    <span class="keyword">using</span> P2 = DefaultPolicy2;</span><br><span class="line">    <span class="keyword">using</span> P3 = DefaultPolicy3;</span><br><span class="line">    <span class="keyword">using</span> P4 = DefaultPolicy4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是，如果我们最终会从该基类继承很多次的话，需要额外小心的避免歧义。因此，此处需要确保对基类使用虚继承：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class to define a use of the default policy values</span></span><br><span class="line"><span class="comment">// avoids ambiguities if we derive from DefaultPolicies more than once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DefaultPolicyArgs</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> DefaultPolicies &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>最后，我们也需要一些模板来重载掉那些默认的策略值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Policy&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Policy1_is</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> DefaultPolicies &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> P1 = Policy; <span class="comment">// overriding type alias</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Policy&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Policy2_is</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> DefaultPolicies &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> P2 = Policy; <span class="comment">// overriding type alias</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Policy&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Policy3_is</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> DefaultPolicies &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> P3 = Policy; <span class="comment">// overriding type alias</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Policy&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Policy4_is</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> DefaultPolicies &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> P4 = Policy; <span class="comment">// overriding type alias&#125;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有了<code>Discriminator&lt;&gt;</code>类模板的帮助，这就会产生一种层级关系，在其中所有的模板参数都是基类。重要的一点是，所有的这些基类都有一个共同的虚基类<code>DefaultPolicies</code>，也正是它定义了P1，P2，P3和P4的默认值。但是P3在某一个派生类中被重新定义了（比如在<code>Policy3_is&lt;&gt;</code>中）。根据作用域规则，该定义会隐藏掉在基类中定义的相应定义。这样，就不会有歧义了。</p>
<p>在模板<code>BreadSlicer</code>中，可以使用<code>Policies::P3</code>的形式引用以上4中策略。比如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;...&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BreadSlicer</span> &#123;</span><br><span class="line">... </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Policies::P3::<span class="built_in">doPrint</span>();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="桥接static和dynamic多态"><a href="#桥接static和dynamic多态" class="headerlink" title="桥接static和dynamic多态"></a>桥接static和dynamic多态</h1><p>本章将介绍在C++中把static多态和dynamic多态桥接起来的方式，该方式具备了各种模型的部分优点：比较小的可执行代码量，几乎全部的动态多态的编译期特性，以及（允许内置类型无缝工作的）静态多态的灵活接口。作为例子，我们将创建一个简化版的<code>std::function&lt;&gt;</code>模板。</p>
<h2 id="函数对象，指针，以及std-function-lt-gt"><a href="#函数对象，指针，以及std-function-lt-gt" class="headerlink" title="函数对象，指针，以及std:function&lt;&gt;"></a>函数对象，指针，以及std:function&lt;&gt;</h2><p>在给模板提供定制化行为的时候，函数对象会比较有用。比如，下面的函数模板列举了从0到某个值之间的所有整数，并将每一个值都提供给了一个已有的函数对象f：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forUpTo</span><span class="params">(<span class="type">int</span> n, F f)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">f</span>(i); <span class="comment">// call passed function f for i</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printInt</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">    <span class="comment">// insert values from 0 to 4:</span></span><br><span class="line">    forUpTo(<span class="number">5</span>,</span><br><span class="line">        [&amp;values](<span class="type">int</span> i) &#123;</span><br><span class="line">            values.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print elements:</span></span><br><span class="line">    forUpTo(<span class="number">5</span>, printInt); <span class="comment">// prints 0 1 2 3 4</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>forUpTo()</code>函数模板适用于所有的函数对象，包括lambda，函数指针，以及任意实现了合适的<code>operator()</code>运算符或者可以转换为一个函数指针或引用的类，而且每一次对<code>forUpTo()</code>的使用都很可能产生一个不同的函数模板实例。上述例子中的函数模板非常小，但是如果该模板非常大的话，这些不同应用导致的实例化很可能会导致代码量的增加。</p>
<p>一个缓解代码量增加的方式是将函数模板转变为非模板的形式，这样就不再需要实例化。比如，我们可能会使用函数指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">forUpTo</span><span class="params">(<span class="type">int</span> n, <span class="type">void</span> (*f)(<span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">        <span class="built_in">f</span>(i); <span class="comment">// call passed function f for i</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，虽然在给其传递<code>printInt()</code>的时候该方式可以正常工作，给其传递lambda却会导致错误：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">forUpTo(<span class="number">5</span>, printInt); <span class="comment">//OK: prints 0 1 2 3 4</span></span><br><span class="line">forUpTo(<span class="number">5</span>,</span><br><span class="line">    [&amp;values](<span class="type">int</span> i) &#123; <span class="comment">//ERROR: lambda not convertible to a function pointer</span></span><br><span class="line">        values.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>标准库中的类模板<code>std::functional&lt;&gt;</code>则可以用来实现另一种类型的<code>forUpTo()</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forUpTo</span><span class="params">(<span class="type">int</span> n, std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">        <span class="built_in">f</span>(i) <span class="comment">// call passed function f for i</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>std::functional&lt;&gt;</code>的模板参数是一个函数类型，该类型体现了函数对象所接受的参数类型以及其所需要产生的返回类型，非常类似于表征了参数和返回类型的函数指针。</p>
<p>这一形式的<code>forUpTo()</code>提供了static多态的一部分特性：适用于一组任意数量的类型（包含函数指针，lambda，以及任意实现了适当<code>operator()</code>运算符的类），同时又是一个只有一种实现的非模板函数。为了实现上述功能，它使用了一种称之为类型消除（type erasure）的技术，该技术将static和dynamic多态桥接了起来。</p>
<h2 id="广义函数指针"><a href="#广义函数指针" class="headerlink" title="广义函数指针"></a>广义函数指针</h2><p><code>std::functional&lt;&gt;</code>类型是一种高效的、广义形式的C++函数指针，提供了与函数指针相同的基本操作：</p>
<ul>
<li>在调用者对函数本身一无所知的情况下，可以被用来调用该函数。</li>
<li>可以被拷贝，move以及赋值。</li>
<li>可以被另一个（函数签名一致的）函数初始化或者赋值。</li>
<li>如果没有函数与之绑定，其状态是“null”。</li>
</ul>
<p>但是，与C++函数指针不同的是，<code>std::functional&lt;&gt;</code>还可以被用来存储lambda，以及其它任意实现了合适的<code>operator()</code>的函数对象，所有这些情况对应的类型都可能不同。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;functionptr.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forUpTo</span><span class="params">(<span class="type">int</span> n, FunctionPtr&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>(i); <span class="comment">// call passed function f for i</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printInt</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">    <span class="comment">// insert values from 0 to 4:</span></span><br><span class="line">    forUpTo(<span class="number">5</span>,[&amp;values](<span class="type">int</span> i) &#123;</span><br><span class="line">        values.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// print elements:</span></span><br><span class="line">    forUpTo(<span class="number">5</span>, printInt); <span class="comment">// prints 0 1 2 3 4</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FunctionPtr的接口非常直观的提供了构造，拷贝，move，析构，初始化，以及从任意函数对象进行赋值，还有就是要能够调用其底层的函数对象。接口中最有意思的一部分是如何在一个类模板的偏特化中对其进行完整的描述，该偏特化将模板参数（函数类型）分解为其组成部分（返回类型以及参数类型）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primary template:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Signature&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FunctionPtr</span>;</span><br><span class="line"><span class="comment">// partial specialization:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FunctionPtr</span>&lt;<span class="built_in">R</span>(Args...)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FunctorBridge&lt;R, Args...&gt;* bridge;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// constructors:</span></span><br><span class="line">    <span class="built_in">FunctionPtr</span>() : <span class="built_in">bridge</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="built_in">FunctionPtr</span>(FunctionPtr <span class="type">const</span>&amp; other); <span class="comment">// see functionptrcpinv.hpp</span></span><br><span class="line"><span class="built_in">FunctionPtr</span>(FunctionPtr&amp; other)</span><br><span class="line">    : <span class="built_in">FunctionPtr</span>(<span class="built_in">static_cast</span>&lt;FunctionPtr <span class="type">const</span>&amp;&gt;(other)) &#123;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">FunctionPtr</span>(FunctionPtr&amp;&amp; other) : <span class="built_in">bridge</span>(other.bridge) &#123;</span><br><span class="line">    other.bridge = <span class="literal">nullptr</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//construction from arbitrary function objects:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt; <span class="title">FunctionPtr</span><span class="params">(F&amp;&amp; f)</span></span>; <span class="comment">// see functionptrinit.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// assignment operators:</span></span><br><span class="line">FunctionPtr&amp; <span class="keyword">operator</span>=(FunctionPtr <span class="type">const</span>&amp; other) &#123;</span><br><span class="line">    FunctionPtr <span class="built_in">tmp</span>(other);</span><br><span class="line">    <span class="built_in">swap</span>(*<span class="keyword">this</span>, tmp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">FunctionPtr&amp; <span class="keyword">operator</span>=(FunctionPtr&amp;&amp; other) &#123;</span><br><span class="line">    <span class="keyword">delete</span> bridge;</span><br><span class="line">    bridge = other.bridge;</span><br><span class="line">    other.bridge = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//construction and assignment from arbitrary function objects:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt; FunctionPtr&amp; <span class="keyword">operator</span>=(F&amp;&amp; f) &#123;</span><br><span class="line">    FunctionPtr <span class="built_in">tmp</span>(std::forward&lt;F&gt;(f));</span><br><span class="line">    <span class="built_in">swap</span>(*<span class="keyword">this</span>, tmp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// destructor:</span></span><br><span class="line">~<span class="built_in">FunctionPtr</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> bridge;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(FunctionPtr&amp; fp1, FunctionPtr&amp; fp2)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">swap</span>(fp<span class="number">1.</span>bridge, fp<span class="number">2.</span>bridge);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bridge == <span class="literal">nullptr</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// invocation:</span></span><br><span class="line"><span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(Args... args)</span> <span class="type">const</span></span>; <span class="comment">// see functionptr-cpinv.hpp</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>该实现包含了唯一一个非static的成员变量，bridge，它将负责被存储函数对象的储存和维护。该指针的所有权被绑定到了一个FunctionPtr的对象上，因此相关的大部分实现都只需要去操纵这个指针即可。</p>
<h2 id="桥接接口"><a href="#桥接接口" class="headerlink" title="桥接接口"></a>桥接接口</h2><p>FunctorBridge类模板负责持有以及维护底层的函数对象，它被实现为一个抽象基类，为FunctionPtr的动态多态打下基础：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FunctorBridge</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">FunctorBridge</span>() &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> FunctorBridge* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> R <span class="title">invoke</span><span class="params">(Args... args)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>FunctorBridge</code>通过虚函数提供了用来操作被存储函数对象的必要操作：一个析构函数，一个用来执行<code>copy</code>的<code>clone()</code>操作，以及一个用来调用底层函数对象的<code>invoke()</code>操作。不要忘记将<code>clone()</code>和<code>invoke()</code>声明为const的成员函数。</p>
<p>有了这些虚函数，就可以继续实现拷贝构造函数和函数调用运算符了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">FunctionPtr&lt;<span class="built_in">R</span>(Args...)&gt;::<span class="built_in">FunctionPtr</span>(FunctionPtr <span class="type">const</span>&amp; other)</span><br><span class="line">: <span class="built_in">bridge</span>(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (other.bridge) &#123;</span><br><span class="line">    bridge = other.bridge-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">R FunctionPtr&lt;<span class="built_in">R</span>(Args...)&gt;::<span class="built_in">operator</span>()(Args&amp;&amp;... args) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> bridge-&gt;<span class="built_in">invoke</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="类型擦除（Type-Erasure）"><a href="#类型擦除（Type-Erasure）" class="headerlink" title="类型擦除（Type Erasure）"></a>类型擦除（Type Erasure）</h2><p><code>FunctorBridge</code>的每一个实例都是一个抽象类，因此其虚函数功能的具体实现是由派生类负责的。为了支持所有可能的函数对象（一个无界集合），我们可能会需要无限多个派生类。幸运的是，我们可以通过用其所存储的函数对象的类型对派生类进行参数化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Functor, <span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecificFunctorBridge</span> : <span class="keyword">public</span> FunctorBridge&lt;R, Args...&gt; &#123;</span><br><span class="line">    Functor functor;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FunctorFwd&gt;</span></span><br><span class="line"><span class="function">    <span class="title">SpecificFunctorBridge</span><span class="params">(FunctorFwd&amp;&amp; functor)</span></span></span><br><span class="line"><span class="function">        : functor(std::forward&lt;FunctorFwd&gt;(functor)) &#123;</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SpecificFunctorBridge* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SpecificFunctorBridge</span>(functor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> R <span class="title">invoke</span><span class="params">(Args&amp;&amp;... args)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">functor</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>每一个<code>SpecificFunctorBridge</code>的实例都存储了函数对象的一份拷贝（类型为Functor），它可以被调用，拷贝，以及销毁（通过隐式调用析构函数）。<code>SpecificFunctorBridge</code>实例会在<code>FunctionPtr</code>被实例化的时候顺带产生，<code>FunctionPtr</code>的剩余实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">FunctionPtr&lt;<span class="built_in">R</span>(Args...)&gt;::<span class="built_in">FunctionPtr</span>(F&amp;&amp; f)</span><br><span class="line">: <span class="built_in">bridge</span>(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> Functor = std::<span class="type">decay_t</span>&lt;F&gt;;</span><br><span class="line">    <span class="keyword">using</span> Bridge = SpecificFunctorBridge&lt;Functor, R, Args...&gt;;</span><br><span class="line">    bridge = <span class="keyword">new</span> <span class="built_in">Bridge</span>(std::forward&lt;F&gt;(f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，此处由于<code>FunctionPtr</code>的构造函数本身也被函数对象类型模板化了，该类型只为<code>SpecificFunctorBridge</code>的特定偏特化版本（以Bridge类型别名表述）所知。一旦新开辟的Bridge实例被赋值给数据成员bridge，由于从派生类到基类的转换（<code>Bridge* --&gt; FunctorBridge&lt;R,
Args...&gt;*</code>），特定类型F的额外信息将会丢失。类型信息的丢失，解释了为什么名称“类型擦除”经常被用于描述用来桥接static和dynamic多态的技术。</p>
<p>该实现的一个特点是在生成Functor的类型的时候使用了std::decay，这使得被推断出来的类型F可以被存储，比如它会将指向函数类型的引用decay成函数指针类型，并移除了顶层const，volatile和引用。</p>
<h2 id="可选桥接（Optional-Bridging）"><a href="#可选桥接（Optional-Bridging）" class="headerlink" title="可选桥接（Optional Bridging）"></a>可选桥接（Optional Bridging）</h2><p>上述FunctionPtr实现几乎可以被当作一个函数指针的非正式替代品适用。但是它并没有提供对下面这一函数指针操作的支持：检测两个FunctionPtr的对象是否会调用相同的函数。为了实现这一功能，需要在<code>FunctorBridge</code>中加入equals操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">equals</span><span class="params">(FunctorBridge <span class="type">const</span>* fb)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>在<code>SpecificFunctorBridge</code>中的具体实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">equals</span><span class="params">(FunctorBridge&lt;R, Args...&gt; <span class="type">const</span>* fb)</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> specFb = <span class="built_in">dynamic_cast</span>&lt;SpecificFunctorBridge <span class="type">const</span>*&gt; (fb))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> functor == specFb-&gt;functor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//functors with different types are never equal:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后可以为<code>FunctionPtr</code>实现<code>operator==</code>，它会先检查对应内容是否是null，然后将比较委托给<code>FunctorBridge</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="type">bool</span></span><br><span class="line"><span class="keyword">operator</span>==(FunctionPtr <span class="type">const</span>&amp; f1, FunctionPtr <span class="type">const</span>&amp; f2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!f1 || !f2) &#123;</span><br><span class="line">        <span class="keyword">return</span> !f1 &amp;&amp; !f2;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> f<span class="number">1.</span>bridge-&gt;<span class="built_in">equals</span>(f<span class="number">2.</span>bridge);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span></span><br><span class="line"><span class="keyword">operator</span>!=(FunctionPtr <span class="type">const</span>&amp; f1, FunctionPtr <span class="type">const</span>&amp; f2) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(f1 == f2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该实现是正确的，但是不幸的是，它也有一个缺点：如果<code>FunctionPtr</code>被一个没有实现合适的<code>operator==</code>的函数对象（比如lambdas）赋值，或者是被这一类对象初始化，那么这个程序会遇到编译错误。这可能会很让人意外，因为<code>FunctionPtrs</code>的<code>operator==</code>可能根本就没有被使用，却遇到了编译错误。而诸如<code>std::vector</code>之类的模板，只要它们的<code>operator==</code>没有被使用，它们就可以被没有相应<code>operator==</code>的类型实例化。</p>
<p>这一<code>operator==</code>相关的问题是由类型擦除导致的：因为在给<code>FunctionPtr</code>赋值或者初始化的时候，我们会丢失函数对象的类型信息，因此在赋值或者初始化完成之前，就需要捕捉到所有所需要知道的该类型的信息。该信息就包含调用函数对象的<code>operator==</code>所需要的信息，因为我们并不知道它在什么时候会被用到。</p>
<p>幸运的是，我们可以使用基于SFINAE的萃取技术，在调用<code>operator==</code>之前，确认它是否可用，如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// for declval()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// for true_type and false_type</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IsEqualityComparable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// test convertibility of == and ! == to bool:</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">conv</span><span class="params">(<span class="type">bool</span>)</span></span>; <span class="comment">// to check convertibility to bool</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> std::true_type <span class="title">test</span><span class="params">(<span class="keyword">decltype</span>(conv(std::declval&lt;U</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span>&amp;&gt;() == std::declval&lt;U <span class="type">const</span>&amp;&gt;())),</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">decltype</span>(conv(!(std::declval&lt;U <span class="type">const</span>&amp;&gt;() == std::declval&lt;U</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span>&amp;&gt;()))))</span></span>;</span><br><span class="line">    <span class="comment">// fallback:</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> std::false_type <span class="title">test</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="keyword">decltype</span>(<span class="built_in">test</span>&lt;T&gt;(<span class="literal">nullptr</span>,</span><br><span class="line">    <span class="literal">nullptr</span>))::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上述<code>IsEqualityComparable</code>技术使用表达式测试萃取的典型形式：两个<code>test()</code>重载，其中一个包含了被封装在decltype中的用来测试的表达式，另一个通过省略号接受任意数量的参数。第一个<code>test()</code>试图通过==去比较两个<code>T const</code>类型的对象，然后确保两个结果都可以被隐式的转换成bool，并将可以转换为bool的结果传递给<code>operator!=()</code>。如果两个运算符都正常的话，参数类型都将是<code>void *</code>。</p>
<p>使用<code>IsEqualityComparable</code>，可以构建一个<code>TryEquals</code>类模板，它要么会调用<code>==</code>运算符，要么就在没有可用的<code>operator==</code>的时候抛出一个异常：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;isequalitycomparable.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">bool</span> EqComparable =</span><br><span class="line">    IsEqualityComparable&lt;T&gt;::value&gt;</span><br><span class="line"><span class="keyword">struct</span> TryEquals</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> <span class="built_in">equals</span>(T <span class="type">const</span>&amp; x1, T <span class="type">const</span>&amp; x2) &#123;</span><br><span class="line">        <span class="keyword">return</span> x1 == x2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotEqualityComparable</span> : <span class="keyword">public</span> std::exception</span><br><span class="line">&#123; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TryEquals</span>&lt;T, <span class="literal">false</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">equals</span><span class="params">(T <span class="type">const</span>&amp; x1, T <span class="type">const</span>&amp; x2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">NotEqualityComparable</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，通过在<code>SpecificFunctorBridge</code>中使用<code>TryEquals</code>，当被存储的函数对象类型一致，而且支持<code>operator==</code>的时候，就可以在<code>FunctionPtr</code>中提供对<code>operator==</code>的支持：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">equals</span><span class="params">(FunctorBridge&lt;R, Args...&gt; <span class="type">const</span>* fb)</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> specFb = <span class="built_in">dynamic_cast</span>&lt;SpecificFunctorBridge <span class="type">const</span>*&gt;(fb)) &#123;</span><br><span class="line">        <span class="keyword">return</span> TryEquals&lt;Functor&gt;::<span class="built_in">equals</span>(functor, specFb-&gt;functor);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//functors with different types are never equal:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="性能考量"><a href="#性能考量" class="headerlink" title="性能考量"></a>性能考量</h2><p>类型擦除技术提供了static和dynamic多态的一部分优点，但是并不是全部。尤其是，使用类型擦除技术产生的代码的性能更接近于动态多态，因为它们都是用虚函数实现了动态分配。因此某些static多态的传统优点（比如编译期将函数调用进行inline的能力）可能就被丢掉了。这一性能损失是否能够被察觉到，取决于具体的应用，但是通过比较被调用函数的运算量以及相关虚函数的运算量，有时候也很容易就能判断出来：如果二者比较接近，（比如FunctionPtr所作的只是对两个整数进行求和），类型擦除可能会比static多态要满很多。而如果函数调用执行的任务量比较大的话（比如访问数据库，对容器进行排列），那么type erasure带来的性能损失就很难被察觉到。</p>
<h1 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h1><h2 id="现代C-元编程的现状"><a href="#现代C-元编程的现状" class="headerlink" title="现代C++元编程的现状"></a>现代C++元编程的现状</h2><p>C++元编程是随着时间发展逐渐成形的。我们先来分类讨论多种在现代C++中经常使用的元<br>编程方法。</p>
<h3 id="值元编程（Value-Metaprogramming）"><a href="#值元编程（Value-Metaprogramming）" class="headerlink" title="值元编程（Value Metaprogramming）"></a>值元编程（Value Metaprogramming）</h3><p>在C++14中，一个在编译期计算平方根的函数可以被简单的写成这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">sqrt</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// handle cases where x and its square root are equal as a special case to simplify</span></span><br><span class="line">    <span class="comment">// the iteration criterion for larger x:</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// repeatedly determine in which half of a [lo, hi] interval the square root of x is located,</span></span><br><span class="line">    <span class="comment">// until the interval is reduced to just one value:</span></span><br><span class="line">    T lo = <span class="number">0</span>, hi = x;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">auto</span> mid = (hi+lo)/<span class="number">2</span>, midSquared = mid*mid;</span><br><span class="line">        <span class="keyword">if</span> (lo<span class="number">+1</span> &gt;= hi || midSquared == x) &#123;</span><br><span class="line">            <span class="comment">// mid must be the square root:</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="comment">//continue with the higher/lower half-interval:</span></span><br><span class="line">        <span class="keyword">if</span> (midSquared &lt; x) &#123;</span><br><span class="line">            lo = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该算法通过反复地选取一个包含x的平方根的中间值来计算结果（为了让收敛标准比较简单，对0和1的平方根做了特殊处理）。该<code>sqrt()</code>函数可以被在编译期或者运行期间计算：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sqrt</span>(<span class="number">25</span>) == <span class="number">5</span>, <span class="string">&quot;&quot;</span>); <span class="comment">//OK (evaluated at compile time)</span></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sqrt</span>(<span class="number">40</span>) == <span class="number">6</span>, <span class="string">&quot;&quot;</span>); <span class="comment">//OK (evaluated at compile time)</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, sqrt(40)+1&gt; arr; <span class="comment">//declares array of 7 elements (compile time)</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> l = <span class="number">53478</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sqrt</span>(l) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//prints 231 (evaluated at run time)</span></span><br></pre></td></tr></table></figure></p>
<p>在运行期间这一实现方式可能不是最高效的（在这里去开发机器的各种特性通常是值得的），但是由于该函数意在被用于编译期计算，绝对的效率并没有可移植性重要。</p>
<p>上面介绍的值元编程（比如在编译期间计算某些数值）偶尔会非常有用，但是在现代C++中还有另外两种可用的元编程方式（在C++14和C++17中）：类型元编程和混合元编程。</p>
<h3 id="类型元编程"><a href="#类型元编程" class="headerlink" title="类型元编程"></a>类型元编程</h3><p>考虑如下例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primary template: in general we yield the given type:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RemoveAllExtentsT</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// partial specializations for array types (with and without bounds):</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> SZ&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RemoveAllExtentsT</span>&lt;T[SZ]&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">typename</span> RemoveAllExtentsT&lt;T&gt;::Type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RemoveAllExtentsT</span>&lt;T[]&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">typename</span> RemoveAllExtentsT&lt;T&gt;::Type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">using</span> RemoveAllExtents = <span class="keyword">typename</span> RemoveAllExtentsT&lt;T&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>这里<code>RemoveAllExtents</code>就是一种类型元函数（比如一个返回类型的计算设备），它会从一个类型中移除掉任意数量的顶层“数组层”。就像下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RemoveAllExtents&lt;<span class="type">int</span>[]&gt; <span class="comment">// yields int</span></span><br><span class="line">RemoveAllExtents&lt;<span class="type">int</span>[<span class="number">5</span>][<span class="number">10</span>]&gt; <span class="comment">// yields int</span></span><br><span class="line">RemoveAllExtents&lt;<span class="type">int</span>[][<span class="number">10</span>]&gt; <span class="comment">// yields int</span></span><br><span class="line">RemoveAllExtents&lt;<span class="built_in">int</span>(*)[<span class="number">5</span>]&gt; <span class="comment">// yields int(*)[5]</span></span><br></pre></td></tr></table></figure></p>
<p>元函数通过偏特化来匹配高层次的数组，递归地调用自己并最终完成任务。如果数值计算的功能只适用于标量，那么其应用会很受限制。幸运的是，几乎有所得语言都至少有一种数值容器，这可以大大的提高该语言的能力。对于元编程也是这样：增加一个“类型容器”会大大的提高其自身的适用范围。幸运的是，现代C++提供了可以用来开发类似容器的机制。</p>
<h3 id="混合元编程"><a href="#混合元编程" class="headerlink" title="混合元编程"></a>混合元编程</h3><p>通过使用数值元编程和类型元编程，可以在编译期间计算数值和类型。但是最终我们关心的还是在运行期间的效果，因此在运行期间的代码中，我们将元程序用在那些需要类型和常量的地方。不过元编程能做的不仅仅是这些：我们可以在编译期间，以编程的方式组合一些有运行期效果的代码。我们称之为混合元编程。</p>
<p>下面通过一个简单的例子来说明这一原理：计算两个<code>std::array</code>的点乘结果。回忆一下，<code>std::array</code>是具有固定长度的容器模板，其声明如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> N&gt; <span class="keyword">struct</span> <span class="title class_">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>N</code>是<code>std::array</code>的长度。假设有两个类型相同的<code>std::array</code>对象，其点乘结果可以通过如下方式计算：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">dotProduct</span><span class="params">(std::array&lt;T, N&gt; <span class="type">const</span>&amp; x, std::array&lt;T, N&gt; <span class="type">const</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T result&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> k = <span class="number">0</span>; k&lt;N; ++k) &#123;</span><br><span class="line">        result += x[k]*y[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果对for循环进行直接编译的话，那么就会生成分支指令，相比于直接运行如下命令，这在一些机器上可能会增加运行成本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result += x[<span class="number">0</span>]*y[<span class="number">0</span>];</span><br><span class="line">result += x[<span class="number">1</span>]*y[<span class="number">1</span>];</span><br><span class="line">result += x[<span class="number">2</span>]*y[<span class="number">2</span>];</span><br><span class="line">result += x[<span class="number">3</span>]*y[<span class="number">3</span>];</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>幸运的是，现代编译器会针对不同的平台做出相应的最为高效的优化。但是为了便于讨论，下面重新实现一版不需要loop的<code>dotProduct()</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DotProductT</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> T <span class="title">result</span><span class="params">(T* a, T* b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *a * *b + DotProduct&lt;T, N<span class="number">-1</span>&gt;::<span class="built_in">result</span>(a<span class="number">+1</span>,b<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// partial specialization as end criteria</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DotProductT</span>&lt;T, <span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> T <span class="title">result</span><span class="params">(T*, T*)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> T&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">dotProduct</span><span class="params">(std::array&lt;T, N&gt; <span class="type">const</span>&amp; x, std::array&lt;T, N&gt; <span class="type">const</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DotProductT&lt;T, N&gt;::<span class="built_in">result</span>(x.<span class="built_in">begin</span>(), y.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>新的实现将计算放在了类模板<code>DotProductT</code>中。这样做的目的是为了使用类模板的递归实例化来计算结果，并能够通过部分特例化来终止递归。注意例子中<code>DotProductT</code>的每一次实例化是如何计算点乘中的一项结果、以及所有剩余结果的。对于<code>std::arrat&lt;T,N&gt;</code>，会对主模板进行N次实例化，对部分特例化的模板进行一次实例化。为了保证效率，编译期需要将每一次对静态成员函数<code>result()</code>的调用内联（inline）。</p>
<p>这段代码的主要特点是它融合了编译期计算（这里通过递归的模板实例化实现，这决定了代码的整体结构）和运行时计算（通过调用<code>result()</code>，决定了具体的运行期间的效果）。我们之前提到过，“类型容器”可以大大提高元编程的能力。我们同样看到固定长度的array在混合元编程中也非常有用。但是混合元编程中真正的“英雄容器”是tuple（元组）。Tuple是一串数值，且其中每个值的类型可以分别指定。C++标准库中包含了支持这一概念的类模板<code>std::tuple</code>。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;<span class="type">int</span>, std::string, <span class="type">bool</span>&gt; tVal&#123;<span class="number">42</span>, <span class="string">&quot;Answer&quot;</span>, <span class="literal">true</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>定义的变量tVal包含了三个类型分别为int, std::string和bool的值。因为tuple这一类容器在现代C++编程中非常重要。<code>tVal</code>的类型和下面<br>这个简单的struct类型非常类似：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyTriple</span> &#123;</span><br><span class="line">    <span class="type">int</span> v1;</span><br><span class="line">    std::string v2;</span><br><span class="line">    <span class="type">bool</span> v3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>既然对于array类型和（简单）的struct类型，我们有比较灵活的<code>std::array</code>和<code>std::tuple</code>与之对应，那么你可能会问，与简单的union对应的类似类型是否对混合元编程也很有益。答案是“yes”。C++标准库在C++17中为了这一目的引入了<code>std::variant</code>模板。</p>
<p>由于<code>std::tuple</code>和`std::variant都是异质类型（与struct类似），使用这些类型的混合元编程有时也被称为“异质元编程”。</p>
<h3 id="将混合元编程用于“单位类型”"><a href="#将混合元编程用于“单位类型”" class="headerlink" title="将混合元编程用于“单位类型”"></a>将混合元编程用于“单位类型”</h3><p>另一个可以展现混合元编程威力的例子是那些实现了不同单位类型的数值之间计算的库。相应的数值计算发生在程序运行期间，而单位计算则发生在编译期间。</p>
<p>下面会以一个极度精简的例子来做讲解。我们将用一个基于主单位的分数来记录相关单位。比如如果时间的主单位是秒，那么就用1/1000表示1微秒，用60/1表示一分钟。因此关键点就是要定义一个比例类型，使得每一个数值都有其自己的类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> N, <span class="type">unsigned</span> D = <span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> Ratio &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> num = N; <span class="comment">// numerator</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> den = D; <span class="comment">// denominator</span></span><br><span class="line">    <span class="keyword">using</span> Type = Ratio&lt;num, den&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在就可以定义在编译期对两个单位进行求和之类的计算：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implementation of adding two ratios:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R1, <span class="keyword">typename</span> R2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RatioAddImpl</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> den = R1::den * R2::den;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> num = R1::num * R2::den + R2::num * R1::den;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Ratio&lt;num, den&gt; Type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// using declaration for convenient usage:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R1, <span class="keyword">typename</span> R2&gt;</span><br><span class="line"><span class="keyword">using</span> RatioAdd = <span class="keyword">typename</span> RatioAddImpl&lt;R1, R2&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以在编译期计算两个比率之和了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> R1 = Ratio&lt;<span class="number">1</span>,<span class="number">1000</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> R2 = Ratio&lt;<span class="number">2</span>,<span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> RS = RatioAdd&lt;R1,R2&gt;; <span class="comment">//RS has type Ratio&lt;2003,2000&gt;</span></span><br><span class="line">std::cout &lt;&lt; RS::num &lt;&lt; <span class="string">&quot;/&quot;</span>&lt;&lt; RS::den &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//prints 2003/3000</span></span><br><span class="line"><span class="keyword">using</span> RA = RatioAdd&lt;Ratio&lt;<span class="number">2</span>,<span class="number">3</span>&gt;,Ratio&lt;<span class="number">5</span>,<span class="number">7</span>&gt;&gt;; <span class="comment">//RA has type Ratio&lt;29,21&gt;</span></span><br><span class="line">std::cout &lt;&lt; RA::num &lt;&lt; <span class="string">&quot;/&quot;</span>&lt;&lt; RA::den &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//prints 29/21</span></span><br></pre></td></tr></table></figure></p>
<p>然后就可以为时间段定义一个类模板，用一个任意数值类型和一个<code>Ratio&lt;&gt;</code>实例化之后的类型作为其模板参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// duration type for values of type T with unit type U:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = Ratio&lt;<span class="number">1</span>&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> Duration &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ValueType = T;</span><br><span class="line">    <span class="keyword">using</span> UnitType = <span class="keyword">typename</span> U::Type;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ValueType val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Duration</span><span class="params">(ValueType v = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    : val(v) &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> ValueType <span class="title">value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>比较有意思的地方是对两个<code>Durations</code>求和的<code>operator+</code>运算符的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// adding two durations where unit type might differ:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> U1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> U2&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">constexpr</span> <span class="keyword">operator</span>+(Duration&lt;T1, U1&gt; <span class="type">const</span>&amp; lhs, Duration&lt;T2, U2&gt; <span class="type">const</span>&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// resulting type is a unit with 1 a nominator and</span></span><br><span class="line">    <span class="comment">// the resulting denominator of adding both unit type fractions</span></span><br><span class="line">    <span class="keyword">using</span> VT = Ratio&lt;<span class="number">1</span>,RatioAdd&lt;U1,U2&gt;::den&gt;;</span><br><span class="line">    <span class="comment">// resulting value is the sum of both values</span></span><br><span class="line">    <span class="comment">// converted to the resulting unit type:</span></span><br><span class="line">    <span class="keyword">auto</span> val = lhs.<span class="built_in">value</span>() * VT::den / U1::den * U1::num +</span><br><span class="line">    rhs.<span class="built_in">value</span>() * VT::den / U2::den * U2::num;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Duration</span>&lt;<span class="keyword">decltype</span>(val), VT&gt;(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里参数所属的单位类型可以不同，比如分别为U1和U2。然后可以基于U1和U2计算最终的时间段，其类型为一个新的分子为1的单位类型。基于此，可以编译如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">77</span>;</span><br><span class="line"><span class="keyword">auto</span> a = Duration&lt;<span class="type">int</span>, Ratio&lt;<span class="number">1</span>,<span class="number">1000</span>&gt;&gt;(x); <span class="comment">// x milliseconds</span></span><br><span class="line"><span class="keyword">auto</span> b = Duration&lt;<span class="type">int</span>, Ratio&lt;<span class="number">2</span>,<span class="number">3</span>&gt;&gt;(y); <span class="comment">// y 2/3 seconds</span></span><br><span class="line"><span class="keyword">auto</span> c = a + b; <span class="comment">//computes resulting unit type 1/3000 seconds</span></span><br><span class="line"><span class="comment">//and generates run-time code for c = a*3 + b*2000</span></span><br></pre></td></tr></table></figure></p>
<p>此处“混合”的效果体现在，在计算c的时候，编译器会在编译期决定结果的单位类型<code>Ratio&lt;1,3000&gt;</code>，并产生出可以在程序运行期间计算最终结果的代码（结果会被根据单位类型进行调整）。</p>
<p>由于数值类型是由模板参数决定的，因此可以将int甚至是异质类型用于Duration类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> d = Duration&lt;<span class="type">double</span>, Ratio&lt;<span class="number">1</span>,<span class="number">3</span>&gt;&gt;(<span class="number">7.5</span>); <span class="comment">// 7.5 1/3 seconds</span></span><br><span class="line"><span class="keyword">auto</span> e = Duration&lt;<span class="type">int</span>, Ratio&lt;<span class="number">1</span>&gt;&gt;(<span class="number">4</span>); <span class="comment">// 4 seconds</span></span><br><span class="line"><span class="keyword">auto</span> f = d + e; <span class="comment">//computes resulting unit type 1/3 seconds</span></span><br><span class="line"><span class="comment">// and generates code for f = d + e*3</span></span><br></pre></td></tr></table></figure></p>
<p>而且如果相应的数值在编译期是已知的话，编译器甚至可以在编译期进行以上计算（因为上文中的<code>operator+</code>是<code>constexpr</code>）。</p>
<h2 id="反射元编程的维度"><a href="#反射元编程的维度" class="headerlink" title="反射元编程的维度"></a>反射元编程的维度</h2><p>上文中介绍了基于constexpr的“值元编程”和基于递归实例化的“类型元编程”。这两种在现代C++中可用的选项采用了明显不同的方式来驱动计算。事实证明“值元编程”也可以通过模板的递归实例化来实现，在引入C++11的constexpr函数之前，这也正是其实现方式。比如下面的代码使用递归实例化来计算一个整数的平方根：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primary template to compute sqrt(N)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N, <span class="type">int</span> LO=<span class="number">1</span>, <span class="type">int</span> HI=N&gt;</span><br><span class="line"><span class="keyword">struct</span> Sqrt &#123;</span><br><span class="line">    <span class="comment">// compute the midpoint, rounded up</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = (LO+HI<span class="number">+1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// search a not too large value in a halved interval</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> value = (N&lt;mid*mid) ?</span><br><span class="line">    Sqrt&lt;N,LO,mid<span class="number">-1</span>&gt;::value : Sqrt&lt;N,mid,HI&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// partial specialization for the case when LO equals HI</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N, <span class="type">int</span> M&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sqrt</span>&lt;N,M,M&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> value = M;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里元函数的输入是一个非类型模板参数，而不是一个函数参数，用来追踪中间值边界的“局部变量”也是非类型模板参数。显然这个方法远不如<code>constexpr</code>函数友好，但是我接下来依然会探讨这段代码是如何消耗编译器资源的。</p>
<p>无论如何，我们已经看到元编程的计算引擎可以有多种潜在的选择。但是计算不是唯一的一个我们应该在其中考虑相关选项的维度。一个综合的元编程解决方案应该在如下3个维度中间做选择：</p>
<ul>
<li>计算维度（Compution）</li>
<li>反射维度（Reflection）</li>
<li>生成维度（Generation）</li>
</ul>
<p>反射维度指的是以编程的方式检测程序特性的能力。生成维度指的是为程序生成额外代码的能力。</p>
<p>我们已经见过计算维度中的两个选项：递归实例化和constexpr计算。目前已有的类型萃取是基于模板实例化的，而且C++总是会提供额外的语言特性或者是“固有的”库元素来在编译期生成包含反射信息的类模板实例。这一方法和基于模板递归实例化进行的计算比较相似。但是不幸的是，类模板实例会占用比较多的编译器内存，而且这部分内存要直到编译结束才会被释放（否则的话编译时间会大大延长）。</p>
<h2 id="递归实例化的代价"><a href="#递归实例化的代价" class="headerlink" title="递归实例化的代价"></a>递归实例化的代价</h2><p>现在来分析<code>Sqrt&lt;&gt;</code>模板。主模板是由模板参数N（被计算平方根的值）和其它两个可选参数触发的、常规的递归计算。两个可选的参数分别是结果的上限和下限。如果只用一个参数调用该模板，那么其平方根最小是1，最大是其自身。递归会按照二分查找的方式进行下去。在模板内部会计算value是在从LO到HI这个区间的上半部还是下半部。这一分支判断是通过运算符<code>?:</code>实现的。如果mid2比N大，那么就继续在上半部分查找，否在就在下半部分查找。</p>
<p>偏特例化被用来在LO和HI的值都为M的时候结束递归，这个值也就是我们最终所要计算的结果。</p>
<p>实例化模板的成本并不低廉：即使是比较适中的类模板，其实例依然有可能占用数KB的内存，而且这部分被占用的内存在编译完成之前不可以被回收利用。我们先来分析一个使用了Sqrt模板的简单程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sqrt1.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sqrt&lt;16&gt;::value = &quot;</span> &lt;&lt; Sqrt&lt;<span class="number">16</span>&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sqrt&lt;25&gt;::value = &quot;</span> &lt;&lt; Sqrt&lt;<span class="number">25</span>&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sqrt&lt;42&gt;::value = &quot;</span> &lt;&lt; Sqrt&lt;<span class="number">42</span>&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sqrt&lt;1&gt;::value = &quot;</span> &lt;&lt; Sqrt&lt;<span class="number">1</span>&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>表达式<code>Sqrt&lt;16&gt;::value</code>被扩展成<code>Sqrt&lt;16,1,16&gt;::value</code>。在模板内部，元程序按照如下方式计算<code>Sqrt&lt;16,1,16&gt;::value</code>的值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mid = (<span class="number">1</span><span class="number">+16</span><span class="number">+1</span>)/<span class="number">2</span> = <span class="number">9</span></span><br><span class="line">value = (<span class="number">16</span>&lt;<span class="number">9</span>*<span class="number">9</span>) ? Sqrt&lt;<span class="number">16</span>,<span class="number">1</span>,<span class="number">8</span>&gt;::value : Sqrt&lt;<span class="number">16</span>,<span class="number">9</span>,<span class="number">16</span>&gt;::value</span><br><span class="line">      = (<span class="number">16</span>&lt;<span class="number">81</span>) ? Sqrt&lt;<span class="number">16</span>,<span class="number">1</span>,<span class="number">8</span>&gt;::value : Sqrt&lt;<span class="number">16</span>,<span class="number">9</span>,<span class="number">16</span>&gt;::value</span><br><span class="line">      = Sqrt&lt;<span class="number">16</span>,<span class="number">1</span>,<span class="number">8</span>&gt;::value</span><br></pre></td></tr></table></figure></p>
<p>接着这个值会被以<code>Sqrt&lt;16,1,8&gt;::value</code>的形式计算，其会被接着展开为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mid = (<span class="number">1</span><span class="number">+8</span><span class="number">+1</span>)/<span class="number">2</span> = <span class="number">5</span></span><br><span class="line">value = (<span class="number">16</span>&lt;<span class="number">5</span>*<span class="number">5</span>) ? Sqrt&lt;<span class="number">16</span>,<span class="number">1</span>,<span class="number">4</span>&gt;::value : Sqrt&lt;<span class="number">16</span>,<span class="number">5</span>,<span class="number">8</span>&gt;::value</span><br><span class="line">      = (<span class="number">16</span>&lt;<span class="number">25</span>) ? Sqrt&lt;<span class="number">16</span>,<span class="number">1</span>,<span class="number">4</span>&gt;::value : Sqrt&lt;<span class="number">16</span>,<span class="number">5</span>,<span class="number">8</span>&gt;::value</span><br><span class="line">      = Sqrt&lt;<span class="number">16</span>,<span class="number">1</span>,<span class="number">4</span>&gt;::value</span><br></pre></td></tr></table></figure></p>
<h3 id="追踪所有的实例化过程"><a href="#追踪所有的实例化过程" class="headerlink" title="追踪所有的实例化过程"></a>追踪所有的实例化过程</h3><p>上文中主要分析了被用来计算16的平方根的实例化过程。但是当编译期计算：<code>(16&lt;=8*8) ? Sqrt&lt;16,1,8&gt;::value : Sqrt&lt;16,9,16&gt;::value</code>的时候，它并不是只计算真正用到了的分支，同样也会计算没有用到的分支<code>Sqrt&lt;16,9,16&gt;</code>。而且，由于代码试图通过运算符::访问最终实例化出来的类的成员，该类中所有的成员都会被实例化。也就是说<code>Sqrt&lt;16,9,16&gt;</code>的完全实例化会导致<code>Sqrt&lt;16,9,12&gt;</code>和<code>Sqrt&lt;16,13,16&gt;</code>都会被完全实例化。仔细分析以上过程，会发现最终会实例化出很多的实例，数量上几乎是N的两倍。</p>
<p>幸运的是，有一些技术可以被用来降低实例化的数目。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ifthenelse.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// primary template for main recursive step</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N, <span class="type">int</span> LO=<span class="number">1</span>, <span class="type">int</span> HI=N&gt;</span><br><span class="line"><span class="keyword">struct</span> Sqrt &#123;</span><br><span class="line">    <span class="comment">// compute the midpoint, rounded up</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = (LO+HI<span class="number">+1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// search a not too large value in a halved interval</span></span><br><span class="line">    <span class="keyword">using</span> SubT = IfThenElse&lt;(N&lt;mid*mid),</span><br><span class="line">        Sqrt&lt;N,LO,mid<span class="number">-1</span>&gt;,</span><br><span class="line">        Sqrt&lt;N,mid,HI&gt;&gt;;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> value = SubT::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// partial specialization for end of recursion criterion</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N, <span class="type">int</span> S&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sqrt</span>&lt;N, S, S&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> value = S;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>IfThenElse</code>模板被用来基于一个布尔常量在两个类型之间做选择。如果布尔型常量是true，那么会选择第一个类型，否则就选择第二个类型。一个比较重要的、需要记住的点是：为一个类模板的实例定义类型别名，不会导致C++编译器去实例化该实例。因此使用如下代码时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SubT = IfThenElse&lt;(N&lt;mid*mid),</span><br><span class="line">    Sqrt&lt;N,LO,mid<span class="number">-1</span>&gt;,</span><br><span class="line">    Sqrt&lt;N,mid,HI&gt;&gt;;</span><br></pre></td></tr></table></figure></p>
<p>既不会完全实例化<code>Sqrt&lt;N,LO,mid-1&gt;</code>也不会完全实例化<code>Sqrt&lt;N,mid,HI&gt;</code>。在调用<code>SubT::value</code>的时候，只有真正被赋值给SubT的那一个实例才会被完全实例化。和之前的方法相比，这会让实例化的数量和log2N成正比：当N比较大的时候，这会大大降低元程序实例化的成本。</p>
<h2 id="计算完整性"><a href="#计算完整性" class="headerlink" title="计算完整性"></a>计算完整性</h2><p>从以上的<code>Sqrt&lt;&gt;</code>的例子可以看出，一个模板元程序可能会包含以下内容：</p>
<ul>
<li>状态变量：模板参数</li>
<li>循环结构：通过递归实现</li>
<li>执行路径选择：通过条件表达式或者偏特例化实现</li>
<li>整数运算</li>
</ul>
<h2 id="递归实例化和递归模板参数"><a href="#递归实例化和递归模板参数" class="headerlink" title="递归实例化和递归模板参数"></a>递归实例化和递归模板参数</h2><p>考虑如下递归模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Doublify</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Trouble</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> LongType = Doublify&lt;<span class="keyword">typename</span> Trouble&lt;N<span class="number">-1</span>&gt;::LongType,</span><br><span class="line">    <span class="keyword">typename</span> Trouble&lt;N<span class="number">-1</span>&gt;::LongType&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Trouble</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> LongType = <span class="type">double</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Trouble&lt;<span class="number">10</span>&gt;::LongType ouch;</span><br></pre></td></tr></table></figure></p>
<p><code>Trouble&lt;10&gt;::LongType</code>的使用并不是简单地触发形如<code>Trouble&lt;9&gt;</code>, <code>Trouble&lt;8&gt;</code>, …,<code>Trouble&lt;0&gt;</code>地递归实例化，还会用越来越复杂地类型实例化Doublify。表展示了其快速地增长方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型别名</th>
<th>底层类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Trouble<0>::LongType</td>
<td>double</td>
</tr>
<tr>
<td>Trouble<1>::LongType</td>
<td>Doublify<double,double></td>
</tr>
<tr>
<td>Trouble<2>::LongType</td>
<td>Doublify<Doublify<double,double>,Doublify<double,double>&gt;</td>
</tr>
<tr>
<td>Trouble<3>::LongType</td>
<td>Doublify<Doublify<Doublify<double,double>,Doublify<double,double>&gt;,<Doublify<double,double>,Doublify<double,double>&gt;&gt;</td>
</tr>
</tbody>
</table>
</div>
<p>就如从表23.1中看到的那样，<code>Trouble&lt;N&gt;::LongType</code>类型的复杂度与N成指数关系。在早期C++中，这一编码方式的实现和模板签名<code>template-id</code>的长度成正比。这些编译器会使用大于10,000个字符来表达<code>Trouble&lt;N&gt;::LongType</code>。</p>
<p>新的C++实现使用了一种聪明的压缩技术来大大降低名称编码（比如对于<code>Trouble&lt;N&gt;::LongType</code>，只需要用数百个字符）的增长速度。如果没有为某些模板实例生成低层级的代码，那么相关类型的名字就是不需要的，新的编译器就不会为这些类型产生名字。除此之外，其它情况都没有改善，因此在组织递归实例化代码的时候，最好不要让模板参数也嵌套递归。</p>
<h2 id="枚举值还是静态常量"><a href="#枚举值还是静态常量" class="headerlink" title="枚举值还是静态常量"></a>枚举值还是静态常量</h2><p>在早期C++中，枚举值是唯一可以用来在类的声明中、创建可用于类成员的“真正的常量”（也称常量表达式）的方式。比如通过它们可以定义Pow3元程序来计算3的指数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primary template to compute 3 to the Nth</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pow3</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; value = <span class="number">3</span> * Pow3&lt;N<span class="number">-1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// full specialization to end the recursion</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pow3</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; value = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在C++98标准中引入了类内静态常量初始化的概念，因此Pow3元程序可以被写成这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primary template to compute 3 to the Nth</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pow3</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> <span class="type">const</span> value = <span class="number">3</span> * Pow3&lt;N<span class="number">-1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// full specialization to end the recursion</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pow3</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> <span class="type">const</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是上面代码中有一个问题：静态常量成员是左值。因此如果我们有如下函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> <span class="type">const</span>&amp;)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>然后我们将元程序的结果传递给它：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">foo</span>(Pow3&lt;<span class="number">7</span>&gt;::value);</span><br></pre></td></tr></table></figure></p>
<p>编译器需要传递<code>Pow3&lt;7&gt;::value</code>的地址，因此必须实例化静态成员并为之开辟内存。这样该计算就不是一个纯正的“编译期”程序了。</p>
<p>枚举值不是左值（也就是说它们没有地址）。因此当将其按引用传递时，不会用到静态内存。几乎等效于将被计算值按照字面值传递。因此本书第一版建议在这一类应用中使用枚举值，而不是静态常量。</p>
<p>不过在C++中，引入了constexpr静态数据成员，并且其使用不限于整型类型。这并没有解决上文中关于地址的问题，但是即使如此，它也是用来产生元程序结果的常规方法。其优点是，它可以有正确的类型（相对于人工的枚举类型而言），而且当用auto声明静态成员的类型时，可以对其类型进行推断。C++17则引入了inline的静态数据成员，这解决了上面提到的地址问题，而且可以和constexpr一起使用。</p>
<h1 id="类型列表（Typelists）"><a href="#类型列表（Typelists）" class="headerlink" title="类型列表（Typelists）"></a>类型列表（Typelists）</h1><h2 id="类型列表剖析"><a href="#类型列表剖析" class="headerlink" title="类型列表剖析"></a>类型列表剖析</h2><p>类型列表指的是一种代表了一组类型，并且可以被模板元编程操作的类型。它提供了典型的列表操作方法：遍历列表中的元素，添加元素或者删除元素。但是类型列表和大多数运行期间的数据结构都不同（比如<code>std::list</code>），它的值不允许被修改。向类型列表中添加一个元素并不会修改原始的类型列表，只是会创建一个新的、包含了原始类型列表和新添加元素的类型列表。</p>
<p>类型列表通常是按照类模板特例的形式实现的，它将自身的内容（包含在模板参数中的类型以及类型之间的顺序）编码到了参数包中。一种将其内容编码到参数包中的类型列表的直接实现方式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Elements&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Typelist</span></span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>Typelist</code>中的元素被直接写成其模板参数。一个空的类型列表被写为<code>Typelist&lt;&gt;</code>，一个只包含int的类型列表被写为<code>Typelist&lt;int&gt;</code>。下面是一个包含了所有有符号整型的类型列表：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SignedIntegralTypes =</span><br><span class="line">Typelist&lt;<span class="type">signed</span> <span class="type">char</span>, <span class="type">short</span>, <span class="type">int</span>, <span class="type">long</span>, <span class="type">long</span> <span class="type">long</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<p>操作这个类型列表需要将其拆分，通常的做法是将第一个元素（the head）从剩余的元素中分离（the tail）。比如Front元函数会从类型列表中提取第一个元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FrontT</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FrontT</span>&lt;Typelist&lt;Head, Tail...&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = Head;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">using</span> Front = <span class="keyword">typename</span> FrontT&lt;List&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>这样<code>FrontT&lt;SignedIntegralTypes&gt;::Type</code>（或者更简洁的记作<code>FrontT&lt;SignedIntegralTypes&gt;</code>）返回的就是<code>signed char</code>。同样PopFront元函数会删除类型列表中的第一个元素。在实现上它会将类型列表中的元素分为头（head）和尾（tail）两部分，然后用尾部的元素创建一个新的Typelist特例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PopFrontT</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PopFrontT</span>&lt;Typelist&lt;Head, Tail...&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = Typelist&lt;Tail...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">using</span> PopFront = <span class="keyword">typename</span> PopFrontT&lt;List&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p><code>PopFront&lt;SignedIntegralTypes&gt;</code>会产生如下类型列表：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Typelist&lt;<span class="type">short</span>, <span class="type">int</span>, <span class="type">long</span>, <span class="type">long</span> <span class="type">long</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>同样也可以向类型列表中添加元素，只需要将所有已经存在的元素捕获到一个参数包中，然后在创建一个包含了所有元素的TypeList特例就行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">typename</span> NewElement&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PushFrontT</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Elements, <span class="keyword">typename</span> NewElement&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PushFrontT</span>&lt;Typelist&lt;Elements...&gt;, NewElement&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = Typelist&lt;NewElement, Elements...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">typename</span> NewElement&gt;</span><br><span class="line"><span class="keyword">using</span> PushFront = <span class="keyword">typename</span> PushFrontT&lt;List, NewElement&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>和预期的一样，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PushFront&lt;SignedIntegralTypes, <span class="type">bool</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>会生成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Typelist&lt;<span class="type">bool</span>, <span class="type">signed</span> <span class="type">char</span>, <span class="type">short</span>, <span class="type">int</span>, <span class="type">long</span>, <span class="type">long</span> <span class="type">long</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="类型列表的算法"><a href="#类型列表的算法" class="headerlink" title="类型列表的算法"></a>类型列表的算法</h2><p>基础的类型列表操作Front，PopFront和PushFront可以被组合起来实现更有意思的列表操作。比如通过将<code>PushFront</code>作用于<code>PopFront</code>可以实现对第一个元素的替换：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Type = PushFront&lt;PopFront&lt;SignedIntegralTypes&gt;, <span class="type">bool</span>&gt;;</span><br><span class="line"><span class="comment">// equivalent to Typelist&lt;bool, short, int, long, long long&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>更近一步，我们可以按照模板原函数的实现方式，实现作用于类型列表的诸如搜索、转换和反转等操作。</p>
<h3 id="索引（Indexing）"><a href="#索引（Indexing）" class="headerlink" title="索引（Indexing）"></a>索引（Indexing）</h3><p>类型列表的一个非常基础的操作是从列表中提取某个特定的类型。接下来我们将这一操作推广到可以提取第Nth个元素。比如，为了提取给定类型列表中的第2个元素，可以这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> TL = NthElement&lt;Typelist&lt;<span class="type">short</span>, <span class="type">int</span>, <span class="type">long</span>&gt;, <span class="number">2</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<p>这相当于将<code>TL</code>作为long的别名使用。<code>NthElement</code>操作的实现方式是使用一个递归的元程序遍历typelist中的元素，直到找到所需元素为止：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursive case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="type">unsigned</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NthElementT</span> : <span class="keyword">public</span> NthElementT&lt;PopFront&lt;List&gt;, N<span class="number">-1</span>&gt;</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="comment">// basis case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NthElementT</span>&lt;List, <span class="number">0</span>&gt; : <span class="keyword">public</span> FrontT&lt;List&gt;</span><br><span class="line">&#123; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="type">unsigned</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> NthElement = <span class="keyword">typename</span> NthElementT&lt;List, N&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>首先来看由N = 0部分特例化出来的基本情况。这一特例化会通过返回类型列表中的第一个元素来终止递归。其方法是对<code>FrontT&lt;List&gt;</code>进行public继承，这样<code>FrontT&lt;List&gt;</code>作为类型列表中第一个元素的Type类型别名，就可以被作为NthElement的结果使用了。</p>
<p>作为模板主要部分的递归代码，会遍历类型列表。由于偏特化部分保证了<code>N &gt; 0</code>，递归部分的代码会不断地从剩余列表中删除第一个元素并请求第N-1个元素。在我们的例子中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NthElementT&lt;Typelist&lt;<span class="type">short</span>, <span class="type">int</span>, <span class="type">long</span>&gt;, <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><br>继承自：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NthElementT&lt;Typelist&lt;<span class="type">int</span>, <span class="type">long</span>&gt;, <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>而它又继承自：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NthElementT&lt;Typelist&lt;<span class="type">long</span>&gt;, <span class="number">0</span>&gt;</span><br></pre></td></tr></table></figure><br>这里遇到了最基本的N = 0的情况，它继承自提供了最终结果Type的<code>FrontT&lt;Typelist&lt;long&gt;&gt;</code>。</p>
<h3 id="寻找最佳匹配"><a href="#寻找最佳匹配" class="headerlink" title="寻找最佳匹配"></a>寻找最佳匹配</h3><p>有些类型列表算法会去查找类型列表中的数据。例如可能想要找出类型列表中最大的类型（比如为了开辟一段可以存储类型列表中任意类型的内存）。这同样可以通过递归模板元程序实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LargestTypeT</span>;</span><br><span class="line"><span class="comment">// recursive case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LargestTypeT</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> First = Front&lt;List&gt;;</span><br><span class="line">    <span class="keyword">using</span> Rest = <span class="keyword">typename</span> LargestTypeT&lt;PopFront&lt;List&gt;&gt;::Type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = IfThenElse&lt;(<span class="built_in">sizeof</span>(First) &gt;= <span class="built_in">sizeof</span>(Rest)), First, Rest&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// basis case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LargestTypeT</span>&lt;Typelist&lt;&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="type">char</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">using</span> LargestType = <span class="keyword">typename</span> LargestTypeT&lt;List&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p><code>LargestType</code>算法会返回类型列表中第一个最大的类型。比如对于<code>Typelist&lt;bool, int, long, short&gt;</code>，该算法会返回第一个大小和long相同的类型，可能是int也可能是long，取决于你的平台。</p>
<p>由于递归算法的使用，对<code>LargestTypeT</code>的调用次数会翻倍。它使用了first/rest的概念，分三步完成任务。在第一步中，它先只基于第一个元素计算出部分结果，在本例中是将第一个元素放置到First中。接下来递归地计算类型列表中剩余部分的结果，并将结果放置在Rest中。比如对于类型列表<code>Typelist&lt;bool, int, long, short&gt;</code>，在递归的第一步中First是bool，而Rest是该算法作用于<code>Typelist&lt;int, long, short&gt;</code>得到的结果。最后在第三步中综合First和Rest得到最终结果。此处，<code>IfThenElse</code>会选出列表中第一个元素（First）和到目前为止的最优解（Rest）中类型最大的那一个。&gt;=的使用会倾向于选择第一个出现的最大的类型。</p>
<p>递归会在类型列表为空时终结。默认情况下我们将char用作哨兵类型来初始化该算法，因为任何类型都不会比char小。</p>
<p>注意上文中的基本情况显式的用到了空的类型列表<code>Typelist&lt;&gt;</code>。这样有点不太好，因为它可能会妨碍到其它类型的类型列表的使用。为了解决这一问题，引入了<code>IsEmpty</code>元函数，它可以被用来判断一个类型列表是否为空：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IsEmpty</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IsEmpty</span>&lt;Typelist&lt;&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>结合<code>IsEmpty</code>，可以像下面这样将<code>LargestType</code>实现成适用于任意支持了<code>Front</code>，<code>PopFront</code>和<code>IsEmpty</code>的类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="type">bool</span> Empty = IsEmpty&lt;List&gt;::value&gt;</span><br><span class="line"><span class="keyword">class</span> LargestTypeT;</span><br><span class="line"><span class="comment">// recursive case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LargestTypeT</span>&lt;List, <span class="literal">false</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> Contender = Front&lt;List&gt;;</span><br><span class="line">    <span class="keyword">using</span> Best = <span class="keyword">typename</span> LargestTypeT&lt;PopFront&lt;List&gt;&gt;::Type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = IfThenElse&lt;(<span class="built_in">sizeof</span>(Contender) &gt;= <span class="built_in">sizeof</span>(Best)),Contender, Best&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// basis case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LargestTypeT</span>&lt;List, <span class="literal">true</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="type">char</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">using</span> LargestType = <span class="keyword">typename</span> LargestTypeT&lt;List&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>默认的<code>LargestTypeT</code>的第二个模板参数<code>Empty</code>会检查一个类型列表是否为空。如果不为空，就递归地继续在剩余的列表中查找。如果为空，就会终止递归并返回作为初始结果的char。</p>
<h3 id="向类型类表中追加元素"><a href="#向类型类表中追加元素" class="headerlink" title="向类型类表中追加元素"></a>向类型类表中追加元素</h3><p>通过<code>PushFront</code>可以向类型列表的头部添加一个元素，并产生一个新的类型列表。除此之外我们还希望能够像在程序运行期间操作<code>std::list</code>和<code>std::vector</code>那样，向列表的末尾追加一个元素。对于我们的Typelist模板，为实现支持这一功能的PushBack，只需要<code>PushFront</code>做一点小的修改：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">typename</span> NewElement&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PushBackT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Elements, <span class="keyword">typename</span> NewElement&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PushBackT</span>&lt;Typelist&lt;Elements...&gt;, NewElement&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = Typelist&lt;Elements..., NewElement&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">typename</span> NewElement&gt;</span><br><span class="line"><span class="keyword">using</span> PushBack = <span class="keyword">typename</span> PushBackT&lt;List, NewElement&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>不过和实现<code>LargestType</code>的算法一样，可以只用<code>Front</code>，<code>PushFront</code>，<code>PopFront</code>和<code>IsEmpty</code>等基础操作实现一个更通用的PushBack算法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">typename</span> NewElement, <span class="type">bool</span> = IsEmpty&lt;List&gt;::value&gt;</span><br><span class="line"><span class="keyword">class</span> PushBackRecT;</span><br><span class="line"><span class="comment">// recursive case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">typename</span> NewElement&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PushBackRecT</span>&lt;List, NewElement, <span class="literal">false</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> Head = Front&lt;List&gt;;</span><br><span class="line">    <span class="keyword">using</span> Tail = PopFront&lt;List&gt;;</span><br><span class="line">    <span class="keyword">using</span> NewTail = <span class="keyword">typename</span> PushBackRecT&lt;Tail, NewElement&gt;::Type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = PushFront&lt;Head, NewTail&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// basis case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">typename</span> NewElement&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PushBackRecT</span>&lt;List, NewElement, <span class="literal">true</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = PushFront&lt;List, NewElement&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// generic push-back operation:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">typename</span> NewElement&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PushBackT</span> : <span class="keyword">public</span> PushBackRecT&lt;List, NewElement&gt; &#123; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">typename</span> NewElement&gt;</span><br><span class="line"><span class="keyword">using</span> PushBack = <span class="keyword">typename</span> PushBackT&lt;List, NewElement&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p><code>PushBackRecT</code>会自行管理递归。对于最基本的情况，用<code>PushFront</code>将<code>NewElement</code>添加到空的类型列表中。递归部分的代码则要有意思的多：它首先将类型列表分成首元素（Head）和一个包含了剩余元素的新的类型列表（Tail）。新元素则被追加到Tail的后面，这样递归的进行下去，就会生成一个NewTail。然后再次使用<code>PushFront</code>将Head添加到NewTail的头部，生成最终的类型列表。接下来以下面这个简单的例子为例展开递归的调用过程：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PushBackRecT&lt;Typelist&lt;<span class="type">short</span>, <span class="type">int</span>&gt;, <span class="type">long</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>在最外层的递归代码中，Head会被解析成short，Tail则被解析成<code>Typelist&lt;int&gt;</code>。然后递归到：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PushBackRecT&lt;Typelist&lt;<span class="type">int</span>&gt;, <span class="type">long</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中Head会被解析成int，Tail则被解析成<code>Typelist&lt;&gt;</code>。然后继续递归计算：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PushBackRecT&lt;Typelist&lt;&gt;, <span class="type">long</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>这会触发最基本的情况并返回<code>PushFront&lt;Typelist&lt;&gt;, long&gt;</code>，其结果是<code>Typelist&lt;long&gt;</code>。然后返回上一层递归，将之前的Head添加到返回结果的头部：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PushFront&lt;<span class="type">int</span>, Typelist&lt;<span class="type">long</span>&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>它会返回<code>Typelist&lt;int, long&gt;</code>。然后继续返回上一层递归，将最外层的Head（short）添加到返回结果的头部：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PushFront&lt;<span class="type">short</span>, Typelist&lt;<span class="type">int</span>, <span class="type">long</span>&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后就得到了最终的结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Typelist&lt;<span class="type">short</span>, <span class="type">int</span>, <span class="type">long</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>通用版的<code>PushBackRecT</code>适用于任何类型的类型列表。计算过程中它需要的模板实例的数量和类型列表的长度N成正比（如果类型列表的长度为N，那么<code>PushBackRecT</code>实例和<code>PushFrontT</code>实例的数目都是N+1，<code>FrontT</code>和<code>PopFront</code>实例的数量为N）。</p>
<h3 id="类型列表的反转"><a href="#类型列表的反转" class="headerlink" title="类型列表的反转"></a>类型列表的反转</h3><p>当类型列表的元素之间有某种顺序的时候，对于某些算法而言，如果能够反转该顺序的话，事情将会变得很方便。比如<code>SignedIntegralTypes</code>中元素是按整型大小的等级递增的。但是对其元素反转之后得到的<code>Typelist&lt;long, long, long, int, short, signed char&gt;</code>可能会更有用。下面的Reverse算法实现了相应的元函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="type">bool</span> Empty = IsEmpty&lt;List&gt;::value&gt;</span><br><span class="line"><span class="keyword">class</span> ReverseT;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">using</span> Reverse = <span class="keyword">typename</span> ReverseT&lt;List&gt;::Type;</span><br><span class="line"><span class="comment">// recursive case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReverseT</span>&lt;List, <span class="literal">false</span>&gt;:<span class="keyword">public</span> PushBackT&lt;Reverse&lt;PopFront&lt;List&gt;&gt;,</span><br><span class="line">    Front&lt;List&gt;&gt; &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// basis case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReverseT</span>&lt;List, <span class="literal">true</span>&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = List;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>该元函数的基本情况是一个作用于空的类型列表的函数。递归的情况则将类型列表分割成第一个元素和剩余元素两部分。比如对于<code>Typelist&lt;short, int, long&gt;</code>，递归过程会先将第一个元素（short）从剩余元素（<code>Typelist&lt;int, long&gt;</code>）中分离开。然后递归得反转<br>列表中剩余的元素（生成<code>Typelist&lt;long, int&gt;</code>），最后通过调用<code>PushBackT</code>将首元素追加到被反转的列表的后面（生成<code>Typelist&lt;long, int, short&gt;</code>）。</p>
<p>结合Reverse，可以实现移除列表中最后一个元素的<code>PopBackT</code>操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PopBackT</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = Reverse&lt;PopFront&lt;Reverse&lt;List&gt;&gt;&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="keyword">using</span> PopBack = <span class="keyword">typename</span> PopBackT&lt;List&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>该算法先反转整个列表，然后删除首元素并将剩余列表再次反转，从而实现删除末尾元素的目的。</p>
<h3 id="类型列表的转换"><a href="#类型列表的转换" class="headerlink" title="类型列表的转换"></a>类型列表的转换</h3><p>之前介绍的类型列表的相关算法允许我们从类型列表中提取任意元素，在类型列表中做查找，构建新的列表以及反转列表。但是我们还需要对类型列表中的元素执行一些其它的操作。比如可能希望对类型列表中的所有元素做某种转换，例如通过AddConst给列表中的元素加上const修饰符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AddConstT</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> AddConst = <span class="keyword">typename</span> AddConstT&lt;T&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>为了实现这一目的，相应的算法应该接受一个类型列表和一个元函数作为参数，并返回一个将该元函数作用于类型列表中每个元素之后，得到的新的类型列表。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transform&lt;SignedIntegralTypes, AddConstT&gt;</span><br></pre></td></tr></table></figure></p>
<p>返回的是一个包含了<code>signed char const</code>，<code>short const</code>，<code>int const</code>，<code>long const</code>，<code>long long const</code>的类型列表。元函数被以模板参数模板的形式提供，它负责将一种类型转换为另一种类型。Transform算法本身和预期的一样是一个递归算法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">MetaFun</span>, <span class="type">bool</span> Empty = IsEmpty&lt;List&gt;::value&gt;</span><br><span class="line"><span class="keyword">class</span> TransformT;</span><br><span class="line"><span class="comment">// recursive case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">MetaFun</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformT</span>&lt;List, MetaFun, <span class="literal">false</span>&gt;</span><br><span class="line">: <span class="keyword">public</span> PushFrontT&lt;<span class="keyword">typename</span> TransformT&lt;PopFront&lt;List&gt;,</span><br><span class="line">MetaFun&gt;::Type, <span class="keyword">typename</span> MetaFun&lt;Front&lt;List&gt;&gt;::Type&gt;</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="comment">// basis case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">MetaFun</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformT</span>&lt;List, MetaFun, <span class="literal">true</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = List;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">MetaFun</span>&gt;</span><br><span class="line"><span class="keyword">using</span> Transform = <span class="keyword">typename</span> TransformT&lt;List, MetaFun&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>此处的递归情况虽然句法比较繁琐，但是依然很直观。最终转换的结果是第一个元素的转换结果，加上对剩余元素执行执行递归转换后的结果。</p>
<h3 id="类型列表的累加（Accumulating-Typelists）"><a href="#类型列表的累加（Accumulating-Typelists）" class="headerlink" title="类型列表的累加（Accumulating Typelists）"></a>类型列表的累加（Accumulating Typelists）</h3><p>转换（Transform）算法在需要对类型列表中的元素做转换时很有帮助。通常将它和累加（Accumulate）算法一起使用，它会将类型列表中的所有元素组合成一个值。<code>Accumulate</code>算法以一个包含元素<code>T1</code>，<code>T2</code>，…，<code>TN</code>的类型列表<code>T</code>，一个初始类型<code>I</code>，和一个接受两个类型作为参数的元函数<code>F</code>为参数，并最终返回一个类型。它的返回值是<code>F (F (F (...F(I, T1), T2), ..., TN−1), TN )</code>，其中在第ith步，<code>F</code>将作用于前i-1步的结果以及<code>Ti</code>。</p>
<p>取决于具体的类型列表，F的选择以及初始值I的选择，可以通过<code>Accumulate</code>产生各种不同的输出。比如如果F可以被用来在两种类型中选择较大的那一个，<code>Accumulate</code>的行为就和<code>LargestType</code>差不多。而如果F接受一个类型列表和一个类型作为参数，并且将类型追加到类型列表的后面，其行为又和<code>Reverse</code>算法差不多。<code>Accumulate</code>的实现方式遵循了标准的递归元编程模式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Y&gt; <span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">typename</span> I, <span class="type">bool</span> = IsEmpty&lt;List&gt;::value&gt;</span><br><span class="line"><span class="keyword">class</span> AccumulateT;</span><br><span class="line"><span class="comment">// recursive case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Y&gt; <span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">typename</span> I&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccumulateT</span>&lt;List, F, I, <span class="literal">false</span>&gt; : <span class="keyword">public</span> AccumulateT&lt;PopFront&lt;List&gt;, F, <span class="keyword">typename</span> F&lt;I, Front&lt;List&gt;&gt;::Type&gt;</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="comment">// basis case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List,</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Y&gt; <span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">typename</span> I&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccumulateT</span>&lt;List, F, I, <span class="literal">true</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = I;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List,</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Y&gt; <span class="keyword">class</span> <span class="title class_">F</span>,</span><br><span class="line"><span class="keyword">typename</span> I&gt;</span><br><span class="line">    <span class="keyword">using</span> Accumulate = <span class="keyword">typename</span> AccumulateT&lt;List, F, I&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>这里初始类型I也被当作累加器使用，被用来捕捉当前的结果。因此当递归到类型列表末尾的时候，递归循环的基本情况会返回这个结果。在递归情况下，算法将F作用于之前的结果（I）以及当前类型列表的首元素，并将F的结果作为初始类型继续传递，用于下一级对剩余列表的求和（Accumulating）。</p>
<p>有了<code>Accumulate</code>，就可以通过将<code>PushFrontT</code>作为元函数F，将空的类型列表（<code>TypeList&lt;T&gt;</code>）作为初始类型I，反转一个类型列表：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Result = Accumulate&lt;SignedIntegralTypes, PushFrontT, Typelist&lt;&gt;&gt;;</span><br><span class="line"><span class="comment">// produces TypeList&lt;long long, long, int, short, signed char&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果要实现基于<code>Accumulate</code>的<code>LargestType</code>（称之为<code>LargestTypeAcc</code>），还需要做一些额外的工作，因为首先要实现一个返回两种类型中类型较大的那一个的元函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LargerTypeT</span></span><br><span class="line">: <span class="keyword">public</span> IfThenElseT&lt;<span class="built_in">sizeof</span>(T) &gt;= <span class="built_in">sizeof</span>(U), T, U&gt;</span><br><span class="line">&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Typelist&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LargestTypeAccT</span> : <span class="keyword">public</span> AccumulateT&lt;PopFront&lt;Typelist&gt;, LargerTypeT,</span><br><span class="line">Front&lt;Typelist&gt;&gt;</span><br><span class="line">&#123; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Typelist&gt;</span><br><span class="line"><span class="keyword">using</span> LargestTypeAcc = <span class="keyword">typename</span> LargestTypeAccT&lt;Typelist&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>值得注意的是，由于这一版的<code>LargestType</code>将类型列表的第一个元素当作初始类型，因此其输入不能为空。我们可以显式地处理空列表的情况，要么是返回一个哨兵类型（char或者void），要么让该算法很好的支持SFINASE：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LargerTypeT</span> : <span class="keyword">public</span> IfThenElseT&lt;<span class="built_in">sizeof</span>(T) &gt;= <span class="built_in">sizeof</span>(U), T, U&gt;</span><br><span class="line">&#123; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Typelist, <span class="type">bool</span> = IsEmpty&lt;Typelist&gt;::value&gt;</span><br><span class="line"><span class="keyword">class</span> LargestTypeAccT;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Typelist&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LargestTypeAccT</span>&lt;Typelist, <span class="literal">false</span>&gt; : <span class="keyword">public</span> AccumulateT&lt;PopFront&lt;Typelist&gt;, LargerTypeT,</span><br><span class="line">Front&lt;Typelist&gt;&gt;</span><br><span class="line">&#123; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Typelist&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LargestTypeAccT</span>&lt;Typelist, <span class="literal">true</span>&gt;</span><br><span class="line">&#123; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Typelist&gt;</span><br><span class="line"><span class="keyword">using</span> LargestTypeAcc = <span class="keyword">typename</span> LargestTypeAccT&lt;Typelist&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p><code>Accumulate</code>是一个非常强大的类型列表算法，利用它可以实现很多种操作，因此可以将其看作类型列表操作相关的基础算法。</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>作为最后一个类型列表相关的算法，我们来介绍插入排序。和其它算法类似，其递归过程会将类型列表分成第一个元素（Head）和剩余的元素（Tail）。然后对Tail进行递归排序，并将Head插入到排序后的类型列表中的合适的位置。该算法的实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="type">bool</span> = IsEmpty&lt;List&gt;::value&gt;</span><br><span class="line"><span class="keyword">class</span> InsertionSortT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="keyword">using</span> InsertionSort = <span class="keyword">typename</span> InsertionSortT&lt;List, Compare&gt;::Type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// recursive case (insert first element into sorted list):</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InsertionSortT</span>&lt;List, Compare, <span class="literal">false</span>&gt;</span><br><span class="line">: <span class="keyword">public</span> InsertSortedT&lt;InsertionSort&lt;PopFront&lt;List&gt;, Compare&gt;,</span><br><span class="line">Front&lt;List&gt;, Compare&gt;</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// basis case (an empty list is sorted):</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InsertionSortT</span>&lt;List, Compare, <span class="literal">true</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = List;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在对类型列表进行排序时，参数Compare被用来作比较。它接受两个参数并通过其value成员返回一个布尔值。将其用来处理空列表的情况会稍嫌繁琐。</p>
<p>插入排序算法的核心时元函数<code>InsertSortedT</code>，它将一个值插入到一个已经排序的列表中（插入到第一个可能的位置）并保持列表依然有序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;identity.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">typename</span> Element, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="type">bool</span> =</span><br><span class="line">    IsEmpty&lt;List&gt;::value&gt;</span><br><span class="line"><span class="keyword">class</span> InsertSortedT;</span><br><span class="line"><span class="comment">// recursive case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">typename</span> Element, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line"><span class="keyword">typename</span> U&gt; <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InsertSortedT</span>&lt;List, Element, Compare, <span class="literal">false</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// compute the tail of the resulting list:</span></span><br><span class="line">    <span class="keyword">using</span> NewTail = <span class="keyword">typename</span> IfThenElse&lt;Compare&lt;Element,</span><br><span class="line">        Front&lt;List&gt;&gt;::value, IdentityT&lt;List&gt;,</span><br><span class="line">        InsertSortedT&lt;PopFront&lt;List&gt;,</span><br><span class="line">        Element, Compare&gt;&gt;::Type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the head of the resulting list:</span></span><br><span class="line">    <span class="keyword">using</span> NewHead = IfThenElse&lt;Compare&lt;Element, Front&lt;List&gt;&gt;::value,</span><br><span class="line">        Element, Front&lt;List&gt;&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = PushFront&lt;NewTail, NewHead&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// basis case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">typename</span> Element, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">    <span class="keyword">typename</span> U&gt; <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InsertSortedT</span>&lt;List, Element, Compare, <span class="literal">true</span>&gt;</span><br><span class="line">: <span class="keyword">public</span> PushFrontT&lt;List, Element&gt;</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">typename</span> Element,<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="keyword">using</span> InsertSorted = <span class="keyword">typename</span> InsertSortedT&lt;List, Element, Compare&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>由于只有一个元素的列表是已经排好序的，因此相关代码不是很复杂。对于递归情况，基于元素应该被插入到列表头部还是剩余部分，其实现也有所不同。如果元素应该被插入到（已经排序的）列表第一个元素的前面，那么就用PushFront直接插入。否则，就将列表分成head和tail两部分，这样递归的尝试将元素插入到tail中，成功之后再用PushFront将head插入到tail的前面。</p>
<p>上述实现中包含了一个避免去实例化不会用到的类型的编译期优化，下面这个实现在技术上也是正确的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> List, <span class="keyword">typename</span> Element, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line"><span class="keyword">typename</span> U&gt; <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InsertSortedT</span>&lt;List, Element, Compare, <span class="literal">false</span>&gt;</span><br><span class="line">: <span class="keyword">public</span> IfThenElseT&lt;Compare&lt;Element, Front&lt;List&gt;&gt;::value, PushFront&lt;List, Element&gt;, PushFront&lt;InsertSorted&lt;PopFront&lt;List&gt;, Element, Compare&gt;, Front&lt;List&gt;&gt;&gt;</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是由于这种递归情况的实现方式会计算<code>IfThenElseT</code>的两个分支（虽然只会用到一个），其效率会受到影响。在这个实现中，在<code>IfThenElseT</code>的then分支中使用<code>PushFront</code>的成本非常低，但是在else分支中递归地使用<code>InsertSorted</code>的成本则很高。在我们的优化实现中，第一个<code>IfThenElse</code>会计算出列表的tail（NewTail）。其第二和第三个参数是用来计算特定结果的元函数。Then分支中的参数使用<code>IdentityT</code>来计算未被修改的List。Else分支中的参数用<code>InsertSorted</code>T来计算将元素插入到已排序列表之后的结果。在较高层面上，<code>Identity</code>和<code>InsertSortedT</code>两者中只有一个会被实例化，因此不会有太多的额外工作。</p>
<p>第二个<code>IfThenElse</code>会计算上面获得的list的head，其两个分支的计算代价都很低，因此都会被立即计算。最终的结果由<code>NewHead</code>和<code>NewTail</code>计算得到。</p>
<p>这一实现方案所需要的实例化数目，与被插入元素在一个已排序列表中的插入位置成正比。这表现为更高级别的插入排序属性：排序一个已经有序的列表，所需要实例化的数目和列表的长度成正比（如果已排序列表的排列顺序和预期顺序相反的话，所需要的实例化数目和列表长度的平方成正比）。</p>
<p>下面的程序会基于列表中元素的大小，用插入排序对其排序。比较函数使用了<code>sizeof</code>运算符并比较其结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SmallerThanT</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="built_in">sizeof</span>(T) &lt; <span class="built_in">sizeof</span>(U);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testInsertionSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> Types = Typelist&lt;<span class="type">int</span>, <span class="type">char</span>, <span class="type">short</span>, <span class="type">double</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> ST = InsertionSort&lt;Types, SmallerThanT&gt;;</span><br><span class="line">    std::cout &lt;&lt; std::is_same&lt;ST,Typelist&lt;<span class="type">char</span>, <span class="type">short</span>, <span class="type">int</span>, <span class="type">double</span>&gt;&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="非类型类型列表（Nontype-Typelists）"><a href="#非类型类型列表（Nontype-Typelists）" class="headerlink" title="非类型类型列表（Nontype Typelists）"></a>非类型类型列表（Nontype Typelists）</h2><p>通过类型列表，有非常多的算法和操作可以用来描述并操作一串类型。某些情况下，还会希望能够操作一串编译期数值，比如多维数组的边界，或者指向另一个类型列表中的索引。有很多种方法可以用来生成一个包含编译期数值的类型列表。一个简单的办法是定义一个类模板<code>CTValue</code>（compile time value），然后用它表示类型列表中某种类型的值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T Value&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CTValue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> T value = Value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>用它就可以生成一个包含了最前面几个素数的类型列表：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Primes = Typelist&lt;CTValue&lt;<span class="type">int</span>, <span class="number">2</span>&gt;, CTValue&lt;<span class="type">int</span>, <span class="number">3</span>&gt;,</span><br><span class="line">CTValue&lt;<span class="type">int</span>, <span class="number">5</span>&gt;, CTValue&lt;<span class="type">int</span>, <span class="number">7</span>&gt;,</span><br><span class="line">CTValue&lt;<span class="type">int</span>, <span class="number">11</span>&gt;&gt;;</span><br></pre></td></tr></table></figure><br>这样就可以对类型列表中的数值进行数值计算，比如计算这些素数的乘积。</p>
<p>首先<code>MultiPlyT</code>模板接受两个类型相同的编译期数值作为参数，并生成一个新的、类型相同的编译期数值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MultiplyT</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T Value1, T Value2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MultiplyT</span>&lt;CTValue&lt;T, Value1&gt;, CTValue&lt;T, Value2&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = CTValue&lt;T, Value1 * Value2&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">using</span> Multiply = <span class="keyword">typename</span> MultiplyT&lt;T, U&gt;::Type;</span><br></pre></td></tr></table></figure></p>
<p>然后结合<code>MultiplyT</code>，下面的表达式就会返回所有<code>Primes</code>中素数的乘积：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accumulate&lt;Primes, MultiplyT, CTValue&lt;<span class="type">int</span>, <span class="number">1</span>&gt;&gt;::value</span><br></pre></td></tr></table></figure></p>
<p>不过这一使用<code>Typelist</code>和<code>CTValue</code>的方式过于复杂，尤其是当所有数值的类型相同的时候。可以通过引入<code>CTTypelist</code>模板别名来进行优化，它提供了一组包含在<code>Typelist</code>中、类型相同的数值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T... Values&gt;</span><br><span class="line"><span class="keyword">using</span> CTTypelist = Typelist&lt;CTValue&lt;T, Values&gt;...&gt;;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以使用<code>CTTypelist</code>来定义一版更为简单的Primes（素数）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Primes = CTTypelist&lt;<span class="type">int</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<p>这一方式的唯一缺点是，别名终归只是别名，当遇到错误的时候，错误信息可能会一直打印到<code>CTValueTypes</code>中的底层<code>Typelist</code>，导致错误信息过于冗长。为了解决这一问题，可以定义一个能够直接存储数值的、全新的类型列表类<code>Valuelist</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T... Values&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Valuelist</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T... Values&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsEmpty</span>&lt;Valuelist&lt;T, Values...&gt;&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="keyword">sizeof</span>...(Values) == <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T Head, T... Tail&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FrontT</span>&lt;Valuelist&lt;T, Head, Tail...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = CTValue&lt;T, Head&gt;;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> T value = Head;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T Head, T... Tail&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PopFrontT</span>&lt;Valuelist&lt;T, Head, Tail...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = Valuelist&lt;T, Tail...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T... Values, T New&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PushFrontT</span>&lt;Valuelist&lt;T, Values...&gt;, CTValue&lt;T, New&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = Valuelist&lt;T, New, Values...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T... Values, T New&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PushBackT</span>&lt;Valuelist&lt;T, Values...&gt;, CTValue&lt;T, New&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = Valuelist&lt;T, Values..., New&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过代码中提供的<code>IsEmpty</code>，<code>FrontT</code>，<code>PopFrontT</code>和<code>PushFrontT</code>，<code>Valuelist</code>就可以被用于本章中介绍的各种算法了。<code>PushBackT</code>被实现为一种算法的特例化，这样做可以降低编译期间该操作的计算成本。比如<code>Valuelist</code>可以被用于前面定义的算法<code>InsertionSort</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterThanT</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T First, T Second&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterThanT</span>&lt;CTValue&lt;T, First&gt;, CTValue&lt;T, Second&gt;&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = First &gt; Second;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">valuelisttest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> Integers = Valuelist&lt;<span class="type">int</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> SortedIntegers = InsertionSort&lt;Integers, GreaterThanT&gt;;</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_same_v&lt;SortedIntegers, Valuelist&lt;<span class="type">int</span>, <span class="number">9</span>, <span class="number">7</span>,</span><br><span class="line">    <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&gt;&gt;, <span class="string">&quot;insertion sort failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意在这里可以提供一种用字面值常量来初始化CTValue的功能，比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">42</span>_c; <span class="comment">// initializes a as CTValue&lt;int,42&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="可推断的非类型参数"><a href="#可推断的非类型参数" class="headerlink" title="可推断的非类型参数"></a>可推断的非类型参数</h3><p>在C++17中，可以通过使用一个可推断的非类型参数（结合auto）来进一步优化<code>CTValue</code>的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">auto</span> Value&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CTValue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> value = Value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样在使用<code>CTValue</code>的时候就可以不用每次都去指定一个类型了，从而简化了使用方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Primes = Typelist&lt;CTValue&lt;<span class="number">2</span>&gt;, CTValue&lt;<span class="number">3</span>&gt;, CTValue&lt;<span class="number">5</span>&gt;, CTValue&lt;<span class="number">7</span>&gt;, CTValue&lt;<span class="number">11</span>&gt;&gt;;</span><br></pre></td></tr></table></figure></p>
<p>在C++17中也可以对<code>Valuelist</code>执行同样的操作，但是结果可能不一定会变得更好。对一个非类型参数包进行类型推断时，各个参数可以不同：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">auto</span>... Values&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Valuelist</span> &#123; &#125;;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">using</span> MyValueList = Valuelist&lt;<span class="number">1</span>,<span class="string">&quot;a&quot;</span>, <span class="literal">true</span>, &amp;x&gt;;</span><br></pre></td></tr></table></figure></p>
<p>虽然这样一个列表可能也很有用，但是它和之前要求元素类型必须相同的<code>Valuelist</code>已经不一样了。虽然我们也可以要求其所有元素的类型必须相同，但是对于一个空的<code>Valuelist&lt;&gt;</code>而言，其元素类型却是未知的。</p>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>本章将会讨论tuples，它采用了类似于class和struct的方式来组织数据。比如，一个包含int，double和std::string的<code>tuple</code>，和一个包含int，double以及std::string类型的成员的struct类似，只不过tuple中的元素是用位置信息（比如0，1，2）索引的，而不是通过名字。元组的位置接口，以及能够容易地从<code>typelist</code>构建tuple的特性，使得其相比于struct更适用于模板元编程技术。</p>
<p>另一种观点是将元组看作在可执行程序中，类型列表的一种表现。比如，类型列表<code>Typelist&lt;int, double, std::string&gt;</code>，描述了一串包含了int，double和std::string的、可以在编译期间操作的类型，而<code>Tuple&lt;int,double, std::string&gt;</code>则描述了可以在运行期间操作的、对int，double和std::string的存储。比如下面的程序就创建了这样一个tuple的实例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuple</span> &#123;</span><br><span class="line">... <span class="comment">// implementation discussed below</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">t</span><span class="params">(<span class="number">17</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello, World!&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>通常会使用模板元编程和typelist来创建用于存储数据的tuple。比如，虽然在上面的程序中随意地选择了int，double和std::string作为元素类型，我们也可以用元程序创建一组可被tuple存储的类型。</p>
<h2 id="基本的元组设计"><a href="#基本的元组设计" class="headerlink" title="基本的元组设计"></a>基本的元组设计</h2><h3 id="存储（Storage）"><a href="#存储（Storage）" class="headerlink" title="存储（Storage）"></a>存储（Storage）</h3><p>元组包含了对模板参数列表中每一个类型的存储。这部分存储可以通过函数模板<code>get</code>进行访问，对于元组<code>t</code>，其用法为<code>get&lt;I&gt;(t)</code>。比如，对于之前例子中的t，<code>get&lt;0&gt;(t)</code>会返回指向<code>int 17</code>的引用，而<code>get&lt;1&gt;(t)</code>返回的则是指向<code>double 3.14</code>的引用。</p>
<p>元组存储的递归实现是基于这样一个思路：一个包含了N &gt; 0个元素的元组可以被存储为一个单独的元素（元组的第一个元素，Head）和一个包含了剩余N-1个元素（Tail）的元组，对于元素为空的元组，只需当作特例处理即可。因此一个包含了三个元素的元组<code>Tuple&lt;int, double, std::string&gt;</code>可以被存储为一个int和一个<code>Tuple&lt;double, std::string&gt;</code>。</p>
<p>这个包含两个元素的元组又可以被存储为一个double和一个<code>Tuple&lt;std::string&gt;</code>，这个只包含一个元素的元组又可以被存储为一个<code>std::string</code>和一个空的元组<code>Tuple&lt;&gt;</code>。事实上，在类型列表算法的泛型版本中也使用了相同的递归分解过程，而且实际递归元组的存储实现也<br>以类似的方式展开：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuple</span>;</span><br><span class="line"><span class="comment">// recursive case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuple</span>&lt;Head, Tail...&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Head head;</span><br><span class="line">    Tuple&lt;Tail...&gt; tail;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// constructors:</span></span><br><span class="line">    <span class="built_in">Tuple</span>() &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">Tuple</span>(Head <span class="type">const</span>&amp; head, Tuple&lt;Tail...&gt; <span class="type">const</span>&amp; tail): <span class="built_in">head</span>(head), <span class="built_in">tail</span>(tail) &#123;</span><br><span class="line">    &#125;... </span><br><span class="line">    <span class="function">Head&amp; <span class="title">getHead</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> head; &#125;</span><br><span class="line">    <span class="function">Head <span class="type">const</span>&amp; <span class="title">getHead</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> head; &#125;</span><br><span class="line">    <span class="function">Tuple&lt;Tail...&gt;&amp; <span class="title">getTail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> tail; &#125;</span><br><span class="line">    <span class="function">Tuple&lt;Tail...&gt; <span class="type">const</span>&amp; <span class="title">getTail</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> tail; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// basis case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuple</span>&lt;&gt; &#123;</span><br><span class="line"><span class="comment">// no storage required</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在递归情况下，Tuple的实例包含一个存储了列表首元素的head，以及一个存储了列表剩余元素的tail。基本情况则是一个没有存储内容的简单的空元组。而函数模板get则会通过遍历这个递归的结构来提取所需要的元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursive case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TupleGet</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="keyword">auto</span> <span class="title">apply</span><span class="params">(Tuple&lt;Head, Tail...&gt; <span class="type">const</span>&amp; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TupleGet&lt;N<span class="number">-1</span>&gt;::<span class="built_in">apply</span>(t.<span class="built_in">getTail</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// basis case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TupleGet</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> Head <span class="type">const</span>&amp; <span class="title">apply</span><span class="params">(Tuple&lt;Head, Tail...&gt; <span class="type">const</span>&amp; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">getHead</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> N, <span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get</span><span class="params">(Tuple&lt;Types...&gt; <span class="type">const</span>&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TupleGet&lt;N&gt;::<span class="built_in">apply</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这里的函数模板get只是封装了一个简单的对TupleGet的静态成员函数调用。在不能对函数模板进行部分特例化的情况下，这是一个有效的变通方法，在这里针对非类型模板参数N进行了特例化。在N &gt; 0的递归情况下，静态成员函数<code>apply()</code>会提取出当前tuple的tail，递减N，然后继续递归地在tail中查找所需元素。对于N=0的基本情况，<code>apply()</code>会返回当前tuple的head，并结束递归。</p>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>除了前面已经定义的构造函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Tuple</span>() &#123;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">Tuple</span>(Head <span class="type">const</span>&amp; head, Tuple&lt;Tail...&gt; <span class="type">const</span>&amp; tail)</span><br><span class="line">: <span class="built_in">head</span>(head), <span class="built_in">tail</span>(tail)</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>为了让元组的使用更方便，还应该允许用一组相互独立的值（每一个值对应元组中的一个元素）或者另一个元组来构造一个新的元组。从一组独立的值去拷贝构造一个元组，会用第一个数值去初始化元组的head，而将剩余的值传递给tail：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Tuple</span>(Head <span class="type">const</span>&amp; head, Tail <span class="type">const</span>&amp;... tail)</span><br><span class="line">: <span class="built_in">head</span>(head), <span class="built_in">tail</span>(tail...)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以像下面这样初始化一个元组了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">t</span><span class="params">(<span class="number">17</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello, World!&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>不过这并不是最通用的接口：用户可能会希望用移动构造（move-construct）来初始化元组的一些（可能不是全部）元素，或者用一个类型不相同的数值来初始化元组的某个元素。因此我们需要用完美转发来初始化元组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VHead, <span class="keyword">typename</span>... VTail&gt;</span></span><br><span class="line"><span class="function"><span class="title">Tuple</span><span class="params">(VHead&amp;&amp; vhead, VTail&amp;&amp;... vtail)</span></span></span><br><span class="line"><span class="function">: head(std::forward&lt;VHead&gt;(vhead)), tail(std::forward&lt;VTail&gt;(vtail)...)</span></span><br><span class="line"><span class="function">&#123;</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>下面的这个实现则允许用一个元组去构建另一个元组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VHead, <span class="keyword">typename</span>... VTail&gt;</span></span><br><span class="line"><span class="function"><span class="title">Tuple</span><span class="params">(Tuple&lt;VHead, VTail...&gt; <span class="type">const</span>&amp; other)</span></span></span><br><span class="line"><span class="function">: head(other.getHead()), tail(other.getTail())</span></span><br><span class="line"><span class="function">&#123;</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这个构造函数不适用于类型转换：给定上文中的t，试图用它去创建一个元素之间类型兼容的元组会遇到错误：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ERROR: no conversion from Tuple&lt;int, double, string&gt; to long</span></span><br><span class="line"><span class="function">Tuple&lt;<span class="type">long</span> <span class="type">int</span>, <span class="type">long</span> <span class="type">double</span>, std::string&gt; <span class="title">t2</span><span class="params">(t)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这是因为上面这个调用，会更匹配用一组数值去初始化一个元组的构造函数模板，而不是用一个元组去初始化另一个元组的构造函数模板。为了解决这一问题，就需要用到<code>std::enable_if&lt;&gt;</code>，在tail的长度与预期不同的时候就禁用相关模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VHead, <span class="keyword">typename</span>... VTail, <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;<span class="keyword">sizeof</span>... (VTail)==<span class="keyword">sizeof</span>... (Tail)&gt;&gt;</span><br><span class="line"><span class="built_in">Tuple</span>(VHead&amp;&amp; vhead, VTail&amp;&amp;... vtail)</span><br><span class="line">: <span class="built_in">head</span>(std::forward&lt;VHead&gt;(vhead)), <span class="built_in">tail</span>(std::forward&lt;VTail&gt;(vtail)...)</span><br><span class="line">&#123; &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> VHead, <span class="keyword">typename</span>... VTail, <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;<span class="keyword">sizeof</span>... (VTail)==<span class="keyword">sizeof</span>... (Tail)&gt;&gt;</span><br><span class="line"><span class="built_in">Tuple</span>(Tuple&lt;VHead, VTail...&gt; <span class="type">const</span>&amp; other)</span><br><span class="line">: <span class="built_in">head</span>(other.<span class="built_in">getHead</span>()), <span class="built_in">tail</span>(other.<span class="built_in">getTail</span>()) &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>函数模板<code>makeTuple()</code>会通过类型推断来决定所生成元组中元素的类型，这使得用一组数值创建一个元组变得更加简单：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">makeTuple</span><span class="params">(Types&amp;&amp;... elems)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Tuple&lt;std::<span class="type">decay_t</span>&lt;Types&gt;...&gt;(std::forward&lt;Types&gt; (elems)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里再一次将<code>std::decay&lt;&gt;</code>和完美转发一起使用，这会将字符串常量和裸数组转换成指针，并去除元素的const和引用属性。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">makeTuple</span>(<span class="number">17</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>生成的元组的类型是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tuple&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">char</span> <span class="type">const</span>*&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="基础元组操作"><a href="#基础元组操作" class="headerlink" title="基础元组操作"></a>基础元组操作</h2><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>元组是包含了其它数值的结构化类型。为了比较两个元组，就需要比较它们的元素。因此可以像下面这样，定义一种能够逐个比较两个元组中元素的<code>operator==</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basis case:</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Tuple&lt;&gt; <span class="type">const</span>&amp;, Tuple&lt;&gt; <span class="type">const</span>&amp;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// empty tuples are always equivalentreturn true;</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// recursive case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head1, <span class="keyword">typename</span>... Tail1,</span><br><span class="line"><span class="keyword">typename</span> Head2, <span class="keyword">typename</span>... Tail2, <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;<span class="keyword">sizeof</span>...(Tail1)==<span class="keyword">sizeof</span>...(Tail2)&gt;&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Tuple&lt;Head1, Tail<span class="number">1.</span>..&gt; <span class="type">const</span>&amp; lhs, Tuple&lt;Head2, Tail<span class="number">2.</span>..&gt; <span class="type">const</span>&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.<span class="built_in">getHead</span>() == rhs.<span class="built_in">getHead</span>() &amp;&amp; lhs.<span class="built_in">getTail</span>() == rhs.<span class="built_in">getTail</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和其它适用于类型列表和元组的算法类似，逐元素的比较两个元组，会先比较首元素，然后递归地比较剩余的元素，最终会调用operator的基本情况结束递归。运算符!=，&lt;，&gt;，以及&gt;=的实现方式都与之类似。</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>贯穿本章始终，我们一直都在创建新的元组类型，因此最好能够在执行程序的时候看到这些元组。下面的<code>operator&lt;&lt;</code>运算符会打印那些元素类型可以被打印的元组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTuple</span><span class="params">(std::ostream&amp; strm, Tuple&lt;&gt; <span class="type">const</span>&amp;, <span class="type">bool</span> isFirst = <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    strm &lt;&lt; ( isFirst ? <span class="string">&quot;(&quot;</span>: <span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTuple</span><span class="params">(std::ostream&amp; strm, Tuple&lt;Head, Tail...&gt; <span class="type">const</span>&amp; t, <span class="type">bool</span> isFirst = <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    strm &lt;&lt; ( isFirst ? <span class="string">&quot;(&quot;</span> : <span class="string">&quot;, &quot;</span> );</span><br><span class="line">    strm &lt;&lt; t.<span class="built_in">getHead</span>();</span><br><span class="line">    <span class="built_in">printTuple</span>(strm, t.<span class="built_in">getTail</span>(), <span class="literal">false</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... Types&gt;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; strm, Tuple&lt;Types...&gt; <span class="type">const</span>&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printTuple</span>(strm, t);</span><br><span class="line">    <span class="keyword">return</span> strm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以很容易地创建并打印元组了。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in">makeTuple</span>(<span class="number">1</span>, <span class="number">2.5</span>, std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>)) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p>会打印出：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">2.5</span>, hello)</span><br></pre></td></tr></table></figure></p>
<h2 id="元组的算法"><a href="#元组的算法" class="headerlink" title="元组的算法"></a>元组的算法</h2><p>元组是一种提供了以下各种功能的容器：可以访问并修改其元素的能力（通过<code>get&lt;&gt;</code>），创建新元组的能力（直接创建或者通过使用<code>makeTuple&lt;&gt;</code>创建），以及将元组分割成<code>head</code>和<code>tail</code>的能力（通过使用<code>getHead()</code>和<code>getTail()</code>）。使用这些功能足以创建各种各样的元组算法，比如添加或者删除元组中的元素，重新排序元组中的元素，或者选取元组中元素的某些子集。</p>
<p>元组很有意思的一点是它既需要用到编译期计算也需要用到运行期计算。将某种算法作用与元组之后可能会得到一个类型迥异的元组，这就需要用到编译期计算。比如反转元组<code>Tuple&lt;int, double, string&gt;</code>会得到<code>Tuple&lt;string, double, int&gt;</code>。</p>
<p>但是和同质容器的算法类似（比如作用域std::vector的std::reverse()），元组算法是需要在运行期间执行代码的，因此我们需要留意被产生出来的代码的效率问题。</p>
<h3 id="将元组用作类型列表"><a href="#将元组用作类型列表" class="headerlink" title="将元组用作类型列表"></a>将元组用作类型列表</h3><p>通过使用一些部分特例化，可以将<code>Tuple</code>变成一个功能完整的<code>Typelist</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// determine whether the tuple is empty:</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsEmpty</span>&lt;Tuple&lt;&gt;&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// extract front element:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FrontT</span>&lt;Tuple&lt;Head, Tail...&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = Head;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// remove front element:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PopFrontT</span>&lt;Tuple&lt;Head, Tail...&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = Tuple&lt;Tail...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// add element to the front:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types, <span class="keyword">typename</span> Element&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PushFrontT</span>&lt;Tuple&lt;Types...&gt;, Element&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = Tuple&lt;Element, Types...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// add element to the back:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types, <span class="keyword">typename</span> Element&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PushBackT</span>&lt;Tuple&lt;Types...&gt;, Element&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = Tuple&lt;Types..., Element&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以很方便的处理元组的类型了。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">t1</span><span class="params">(<span class="number">17</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello, World!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">using</span> T2 = PopFront&lt;PushBack&lt;<span class="keyword">decltype</span>(t1), <span class="type">bool</span>&gt;&gt;;</span><br><span class="line"><span class="function">T2 <span class="title">t2</span><span class="params">(get&lt;<span class="number">1</span>&gt;(t1), get&lt;<span class="number">2</span>&gt;(t1), <span class="literal">true</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; t2;</span><br></pre></td></tr></table></figure></p>
<p>会打印出：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">3.14</span>, Hello, World!, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>很快就会看到，将typelist算法用于tuple，通常是为了确定tuple算法返回值的类型。</p>
<h3 id="添加以及删除元素"><a href="#添加以及删除元素" class="headerlink" title="添加以及删除元素"></a>添加以及删除元素</h3><p>对于Tuple，能否向其头部或者尾部添加元素，对开发相关的高阶算法而言是很重要的。和<code>typelist</code>的情况一样，向头部插入一个元素要远比向尾部插入一个元素要简单，因此我们从<code>pushFront</code>开始：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types, <span class="keyword">typename</span> V&gt;</span><br><span class="line">PushFront&lt;Tuple&lt;Types...&gt;, V&gt;</span><br><span class="line"><span class="built_in">pushFront</span>(Tuple&lt;Types...&gt; <span class="type">const</span>&amp; tuple, V <span class="type">const</span>&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PushFront&lt;Tuple&lt;Types...&gt;, V&gt;(value, tuple);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将一个新元素（称之为value）添加到一个已有元组的头部，需要生成一个新的、以<code>value</code>为head、以已有tuple为tail的元组。返回结过的类型是<code>Tuple&lt;V, Types...&gt;</code>。不过这里我们选择使用<code>typelist</code>的算法<code>PushFront</code>来获得返回类型，这样做可以体现出tuple算法中编译期部分和运行期部分之间的紧密耦合关系：编译期的<code>PushFront</code>计算出了我们应该生成的运行期结果的类型。</p>
<p>将一个新元素添加到一个已有元组的末尾则会复杂得多，因为这需要遍历一个元组。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basis case</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function">Tuple&lt;V&gt; <span class="title">pushBack</span><span class="params">(Tuple&lt;&gt; <span class="type">const</span>&amp;, V <span class="type">const</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Tuple</span>&lt;V&gt;(value);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// recursive case</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail, <span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function">Tuple&lt;Head, Tail..., V&gt;</span></span><br><span class="line"><span class="function"><span class="title">pushBack</span><span class="params">(Tuple&lt;Head, Tail...&gt; <span class="type">const</span>&amp; tuple, V <span class="type">const</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Tuple</span>&lt;Head, Tail..., V&gt;(tuple.<span class="built_in">getHead</span>(), <span class="built_in">pushBack</span>(tuple.<span class="built_in">getTail</span>(), value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于基本情况，和预期的一样，会将值追加到一个长度为零的元组的后面。对于递归情况，则将元组分为head和tail两部分，然后将首元素以及将新元素追加到tail的后面得到结果组装成最终的结果。虽然这里我们使用的返回值类型是<code>Tuple&lt;Head, Tail..., V&gt;</code>，但是它和编译期的<code>PushBack&lt;Tuple&lt;Hrad, Tail...&gt;, V&gt;</code>是一样的。</p>
<p>同样地，<code>popFront()</code>也很容易实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line">PopFront&lt;Tuple&lt;Types...&gt;&gt; <span class="built_in">popFront</span>(Tuple&lt;Types...&gt; <span class="type">const</span>&amp; tuple)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tuple.<span class="built_in">getTail</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们可以像下面这样编写例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">t1</span><span class="params">(<span class="number">17</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello, World!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> t2 = <span class="built_in">popFront</span>(<span class="built_in">pushBack</span>(t1, <span class="literal">true</span>));</span><br><span class="line">std::cout &lt;&lt; std::boolalpha &lt;&lt; t2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p>打印结果为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">3.14</span>, Hello, World!, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="元组的反转"><a href="#元组的反转" class="headerlink" title="元组的反转"></a>元组的反转</h3><p>元组的反转可以采用另一种递归的类型列表的反转方式实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basis case</span></span><br><span class="line">Tuple&lt;&gt; <span class="built_in">reverse</span>(Tuple&lt;&gt; <span class="type">const</span>&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// recursive case</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line">Reverse&lt;Tuple&lt;Head, Tail...&gt;&gt; <span class="built_in">reverse</span>(Tuple&lt;Head, Tail...&gt; <span class="type">const</span>&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pushBack</span>(<span class="built_in">reverse</span>(t.<span class="built_in">getTail</span>()), t.<span class="built_in">getHead</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基本情况比较简单，而递归情况则是递归地将head追加到反转之后的tail的后面。也就是说：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(<span class="built_in">makeTuple</span>(<span class="number">1</span>, <span class="number">2.5</span>, std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>)))</span><br></pre></td></tr></table></figure>
<p>会生成一个包含了<code>string(“hello”)</code>，2.5，和1的类型为<code>Tuple&lt;string, double, int&gt;</code>的元组。和类型列表类似，现在就可以简单地通过先反转元组，然后调用<code>popFront()</code>，然后再次反转元组实现<code>popBack()</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line">PopBack&lt;Tuple&lt;Types...&gt;&gt; <span class="built_in">popBack</span>(Tuple&lt;Types...&gt; <span class="type">const</span>&amp; tuple)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reverse</span>(<span class="built_in">popFront</span>(<span class="built_in">reverse</span>(tuple)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="索引列表"><a href="#索引列表" class="headerlink" title="索引列表"></a>索引列表</h3><p>虽然上文中反转元组用到的递归方式是正确的，但是它在运行期间的效率却非常低。为了展现这一问题，引入下面这个可以计算其实例被copy次数的类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CopyCounter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">unsigned</span> numCopies = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CopyCounter</span>()</span><br><span class="line">    &#123; &#125; </span><br><span class="line">    <span class="built_in">CopyCounter</span>(CopyCounter <span class="type">const</span>&amp;) &#123;</span><br><span class="line">        ++numCopies;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后创建并反转一个包含了<code>CopyCounter</code>实例的元组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">copycountertest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tuple&lt;CopyCounter&lt;<span class="number">0</span>&gt;, CopyCounter&lt;<span class="number">1</span>&gt;, CopyCounter&lt;<span class="number">2</span>&gt;, CopyCounter&lt;<span class="number">3</span>&gt;, CopyCounter&lt;<span class="number">4</span>&gt;&gt; copies;</span><br><span class="line">    <span class="keyword">auto</span> reversed = <span class="built_in">reverse</span>(copies);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;0: &quot;</span> &lt;&lt; CopyCounter&lt;<span class="number">0</span>&gt;::numCopies &lt;&lt; <span class="string">&quot; copies\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;1: &quot;</span> &lt;&lt; CopyCounter&lt;<span class="number">1</span>&gt;::numCopies &lt;&lt; <span class="string">&quot; copies\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2: &quot;</span> &lt;&lt; CopyCounter&lt;<span class="number">2</span>&gt;::numCopies &lt;&lt; <span class="string">&quot; copies\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;3: &quot;</span> &lt;&lt; CopyCounter&lt;<span class="number">3</span>&gt;::numCopies &lt;&lt; <span class="string">&quot; copies\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;4: &quot;</span> &lt;&lt; CopyCounter&lt;<span class="number">4</span>&gt;::numCopies &lt;&lt; <span class="string">&quot; copies\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个程序会打印出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0: 5 copies</span><br><span class="line">1: 8 copies</span><br><span class="line">2: 9 copies</span><br><span class="line">3: 8 copies</span><br><span class="line">4: 5 copies</span><br></pre></td></tr></table></figure></p>
<p>这确实进行了很多次copy！在理想的实现中，反转一个元组时，每一个元素只应该被copy一次：从其初始位置直接被copy到目的位置。我们可以通过使用引用来达到这一目的，包括对中间变量的类型使用引用，但是这样做会使实现变得很复杂。</p>
<p>在反转元组时，为了避免不必要的copy，考虑一下我们该如何实现一个一次性的算法，来反转一个简单的、长度已知的元组（比如包含5个元素）。可以像下面这样只是简单地使用<code>makeTuple()</code>和<code>get()</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> reversed = <span class="built_in">makeTuple</span>(<span class="built_in">get</span>&lt;<span class="number">4</span>&gt;(copies), <span class="built_in">get</span>&lt;<span class="number">3</span>&gt;(copies), <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(copies),</span><br><span class="line"><span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(copies), <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(copies));</span><br></pre></td></tr></table></figure></p>
<p>这个程序会按照我们预期的那样进行，对每个元素只进行一次copy：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: <span class="number">1</span> copies</span><br><span class="line"><span class="number">1</span>: <span class="number">1</span> copies</span><br><span class="line"><span class="number">2</span>: <span class="number">1</span> copies</span><br><span class="line"><span class="number">3</span>: <span class="number">1</span> copies</span><br><span class="line"><span class="number">4</span>: <span class="number">1</span> copies</span><br></pre></td></tr></table></figure></p>
<p>索引列表通过将一组元组的索引捕获进一个参数包，推广了上述概念，本例中的索引列表是4，3，2，1，0，这样就可以通过包展开进行一组get函数的调用。采用这种方法可以将索引列表的计算（可以采用任意复杂度的模板源程序）和使用（更关注运行期的性能）分离开。在C++14中引入的标准类型<code>std::integer_sequence</code>，通常被用来表示索引列表。</p>
<h2 id="元组的展开"><a href="#元组的展开" class="headerlink" title="元组的展开"></a>元组的展开</h2><p>在需要将一组相关的数值存储到一个变量中时（不管这些相关数值的数量是多少、类型是什么），元组会很有用。在某些情况下，可能会需要展开一个元组（比如在需要将其元素作为独立参数传递给某个函数的时候）。作为一个简单的例子，可能需要将一个元组的元素传递给变参<code>print()</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Tuple&lt;std::string, <span class="type">char</span> <span class="type">const</span>*, <span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">t</span><span class="params">(<span class="string">&quot;Pi&quot;</span>, <span class="string">&quot;is roughly&quot;</span>, <span class="number">3</span>, <span class="string">&quot;\n&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">print</span>(t...); <span class="comment">//ERROR: cannot expand a tuple; it isn&quot;t a parameter pack</span></span><br></pre></td></tr></table></figure></p>
<p>正如例子中注释部分所讲的，这个“明显”需要展开一个元组的操作会失败，因为它不是一个参数包。不过我们可以使用索引列表实现这一功能。下面的函数模板apply()接受一个函数和一个元组作为参数，然后以展开后的元组元素为参数，去调用这个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Elements, <span class="type">unsigned</span>... Indices&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">applyImpl</span><span class="params">(F f, Tuple&lt;Elements...&gt; <span class="type">const</span>&amp; t,</span></span></span><br><span class="line"><span class="params"><span class="function">Valuelist&lt;<span class="type">unsigned</span>, Indices...&gt;)</span> -&gt;<span class="title">decltype</span><span class="params">(f(get&lt;Indices&gt;(t)...))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(<span class="built_in">get</span>&lt;Indices&gt;(t)...);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Elements, <span class="type">unsigned</span> N </span>= <span class="keyword">sizeof</span>...(Elements)&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">apply</span><span class="params">(F f, Tuple&lt;Elements...&gt; <span class="type">const</span>&amp; t)</span> -&gt;<span class="title">decltype</span><span class="params">(applyImpl(f, t, MakeIndexList&lt;N&gt;()))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">applyImpl</span>(f, t, <span class="built_in">MakeIndexList</span>&lt;N&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数模板<code>applyImpl()</code>会接受一个索引列表作为参数，并用其将元组中的元素展开成一个适用于函数对象f的参数列表。而供用户直接使用的<code>apply()</code>则只是负责构建初始的索引列表。这样就可以将一个元组扩展成<code>print()</code>的参数了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Tuple&lt;std::string, <span class="type">char</span> <span class="type">const</span>*, <span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">t</span><span class="params">(<span class="string">&quot;Pi&quot;</span>, <span class="string">&quot;is roughly&quot;</span>, <span class="number">3</span>, <span class="string">&quot;\n&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">apply</span>(print, t); <span class="comment">//OK: prints Pi is roughly 3</span></span><br></pre></td></tr></table></figure></p>
<h2 id="元组的优化"><a href="#元组的优化" class="headerlink" title="元组的优化"></a>元组的优化</h2><p>元组是一种基础的、潜在用途广泛的异质容器。因此有必要考虑下该怎么在运行期（存储和执行时间）和编译期（实例化的数量）对其进行优化。本节将介绍一些适用于上文中实现的元组的特定优化方案。</p>
<h3 id="元组和EBCO"><a href="#元组和EBCO" class="headerlink" title="元组和EBCO"></a>元组和EBCO</h3><p>我们实现的元组，其存储方式所需要的存储空间，要比其严格意义上所需要的存储空间多。其中一个问题是，tail成员最终会是一个空的数值（因为所有非空的元组都会以一个空的元组作为结束），而任意数据成员又总会至少占用一个字节的内存。为了提高元组的存储效率，可以使用空基类优化（EBCO，empty base class optimization），让元组继承自一个尾元组（tail tuple），而不是将尾元组作为一个成员。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursive case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuple</span>&lt;Head, Tail...&gt; : <span class="keyword">private</span> Tuple&lt;Tail...&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Head head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Head&amp; <span class="title">getHead</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> head; &#125;</span><br><span class="line">    <span class="function">Head <span class="type">const</span>&amp; <span class="title">getHead</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> head; &#125;</span><br><span class="line">    <span class="function">Tuple&lt;Tail...&gt;&amp; <span class="title">getTail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="function">Tuple&lt;Tail...&gt; <span class="type">const</span>&amp; <span class="title">getTail</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这和<code>BaseMemberPair</code>使用的优化方式一致。不幸的是，这种方式有其副作用，就是颠倒了元组元素在构造函数中被初始化的顺序。在之前的实现中，head成员在tail成员前面，因此head总是会先被初始化。在新的实现方式中，tail则是以基类的形式存在，因此它会在head成员之前被初始化。</p>
<p>这一问题可以通过将head成员放入其自身的基类中，并让这个基类在基类列表中排在tail的前面来解决。该方案的一个直接实现方式是，引入一个用来封装各种元素类型的TupleElt模板，并让Tuple继承自它：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuple</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TupleElt</span></span><br><span class="line">&#123;</span><br><span class="line">    T value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TupleElt</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">TupleElt</span><span class="params">(U&amp;&amp; other)</span> : value(std::forward&lt;U&gt;(other) &#123;</span> &#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// recursive case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuple</span>&lt;Head, Tail...&gt;</span><br><span class="line">: <span class="keyword">private</span> TupleElt&lt;Head&gt;, <span class="keyword">private</span> Tuple&lt;Tail...&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Head&amp; <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// potentially ambiguous</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;TupleElt&lt;Head&gt; *&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Head <span class="type">const</span>&amp; <span class="title">getHead</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// potentially ambiguous</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;TupleElt&lt;Head&gt; <span class="type">const</span>*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Tuple&lt;Tail...&gt;&amp; <span class="title">getTail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="function">Tuple&lt;Tail...&gt; <span class="type">const</span>&amp; <span class="title">getTail</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// basis case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuple</span>&lt;&gt; &#123;</span><br><span class="line"><span class="comment">// no storage required</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>虽然这一方式解决了元素初始化顺序的问题，但是却引入了一个更糟糕的问题：如果一个元组包含两个类型相同的元素（比如<code>Tuple&lt;int, int&gt;</code>），我们将不再能够从中提取元素，因为此时从<code>Tuple&lt;int, int&gt;</code>向<code>TupleElt&lt;int&gt;</code>的转换（自派生类向基类的转换）不是唯一的（有歧义）。为了打破歧义，需要保证在给定的Tuple中每一个TupleElt基类都是唯一的。一个方式是将这个值的“高度”信息（也就是tail元组的长度信息）编码进元组中。元组最后一个元素的高度会被存储生0，倒数第一个元素的长度会被存储成1，以此类推：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> Height, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TupleElt</span> &#123;</span><br><span class="line">    T value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TupleElt</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">TupleElt</span><span class="params">(U&amp;&amp; other)</span> : value(std::forward&lt;U&gt;(other)) &#123;</span> &#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过这一方式，就能够实现一个即使用了EBCO优化，又能保持元素的初始化顺序，并支持包含相同类型元素的元组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuple</span>;</span><br><span class="line"><span class="comment">// recursive case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuple</span>&lt;Head, Tail...&gt;</span><br><span class="line">: <span class="keyword">private</span> TupleElt&lt;<span class="keyword">sizeof</span>...(Tail), Head&gt;, <span class="keyword">private</span> Tuple&lt;Tail...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> HeadElt = TupleElt&lt;<span class="keyword">sizeof</span>...(Tail), Head&gt;;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Head&amp; <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;HeadElt *&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">get</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function">Head <span class="type">const</span>&amp; <span class="title">getHead</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;HeadElt <span class="type">const</span>*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Tuple&lt;Tail...&gt;&amp; <span class="title">getTail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="function">Tuple&lt;Tail...&gt; <span class="type">const</span>&amp; <span class="title">getTail</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// basis case:</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuple</span>&lt;&gt; &#123;</span><br><span class="line"><span class="comment">// no storage required</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>基于这一实现，下面的程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tupleelt1.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tuplestorage3.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="built_in">B</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tuple&lt;A, <span class="type">char</span>, A, <span class="type">char</span>, B&gt; t1;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(t1) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>会打印出：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">A</span>()</span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line"><span class="built_in">B</span>()</span><br><span class="line"><span class="number">5</span> bytes</span><br></pre></td></tr></table></figure></p>
<p>从中可以看出，EBCO使得内存占用减少了一个字节（减少的内容是空元组Tuple&lt;&gt;）。但是请注意A和B都是空的类，这暗示了进一步用EBCO进行优化的可能。如果能够安全的从其元素类型继承的话，那么就让TupleElt继承自其元素类型（这一优化不需要更改Tuple的定义）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> Height, <span class="keyword">typename</span> T,</span><br><span class="line"><span class="type">bool</span> = std::is_class&lt;T&gt;::value &amp;&amp; !std::is_final&lt;T&gt;::value&gt;</span><br><span class="line"><span class="keyword">class</span> TupleElt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> Height, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TupleElt</span>&lt;Height, T, <span class="literal">false</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TupleElt</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">TupleElt</span><span class="params">(U&amp;&amp; other)</span> : value(std::forward&lt;U&gt;(other)) &#123;</span> &#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> Height, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TupleElt</span>&lt;Height, T, <span class="literal">true</span>&gt; : <span class="keyword">private</span> T</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TupleElt</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">TupleElt</span><span class="params">(U&amp;&amp; other)</span> : T(std::forward&lt;U&gt;(other)) &#123;</span> &#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="function">T <span class="type">const</span>&amp; <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当提供给TupleElt的模板参数是一个可以被继承的类的时候，它会从该模板参数做private继承，从而也可以将EBCO用于被存储的值。有了这些变化，之前的程序会打印出：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">A</span>()</span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line"><span class="built_in">B</span>()</span><br><span class="line"><span class="number">2</span> bytes</span><br></pre></td></tr></table></figure></p>
<h3 id="常数时间的get"><a href="#常数时间的get" class="headerlink" title="常数时间的get()"></a>常数时间的get()</h3><p>在使用元组的时候，<code>get()</code>操作的使用是非常常见的，但是其递归的实现方式需要用到线性次数的模板实例化，这会影响编译所需要的时间。幸运的是，基于在之前章节中介绍的EBCO，可以实现一种更高效的get，我们接下来会对其进行讨论。</p>
<p>主要的思路是，当用一个（基类类型的）参数去适配一个（派生类类型的）参数时，模板参数推导会为基类推断出模板参数的类型。因此，如果我们能够计算出目标元素的高度H，就可以不用遍历所有的索引，也能够基于从Tuple的特化结果向<code>TupleElt&lt;H,T&gt;</code>（T的类型由推断得到）的转化提取出相应的元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> H, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp; <span class="title">getHeight</span><span class="params">(TupleElt&lt;H,T&gt;&amp; te)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> te.<span class="built_in">get</span>();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuple</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> I, <span class="keyword">typename</span>... Elements&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get</span><span class="params">(Tuple&lt;Elements...&gt;&amp; t)</span> -&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(getHeight&lt;<span class="keyword">sizeof</span>...(Elements)-I<span class="number">-1</span>&gt;(t))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getHeight</span>&lt;<span class="keyword">sizeof</span>...(Elements)-I<span class="number">-1</span>&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于<code>get&lt;I&gt;(t)</code>接收目标元素（从元组头部开始计算）的索引I作为参数，而元组的实际存储是以高度H来衡量的（从元组的末尾开始计算），因此需要用H来计算I。真正的查找工作是由调用<code>getHeight()</code>时的参数推导执行的：由于H是在函数调用时显示指定的，因此它的值是确定的，这样就只会有一个<code>TupleElt</code>会被匹配到，其模板参数T则是通过推断得到的。</p>
<p>这里必须要将<code>getHeight()</code>声明<code>Tuple</code>的friend，否则将无法执行从派生类向private父类的转换。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inside the recursive case for class template Tuple:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> I, <span class="keyword">typename</span>... Elements&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">auto</span> <span class="title">get</span><span class="params">(Tuple&lt;Elements...&gt;&amp; t)</span></span></span><br><span class="line"><span class="function">-&gt; <span class="title">decltype</span><span class="params">(getHeight&lt;<span class="keyword">sizeof</span>...(Elements)-I<span class="number">-1</span>&gt;(t))</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>由于我们已经将繁杂的索引匹配工作转移到了编译器的模板推断那里，因此这一实现方式只需要常数数量的模板实例化。</p>
<h2 id="元组下标"><a href="#元组下标" class="headerlink" title="元组下标"></a>元组下标</h2><p>理论上也可以通过定义<code>operator[]</code>来访问元组中的元素，这和在<code>std::vector</code>中定义<code>operator[]</code>的情况类似。不过和<code>std::vector</code>不同的是，元组中元素的类型可以不同，因此元组的<code>operator[]</code>必须是一个模板，其返回类型也需要随着索引的不同而不同。这反过来也就要求每一个索引都要有不同的类型，因为需要根据索引的类型来决定元素的类型。</p>
<p>使用类模板<code>CTValue</code>，可以将数值索引编码进一个类型中。将其用于Tuple下标运算符定义的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T Index&gt;</span><br><span class="line"><span class="keyword">auto</span>&amp; <span class="keyword">operator</span>[](CTValue&lt;T, Index&gt;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>&lt;Index&gt;(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后就可以基于被传递的CTValue类型的参数，用其中的索引信息去执行相关的<code>get&lt;&gt;()</code>调用。上述代码的用法如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> t = <span class="built_in">makeTuple</span>(<span class="number">0</span>, <span class="string">&quot;1&quot;</span>, <span class="number">2.2f</span>, std::string&#123;<span class="string">&quot;hello&quot;</span>&#125;);</span><br><span class="line"><span class="keyword">auto</span> a = t[CTValue&lt;<span class="type">unsigned</span>, <span class="number">2</span>&gt;&#123;&#125;];</span><br><span class="line"><span class="keyword">auto</span> b = t[CTValue&lt;<span class="type">unsigned</span>, <span class="number">3</span>&gt;&#123;&#125;];</span><br></pre></td></tr></table></figure></p>
<p>变量<code>a</code>和<code>b</code>分别会被<code>Tuple t</code>中的第三个和第四个参数初始化成相应的类型和数值。为了让常量索引的使用变得更方便，我们可以用<code>constexpr</code>实现一种字面常量运算符，专门用来直接从以_c结尾的常规字面常量，计算出所需的编译期数值字面常量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ctvalue.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="comment">// convert single char to corresponding int value at compile time:</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">toInt</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// hexadecimal letters:</span></span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&quot;A&quot;</span>&amp;&amp; c &lt;= <span class="string">&quot;F&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(c) - <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="string">&quot;A&quot;</span>) + <span class="number">10</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&quot;a&quot;</span>&amp;&amp; c &lt;= <span class="string">&quot;f&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(c) - <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="string">&quot;a&quot;</span>) + <span class="number">10</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// other (disable &quot;.&quot;for floating-point literals):</span></span><br><span class="line">    <span class="built_in">assert</span>(c &gt;= <span class="string">&quot;0&quot;</span>&amp;&amp; c &lt;= <span class="string">&quot;9&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(c) - <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// parse array of chars to corresponding int value at compile time:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;std::<span class="type">size_t</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">parseInt</span><span class="params">(<span class="type">char</span> <span class="type">const</span> (&amp;arr)[N])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> base = <span class="number">10</span>; <span class="comment">// to handle base (default: decimal)</span></span><br><span class="line">    <span class="type">int</span> offset = <span class="number">0</span>; <span class="comment">// to skip prefixes like 0x</span></span><br><span class="line">    <span class="keyword">if</span> (N &gt; <span class="number">2</span> &amp;&amp; arr[<span class="number">0</span>] == <span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (arr[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;x&quot;</span>: <span class="comment">//prefix 0x or 0X, so hexadecimal</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;X&quot;</span>:</span><br><span class="line">            base = <span class="number">16</span>;</span><br><span class="line">            offset = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>: <span class="comment">//prefix 0b or 0B (since C++14), so binary</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">            base = <span class="number">2</span>;offset = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">//prefix 0, so octal</span></span><br><span class="line">            base = <span class="number">8</span>;</span><br><span class="line">            offset = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// iterate over all digits and compute resulting value:</span></span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> multiplier = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; N - offset; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[N<span class="number">-1</span>-i] != <span class="string">&quot;\&quot;&quot;</span>) &#123; <span class="comment">//ignore separating single quotes (e.g. in 1’ 000)</span></span><br><span class="line">            value += <span class="built_in">toInt</span>(arr[N<span class="number">-1</span>-i]) * multiplier;</span><br><span class="line">            multiplier *= base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// literal operator: parse integral literals with suffix _c as sequence of chars:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">char</span>... cs&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _c() &#123;</span><br><span class="line">    <span class="keyword">return</span> CTValue&lt;<span class="type">int</span>, <span class="built_in">parseInt</span>&lt;<span class="keyword">sizeof</span>...(cs)&gt;(&#123;cs...&#125;)&gt;&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处我们用到了这样一个事实，对于数值字面常量，可以用字面常量运算符推导出该字面常量的每一个字符，并将其用作字面常量运算符模板的参数。然后将这些字符传递给一个<code>constexpr</code>类型的辅助函数<code>parseInt()</code>（它可以计算出字符串序列的值，并将其按照CTValue类型返回）。比如：</p>
<ul>
<li><code>42_c</code>生成<code>CTValue&lt;int,42&gt;</code></li>
<li><code>0x815_c</code>生成<code>CTValue&lt;int,2069&gt;</code></li>
<li><code>0b1111’1111_c</code>生成<code>CTValue&lt;int,255&gt;</code></li>
</ul>
<p>注意该程序不会处理浮点型字面值常量。对这种情况，相应的assert语句会触发编译期错误，因为这是一个运行期的特性，不能用在编译期上下文中。基于以上内容，可以像下面这样使用元组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> t = <span class="built_in">makeTuple</span>(<span class="number">0</span>, <span class="string">&quot;1&quot;</span>, <span class="number">2.2f</span>, std::string&#123;<span class="string">&quot;hello&quot;</span>&#125;);</span><br><span class="line"><span class="keyword">auto</span> c = t[<span class="number">2</span>_c];</span><br><span class="line"><span class="keyword">auto</span> d = t[<span class="number">3</span>_c];</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/04/Introduction%20to%20HPC%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/" rel="prev" title="Introduction to HPC——笔记">
      <i class="fa fa-chevron-left"></i> Introduction to HPC——笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/28/cpp%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/" rel="next" title="C++性能优化指南">
      C++性能优化指南 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%EF%BC%88Function-Templates%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">函数模板（Function Templates）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%88%9D%E6%8E%A2"><span class="nav-number">1.1.</span> <span class="nav-text">函数模板初探</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.1.</span> <span class="nav-text">定义模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.2.</span> <span class="nav-text">使用模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BC%96%E8%AF%91%E6%A3%80%E6%9F%A5%EF%BC%88Two-Phase-Translation-%EF%BC%89"><span class="nav-number">1.1.3.</span> <span class="nav-text">两阶段编译检查（Two-Phase Translation ）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="nav-number">1.1.4.</span> <span class="nav-text">编译和链接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%8E%A8%E6%96%AD"><span class="nav-number">1.2.</span> <span class="nav-text">模板参数推断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.2.1.</span> <span class="nav-text">类型推断中的类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E9%BB%98%E8%AE%A4%E8%B0%83%E7%94%A8%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="nav-number">1.2.2.</span> <span class="nav-text">对默认调用参数的类型推断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.</span> <span class="nav-text">多个模板参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.1.</span> <span class="nav-text">作为返回类型的模板参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="nav-number">1.3.2.</span> <span class="nav-text">返回类型推断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E4%B8%BA%E5%85%AC%E5%85%B1%E7%B1%BB%E5%9E%8B%EF%BC%88Common-Type%EF%BC%89"><span class="nav-number">1.3.3.</span> <span class="nav-text">将返回类型声明为公共类型（Common Type）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="nav-number">1.4.</span> <span class="nav-text">默认模板参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">1.5.</span> <span class="nav-text">函数模板的重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%BE%E9%81%93%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%8D%E5%BA%94%E8%AF%A5%E2%80%A6%EF%BC%9F"><span class="nav-number">1.6.</span> <span class="nav-text">难道，我们不应该…？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="nav-number">1.7.</span> <span class="nav-text">按值传递还是按引用传递？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%80%82%E7%94%A8inline%EF%BC%9F"><span class="nav-number">1.7.1.</span> <span class="nav-text">为什么不适用inline？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8constexpr%EF%BC%9F"><span class="nav-number">1.7.2.</span> <span class="nav-text">为什么不用constexpr？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%EF%BC%88Class-Templates%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">类模板（Class Templates）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Stack%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.</span> <span class="nav-text">Stack类模板的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.1.1.</span> <span class="nav-text">声明一个类模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.2.</span> <span class="nav-text">成员函数的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stack%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">2.2.</span> <span class="nav-text">Stack类模板的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%83%A8%E5%88%86%E5%9C%B0%E4%BD%BF%E7%94%A8%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.3.</span> <span class="nav-text">部分地使用类模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Concept"><span class="nav-number">2.3.1.</span> <span class="nav-text">Concept</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8B%E5%85%83"><span class="nav-number">2.4.</span> <span class="nav-text">友元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="nav-number">2.5.</span> <span class="nav-text">模板类的特例化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%83%A8%E5%88%86%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="nav-number">2.6.</span> <span class="nav-text">部分特例化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E7%9A%84%E9%83%A8%E5%88%86%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="nav-number">2.6.1.</span> <span class="nav-text">多模板参数的部分特例化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="nav-number">2.7.</span> <span class="nav-text">默认类模板参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%EF%BC%88Type-Aliases%EF%BC%89"><span class="nav-number">2.8.</span> <span class="nav-text">类型别名（Type Aliases）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Typedefs%E5%92%8CAlias%E5%A3%B0%E6%98%8E"><span class="nav-number">2.8.1.</span> <span class="nav-text">Typedefs和Alias声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Alias-Templates%EF%BC%88%E5%88%AB%E5%90%8D%E6%A8%A1%E6%9D%BF%EF%BC%89"><span class="nav-number">2.8.2.</span> <span class="nav-text">Alias Templates（别名模板）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Alias-Templates-for-Member-Types%EF%BC%88class%E6%88%90%E5%91%98%E7%9A%84%E5%88%AB%E5%90%8D%E6%A8%A1%E6%9D%BF%EF%BC%89"><span class="nav-number">2.8.3.</span> <span class="nav-text">Alias Templates for Member Types（class成员的别名模板）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Type-Traits-Suffix-t-%EF%BC%88Suffix-t%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96%EF%BC%89"><span class="nav-number">2.8.4.</span> <span class="nav-text">Type Traits Suffix_t （Suffix_t类型萃取）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="nav-number">2.9.</span> <span class="nav-text">类模板的类型推导</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%EF%BC%88Class-Template-Arguments-Deduction-with-String-Literals%EF%BC%89"><span class="nav-number">2.9.1.</span> <span class="nav-text">类模板对字符串常量参数的类型推断（Class Template Arguments Deduction with String Literals）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E6%96%AD%E6%8C%87%E5%BC%95%EF%BC%88Deduction-Guides%EF%BC%89"><span class="nav-number">2.9.2.</span> <span class="nav-text">推断指引（Deduction Guides）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%8C%96%EF%BC%88Templatized-Aggregates%EF%BC%89"><span class="nav-number">2.10.</span> <span class="nav-text">聚合类的模板化（Templatized Aggregates）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">2.11.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text">非类型模板参数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-number">3.1.</span> <span class="nav-text">类模板的非类型参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-number">3.2.</span> <span class="nav-text">函数模板的非类型参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-number">3.3.</span> <span class="nav-text">非类型模板参数的限制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%97%A0%E6%95%88%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.3.1.</span> <span class="nav-text">避免无效表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8auto%E4%BD%9C%E4%B8%BA%E9%9D%9E%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.4.</span> <span class="nav-text">用auto作为非模板类型参数的类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">3.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%98%E5%8F%82%E6%A8%A1%E6%9D%BF"><span class="nav-number">4.</span> <span class="nav-text">变参模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E5%8F%82%E6%A8%A1%E6%9D%BF-1"><span class="nav-number">4.1.</span> <span class="nav-text">变参模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%8F%82%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%88%97"><span class="nav-number">4.1.1.</span> <span class="nav-text">变参模板实列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%8F%82%E5%92%8C%E9%9D%9E%E5%8F%98%E5%8F%82%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">4.1.2.</span> <span class="nav-text">变参和非变参模板的重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sizeof%E2%80%A6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">4.1.3.</span> <span class="nav-text">sizeof…运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">折叠表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E5%8F%82%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.3.</span> <span class="nav-text">变参模板的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E5%8F%82%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%8F%98%E5%8F%82%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.4.</span> <span class="nav-text">变参类模板和变参表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%8F%82%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.4.1.</span> <span class="nav-text">变参表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%8F%82%E4%B8%8B%E6%A0%87%EF%BC%88Variadic-Indices%EF%BC%89"><span class="nav-number">4.4.2.</span> <span class="nav-text">变参下标（Variadic Indices）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%8F%82%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">4.4.3.</span> <span class="nav-text">变参类模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%8F%82%E6%8E%A8%E6%96%AD%E6%8C%87%E5%BC%95"><span class="nav-number">4.4.4.</span> <span class="nav-text">变参推断指引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%8F%82%E5%9F%BA%E7%B1%BB%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8"><span class="nav-number">4.4.5.</span> <span class="nav-text">变参基类及其使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-3"><span class="nav-number">4.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%8A%80%E5%B7%A7"><span class="nav-number">5.</span> <span class="nav-text">基础技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#typename%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">5.1.</span> <span class="nav-text">typename关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%B6%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.2.</span> <span class="nav-text">零初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8this-gt"><span class="nav-number">5.3.</span> <span class="nav-text">使用this-&gt;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A3%B8%E6%95%B0%E7%BB%84%E6%88%96%E8%80%85%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="nav-number">5.4.</span> <span class="nav-text">使用裸数组或者字符串常量的模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF"><span class="nav-number">5.5.</span> <span class="nav-text">成员模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="nav-number">5.5.1.</span> <span class="nav-text">成员模板的特例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="nav-number">5.5.2.</span> <span class="nav-text">特殊成员函数的模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#template%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">5.5.3.</span> <span class="nav-text">.template的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8Blambdas%E5%92%8C%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF"><span class="nav-number">5.5.4.</span> <span class="nav-text">泛型lambdas和成员模板</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%A8%A1%E6%9D%BF"><span class="nav-number">5.6.</span> <span class="nav-text">变量模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%8F%98%E9%87%8F%E6%A8%A1%E6%9D%BF"><span class="nav-number">5.6.1.</span> <span class="nav-text">用于数据成员的变量模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96Suffix-v"><span class="nav-number">5.6.2.</span> <span class="nav-text">类型萃取Suffix_v</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">5.7.</span> <span class="nav-text">模板参数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8F%82%E6%95%B0%E5%8C%B9%E9%85%8D"><span class="nav-number">5.7.1.</span> <span class="nav-text">模板参数模板的参数匹配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-4"><span class="nav-number">5.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%92%8Cenable-if-lt-gt"><span class="nav-number">6.</span> <span class="nav-text">移动语义和enable_if&lt;&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%EF%BC%88Perfect-Forwarding%EF%BC%89"><span class="nav-number">6.1.</span> <span class="nav-text">完美转发（Perfect Forwarding）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">6.2.</span> <span class="nav-text">特殊成员函数模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87std-enable-if-lt-gt-%E7%A6%81%E7%94%A8%E6%A8%A1%E6%9D%BF"><span class="nav-number">6.3.</span> <span class="nav-text">通过std::enable_if&lt;&gt;禁用模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8enable-if-lt-gt"><span class="nav-number">6.4.</span> <span class="nav-text">使用enable_if&lt;&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A6%81%E7%94%A8%E6%9F%90%E4%BA%9B%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">6.4.1.</span> <span class="nav-text">禁用某些成员函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8concept%E7%AE%80%E5%8C%96enable-if-lt-gt-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">6.5.</span> <span class="nav-text">使用concept简化enable_if&lt;&gt;表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-5"><span class="nav-number">6.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="nav-number">7.</span> <span class="nav-text">按值传递还是按引用传递</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92"><span class="nav-number">7.1.</span> <span class="nav-text">按值传递</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%B1%BB%E5%9E%8B%E9%80%80%E5%8C%96%EF%BC%88decay%EF%BC%89"><span class="nav-number">7.1.1.</span> <span class="nav-text">按值传递会导致类型退化（decay）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="nav-number">7.2.</span> <span class="nav-text">按引用传递</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89const%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="nav-number">7.2.1.</span> <span class="nav-text">按const引用传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E4%B8%8D%E4%BC%9A%E5%81%9A%E7%B1%BB%E5%9E%8B%E9%80%80%E5%8C%96%EF%BC%88decay%EF%BC%89"><span class="nav-number">7.2.2.</span> <span class="nav-text">按引用传递不会做类型退化（decay）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89%E9%9D%9Econst%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="nav-number">7.2.3.</span> <span class="nav-text">按非const引用传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89%E8%BD%AC%E5%8F%91%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%EF%BC%88Forwarding-Reference%EF%BC%89"><span class="nav-number">7.2.4.</span> <span class="nav-text">按转发引用传递参数（Forwarding Reference）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8std-ref-%E5%92%8Cstd-cref"><span class="nav-number">7.3.</span> <span class="nav-text">使用std::ref()和std::cref()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E5%92%8C%E8%A3%B8%E6%95%B0%E7%BB%84"><span class="nav-number">7.4.</span> <span class="nav-text">处理字符串常量和裸数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E5%92%8C%E8%A3%B8%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.4.1.</span> <span class="nav-text">关于字符串常量和裸数组的特殊实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">7.5.</span> <span class="nav-text">处理返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E5%A3%B0%E6%98%8E%E7%9A%84%E6%8E%A8%E8%8D%90%E6%96%B9%E6%B3%95"><span class="nav-number">7.6.</span> <span class="nav-text">关于模板参数声明的推荐方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E8%BF%87%E5%88%86%E6%B3%9B%E5%9E%8B%E5%8C%96"><span class="nav-number">7.6.1.</span> <span class="nav-text">不要过分泛型化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5std-make-pair-lt-gt-%E4%B8%BA%E4%BE%8B"><span class="nav-number">7.6.1.1.</span> <span class="nav-text">以std::make_pair&lt;&gt;为例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-6"><span class="nav-number">7.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%9C%9F%E7%BC%96%E7%A8%8B"><span class="nav-number">8.</span> <span class="nav-text">编译期编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B"><span class="nav-number">8.1.</span> <span class="nav-text">模板元编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87constexpr%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97"><span class="nav-number">8.2.</span> <span class="nav-text">通过constexpr进行计算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E9%83%A8%E5%88%86%E7%89%B9%E4%BE%8B%E5%8C%96%E8%BF%9B%E8%A1%8C%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9"><span class="nav-number">8.3.</span> <span class="nav-text">通过部分特例化进行路径选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SFINAE-Substitution-Failure-Is-Not-An-Error-%E6%9B%BF%E6%8D%A2%E5%A4%B1%E8%B4%A5%E4%B8%8D%E6%98%AF%E9%94%99%E8%AF%AF"><span class="nav-number">8.4.</span> <span class="nav-text">SFINAE (Substitution Failure Is Not An Error,替换失败不是错误)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87decltype%E8%BF%9B%E8%A1%8CSFINAE%EF%BC%88%E6%AD%A4%E5%A4%84%E6%98%AF%E5%8A%A8%E8%AF%8D%EF%BC%89%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">8.4.1.</span> <span class="nav-text">通过decltype进行SFINAE（此处是动词）的表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%9C%9Fif"><span class="nav-number">8.5.</span> <span class="nav-text">编译期if</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-7"><span class="nav-number">8.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8%E5%AE%9E%E8%B7%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF"><span class="nav-number">9.</span> <span class="nav-text">在实践中使用模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E5%90%AB%E6%A8%A1%E5%BC%8F"><span class="nav-number">9.1.</span> <span class="nav-text">包含模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E9%94%99%E8%AF%AF"><span class="nav-number">9.1.1.</span> <span class="nav-text">链接错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="nav-number">9.1.2.</span> <span class="nav-text">头文件中的模板</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%92%8Cinline"><span class="nav-number">9.2.</span> <span class="nav-text">模板和inline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">9.3.</span> <span class="nav-text">预编译头文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A0%B4%E8%AF%91%E5%A4%A7%E7%AF%87%E5%B9%85%E7%9A%84%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF"><span class="nav-number">9.4.</span> <span class="nav-text">破译大篇幅的错误信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%8C%B9%E9%85%8D%E6%83%85%E5%86%B5"><span class="nav-number">9.4.1.</span> <span class="nav-text">简单的类型不匹配情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-8"><span class="nav-number">9.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-number">10.</span> <span class="nav-text">模板基本术语</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%80%9C%E7%B1%BB%E6%A8%A1%E6%9D%BF%E2%80%9D%E8%BF%98%E6%98%AF%E2%80%9C%E6%A8%A1%E6%9D%BF%E7%B1%BB%E2%80%9D"><span class="nav-number">10.1.</span> <span class="nav-text">“类模板”还是“模板类”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%EF%BC%8C%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%8C%E5%92%8C%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="nav-number">10.2.</span> <span class="nav-text">替换，实例化，和特例化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89"><span class="nav-number">10.3.</span> <span class="nav-text">声明和定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%9D%9E%E5%AE%8C%E6%95%B4%E7%B1%BB%E5%9E%8B%EF%BC%88complete-versus-incomplete-types%EF%BC%89"><span class="nav-number">10.3.1.</span> <span class="nav-text">完整类型和非完整类型（complete versus incomplete types）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E5%AE%9A%E4%B9%89%E6%B3%95%E5%88%99"><span class="nav-number">10.4.</span> <span class="nav-text">唯一定义法则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Template-Arguments-versus-Template-Parameters"><span class="nav-number">10.5.</span> <span class="nav-text">Template Arguments versus Template Parameters</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-9"><span class="nav-number">10.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%BA%93"><span class="nav-number">11.</span> <span class="nav-text">泛型库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%EF%BC%88Callables%EF%BC%89"><span class="nav-number">11.1.</span> <span class="nav-text">可调用对象（Callables）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%94%AF%E6%8C%81"><span class="nav-number">11.1.1.</span> <span class="nav-text">函数对象的支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E9%A2%9D%E5%A4%96%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">11.1.2.</span> <span class="nav-text">处理成员函数以及额外的参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%8C%85%E8%A3%85"><span class="nav-number">11.1.3.</span> <span class="nav-text">函数调用的包装</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%B3%9B%E5%9E%8B%E5%BA%93%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="nav-number">11.2.</span> <span class="nav-text">其他一些实现泛型库的工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96"><span class="nav-number">11.2.1.</span> <span class="nav-text">类型萃取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-addressoff"><span class="nav-number">11.2.2.</span> <span class="nav-text">std::addressoff()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-declval"><span class="nav-number">11.2.3.</span> <span class="nav-text">std::declval()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F"><span class="nav-number">11.3.</span> <span class="nav-text">完美转发临时变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-number">11.4.</span> <span class="nav-text">作为模板参数的引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A8%E8%BF%9F%E8%AE%A1%E7%AE%97%EF%BC%88Defer-Evaluation%EF%BC%89"><span class="nav-number">11.5.</span> <span class="nav-text">推迟计算（Defer Evaluation）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E5%86%99%E6%B3%9B%E5%9E%8B%E5%BA%93%E6%97%B6%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E4%BA%8B%E6%83%85"><span class="nav-number">11.6.</span> <span class="nav-text">在写泛型库时需要考虑的事情</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-10"><span class="nav-number">11.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E6%A8%A1%E6%9D%BF"><span class="nav-number">12.</span> <span class="nav-text">深入模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%9D%9E%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98"><span class="nav-number">12.1.</span> <span class="nav-text">类模板的非模板成员</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">12.1.1.</span> <span class="nav-text">虚拟成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%A4%96%E8%81%94"><span class="nav-number">12.1.2.</span> <span class="nav-text">模板外联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%A8%A1%E6%9D%BF"><span class="nav-number">12.1.3.</span> <span class="nav-text">主要模板</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="nav-number">12.2.</span> <span class="nav-text">模板参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-number">12.2.1.</span> <span class="nav-text">类型参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-number">12.2.2.</span> <span class="nav-text">非类型参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="nav-number">12.2.3.</span> <span class="nav-text">模板模板参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E5%8C%85"><span class="nav-number">12.2.4.</span> <span class="nav-text">模板参数包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0-1"><span class="nav-number">12.2.5.</span> <span class="nav-text">默认模板参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0-1"><span class="nav-number">12.3.</span> <span class="nav-text">模板参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="nav-number">12.3.1.</span> <span class="nav-text">函数模板参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0-1"><span class="nav-number">12.3.2.</span> <span class="nav-text">非类型参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0-1"><span class="nav-number">12.3.3.</span> <span class="nav-text">模板模板参数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="nav-number">13.</span> <span class="nav-text">模板中的名称</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8D%E7%A7%B0%E5%88%86%E7%B1%BB"><span class="nav-number">13.1.</span> <span class="nav-text">名称分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%90%8D%E7%A7%B0"><span class="nav-number">13.2.</span> <span class="nav-text">查找名称</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E7%9B%B8%E5%85%B3%E6%9F%A5%E6%89%BEADL"><span class="nav-number">13.2.1.</span> <span class="nav-text">参数相关查找ADL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E6%A8%A1%E6%9D%BF"><span class="nav-number">13.3.</span> <span class="nav-text">解析模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E6%95%8F%E6%84%9F%E6%80%A7"><span class="nav-number">13.3.1.</span> <span class="nav-text">非模板中的上下文敏感性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">14.</span> <span class="nav-text">实例化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%89%E9%9C%80%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">14.1.</span> <span class="nav-text">按需实例化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%83%B0%E6%80%A7%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">14.2.</span> <span class="nav-text">惰性实例化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%83%A8%E5%88%86%E5%92%8C%E5%85%A8%E9%83%A8%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">14.2.1.</span> <span class="nav-text">部分和全部实例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%BB%84%E4%BB%B6"><span class="nav-number">14.2.2.</span> <span class="nav-text">实例化组件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%A8%A1%E5%9E%8B"><span class="nav-number">14.3.</span> <span class="nav-text">C++实例化模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%9F%A5%E6%89%BE"><span class="nav-number">14.3.1.</span> <span class="nav-text">两阶段查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%82%B9"><span class="nav-number">14.3.2.</span> <span class="nav-text">实例化点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%9C%9Fif%E6%AE%B5"><span class="nav-number">14.4.</span> <span class="nav-text">编译期if段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD"><span class="nav-number">14.5.</span> <span class="nav-text">在标准库中</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%8E%A8%E5%AF%BC"><span class="nav-number">15.</span> <span class="nav-text">模板参数推导</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A8%E5%AF%BC%E8%BF%87%E7%A8%8B"><span class="nav-number">15.1.</span> <span class="nav-text">推导过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A8%E6%96%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-number">15.2.</span> <span class="nav-text">推断的上下文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%8E%A8%E5%AF%BC%E6%83%85%E5%86%B5"><span class="nav-number">15.3.</span> <span class="nav-text">特殊推导情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">15.4.</span> <span class="nav-text">初始化列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%8C%85"><span class="nav-number">15.5.</span> <span class="nav-text">参数包</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%A4%9A%E6%80%81%E6%80%A7"><span class="nav-number">16.</span> <span class="nav-text">模板的多态性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%EF%BC%88dynamic-polymorphism%EF%BC%89"><span class="nav-number">16.1.</span> <span class="nav-text">动态多态（dynamic polymorphism）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81"><span class="nav-number">16.2.</span> <span class="nav-text">静态多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81VS%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81"><span class="nav-number">16.3.</span> <span class="nav-text">动态多态VS静态多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8concepts"><span class="nav-number">16.4.</span> <span class="nav-text">使用concepts</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88Generic-Programming%EF%BC%89"><span class="nav-number">16.5.</span> <span class="nav-text">泛型编程（Generic Programming）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%90%83%E5%8F%96%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">17.</span> <span class="nav-text">萃取的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%AF%B9%E4%B8%80%E4%B8%AA%E5%BA%8F%E5%88%97%E6%B1%82%E5%92%8C"><span class="nav-number">17.1.</span> <span class="nav-text">一个例子：对一个序列求和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E7%9A%84%E8%90%83%E5%8F%96%EF%BC%88Fixed-Traits%EF%BC%89"><span class="nav-number">17.1.1.</span> <span class="nav-text">固定的萃取（Fixed Traits）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%BC%E8%90%83%E5%8F%96%EF%BC%88Value-Traits%EF%BC%89"><span class="nav-number">17.1.2.</span> <span class="nav-text">值萃取（Value Traits）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%8C%96%E7%9A%84%E8%90%83%E5%8F%96"><span class="nav-number">17.1.3.</span> <span class="nav-text">参数化的萃取</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%90%83%E5%8F%96%E8%BF%98%E6%98%AF%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8A%E7%AD%96%E7%95%A5%E7%B1%BB"><span class="nav-number">17.2.</span> <span class="nav-text">萃取还是策略以及策略类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%90%83%E5%8F%96%E5%92%8C%E7%AD%96%E7%95%A5%EF%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">17.2.1.</span> <span class="nav-text">萃取和策略：有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF%E8%BF%98%E6%98%AF%E6%A8%A1%E6%9D%BF%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="nav-number">17.2.2.</span> <span class="nav-text">成员模板还是模板模板参数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E5%90%88%E5%A4%9A%E4%B8%AA%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8A-%E6%88%96%E8%80%85%E8%90%83%E5%8F%96"><span class="nav-number">17.2.3.</span> <span class="nav-text">结合多个策略以及&#x2F;或者萃取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E6%99%AE%E9%80%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%B4%AF%E7%A7%AF"><span class="nav-number">17.2.4.</span> <span class="nav-text">通过普通迭代器实现累积</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="nav-number">17.3.</span> <span class="nav-text">类型函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B"><span class="nav-number">17.3.1.</span> <span class="nav-text">元素类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E8%90%83%E5%8F%96%EF%BC%88Transformation-Traits%EF%BC%89"><span class="nav-number">17.3.2.</span> <span class="nav-text">转换萃取（Transformation Traits）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%BC%95%E7%94%A8"><span class="nav-number">17.3.2.1.</span> <span class="nav-text">删除引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%BC%95%E7%94%A8"><span class="nav-number">17.3.2.2.</span> <span class="nav-text">添加引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E9%99%90%E5%88%B6%E7%AC%A6"><span class="nav-number">17.3.2.3.</span> <span class="nav-text">移除限制符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%80%E5%8C%96%EF%BC%88Decay%EF%BC%89"><span class="nav-number">17.3.2.4.</span> <span class="nav-text">退化（Decay）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E6%B5%8B%E5%9E%8B%E8%90%83%E5%8F%96"><span class="nav-number">17.3.3.</span> <span class="nav-text">预测型萃取</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#true-type%E5%92%8Cfalse-type"><span class="nav-number">17.3.3.1.</span> <span class="nav-text">true_type和false_type</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96"><span class="nav-number">17.3.4.</span> <span class="nav-text">返回结果类型萃取</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#declval"><span class="nav-number">17.3.4.1.</span> <span class="nav-text">declval</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8ESFINAE%E7%9A%84%E8%90%83%E5%8F%96%EF%BC%88SFINAE-Based-Traits%EF%BC%89"><span class="nav-number">17.4.</span> <span class="nav-text">基于SFINAE的萃取（SFINAE-Based Traits）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8SFINAE%E6%8E%92%E9%99%A4%E6%9F%90%E4%BA%9B%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="nav-number">17.4.1.</span> <span class="nav-text">用SFINAE排除某些重载函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8ESFINAE%E7%9A%84%E8%90%83%E5%8F%96%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AD%96%E7%95%A5"><span class="nav-number">17.4.1.1.</span> <span class="nav-text">另一种基于SFINAE的萃取的实现策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8SFINAE%E6%8E%92%E9%99%A4%E5%81%8F%E7%89%B9%E5%8C%96"><span class="nav-number">17.4.2.</span> <span class="nav-text">用SFINAE排除偏特化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E6%B3%9B%E5%9E%8BLambdas%E7%94%A8%E4%BA%8ESFINAE"><span class="nav-number">17.4.3.</span> <span class="nav-text">将泛型Lambdas用于SFINAE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SFINAE%E5%8F%8B%E5%A5%BD%E7%9A%84%E8%90%83%E5%8F%96"><span class="nav-number">17.4.4.</span> <span class="nav-text">SFINAE友好的萃取</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IsConvertibleT"><span class="nav-number">17.5.</span> <span class="nav-text">IsConvertibleT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="nav-number">17.5.0.1.</span> <span class="nav-text">处理特殊情况</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A2%E6%B5%8B%E6%88%90%E5%91%98%EF%BC%88Detecting-Members%EF%BC%89"><span class="nav-number">17.6.</span> <span class="nav-text">探测成员（Detecting Members）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A2%E6%B5%8B%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98"><span class="nav-number">17.6.1.</span> <span class="nav-text">探测类型成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A2%E6%B5%8B%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98"><span class="nav-number">17.6.2.</span> <span class="nav-text">探测任意类型成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A2%E6%B5%8B%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98"><span class="nav-number">17.6.3.</span> <span class="nav-text">探测非类型成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%B3%9B%E5%9E%8BLambda%E6%8E%A2%E6%B5%8B%E6%88%90%E5%91%98"><span class="nav-number">17.6.4.</span> <span class="nav-text">用泛型Lambda探测成员</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E7%9A%84%E8%90%83%E5%8F%96%E6%8A%80%E6%9C%AF"><span class="nav-number">17.7.</span> <span class="nav-text">其它的萃取技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#If-Then-Else"><span class="nav-number">17.7.1.</span> <span class="nav-text">If-Then-Else</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A2%E6%B5%8B%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">17.7.2.</span> <span class="nav-text">探测不抛出异常的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%90%83%E5%8F%96%E7%9A%84%E4%BE%BF%E6%8D%B7%E6%80%A7"><span class="nav-number">17.7.3.</span> <span class="nav-text">萃取的便捷性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%AB%E5%90%8D%E6%A8%A1%E6%9D%BF%E5%92%8C%E8%90%83%E5%8F%96"><span class="nav-number">17.7.3.1.</span> <span class="nav-text">别名模板和萃取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%A8%A1%E6%9D%BF%E5%92%8C%E8%90%83%E5%8F%96"><span class="nav-number">17.7.3.2.</span> <span class="nav-text">变量模板和萃取</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="nav-number">17.8.</span> <span class="nav-text">类型分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="nav-number">17.8.1.</span> <span class="nav-text">判断基础类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">17.8.2.</span> <span class="nav-text">判断复合类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%86%E5%88%AB%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">17.8.3.</span> <span class="nav-text">识别函数类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%ADclass%E7%B1%BB%E5%9E%8B"><span class="nav-number">17.8.4.</span> <span class="nav-text">判断class类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%86%E5%88%AB%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">17.8.5.</span> <span class="nav-text">识别枚举类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E8%90%83%E5%8F%96%EF%BC%88Policy-Traits%EF%BC%89"><span class="nav-number">17.9.</span> <span class="nav-text">策略萃取（Policy Traits）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E8%AF%BB%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">17.9.1.</span> <span class="nav-text">只读参数类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">17.10.</span> <span class="nav-text">在标准库中的情况</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">18.</span> <span class="nav-text">基于类型属性的重载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%89%B9%E5%8C%96"><span class="nav-number">18.1.</span> <span class="nav-text">算法特化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E6%B4%BE%E5%8F%91%EF%BC%88Tag-Dispatching%EF%BC%89"><span class="nav-number">18.2.</span> <span class="nav-text">标记派发（Tag Dispatching）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Enable-Disable%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">18.3.</span> <span class="nav-text">Enable&#x2F;Disable函数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BE%9B%E5%A4%9A%E7%A7%8D%E7%89%B9%E5%8C%96%E7%89%88%E6%9C%AC"><span class="nav-number">18.3.1.</span> <span class="nav-text">提供多种特化版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EnableIf%E6%89%80%E4%B9%8B%E4%BD%95%E5%A4%84"><span class="nav-number">18.3.2.</span> <span class="nav-text">EnableIf所之何处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%9C%9Fif-1"><span class="nav-number">18.3.3.</span> <span class="nav-text">编译期if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Concepts"><span class="nav-number">18.3.4.</span> <span class="nav-text">Concepts</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E7%89%B9%E5%8C%96"><span class="nav-number">18.4.</span> <span class="nav-text">类的特化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E7%94%A8-%E7%A6%81%E7%94%A8%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">18.4.1.</span> <span class="nav-text">启用&#x2F;禁用类模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%A0%87%E8%AE%B0%E6%B4%BE%E5%8F%91"><span class="nav-number">18.4.2.</span> <span class="nav-text">类模板的标记派发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AE%89%E5%85%A8%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="nav-number">18.5.</span> <span class="nav-text">实例化安全的模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E6%83%85%E5%86%B5-1"><span class="nav-number">18.6.</span> <span class="nav-text">在标准库中的情况</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="nav-number">19.</span> <span class="nav-text">模板和继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E5%9F%BA%E7%B1%BB%E4%BC%98%E5%8C%96"><span class="nav-number">19.1.</span> <span class="nav-text">空基类优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E5%B1%80%E5%8E%9F%E5%88%99"><span class="nav-number">19.1.1.</span> <span class="nav-text">布局原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%AE%9E%E7%8E%B0%E4%B8%BA%E5%9F%BA%E7%B1%BB"><span class="nav-number">19.1.2.</span> <span class="nav-text">将数据成员实现为基类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Curiously-Recurring-Template-Pattern-CRTP"><span class="nav-number">19.2.</span> <span class="nav-text">The Curiously Recurring Template Pattern (CRTP)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Barton-Nackman-Trick"><span class="nav-number">19.2.1.</span> <span class="nav-text">The Barton-Nackman Trick</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">19.2.2.</span> <span class="nav-text">运算符的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mixins"><span class="nav-number">19.3.</span> <span class="nav-text">Mixins</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Curious-Mixins"><span class="nav-number">19.3.1.</span> <span class="nav-text">Curious Mixins</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parameterized-Virtuality"><span class="nav-number">19.3.2.</span> <span class="nav-text">Parameterized Virtuality</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Named-Template-Arguments"><span class="nav-number">19.4.</span> <span class="nav-text">Named Template Arguments</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5static%E5%92%8Cdynamic%E5%A4%9A%E6%80%81"><span class="nav-number">20.</span> <span class="nav-text">桥接static和dynamic多态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%8C%87%E9%92%88%EF%BC%8C%E4%BB%A5%E5%8F%8Astd-function-lt-gt"><span class="nav-number">20.1.</span> <span class="nav-text">函数对象，指针，以及std:function&lt;&gt;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">20.2.</span> <span class="nav-text">广义函数指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5%E6%8E%A5%E5%8F%A3"><span class="nav-number">20.3.</span> <span class="nav-text">桥接接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%88Type-Erasure%EF%BC%89"><span class="nav-number">20.4.</span> <span class="nav-text">类型擦除（Type Erasure）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E6%A1%A5%E6%8E%A5%EF%BC%88Optional-Bridging%EF%BC%89"><span class="nav-number">20.5.</span> <span class="nav-text">可选桥接（Optional Bridging）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E8%80%83%E9%87%8F"><span class="nav-number">20.6.</span> <span class="nav-text">性能考量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%83%E7%BC%96%E7%A8%8B"><span class="nav-number">21.</span> <span class="nav-text">元编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%B0%E4%BB%A3C-%E5%85%83%E7%BC%96%E7%A8%8B%E7%9A%84%E7%8E%B0%E7%8A%B6"><span class="nav-number">21.1.</span> <span class="nav-text">现代C++元编程的现状</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%BC%E5%85%83%E7%BC%96%E7%A8%8B%EF%BC%88Value-Metaprogramming%EF%BC%89"><span class="nav-number">21.1.1.</span> <span class="nav-text">值元编程（Value Metaprogramming）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%85%83%E7%BC%96%E7%A8%8B"><span class="nav-number">21.1.2.</span> <span class="nav-text">类型元编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E5%85%83%E7%BC%96%E7%A8%8B"><span class="nav-number">21.1.3.</span> <span class="nav-text">混合元编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E6%B7%B7%E5%90%88%E5%85%83%E7%BC%96%E7%A8%8B%E7%94%A8%E4%BA%8E%E2%80%9C%E5%8D%95%E4%BD%8D%E7%B1%BB%E5%9E%8B%E2%80%9D"><span class="nav-number">21.1.4.</span> <span class="nav-text">将混合元编程用于“单位类型”</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E5%85%83%E7%BC%96%E7%A8%8B%E7%9A%84%E7%BB%B4%E5%BA%A6"><span class="nav-number">21.2.</span> <span class="nav-text">反射元编程的维度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="nav-number">21.3.</span> <span class="nav-text">递归实例化的代价</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%BD%E8%B8%AA%E6%89%80%E6%9C%89%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">21.3.1.</span> <span class="nav-text">追踪所有的实例化过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="nav-number">21.4.</span> <span class="nav-text">计算完整性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%92%8C%E9%80%92%E5%BD%92%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="nav-number">21.5.</span> <span class="nav-text">递归实例化和递归模板参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E5%80%BC%E8%BF%98%E6%98%AF%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F"><span class="nav-number">21.6.</span> <span class="nav-text">枚举值还是静态常量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%97%E8%A1%A8%EF%BC%88Typelists%EF%BC%89"><span class="nav-number">22.</span> <span class="nav-text">类型列表（Typelists）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%97%E8%A1%A8%E5%89%96%E6%9E%90"><span class="nav-number">22.1.</span> <span class="nav-text">类型列表剖析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%97%E8%A1%A8%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">22.2.</span> <span class="nav-text">类型列表的算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%EF%BC%88Indexing%EF%BC%89"><span class="nav-number">22.2.1.</span> <span class="nav-text">索引（Indexing）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E6%9C%80%E4%BD%B3%E5%8C%B9%E9%85%8D"><span class="nav-number">22.2.2.</span> <span class="nav-text">寻找最佳匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E7%B1%BB%E5%9E%8B%E7%B1%BB%E8%A1%A8%E4%B8%AD%E8%BF%BD%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="nav-number">22.2.3.</span> <span class="nav-text">向类型类表中追加元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%97%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC"><span class="nav-number">22.2.4.</span> <span class="nav-text">类型列表的反转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%97%E8%A1%A8%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">22.2.5.</span> <span class="nav-text">类型列表的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%97%E8%A1%A8%E7%9A%84%E7%B4%AF%E5%8A%A0%EF%BC%88Accumulating-Typelists%EF%BC%89"><span class="nav-number">22.2.6.</span> <span class="nav-text">类型列表的累加（Accumulating Typelists）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">22.2.7.</span> <span class="nav-text">插入排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E7%B1%BB%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%88%97%E8%A1%A8%EF%BC%88Nontype-Typelists%EF%BC%89"><span class="nav-number">22.3.</span> <span class="nav-text">非类型类型列表（Nontype Typelists）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E6%8E%A8%E6%96%AD%E7%9A%84%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-number">22.3.1.</span> <span class="nav-text">可推断的非类型参数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%83%E7%BB%84"><span class="nav-number">23.</span> <span class="nav-text">元组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%85%83%E7%BB%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">23.1.</span> <span class="nav-text">基本的元组设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%EF%BC%88Storage%EF%BC%89"><span class="nav-number">23.1.1.</span> <span class="nav-text">存储（Storage）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0"><span class="nav-number">23.1.2.</span> <span class="nav-text">构造</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E5%85%83%E7%BB%84%E6%93%8D%E4%BD%9C"><span class="nav-number">23.2.</span> <span class="nav-text">基础元组操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83"><span class="nav-number">23.2.1.</span> <span class="nav-text">比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA"><span class="nav-number">23.2.2.</span> <span class="nav-text">输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%83%E7%BB%84%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">23.3.</span> <span class="nav-text">元组的算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E5%85%83%E7%BB%84%E7%94%A8%E4%BD%9C%E7%B1%BB%E5%9E%8B%E5%88%97%E8%A1%A8"><span class="nav-number">23.3.1.</span> <span class="nav-text">将元组用作类型列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E4%BB%A5%E5%8F%8A%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">23.3.2.</span> <span class="nav-text">添加以及删除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%BB%84%E7%9A%84%E5%8F%8D%E8%BD%AC"><span class="nav-number">23.3.3.</span> <span class="nav-text">元组的反转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%88%97%E8%A1%A8"><span class="nav-number">23.3.4.</span> <span class="nav-text">索引列表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%83%E7%BB%84%E7%9A%84%E5%B1%95%E5%BC%80"><span class="nav-number">23.4.</span> <span class="nav-text">元组的展开</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%83%E7%BB%84%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">23.5.</span> <span class="nav-text">元组的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%BB%84%E5%92%8CEBCO"><span class="nav-number">23.5.1.</span> <span class="nav-text">元组和EBCO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E7%9A%84get"><span class="nav-number">23.5.2.</span> <span class="nav-text">常数时间的get()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%83%E7%BB%84%E4%B8%8B%E6%A0%87"><span class="nav-number">23.6.</span> <span class="nav-text">元组下标</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
