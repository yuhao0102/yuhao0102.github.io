<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zn-ch">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++," />










<meta name="description" content="第一章 容器第一条： 慎重选择容器类型C++所提供的容器类型有如下几种：  标准STL序列容器 vector string deque list 标准STL关联容器 set multiset map multimap 非标准序列容器 slist rope 非标准关联容器 hash_set hash_multiset hash_map hash_multimap vector作为string的替代">
<meta property="og:type" content="article">
<meta property="og:title" content="《Effective STL》读书笔记">
<meta property="og:url" content="http://yoursite.com/2020/08/28/Effective_STL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="第一章 容器第一条： 慎重选择容器类型C++所提供的容器类型有如下几种：  标准STL序列容器 vector string deque list 标准STL关联容器 set multiset map multimap 非标准序列容器 slist rope 非标准关联容器 hash_set hash_multiset hash_map hash_multimap vector作为string的替代">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/1598597500.jpg">
<meta property="og:image" content="http://yoursite.com/img/1598598408.jpg">
<meta property="og:image" content="http://yoursite.com/img/1598598451.jpg">
<meta property="og:image" content="http://yoursite.com/img/1598598481.jpg">
<meta property="og:image" content="http://yoursite.com/img/1598598601.jpg">
<meta property="og:image" content="http://yoursite.com/img/1598599694.jpg">
<meta property="og:image" content="http://yoursite.com/img/201108201329543528.png">
<meta property="og:image" content="http://yoursite.com/img/1598600168.jpg">
<meta property="og:image" content="http://yoursite.com/img/20110912122959468.gif">
<meta property="og:image" content="http://yoursite.com/img/1598600816.jpg">
<meta property="article:published_time" content="2020-08-28T06:47:00.000Z">
<meta property="article:modified_time" content="2020-08-28T07:13:18.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/1598597500.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/08/28/Effective_STL读书笔记/"/>





  <title>《Effective STL》读书笔记 | Hao Yu's blog</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/28/Effective_STL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《Effective STL》读书笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-28T14:47:00+08:00">
                2020-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第一章-容器"><a href="#第一章-容器" class="headerlink" title="第一章 容器"></a>第一章 容器</h1><h2 id="第一条：-慎重选择容器类型"><a href="#第一条：-慎重选择容器类型" class="headerlink" title="第一条： 慎重选择容器类型"></a>第一条： 慎重选择容器类型</h2><p>C++所提供的容器类型有如下几种：</p>
<ul>
<li>标准STL序列容器 vector string deque list</li>
<li>标准STL关联容器 set multiset map multimap</li>
<li>非标准序列容器 slist rope</li>
<li>非标准关联容器 hash_set hash_multiset hash_map hash_multimap</li>
<li>vector<char>作为string的替代</li>
<li>vector作为标准关联容器的替代</li>
<li>非标准的STL容器 array bitset valarray stack queue priority_queue</li>
</ul>
<p>标准容器中的<code>vector</code> <code>string</code>和<code>list</code>比较熟悉。<code>deque</code>是<code>double ended queue</code>,提供了与<code>vector</code>一样的随机访问功能，但同时对头尾元素的增删操作提供了优化。<code>set</code>和<code>multiset</code>中的数据都是顺序排列的，数据值本身就是键值，<code>set</code>中的数据必须唯一而<code>multiset</code>没有这样的限制。<code>map</code>和<code>multimap</code>中的数据对按照键值顺序排列，<code>map</code>中不允许出现重复的key，而<code>multimap</code>中可以用相同的key对应不同的value。<code>slist</code>是<code>single linked list</code>，与STL中标准的<code>list</code>之间的区别就在于<code>slist</code>的iterator是单向的，而<code>list</code>的iterator是双向的。<code>rope</code>用于处理大规模的字符串。<code>hash_set</code>，<code>hash_multiset</code>，<code>hash_map</code>，<code>hash_multimap</code>利用hash算法对相对应的关联容器进行了优化。<code>bitset</code>是专门用来存储bit的容器。<code>valarray</code>主要用于对一系列的数字进行高速运算。<code>priority_queue</code>类似于heap,可以高效的获取最高priority的元素。</p>
<ul>
<li>连续内存容器，动态申请一块或多块内存，每块内存中存储多个容器中的元素，当发生插入或删除操作时，要对该内存中的其他元素进行新移动操作，这会降低效率。vector，string，rope都是连续内存容器。</li>
<li>基于节点的容器，为容器中的每一元素申请单独的内存，元素中有指针指向其他的元素，插入和删除的操作只需要改变指针的指向。缺点在于占用内存相对连续内存容器较大。list, slist, 关联容器以及hash容器都是基于节点的容器。</li>
</ul>
<p><img src="/img/1598597500.jpg" alt=""></p>
<h2 id="第二条：-不要编写试图独立于容器的代码"><a href="#第二条：-不要编写试图独立于容器的代码" class="headerlink" title="第二条： 不要编写试图独立于容器的代码"></a>第二条： 不要编写试图独立于容器的代码</h2><ul>
<li>数组被泛化为以其所包含对象的类型为参数的容器</li>
<li>函数被泛化为以其使用的迭代器的类型为参数的算法</li>
<li>指针被泛化为以其所指向的对象的类型为参数的迭代器</li>
</ul>
<p>考虑到以后可能会使用其他的容器替换现有的容器，为了使修改的部分最小化，最好采用如下的方式<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SpecialAllocator&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;Widget, SpecialAllocator&lt;Widget&gt;&gt; WidgetContainer;</span><br><span class="line"><span class="keyword">typedef</span> WidgetContainer::iterator WCIterator;</span><br><span class="line"></span><br><span class="line">WidgetContainer wc;</span><br><span class="line">Widget widget;</span><br><span class="line">...</span><br><span class="line">WCIterator i = <span class="built_in">find</span>(wc.<span class="built_in">begin</span>(), wc.<span class="built_in">end</span>(), widget);</span><br></pre></td></tr></table></figure></p>
<p>使用Class将自定义的容器封装起来，可以更好的实现修改部分最小化，同时达到了安全修改的目的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomizedContainer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> vector&lt;Widget&gt; InternalContainer;</span><br><span class="line">    <span class="keyword">typedef</span> InternalContainer::Iterator ICIterator;</span><br><span class="line">    </span><br><span class="line">    InternalContainer container;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="第三条：-确保容器内对象的拷贝正确而高效"><a href="#第三条：-确保容器内对象的拷贝正确而高效" class="headerlink" title="第三条： 确保容器内对象的拷贝正确而高效"></a>第三条： 确保容器内对象的拷贝正确而高效</h2><p>STL的工作方式是Copy In, Copy Out，也就是说在STL容器中的插入对象和读取对象，使用的都是对象的拷贝。在存放基类对象的容器中存放子类的对象，当容器内的对象发生拷贝时，会发生截断(剥离 slicing)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Widget&gt; vw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWidget</span> : <span class="keyword">public</span> Widget</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SpecialWidget sw;</span><br><span class="line">vw.<span class="built_in">push_back</span>(sw);</span><br></pre></td></tr></table></figure>
<p>正确的方法是使容器包含指针而非对象。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Widget*&gt; vw;</span><br><span class="line"></span><br><span class="line">class SpecialWidget : public Widget</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SpecialWidget sw;</span><br><span class="line">vw.push_back(&amp;sw);</span><br></pre></td></tr></table></figure><br>容器与数组在数据拷贝方面的对比：</p>
<p>当创建一个包含某类型对象的一个数组的时候，总是调用了次数等于数组长度的该类型的构造函数。尽管这个初始值之后会被覆盖掉<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget w[maxNumWidgets]; <span class="comment">//maxNumWidgets 次的Widget构造函数</span></span><br></pre></td></tr></table></figure></p>
<p>如果使用vecor，效率会有所提升。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;widget&gt; w;     <span class="comment">//既不调用构造函数也不调用拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;widget&gt; <span class="title">w</span><span class="params">(<span class="number">5</span>)</span></span>;  <span class="comment">//1次构造 5次拷贝构造</span></span><br><span class="line"></span><br><span class="line">vector&lt;widget&gt; w;     <span class="comment">//既不调用构造函数也不调用拷贝构造函数</span></span><br><span class="line">w.<span class="built_in">reserve</span>(<span class="number">5</span>);         <span class="comment">//既不调用构造函数也不调用拷贝构造函数</span></span><br><span class="line"><span class="function">vector&lt;widget&gt; <span class="title">w</span><span class="params">(<span class="number">5</span>)</span></span>;  <span class="comment">//1次构造 5次拷贝构造</span></span><br><span class="line">w.<span class="built_in">reserve</span>(<span class="number">6</span>);         <span class="comment">//需要移动位置，调用5次拷贝构造</span></span><br></pre></td></tr></table></figure></p>
<h2 id="第四条：-调用empty-而不是检查size-是否为0"><a href="#第四条：-调用empty-而不是检查size-是否为0" class="headerlink" title="第四条： 调用empty()而不是检查size()是否为0"></a>第四条： 调用empty()而不是检查size()是否为0</h2><p>empty()对于所有标准容器都是常数时间，而对list操作，size()耗费线性时间。list具有常数时间的Splice操作，如果在两个list之间做链接的时候需要记录被链接到当前list的节点的个数，那么Splice操作将会变成线性时间。对于list而言，用户对Splice效率的要求高于取得list长度的要求，所以list的size()需要耗费线性的时间去遍历整个list。所以，调用empty()是判断list是否为空的最高效方法。</p>
<h2 id="第五条：-区间成员函数优先于与之对应的单元素成员函数"><a href="#第五条：-区间成员函数优先于与之对应的单元素成员函数" class="headerlink" title="第五条： 区间成员函数优先于与之对应的单元素成员函数"></a>第五条： 区间成员函数优先于与之对应的单元素成员函数</h2><p>区间成员函数在效率方面的开销要小于循环调用单元素的成员函数，以insert为例</p>
<ul>
<li>避免不必要的函数调用</li>
<li>避免频繁的元素移动</li>
<li>避免多次进行内存分配</li>
</ul>
<p>区间创建<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container::<span class="built_in">container</span>(InputIterator begin, InputIterator end);</span><br></pre></td></tr></table></figure></p>
<p>区间插入<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">container::insert</span><span class="params">(Iterator position, InputIterator begin, InputIterator end)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">associatedContainer::insert</span><span class="params">(InputIterator begin, InputIterator end)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>区间删除<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator <span class="title">container::erase</span><span class="params">(Iterator begin, Interator end)</span></span>;</span><br><span class="line"><span class="type">void</span> associatedContainer:<span class="built_in">erase</span>(Iterator begin, Iterator end);</span><br></pre></td></tr></table></figure></p>
<p>区间赋值<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">container::assign</span><span class="params">(InputIterator begin, InputIterator end)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="第六条：当心C-编译器最烦人的分析机制"><a href="#第六条：当心C-编译器最烦人的分析机制" class="headerlink" title="第六条：当心C++编译器最烦人的分析机制"></a>第六条：当心C++编译器最烦人的分析机制</h2><p>C++会尽可能的将一条语句解释为函数声明。下列语句都声明了一个函数返回值为int类型的函数f，其参数是double类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">double</span>(d))</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">double</span> d)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">double</span>)</span></span>; 　</span><br></pre></td></tr></table></figure><br>下列语句都声明了一个返回值为int类型的函数g，它的参数是返回值为double类型且无参的函数指针<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">double</span>(*pf)())</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">double</span> pf())</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">double</span> ())</span></span>; <span class="comment">//注意与int g(double (f))的区别</span></span><br><span class="line">```　　</span><br><span class="line"></span><br><span class="line">对于如下语句，编译器会做出这样的解释：声明了一个返回值为`list&lt;<span class="type">int</span>&gt;`的函数data，该函数有两个参数，一个是`istream_iterator&lt;<span class="type">int</span>&gt;`类型的变量，另一个是返回值为`istream_iterator&lt;<span class="type">int</span>&gt;`类型的无参函数指针。</span><br><span class="line">```C++</span><br><span class="line"><span class="function">ifstream <span class="title">dataFile</span><span class="params">(<span class="string">&quot;ints.dat&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(istream_iterator&lt;<span class="type">int</span>&gt;(dataFile),istream_iterator&lt;<span class="type">int</span>&gt;())</span></span>;</span><br></pre></td></tr></table></figure><br>如果希望构造一个<code>list&lt;int&gt;</code>类型的变量data，最好的方式是使用命名的迭代器。尽管这与通常的STL风格相违背，但是消除了编译器的二义性而且增强了程序的可读性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">dataFile</span><span class="params">(<span class="string">&quot;ints.dat&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">istream_iterator <span class="title">dataBegin</span><span class="params">(dataFile)</span></span>;</span><br><span class="line">istream_iterator dataEnd;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(dataBegin,dataEnd)</span></span>;　</span><br></pre></td></tr></table></figure></p>
<h2 id="第七条：如果容器中包含了通过new操作创建的指针，切记在容器对象析构前将指针delete掉"><a href="#第七条：如果容器中包含了通过new操作创建的指针，切记在容器对象析构前将指针delete掉" class="headerlink" title="第七条：如果容器中包含了通过new操作创建的指针，切记在容器对象析构前将指针delete掉"></a>第七条：如果容器中包含了通过new操作创建的指针，切记在容器对象析构前将指针delete掉</h2><p>STL容器在析构之前，会将其所包含的对象进行析构。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">widget</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">doSth</span>()</span><br><span class="line">&#123;</span><br><span class="line">    widget w; <span class="comment">//一次构造函数</span></span><br><span class="line">    vector&lt;widget&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(w); <span class="comment">//一次拷贝构造函数</span></span><br><span class="line">&#125; <span class="comment">// 两次析构函数</span></span><br></pre></td></tr></table></figure></p>
<p>但如果容器中包含的是指针的话，一旦没有特别将指针delete掉将会发生内存泄漏<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">widget</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">doSth</span>()</span><br><span class="line">&#123;</span><br><span class="line">    widget* w = <span class="keyword">new</span> <span class="built_in">widget</span>();</span><br><span class="line">    vector&lt;widget*&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(w); </span><br><span class="line">&#125; <span class="comment">// memory leak!!!</span></span><br></pre></td></tr></table></figure></p>
<p>最为方便并且能够保证异常安全的做法是将容器所保存的对象定义为带有引用计数的智能指针<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">widget</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">doSth</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;widget&gt; <span class="title">w</span><span class="params">(<span class="keyword">new</span> widget())</span></span>; <span class="comment">//构造函数一次</span></span><br><span class="line">    vector&lt;shared_ptr&lt;widget&gt;&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(w); </span><br><span class="line">&#125; <span class="comment">//析构函数一次 没有内存泄漏</span></span><br></pre></td></tr></table></figure></p>
<h2 id="第八条：切勿创建包含auto-ptr对象的容器"><a href="#第八条：切勿创建包含auto-ptr对象的容器" class="headerlink" title="第八条：切勿创建包含auto_ptr对象的容器"></a>第八条：切勿创建包含auto_ptr对象的容器</h2><p>由于auto_ptr对于其”裸指针”必须具有独占性，当将一个auto_ptr的指针赋给另一个auto_ptr时，其值将被置空。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>; <span class="comment">// p1 = 1</span></span><br><span class="line"><span class="function">auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">2</span>))</span></span>; <span class="comment">// p2 = 2</span></span><br><span class="line"></span><br><span class="line">p2 = p1; <span class="comment">// p2 = 1  p1 = emtpy;</span></span><br></pre></td></tr></table></figure><br>第三条提到STL容器中的插入对象和读取对象，使用的都是对象的拷贝，并且基于STL容器的算法也通常需要进行对象的copy，所以，创建包含auto_ptr的容器是不明智的。</p>
<h2 id="第九条：慎重选择删除元素的方法"><a href="#第九条：慎重选择删除元素的方法" class="headerlink" title="第九条：慎重选择删除元素的方法"></a>第九条：慎重选择删除元素的方法</h2><p>要删除容器中特定值的所有对象<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于vector、string、deque 使用erase-remove方法</span></span><br><span class="line">container.<span class="built_in">erase</span>(<span class="built_in">remove</span>(container.<span class="built_in">begin</span>(),container.<span class="built_in">end</span>(),value),container.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于list 使用remove方法</span></span><br><span class="line">list.<span class="built_in">remove</span>(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于标准关联容器 使用erase方法</span></span><br><span class="line">associatedContainer.<span class="built_in">erase</span>(value);</span><br></pre></td></tr></table></figure></p>
<p>要删除容器中满足特定条件的所有对象<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">condition</span><span class="params">(<span class="type">int</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于vector、string、deque 使用erase-remove_if方法</span></span><br><span class="line">container.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(container.<span class="built_in">begin</span>(),container.<span class="built_in">end</span>(),condition),container.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于list 使用remove_if方法</span></span><br><span class="line">list.<span class="built_in">remove_if</span>(condition);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于标准关联容器 第一种方法是结合remove_copy_if和swap方法</span></span><br><span class="line">associatedContainer.<span class="built_in">remove_copy_if</span>(associatedContainer.<span class="built_in">begin</span>(),</span><br><span class="line">                                   associatedContainer.<span class="built_in">end</span>(),</span><br><span class="line">                                   <span class="built_in">insert</span>(tempAssocContainer,tempAssocContainer.<span class="built_in">end</span>()),</span><br><span class="line">                                   condition);</span><br><span class="line"></span><br><span class="line"><span class="comment">//另外一种方法是遍历容器内容并在erase元素之前将迭代器进行后缀递增</span></span><br><span class="line"><span class="keyword">for</span>(assocIt = associatedContainer.<span class="built_in">begin</span>(); assocIt != associatedContainer.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">condition</span>(*assoIt))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">///当关联容器中的一个元素被删除掉时，所有指向该元素的迭代器都被设为无效，所以要提前将迭代器向后递增</span></span><br><span class="line">        associatedContainer.<span class="built_in">erase</span>(assoIt++); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        assocIt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果除了在删除容器内对象的同时还需要进行额外的操作时<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">condition</span><span class="params">(<span class="type">int</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dosth</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于标准序列容器，循环遍历容器内容，利用erase的返回值更新迭代器</span></span><br><span class="line"><span class="keyword">for</span>(containerIt = container.<span class="built_in">begin</span>(); containerIt != container.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">condition</span>(*containerIt))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">doSth</span>();</span><br><span class="line">        <span class="comment">//当标准容器中的一个元素被删除掉时，所有指向该元素以及该元素之后的迭代器都被设为无效，所以要利用erase的返回值</span></span><br><span class="line">        containerIt = container.<span class="built_in">erase</span>(containerIt++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        containerIt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于标准关联容器，循环遍历容器内容，并在erase之前后缀递增迭代器</span></span><br><span class="line"><span class="keyword">for</span>(assocIt = associatedContainer.<span class="built_in">begin</span>(); assocIt != associatedContainer.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">condition</span>(*assoIt))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dosth</span>();</span><br><span class="line">        associatedContainer.<span class="built_in">erase</span>(assoIt++); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        assocIt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我觉得第三种情况下可以用第二种情况的实现代替，我们需要做的仅是将额外做的事情和判断条件包装在一个函数内，并用这个函数替代原有的判断条件。　<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">condition_doSth</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> ret = <span class="built_in">condition</span>(i);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">doSth</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第十条：了解分配子的约定和限制"><a href="#第十条：了解分配子的约定和限制" class="headerlink" title="第十条：了解分配子的约定和限制"></a>第十条：了解分配子的约定和限制</h2><p>如果需要编写自定义的分配子，有以下几点需要注意</p>
<ul>
<li>当分配子是一个模板，模板参数T代表你为其分配内存的对象的类型</li>
<li>提供类型定义pointer和reference，始终让pointer为T*而reference为T&amp;</li>
<li>不要让分配子拥有随对象而不同的状态，通常，分配子不应该有非静态数据成员</li>
<li>传递给allocator的是要创建元素的个数而不是申请的字节数，该函数返回T*，尽管此时还没有T对象构造出来</li>
<li>必须提供rebind模板，因为标准容器依赖于该模板</li>
</ul>
<h2 id="第十一条：理解自定义分配子的合理用法"><a href="#第十一条：理解自定义分配子的合理用法" class="headerlink" title="第十一条：理解自定义分配子的合理用法"></a>第十一条：理解自定义分配子的合理用法</h2><p>如果需要在共享的内存空间中手动的管理内存分配，下列代码提供了一定的参考<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户自定义的管理共享内存的malloc和free</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mallocShared</span><span class="params">(<span class="type">size_t</span> bytesNeeded)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">freeShared</span><span class="params">(<span class="type">void</span>* ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sharedMemoryAllocator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function">point <span class="title">allocator</span><span class="params">(size_type numObjects, <span class="type">const</span> <span class="type">void</span>* localityHint=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;pointer&gt;(<span class="built_in">mallocShared</span>(numObjects*<span class="built_in">sizeof</span>(T)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(pointer ptrMemory, size_type numObjects)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">freeShared</span>(ptrMemory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　<br>如果不仅仅是将容器的元素放在共享内存，而且要将容器对象本身也放在共享内存中，参考如下代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* ptrVecMemory = <span class="built_in">mallocShared</span>(<span class="built_in">sizeof</span>(SharedDoubleVec));</span><br><span class="line">SharedDoubleVec* sharedVec = <span class="built_in">new</span>(ptrVecMemory) SharedDoubleVec;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">sharedVec-&gt;~<span class="built_in">SharedDoubleVec</span>();</span><br><span class="line"><span class="built_in">freeShared</span>(sharedVec);</span><br></pre></td></tr></table></figure></p>
<h2 id="第十二条：切勿对STL容器的线程安全性有不切实际的依赖"><a href="#第十二条：切勿对STL容器的线程安全性有不切实际的依赖" class="headerlink" title="第十二条：切勿对STL容器的线程安全性有不切实际的依赖"></a>第十二条：切勿对STL容器的线程安全性有不切实际的依赖</h2><p>对于STL容器的多线程读是安全的，对于多个不同的STL容器，采用面向对象的方式对STL容器进行加锁和解锁<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lock</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Lock</span>(<span class="type">const</span> Container&amp; container):<span class="built_in">c</span>(container)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getMutexFor</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Lock</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">releaseMutex</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container&amp; c;</span><br><span class="line">&#125;,</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    Lock&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">lock</span>(v); <span class="comment">//构造lock,加锁v</span></span><br><span class="line">    <span class="built_in">doSthSync</span>(v); <span class="comment">//对v进行多线程的操作</span></span><br><span class="line">&#125; <span class="comment">//析构lock,解锁v</span></span><br></pre></td></tr></table></figure></p>
<h1 id="vector和string"><a href="#vector和string" class="headerlink" title="vector和string"></a>vector和string</h1><h2 id="第十三条：-vector和string优先于动态分配的数组"><a href="#第十三条：-vector和string优先于动态分配的数组" class="headerlink" title="第十三条： vector和string优先于动态分配的数组"></a>第十三条： vector和string优先于动态分配的数组</h2><p>如果使用new来动态分配内存，使用者必须承担以下的责任</p>
<ul>
<li>确保之后调用delete将内存释放</li>
<li>确保使用的是正确的delete形式，对于单个对象要用delete，对于数组对象需要用delete[]</li>
<li>确保对于一个对象只delete一次</li>
</ul>
<p>vector、string自动管理其所包含元素的构造与析构，并有一系列的STL算法支持，同时vector也能够保证和老代码的兼容。使用了引用计数的string可以避免不必要的内存分配和字符串拷贝(COW- copy on write)，但是在多线程环境里，对这个string进行线程同步的开销远大于COW的开销。此时，可以考虑使用<code>vector&lt;char&gt;</code>或动态数组。</p>
<h2 id="第十四条：-使用reserve来避免不必要的内存分配"><a href="#第十四条：-使用reserve来避免不必要的内存分配" class="headerlink" title="第十四条： 使用reserve来避免不必要的内存分配"></a>第十四条： 使用reserve来避免不必要的内存分配</h2><p>对于STL容器而言，当他们的容量不足以放下一个新元素的时候，会自动增长以便容纳新的数据。(只要不超过max_size)</p>
<ul>
<li>分配一块儿原内存大小数倍的新内存，对于vector和string而言，通常是两倍。</li>
<li>将原来容器中的元素拷贝到新内存中</li>
<li>析构旧内存中的对象</li>
<li>释放旧内存</li>
</ul>
<p>reserve以及与resever相关的几个函数</p>
<ul>
<li><code>size()</code> 容器中现有的元素的个数</li>
<li><code>capacity()</code> 容器在不重新分配内存的情况下可容纳元素的总个数</li>
<li><code>resize(Container::size_type n)</code> 将容器的size强制改变为n  <ul>
<li><code>n&gt;size</code> 将现有容器中的元素拷贝到新内存，并将空余部分用默认构造的新函数填满</li>
<li><code>n&lt;size</code> 将尾部的元素全部析构掉</li>
</ul>
</li>
<li><code>reserve(Container::size_type n)</code>将容器的size改变至少为n<ul>
<li><code>n&gt;size</code> 将现有容器中的元素拷贝到新内存，多余部分的内存仍然空置</li>
<li><code>n&lt;size</code> 对容器没有影响</li>
</ul>
</li>
</ul>
<p>通常有两种方式使用reserve避免不必要的内存分配</p>
<ul>
<li>预测大致所需的内存，并在构造容器之后就调用reserve预留内存</li>
<li>先用reserve分配足够大的内存，将所有元素都加入到容器之后再去除多余内存。</li>
</ul>
<h2 id="第十五条：-string实现的多样性"><a href="#第十五条：-string实现的多样性" class="headerlink" title="第十五条： string实现的多样性"></a>第十五条： string实现的多样性</h2><p>实现A  在该实现中，包含默认Allocator的string是一个指针大小的4倍。对于有自定义的Allocator的string，他的大小将更大<br><img src="/img/1598598408.jpg" alt=""></p>
<p>实现B 在使用默认的Allocator的情况下，string对象的大小与指针的大小相等。当使用自定义的Allocator时，string对象将加上对应的自定义Allocator的对象。Other部分用来在多线程条件下进行同步控制，其大小通常为指针大小的6倍。<br><img src="/img/1598598451.jpg" alt=""></p>
<p>实现C string对象的大小总与指针大小相同，没有对单个对象的Allocator的支持。X包含一些与值的可共享性相关的数据<br><img src="/img/1598598481.jpg" alt=""></p>
<p>实现D 对于使用默认Allocator的string，其大小等于指针大小的7倍。不使用引用计数，string内部包含一块内存可容纳15个字符的字符串。<br><img src="/img/1598598601.jpg" alt=""></p>
<p>总结string的多种实现</p>
<ul>
<li>string的值可能会被引用计数(实现A 实现B 实现C)也可能不会(实现D)</li>
<li>string对象的大小可能在char*指针的1倍到7倍之间</li>
<li>创建一个新的字符串值可能需要0次(实现D capacity&lt;=15)、1次(实现A、实现C、实现D capacity&gt;15)或2次(实现B)动态的内存分配</li>
<li>string对象可能共享(实现B、实现C)也可能不共享(实现A 实现D)其大小和容量信息</li>
<li>string可能支持(实现A 实现B 实现D)也可能不支持(实现C)单个对象的分配子</li>
<li>不同的实现对字符内存的最小分配单位有不同的策略</li>
</ul>
<h2 id="第十六条：-了解如何把vector和string数据传给旧的API"><a href="#第十六条：-了解如何把vector和string数据传给旧的API" class="headerlink" title="第十六条： 了解如何把vector和string数据传给旧的API"></a>第十六条： 了解如何把vector和string数据传给旧的API</h2><p>将vector传递给接受数组指针的函数，要注意vector为空的情况。迭代器并不等价于指针，所以不要将迭代器传递给参数为指针的函数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void foo(const int* ptr, size_t size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">...</span><br><span class="line">foo(v.empty() ? NULL : &amp;v[0], v.size());</span><br></pre></td></tr></table></figure></p>
<p>将string传递给接受字符串指针的函数。该方法还适用于s为空或包含”\0”的情况<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">foo</span>(s.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure></p>
<p>使用初始化数组的方式初始化vector<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向数组中填入数据</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fillArray</span><span class="params">(<span class="type">int</span>* ptr, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> maxSize = <span class="number">10</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(maxSize)</span></span>;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="built_in">fillArray</span>(&amp;v[<span class="number">0</span>],v.<span class="built_in">size</span>()));</span><br></pre></td></tr></table></figure><br>借助vector与数组内存布局的一致性，我们可以使用vector作为中介，将数组中的内容拷贝到其他STL容器之中或将其他STL容器中的内容拷贝到数组中<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向数组中填入数据</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fillArray</span><span class="params">(<span class="type">int</span>* ptr, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(maxSize)</span></span>;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="built_in">fillArray</span>(&amp;v[<span class="number">0</span>],v.<span class="built_in">size</span>()));</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(v.begin(),v.end())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* ptr, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(l.begin(),l.end())</span></span>;</span><br><span class="line"><span class="built_in">foo</span>(v.<span class="built_in">empty</span>()? <span class="literal">NULL</span> : &amp;v[<span class="number">0</span>],v.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure></p>
<h2 id="第十七条：-使用swap去除多余容量"><a href="#第十七条：-使用swap去除多余容量" class="headerlink" title="第十七条： 使用swap去除多余容量"></a>第十七条： 使用swap去除多余容量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v);</span><br></pre></td></tr></table></figure>
<p><code>vector&lt;int&gt;(v)</code>使用v创建一个临时变量，v中空余的内存将不会被拷贝到这个临时变量的空间中，再利用swap将这个临时变量与v进行交换，相当于去除掉了v中的多余内存。</p>
<p>由于STL实现的多样性，swap的方式并不能保证去掉所有的多余容量，但它将尽量将空间压缩到其实现的最小程度。利用swap的交换容器的值的好处在于可以保证容器中元素的迭代器、指针和引用在交换后依然有效。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator i = v1.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v1)</span></span>;</span><br><span class="line">v2.<span class="built_in">swap</span>(v1);</span><br><span class="line">cout&lt;&lt;*i&lt;&lt;endl;  <span class="comment">//output 1  iterator指向v2的begin</span></span><br></pre></td></tr></table></figure>
<p>但是在使用基于临时变量的swap要当心iterator失效的情况　　<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator i = v1.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v1).<span class="built_in">swap</span>(v1);</span><br><span class="line">cout&lt;&lt;*i&lt;&lt;endl;  <span class="comment">//crash here</span></span><br></pre></td></tr></table></figure><br>原因在于第5行构造的临时变量在该行结束后就被析构了。</p>
<h2 id="第十八条：-避免使用vector"><a href="#第十八条：-避免使用vector" class="headerlink" title="第十八条： 避免使用vector"></a>第十八条： 避免使用vector<bool></h2><p><code>vector&lt;bool&gt;</code>并不是一个真正的容器，也并不存储真正的bool类型，为了节省空间，它存储的是bool的紧凑表示，通常是一个bit。<br>由于指向单个bit的指针或引用都是不被允许的，<code>vector&lt;bool&gt;</code>采用代理对象模拟指针指向单个bit。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">bool</span>&gt; v;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> *pb = &amp;v[<span class="number">0</span>]; <span class="comment">// compile error</span></span><br><span class="line">vector&lt;<span class="type">bool</span>&gt;::reference *pr = &amp;v[<span class="number">0</span>];  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure></p>
<p>可以考虑两种方式替代<code>vector&lt;bool&gt;</code></p>
<ul>
<li><code>deque&lt;bool&gt;</code>但是要注意deque的内存布局与数组并不一致</li>
<li><code>bitset</code>不是STL容器所以不支持迭代器，其大小在编译器就已经确定，bool也是紧凑的存储在内存中。</li>
</ul>
<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><h2 id="第十九条：-理解相等-equality-和等价-equivalence-的区别"><a href="#第十九条：-理解相等-equality-和等价-equivalence-的区别" class="headerlink" title="第十九条： 理解相等(equality)和等价(equivalence)的区别　　"></a>第十九条： 理解相等(equality)和等价(equivalence)的区别　　</h2><p>相等的概念是基于<code>operator==</code>的，也就是取决于<code>operator==</code>的实现。等价关系是基于元素在容器中的排列顺序的，如果两个元素谁也不能排列在另一个的前面，那么这两个元素是等价的。标准关联容器需要保证内部元素的有序排列，所以标准容器的实现是基于等价的。标准关联容器的使用者要为所使用的容器指定一个比较函数(默认为less)，用来决定元素的排列顺序。</p>
<p>非成员的函数(通常为STL算法)大部分是基于相等的。下列代码可能会返回不同的结果<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CIStringCompare</span>:</span><br><span class="line">    <span class="keyword">public</span> binary_function&lt;string, string, <span class="type">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp; lhs,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> string&amp; rhs)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">stricmp</span>(lhs.<span class="built_in">c_str</span>(),rhs.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;string, CIStringCompare&gt; s; <span class="comment">//set的第二个参数是类型而不是函数</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">find</span>(<span class="string">&quot;a&quot;</span>) != s.<span class="built_in">end</span>())  <span class="comment">//true</span></span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),<span class="string">&quot;a&quot;</span>) != s.<span class="built_in">end</span>())   <span class="comment">//false</span></span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第二十条：-为包含指针的关联容器指定比较类型"><a href="#第二十条：-为包含指针的关联容器指定比较类型" class="headerlink" title="第二十条： 为包含指针的关联容器指定比较类型　　"></a>第二十条： 为包含指针的关联容器指定比较类型　　</h2><p>下面的程序通常不会得到用户期望的结果。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string*&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;C&quot;</span>));</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;B&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(set&lt;string*&gt;::iterator i = s.<span class="built_in">begin</span>(); i != s.<span class="built_in">end</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;**i;  <span class="comment">//输出一定会是ABC么？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为set中存储的是指针类型，而它也仅仅会对指针所处的位置大小进行排序，与指针所指向的内容无关。当关联容器中存储指针或迭代器类型的时候，往往需要用户自定义一个比较函数来替换默认的比较函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomedStringCompare</span>:</span><br><span class="line">    <span class="keyword">public</span> binary_function&lt;string*, string*, <span class="type">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string* lhs,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> string* rhs)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *lhs &lt; *rhs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;string*,CustomedStringCompare&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;C&quot;</span>));</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;B&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(set&lt;string*, CustomedStringCompare&gt;::iterator i = s.<span class="built_in">begin</span>(); i != s.<span class="built_in">end</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;**i; <span class="comment">//ABC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　<br>可以更进一步的实现一个通用的解引用比较类型<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DerefenceLess</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> PtrType&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(PtrType ptr1, PtrType ptr2)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr1 &lt; *ptr2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;string*,DerefenceLess&gt; s;</span><br></pre></td></tr></table></figure></p>
<p>如果用less_equal来实现关联容器中的比较函数,那么对于连续插入两个相等的元素则有<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>,less_equal&lt;<span class="type">int</span>&gt;&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><br>因为关联容器是依据等价来实现的,所以判断两个1是否等价!<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!(<span class="number">1</span>&lt;=<span class="number">1</span>) &amp;&amp; !(<span class="number">1</span>&lt;=<span class="number">1</span>) <span class="comment">// false 不等价 </span></span><br></pre></td></tr></table></figure><br>所以这两个1都被存储在set中,从而破坏了set中不能有重复数据的约定.　</p>
<p>比较函数的返回值表明元素按照该函数定义的顺序排列,一个值是否在另一个之前。相等的值不会有前后顺序，所以，对于相等的值，比较函数应该返回false。</p>
<p>对于multiset又如何呢？multiset应该可以存储两个相等的元素吧？ 答案也是否定的。对于下面的操作:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">multiset&lt;<span class="type">int</span>,less_equal&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">pair&lt;multiset&lt;<span class="type">int</span>,less_equal&gt;::iterator,multiset&lt;<span class="type">int</span>,less_equal&gt;::iterator&gt; ret = s.<span class="built_in">equal_range</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>返回的结果并不是所期望的两个1。因为equal_range的实现(lower_bound:第一个不小于参数值的元素(基于比较函数的小于), upper_bound:第一个大于参数值的元素)是基于等价的，而这两个1基于less_equal是不等价的，所以返回值中比不存在1。</p>
<p>事实上，上面的代码在执行时会产生错误。VC9编译器Debug环境会在第3行出错，Release环境会在之后用到ret的地方发生难以预测的错误。</p>
<h2 id="第二十二条：-切勿直接修改set或multiset的键"><a href="#第二十二条：-切勿直接修改set或multiset的键" class="headerlink" title="第二十二条： 切勿直接修改set或multiset的键　　"></a>第二十二条： 切勿直接修改set或multiset的键　　</h2><p>set、multiset、map、multimap都会按照一定的顺序存储其中的元素，但如果修改了其中用于排序的键值，则将会破坏容器的有序性。</p>
<p>对于map和multimap而言，其存储元素的类型为<code>pair&lt;const key, value&gt;</code>，修改map中的key值将不能通过编译(除非使用const_cast)。对于set和multiset，其存储的键值并不是const的，在修改其中元素的时候，要小心不要修改到键值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string title;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">compare</span>:</span><br><span class="line">    <span class="keyword">public</span> binary_function&lt;Employee&amp;, Employee&amp;, <span class="type">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Employee&amp; lhs,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> Employee&amp; rhs)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.id &lt; rhs.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;Employee,compare&gt; s;</span><br><span class="line"></span><br><span class="line">Employee e1,e2;</span><br><span class="line"></span><br><span class="line">e1.id = <span class="number">2</span>;</span><br><span class="line">e1.title = <span class="string">&quot;QA&quot;</span>;</span><br><span class="line"></span><br><span class="line">e2.id = <span class="number">1</span>;</span><br><span class="line">e2.title = <span class="string">&quot;Developer&quot;</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">insert</span>(e1);</span><br><span class="line">s.<span class="built_in">insert</span>(e2);</span><br><span class="line"></span><br><span class="line">set&lt;Employee,compare&gt;::iterator i = s.<span class="built_in">begin</span>();</span><br><span class="line">i-&gt;title = <span class="string">&quot;Manager&quot;</span>; <span class="comment">//OK to update non-key value</span></span><br><span class="line">i-&gt;id = <span class="number">3</span>; <span class="comment">// 破坏了有序性</span></span><br></pre></td></tr></table></figure><br>　　<br>有些STL的实现将<code>set&lt;T&gt;::iterator</code>的<code>operator*</code>返回一个<code>const T&amp;</code>，用来保护容器中的值不被修改，在这种情况下，如果希望修改非键值，必须通过const_case。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set&lt;Employee,compare&gt;::iterator i = s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="built_in">const_cast</span>&lt;Employee&amp;&gt;(*i).title = <span class="string">&quot;Manager&quot;</span>; <span class="comment">//OK</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;Employee*&gt;(&amp;*i).title = <span class="string">&quot;Arch&quot;</span>; <span class="comment">//OK</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;Employee&gt;(*i).title = <span class="string">&quot;Director&quot;</span>; <span class="comment">// Bad 仅仅就修改了临时变量的值 set中的值没有发生改变</span></span><br></pre></td></tr></table></figure><br>对于map和multimap而言，尽量不要修改键值，即使是通过const_cast的方式，因为STL的实现可能将键值放在只读的内存区域当中。</p>
<p>相对安全(而低效)的方式来修改关联容器中的元素</p>
<ul>
<li>找到希望修改的元素。</li>
<li>将要被修改的元素做一份拷贝。(注意拷贝的Map的key值不要声明为const)</li>
<li>修改拷贝的值。</li>
<li>从容器中删除元素。(erase 见第九条)</li>
<li>插入拷贝的那个元素。如果位置不变或邻近，可以使用hint方式的insert从而将插入的效率从对数时间提高到常数时间。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">set&lt;Employee,compare&gt; s;</span><br><span class="line"></span><br><span class="line">Employee e1,e2;</span><br><span class="line"></span><br><span class="line">e1.id = <span class="number">2</span>;</span><br><span class="line">e1.title = <span class="string">&quot;QA&quot;</span>;</span><br><span class="line"></span><br><span class="line">e2.id = <span class="number">1</span>;</span><br><span class="line">e2.title = <span class="string">&quot;Developer&quot;</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">insert</span>(e1);</span><br><span class="line">s.<span class="built_in">insert</span>(e2);</span><br><span class="line"></span><br><span class="line">set&lt;Employee,compare&gt;::iterator i = s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="function">Employee <span class="title">e</span><span class="params">(*i)</span></span>;</span><br><span class="line">e.title = <span class="string">&quot;Manager&quot;</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">erase</span>(i++);</span><br><span class="line">s.<span class="built_in">insert</span>(i,e);</span><br></pre></td></tr></table></figure>
<h2 id="第二十三条：-考虑使用排序的vector替代关联容器"><a href="#第二十三条：-考虑使用排序的vector替代关联容器" class="headerlink" title="第二十三条： 考虑使用排序的vector替代关联容器　　"></a>第二十三条： 考虑使用排序的vector替代关联容器　　</h2><p>哈希容器大部分情况下可以提供常数时间的查找效率，标准容器也可以达到对数时间的查找效率。</p>
<p>标准容器通常基于平衡二叉树实现， 这种实现对于插入、删除和查找的混合操作提供了优化。但是对于3步式的操作(首先进行插入操作，再进行查找操作，再修改元素或删除元素)，排序的vector能够提供更好的性能。因为相对于vector，关联容器需要更大的存储空间。在排序的vector中存储数据比在关联容器中存储数据消耗更少的内存，考虑到页面错误的因素，通过二分搜索进行查找，排序的vector效率更高一些。</p>
<p>如果使用排序的vector替换map，需要实现一个自定义的排序类型，该排序类型依照键值进行排序。</p>
<h2 id="第二十四条：-当效率至关重要时，请在map-operator-和map-insert之间谨慎作出选择"><a href="#第二十四条：-当效率至关重要时，请在map-operator-和map-insert之间谨慎作出选择" class="headerlink" title="第二十四条： 当效率至关重要时，请在map:operator[]和map:insert之间谨慎作出选择　"></a>第二十四条： 当效率至关重要时，请在map:operator[]和map:insert之间谨慎作出选择　</h2><p>从效率方面的考虑，当向map中添加元素时，应该使用insert，当需要修改一个元素的值的时候，需要使用<code>operator[]</code><br>如果使用operator[]添加元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>,Widget&gt; m;</span><br><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line">m[<span class="number">0</span>] = w；</span><br><span class="line"><span class="comment">//Widget构造函数被调用两次 </span></span><br></pre></td></tr></table></figure>
<p>对于第8行，如果m[0]没有对应的值，则会通过默认的构造函数生成一个widget对象，然后再用operator=将w的值赋给这个widget对象。 使用insert可以避免创建这个中间对象。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,Widget&gt; m;</span><br><span class="line">Widget w; </span><br><span class="line"></span><br><span class="line">m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>,Widget&gt;::<span class="built_in">value_type</span>(<span class="number">0</span>,w));  <span class="comment">//没有调用构造函数</span></span><br></pre></td></tr></table></figure><br>如果使用insert修改元素的值（当然，不会有人这样做）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,Widget&gt; m;</span><br><span class="line"><span class="function">Widget <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>; </span><br><span class="line">m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>,Widget&gt;::<span class="built_in">value_type</span>(<span class="number">0</span>,w)); </span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>,Widget&gt;::<span class="built_in">value_type</span>(<span class="number">0</span>,w2)).first-&gt;second = w2;  <span class="comment">//构造了一个pair对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面这段代码比较晦涩</span></span><br><span class="line"><span class="comment">// map::insert(const value_type&amp; x)的返回值为pair&lt;iterator,bool&gt; </span></span><br><span class="line"><span class="comment">// 当insert的值已经存在时，iterator指向这个已经存在的值，bool值为false。</span></span><br><span class="line"><span class="comment">// 反之，指向新插入的值，bool值为true。</span></span><br></pre></td></tr></table></figure>
<p>使用operator[]则轻便且高效的多</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,Widget&gt; m;</span><br><span class="line"><span class="function">Widget <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>; </span><br><span class="line">m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>,Widget&gt;::<span class="built_in">value_type</span>(<span class="number">0</span>,w));</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">m[<span class="number">0</span>] = w2;</span><br></pre></td></tr></table></figure>
<p>　<br>一个通用的添加和修改map中元素的方法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> MapType,</span></span><br><span class="line"><span class="function">         <span class="keyword">typename</span> KeyType,</span></span><br><span class="line"><span class="function">         <span class="keyword">typename</span> ValueType&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> MapType::iterator <span class="title">InsertOrUpdate</span><span class="params">(MapType&amp; map,<span class="type">const</span> KeyType&amp; k, <span class="type">const</span> ValueType&amp; v)</span> <span class="comment">// 注意typename的用法 从属类型前一定要使用typename</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> MapType::iterator i = map.<span class="built_in">lower_bound</span>(k); <span class="comment">// 如果i！=map.end()，则i-&gt;first不小于k</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i!=map.<span class="built_in">end</span>() &amp;&amp; !map.<span class="built_in">key_comp</span>()(k,i-&gt;first)) <span class="comment">// k不小于i-&gt;first 等价！</span></span><br><span class="line">    &#123;</span><br><span class="line">        i-&gt;second = v;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> map.<span class="built_in">insert</span>(i,<span class="built_in">pair</span>&lt;<span class="type">const</span> KeyType, ValueType&gt;(k,v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>,Widget&gt; m;</span><br><span class="line"><span class="function">Widget <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>,Widget&gt;::iterator i  = InsertOrUpdate&lt;map&lt;<span class="type">int</span>,Widget&gt;,<span class="type">int</span>,Widget&gt;(m,<span class="number">0</span>,w);</span><br></pre></td></tr></table></figure></p>
<h2 id="第二十五条：-熟悉非标准的哈希容器"><a href="#第二十五条：-熟悉非标准的哈希容器" class="headerlink" title="第二十五条： 熟悉非标准的哈希容器"></a>第二十五条： 熟悉非标准的哈希容器</h2><p>常见的hash容器的实现有SGI和Dinkumware，SGI的hashset的声明类似于<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">         <span class="keyword">typename</span> HashFunction = hash&lt;T&gt;,</span><br><span class="line">         <span class="keyword">typename</span> CompareFunction = equal_to&lt;T&gt;,</span><br><span class="line">         <span class="keyword">typename</span> Allocator = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> hashSet;</span><br></pre></td></tr></table></figure></p>
<p>Dinkumware的hash_set声明<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">         <span class="keyword">typename</span> CompareFunction&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hash_compare</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">         <span class="keyword">typename</span> HashingInfo = hash_compare&lt;T,less&lt;T&gt;&gt;,</span><br><span class="line">         <span class="keyword">typename</span> Allocator = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> hash_set;</span><br></pre></td></tr></table></figure></p>
<p>SGI使用传统的开放式哈希策略，由指向元素的单向链表的指针数组(桶)构成。Dinkumware同样使用开放式哈希策略，由指向元素的双向链表的迭代器数组(桶)组成。从内存的角度上讲，SGI的设计要节省一些。</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="第二十六条：-iterator优先于const-iterator-reverse-iterator以及const-reverse-iterator"><a href="#第二十六条：-iterator优先于const-iterator-reverse-iterator以及const-reverse-iterator" class="headerlink" title="第二十六条： iterator优先于const_iterator, reverse_iterator以及const_reverse_iterator"></a>第二十六条： iterator优先于const_iterator, reverse_iterator以及const_reverse_iterator</h2><p>对于容器类<code>container&lt;T&gt;</code>而言，</p>
<ul>
<li><code>iterator</code>的功效相当与<code>T*</code></li>
<li><code>const_iterator</code>的功效相当于 <code>const T*</code></li>
<li><code>reverse_iterator</code>与<code>const_reverse_iterator</code>与前两者类似，只是按照反向遍历</li>
</ul>
<p>它们之间相互转换的关系如图<br><img src="/img/1598599694.jpg" alt=""></p>
<p>从iterator到const_iterator和reverse_iterator存在隐式转换，从reverse_iterator到const_iterator也存在隐式转换。</p>
<p>通过base()可以将reverse_iterator转换为iterator，同样可以将const_reversse_iterator转换为const_iterator，但是转换后的结果并不指向同一元素(有一个偏移量)</p>
<h2 id="第二十七条：-使用distance和advance将容器的const-iterator转换成iterator"><a href="#第二十七条：-使用distance和advance将容器的const-iterator转换成iterator" class="headerlink" title="第二十七条： 使用distance和advance将容器的const_iterator转换成iterator"></a>第二十七条： 使用distance和advance将容器的const_iterator转换成iterator</h2><p>对于大多数的容器，const_cast并不能将const_iterator转换为iterator。即使在某些编译器上可以将vector和string的const_iterator转换为iterator，但存在移植性的问题</p>
<p>通过distance和advance将const_iterator转换为iterator的方法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Widget&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;Widget&gt;::const_iterator ConstIter;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;Widget&gt;::iterator Iter;</span><br><span class="line"></span><br><span class="line">ConstIter ci; </span><br><span class="line"></span><br><span class="line">... <span class="comment">//使ci指向v中的元素</span></span><br><span class="line">Iter i = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="built_in">advance</span>(i,<span class="built_in">distance</span>&lt;ConstIter&gt;(i,ci));</span><br></pre></td></tr></table></figure>
　　</p>
<h2 id="第二十八条：-正确理解由reverse-iterator的base-成员函数所产生的iterator的用法"><a href="#第二十八条：-正确理解由reverse-iterator的base-成员函数所产生的iterator的用法" class="headerlink" title="第二十八条： 正确理解由reverse_iterator的base()成员函数所产生的iterator的用法"></a>第二十八条： 正确理解由reverse_iterator的base()成员函数所产生的iterator的用法</h2><p>使用<code>reverse_iterator</code>的<code>base()</code>成员函数所产生的<code>iterator</code>和原来的<code>reverse_iterator</code>之间有一个元素的偏移量。<br><img src="/img/201108201329543528.png" alt=""></p>
<p>容器的插入、删除和修改操作都是基于iterator的，所以对于reverse_iterator，必须通过base()成员函数转换为iterator之后才能进行增删改的操作。</p>
<ul>
<li>对于插入操作而言，新插入的元素都在3和4之间，所以可以直接使用insert(ri.base(),xxx)</li>
<li>对于修改和删除操作，由于ri和ri.base()并不指向同一元素，所以在修改和删除前，必须修正偏移量</li>
</ul>
<p>修正ri和ri.base()偏移量的做法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set&lt;Widget&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> set&lt;Widget&gt;::reverse_iterator RIter;</span><br><span class="line"></span><br><span class="line">RIter ri;</span><br><span class="line"></span><br><span class="line">... <span class="comment">//使ri指向v中的元素 </span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">erase</span>(--ri.<span class="built_in">base</span>()); <span class="comment">//直接修改函数返回的指针不能被直接修改。 如果iterator是基于指针实现的，代码将不具有可以执行。</span></span><br><span class="line">s.<span class="built_in">erase</span>((++ri).<span class="built_in">base</span>()); <span class="comment">//具备可移植性的代码</span></span><br></pre></td></tr></table></figure></p>
<h2 id="第二十九条：-对于逐个字符的输入请考虑使用istreambuf-iterator"><a href="#第二十九条：-对于逐个字符的输入请考虑使用istreambuf-iterator" class="headerlink" title="第二十九条： 对于逐个字符的输入请考虑使用istreambuf_iterator"></a>第二十九条： 对于逐个字符的输入请考虑使用istreambuf_iterator</h2><p>常用的istream_iterator内部使用的<code>operator&gt;&gt;</code>实际上执行了格式化的输入，每一次的<code>operator&gt;&gt;</code>操作都有很多的附加操作</p>
<ul>
<li>一个内部sentry对象的构造和析构(设置和清理行为的对象)</li>
<li>检查可能影响行为的流标志(比如skipws)</li>
<li>检查可能发生的读取错误</li>
<li>出现错误时检查流的异常屏蔽标志以决定是否抛出异常</li>
</ul>
<p>对于<code>istreambuf_iterator</code>，它直接从流的缓冲区中读取下一个字符，不存在任何的格式化，所以效率相对<code>istream_iterator</code>要高得多。对于非格式化的输出，也可以考虑使用<code>ostreambuf_iterator</code>代替<code>ostream_iterator</code>。（损失了格式化输出的灵活性）</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="第三十条：-确保目标区间足够大"><a href="#第三十条：-确保目标区间足够大" class="headerlink" title="第三十条： 确保目标区间足够大"></a>第三十条： 确保目标区间足够大</h2><p>下面例子中,希望将一个容器中的内容添加到另一个容器的尾部<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">transformogrify</span><span class="params">(<span class="type">int</span> x)</span></span>; <span class="comment">//将x值做一些处理，返回一个新的值</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; results;</span><br><span class="line"></span><br><span class="line">... <span class="comment">//初始化values</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">transform</span>(values.<span class="built_in">begin</span>(),values.<span class="built_in">end</span>(),results.<span class="built_in">end</span>(),transformogrify);</span><br></pre></td></tr></table></figure><br>由于results.end()返回的迭代器指向一段未初始化的内存，上面的代码在运行时会导致无效对象的赋值操作。</p>
<p>可以通过back_inserter或者front_inserter来实现在头尾插入另一个容器中的元素。因为front_inserter的实现是基于push_front操作(vector和string不支持push_front)，所以通过front_inserter插入的元素与他们在原来容器中的顺序正好相反，这个时候可以使用reverse_iterator。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">transformogrify</span><span class="params">(<span class="type">int</span> x)</span></span>; <span class="comment">//将x值做一些处理，返回一个新的值</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; results;</span><br><span class="line"></span><br><span class="line">... <span class="comment">//初始化values</span></span><br><span class="line"><span class="built_in">transform</span>(values.<span class="built_in">begin</span>(),values.<span class="built_in">end</span>(),<span class="built_in">back_inserter</span>(results),transformogrify);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">transformogrify</span><span class="params">(<span class="type">int</span> x)</span></span>; <span class="comment">//将x值做一些处理，返回一个新的值</span></span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; results;</span><br><span class="line"></span><br><span class="line">... <span class="comment">//初始化values</span></span><br><span class="line"><span class="built_in">transform</span>(values.<span class="built_in">rbegin</span>(),values.<span class="built_in">rend</span>(),<span class="built_in">front_inserter</span>(results),transformogrify);</span><br></pre></td></tr></table></figure>
<p>另外可以使用inserter在results的任意位置插入元素<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">transformogrify</span><span class="params">(<span class="type">int</span> x)</span></span>; <span class="comment">//将x值做一些处理，返回一个新的值</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; results;</span><br><span class="line"></span><br><span class="line">... <span class="comment">//初始化values</span></span><br><span class="line"><span class="built_in">transform</span>(values.<span class="built_in">begin</span>(),values.<span class="built_in">end</span>(),<span class="built_in">inserter</span>(results,results.<span class="built_in">begin</span>()+results.<span class="built_in">size</span>()/<span class="number">2</span>),transformogrify); <span class="comment">//插入中间　</span></span><br></pre></td></tr></table></figure><br>书中提到“但是，如果该算法执行的是插入操作，则第五条中建议的方案(使用区间成员函数)并不适用”，不知是翻译的问题还是理解不到位，为什么插入操作不能用区间成员函数替换？ 在我看来是因为区间成员函数并不支持自定义的函数对象，而这又跟插入操作有什么关系呢？莫非删除可以？？？</p>
<p>如果插入操作的目标容器是vector或string，可以通过reserve操作来避免不必要的容器内存重新分配。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">transformogrify</span><span class="params">(<span class="type">int</span> x)</span></span>; <span class="comment">//将x值做一些处理，返回一个新的值</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; results;</span><br><span class="line"></span><br><span class="line"><span class="comment">//... //初始化values</span></span><br><span class="line">results.<span class="built_in">reserve</span>(values.<span class="built_in">size</span>()+results.<span class="built_in">size</span>()); <span class="comment">//预留results和values的空间</span></span><br><span class="line"><span class="built_in">transform</span>(values.<span class="built_in">begin</span>(),values.<span class="built_in">end</span>(),<span class="built_in">back_inserter</span>(results),transformogrify);</span><br></pre></td></tr></table></figure></p>
<p>如果操作的结果不是插入而是替换目标容器中的元素，可以采用下面的两种方式<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">transformogrify</span><span class="params">(<span class="type">int</span> x)</span></span>; <span class="comment">//将x值做一些处理，返回一个新的值</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; results;</span><br><span class="line"></span><br><span class="line"><span class="comment">//... //初始化values</span></span><br><span class="line"></span><br><span class="line">results.<span class="built_in">resize</span>(values.<span class="built_in">size</span>()); <span class="comment">//想想对于results.size() &gt; values.size() 和results.size() &lt; values.size()两种情况</span></span><br><span class="line"><span class="built_in">transform</span>(values.<span class="built_in">begin</span>(),values.<span class="built_in">end</span>(),results.<span class="built_in">begin</span>(),transformogrify);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">transformogrify</span><span class="params">(<span class="type">int</span> x)</span></span>; <span class="comment">//将x值做一些处理，返回一个新的值</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; results;</span><br><span class="line"></span><br><span class="line"><span class="comment">//... //初始化values</span></span><br><span class="line"></span><br><span class="line">results.<span class="built_in">clear</span>(); <span class="comment">//results.size()为，results.capacity()不变</span></span><br><span class="line">results.<span class="built_in">reserve</span>(values.<span class="built_in">size</span>()); <span class="comment">//相对于上一种方式，如果values.size()小于原来的results.size(),那么会空余出一些元素的内存。</span></span><br><span class="line"><span class="built_in">transform</span>(values.<span class="built_in">begin</span>(),values.<span class="built_in">end</span>(),results.<span class="built_in">begin</span>(),transformogrify);</span><br></pre></td></tr></table></figure></p>
<h2 id="第三十一条：-了解各种与排序有关的选择"><a href="#第三十一条：-了解各种与排序有关的选择" class="headerlink" title="第三十一条： 了解各种与排序有关的选择"></a>第三十一条： 了解各种与排序有关的选择</h2><p>对vector、string、deque或数组中的元素执行一次完全排序，可以使用sort或stable_sort</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">values.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">values.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">values.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">values.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">values.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">sort</span>(values.<span class="built_in">begin</span>(),values.<span class="built_in">end</span>()); <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>
<p>对vector、string、deque或数组中的元素选出前n个进行并对这n个元素进行排序，可以使用<code>partial_sort</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">partial_sort</span>(values.<span class="built_in">begin</span>(),values.<span class="built_in">begin</span>()+<span class="number">2</span>,values.<span class="built_in">end</span>()); <span class="comment">// 1,2,4,5,3 注意第二个参数是一个开区间</span></span><br></pre></td></tr></table></figure></p>
<p>对vector、string、deque或数组中的元素，要求找到按顺序排在第n个位置上的元素，或者找到排名前n的数据，但并不需要对这n个数据进行排序，这时可以使用<code>nth_element</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nth_element</span>(values.<span class="built_in">begin</span>(),values.<span class="built_in">begin</span>()+<span class="number">1</span>,values.<span class="built_in">end</span>()); <span class="comment">// 1,2,3,4,5 注意第二个参数是一个闭区间</span></span><br></pre></td></tr></table></figure><br>这个返回的结果跟我期望的有些差距，期望的返回值应该是1，2，4，5，3。VC10编译器</p>
<p>对于标准序列容器(这回包含了list),如果要将其中元素按照是否满足某种特定的条件区分开来，可以使用partition或stable_partition<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator firstIteratorNotLessThan3 = <span class="built_in">partition</span>(values.<span class="built_in">begin</span>(),values.<span class="built_in">end</span>(),lessThan3); <span class="comment">//返回值为 2,1,4,5,3</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator firstIteratorNotLessThan3 = <span class="built_in">stable_partition</span>(values.<span class="built_in">begin</span>(),values.<span class="built_in">end</span>(),lessThan3); <span class="comment">//返回值为 1,2,4,5,3</span></span><br></pre></td></tr></table></figure><br>对于list而言，它的成员函数sort保证了可以stable的对list中元素进行排序。对于nth_element和partition操作，有三种替代方案：</p>
<ul>
<li>将list中的元素拷贝到提供随机访问迭代器的容器中，然后执行相应的算法</li>
<li>创建一个list::iterator的容器，在对容器执行相应的算法</li>
<li>利用一个包含迭代器的有序容器的信息，反复调用splice成员函数，将list中的成员调整到相应的位置。</li>
</ul>
<h2 id="第三十二条：-如果确实要删除元素，请确保在remove这一类算法以后调用erase"><a href="#第三十二条：-如果确实要删除元素，请确保在remove这一类算法以后调用erase" class="headerlink" title="第三十二条： 如果确实要删除元素，请确保在remove这一类算法以后调用erase"></a>第三十二条： 如果确实要删除元素，请确保在remove这一类算法以后调用erase</h2><p>remove算法接受两个迭代器作为参数，这两个迭代器指定了需要进行操作的区间。Remove并不知道它所操作的容器，所以并不能真正的将容器中的元素删除掉。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    values.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">values[<span class="number">3</span>] = values[<span class="number">5</span>] = values[<span class="number">9</span>] = <span class="number">99</span>;</span><br><span class="line"><span class="built_in">remove</span>(values.<span class="built_in">begin</span>(),values.<span class="built_in">end</span>(),<span class="number">99</span>); <span class="comment">// 0,1,2,4,6,7,8,7,8,99</span></span><br></pre></td></tr></table></figure></p>
<p>从上面的代码可见，remove并没有删除所有值为99的元素，只不过是用后面元素的值覆盖了需要被remove的元素的值，并一一填补空下来的元素的空间，对于最后三个元素，并没有其他的元素去覆盖他们的值，所以仍然保留原值。<br><img src="/img/1598600168.jpg" alt=""></p>
<p>上图可以看出，remove只不过是用后面的值填补了空缺的值，但并没有将容器中的元素删除，所以在remove之后，要调用erase将不需要的元素删除掉。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values.<span class="built_in">erase</span>(<span class="built_in">remove</span>(values.<span class="built_in">begin</span>(),values.<span class="built_in">end</span>(),<span class="number">99</span>),values.<span class="built_in">end</span>()); <span class="comment">// 0,1,2,4,6,7,8</span></span><br></pre></td></tr></table></figure><br>类似于remove的算法还有remove_if和unique, 这些算法都没有真正的删除元素，习惯用法是将它们作为容器erase成员函数的第一个参数。List是容器中的一个例外，它有remove和unique成员函数，而且可以从容器中直接删除不需要的元素。</p>
<h2 id="第三十三条：-对于包含指针的容器使用remove这一类算法时要特别小心"><a href="#第三十三条：-对于包含指针的容器使用remove这一类算法时要特别小心" class="headerlink" title="第三十三条： 对于包含指针的容器使用remove这一类算法时要特别小心"></a>第三十三条： 对于包含指针的容器使用remove这一类算法时要特别小心</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isCertified</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Widget*&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Widget</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="built_in">not1</span>(<span class="built_in">mem_fun</span>(&amp;Widget::isCertified))),v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>上面的代码可能会造成内存泄漏<br><img src="/img/20110912122959468.gif" alt=""></p>
<p>避免内存泄漏的方式有两种，第一种是先将需要被删除的元素的指针删除并设置为空，然后再删除容器中的空指针。第二种方式更为简单而且直观，就是使用智能指针。</p>
<p>方案1<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">delAndNullifyUncertified</span><span class="params">(Widget*&amp; pWidget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pWidget-&gt;<span class="built_in">isCertified</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pWidget;</span><br><span class="line">        pWidget = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;Widget*&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Widget</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),delAndNullifyUncertified);</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">erase</span>(<span class="built_in">remove</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="built_in">static_cast</span>&lt;Widget*&gt;(<span class="number">0</span>)),v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></p>
<p>方案2<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RCSP</span>&#123;...&#125;; <span class="comment">// Reference counting smart pointer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> RSCP&lt;Widget&gt; RSCPW;</span><br><span class="line"></span><br><span class="line">vector&lt;RSCPW&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">RSCPW</span>(<span class="keyword">new</span> <span class="built_in">Widget</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="built_in">not1</span>(<span class="built_in">mem_fun</span>(&amp;Widget::isCertified))),v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></p>
<h2 id="第三十四条：-了解哪些算法要求使用排序的区间作为参数"><a href="#第三十四条：-了解哪些算法要求使用排序的区间作为参数" class="headerlink" title="第三十四条： 了解哪些算法要求使用排序的区间作为参数"></a>第三十四条： 了解哪些算法要求使用排序的区间作为参数</h2><ul>
<li>用于查找的算法<code>binary_search</code>, <code>lower_bound</code>, <code>upper_bound</code>和<code>equal_range</code>采用二分法查找数据，所以数据必须是事先排好序的。对于随机访问迭代器，这些算法可以保证对数时间的查找效率，对于双向迭代器，需要线性时间</li>
<li><code>set_union</code>, <code>set_intersection</code>, <code>set_difference</code>和<code>set_symmetric_difference</code>提供了线性时间的集合操作。排序的元素是线性效率的前提。</li>
<li>merge和inplace_merge实现了合并和排序的联合操作。读入两个排序的区间，合并成一个新的排序区间。具有线性时间的性能。</li>
<li>includes,判断一个区间中的元素是否都在另一个区间之中。具有线性的时间性能。</li>
<li>unique和unique_copy不一定需要排序的区间，但一般来说只有针对排序的区间才能删除所有的重复数据，否则只是保留相邻的重复数据中的第一个。</li>
</ul>
<p>针对一个区间的进行多次算法的操作，要保证这些算法的排序方式是一致的。(比如都是升序或都是降序)</p>
<h2 id="第三十五条：-通过mismatch和lexicographical-compare实现简单的忽略大小写的字符串比较"><a href="#第三十五条：-通过mismatch和lexicographical-compare实现简单的忽略大小写的字符串比较" class="headerlink" title="第三十五条： 通过mismatch和lexicographical_compare实现简单的忽略大小写的字符串比较"></a>第三十五条： 通过mismatch和lexicographical_compare实现简单的忽略大小写的字符串比较</h2><p>Mismatch的作用在于找出两个区间中第一个对应值不同的位置。 要实现忽略大小写的字符串比较，可以先找到两个字符串中第一个不同的字符，然后通过比较这两个字符的大小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ciStringCompareImpl</span><span class="params">(<span class="type">const</span> string&amp; s1, <span class="type">const</span> string&amp; s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;string::const_iterator, string::const_iterator&gt; PSCI; <span class="comment">//pair of string::const_iterator</span></span><br><span class="line"></span><br><span class="line">    PSCI p = <span class="built_in">mismatch</span>(s1.<span class="built_in">begin</span>(),s1.<span class="built_in">end</span>(),s2.<span class="built_in">begin</span>(),<span class="built_in">not2</span>(<span class="built_in">ptr_fun</span>(ciCharCompare)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p.first == s1.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.second == s2.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ciCharCompare</span>(*p.first,*p.second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Lexicograghical_compare是strcmp的一个泛化的版本，strcmp只能与字符数组一起工作，而lexicograghical_compare可以与任何类型的值区间一起工作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">charLess</span><span class="params">(<span class="type">char</span> c1, <span class="type">char</span> c2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ciStringCompair</span><span class="params">(<span class="type">const</span> string&amp; s1, <span class="type">const</span> string&amp; s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lexicographical_compare</span>(s1.<span class="built_in">begin</span>(),s1.<span class="built_in">end</span>(),s2.<span class="built_in">begin</span>(),s2.<span class="built_in">end</span>(),charLess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第三十六条：-理解copy-if算法的正确实现"><a href="#第三十六条：-理解copy-if算法的正确实现" class="headerlink" title="第三十六条： 理解copy_if算法的正确实现"></a>第三十六条： 理解copy_if算法的正确实现</h2><p>标准的STL中并不存在copy_if算法，正确的copy_if算法的实现如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator,</span></span><br><span class="line"><span class="function">              <span class="keyword">typename</span> OutputIterator,</span></span><br><span class="line"><span class="function">              <span class="keyword">typename</span> Predicate&gt;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">copy_if</span><span class="params">(InputIterator begin,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     InputIterator end,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     OutputIterator destBegin,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     Predicate p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(begin != end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">p</span>(*begin))</span><br><span class="line">        &#123;</span><br><span class="line">            *destBegin++ = *begin;</span><br><span class="line">            ++begin;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> destBegin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第三十七条：-使用accumulate或者for-each进行区间统计"><a href="#第三十七条：-使用accumulate或者for-each进行区间统计" class="headerlink" title="第三十七条： 使用accumulate或者for_each进行区间统计"></a>第三十七条： 使用accumulate或者for_each进行区间统计</h2><p>accumulate有两种形式，第一种接受两个迭代器和一个初始值，返回结果是初始值与两个迭代器区间的元素的总和。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br></pre></td></tr></table></figure><br>第二种方式加了一个统计函数，使得accumulate函数变得更加通用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="built_in">static_cast</span>&lt;string::size_type&gt;(<span class="number">0</span>), StringLegthSum);</span><br></pre></td></tr></table></figure></p>
<p>accumulate的一个限制是不能产生任何的副作用，这时，for_each就是一个很好的补充。For_each接受三个参数，两个迭代器确定的一个区间，以及统计函数。For_each的返回值是一个函数对象，必须通过调用函数对象中的方法才能够取得统计的值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> _x, <span class="type">double</span> _y):<span class="built_in">x</span>(_x),<span class="built_in">y</span>(_y)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PointAverge</span> : <span class="keyword">public</span> unary_function&lt;Point,<span class="type">void</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PointAverage</span>(): <span class="built_in">sum_x</span>(<span class="number">0.0</span>), <span class="built_in">sum_y</span>(<span class="number">0.0</span>),<span class="built_in">sum</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Point&amp; p)</span> <span class="comment">//可以产生副作用</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sum++;</span><br><span class="line">        sum_x += p.x;</span><br><span class="line">        sum_y += p.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Point <span class="title">GetResult</span><span class="params">()</span> <span class="comment">//用于返回统计结果</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(sum_x/sum, sum_y/sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> sum_x, sum_y;</span><br><span class="line">    nt sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;Point&gt; v;</span><br><span class="line">...</span><br><span class="line">Point result = for_each(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="built_in">PointAverage</span>()).<span class="built_in">GetResult</span>();</span><br></pre></td></tr></table></figure></p>
<h1 id="函数子、函数子类、函数及其他"><a href="#函数子、函数子类、函数及其他" class="headerlink" title="函数子、函数子类、函数及其他"></a>函数子、函数子类、函数及其他</h1><h2 id="第三十八条-遵循按值传递的原则来设计函数子类"><a href="#第三十八条-遵循按值传递的原则来设计函数子类" class="headerlink" title="第三十八条 遵循按值传递的原则来设计函数子类"></a>第三十八条 遵循按值传递的原则来设计函数子类</h2><p>c和C++中 以函数指针为参数的例子，函数指针是按值传递的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">void</span>* base, <span class="type">size_t</span> nmemb, <span class="type">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span>(*cmpfcn)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span></span>;</span><br></pre></td></tr></table></figure><br>STL函数对象是对函数指针的抽象形式，在STL中函数对象在函数中的传递也是按值传递的。for_each算法的返回值就是一个函数对象，它的第三个参数也是函数对象。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>,</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Function</span>&gt;</span><br><span class="line">Function <span class="comment">//按值返回</span></span><br><span class="line">for_each(InputIterator first, InputIterator second, Function f); <span class="comment">//按值传递</span></span><br></pre></td></tr></table></figure></p>
<p>因为STL函数对象按值传递的特性，所以在设计函数对象时要：</p>
<ul>
<li>将函数对象要尽可能的小，以减少拷贝的开销。</li>
<li>函数对象尽量是单态的(不要使用虚函数)，以避免剥离问题。</li>
</ul>
<p>对于复杂的设计而言，具有包含很多信息的和含有继承关系的函数对象也可能难以避免，这时可以采用Bridge Pattern来实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">functorImp</span> :</span><br><span class="line"><span class="keyword">public</span> unary_function&lt;T,<span class="type">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    Widget w;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">functorImp</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> T&amp; val)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">functor</span>&lt;T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">functor</span> :</span><br><span class="line"><span class="keyword">public</span> unary_function&lt;T,<span class="type">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    functorImp&lt;T&gt; *pImp; <span class="comment">//唯一的一个数据成员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> T&amp; val)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pImp-&gt;<span class="built_in">operator</span>()(val); <span class="comment">//调用重载的operator</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>函数对象本身只包含一个指针，而且是不含虚函数的单态对象。真正的数据和操作都是由指针所指向的对象完成的。对于这个实现，要注意的是在函数对象拷贝的过程中，如何维护这个指针成员。既能避免内存泄漏而且可以保证指针有效性的智能指针是个不错的选择。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;functorImp&lt;T&gt; *&gt; pImp;</span><br></pre></td></tr></table></figure></p>
<h2 id="第三十九条-确保判别式是纯函数"><a href="#第三十九条-确保判别式是纯函数" class="headerlink" title="第三十九条 确保判别式是纯函数"></a>第三十九条 确保判别式是纯函数</h2><p>判别式的一些基本概念：</p>
<ul>
<li>判别式 - 返回值为bool类型或者可以隐式转换为bool类型的函数</li>
<li>纯函数 - 返回值仅与函数的参数相关的函数</li>
<li>判别式类 – operator()函数是判别式的函数子类。 STL中凡是能接受判别式的地方，就可以接受一个判别式类的对象。 </li>
</ul>
<p>对于判别式不是纯函数的一个反例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Remove3rdElement</span> </span><br><span class="line">: <span class="keyword">public</span> unary_function&lt;<span class="type">int</span>,<span class="type">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Remove3rdElement</span>():<span class="built_in">i</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++i == <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; myvector;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">myvector.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">myvector.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">myvector.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">myvector.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">myvector.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">myvector.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">myvector.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">myvector.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="built_in">Remove3rdElement</span>()),myvector.<span class="built_in">end</span>()); <span class="comment">// 1，2，4，5，7 remove_if之后的结果为 1，2，4，5，7，6，7。 返回值指向的是第六个元素。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="第四十条-如果一个类是函数子，应该使它可配接"><a href="#第四十条-如果一个类是函数子，应该使它可配接" class="headerlink" title="第四十条 如果一个类是函数子，应该使它可配接"></a>第四十条 如果一个类是函数子，应该使它可配接</h2><p>STL中四个标准的函数配接器(not1, not2, bind1st, bind2nd)要求其使用的函数对象包含一些特殊的类型定义，包含这些类型定义的函数对象称作是可配接的函数对象。下面的代码无法通过编译：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isWanted</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; myvector</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="built_in">not1</span>(isWanted)); <span class="comment">// error C2955: &#x27;std::unary_function&#x27; : use of class template requires template argument list</span></span><br></pre></td></tr></table></figure>
<p>从上面的错误可以看出，这个isWanted函数指针不能被not1使用，因为缺少了一些模板参数列表。ptr_fun的作用就在于给予这个函数指针所需要的类型定义从而使之可配接。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="built_in">not1</span>(<span class="built_in">ptr_fun</span>(isWanted)));</span><br></pre></td></tr></table></figure><br>这些特殊的类型定义包括: <code>argument_type``first_argument_type``second_argument_type``result_type</code>，提供这些类型定义最简单的方式是是函数对象的类从特定的模板继承。</p>
<p>如果函数子类的operator方法只有一个实参，那么应该从unary_function继承；如果有两个实参，应该从binary_function继承。对于unary_function和binary_function，必须指定参数类型和返回值类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">functor</span> : <span class="keyword">public</span> unary_function&lt;<span class="type">int</span>, <span class="type">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">functor2</span> : <span class="keyword">public</span> binary_function&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>, <span class="type">bool</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于operator方法的参数:</p>
<ul>
<li>operator的参数如果是非指针类型的，传递给unary_function和binary_function的参数需要去掉const和引用&amp;符号</li>
<li>operator的参数如果是指针类型的，传递给unary_function和binary_function的参数要与operator的参数完全一致。</li>
</ul>
<h2 id="第四十一条-理解ptr-fun、mem-fun和mem-fun-reference的来由"><a href="#第四十一条-理解ptr-fun、mem-fun和mem-fun-reference的来由" class="headerlink" title="第四十一条 理解ptr_fun、mem_fun和mem_fun_reference的来由"></a>第四十一条 理解ptr_fun、mem_fun和mem_fun_reference的来由</h2><p>对于ptr_fun在第40条已经有了一些介绍，它可以用在任何的函数指针上来使其可配接。下面的例子，希望在myvector和myvector2的每一个元素上调用元素的成员函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">vector&lt;Widget&gt; myvector;</span><br><span class="line">vector&lt;Widget*&gt; myvector2;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">for_each(myvector.<span class="built_in">begin</span>(),myvector.<span class="built_in">end</span>(), &amp;Widget::test); <span class="comment">// 编译错误</span></span><br><span class="line">for_each(myvector2.<span class="built_in">begin</span>(),myvector2.<span class="built_in">end</span>(), &amp;Widget::test); <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>
<p>而for_each的实现可能是这样的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Function&gt;</span></span><br><span class="line"><span class="function">Function <span class="title">for_each</span><span class="params">(InputIterator begin, InputIterator end, Function f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (begin != end)</span><br><span class="line">        <span class="built_in">f</span>(*begin++);</span><br><span class="line">&#125;　</span><br></pre></td></tr></table></figure></p>
<p>对于mem_fun和mem_fun_reference, 就是要使成员方法可以作为合法的函数指针传递<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for_each(myvector.<span class="built_in">begin</span>(),myvector.<span class="built_in">end</span>(), <span class="built_in">mem_fun_ref</span>(&amp;Widget::test)); <span class="comment">// 当容器中的元素为对象时使用mem_fun_ref</span></span><br><span class="line">for_each(myvector2.<span class="built_in">begin</span>(),myvector2.<span class="built_in">end</span>(), <span class="built_in">mem_fun</span>(&amp;Widget::test)); <span class="comment">// 当容器中的元素为指针时，使用mem_fun</span></span><br></pre></td></tr></table></figure><br>那么mem_fun是如何实现的呢？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">mem_fun_t</span>&lt;R,C&gt;</span></span><br><span class="line"><span class="function"><span class="title">mem_fun</span><span class="params">(R(C::*pmf)())</span></span>;</span><br></pre></td></tr></table></figure><br>mem_fun接受一个返回值为R且不带参数的C类型的成员函数，并返回一个mem_fun_t类型的对象。mem_fun_t是一个函数子类，拥有成员函数的指针，并提供了operator()接口。operator中调用了通过参数传递进来的对象上的成员函数。</p>
<h2 id="第四十二条-确保less与operator-lt-具有相同的语义"><a href="#第四十二条-确保less与operator-lt-具有相同的语义" class="headerlink" title="第四十二条 确保less与operator&lt;具有相同的语义"></a>第四十二条 确保less<T>与operator&lt;具有相同的语义</h2><p>STL规定，less总是等价于operator&lt;, operator&lt;是less的默认实现。</p>
<p>应当尽量避免修改less的行为，而且要确保它与operator&lt;具有相同的意义。如果希望以一种特殊的方式来排序对象，那么就去创建一个新的函数子类，它的名字不能是less.</p>
<h1 id="在程序中使用STL"><a href="#在程序中使用STL" class="headerlink" title="在程序中使用STL"></a>在程序中使用STL</h1><h2 id="第四十三条：算法调用优先于手写的循环"><a href="#第四十三条：算法调用优先于手写的循环" class="headerlink" title="第四十三条：算法调用优先于手写的循环"></a>第四十三条：算法调用优先于手写的循环</h2><p>算法往往作用于一对迭代器所指定的区间中的每一个元素上，所以算法的内部实现是基于循环的。虽然说类似于find和find_if的算法可能不会遍历所有的元素就返回了结果，但是在极端情况下，还是需要遍历全部的元素。</p>
<h2 id="第四十四条：容器的成员函数优于同名的算法"><a href="#第四十四条：容器的成员函数优于同名的算法" class="headerlink" title="第四十四条：容器的成员函数优于同名的算法"></a>第四十四条：容器的成员函数优于同名的算法</h2><ul>
<li>成员函数速度优于同名算法</li>
<li>成员函数与容器的联系更加紧密</li>
</ul>
<p>对于关联容器请看下面的例子:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator i1 = s.<span class="built_in">find</span>(<span class="number">727</span>);</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator i2 = <span class="built_in">find</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="number">727</span>);</span><br></pre></td></tr></table></figure><br>对于set而言，它的find成员函数的时间复杂度是log(n)，而算法find的时间复杂度是线性的n。明显，成员函数的效率要远高于算法。另外，算法是基于相等性而关联容器基于等价性，在这种情况下，调用成员函数和调用算法可能会得到不同的结果。(参见第19条)对于map以及multimap，成员函数之针基于key进行操作，而算法基于key-value pair进行操作。对于list而言，成员函数相对于算法的优势更加明显。算法是基于元素的拷贝的，而list成员函数可能只需要修改指针的指向。还有之前所提到的list的remove成员函数，同时起到了remove和erase的作用。</p>
<p>有些算法，例如sort并不能应用在list上，因为sort是基于随机访问迭代器的。还有merge算法，它要求不能修改源区间，而merge成员函数总是在修改源链表的元素的指针指向。</p>
<h2 id="第四十五条：正确区分count、find、binary-search、lower-bound、upper-bound和equal-range"><a href="#第四十五条：正确区分count、find、binary-search、lower-bound、upper-bound和equal-range" class="headerlink" title="第四十五条：正确区分count、find、binary_search、lower_bound、upper_bound和equal_range"></a>第四十五条：正确区分count、find、binary_search、lower_bound、upper_bound和equal_range</h2><ul>
<li>count: 区间内是否存在某个特定的值，如果存在的话，这个值有多少个拷贝。</li>
<li>find:  区间内时候存在某个特定的值，如果存在的话，第一个符合条件的值在哪里。</li>
<li>binary_search：一个排序的区间内是否存在一个特定的值。</li>
<li>lower_bound：返回一个迭代器，或者指向第一个满足条件的元素，或者指向适合于该值插入的位置。切记lower_bound是基于等价性的，用相等性来比较lower_bound的返回值和目标元素是存在潜在风险的。</li>
<li>upper_bound：返回一个迭代器，指向最后一个满足条件元素的后面一个元素。</li>
<li>equal_range：返回一对迭代器，第一个指向lower_bound的返回值，第二个指向upper_bound的返回值。如果两个返回值指向同一位置，则说明没有符合条件的元素。Lower_bound与upper_bound的distance可以求得符合条件的元素的个数。</li>
</ul>
<p>下表总结了在什么情况下使用什么样的算法或成员函数<br><img src="/img/1598600816.jpg" alt=""></p>
<p>对于multi容器来说，find并不能保证找出的元素是第一个具有此值的元素。如果希望找到第一个元素，必须通过lower_bound，然后在通过等价性的验证。Equal_range是另外一种方式，而且可以避免等价性测试，只是equal_range的开销要大于lower_bound。</p>
<h2 id="第四十六条：考虑使用函数对象而不是函数作为STL算法的参数"><a href="#第四十六条：考虑使用函数对象而不是函数作为STL算法的参数" class="headerlink" title="第四十六条：考虑使用函数对象而不是函数作为STL算法的参数"></a>第四十六条：考虑使用函数对象而不是函数作为STL算法的参数</h2><p>函数对象优于函数的第一个原因在于函数对象的operator方法可以被优化为内联函数，从而使的函数调用的开销在编译器被消化。而编译器并没有将函数指针的间接调用在编译器进行优化，也就是说，函数作为STL算法的参数相对于函数对象而言，具有函数调用的开销。</p>
<p>第二个理由是某些编译器对于函数作为STL的参数支持的并不好。</p>
<p>第三个理由是有助于避免一些微妙的、语言本身的缺陷。比如说实例化一个函数模板，可能会与其他已经预定义的函数产生冲突。</p>
<h2 id="第四十七条：避免产生“直写型”-write-only-的代码"><a href="#第四十七条：避免产生“直写型”-write-only-的代码" class="headerlink" title="第四十七条：避免产生“直写型”(write-only)的代码"></a>第四十七条：避免产生“直写型”(write-only)的代码</h2><p>根据以往的经验，代码被阅读的次数要远远多于被编写的次数，所以要有意识的写出具备可读性的代码。对于STL而言，则是尽量避免“直写型”的代码。</p>
<p>直写型的代码是这样的，对于程序的编写者而言，它显得非常的直接，并且每一步都符合当初设计的逻辑。但是对于程序的阅读者来说，在没有全面了解程序编写者动机的前提下，这样的代码往往让人一头雾水。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(<span class="built_in">find_if</span>(v.<span class="built_in">rbegin</span>(),v.<span class="built_in">rend</span>(),<span class="built_in">bind2nd</span>(<span class="built_in">greater_equaql</span>&lt;<span class="type">int</span>&gt;(),y)).<span class="built_in">base</span>()),v.<span class="built_in">end</span>(),<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(),x));</span><br></pre></td></tr></table></figure><br>比较易读的写法最好是这样的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化range_begin，使它指向v中大于等于y的最后一个元素之后的那个元素</span></span><br><span class="line"><span class="comment">// 如果不存在这样的元素，则rangeBegin被初始化为v.begin()</span></span><br><span class="line"><span class="comment">// 如果这个元素恰好是v的最后一个元素，则range_begin将被初始化为v.end()</span></span><br><span class="line">VecIt rangeBegin = <span class="built_in">find_if</span>(v.<span class="built_in">rbegin</span>(),v.<span class="built_in">rend</span>(),<span class="built_in">bind2nd</span>(<span class="built_in">greater_equal</span>&lt;<span class="type">int</span>&gt;(),y)).<span class="built_in">base</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从rangeBegin到v.end()的区间中，删除所有小于x的值</span></span><br><span class="line">v.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(rangeBegin,v.<span class="built_in">end</span>(),<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(),x)),v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></p>
<h2 id="第四十八条-总是include正确的头文件"><a href="#第四十八条-总是include正确的头文件" class="headerlink" title="第四十八条 总是include正确的头文件"></a>第四十八条 总是include正确的头文件</h2><p>与STL头文件相关的一些总结</p>
<ul>
<li>几乎所有的STL容器都被声明在与之同名的头文件之中</li>
<li>除了<code>accumulate</code>、<code>inner_product</code>、<code>adjacent_difference</code>和<code>partial_sum</code>被声明在<code>&lt;numeric&gt;</code>中之外，其他都所有算法都声明在<code>&lt;algorithm&gt;</code>中</li>
<li>特殊类型的迭代器，例如<code>isteam_iterator</code>和<code>istreambuf_iterator</code>，都被声明在<code>&lt;iterator&gt;</code>中</li>
<li>标准的函数子，比如<code>less&lt;T&gt;</code>，和函数子配接器，比如not1、bind2nd都被声明在<code>&lt;functional&gt;</code>中。</li>
</ul>
<h2 id="第四十九条-学会分析与STL相关的编译器诊断信息"><a href="#第四十九条-学会分析与STL相关的编译器诊断信息" class="headerlink" title="第四十九条 学会分析与STL相关的编译器诊断信息"></a>第四十九条 学会分析与STL相关的编译器诊断信息</h2><p>STL的编译错误信息往往冗长而且难以阅读，通过文本替换将复杂的容器名称替换为简单的代号，可以使得错误信息得到简化。</p>
<p>例如，将<code>std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&gt;</code>替换为可读性更强的string。</p>
<p>下面列举一些常见的STL错误，以及可能的出错原因</p>
<ul>
<li>Vector和string的迭代器通常就是指针，当错误的使用iterator的时候，编译器的错误信息中可能会包含指针类型的错误。</li>
<li>如果诊断信息提到了back_insert_iterator, front_insert_iterator和insert_iterator，则几乎意味着程序中直接或间接地调用了back_inserter, front_inserter或者是inserter。</li>
<li>输出迭代器以及inserter函数返回的迭代器在赋值操作符内部完成输入或者插入操作，如果有赋值操作符有关的错误信息，可以关注这些迭代器。</li>
<li>如果错误信息来自于算法的内部实现，往往意味着传递给算法的对象使用了错误的类型。</li>
<li>如果在使用一个常见的STL组件，但编译器却不认知，可能是没有包含合适的头文件。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/08/28/effective_modern_cpp%E7%AC%94%E8%AE%B0/" rel="next" title="Effective modern C++ 笔记">
                <i class="fa fa-chevron-left"></i> Effective modern C++ 笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/09/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E7%AC%94%E8%AE%B0/" rel="prev" title="程序员的自我修养笔记">
                程序员的自我修养笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">130</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%AE%B9%E5%99%A8"><span class="nav-number">1.</span> <span class="nav-text">第一章 容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%9D%A1%EF%BC%9A-%E6%85%8E%E9%87%8D%E9%80%89%E6%8B%A9%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">第一条： 慎重选择容器类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%9D%A1%EF%BC%9A-%E4%B8%8D%E8%A6%81%E7%BC%96%E5%86%99%E8%AF%95%E5%9B%BE%E7%8B%AC%E7%AB%8B%E4%BA%8E%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">1.2.</span> <span class="nav-text">第二条： 不要编写试图独立于容器的代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%9D%A1%EF%BC%9A-%E7%A1%AE%E4%BF%9D%E5%AE%B9%E5%99%A8%E5%86%85%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%AD%A3%E7%A1%AE%E8%80%8C%E9%AB%98%E6%95%88"><span class="nav-number">1.3.</span> <span class="nav-text">第三条： 确保容器内对象的拷贝正确而高效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E6%9D%A1%EF%BC%9A-%E8%B0%83%E7%94%A8empty-%E8%80%8C%E4%B8%8D%E6%98%AF%E6%A3%80%E6%9F%A5size-%E6%98%AF%E5%90%A6%E4%B8%BA0"><span class="nav-number">1.4.</span> <span class="nav-text">第四条： 调用empty()而不是检查size()是否为0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E6%9D%A1%EF%BC%9A-%E5%8C%BA%E9%97%B4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BC%98%E5%85%88%E4%BA%8E%E4%B8%8E%E4%B9%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8D%95%E5%85%83%E7%B4%A0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.</span> <span class="nav-text">第五条： 区间成员函数优先于与之对应的单元素成员函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E6%9D%A1%EF%BC%9A%E5%BD%93%E5%BF%83C-%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%80%E7%83%A6%E4%BA%BA%E7%9A%84%E5%88%86%E6%9E%90%E6%9C%BA%E5%88%B6"><span class="nav-number">1.6.</span> <span class="nav-text">第六条：当心C++编译器最烦人的分析机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E6%9D%A1%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BA%86%E9%80%9A%E8%BF%87new%E6%93%8D%E4%BD%9C%E5%88%9B%E5%BB%BA%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%8C%E5%88%87%E8%AE%B0%E5%9C%A8%E5%AE%B9%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%9E%90%E6%9E%84%E5%89%8D%E5%B0%86%E6%8C%87%E9%92%88delete%E6%8E%89"><span class="nav-number">1.7.</span> <span class="nav-text">第七条：如果容器中包含了通过new操作创建的指针，切记在容器对象析构前将指针delete掉</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E6%9D%A1%EF%BC%9A%E5%88%87%E5%8B%BF%E5%88%9B%E5%BB%BA%E5%8C%85%E5%90%ABauto-ptr%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">1.8.</span> <span class="nav-text">第八条：切勿创建包含auto_ptr对象的容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E6%9D%A1%EF%BC%9A%E6%85%8E%E9%87%8D%E9%80%89%E6%8B%A9%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.</span> <span class="nav-text">第九条：慎重选择删除元素的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E6%9D%A1%EF%BC%9A%E4%BA%86%E8%A7%A3%E5%88%86%E9%85%8D%E5%AD%90%E7%9A%84%E7%BA%A6%E5%AE%9A%E5%92%8C%E9%99%90%E5%88%B6"><span class="nav-number">1.10.</span> <span class="nav-text">第十条：了解分配子的约定和限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E6%9D%A1%EF%BC%9A%E7%90%86%E8%A7%A3%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E9%85%8D%E5%AD%90%E7%9A%84%E5%90%88%E7%90%86%E7%94%A8%E6%B3%95"><span class="nav-number">1.11.</span> <span class="nav-text">第十一条：理解自定义分配子的合理用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E6%9D%A1%EF%BC%9A%E5%88%87%E5%8B%BF%E5%AF%B9STL%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E6%9C%89%E4%B8%8D%E5%88%87%E5%AE%9E%E9%99%85%E7%9A%84%E4%BE%9D%E8%B5%96"><span class="nav-number">1.12.</span> <span class="nav-text">第十二条：切勿对STL容器的线程安全性有不切实际的依赖</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vector%E5%92%8Cstring"><span class="nav-number">2.</span> <span class="nav-text">vector和string</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E6%9D%A1%EF%BC%9A-vector%E5%92%8Cstring%E4%BC%98%E5%85%88%E4%BA%8E%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-number">2.1.</span> <span class="nav-text">第十三条： vector和string优先于动态分配的数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E6%9D%A1%EF%BC%9A-%E4%BD%BF%E7%94%A8reserve%E6%9D%A5%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">2.2.</span> <span class="nav-text">第十四条： 使用reserve来避免不必要的内存分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E6%9D%A1%EF%BC%9A-string%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%A4%9A%E6%A0%B7%E6%80%A7"><span class="nav-number">2.3.</span> <span class="nav-text">第十五条： string实现的多样性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AD%E6%9D%A1%EF%BC%9A-%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E6%8A%8Avector%E5%92%8Cstring%E6%95%B0%E6%8D%AE%E4%BC%A0%E7%BB%99%E6%97%A7%E7%9A%84API"><span class="nav-number">2.4.</span> <span class="nav-text">第十六条： 了解如何把vector和string数据传给旧的API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%83%E6%9D%A1%EF%BC%9A-%E4%BD%BF%E7%94%A8swap%E5%8E%BB%E9%99%A4%E5%A4%9A%E4%BD%99%E5%AE%B9%E9%87%8F"><span class="nav-number">2.5.</span> <span class="nav-text">第十七条： 使用swap去除多余容量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AB%E6%9D%A1%EF%BC%9A-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8vector"><span class="nav-number">2.6.</span> <span class="nav-text">第十八条： 避免使用vector</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">关联容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B9%9D%E6%9D%A1%EF%BC%9A-%E7%90%86%E8%A7%A3%E7%9B%B8%E7%AD%89-equality-%E5%92%8C%E7%AD%89%E4%BB%B7-equivalence-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.</span> <span class="nav-text">第十九条： 理解相等(equality)和等价(equivalence)的区别　　</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E6%9D%A1%EF%BC%9A-%E4%B8%BA%E5%8C%85%E5%90%AB%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%8C%87%E5%AE%9A%E6%AF%94%E8%BE%83%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.</span> <span class="nav-text">第二十条： 为包含指针的关联容器指定比较类型　　</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E6%9D%A1%EF%BC%9A-%E5%88%87%E5%8B%BF%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9set%E6%88%96multiset%E7%9A%84%E9%94%AE"><span class="nav-number">3.3.</span> <span class="nav-text">第二十二条： 切勿直接修改set或multiset的键　　</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E6%9D%A1%EF%BC%9A-%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E6%8E%92%E5%BA%8F%E7%9A%84vector%E6%9B%BF%E4%BB%A3%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="nav-number">3.4.</span> <span class="nav-text">第二十三条： 考虑使用排序的vector替代关联容器　　</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E6%9D%A1%EF%BC%9A-%E5%BD%93%E6%95%88%E7%8E%87%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81%E6%97%B6%EF%BC%8C%E8%AF%B7%E5%9C%A8map-operator-%E5%92%8Cmap-insert%E4%B9%8B%E9%97%B4%E8%B0%A8%E6%85%8E%E4%BD%9C%E5%87%BA%E9%80%89%E6%8B%A9"><span class="nav-number">3.5.</span> <span class="nav-text">第二十四条： 当效率至关重要时，请在map:operator[]和map:insert之间谨慎作出选择　</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E6%9D%A1%EF%BC%9A-%E7%86%9F%E6%82%89%E9%9D%9E%E6%A0%87%E5%87%86%E7%9A%84%E5%93%88%E5%B8%8C%E5%AE%B9%E5%99%A8"><span class="nav-number">3.6.</span> <span class="nav-text">第二十五条： 熟悉非标准的哈希容器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AD%E6%9D%A1%EF%BC%9A-iterator%E4%BC%98%E5%85%88%E4%BA%8Econst-iterator-reverse-iterator%E4%BB%A5%E5%8F%8Aconst-reverse-iterator"><span class="nav-number">4.1.</span> <span class="nav-text">第二十六条： iterator优先于const_iterator, reverse_iterator以及const_reverse_iterator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E6%9D%A1%EF%BC%9A-%E4%BD%BF%E7%94%A8distance%E5%92%8Cadvance%E5%B0%86%E5%AE%B9%E5%99%A8%E7%9A%84const-iterator%E8%BD%AC%E6%8D%A2%E6%88%90iterator"><span class="nav-number">4.2.</span> <span class="nav-text">第二十七条： 使用distance和advance将容器的const_iterator转换成iterator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E6%9D%A1%EF%BC%9A-%E6%AD%A3%E7%A1%AE%E7%90%86%E8%A7%A3%E7%94%B1reverse-iterator%E7%9A%84base-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%89%80%E4%BA%A7%E7%94%9F%E7%9A%84iterator%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">第二十八条： 正确理解由reverse_iterator的base()成员函数所产生的iterator的用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B9%9D%E6%9D%A1%EF%BC%9A-%E5%AF%B9%E4%BA%8E%E9%80%90%E4%B8%AA%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E8%AF%B7%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8istreambuf-iterator"><span class="nav-number">4.4.</span> <span class="nav-text">第二十九条： 对于逐个字符的输入请考虑使用istreambuf_iterator</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E5%8D%81%E6%9D%A1%EF%BC%9A-%E7%A1%AE%E4%BF%9D%E7%9B%AE%E6%A0%87%E5%8C%BA%E9%97%B4%E8%B6%B3%E5%A4%9F%E5%A4%A7"><span class="nav-number">5.1.</span> <span class="nav-text">第三十条： 确保目标区间足够大</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%80%E6%9D%A1%EF%BC%9A-%E4%BA%86%E8%A7%A3%E5%90%84%E7%A7%8D%E4%B8%8E%E6%8E%92%E5%BA%8F%E6%9C%89%E5%85%B3%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">5.2.</span> <span class="nav-text">第三十一条： 了解各种与排序有关的选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%8C%E6%9D%A1%EF%BC%9A-%E5%A6%82%E6%9E%9C%E7%A1%AE%E5%AE%9E%E8%A6%81%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%8C%E8%AF%B7%E7%A1%AE%E4%BF%9D%E5%9C%A8remove%E8%BF%99%E4%B8%80%E7%B1%BB%E7%AE%97%E6%B3%95%E4%BB%A5%E5%90%8E%E8%B0%83%E7%94%A8erase"><span class="nav-number">5.3.</span> <span class="nav-text">第三十二条： 如果确实要删除元素，请确保在remove这一类算法以后调用erase</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%89%E6%9D%A1%EF%BC%9A-%E5%AF%B9%E4%BA%8E%E5%8C%85%E5%90%AB%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8remove%E8%BF%99%E4%B8%80%E7%B1%BB%E7%AE%97%E6%B3%95%E6%97%B6%E8%A6%81%E7%89%B9%E5%88%AB%E5%B0%8F%E5%BF%83"><span class="nav-number">5.4.</span> <span class="nav-text">第三十三条： 对于包含指针的容器使用remove这一类算法时要特别小心</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E5%8D%81%E5%9B%9B%E6%9D%A1%EF%BC%9A-%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E7%AE%97%E6%B3%95%E8%A6%81%E6%B1%82%E4%BD%BF%E7%94%A8%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8C%BA%E9%97%B4%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="nav-number">5.5.</span> <span class="nav-text">第三十四条： 了解哪些算法要求使用排序的区间作为参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E6%9D%A1%EF%BC%9A-%E9%80%9A%E8%BF%87mismatch%E5%92%8Clexicographical-compare%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%BF%BD%E7%95%A5%E5%A4%A7%E5%B0%8F%E5%86%99%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="nav-number">5.6.</span> <span class="nav-text">第三十五条： 通过mismatch和lexicographical_compare实现简单的忽略大小写的字符串比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AD%E6%9D%A1%EF%BC%9A-%E7%90%86%E8%A7%A3copy-if%E7%AE%97%E6%B3%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.7.</span> <span class="nav-text">第三十六条： 理解copy_if算法的正确实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E6%9D%A1%EF%BC%9A-%E4%BD%BF%E7%94%A8accumulate%E6%88%96%E8%80%85for-each%E8%BF%9B%E8%A1%8C%E5%8C%BA%E9%97%B4%E7%BB%9F%E8%AE%A1"><span class="nav-number">5.8.</span> <span class="nav-text">第三十七条： 使用accumulate或者for_each进行区间统计</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AD%90%E3%80%81%E5%87%BD%E6%95%B0%E5%AD%90%E7%B1%BB%E3%80%81%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E4%BB%96"><span class="nav-number">6.</span> <span class="nav-text">函数子、函数子类、函数及其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AB%E6%9D%A1-%E9%81%B5%E5%BE%AA%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E7%9A%84%E5%8E%9F%E5%88%99%E6%9D%A5%E8%AE%BE%E8%AE%A1%E5%87%BD%E6%95%B0%E5%AD%90%E7%B1%BB"><span class="nav-number">6.1.</span> <span class="nav-text">第三十八条 遵循按值传递的原则来设计函数子类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B9%9D%E6%9D%A1-%E7%A1%AE%E4%BF%9D%E5%88%A4%E5%88%AB%E5%BC%8F%E6%98%AF%E7%BA%AF%E5%87%BD%E6%95%B0"><span class="nav-number">6.2.</span> <span class="nav-text">第三十九条 确保判别式是纯函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E5%8D%81%E6%9D%A1-%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E5%87%BD%E6%95%B0%E5%AD%90%EF%BC%8C%E5%BA%94%E8%AF%A5%E4%BD%BF%E5%AE%83%E5%8F%AF%E9%85%8D%E6%8E%A5"><span class="nav-number">6.3.</span> <span class="nav-text">第四十条 如果一个类是函数子，应该使它可配接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%80%E6%9D%A1-%E7%90%86%E8%A7%A3ptr-fun%E3%80%81mem-fun%E5%92%8Cmem-fun-reference%E7%9A%84%E6%9D%A5%E7%94%B1"><span class="nav-number">6.4.</span> <span class="nav-text">第四十一条 理解ptr_fun、mem_fun和mem_fun_reference的来由</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E6%9D%A1-%E7%A1%AE%E4%BF%9Dless%E4%B8%8Eoperator-lt-%E5%85%B7%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E8%AF%AD%E4%B9%89"><span class="nav-number">6.5.</span> <span class="nav-text">第四十二条 确保less与operator&lt;具有相同的语义</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8STL"><span class="nav-number">7.</span> <span class="nav-text">在程序中使用STL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E6%9D%A1%EF%BC%9A%E7%AE%97%E6%B3%95%E8%B0%83%E7%94%A8%E4%BC%98%E5%85%88%E4%BA%8E%E6%89%8B%E5%86%99%E7%9A%84%E5%BE%AA%E7%8E%AF"><span class="nav-number">7.1.</span> <span class="nav-text">第四十三条：算法调用优先于手写的循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B%E6%9D%A1%EF%BC%9A%E5%AE%B9%E5%99%A8%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BC%98%E4%BA%8E%E5%90%8C%E5%90%8D%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text">第四十四条：容器的成员函数优于同名的算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%94%E6%9D%A1%EF%BC%9A%E6%AD%A3%E7%A1%AE%E5%8C%BA%E5%88%86count%E3%80%81find%E3%80%81binary-search%E3%80%81lower-bound%E3%80%81upper-bound%E5%92%8Cequal-range"><span class="nav-number">7.3.</span> <span class="nav-text">第四十五条：正确区分count、find、binary_search、lower_bound、upper_bound和equal_range</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AD%E6%9D%A1%EF%BC%9A%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E8%80%8C%E4%B8%8D%E6%98%AF%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BASTL%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">7.4.</span> <span class="nav-text">第四十六条：考虑使用函数对象而不是函数作为STL算法的参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E6%9D%A1%EF%BC%9A%E9%81%BF%E5%85%8D%E4%BA%A7%E7%94%9F%E2%80%9C%E7%9B%B4%E5%86%99%E5%9E%8B%E2%80%9D-write-only-%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">7.5.</span> <span class="nav-text">第四十七条：避免产生“直写型”(write-only)的代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AB%E6%9D%A1-%E6%80%BB%E6%98%AFinclude%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">7.6.</span> <span class="nav-text">第四十八条 总是include正确的头文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E6%9D%A1-%E5%AD%A6%E4%BC%9A%E5%88%86%E6%9E%90%E4%B8%8ESTL%E7%9B%B8%E5%85%B3%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%8A%E6%96%AD%E4%BF%A1%E6%81%AF"><span class="nav-number">7.7.</span> <span class="nav-text">第四十九条 学会分析与STL相关的编译器诊断信息</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
